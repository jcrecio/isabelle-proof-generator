{"file_name": "/home/qj213/afp-2021-10-22/thys/ADS_Functor/ADS_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ADS_Functor", "problem_names": ["lemma blinding_of_discrete_hash:\n  \"blinding_of_discrete \\<le> vimage2p hash_discrete hash_discrete (=)\"", "lemma blinding_of_on_discrete [locale_witness]:\n  \"blinding_of_on UNIV hash_discrete blinding_of_discrete\"", "lemma merge_on_discrete [locale_witness]:\n  \"merge_on UNIV hash_discrete blinding_of_discrete merge_discrete\"", "lemma merkle_discrete [locale_witness]:\n  \"merkle_interface hash_discrete blinding_of_discrete merge_discrete\"", "lemma blinding_of_unit_hash:\n  \"blinding_of_unit \\<le> vimage2p hash_unit hash_unit (=)\"", "lemma blinding_of_on_unit:\n  \"blinding_of_on UNIV hash_unit blinding_of_unit\"", "lemma merge_on_unit:\n  \"merge_on UNIV hash_unit blinding_of_unit merge_unit\"", "lemma merkle_interface_unit:\n  \"merkle_interface hash_unit blinding_of_unit merge_unit\"", "lemma hash_blindable_simps [simp]:\n  \"hash_blindable h (Unblinded x) = Content (h x)\"\n  \"hash_blindable h (Blinded y) = y\"", "lemma hash_map_blindable_simp:\n  \"hash_blindable f (map_blindable\\<^sub>m f' id x) = hash_blindable (f o f') x\"", "lemma blinding_of_blindable_mono:\n  assumes \"bo \\<le> bo'\"\n  shows \"blinding_of_blindable h bo \\<le> blinding_of_blindable h bo'\"", "lemma blinding_of_blindable_hash:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_blindable h bo \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)\"", "lemma blinding_of_on_blindable [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h) (blinding_of_blindable h bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_blindable [locale_witness] = blinding_of_on_blindable[of UNIV, simplified]", "lemma merge_on_blindable [locale_witness]:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h) (blinding_of_blindable h bo) merge_blindable\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_blindable [locale_witness] = \n  merge_on_blindable[of UNIV, simplified]", "lemma merge_blindable_alt_def:\n  \"merge_blindable h m x y = (case (x, y) of\n    (Unblinded x, Unblinded y) \\<Rightarrow> map_option Unblinded (m x y)\n  | (Blinded x, Unblinded y) \\<Rightarrow> (if Content (h y) = x then Some (Unblinded y) else None)\n  | (Unblinded y, Blinded x) \\<Rightarrow> (if Content (h y) = x then Some (Unblinded y) else None)\n  | (Blinded t, Blinded u) \\<Rightarrow> (if t = u then Some (Blinded u) else None))\"", "lemma merge_blindable_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_blindable\\<^sub>m x; b \\<in> set1_blindable\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_blindable h m x y = merge_blindable h m' x y\"", "lemma merkle_blindable [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_blindable h) (blinding_of_blindable h bo) (merge_blindable h m)\"", "lemma merge_on_nr_blindable:\n  \"merge_on UNIV hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable\"", "lemma merkle_nr_blindable:\n  \"merkle_interface hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable\"", "lemmas blinding_of_sum_mono = sum.rel_mono", "lemma blinding_of_sum_hash:\n  assumes \"boa \\<le> vimage2p rha rha (=)\" \"bob \\<le> vimage2p rhb rhb (=)\"\n  shows \"blinding_of_sum boa bob \\<le> vimage2p (hash_sum rha rhb) (hash_sum rha rhb) (=)\"", "lemma blinding_of_on_sum [locale_witness]:\n  assumes \"blinding_of_on A rha boa\" \"blinding_of_on B rhb bob\"\n  shows \"blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B} (hash_sum rha rhb) (blinding_of_sum boa bob)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_sum [locale_witness] = blinding_of_on_sum[of UNIV _ _ UNIV, simplified]", "lemma merge_on_sum [locale_witness]:\n  assumes \"merge_on A rha boa ma\" \"merge_on B rhb bob mb\"\n  shows \"merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B} (hash_sum rha rhb) (blinding_of_sum boa bob) merge_sum\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_sum [locale_witness] = merge_on_sum[where A=UNIV and B=UNIV, simplified]", "lemma merge_sum_alt_def:\n  \"merge_sum x y = (case (x, y) of\n    (Inl x, Inl y) \\<Rightarrow> map_option Inl (ma x y)\n  | (Inr x, Inr y) \\<Rightarrow> map_option Inr (mb x y)\n  | _ \\<Rightarrow> None)\"", "lemma merge_sum_cong[fundef_cong]:\n  \"\\<lbrakk> x = x'; y = y'; \n    \\<And>xl yl. \\<lbrakk> x = Inl xl; y = Inl yl \\<rbrakk> \\<Longrightarrow> ma xl yl = ma' xl yl;\n    \\<And>xr yr. \\<lbrakk> x = Inr xr; y = Inr yr \\<rbrakk> \\<Longrightarrow> mb xr yr = mb' xr yr \\<rbrakk> \\<Longrightarrow>\n    merge_sum ma mb x y = merge_sum ma' mb' x' y'\"", "lemma merkle_sum [locale_witness]:\n  assumes \"merkle_interface rha boa ma\" \"merkle_interface rhb bob mb\"\n  shows \"merkle_interface (hash_sum rha rhb) (blinding_of_sum boa bob) (merge_sum ma mb)\"", "lemmas blinding_of_prod_mono = prod.rel_mono", "lemma blinding_of_prod_hash:\n  assumes \"boa \\<le> vimage2p rha rha (=)\" \"bob \\<le> vimage2p rhb rhb (=)\"\n  shows \"blinding_of_prod boa bob \\<le> vimage2p (hash_prod rha rhb) (hash_prod rha rhb) (=)\"", "lemma blinding_of_on_prod [locale_witness]:\n  assumes \"blinding_of_on A rha boa\" \"blinding_of_on B rhb bob\"\n  shows \"blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B} (hash_prod rha rhb) (blinding_of_prod boa bob)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_prod [locale_witness] = blinding_of_on_prod[where A=UNIV and B=UNIV, simplified]", "lemma merge_on_prod [locale_witness]:\n  assumes \"merge_on A rha boa ma\" \"merge_on B rhb bob mb\"\n  shows \"merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B} (hash_prod rha rhb) (blinding_of_prod boa bob) merge_prod\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_prod [locale_witness] = merge_on_prod[where A=UNIV and B=UNIV, simplified]", "lemma merge_prod_alt_def:\n  \"merge_prod = (\\<lambda>(x, y) (x', y'). Option.bind (ma x x') (\\<lambda>x''. map_option (Pair x'') (mb y y')))\"", "lemma merge_prod_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> fsts p1; b \\<in> fsts p2 \\<rbrakk> \\<Longrightarrow> ma a b = ma' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> snds p1; b \\<in> snds p2 \\<rbrakk> \\<Longrightarrow> mb a b = mb' a b\" \n  shows \"merge_prod ma mb p1 p2 = merge_prod ma' mb' p1 p2\"", "lemma merkle_product [locale_witness]:\n  assumes \"merkle_interface rha boa ma\" \"merkle_interface rhb bob mb\"\n  shows \"merkle_interface (hash_prod rha rhb) (blinding_of_prod boa bob) (merge_prod ma mb)\"", "lemma list_R1_const_into_dest: \"list_R1 F = l \\<longleftrightarrow> F = unR l\"", "lemma list_R1_induct[case_names list_R1]:\n  assumes \"\\<And>F. \\<lbrakk> \\<And>l'. l' \\<in> set_rec_F\\<^sub>m F  \\<Longrightarrow> P l' \\<rbrakk> \\<Longrightarrow> P (list_R1 F)\"\n  shows \"P l\"", "lemma set_list_R1_eq: \n  \"{x. set_base_F\\<^sub>m x \\<subseteq> A \\<and> set_rec_F\\<^sub>m x \\<subseteq> B} =\n   {x. setl x \\<subseteq> UNIV \\<and> setr x \\<subseteq> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}}\"", "lemma list_R1_to_list_simps [simp]:\n  \"list_R1_to_list (list_R1 (Inl ())) = []\"\n  \"list_R1_to_list (list_R1 (Inr (x, xs))) = x # list_R1_to_list xs\"", "lemma R1_of_list: \"list_R1_to_list (list_to_list_R1 x) = x\"", "lemma list_of_R1: \"list_to_list_R1 (list_R1_to_list x) = x\"", "lemma list_R1_def: \"type_definition list_to_list_R1 list_R1_to_list UNIV\"", "lemma map_list_R1_list_to_list_R1: \"map_list_R1 f (list_to_list_R1 xs) = list_to_list_R1 (map f xs)\"", "lemma list_R1_map_trans [transfer_rule]: includes lifting_syntax shows\n  \"(((=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=)) map_list_R1 map\"", "lemma set_list_R1_list_to_list_R1: \"set_list_R1 (list_to_list_R1 xs) = set xs\"", "lemma list_R1_set_trans [transfer_rule]: includes lifting_syntax shows\n  \"(pcr_list (=) ===> (=)) set_list_R1 set\"", "lemma rel_list_R1_list_to_list_R1:\n   \"rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys) \\<longleftrightarrow> list_all2 R xs ys\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma list_R1_rel_trans[transfer_rule]: includes lifting_syntax shows\n  \"(((=) ===> (=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=) ===> (=)) rel_list_R1 list_all2\"", "lemma blinding_of_hash_R1:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_R1 bo \\<le> vimage2p (hash_R1 h) (hash_R1 h) (=)\"", "lemma blinding_of_on_R1 [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set_list_R1 x \\<subseteq> A} (hash_R1 h) (blinding_of_R1 bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_R1 [locale_witness] = blinding_of_on_R1[where A=UNIV, simplified]", "lemma merge_F_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set_base_F\\<^sub>m x; b \\<in> set_base_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> set_rec_F\\<^sub>m x; b \\<in> set_rec_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> mL a b = mL' a b\"\n  shows \"merge_F m mL x y = merge_F m' mL' x y\"", "lemma merge_on_R1:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set_list_R1 x \\<subseteq> A } (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_R1 [locale_witness] = merge_on_R1[where A=UNIV, simplified]", "lemma merkle_list_R1 [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)\"", "lemma merge_R1_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set_list_R1 x; b \\<in> set_list_R1 y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_R1 m x y = merge_R1 m' x y\"", "lemma merge_R1_parametric [transfer_rule]:\n  includes lifting_syntax \n  notes [simp del] = merge_cases\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"((A ===> A ===> rel_option A) ===> rel_list_R1 A ===> rel_list_R1 A ===> rel_option (rel_list_R1 A))\n   merge_R1 merge_R1\"", "lemma blinding_of_list_mono:\n  \"\\<lbrakk> \\<And>x y. bo x y \\<longrightarrow> bo' x y \\<rbrakk> \\<Longrightarrow> \n  blinding_of_list bo x y \\<longrightarrow> blinding_of_list bo' x y\"", "lemmas blinding_of_list_hash = blinding_of_hash_R1[Transfer.transferred]\n  and blinding_of_on_list [locale_witness] = blinding_of_on_R1[Transfer.transferred]\n  and blinding_of_list [locale_witness] = blinding_of_R1[Transfer.transferred]\n  and merge_on_list [locale_witness] = merge_on_R1[Transfer.transferred]\n  and merge_list [locale_witness] = merge_R1[Transfer.transferred]\n  and merge_list_cong = merge_R1_cong[Transfer.transferred]", "lemma blinding_of_list_mono_pred:\n  \"R \\<le> R' \\<Longrightarrow> blinding_of_list R \\<le> blinding_of_list R'\"", "lemma blinding_of_list_simp: \"blinding_of_list = list_all2\"", "lemma merkle_list [locale_witness]:\n  assumes [locale_witness]: \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_list h) (blinding_of_list bo) (merge_list m)\"", "lemmas blinding_of_fun_mono = fun.rel_mono", "lemma blinding_of_fun_hash:\n  assumes \"bo \\<le> vimage2p rh rh (=)\"\n  shows \"blinding_of_fun bo \\<le> vimage2p (hash_fun rh) (hash_fun rh) (=)\"", "lemma blinding_of_on_fun [locale_witness]:\n  assumes \"blinding_of_on A rh bo\"\n  shows \"blinding_of_on {x. range x \\<subseteq> A} (hash_fun rh) (blinding_of_fun bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_fun [locale_witness] = blinding_of_on_fun[where A=UNIV, simplified]", "lemma merge_on_fun [locale_witness]:\n  assumes \"merge_on A rh bo m\"\n  shows \"merge_on {x. range x \\<subseteq> A} (hash_fun rh) (blinding_of_fun bo) merge_fun\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_fun [locale_witness] = merge_on_fun[where A=UNIV, simplified]", "lemma merge_fun_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> range f; b \\<in> range g \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_fun m f g = merge_fun m' f g\"", "lemma is_none_alt_def: \"Option.is_none x \\<longleftrightarrow> (case x of None \\<Rightarrow> True | Some _ \\<Rightarrow> False)\"", "lemma merge_fun_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> B ===> rel_option C) ===> ((=) ===> A) ===> ((=) ===> B) ===> rel_option ((=) ===> C))\n   merge_fun merge_fun\"", "lemma merkle_fun [locale_witness]:\n  assumes \"merkle_interface rh bo m\"\n  shows \"merkle_interface (hash_fun rh) (blinding_of_fun bo) (merge_fun m)\"", "lemma hash_rt_F\\<^sub>m_alt_def: \"hash_rt_F\\<^sub>m h rhm = hash_blindable (map_prod h (map rhm))\"", "lemma blindable\\<^sub>m_map_compositionality:\n  \"map_blindable\\<^sub>m f g o map_blindable\\<^sub>m f' g' = map_blindable\\<^sub>m (f o f') (g o g')\"", "lemma hash_tree_simps [simp]:\n  \"hash_tree h (Tree\\<^sub>m x) = Tree\\<^sub>h (hash_rt_F\\<^sub>m h (hash_tree h) x)\"", "lemma blinding_of_rt_F\\<^sub>m_mono:\n  \"\\<lbrakk> boa \\<le> boa'; bob \\<le> bob' \\<rbrakk> \\<Longrightarrow> blinding_of_rt_F\\<^sub>m ha boa hb bob \\<le> blinding_of_rt_F\\<^sub>m ha boa' hb bob'\"", "lemma blinding_of_rt_F\\<^sub>m_mono_inductive:\n  assumes \"\\<And>x y. boa x y \\<longrightarrow> boa' x y\" \"\\<And>x y. bob x y \\<longrightarrow> bob' x y\"\n  shows \"blinding_of_rt_F\\<^sub>m ha boa hb bob x y \\<longrightarrow> blinding_of_rt_F\\<^sub>m ha boa' hb bob' x y\"", "lemma blinding_of_rt_F\\<^sub>m_hash:\n  assumes \"boa \\<le> vimage2p ha ha (=)\" \"bob \\<le> vimage2p hb hb (=)\"\n  shows \"blinding_of_rt_F\\<^sub>m ha boa hb bob \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb) (=)\"", "lemma blinding_of_tree_hash:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)\"", "lemma set_rt_F\\<^sub>m_eq: \n  \"{x. set1_rt_F\\<^sub>m x \\<subseteq> A \\<and> set3_rt_F\\<^sub>m x \\<subseteq> B} = \n   {x. set1_blindable\\<^sub>m x \\<subseteq> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> {x. set x \\<subseteq> B}}}\"", "lemma hash_blindable_map: \"hash_blindable f \\<circ> map_blindable\\<^sub>m g id = hash_blindable (f \\<circ> g)\"", "lemma blinding_of_on_tree [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h) (blinding_of_tree h bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")", "lemmas blinding_of_tree [locale_witness] = blinding_of_on_tree[where A=UNIV, simplified]", "lemma blinding_of_tree_mono:\n  \"bo \\<le> bo' \\<Longrightarrow> blinding_of_tree h bo \\<le> blinding_of_tree h bo'\"", "lemma merge_rt_F\\<^sub>m_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_rt_F\\<^sub>m x; b \\<in> set1_rt_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> ma a b = ma' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> set3_rt_F\\<^sub>m x; b \\<in> set3_rt_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> mm a b = mm' a b\"\n  shows \"merge_rt_F\\<^sub>m ha ma hm mm x y = merge_rt_F\\<^sub>m ha ma' hm mm' x y\"", "lemma in_set1_blindable\\<^sub>m_iff: \"x \\<in> set1_blindable\\<^sub>m y \\<longleftrightarrow> y = Unblinded x\"", "lemma merge_on_tree [locale_witness]:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)\"\n  (is \"merge_on ?A ?h ?bo ?m\")", "lemmas merge_tree [locale_witness] = merge_on_tree[where A=UNIV, simplified]", "lemma option_bind_comm:\n \"((x :: 'a option) \\<bind> (\\<lambda>y. c \\<bind> (\\<lambda>z. f y z))) = (c \\<bind> (\\<lambda>y. x \\<bind> (\\<lambda>z. f z y)))\"", "lemma merkle_tree [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)\"", "lemma merge_tree_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_rose_tree\\<^sub>m x; b \\<in> set1_rose_tree\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_tree h m x y = merge_tree h m' x y\""], "translations": [["", "lemma blinding_of_discrete_hash:\n  \"blinding_of_discrete \\<le> vimage2p hash_discrete hash_discrete (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) \\<le> vimage2p id id (=)", "by(auto simp add: vimage2p_def)"], ["", "lemma blinding_of_on_discrete [locale_witness]:\n  \"blinding_of_on UNIV hash_discrete blinding_of_discrete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV id (=)", "by(unfold_locales)(simp_all add: OO_eq eq_onp_def blinding_of_discrete_hash)"], ["", "lemma merge_on_discrete [locale_witness]:\n  \"merge_on UNIV hash_discrete blinding_of_discrete merge_discrete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV id (=) merge_discrete", "by unfold_locales(auto simp add: merge_discrete_def)"], ["", "lemma merkle_discrete [locale_witness]:\n  \"merkle_interface hash_discrete blinding_of_discrete merge_discrete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface id (=) merge_discrete", ".."], ["", "parametric_constant merge_discrete_parametric [transfer_rule]: merge_discrete_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open>Example: instantiation for @{typ unit}\\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) hash_unit :: \"(unit, unit) hash\" where \"hash_unit \\<equiv> hash_discrete\""], ["", "abbreviation blinding_of_unit :: \"unit blinding_of\" where\n  \"blinding_of_unit \\<equiv> blinding_of_discrete\""], ["", "abbreviation merge_unit :: \"unit merge\" where \"merge_unit \\<equiv> merge_discrete\""], ["", "lemma blinding_of_unit_hash:\n  \"blinding_of_unit \\<le> vimage2p hash_unit hash_unit (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) \\<le> vimage2p id id (=)", "by(fact blinding_of_discrete_hash)"], ["", "lemma blinding_of_on_unit:\n  \"blinding_of_on UNIV hash_unit blinding_of_unit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on UNIV id (=)", "by(fact blinding_of_on_discrete)"], ["", "lemma merge_on_unit:\n  \"merge_on UNIV hash_unit blinding_of_unit merge_unit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV id (=) merge_unit", "by(fact merge_on_discrete)"], ["", "lemma merkle_interface_unit:\n  \"merkle_interface hash_unit blinding_of_unit merge_unit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface id (=) merge_unit", "by(intro merkle_interfaceI merge_on_unit)"], ["", "(************************************************************)"], ["", "subsection \\<open> Building Block: Blindable Position \\<close>"], ["", "(************************************************************)"], ["", "type_synonym 'a blindable = 'a"], ["", "text \\<open> The following type represents the hashes of a datatype. We model hashes as being injective,\n  but not surjective; some hashes do not correspond to any values of the original datatypes. We\n  model such values as \"garbage\" coming from a countable set (here, naturals). \\<close>"], ["", "type_synonym garbage = nat"], ["", "datatype 'a\\<^sub>h blindable\\<^sub>h = Content 'a\\<^sub>h | Garbage garbage"], ["", "datatype ('a\\<^sub>m, 'a\\<^sub>h) blindable\\<^sub>m = Unblinded 'a\\<^sub>m | Blinded \"'a\\<^sub>h blindable\\<^sub>h\""], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "primrec hash_blindable' :: \"(('a\\<^sub>h, 'a\\<^sub>h) blindable\\<^sub>m, 'a\\<^sub>h blindable\\<^sub>h) hash\" where\n  \"hash_blindable' (Unblinded x) = Content x\"\n| \"hash_blindable' (Blinded x) = x\""], ["", "definition hash_blindable :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> (('a\\<^sub>m, 'a\\<^sub>h) blindable\\<^sub>m, 'a\\<^sub>h blindable\\<^sub>h) hash\" where\n  \"hash_blindable h = hash_blindable' \\<circ> map_blindable\\<^sub>m h id\""], ["", "lemma hash_blindable_simps [simp]:\n  \"hash_blindable h (Unblinded x) = Content (h x)\"\n  \"hash_blindable h (Blinded y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_blindable h (Unblinded x) = Content (h x) &&&\n    hash_blindable h (Blinded y) = y", "by(simp_all add: hash_blindable_def blindable\\<^sub>h.map_id)"], ["", "lemma hash_map_blindable_simp:\n  \"hash_blindable f (map_blindable\\<^sub>m f' id x) = hash_blindable (f o f') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_blindable f (map_blindable\\<^sub>m f' id x) =\n    hash_blindable (f \\<circ> f') x", "by(cases x) (simp_all add: hash_blindable_def blindable\\<^sub>h.map_comp)"], ["", "parametric_constant hash_blindable'_parametric [transfer_rule]: hash_blindable'_def"], ["", "parametric_constant hash_blindable_parametric [transfer_rule]: hash_blindable_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "context\n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and bo :: \"'a\\<^sub>m blinding_of\"\nbegin"], ["", "inductive blinding_of_blindable :: \"('a\\<^sub>m, 'a\\<^sub>h) blindable\\<^sub>m blinding_of\" where\n  \"blinding_of_blindable (Unblinded x) (Unblinded y)\" if \"bo x y\"\n| \"blinding_of_blindable (Blinded x) t\" if \"hash_blindable h t = x\""], ["", "inductive_simps blinding_of_blindable_simps [simp]:\n  \"blinding_of_blindable (Unblinded x) y\"\n  \"blinding_of_blindable (Blinded x) y\"\n  \"blinding_of_blindable z (Unblinded x)\"\n  \"blinding_of_blindable z (Blinded x)\""], ["", "inductive_simps blinding_of_blindable_simps2:\n   \"blinding_of_blindable (Unblinded x) (Unblinded y)\"\n   \"blinding_of_blindable (Unblinded x) (Blinded y')\"\n   \"blinding_of_blindable (Blinded x') (Unblinded y)\"\n   \"blinding_of_blindable (Blinded x') (Blinded y')\""], ["", "end"], ["", "lemma blinding_of_blindable_mono:\n  assumes \"bo \\<le> bo'\"\n  shows \"blinding_of_blindable h bo \\<le> blinding_of_blindable h bo'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo \\<le> blinding_of_blindable h bo'", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       blinding_of_blindable h bo x y \\<Longrightarrow>\n       blinding_of_blindable h bo' x y", "apply(erule blinding_of_blindable.cases; hypsubst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       bo xa ya \\<Longrightarrow>\n       blinding_of_blindable h bo' (Unblinded xa) (Unblinded ya)\n 2. \\<And>x y t xa.\n       blinding_of_blindable h bo' (Blinded (hash_blindable h t)) t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bo xa_ ya_ \\<Longrightarrow>\n    blinding_of_blindable h bo' (Unblinded xa_) (Unblinded ya_)", "by(rule blinding_of_blindable.intros)(rule assms[THEN predicate2D])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y t xa.\n       blinding_of_blindable h bo' (Blinded (hash_blindable h t)) t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo' (Blinded (hash_blindable h t_)) t_", "by(rule blinding_of_blindable.intros) simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blinding_of_blindable_hash:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_blindable h bo \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo\n    \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)", "apply(rule predicate2I vimage2pI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       blinding_of_blindable h bo x y \\<Longrightarrow>\n       hash_blindable h x = hash_blindable h y", "apply(erule blinding_of_blindable.cases; hypsubst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       bo xa ya \\<Longrightarrow>\n       hash_blindable h (Unblinded xa) = hash_blindable h (Unblinded ya)\n 2. \\<And>x y t xa.\n       hash_blindable h (Blinded (hash_blindable h t)) = hash_blindable h t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bo xa_ ya_ \\<Longrightarrow>\n    hash_blindable h (Unblinded xa_) = hash_blindable h (Unblinded ya_)", "using assms[THEN predicate2D]"], ["proof (prove)\nusing this:\n  bo ?x ?y \\<Longrightarrow> vimage2p h h (=) ?x ?y\n\ngoal (1 subgoal):\n 1. bo xa_ ya_ \\<Longrightarrow>\n    hash_blindable h (Unblinded xa_) = hash_blindable h (Unblinded ya_)", "by(simp add: vimage2p_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y t xa.\n       hash_blindable h (Blinded (hash_blindable h t)) = hash_blindable h t", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_blindable h (Blinded (hash_blindable h t_)) = hash_blindable h t_", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blinding_of_on_blindable [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h) (blinding_of_blindable h bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n     (hash_blindable h) (blinding_of_blindable h bo)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n     (hash_blindable h) (blinding_of_blindable h bo)", "interpret blinding_of_on A h bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A h bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n     (hash_blindable h) (blinding_of_blindable h bo)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n     (hash_blindable h) (blinding_of_blindable h bo)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. blinding_of_blindable h bo\n    \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)\n 2. \\<And>x.\n       x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n       blinding_of_blindable h bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y z;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_blindable h bo x z\n 4. \\<And>x y.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y x;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo \\<le> vimage2p ?h ?h (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo\n    \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)", "by(rule blinding_of_blindable_hash)(rule hash)"], ["proof (state)\nthis:\n  blinding_of_blindable h bo\n  \\<le> vimage2p (hash_blindable h) (hash_blindable h) (=)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n       blinding_of_blindable h bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y z;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_blindable h bo x z\n 3. \\<And>x y.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y x;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x x\" if \"x \\<in> ?A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo x x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo x x", "by(cases x)(auto simp add: refl)"], ["proof (state)\nthis:\n  ?x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  blinding_of_blindable h bo ?x ?x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y z;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_blindable h bo x z\n 2. \\<And>x y.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y x;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x z\" if \"?bo x y\" \"?bo y z\" \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo x z", "using that"], ["proof (prove)\nusing this:\n  blinding_of_blindable h bo x y\n  blinding_of_blindable h bo y z\n  x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. blinding_of_blindable h bo x z", "by(auto elim!: blinding_of_blindable.cases dest: trans blinding_hash_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>blinding_of_blindable h bo ?x ?y;\n   blinding_of_blindable h bo ?y ?z;\n   ?x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_blindable h bo ?x ?z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>blinding_of_blindable h bo x y;\n        blinding_of_blindable h bo y x;\n        x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\" if \"?bo x y\" \"?bo y x\" \"x \\<in> ?A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  blinding_of_blindable h bo x y\n  blinding_of_blindable h bo y x\n  x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. x = y", "by(auto elim!: blinding_of_blindable.cases dest: antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>blinding_of_blindable h bo ?x ?y;\n   blinding_of_blindable h bo ?y ?x;\n   ?x \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  blinding_of_on {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n   (hash_blindable h) (blinding_of_blindable h bo)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_blindable [locale_witness] = blinding_of_on_blindable[of UNIV, simplified]"], ["", "case_of_simps blinding_of_blindable_alt_def: blinding_of_blindable_simps2"], ["", "parametric_constant blinding_of_blindable_parametric [transfer_rule]: blinding_of_blindable_alt_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "context\n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n  fixes m :: \"'a\\<^sub>m merge\"\nbegin"], ["", "fun merge_blindable :: \"('a\\<^sub>m, 'a\\<^sub>h) blindable\\<^sub>m merge\" where\n  \"merge_blindable (Unblinded x) (Unblinded y) = map_option Unblinded (m x y)\"\n| \"merge_blindable (Blinded x) (Unblinded y) = (if x = Content (h y) then Some (Unblinded y) else None)\"\n| \"merge_blindable (Unblinded y) (Blinded x) = (if x = Content (h y) then Some (Unblinded y) else None)\"\n| \"merge_blindable (Blinded t) (Blinded u) = (if t = u then Some (Blinded u) else None)\""], ["", "lemma merge_on_blindable [locale_witness]:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h) (blinding_of_blindable h bo) merge_blindable\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h)\n     (blinding_of_blindable h bo) local.merge_blindable", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h)\n     (blinding_of_blindable h bo) local.merge_blindable", "interpret merge_on A h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A h bo m", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h)\n     (blinding_of_blindable h bo) local.merge_blindable", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h)\n     (blinding_of_blindable h bo) local.merge_blindable", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_blindable h a = hash_blindable h b;\n        a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            local.merge_blindable a b = Some ab \\<and>\n                            blinding_of_blindable h bo a ab \\<and>\n                            blinding_of_blindable h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_blindable h bo a\n                                 u \\<longrightarrow>\n                                blinding_of_blindable h bo b\n                                 u \\<longrightarrow>\n                                blinding_of_blindable h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_blindable h a \\<noteq> hash_blindable h b;\n        a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> local.merge_blindable a b = None", "show \"\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\" if \"?h a = ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_blindable a b = Some ab \\<and>\n       blinding_of_blindable h bo a ab \\<and>\n       blinding_of_blindable h bo b ab \\<and>\n       (\\<forall>u.\n           blinding_of_blindable h bo a u \\<longrightarrow>\n           blinding_of_blindable h bo b u \\<longrightarrow>\n           blinding_of_blindable h bo ab u)", "using that"], ["proof (prove)\nusing this:\n  hash_blindable h a = hash_blindable h b\n  a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_blindable a b = Some ab \\<and>\n       blinding_of_blindable h bo a ab \\<and>\n       blinding_of_blindable h bo b ab \\<and>\n       (\\<forall>u.\n           blinding_of_blindable h bo a u \\<longrightarrow>\n           blinding_of_blindable h bo b u \\<longrightarrow>\n           blinding_of_blindable h bo ab u)", "by(cases \"(a, b)\" rule: merge_blindable.cases)(auto simp add: refl dest!: join)"], ["proof (state)\nthis:\n  \\<lbrakk>hash_blindable h ?a = hash_blindable h ?b;\n   ?a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       local.merge_blindable ?a ?b = Some ab \\<and>\n                       blinding_of_blindable h bo ?a ab \\<and>\n                       blinding_of_blindable h bo ?b ab \\<and>\n                       (\\<forall>u.\n                           blinding_of_blindable h bo ?a u \\<longrightarrow>\n                           blinding_of_blindable h bo ?b u \\<longrightarrow>\n                           blinding_of_blindable h bo ab u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>hash_blindable h a \\<noteq> hash_blindable h b;\n        a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> local.merge_blindable a b = None", "show \"?m a b = None\" if \"?h a \\<noteq> ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_blindable a b = None", "using that"], ["proof (prove)\nusing this:\n  hash_blindable h a \\<noteq> hash_blindable h b\n  a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. local.merge_blindable a b = None", "by(cases \"(a, b)\" rule: merge_blindable.cases)(auto simp add: dest!: undefined)"], ["proof (state)\nthis:\n  \\<lbrakk>hash_blindable h ?a \\<noteq> hash_blindable h ?b;\n   ?a \\<in> {x. set1_blindable\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> local.merge_blindable ?a ?b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. set1_blindable\\<^sub>m x \\<subseteq> A} (hash_blindable h)\n   (blinding_of_blindable h bo) local.merge_blindable\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_blindable [locale_witness] = \n  merge_on_blindable[of UNIV, simplified]"], ["", "end"], ["", "lemma merge_blindable_alt_def:\n  \"merge_blindable h m x y = (case (x, y) of\n    (Unblinded x, Unblinded y) \\<Rightarrow> map_option Unblinded (m x y)\n  | (Blinded x, Unblinded y) \\<Rightarrow> (if Content (h y) = x then Some (Unblinded y) else None)\n  | (Unblinded y, Blinded x) \\<Rightarrow> (if Content (h y) = x then Some (Unblinded y) else None)\n  | (Blinded t, Blinded u) \\<Rightarrow> (if t = u then Some (Blinded u) else None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_blindable h m x y =\n    (case (x, y) of\n     (Unblinded x, Unblinded y) \\<Rightarrow> map_option Unblinded (m x y)\n     | (Unblinded x, Blinded xa) \\<Rightarrow>\n         if Content (h x) = xa then Some (Unblinded x) else None\n     | (Blinded x, Unblinded y) \\<Rightarrow>\n         if Content (h y) = x then Some (Unblinded y) else None\n     | (Blinded x, Blinded u) \\<Rightarrow>\n         if x = u then Some (Blinded u) else None)", "by(simp split: blindable\\<^sub>m.split blindable\\<^sub>h.split)"], ["", "parametric_constant merge_blindable_parametric [transfer_rule]: merge_blindable_alt_def"], ["", "lemma merge_blindable_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_blindable\\<^sub>m x; b \\<in> set1_blindable\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_blindable h m x y = merge_blindable h m' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_blindable h m x y = merge_blindable h m' x y", "by(auto simp add: merge_blindable_alt_def split: blindable\\<^sub>m.split intro: assms intro!: arg_cong[where f=\"map_option _\"])"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merkle interface \\<close>"], ["", "(************************************************************)"], ["", "lemma merkle_blindable [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_blindable h) (blinding_of_blindable h bo) (merge_blindable h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable h) (blinding_of_blindable h bo)\n     (merge_blindable h m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable h) (blinding_of_blindable h bo)\n     (merge_blindable h m)", "interpret merge_on UNIV h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "using assms"], ["proof (prove)\nusing this:\n  merkle_interface h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "by(simp add: merkle_interface_aux)"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable h) (blinding_of_blindable h bo)\n     (merge_blindable h m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable h) (blinding_of_blindable h bo)\n     (merge_blindable h m)", "unfolding merkle_interface_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV (hash_blindable h) (blinding_of_blindable h bo)\n     (merge_blindable h m)", ".."], ["proof (state)\nthis:\n  merkle_interface (hash_blindable h) (blinding_of_blindable h bo)\n   (merge_blindable h m)\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Non-recursive blindable positions \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> For a non-recursive data type @{typ 'a}, the type of hashes in @{type blindable\\<^sub>m} is fixed\nto be simply @{typ \"'a blindable\\<^sub>h\"}. We obtain this by instantiating the type variable with the\nidentity building block. \\<close>"], ["", "type_synonym 'a nr_blindable = \"('a, 'a) blindable\\<^sub>m\""], ["", "abbreviation hash_nr_blindable :: \"('a nr_blindable, 'a blindable\\<^sub>h) hash\" where\n  \"hash_nr_blindable \\<equiv> hash_blindable hash_discrete\""], ["", "abbreviation blinding_of_nr_blindable :: \"'a nr_blindable blinding_of\" where\n  \"blinding_of_nr_blindable \\<equiv> blinding_of_blindable hash_discrete blinding_of_discrete\""], ["", "abbreviation merge_nr_blindable :: \"'a nr_blindable merge\" where\n  \"merge_nr_blindable \\<equiv> merge_blindable hash_discrete merge_discrete\""], ["", "lemma merge_on_nr_blindable:\n  \"merge_on UNIV hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV (hash_blindable id) (blinding_of_blindable id (=))\n     (merge_blindable id merge_discrete)", ".."], ["", "lemma merkle_nr_blindable:\n  \"merkle_interface hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_blindable id) (blinding_of_blindable id (=))\n     (merge_blindable id merge_discrete)", ".."], ["", "(************************************************************)"], ["", "subsection \\<open> Building block: Sums \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> We prove that we can lift the ADS construction through sums.\\<close>"], ["", "type_synonym ('a\\<^sub>h, 'b\\<^sub>h) sum\\<^sub>h = \"'a\\<^sub>h + 'b\\<^sub>h\""], ["", "type_notation sum\\<^sub>h (infixr \"+\\<^sub>h\" 10)"], ["", "type_synonym ('a\\<^sub>m, 'b\\<^sub>m) sum\\<^sub>m = \"'a\\<^sub>m + 'b\\<^sub>m\"\n  \\<comment> \\<open>If a functor does not introduce blindable positions, then we don't need the type variable copies.\\<close>"], ["", "type_notation sum\\<^sub>m (infixr \"+\\<^sub>m\" 10)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) hash_sum' :: \"('a\\<^sub>h +\\<^sub>h 'b\\<^sub>h, 'a\\<^sub>h +\\<^sub>h 'b\\<^sub>h) hash\" where\n  \"hash_sum' \\<equiv> id\""], ["", "abbreviation (input) hash_sum :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> ('a\\<^sub>m +\\<^sub>m 'b\\<^sub>m, 'a\\<^sub>h +\\<^sub>h 'b\\<^sub>h) hash\"\n  where \"hash_sum \\<equiv> map_sum\""], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) blinding_of_sum :: \"'a\\<^sub>m blinding_of \\<Rightarrow> 'b\\<^sub>m blinding_of \\<Rightarrow> ('a\\<^sub>m +\\<^sub>m 'b\\<^sub>m) blinding_of\" where\n  \"blinding_of_sum \\<equiv> rel_sum\""], ["", "lemmas blinding_of_sum_mono = sum.rel_mono"], ["", "lemma blinding_of_sum_hash:\n  assumes \"boa \\<le> vimage2p rha rha (=)\" \"bob \\<le> vimage2p rhb rhb (=)\"\n  shows \"blinding_of_sum boa bob \\<le> vimage2p (hash_sum rha rhb) (hash_sum rha rhb) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)", "using assms"], ["proof (prove)\nusing this:\n  boa \\<le> vimage2p rha rha (=)\n  bob \\<le> vimage2p rhb rhb (=)\n\ngoal (1 subgoal):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)", "by(auto simp add: vimage2p_def elim!: rel_sum.cases)"], ["", "lemma blinding_of_on_sum [locale_witness]:\n  assumes \"blinding_of_on A rha boa\" \"blinding_of_on B rhb bob\"\n  shows \"blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B} (hash_sum rha rhb) (blinding_of_sum boa bob)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob)", "interpret a: blinding_of_on A rha boa"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A rha boa", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob)", "interpret b: blinding_of_on B rhb bob"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on B rhb bob", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)\n 2. \\<And>x.\n       x \\<in> {x. setl x \\<subseteq> A \\<and>\n                   setr x \\<subseteq> B} \\<Longrightarrow>\n       rel_sum boa bob x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_sum boa bob x y; rel_sum boa bob y z;\n        x \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> rel_sum boa bob x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_sum boa bob x y; rel_sum boa bob y x;\n        x \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x x\" if \"x \\<in> ?A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_sum boa bob x x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. rel_sum boa bob x x", "by(intro sum.rel_refl_strong)(auto intro: a.refl b.refl)"], ["proof (state)\nthis:\n  ?x \\<in> {x. setl x \\<subseteq> A \\<and>\n               setr x \\<subseteq> B} \\<Longrightarrow>\n  rel_sum boa bob ?x ?x\n\ngoal (3 subgoals):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_sum boa bob x y; rel_sum boa bob y z;\n        x \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> rel_sum boa bob x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_sum boa bob x y; rel_sum boa bob y x;\n        x \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x z\" if \"?bo x y\" \"?bo y z\" \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_sum boa bob x z", "using that"], ["proof (prove)\nusing this:\n  rel_sum boa bob x y\n  rel_sum boa bob y z\n  x \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. rel_sum boa bob x z", "by(auto elim!: rel_sum.cases dest: a.trans b.trans)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_sum boa bob ?x ?y; rel_sum boa bob ?y ?z;\n   ?x \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> rel_sum boa bob ?x ?z\n\ngoal (2 subgoals):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)\n 2. \\<And>x y.\n       \\<lbrakk>rel_sum boa bob x y; rel_sum boa bob y x;\n        x \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\" if \"?bo x y\" \"?bo y x\" \"x \\<in> ?A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  rel_sum boa bob x y\n  rel_sum boa bob y x\n  x \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. x = y", "by(auto elim!: rel_sum.cases dest: a.antisym b.antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_sum boa bob ?x ?y; rel_sum boa bob ?y ?x;\n   ?x \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rel_sum boa bob \\<le> vimage2p (map_sum rha rhb) (map_sum rha rhb) (=)", "qed(rule blinding_of_sum_hash a.hash b.hash)+"], ["proof (state)\nthis:\n  blinding_of_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n   (map_sum rha rhb) (rel_sum boa bob)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_sum [locale_witness] = blinding_of_on_sum[of UNIV _ _ UNIV, simplified]"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "context\n  fixes ma :: \"'a\\<^sub>m merge\"\n  fixes mb :: \"'b\\<^sub>m merge\"\nbegin"], ["", "fun merge_sum :: \"('a\\<^sub>m +\\<^sub>m 'b\\<^sub>m) merge\" where\n  \"merge_sum (Inl x) (Inl y) = map_option Inl (ma x y)\"\n| \"merge_sum (Inr x) (Inr y) = map_option Inr (mb x y)\"\n| \"merge_sum _ _ = None\""], ["", "lemma merge_on_sum [locale_witness]:\n  assumes \"merge_on A rha boa ma\" \"merge_on B rhb bob mb\"\n  shows \"merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B} (hash_sum rha rhb) (blinding_of_sum boa bob) merge_sum\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob) local.merge_sum", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob) local.merge_sum", "interpret a: merge_on A rha boa ma"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A rha boa ma", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob) local.merge_sum", "interpret b: merge_on B rhb bob mb"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on B rhb bob mb", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob) local.merge_sum", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n     (map_sum rha rhb) (rel_sum boa bob) local.merge_sum", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_sum rha rhb a = map_sum rha rhb b;\n        a \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            local.merge_sum a b = Some ab \\<and>\n                            rel_sum boa bob a ab \\<and>\n                            rel_sum boa bob b ab \\<and>\n                            (\\<forall>u.\n                                rel_sum boa bob a u \\<longrightarrow>\n                                rel_sum boa bob b u \\<longrightarrow>\n                                rel_sum boa bob ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_sum rha rhb a \\<noteq> map_sum rha rhb b;\n        a \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> local.merge_sum a b = None", "show \"\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n      if \"?h a = ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_sum a b = Some ab \\<and>\n       rel_sum boa bob a ab \\<and>\n       rel_sum boa bob b ab \\<and>\n       (\\<forall>u.\n           rel_sum boa bob a u \\<longrightarrow>\n           rel_sum boa bob b u \\<longrightarrow> rel_sum boa bob ab u)", "using that"], ["proof (prove)\nusing this:\n  map_sum rha rhb a = map_sum rha rhb b\n  a \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_sum a b = Some ab \\<and>\n       rel_sum boa bob a ab \\<and>\n       rel_sum boa bob b ab \\<and>\n       (\\<forall>u.\n           rel_sum boa bob a u \\<longrightarrow>\n           rel_sum boa bob b u \\<longrightarrow> rel_sum boa bob ab u)", "by(cases \"(a, b)\" rule: merge_sum.cases)(auto dest!: a.join b.join elim!: rel_sum.cases)"], ["proof (state)\nthis:\n  \\<lbrakk>map_sum rha rhb ?a = map_sum rha rhb ?b;\n   ?a \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       local.merge_sum ?a ?b = Some ab \\<and>\n                       rel_sum boa bob ?a ab \\<and>\n                       rel_sum boa bob ?b ab \\<and>\n                       (\\<forall>u.\n                           rel_sum boa bob ?a u \\<longrightarrow>\n                           rel_sum boa bob ?b u \\<longrightarrow>\n                           rel_sum boa bob ab u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>map_sum rha rhb a \\<noteq> map_sum rha rhb b;\n        a \\<in> {x. setl x \\<subseteq> A \\<and>\n                    setr x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> local.merge_sum a b = None", "show \"?m a b = None\" if \"?h a \\<noteq> ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_sum a b = None", "using that"], ["proof (prove)\nusing this:\n  map_sum rha rhb a \\<noteq> map_sum rha rhb b\n  a \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. local.merge_sum a b = None", "by(cases \"(a, b)\" rule: merge_sum.cases)(auto dest!: a.undefined b.undefined)"], ["proof (state)\nthis:\n  \\<lbrakk>map_sum rha rhb ?a \\<noteq> map_sum rha rhb ?b;\n   ?a \\<in> {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> local.merge_sum ?a ?b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. setl x \\<subseteq> A \\<and> setr x \\<subseteq> B}\n   (map_sum rha rhb) (rel_sum boa bob) local.merge_sum\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_sum [locale_witness] = merge_on_sum[where A=UNIV and B=UNIV, simplified]"], ["", "lemma merge_sum_alt_def:\n  \"merge_sum x y = (case (x, y) of\n    (Inl x, Inl y) \\<Rightarrow> map_option Inl (ma x y)\n  | (Inr x, Inr y) \\<Rightarrow> map_option Inr (mb x y)\n  | _ \\<Rightarrow> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_sum x y =\n    (case (x, y) of (Inl x, Inl y) \\<Rightarrow> map_option Inl (ma x y)\n     | (Inl x, Inr xa) \\<Rightarrow> Map.empty xa\n     | (Inr x, Inl xa) \\<Rightarrow> Map.empty xa\n     | (Inr x, Inr y) \\<Rightarrow> map_option Inr (mb x y))", "by(simp add: split: sum.split)"], ["", "end"], ["", "lemma merge_sum_cong[fundef_cong]:\n  \"\\<lbrakk> x = x'; y = y'; \n    \\<And>xl yl. \\<lbrakk> x = Inl xl; y = Inl yl \\<rbrakk> \\<Longrightarrow> ma xl yl = ma' xl yl;\n    \\<And>xr yr. \\<lbrakk> x = Inr xr; y = Inr yr \\<rbrakk> \\<Longrightarrow> mb xr yr = mb' xr yr \\<rbrakk> \\<Longrightarrow>\n    merge_sum ma mb x y = merge_sum ma' mb' x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = x'; y = y';\n     \\<And>xl yl.\n        \\<lbrakk>x = Inl xl; y = Inl yl\\<rbrakk>\n        \\<Longrightarrow> ma xl yl = ma' xl yl;\n     \\<And>xr yr.\n        \\<lbrakk>x = Inr xr; y = Inr yr\\<rbrakk>\n        \\<Longrightarrow> mb xr yr = mb' xr yr\\<rbrakk>\n    \\<Longrightarrow> merge_sum ma mb x y = merge_sum ma' mb' x' y'", "by(cases x; simp_all; cases y; auto)"], ["", "parametric_constant merge_sum_parametric [transfer_rule]: merge_sum_alt_def"], ["", "subsubsection \\<open> Merkle interface \\<close>"], ["", "lemma merkle_sum [locale_witness]:\n  assumes \"merkle_interface rha boa ma\" \"merkle_interface rhb bob mb\"\n  shows \"merkle_interface (hash_sum rha rhb) (blinding_of_sum boa bob) (merge_sum ma mb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", "interpret a: merge_on UNIV rha boa ma"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV rha boa ma", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface rha boa ma", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", "interpret b: merge_on UNIV rhb bob mb"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV rhb bob mb", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface rhb bob mb", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)", ".."], ["proof (state)\nthis:\n  merkle_interface (map_sum rha rhb) (rel_sum boa bob) (merge_sum ma mb)\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************)"], ["", "subsection \\<open> Building Block: Products\\<close>"], ["", "(************************************************************)"], ["", "text \\<open> We prove that we can lift the ADS construction through products.\\<close>"], ["", "type_synonym ('a\\<^sub>h, 'b\\<^sub>h) prod\\<^sub>h = \"'a\\<^sub>h \\<times> 'b\\<^sub>h\""], ["", "type_notation prod\\<^sub>h (\"(_ \\<times>\\<^sub>h/ _)\" [21, 20] 20)"], ["", "type_synonym ('a\\<^sub>m, 'b\\<^sub>m) prod\\<^sub>m = \"'a\\<^sub>m \\<times> 'b\\<^sub>m\"\n  \\<comment> \\<open>If a functor does not introduce blindable positions, then we don't need the type variable copies.\\<close>"], ["", "type_notation prod\\<^sub>m (\"(_ \\<times>\\<^sub>m/ _)\" [21, 20] 20)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) hash_prod' :: \"('a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h, 'a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h) hash\" where\n  \"hash_prod' \\<equiv> id\""], ["", "abbreviation (input) hash_prod :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> ('a\\<^sub>m \\<times>\\<^sub>m 'b\\<^sub>m, 'a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h) hash\"\n  where \"hash_prod \\<equiv> map_prod\""], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) blinding_of_prod :: \"'a\\<^sub>m blinding_of \\<Rightarrow> 'b\\<^sub>m blinding_of \\<Rightarrow> ('a\\<^sub>m \\<times>\\<^sub>m 'b\\<^sub>m) blinding_of\" where\n  \"blinding_of_prod \\<equiv> rel_prod\""], ["", "lemmas blinding_of_prod_mono = prod.rel_mono"], ["", "lemma blinding_of_prod_hash:\n  assumes \"boa \\<le> vimage2p rha rha (=)\" \"bob \\<le> vimage2p rhb rhb (=)\"\n  shows \"blinding_of_prod boa bob \\<le> vimage2p (hash_prod rha rhb) (hash_prod rha rhb) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)", "using assms"], ["proof (prove)\nusing this:\n  boa \\<le> vimage2p rha rha (=)\n  bob \\<le> vimage2p rhb rhb (=)\n\ngoal (1 subgoal):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)", "by(auto simp add: vimage2p_def)"], ["", "lemma blinding_of_on_prod [locale_witness]:\n  assumes \"blinding_of_on A rha boa\" \"blinding_of_on B rhb bob\"\n  shows \"blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B} (hash_prod rha rhb) (blinding_of_prod boa bob)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob)", "interpret a: blinding_of_on A rha boa"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A rha boa", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob)", "interpret b: blinding_of_on B rhb bob"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on B rhb bob", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)\n 2. \\<And>x.\n       x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                   snds x \\<subseteq> B} \\<Longrightarrow>\n       rel_prod boa bob x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_prod boa bob x y; rel_prod boa bob y z;\n        x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> rel_prod boa bob x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_prod boa bob x y; rel_prod boa bob y x;\n        x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x x\" if \"x \\<in> ?A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod boa bob x x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. rel_prod boa bob x x", "by(cases x)(auto intro: a.refl b.refl)"], ["proof (state)\nthis:\n  ?x \\<in> {x. fsts x \\<subseteq> A \\<and>\n               snds x \\<subseteq> B} \\<Longrightarrow>\n  rel_prod boa bob ?x ?x\n\ngoal (3 subgoals):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_prod boa bob x y; rel_prod boa bob y z;\n        x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> rel_prod boa bob x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_prod boa bob x y; rel_prod boa bob y x;\n        x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x z\" if \"?bo x y\" \"?bo y z\" \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_prod boa bob x z", "using that"], ["proof (prove)\nusing this:\n  rel_prod boa bob x y\n  rel_prod boa bob y z\n  x \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. rel_prod boa bob x z", "by(auto elim!: rel_prod.cases dest: a.trans b.trans)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_prod boa bob ?x ?y; rel_prod boa bob ?y ?z;\n   ?x \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> rel_prod boa bob ?x ?z\n\ngoal (2 subgoals):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)\n 2. \\<And>x y.\n       \\<lbrakk>rel_prod boa bob x y; rel_prod boa bob y x;\n        x \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\" if \"?bo x y\" \"?bo y x\" \"x \\<in> ?A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  rel_prod boa bob x y\n  rel_prod boa bob y x\n  x \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. x = y", "by(auto elim!: rel_prod.cases dest: a.antisym b.antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_prod boa bob ?x ?y; rel_prod boa bob ?y ?x;\n   ?x \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rel_prod boa bob\n    \\<le> vimage2p (map_prod rha rhb) (map_prod rha rhb) (=)", "qed(rule blinding_of_prod_hash a.hash b.hash)+"], ["proof (state)\nthis:\n  blinding_of_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n   (map_prod rha rhb) (rel_prod boa bob)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_prod [locale_witness] = blinding_of_on_prod[where A=UNIV and B=UNIV, simplified]"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "context\n  fixes ma :: \"'a\\<^sub>m merge\"\n  fixes mb :: \"'b\\<^sub>m merge\"\nbegin"], ["", "fun merge_prod :: \"('a\\<^sub>m \\<times>\\<^sub>m 'b\\<^sub>m) merge\" where\n  \"merge_prod (x, y) (x', y') = Option.bind (ma x x') (\\<lambda>x''. map_option (Pair x'') (mb y y'))\""], ["", "lemma merge_on_prod [locale_witness]:\n  assumes \"merge_on A rha boa ma\" \"merge_on B rhb bob mb\"\n  shows \"merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B} (hash_prod rha rhb) (blinding_of_prod boa bob) merge_prod\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob) local.merge_prod", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob) local.merge_prod", "interpret a: merge_on A rha boa ma"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A rha boa ma", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob) local.merge_prod", "interpret b: merge_on B rhb bob mb"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on B rhb bob mb", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob) local.merge_prod", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n     (map_prod rha rhb) (rel_prod boa bob) local.merge_prod", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_prod rha rhb a = map_prod rha rhb b;\n        a \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            local.merge_prod a b = Some ab \\<and>\n                            rel_prod boa bob a ab \\<and>\n                            rel_prod boa bob b ab \\<and>\n                            (\\<forall>u.\n                                rel_prod boa bob a u \\<longrightarrow>\n                                rel_prod boa bob b u \\<longrightarrow>\n                                rel_prod boa bob ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_prod rha rhb a \\<noteq> map_prod rha rhb b;\n        a \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> local.merge_prod a b = None", "show \"\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n      if \"?h a = ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_prod a b = Some ab \\<and>\n       rel_prod boa bob a ab \\<and>\n       rel_prod boa bob b ab \\<and>\n       (\\<forall>u.\n           rel_prod boa bob a u \\<longrightarrow>\n           rel_prod boa bob b u \\<longrightarrow> rel_prod boa bob ab u)", "using that"], ["proof (prove)\nusing this:\n  map_prod rha rhb a = map_prod rha rhb b\n  a \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_prod a b = Some ab \\<and>\n       rel_prod boa bob a ab \\<and>\n       rel_prod boa bob b ab \\<and>\n       (\\<forall>u.\n           rel_prod boa bob a u \\<longrightarrow>\n           rel_prod boa bob b u \\<longrightarrow> rel_prod boa bob ab u)", "by(cases \"(a, b)\" rule: merge_prod.cases)(auto dest!: a.join b.join)"], ["proof (state)\nthis:\n  \\<lbrakk>map_prod rha rhb ?a = map_prod rha rhb ?b;\n   ?a \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       local.merge_prod ?a ?b = Some ab \\<and>\n                       rel_prod boa bob ?a ab \\<and>\n                       rel_prod boa bob ?b ab \\<and>\n                       (\\<forall>u.\n                           rel_prod boa bob ?a u \\<longrightarrow>\n                           rel_prod boa bob ?b u \\<longrightarrow>\n                           rel_prod boa bob ab u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>map_prod rha rhb a \\<noteq> map_prod rha rhb b;\n        a \\<in> {x. fsts x \\<subseteq> A \\<and>\n                    snds x \\<subseteq> B}\\<rbrakk>\n       \\<Longrightarrow> local.merge_prod a b = None", "show \"?m a b = None\" if \"?h a \\<noteq> ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_prod a b = None", "using that"], ["proof (prove)\nusing this:\n  map_prod rha rhb a \\<noteq> map_prod rha rhb b\n  a \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n\ngoal (1 subgoal):\n 1. local.merge_prod a b = None", "by(cases \"(a, b)\" rule: merge_prod.cases)(auto dest!: a.undefined b.undefined)"], ["proof (state)\nthis:\n  \\<lbrakk>map_prod rha rhb ?a \\<noteq> map_prod rha rhb ?b;\n   ?a \\<in> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\\<rbrakk>\n  \\<Longrightarrow> local.merge_prod ?a ?b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}\n   (map_prod rha rhb) (rel_prod boa bob) local.merge_prod\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_prod [locale_witness] = merge_on_prod[where A=UNIV and B=UNIV, simplified]"], ["", "lemma merge_prod_alt_def:\n  \"merge_prod = (\\<lambda>(x, y) (x', y'). Option.bind (ma x x') (\\<lambda>x''. map_option (Pair x'') (mb y y')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_prod =\n    (\\<lambda>(x, y) (x', y').\n        ma x x' \\<bind> (\\<lambda>x''. map_option (Pair x'') (mb y y')))", "by(simp add: fun_eq_iff)"], ["", "end"], ["", "lemma merge_prod_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> fsts p1; b \\<in> fsts p2 \\<rbrakk> \\<Longrightarrow> ma a b = ma' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> snds p1; b \\<in> snds p2 \\<rbrakk> \\<Longrightarrow> mb a b = mb' a b\" \n  shows \"merge_prod ma mb p1 p2 = merge_prod ma' mb' p1 p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_prod ma mb p1 p2 = merge_prod ma' mb' p1 p2", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> fsts p1; ?b \\<in> fsts p2\\<rbrakk>\n  \\<Longrightarrow> ma ?a ?b = ma' ?a ?b\n  \\<lbrakk>?a \\<in> snds p1; ?b \\<in> snds p2\\<rbrakk>\n  \\<Longrightarrow> mb ?a ?b = mb' ?a ?b\n\ngoal (1 subgoal):\n 1. merge_prod ma mb p1 p2 = merge_prod ma' mb' p1 p2", "by(cases p1; cases p2) auto"], ["", "parametric_constant merge_prod_parametric [transfer_rule]: merge_prod_alt_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merkle Interface \\<close>"], ["", "(************************************************************)"], ["", "lemma merkle_product [locale_witness]:\n  assumes \"merkle_interface rha boa ma\" \"merkle_interface rhb bob mb\"\n  shows \"merkle_interface (hash_prod rha rhb) (blinding_of_prod boa bob) (merge_prod ma mb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", "interpret a: merge_on UNIV rha boa ma"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV rha boa ma", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface rha boa ma", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", "interpret b: merge_on UNIV rhb bob mb"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV rhb bob mb", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface rhb bob mb", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_prod rha rhb) (rel_prod boa bob)\n     (merge_prod ma mb)", ".."], ["proof (state)\nthis:\n  merkle_interface (map_prod rha rhb) (rel_prod boa bob) (merge_prod ma mb)\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************)"], ["", "subsection \\<open>Building Block: Lists\\<close>"], ["", "(************************************************************)"], ["", "text \\<open>The ADS construction on lists is done the easiest through a separate isomorphic datatype\n  that has only a single constructor. We hide this construction in a locale. \\<close>"], ["", "locale list_R1 begin"], ["", "type_synonym ('a, 'b) list_F = \"unit + 'a \\<times> 'b\""], ["", "abbreviation (input) \"set_base_F\\<^sub>m \\<equiv> \\<lambda>x. setr x \\<bind> fsts\""], ["", "abbreviation (input) \"set_rec_F\\<^sub>m \\<equiv> \\<lambda>A. setr A \\<bind> snds\""], ["", "abbreviation (input) \"map_F \\<equiv> \\<lambda>fb fr. map_sum id (map_prod fb fr)\""], ["", "datatype 'a list_R1 = list_R1 (unR: \"('a, 'a list_R1) list_F\")"], ["", "lemma list_R1_const_into_dest: \"list_R1 F = l \\<longleftrightarrow> F = unR l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_R1 F = l) = (F = unR l)", "by auto"], ["", "declare list_R1.split[split]"], ["", "lemma list_R1_induct[case_names list_R1]:\n  assumes \"\\<And>F. \\<lbrakk> \\<And>l'. l' \\<in> set_rec_F\\<^sub>m F  \\<Longrightarrow> P l' \\<rbrakk> \\<Longrightarrow> P (list_R1 F)\"\n  shows \"P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P l", "apply(rule list_R1.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa.\n           \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa\\<rbrakk>\n           \\<Longrightarrow> P xaaa) \\<Longrightarrow>\n       P (list_R1 xa)", "apply(auto intro!: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_list_R1_eq: \n  \"{x. set_base_F\\<^sub>m x \\<subseteq> A \\<and> set_rec_F\\<^sub>m x \\<subseteq> B} =\n   {x. setl x \\<subseteq> UNIV \\<and> setr x \\<subseteq> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. setr x \\<bind> fsts \\<subseteq> A \\<and>\n        setr x \\<bind> snds \\<subseteq> B} =\n    {x. setl x \\<subseteq> UNIV \\<and>\n        setr x\n        \\<subseteq> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> B}}", "by(auto simp add: bind_UNION)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> The Isomorphism \\<close>"], ["", "(************************************************************)"], ["", "primrec (transfer) list_R1_to_list :: \"'a list_R1 \\<Rightarrow> 'a list\" where\n  \"list_R1_to_list (list_R1 l) = (case map_sum id (map_prod id list_R1_to_list) l of Inl () \\<Rightarrow> [] | Inr (x, xs) \\<Rightarrow> x # xs)\""], ["", "lemma list_R1_to_list_simps [simp]:\n  \"list_R1_to_list (list_R1 (Inl ())) = []\"\n  \"list_R1_to_list (list_R1 (Inr (x, xs))) = x # list_R1_to_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1_to_list (list_R1 (Inl ())) = [] &&&\n    list_R1_to_list (list_R1 (Inr (x, xs))) = x # list_R1_to_list xs", "by(simp_all split: unit.split)"], ["", "declare list_R1_to_list.simps [simp del]"], ["", "primrec (transfer) list_to_list_R1 :: \"'a list \\<Rightarrow> 'a list_R1\" where\n  \"list_to_list_R1 [] = list_R1 (Inl ())\"\n| \"list_to_list_R1 (x#xs) = list_R1 (Inr (x, list_to_list_R1 xs))\""], ["", "lemma R1_of_list: \"list_R1_to_list (list_to_list_R1 x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1_to_list (list_to_list_R1 x) = x", "by(induct x) (auto)"], ["", "lemma list_of_R1: \"list_to_list_R1 (list_R1_to_list x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_to_list_R1 (list_R1_to_list x) = x", "apply(induct x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>xaa xaaa.\n           \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa\\<rbrakk>\n           \\<Longrightarrow> list_to_list_R1 (list_R1_to_list xaaa) =\n                             xaaa) \\<Longrightarrow>\n       list_to_list_R1 (list_R1_to_list (list_R1 xa)) = list_R1 xa", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xaa xaaa.\n        \\<lbrakk>xaa \\<in> setr x; xaaa \\<in> snds xaa\\<rbrakk>\n        \\<Longrightarrow> list_to_list_R1 (list_R1_to_list xaaa) =\n                          xaaa) \\<Longrightarrow>\n    list_to_list_R1 (list_R1_to_list (list_R1 x)) = list_R1 x", "by(cases x) (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_R1_def: \"type_definition list_to_list_R1 list_R1_to_list UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition list_to_list_R1 list_R1_to_list UNIV", "by(unfold_locales)(auto intro: R1_of_list list_of_R1)"], ["", "setup_lifting list_R1_def"], ["", "lemma map_list_R1_list_to_list_R1: \"map_list_R1 f (list_to_list_R1 xs) = list_to_list_R1 (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_list_R1 f (list_to_list_R1 xs) = list_to_list_R1 (map f xs)", "by(induction xs) auto"], ["", "lemma list_R1_map_trans [transfer_rule]: includes lifting_syntax shows\n  \"(((=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=)) map_list_R1 map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=)) map_list_R1 map", "by(auto 4 3 simp add: list.pcr_cr_eq rel_fun_eq cr_list_def map_list_R1_list_to_list_R1)"], ["", "lemma set_list_R1_list_to_list_R1: \"set_list_R1 (list_to_list_R1 xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_list_R1 (list_to_list_R1 xs) = set xs", "by(induction xs) auto"], ["", "lemma list_R1_set_trans [transfer_rule]: includes lifting_syntax shows\n  \"(pcr_list (=) ===> (=)) set_list_R1 set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_list (=) ===> (=)) set_list_R1 set", "by(auto simp add: list.pcr_cr_eq cr_list_def set_list_R1_list_to_list_R1)"], ["", "lemma rel_list_R1_list_to_list_R1:\n   \"rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys) \\<longleftrightarrow> list_all2 R xs ys\"\n  (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys) =\n    list_all2 R xs ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rel_list_R1 R (list_to_list_R1 xs)\n     (list_to_list_R1 ys) \\<Longrightarrow>\n    list_all2 R xs ys\n 2. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "define xs' and ys' where \"xs' = list_to_list_R1 xs\" and \"ys' = list_to_list_R1 ys\""], ["proof (state)\nthis:\n  xs' = list_to_list_R1 xs\n  ys' = list_to_list_R1 ys\n\ngoal (2 subgoals):\n 1. rel_list_R1 R (list_to_list_R1 xs)\n     (list_to_list_R1 ys) \\<Longrightarrow>\n    list_all2 R xs ys\n 2. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "assume \"rel_list_R1 R xs' ys'\""], ["proof (state)\nthis:\n  rel_list_R1 R xs' ys'\n\ngoal (2 subgoals):\n 1. rel_list_R1 R (list_to_list_R1 xs)\n     (list_to_list_R1 ys) \\<Longrightarrow>\n    list_all2 R xs ys\n 2. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "then"], ["proof (chain)\npicking this:\n  rel_list_R1 R xs' ys'", "have \"list_all2 R (list_R1_to_list xs') (list_R1_to_list ys')\""], ["proof (prove)\nusing this:\n  rel_list_R1 R xs' ys'\n\ngoal (1 subgoal):\n 1. list_all2 R (list_R1_to_list xs') (list_R1_to_list ys')", "by induction(auto elim!: rel_sum.cases)"], ["proof (state)\nthis:\n  list_all2 R (list_R1_to_list xs') (list_R1_to_list ys')\n\ngoal (2 subgoals):\n 1. rel_list_R1 R (list_to_list_R1 xs)\n     (list_to_list_R1 ys) \\<Longrightarrow>\n    list_all2 R xs ys\n 2. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "thus ?rhs"], ["proof (prove)\nusing this:\n  list_all2 R (list_R1_to_list xs') (list_R1_to_list ys')\n\ngoal (1 subgoal):\n 1. list_all2 R xs ys", "by(simp add: xs'_def ys'_def R1_of_list)"], ["proof (state)\nthis:\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2 R xs ys \\<Longrightarrow>\n    rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "using that"], ["proof (prove)\nusing this:\n  list_all2 R xs ys\n\ngoal (1 subgoal):\n 1. rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)", "by induction auto"], ["proof (state)\nthis:\n  list_all2 R xs ys \\<Longrightarrow>\n  rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_R1_rel_trans[transfer_rule]: includes lifting_syntax shows\n  \"(((=) ===> (=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=) ===> (=)) rel_list_R1 list_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (=) ===> (=)) ===> pcr_list (=) ===> pcr_list (=) ===> (=))\n     rel_list_R1 list_all2", "by(auto 4 4 simp add: list.pcr_cr_eq rel_fun_eq cr_list_def rel_list_R1_list_to_list_R1)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "type_synonym ('a\\<^sub>h, 'b\\<^sub>h) list_F\\<^sub>h = \"unit +\\<^sub>h 'a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h\""], ["", "type_synonym ('a\\<^sub>m, 'b\\<^sub>m) list_F\\<^sub>m = \"unit +\\<^sub>m 'a\\<^sub>m \\<times>\\<^sub>m 'b\\<^sub>m\""], ["", "type_synonym 'a\\<^sub>h list_R1\\<^sub>h = \"'a\\<^sub>h list_R1\" \n  \\<comment> \\<open>In theory, we should define a separate datatype here of the functor @{typ \"('a\\<^sub>h, _) list_F\\<^sub>h\"}.\n    We take a shortcut because they're isomorphic.\\<close>"], ["", "type_synonym 'a\\<^sub>m list_R1\\<^sub>m = \"'a\\<^sub>m list_R1\"\n  \\<comment> \\<open>In theory, we should define a separate datatype here of the functor @{typ \"('a\\<^sub>m, _) list_F\\<^sub>m\"}.\n    We take a shortcut because they're isomorphic.\\<close>"], ["", "definition hash_F :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> (('a\\<^sub>m, 'b\\<^sub>m) list_F\\<^sub>m, ('a\\<^sub>h, 'b\\<^sub>h) list_F\\<^sub>h) hash\" where \n  \"hash_F h rhL = hash_sum hash_unit (hash_prod h rhL)\""], ["", "abbreviation (input) hash_R1 :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('a\\<^sub>m list_R1\\<^sub>m, 'a\\<^sub>h list_R1\\<^sub>h) hash\" where\n  \"hash_R1 \\<equiv> map_list_R1\""], ["", "parametric_constant hash_F_parametric[transfer_rule]: hash_F_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "definition blinding_of_F :: \"'a\\<^sub>m blinding_of \\<Rightarrow> 'b\\<^sub>m blinding_of \\<Rightarrow> ('a\\<^sub>m, 'b\\<^sub>m) list_F\\<^sub>m blinding_of\" where\n  \"blinding_of_F bo bL = blinding_of_sum blinding_of_unit (blinding_of_prod bo bL)\""], ["", "abbreviation (input) blinding_of_R1 :: \"'a blinding_of \\<Rightarrow> 'a list_R1 blinding_of\" where\n  \"blinding_of_R1 \\<equiv> rel_list_R1\""], ["", "lemma blinding_of_hash_R1:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_R1 bo \\<le> vimage2p (hash_R1 h) (hash_R1 h) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)", "apply(rule predicate2I vimage2pI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_list_R1 bo x y \\<Longrightarrow>\n       map_list_R1 h x = map_list_R1 h y", "apply(auto simp add: predicate2D_vimage2p[OF assms] elim!: list_R1.rel_induct rel_sum.cases rel_prod.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blinding_of_on_R1 [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set_list_R1 x \\<subseteq> A} (hash_R1 h) (blinding_of_R1 bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo)", "interpret a: blinding_of_on A h bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A h bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n 2. \\<And>x.\n       x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n       rel_list_R1 bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show hash: \"?bo \\<le> vimage2p ?h ?h (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)", "using a.hash"], ["proof (prove)\nusing this:\n  bo \\<le> vimage2p h h (=)\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)", "by(rule blinding_of_hash_R1)"], ["proof (state)\nthis:\n  rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n       rel_list_R1 bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"?bo x x \\<and> (?bo x y \\<longrightarrow> ?bo y z \\<longrightarrow> ?bo x z) \\<and> (?bo x y \\<longrightarrow> ?bo y x \\<longrightarrow> x = y)\" if \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo x x \\<and>\n    (rel_list_R1 bo x y \\<longrightarrow>\n     rel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo x z) \\<and>\n    (rel_list_R1 bo x y \\<longrightarrow>\n     rel_list_R1 bo y x \\<longrightarrow> x = y)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo x x \\<and>\n    (rel_list_R1 bo x y \\<longrightarrow>\n     rel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo x z) \\<and>\n    (rel_list_R1 bo x y \\<longrightarrow>\n     rel_list_R1 bo y x \\<longrightarrow> x = y)", "proof(induction x arbitrary: y z)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa y z.\n                   \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa;\n                    xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> rel_list_R1 bo xaaa xaaa \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo xaaa z) \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y xaaa \\<longrightarrow> xaaa = y);\n        list_R1 xa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo (list_R1 xa) (list_R1 xa) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y z \\<longrightarrow>\n                          rel_list_R1 bo (list_R1 xa) z) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y (list_R1 xa) \\<longrightarrow>\n                          list_R1 xa = y)", "case (list_R1 x y' z')"], ["proof (state)\nthis:\n  \\<lbrakk>?xaa \\<in> setr x; ?xaaa \\<in> snds ?xaa;\n   ?xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo ?xaaa ?xaaa \\<and>\n                    (rel_list_R1 bo ?xaaa ?y \\<longrightarrow>\n                     rel_list_R1 bo ?y ?z \\<longrightarrow>\n                     rel_list_R1 bo ?xaaa ?z) \\<and>\n                    (rel_list_R1 bo ?xaaa ?y \\<longrightarrow>\n                     rel_list_R1 bo ?y ?xaaa \\<longrightarrow> ?xaaa = ?y)\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa y z.\n                   \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa;\n                    xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> rel_list_R1 bo xaaa xaaa \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo xaaa z) \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y xaaa \\<longrightarrow> xaaa = y);\n        list_R1 xa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo (list_R1 xa) (list_R1 xa) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y z \\<longrightarrow>\n                          rel_list_R1 bo (list_R1 xa) z) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y (list_R1 xa) \\<longrightarrow>\n                          list_R1 xa = y)", "from list_R1.prems"], ["proof (chain)\npicking this:\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}", "have s1: \"set_base_F\\<^sub>m x \\<subseteq> A\""], ["proof (prove)\nusing this:\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. setr x \\<bind> fsts \\<subseteq> A", "by(fastforce)"], ["proof (state)\nthis:\n  setr x \\<bind> fsts \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa y z.\n                   \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa;\n                    xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> rel_list_R1 bo xaaa xaaa \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo xaaa z) \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y xaaa \\<longrightarrow> xaaa = y);\n        list_R1 xa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo (list_R1 xa) (list_R1 xa) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y z \\<longrightarrow>\n                          rel_list_R1 bo (list_R1 xa) z) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y (list_R1 xa) \\<longrightarrow>\n                          list_R1 xa = y)", "from list_R1.prems"], ["proof (chain)\npicking this:\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}", "have s3: \"set_rec_F\\<^sub>m x \\<bind> set_list_R1 \\<subseteq> A\""], ["proof (prove)\nusing this:\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. setr x \\<bind> snds \\<bind> set_list_R1 \\<subseteq> A", "by(fastforce intro: rev_bexI)"], ["proof (state)\nthis:\n  setr x \\<bind> snds \\<bind> set_list_R1 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa y z.\n                   \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa;\n                    xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> rel_list_R1 bo xaaa xaaa \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo xaaa z) \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y xaaa \\<longrightarrow> xaaa = y);\n        list_R1 xa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo (list_R1 xa) (list_R1 xa) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y z \\<longrightarrow>\n                          rel_list_R1 bo (list_R1 xa) z) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y (list_R1 xa) \\<longrightarrow>\n                          list_R1 xa = y)", "interpret F: blinding_of_on \"{y. set_base_F\\<^sub>m y \\<subseteq> A \\<and> set_rec_F\\<^sub>m y \\<subseteq> set_rec_F\\<^sub>m x}\"\n        \"hash_F h (hash_R1 h)\" \"blinding_of_F bo (blinding_of_R1 bo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on\n     {y. setr y \\<bind> fsts \\<subseteq> A \\<and>\n         setr y \\<bind> snds \\<subseteq> setr x \\<bind> snds}\n     (hash_F h (map_list_R1 h)) (blinding_of_F bo (rel_list_R1 bo))", "unfolding hash_F_def blinding_of_F_def set_list_R1_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on\n     {y. setl y \\<subseteq> UNIV \\<and>\n         setr y\n         \\<subseteq> {y. fsts y \\<subseteq> A \\<and>\n                         snds y \\<subseteq> setr x \\<bind> snds}}\n     (map_sum id (map_prod h (map_list_R1 h)))\n     (rel_sum (=) (rel_prod bo (rel_list_R1 bo)))", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n 2. \\<And>x.\n       x \\<in> setr x \\<bind> snds \\<Longrightarrow> rel_list_R1 bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> x = y", "let ?A' = \"setr x \\<bind> snds\" and ?bo' = \"rel_list_R1 bo\""], ["proof (state)\ngoal (4 subgoals):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n 2. \\<And>x.\n       x \\<in> setr x \\<bind> snds \\<Longrightarrow> rel_list_R1 bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo' x x\" if \"x \\<in> ?A'\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo x x", "using that list_R1"], ["proof (prove)\nusing this:\n  x \\<in> setr xa__ \\<bind> snds\n  \\<lbrakk>?xaa \\<in> setr xa__; ?xaaa \\<in> snds ?xaa;\n   ?xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo ?xaaa ?xaaa \\<and>\n                    (rel_list_R1 bo ?xaaa ?y \\<longrightarrow>\n                     rel_list_R1 bo ?y ?z \\<longrightarrow>\n                     rel_list_R1 bo ?xaaa ?z) \\<and>\n                    (rel_list_R1 bo ?xaaa ?y \\<longrightarrow>\n                     rel_list_R1 bo ?y ?xaaa \\<longrightarrow> ?xaaa = ?y)\n  list_R1 xa__ \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo x x", "by(force simp add: eq_onp_def)"], ["proof (state)\nthis:\n  ?x \\<in> setr x \\<bind> snds \\<Longrightarrow> rel_list_R1 bo ?x ?x\n\ngoal (3 subgoals):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo' x z\" if \"?bo' x y\" \"?bo' y z\" \"x \\<in> ?A'\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo x z", "using that list_R1.IH[of _ x y z] list_R1.prems"], ["proof (prove)\nusing this:\n  rel_list_R1 bo x y\n  rel_list_R1 bo y z\n  x \\<in> setr xa__ \\<bind> snds\n  \\<lbrakk>?xaa \\<in> setr xa__; x \\<in> snds ?xaa;\n   x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo x x \\<and>\n                    (rel_list_R1 bo x y \\<longrightarrow>\n                     rel_list_R1 bo y z \\<longrightarrow>\n                     rel_list_R1 bo x z) \\<and>\n                    (rel_list_R1 bo x y \\<longrightarrow>\n                     rel_list_R1 bo y x \\<longrightarrow> x = y)\n  list_R1 xa__ \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo x z", "by(force simp add: bind_UNION prod_set_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_list_R1 bo ?x ?y; rel_list_R1 bo ?y ?z;\n   ?x \\<in> setr x \\<bind> snds\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo ?x ?z\n\ngoal (2 subgoals):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)\n 2. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> setr x \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\" if \"?bo' x y\" \"?bo' y x\" \"x \\<in> ?A'\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that list_R1.IH[of _ x y] list_R1.prems"], ["proof (prove)\nusing this:\n  rel_list_R1 bo x y\n  rel_list_R1 bo y x\n  x \\<in> setr xa__ \\<bind> snds\n  \\<lbrakk>?xaa \\<in> setr xa__; x \\<in> snds ?xaa;\n   x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo x x \\<and>\n                    (rel_list_R1 bo x y \\<longrightarrow>\n                     rel_list_R1 bo y ?z \\<longrightarrow>\n                     rel_list_R1 bo x ?z) \\<and>\n                    (rel_list_R1 bo x y \\<longrightarrow>\n                     rel_list_R1 bo y x \\<longrightarrow> x = y)\n  list_R1 xa__ \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. x = y", "by(force simp add: prod_set_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_list_R1 bo ?x ?y; rel_list_R1 bo ?y ?x;\n   ?x \\<in> setr x \\<bind> snds\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo \\<le> vimage2p (map_list_R1 h) (map_list_R1 h) (=)", "qed(rule hash)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa y z.\n                   \\<lbrakk>xaa \\<in> setr xa; xaaa \\<in> snds xaa;\n                    xaaa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> rel_list_R1 bo xaaa xaaa \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y z \\<longrightarrow> rel_list_R1 bo xaaa z) \\<and>\n                                     (rel_list_R1 bo xaaa\n y \\<longrightarrow>\nrel_list_R1 bo y xaaa \\<longrightarrow> xaaa = y);\n        list_R1 xa \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo (list_R1 xa) (list_R1 xa) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y z \\<longrightarrow>\n                          rel_list_R1 bo (list_R1 xa) z) \\<and>\n                         (rel_list_R1 bo (list_R1 xa) y \\<longrightarrow>\n                          rel_list_R1 bo y (list_R1 xa) \\<longrightarrow>\n                          list_R1 xa = y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_list_R1 bo (list_R1 x) (list_R1 x) \\<and>\n    (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n     rel_list_R1 bo y' z' \\<longrightarrow>\n     rel_list_R1 bo (list_R1 x) z') \\<and>\n    (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n     rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y')", "using list_R1.prems"], ["proof (prove)\nusing this:\n  list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_list_R1 bo (list_R1 x) (list_R1 x) \\<and>\n    (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n     rel_list_R1 bo y' z' \\<longrightarrow>\n     rel_list_R1 bo (list_R1 x) z') \\<and>\n    (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n     rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y')", "apply(intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) (list_R1 x)\n 2. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' z' \\<longrightarrow> rel_list_R1 bo (list_R1 x) z'\n 3. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) (list_R1 x)", "using F.refl[of x] s1"], ["proof (prove)\nusing this:\n  x \\<in> {y. setr y \\<bind> fsts \\<subseteq> A \\<and>\n              setr y \\<bind> snds\n              \\<subseteq> setr x \\<bind> snds} \\<Longrightarrow>\n  blinding_of_F bo (rel_list_R1 bo) x x\n  setr x \\<bind> fsts \\<subseteq> A\n\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) (list_R1 x)", "unfolding blinding_of_F_def"], ["proof (prove)\nusing this:\n  x \\<in> {y. setr y \\<bind> fsts \\<subseteq> A \\<and>\n              setr y \\<bind> snds\n              \\<subseteq> setr x \\<bind> snds} \\<Longrightarrow>\n  rel_sum (=) (rel_prod bo (rel_list_R1 bo)) x x\n  setr x \\<bind> fsts \\<subseteq> A\n\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) (list_R1 x)", "by(auto intro: list_R1.rel_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' z' \\<longrightarrow> rel_list_R1 bo (list_R1 x) z'\n 2. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' z' \\<longrightarrow> rel_list_R1 bo (list_R1 x) z'", "using s1"], ["proof (prove)\nusing this:\n  setr x \\<bind> fsts \\<subseteq> A\n\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' z' \\<longrightarrow> rel_list_R1 bo (list_R1 x) z'", "by(auto elim!: list_R1.rel_cases F.trans[unfolded blinding_of_F_def] intro: list_R1.rel_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y'", "using s1"], ["proof (prove)\nusing this:\n  setr x \\<bind> fsts \\<subseteq> A\n\ngoal (1 subgoal):\n 1. list_R1 x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n    rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n    rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y'", "by(auto elim!: list_R1.rel_cases dest: F.antisym[unfolded blinding_of_F_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_list_R1 bo (list_R1 x) (list_R1 x) \\<and>\n  (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n   rel_list_R1 bo y' z' \\<longrightarrow>\n   rel_list_R1 bo (list_R1 x) z') \\<and>\n  (rel_list_R1 bo (list_R1 x) y' \\<longrightarrow>\n   rel_list_R1 bo y' (list_R1 x) \\<longrightarrow> list_R1 x = y')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  rel_list_R1 bo ?x ?x \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?z \\<longrightarrow> rel_list_R1 bo ?x ?z) \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?x \\<longrightarrow> ?x = ?y)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n       rel_list_R1 bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_list_R1 bo x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n        x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  rel_list_R1 bo ?x ?x \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?z \\<longrightarrow> rel_list_R1 bo ?x ?z) \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?x \\<longrightarrow> ?x = ?y)", "show \"x \\<in> ?A \\<Longrightarrow> ?bo x x\" \n      and \"\\<lbrakk> ?bo x y; ?bo y z; x \\<in> ?A \\<rbrakk> \\<Longrightarrow> ?bo x z\"\n      and \"\\<lbrakk> ?bo x y; ?bo y x; x \\<in> ?A \\<rbrakk> \\<Longrightarrow> x = y\"\n      for x y z"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  rel_list_R1 bo ?x ?x \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?z \\<longrightarrow> rel_list_R1 bo ?x ?z) \\<and>\n  (rel_list_R1 bo ?x ?y \\<longrightarrow>\n   rel_list_R1 bo ?y ?x \\<longrightarrow> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n     rel_list_R1 bo x x) &&&\n    (\\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y z;\n      x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n     \\<Longrightarrow> rel_list_R1 bo x z) &&&\n    (\\<lbrakk>rel_list_R1 bo x y; rel_list_R1 bo y x;\n      x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n     \\<Longrightarrow> x = y)", "by blast+"], ["proof (state)\nthis:\n  ?x \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  rel_list_R1 bo ?x ?x\n  \\<lbrakk>rel_list_R1 bo ?x ?y; rel_list_R1 bo ?y ?z;\n   ?x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_list_R1 bo ?x ?z\n  \\<lbrakk>rel_list_R1 bo ?x ?y; rel_list_R1 bo ?y ?x;\n   ?x \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  blinding_of_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n   (rel_list_R1 bo)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_R1 [locale_witness] = blinding_of_on_R1[where A=UNIV, simplified]"], ["", "parametric_constant blinding_of_F_parametric[transfer_rule]: blinding_of_F_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "definition merge_F :: \"'a\\<^sub>m merge \\<Rightarrow> 'b\\<^sub>m merge \\<Rightarrow> ('a\\<^sub>m, 'b\\<^sub>m) list_F\\<^sub>m merge\" where \n  \"merge_F m mL = merge_sum merge_unit (merge_prod m mL)\""], ["", "lemma merge_F_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set_base_F\\<^sub>m x; b \\<in> set_base_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> set_rec_F\\<^sub>m x; b \\<in> set_rec_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> mL a b = mL' a b\"\n  shows \"merge_F m mL x y = merge_F m' mL' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_F m mL x y = merge_F m' mL' x y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> setr x \\<bind> fsts;\n   ?b \\<in> setr y \\<bind> fsts\\<rbrakk>\n  \\<Longrightarrow> m ?a ?b = m' ?a ?b\n  \\<lbrakk>?a \\<in> setr x \\<bind> snds;\n   ?b \\<in> setr y \\<bind> snds\\<rbrakk>\n  \\<Longrightarrow> mL ?a ?b = mL' ?a ?b\n\ngoal (1 subgoal):\n 1. merge_F m mL x y = merge_F m' mL' x y", "apply(cases x; cases y)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n                    b \\<in> setr y \\<bind> fsts\\<rbrakk>\n                   \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        x = Inl a;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n            b \\<in> setr y \\<bind> fsts\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> merge_F m mL x y = merge_F m' mL' x y\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n                    b \\<in> setr y \\<bind> fsts\\<rbrakk>\n                   \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        x = Inl a;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n            b \\<in> setr y \\<bind> fsts\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        y = Inr b\\<rbrakk>\n       \\<Longrightarrow> merge_F m mL x y = merge_F m' mL' x y\n 3. \\<And>b a.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n                    b \\<in> setr y \\<bind> fsts\\<rbrakk>\n                   \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        x = Inr b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n            b \\<in> setr y \\<bind> fsts\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        y = Inl a\\<rbrakk>\n       \\<Longrightarrow> merge_F m mL x y = merge_F m' mL' x y\n 4. \\<And>b ba.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n                    b \\<in> setr y \\<bind> fsts\\<rbrakk>\n                   \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        x = Inr b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> fsts;\n            b \\<in> setr y \\<bind> fsts\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> setr x \\<bind> snds;\n            b \\<in> setr y \\<bind> snds\\<rbrakk>\n           \\<Longrightarrow> mL a b = mL' a b;\n        y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> merge_F m mL x y = merge_F m' mL' x y", "apply(simp_all add: merge_F_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba.\n       \\<lbrakk>x = Inr b;\n        \\<And>a bb.\n           \\<lbrakk>a \\<in> fsts b; bb \\<in> fsts ba\\<rbrakk>\n           \\<Longrightarrow> m a bb = m' a bb;\n        \\<And>a bb.\n           \\<lbrakk>a \\<in> snds b; bb \\<in> snds ba\\<rbrakk>\n           \\<Longrightarrow> mL a bb = mL' a bb;\n        y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> map_option Inr (merge_prod m mL b ba) =\n                         map_option Inr (merge_prod m' mL' b ba)", "apply(rule arg_cong[where f=\"map_option _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba.\n       \\<lbrakk>x = Inr b;\n        \\<And>a bb.\n           \\<lbrakk>a \\<in> fsts b; bb \\<in> fsts ba\\<rbrakk>\n           \\<Longrightarrow> m a bb = m' a bb;\n        \\<And>a bb.\n           \\<lbrakk>a \\<in> snds b; bb \\<in> snds ba\\<rbrakk>\n           \\<Longrightarrow> mL a bb = mL' a bb;\n        y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> merge_prod m mL b ba = merge_prod m' mL' b ba", "apply(blast intro: merge_prod_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes m :: \"'a\\<^sub>m merge\" \n  notes setr.simps[simp]\nbegin"], ["", "fun merge_R1 :: \"'a\\<^sub>m list_R1\\<^sub>m merge\" where\n  \"merge_R1 (list_R1 l1) (list_R1 l2) = map_option list_R1 (merge_F m merge_R1 l1 l2)\""], ["", "end"], ["", "case_of_simps merge_cases [simp]: merge_R1.simps"], ["", "lemma merge_on_R1:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set_list_R1 x \\<subseteq> A } (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo) (merge_R1 m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo) (merge_R1 m)", "interpret a: merge_on A h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A h bo m", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo) (merge_R1 m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h)\n     (rel_list_R1 bo) (merge_R1 m)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "have \"(?h a = ?h b \\<longrightarrow> (\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u))) \\<and>\n      (?h a \\<noteq> ?h b \\<longrightarrow> ?m a b = None)\"\n      if \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_R1 m a b = Some ab \\<and>\n         rel_list_R1 bo a ab \\<and>\n         rel_list_R1 bo b ab \\<and>\n         (\\<forall>u.\n             rel_list_R1 bo a u \\<longrightarrow>\n             rel_list_R1 bo b u \\<longrightarrow>\n             rel_list_R1 bo ab u))) \\<and>\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<longrightarrow>\n     merge_R1 m a b = None)", "using that"], ["proof (prove)\nusing this:\n  a \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_R1 m a b = Some ab \\<and>\n         rel_list_R1 bo a ab \\<and>\n         rel_list_R1 bo b ab \\<and>\n         (\\<forall>u.\n             rel_list_R1 bo a u \\<longrightarrow>\n             rel_list_R1 bo b u \\<longrightarrow>\n             rel_list_R1 bo ab u))) \\<and>\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<longrightarrow>\n     merge_R1 m a b = None)", "unfolding mem_Collect_eq"], ["proof (prove)\nusing this:\n  set_list_R1 a \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_R1 m a b = Some ab \\<and>\n         rel_list_R1 bo a ab \\<and>\n         rel_list_R1 bo b ab \\<and>\n         (\\<forall>u.\n             rel_list_R1 bo a u \\<longrightarrow>\n             rel_list_R1 bo b u \\<longrightarrow>\n             rel_list_R1 bo ab u))) \\<and>\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<longrightarrow>\n     merge_R1 m a b = None)", "proof(induction a arbitrary: b rule: list_R1_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F b.\n       \\<lbrakk>\\<And>l' b.\n                   \\<lbrakk>l' \\<in> setr F \\<bind> snds;\n                    set_list_R1 l' \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (map_list_R1 h l' =\nmap_list_R1 h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_R1 m l' b = Some ab \\<and>\n    rel_list_R1 bo l' ab \\<and>\n    rel_list_R1 bo b ab \\<and>\n    (\\<forall>u.\n        rel_list_R1 bo l' u \\<longrightarrow>\n        rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u))) \\<and>\n                                     (map_list_R1 h l' \\<noteq>\nmap_list_R1 h b \\<longrightarrow>\nmerge_R1 m l' b = None);\n        set_list_R1 (list_R1 F) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (map_list_R1 h (list_R1 F) =\n                          map_list_R1 h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_R1 m (list_R1 F) b = Some ab \\<and>\n                              rel_list_R1 bo (list_R1 F) ab \\<and>\n                              rel_list_R1 bo b ab \\<and>\n                              (\\<forall>u.\n                                  rel_list_R1 bo (list_R1 F)\n                                   u \\<longrightarrow>\n                                  rel_list_R1 bo b u \\<longrightarrow>\n                                  rel_list_R1 bo ab u))) \\<and>\n                         (map_list_R1 h (list_R1 F) \\<noteq>\n                          map_list_R1 h b \\<longrightarrow>\n                          merge_R1 m (list_R1 F) b = None)", "case wfInd: (list_R1 l)"], ["proof (state)\nthis:\n  \\<lbrakk>?l'3 \\<in> setr l \\<bind> snds;\n   set_list_R1 ?l'3 \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (map_list_R1 h ?l'3 =\n                     map_list_R1 h ?b3 \\<longrightarrow>\n                     (\\<exists>ab.\n                         merge_R1 m ?l'3 ?b3 = Some ab \\<and>\n                         rel_list_R1 bo ?l'3 ab \\<and>\n                         rel_list_R1 bo ?b3 ab \\<and>\n                         (\\<forall>u.\n                             rel_list_R1 bo ?l'3 u \\<longrightarrow>\n                             rel_list_R1 bo ?b3 u \\<longrightarrow>\n                             rel_list_R1 bo ab u))) \\<and>\n                    (map_list_R1 h ?l'3 \\<noteq>\n                     map_list_R1 h ?b3 \\<longrightarrow>\n                     merge_R1 m ?l'3 ?b3 = None)\n  set_list_R1 (list_R1 l) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>F b.\n       \\<lbrakk>\\<And>l' b.\n                   \\<lbrakk>l' \\<in> setr F \\<bind> snds;\n                    set_list_R1 l' \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (map_list_R1 h l' =\nmap_list_R1 h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_R1 m l' b = Some ab \\<and>\n    rel_list_R1 bo l' ab \\<and>\n    rel_list_R1 bo b ab \\<and>\n    (\\<forall>u.\n        rel_list_R1 bo l' u \\<longrightarrow>\n        rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u))) \\<and>\n                                     (map_list_R1 h l' \\<noteq>\nmap_list_R1 h b \\<longrightarrow>\nmerge_R1 m l' b = None);\n        set_list_R1 (list_R1 F) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (map_list_R1 h (list_R1 F) =\n                          map_list_R1 h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_R1 m (list_R1 F) b = Some ab \\<and>\n                              rel_list_R1 bo (list_R1 F) ab \\<and>\n                              rel_list_R1 bo b ab \\<and>\n                              (\\<forall>u.\n                                  rel_list_R1 bo (list_R1 F)\n                                   u \\<longrightarrow>\n                                  rel_list_R1 bo b u \\<longrightarrow>\n                                  rel_list_R1 bo ab u))) \\<and>\n                         (map_list_R1 h (list_R1 F) \\<noteq>\n                          map_list_R1 h b \\<longrightarrow>\n                          merge_R1 m (list_R1 F) b = None)", "interpret merge_on \"{y. set_base_F\\<^sub>m y \\<subseteq> A \\<and> set_rec_F\\<^sub>m y \\<subseteq> set_rec_F\\<^sub>m l}\"\n        \"hash_F h ?h\" \"blinding_of_F bo ?bo\" \"merge_F m ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on\n     {y. setr y \\<bind> fsts \\<subseteq> A \\<and>\n         setr y \\<bind> snds \\<subseteq> setr l \\<bind> snds}\n     (hash_F h (map_list_R1 h)) (blinding_of_F bo (rel_list_R1 bo))\n     (merge_F m (merge_R1 m))", "unfolding set_list_R1_eq hash_F_def merge_F_def blinding_of_F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on\n     {y. setl y \\<subseteq> UNIV \\<and>\n         setr y\n         \\<subseteq> {y. fsts y \\<subseteq> A \\<and>\n                         snds y \\<subseteq> setr l \\<bind> snds}}\n     (map_sum id (map_prod h (map_list_R1 h)))\n     (rel_sum (=) (rel_prod bo (rel_list_R1 bo)))\n     (merge_sum merge_unit (merge_prod m (merge_R1 m)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "assume a: \"a \\<in> set_rec_F\\<^sub>m l\""], ["proof (state)\nthis:\n  a \\<in> setr l \\<bind> snds\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "with wfInd.prems"], ["proof (chain)\npicking this:\n  set_list_R1 (list_R1 l) \\<subseteq> A\n  a \\<in> setr l \\<bind> snds", "have a': \"set_list_R1 a \\<subseteq> A\""], ["proof (prove)\nusing this:\n  set_list_R1 (list_R1 l) \\<subseteq> A\n  a \\<in> setr l \\<bind> snds\n\ngoal (1 subgoal):\n 1. set_list_R1 a \\<subseteq> A", "by fastforce"], ["proof (state)\nthis:\n  set_list_R1 a \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> setr l \\<bind> snds\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "show \"hash_R1 h a = hash_R1 h b\n           \\<Longrightarrow> \\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and>\n                    (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n          and \"?h a \\<noteq> ?h b \\<Longrightarrow> ?m a b = None\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_R1 m a b = Some ab \\<and>\n        rel_list_R1 bo a ab \\<and>\n        rel_list_R1 bo b ab \\<and>\n        (\\<forall>u.\n            rel_list_R1 bo a u \\<longrightarrow>\n            rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u)) &&&\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<Longrightarrow>\n     merge_R1 m a b = None)", "using wfInd.IH[OF a a', rule_format, of b]"], ["proof (prove)\nusing this:\n  (map_list_R1 h a = map_list_R1 h b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m a b = Some ab \\<and>\n       rel_list_R1 bo a ab \\<and>\n       rel_list_R1 bo b ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo a u \\<longrightarrow>\n           rel_list_R1 bo b u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h a \\<noteq> map_list_R1 h b \\<longrightarrow>\n   merge_R1 m a b = None)\n\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_R1 m a b = Some ab \\<and>\n        rel_list_R1 bo a ab \\<and>\n        rel_list_R1 bo b ab \\<and>\n        (\\<forall>u.\n            rel_list_R1 bo a u \\<longrightarrow>\n            rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u)) &&&\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<Longrightarrow>\n     merge_R1 m a b = None)", "by(auto dest: sym)"], ["proof (state)\nthis:\n  map_list_R1 h a = map_list_R1 h ?b3 \\<Longrightarrow>\n  \\<exists>ab.\n     merge_R1 m a ?b3 = Some ab \\<and>\n     rel_list_R1 bo a ab \\<and>\n     rel_list_R1 bo ?b3 ab \\<and>\n     (\\<forall>u.\n         rel_list_R1 bo a u \\<longrightarrow>\n         rel_list_R1 bo ?b3 u \\<longrightarrow> rel_list_R1 bo ab u)\n  map_list_R1 h a \\<noteq> map_list_R1 h ?b3 \\<Longrightarrow>\n  merge_R1 m a ?b3 = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F b.\n       \\<lbrakk>\\<And>l' b.\n                   \\<lbrakk>l' \\<in> setr F \\<bind> snds;\n                    set_list_R1 l' \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (map_list_R1 h l' =\nmap_list_R1 h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_R1 m l' b = Some ab \\<and>\n    rel_list_R1 bo l' ab \\<and>\n    rel_list_R1 bo b ab \\<and>\n    (\\<forall>u.\n        rel_list_R1 bo l' u \\<longrightarrow>\n        rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u))) \\<and>\n                                     (map_list_R1 h l' \\<noteq>\nmap_list_R1 h b \\<longrightarrow>\nmerge_R1 m l' b = None);\n        set_list_R1 (list_R1 F) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (map_list_R1 h (list_R1 F) =\n                          map_list_R1 h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_R1 m (list_R1 F) b = Some ab \\<and>\n                              rel_list_R1 bo (list_R1 F) ab \\<and>\n                              rel_list_R1 bo b ab \\<and>\n                              (\\<forall>u.\n                                  rel_list_R1 bo (list_R1 F)\n                                   u \\<longrightarrow>\n                                  rel_list_R1 bo b u \\<longrightarrow>\n                                  rel_list_R1 bo ab u))) \\<and>\n                         (map_list_R1 h (list_R1 F) \\<noteq>\n                          map_list_R1 h b \\<longrightarrow>\n                          merge_R1 m (list_R1 F) b = None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_list_R1 h (list_R1 l) = map_list_R1 h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_R1 m (list_R1 l) b = Some ab \\<and>\n         rel_list_R1 bo (list_R1 l) ab \\<and>\n         rel_list_R1 bo b ab \\<and>\n         (\\<forall>u.\n             rel_list_R1 bo (list_R1 l) u \\<longrightarrow>\n             rel_list_R1 bo b u \\<longrightarrow>\n             rel_list_R1 bo ab u))) \\<and>\n    (map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b \\<longrightarrow>\n     merge_R1 m (list_R1 l) b = None)", "using wfInd.prems"], ["proof (prove)\nusing this:\n  set_list_R1 (list_R1 l) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (map_list_R1 h (list_R1 l) = map_list_R1 h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_R1 m (list_R1 l) b = Some ab \\<and>\n         rel_list_R1 bo (list_R1 l) ab \\<and>\n         rel_list_R1 bo b ab \\<and>\n         (\\<forall>u.\n             rel_list_R1 bo (list_R1 l) u \\<longrightarrow>\n             rel_list_R1 bo b u \\<longrightarrow>\n             rel_list_R1 bo ab u))) \\<and>\n    (map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b \\<longrightarrow>\n     merge_R1 m (list_R1 l) b = None)", "apply(intro conjI strip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set_list_R1 (list_R1 l) \\<subseteq> A;\n     map_list_R1 h (list_R1 l) = map_list_R1 h b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ab.\n                         merge_R1 m (list_R1 l) b = Some ab \\<and>\n                         rel_list_R1 bo (list_R1 l) ab \\<and>\n                         rel_list_R1 bo b ab \\<and>\n                         (\\<forall>u.\n                             rel_list_R1 bo (list_R1 l) u \\<longrightarrow>\n                             rel_list_R1 bo b u \\<longrightarrow>\n                             rel_list_R1 bo ab u)\n 2. \\<lbrakk>set_list_R1 (list_R1 l) \\<subseteq> A;\n     map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b\\<rbrakk>\n    \\<Longrightarrow> merge_R1 m (list_R1 l) b = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_list_R1 (list_R1 l) \\<subseteq> A;\n     map_list_R1 h (list_R1 l) = map_list_R1 h b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ab.\n                         merge_R1 m (list_R1 l) b = Some ab \\<and>\n                         rel_list_R1 bo (list_R1 l) ab \\<and>\n                         rel_list_R1 bo b ab \\<and>\n                         (\\<forall>u.\n                             rel_list_R1 bo (list_R1 l) u \\<longrightarrow>\n                             rel_list_R1 bo b u \\<longrightarrow>\n                             rel_list_R1 bo ab u)", "by(auto 4 4 dest!: join[unfolded hash_F_def]\n              simp add: blinding_of_F_def UN_subset_iff list_R1.rel_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_list_R1 (list_R1 l) \\<subseteq> A;\n     map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b\\<rbrakk>\n    \\<Longrightarrow> merge_R1 m (list_R1 l) b = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_list_R1 (list_R1 l) \\<subseteq> A;\n     map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b\\<rbrakk>\n    \\<Longrightarrow> merge_R1 m (list_R1 l) b = None", "by(auto 4 3 intro!: undefined[simplified hash_F_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (map_list_R1 h (list_R1 l) = map_list_R1 h b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m (list_R1 l) b = Some ab \\<and>\n       rel_list_R1 bo (list_R1 l) ab \\<and>\n       rel_list_R1 bo b ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo (list_R1 l) u \\<longrightarrow>\n           rel_list_R1 bo b u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h (list_R1 l) \\<noteq> map_list_R1 h b \\<longrightarrow>\n   merge_R1 m (list_R1 l) b = None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a3 \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  (map_list_R1 h ?a3 = map_list_R1 h ?b3 \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m ?a3 ?b3 = Some ab \\<and>\n       rel_list_R1 bo ?a3 ab \\<and>\n       rel_list_R1 bo ?b3 ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo ?a3 u \\<longrightarrow>\n           rel_list_R1 bo ?b3 u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h ?a3 \\<noteq> map_list_R1 h ?b3 \\<longrightarrow>\n   merge_R1 m ?a3 ?b3 = None)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a = map_list_R1 h b;\n        a \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_R1 m a b = Some ab \\<and>\n                            rel_list_R1 bo a ab \\<and>\n                            rel_list_R1 bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_list_R1 bo a u \\<longrightarrow>\n                                rel_list_R1 bo b u \\<longrightarrow>\n                                rel_list_R1 bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>map_list_R1 h a \\<noteq> map_list_R1 h b;\n        a \\<in> {x. set_list_R1 x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m a b = None", "then"], ["proof (chain)\npicking this:\n  ?a3 \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  (map_list_R1 h ?a3 = map_list_R1 h ?b3 \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m ?a3 ?b3 = Some ab \\<and>\n       rel_list_R1 bo ?a3 ab \\<and>\n       rel_list_R1 bo ?b3 ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo ?a3 u \\<longrightarrow>\n           rel_list_R1 bo ?b3 u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h ?a3 \\<noteq> map_list_R1 h ?b3 \\<longrightarrow>\n   merge_R1 m ?a3 ?b3 = None)", "show\n      \"?h a = ?h b \\<Longrightarrow> \\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n      \"?h a \\<noteq> ?h b \\<Longrightarrow> ?m a b = None\"\n      if \"a \\<in> ?A\" for a b"], ["proof (prove)\nusing this:\n  ?a3 \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  (map_list_R1 h ?a3 = map_list_R1 h ?b3 \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m ?a3 ?b3 = Some ab \\<and>\n       rel_list_R1 bo ?a3 ab \\<and>\n       rel_list_R1 bo ?b3 ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo ?a3 u \\<longrightarrow>\n           rel_list_R1 bo ?b3 u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h ?a3 \\<noteq> map_list_R1 h ?b3 \\<longrightarrow>\n   merge_R1 m ?a3 ?b3 = None)\n\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_R1 m a b = Some ab \\<and>\n        rel_list_R1 bo a ab \\<and>\n        rel_list_R1 bo b ab \\<and>\n        (\\<forall>u.\n            rel_list_R1 bo a u \\<longrightarrow>\n            rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u)) &&&\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<Longrightarrow>\n     merge_R1 m a b = None)", "using that"], ["proof (prove)\nusing this:\n  ?a3 \\<in> {x. set_list_R1 x \\<subseteq> A} \\<Longrightarrow>\n  (map_list_R1 h ?a3 = map_list_R1 h ?b3 \\<longrightarrow>\n   (\\<exists>ab.\n       merge_R1 m ?a3 ?b3 = Some ab \\<and>\n       rel_list_R1 bo ?a3 ab \\<and>\n       rel_list_R1 bo ?b3 ab \\<and>\n       (\\<forall>u.\n           rel_list_R1 bo ?a3 u \\<longrightarrow>\n           rel_list_R1 bo ?b3 u \\<longrightarrow>\n           rel_list_R1 bo ab u))) \\<and>\n  (map_list_R1 h ?a3 \\<noteq> map_list_R1 h ?b3 \\<longrightarrow>\n   merge_R1 m ?a3 ?b3 = None)\n  a \\<in> {x. set_list_R1 x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. (map_list_R1 h a = map_list_R1 h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_R1 m a b = Some ab \\<and>\n        rel_list_R1 bo a ab \\<and>\n        rel_list_R1 bo b ab \\<and>\n        (\\<forall>u.\n            rel_list_R1 bo a u \\<longrightarrow>\n            rel_list_R1 bo b u \\<longrightarrow> rel_list_R1 bo ab u)) &&&\n    (map_list_R1 h a \\<noteq> map_list_R1 h b \\<Longrightarrow>\n     merge_R1 m a b = None)", "by blast+"], ["proof (state)\nthis:\n  \\<lbrakk>?a3 \\<in> {x. set_list_R1 x \\<subseteq> A};\n   map_list_R1 h ?a3 = map_list_R1 h ?b3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       merge_R1 m ?a3 ?b3 = Some ab \\<and>\n                       rel_list_R1 bo ?a3 ab \\<and>\n                       rel_list_R1 bo ?b3 ab \\<and>\n                       (\\<forall>u.\n                           rel_list_R1 bo ?a3 u \\<longrightarrow>\n                           rel_list_R1 bo ?b3 u \\<longrightarrow>\n                           rel_list_R1 bo ab u)\n  \\<lbrakk>?a3 \\<in> {x. set_list_R1 x \\<subseteq> A};\n   map_list_R1 h ?a3 \\<noteq> map_list_R1 h ?b3\\<rbrakk>\n  \\<Longrightarrow> merge_R1 m ?a3 ?b3 = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. set_list_R1 x \\<subseteq> A} (map_list_R1 h) (rel_list_R1 bo)\n   (merge_R1 m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_R1 [locale_witness] = merge_on_R1[where A=UNIV, simplified]"], ["", "lemma merkle_list_R1 [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)", "interpret merge_on UNIV h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "using assms"], ["proof (prove)\nusing this:\n  merkle_interface h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "by(unfold merkle_interface_aux)"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)", ".."], ["proof (state)\nthis:\n  merkle_interface (map_list_R1 h) (rel_list_R1 bo) (merge_R1 m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_R1_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set_list_R1 x; b \\<in> set_list_R1 y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_R1 m x y = merge_R1 m' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_R1 m x y = merge_R1 m' x y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a3 \\<in> set_list_R1 x; ?b3 \\<in> set_list_R1 y\\<rbrakk>\n  \\<Longrightarrow> m ?a3 ?b3 = m' ?a3 ?b3\n\ngoal (1 subgoal):\n 1. merge_R1 m x y = merge_R1 m' x y", "apply(induction x y rule: merge_R1.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> setr l1 \\<bind> snds;\n                    b \\<in> setr l2 \\<bind> snds;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set_list_R1 a;\n                        ba \\<in> set_list_R1 b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_R1 m a b = merge_R1 m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set_list_R1 (list_R1 l1);\n            b \\<in> set_list_R1 (list_R1 l2)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> merge_R1 m (list_R1 l1) (list_R1 l2) =\n                         merge_R1 m' (list_R1 l1) (list_R1 l2)", "apply(simp del: merge_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>\\<exists>x\\<in>setr l1. a \\<in> snds x;\n                    \\<exists>x\\<in>setr l2. b \\<in> snds x;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set_list_R1 a;\n                        ba \\<in> set_list_R1 b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_R1 m a b = merge_R1 m' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>setr l1.\n                       a \\<in> fsts x \\<or>\n                       (\\<exists>x\\<in>snds x. a \\<in> set_list_R1 x);\n            \\<exists>x\\<in>setr l2.\n               b \\<in> fsts x \\<or>\n               (\\<exists>x\\<in>snds x. b \\<in> set_list_R1 x)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> map_option list_R1 (merge_F m (merge_R1 m) l1 l2) =\n                         map_option list_R1 (merge_F m' (merge_R1 m') l1 l2)", "apply(rule arg_cong[where f=\"map_option _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 l2.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>\\<exists>x\\<in>setr l1. a \\<in> snds x;\n                    \\<exists>x\\<in>setr l2. b \\<in> snds x;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set_list_R1 a;\n                        ba \\<in> set_list_R1 b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_R1 m a b = merge_R1 m' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>setr l1.\n                       a \\<in> fsts x \\<or>\n                       (\\<exists>x\\<in>snds x. a \\<in> set_list_R1 x);\n            \\<exists>x\\<in>setr l2.\n               b \\<in> fsts x \\<or>\n               (\\<exists>x\\<in>snds x. b \\<in> set_list_R1 x)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> merge_F m (merge_R1 m) l1 l2 =\n                         merge_F m' (merge_R1 m') l1 l2", "apply(blast intro: merge_F_cong[unfolded bind_UNION])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "parametric_constant merge_F_parametric[transfer_rule]: merge_F_def"], ["", "lemma merge_R1_parametric [transfer_rule]:\n  includes lifting_syntax \n  notes [simp del] = merge_cases\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"((A ===> A ===> rel_option A) ===> rel_list_R1 A ===> rel_list_R1 A ===> rel_option (rel_list_R1 A))\n   merge_R1 merge_R1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> rel_option A) ===>\n     rel_list_R1 A ===> rel_list_R1 A ===> rel_option (rel_list_R1 A))\n     merge_R1 merge_R1", "apply(intro rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> rel_option A) x y; rel_list_R1 A xa ya;\n        rel_list_R1 A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_list_R1 A) (merge_R1 x xa xb)\n                          (merge_R1 y ya yb)", "subgoal premises prems [transfer_rule] for m1 m2 xs1 xs2 ys1 ys2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_list_R1 A) (merge_R1 m1 xs1 ys1) (merge_R1 m2 xs2 ys2)", "using prems(2, 3)"], ["proof (prove)\nusing this:\n  rel_list_R1 A xs1 xs2\n  rel_list_R1 A ys1 ys2\n\ngoal (1 subgoal):\n 1. rel_option (rel_list_R1 A) (merge_R1 m1 xs1 ys1) (merge_R1 m2 xs2 ys2)", "apply(induction xs1 ys1 arbitrary: xs2 ys2 rule: merge_R1.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l1 l2 xs2 ys2.\n       \\<lbrakk>\\<And>a b xs2 ys2.\n                   \\<lbrakk>a \\<in> setr l1 \\<bind> snds;\n                    b \\<in> setr l2 \\<bind> snds; rel_list_R1 A a xs2;\n                    rel_list_R1 A b ys2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (rel_list_R1 A)\n(merge_R1 m1 a b) (merge_R1 m2 xs2 ys2);\n        rel_list_R1 A (list_R1 l1) xs2;\n        rel_list_R1 A (list_R1 l2) ys2\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_list_R1 A)\n                          (merge_R1 m1 (list_R1 l1) (list_R1 l2))\n                          (merge_R1 m2 xs2 ys2)", "apply(elim list_R1.rel_cases rel_sum.cases; clarsimp simp add: option.rel_map merge_F_def merge_discrete_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>\\<And>a ba xs2 ys2.\n                   \\<lbrakk>a = b; ba = bb; rel_list_R1 A b xs2;\n                    rel_list_R1 A bb ys2\\<rbrakk>\n                   \\<Longrightarrow> rel_option (rel_list_R1 A)\n(merge_R1 m1 b bb) (merge_R1 m2 xs2 ys2);\n        A a aa; rel_list_R1 A b ba; A ab ac; rel_list_R1 A bb bc\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod A (rel_list_R1 A))\n                          (m1 a ab \\<bind>\n                           (\\<lambda>x''.\n                               map_option (Pair x'') (merge_R1 m1 b bb)))\n                          (m2 aa ac \\<bind>\n                           (\\<lambda>x''.\n                               map_option (Pair x'') (merge_R1 m2 ba bc)))", "apply(elim meta_allE; (erule meta_impE, simp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>A a aa; rel_list_R1 A b ba; A ab ac; rel_list_R1 A bb bc;\n        rel_option (rel_list_R1 A) (merge_R1 m1 b bb)\n         (merge_R1 m2 ba bc)\\<rbrakk>\n       \\<Longrightarrow> rel_option (rel_prod A (rel_list_R1 A))\n                          (m1 a ab \\<bind>\n                           (\\<lambda>x''.\n                               map_option (Pair x'') (merge_R1 m1 b bb)))\n                          (m2 aa ac \\<bind>\n                           (\\<lambda>x''.\n                               map_option (Pair x'') (merge_R1 m2 ba bc)))", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_prod A (rel_list_R1 A))\n     (m1 a_ ab_ \\<bind>\n      (\\<lambda>x''. map_option (Pair x'') (merge_R1 m1 b_ bb_)))\n     (m2 aa_ ac_ \\<bind>\n      (\\<lambda>x''. map_option (Pair x'') (merge_R1 m2 ba_ bc_)))", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open> Transferring the Constructions to Lists \\<close>"], ["", "type_synonym 'a\\<^sub>h list\\<^sub>h = \"'a\\<^sub>h list\""], ["", "type_synonym 'a\\<^sub>m list\\<^sub>m = \"'a\\<^sub>m list\""], ["", "context begin"], ["", "interpretation list_R1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation (input) hash_list :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('a\\<^sub>m list\\<^sub>m, 'a\\<^sub>h list\\<^sub>h) hash\"\n  where \"hash_list \\<equiv> map\""], ["", "abbreviation (input) blinding_of_list :: \"'a\\<^sub>m blinding_of \\<Rightarrow> 'a\\<^sub>m list\\<^sub>m blinding_of\"\n  where \"blinding_of_list \\<equiv> list_all2\""], ["", "lift_definition merge_list :: \"'a\\<^sub>m merge \\<Rightarrow> 'a\\<^sub>m list\\<^sub>m merge\" is merge_R1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma blinding_of_list_mono:\n  \"\\<lbrakk> \\<And>x y. bo x y \\<longrightarrow> bo' x y \\<rbrakk> \\<Longrightarrow> \n  blinding_of_list bo x y \\<longrightarrow> blinding_of_list bo' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. bo x y \\<longrightarrow> bo' x y) \\<Longrightarrow>\n    list_all2 bo x y \\<longrightarrow> list_all2 bo' x y", "by (transfer) (blast intro: list_R1.rel_mono_strong)"], ["", "lemmas blinding_of_list_hash = blinding_of_hash_R1[Transfer.transferred]\n  and blinding_of_on_list [locale_witness] = blinding_of_on_R1[Transfer.transferred]\n  and blinding_of_list [locale_witness] = blinding_of_R1[Transfer.transferred]\n  and merge_on_list [locale_witness] = merge_on_R1[Transfer.transferred]\n  and merge_list [locale_witness] = merge_R1[Transfer.transferred]\n  and merge_list_cong = merge_R1_cong[Transfer.transferred]"], ["", "lemma blinding_of_list_mono_pred:\n  \"R \\<le> R' \\<Longrightarrow> blinding_of_list R \\<le> blinding_of_list R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> R' \\<Longrightarrow> list_all2 R \\<le> list_all2 R'", "by(transfer) (rule list_R1.rel_mono)"], ["", "lemma blinding_of_list_simp: \"blinding_of_list = list_all2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 = list_all2", "by(transfer) (rule refl)"], ["", "lemma merkle_list [locale_witness]:\n  assumes [locale_witness]: \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_list h) (blinding_of_list bo) (merge_list m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (map h) (list_all2 bo) (merge_list m)", "by(transfer fixing: h bo m) unfold_locales"], ["", "parametric_constant merge_list_parametric [transfer_rule]: merge_list_def"], ["", "lifting_update list.lifting"], ["", "lifting_forget list.lifting"], ["", "end"], ["", "(************************************************************)"], ["", "subsection \\<open>Building block: function space\\<close>"], ["", "(************************************************************)"], ["", "text \\<open> We prove that we can lift the ADS construction through functions.\\<close>"], ["", "type_synonym ('a, 'b\\<^sub>h) fun\\<^sub>h = \"'a \\<Rightarrow> 'b\\<^sub>h\""], ["", "type_notation fun\\<^sub>h (infixr \"\\<Rightarrow>\\<^sub>h\" 0)"], ["", "type_synonym ('a, 'b\\<^sub>m) fun\\<^sub>m = \"'a \\<Rightarrow> 'b\\<^sub>m\""], ["", "type_notation fun\\<^sub>m (infixr \"\\<Rightarrow>\\<^sub>m\" 0)"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "text \\<open> Only the range is live, the domain is dead like for BNFs. \\<close>"], ["", "abbreviation (input) hash_fun' :: \"('a \\<Rightarrow>\\<^sub>m 'b\\<^sub>h, 'a \\<Rightarrow>\\<^sub>h 'b\\<^sub>h) hash\" where\n  \"hash_fun' \\<equiv> id\""], ["", "abbreviation (input) hash_fun :: \"('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>m 'b\\<^sub>m, 'a \\<Rightarrow>\\<^sub>h 'b\\<^sub>h) hash\"\n  where \"hash_fun \\<equiv> comp\""], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) blinding_of_fun :: \"'b\\<^sub>m blinding_of \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>m 'b\\<^sub>m) blinding_of\" where\n  \"blinding_of_fun \\<equiv> rel_fun (=)\""], ["", "lemmas blinding_of_fun_mono = fun.rel_mono"], ["", "lemma blinding_of_fun_hash:\n  assumes \"bo \\<le> vimage2p rh rh (=)\"\n  shows \"blinding_of_fun bo \\<le> vimage2p (hash_fun rh) (hash_fun rh) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)", "using assms"], ["proof (prove)\nusing this:\n  bo \\<le> vimage2p rh rh (=)\n\ngoal (1 subgoal):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)", "by(auto simp add: vimage2p_def rel_fun_def le_fun_def)"], ["", "lemma blinding_of_on_fun [locale_witness]:\n  assumes \"blinding_of_on A rh bo\"\n  shows \"blinding_of_on {x. range x \\<subseteq> A} (hash_fun rh) (blinding_of_fun bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. range x \\<subseteq> A} ((\\<circ>) rh)\n     (rel_fun (=) bo)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. range x \\<subseteq> A} ((\\<circ>) rh)\n     (rel_fun (=) bo)", "interpret a: blinding_of_on A rh bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A rh bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. range x \\<subseteq> A} ((\\<circ>) rh)\n     (rel_fun (=) bo)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. range x \\<subseteq> A} ((\\<circ>) rh)\n     (rel_fun (=) bo)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)\n 2. \\<And>x.\n       x \\<in> {x. range x \\<subseteq> A} \\<Longrightarrow>\n       rel_fun (=) bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>rel_fun (=) bo x y; rel_fun (=) bo y z;\n        x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_fun (=) bo x z\n 4. \\<And>x y.\n       \\<lbrakk>rel_fun (=) bo x y; rel_fun (=) bo y x;\n        x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x x\" if \"x \\<in> ?A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) bo x x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. range x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_fun (=) bo x x", "by(auto simp add: rel_fun_def intro: a.refl)"], ["proof (state)\nthis:\n  ?x \\<in> {x. range x \\<subseteq> A} \\<Longrightarrow> rel_fun (=) bo ?x ?x\n\ngoal (3 subgoals):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_fun (=) bo x y; rel_fun (=) bo y z;\n        x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> rel_fun (=) bo x z\n 3. \\<And>x y.\n       \\<lbrakk>rel_fun (=) bo x y; rel_fun (=) bo y x;\n        x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo x z\" if \"?bo x y\" \"?bo y z\" \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=) bo x z", "using that"], ["proof (prove)\nusing this:\n  rel_fun (=) bo x y\n  rel_fun (=) bo y z\n  x \\<in> {x. range x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. rel_fun (=) bo x z", "by(auto 4 3 simp add: rel_fun_def intro: a.trans)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_fun (=) bo ?x ?y; rel_fun (=) bo ?y ?z;\n   ?x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> rel_fun (=) bo ?x ?z\n\ngoal (2 subgoals):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)\n 2. \\<And>x y.\n       \\<lbrakk>rel_fun (=) bo x y; rel_fun (=) bo y x;\n        x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\" if \"?bo x y\" \"?bo y x\" \"x \\<in> ?A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  rel_fun (=) bo x y\n  rel_fun (=) bo y x\n  x \\<in> {x. range x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. x = y", "by(fastforce simp add: fun_eq_iff rel_fun_def intro: a.antisym)"], ["proof (state)\nthis:\n  \\<lbrakk>rel_fun (=) bo ?x ?y; rel_fun (=) bo ?y ?x;\n   ?x \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. rel_fun (=) bo \\<le> vimage2p ((\\<circ>) rh) ((\\<circ>) rh) (=)", "qed(rule blinding_of_fun_hash a.hash)+"], ["proof (state)\nthis:\n  blinding_of_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_fun [locale_witness] = blinding_of_on_fun[where A=UNIV, simplified]"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "context\n  fixes m :: \"'b\\<^sub>m merge\"\nbegin"], ["", "definition merge_fun :: \"('a \\<Rightarrow>\\<^sub>m 'b\\<^sub>m) merge\" where\n  \"merge_fun f g = (if \\<forall>x. m (f x) (g x) \\<noteq> None then Some (\\<lambda>x. the (m (f x) (g x))) else None)\""], ["", "lemma merge_on_fun [locale_witness]:\n  assumes \"merge_on A rh bo m\"\n  shows \"merge_on {x. range x \\<subseteq> A} (hash_fun rh) (blinding_of_fun bo) merge_fun\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n     local.merge_fun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n     local.merge_fun", "interpret a: merge_on A rh bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A rh bo m", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n     local.merge_fun", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n     local.merge_fun", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>rh \\<circ> a = rh \\<circ> b;\n        a \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            local.merge_fun a b = Some ab \\<and>\n                            rel_fun (=) bo a ab \\<and>\n                            rel_fun (=) bo b ab \\<and>\n                            (\\<forall>u.\n                                rel_fun (=) bo a u \\<longrightarrow>\n                                rel_fun (=) bo b u \\<longrightarrow>\n                                rel_fun (=) bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>rh \\<circ> a \\<noteq> rh \\<circ> b;\n        a \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> local.merge_fun a b = None", "show \"\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n      if \"?h a = ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_fun a b = Some ab \\<and>\n       rel_fun (=) bo a ab \\<and>\n       rel_fun (=) bo b ab \\<and>\n       (\\<forall>u.\n           rel_fun (=) bo a u \\<longrightarrow>\n           rel_fun (=) bo b u \\<longrightarrow> rel_fun (=) bo ab u)", "using that(1)[THEN fun_cong, unfolded o_apply, THEN a.join, OF that(2)[unfolded mem_Collect_eq, THEN subsetD, OF rangeI]]"], ["proof (prove)\nusing this:\n  \\<exists>ab.\n     m (a ?x1) (b ?x1) = Some ab \\<and>\n     bo (a ?x1) ab \\<and>\n     bo (b ?x1) ab \\<and>\n     (\\<forall>u.\n         bo (a ?x1) u \\<longrightarrow>\n         bo (b ?x1) u \\<longrightarrow> bo ab u)\n\ngoal (1 subgoal):\n 1. \\<exists>ab.\n       local.merge_fun a b = Some ab \\<and>\n       rel_fun (=) bo a ab \\<and>\n       rel_fun (=) bo b ab \\<and>\n       (\\<forall>u.\n           rel_fun (=) bo a u \\<longrightarrow>\n           rel_fun (=) bo b u \\<longrightarrow> rel_fun (=) bo ab u)", "by atomize(subst (asm) choice_iff; auto simp add: merge_fun_def rel_fun_def)"], ["proof (state)\nthis:\n  \\<lbrakk>rh \\<circ> ?a1 = rh \\<circ> ?b1;\n   ?a1 \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       local.merge_fun ?a1 ?b1 = Some ab \\<and>\n                       rel_fun (=) bo ?a1 ab \\<and>\n                       rel_fun (=) bo ?b1 ab \\<and>\n                       (\\<forall>u.\n                           rel_fun (=) bo ?a1 u \\<longrightarrow>\n                           rel_fun (=) bo ?b1 u \\<longrightarrow>\n                           rel_fun (=) bo ab u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>rh \\<circ> a \\<noteq> rh \\<circ> b;\n        a \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> local.merge_fun a b = None", "show \"?m a b = None\" if \"?h a \\<noteq> ?h b\" \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.merge_fun a b = None", "using that"], ["proof (prove)\nusing this:\n  rh \\<circ> a \\<noteq> rh \\<circ> b\n  a \\<in> {x. range x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. local.merge_fun a b = None", "by(auto simp add: merge_fun_def fun_eq_iff dest: a.undefined)"], ["proof (state)\nthis:\n  \\<lbrakk>rh \\<circ> ?a1 \\<noteq> rh \\<circ> ?b1;\n   ?a1 \\<in> {x. range x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> local.merge_fun ?a1 ?b1 = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. range x \\<subseteq> A} ((\\<circ>) rh) (rel_fun (=) bo)\n   local.merge_fun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_fun [locale_witness] = merge_on_fun[where A=UNIV, simplified]"], ["", "end"], ["", "lemma merge_fun_cong[fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> range f; b \\<in> range g \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_fun m f g = merge_fun m' f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_fun m f g = merge_fun m' f g", "using assms[OF rangeI rangeI]"], ["proof (prove)\nusing this:\n  m (f ?x2) (g ?x1) = m' (f ?x2) (g ?x1)\n\ngoal (1 subgoal):\n 1. merge_fun m f g = merge_fun m' f g", "by(clarsimp simp add: merge_fun_def)"], ["", "lemma is_none_alt_def: \"Option.is_none x \\<longleftrightarrow> (case x of None \\<Rightarrow> True | Some _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Option.is_none x =\n    (case x of None \\<Rightarrow> True | Some x \\<Rightarrow> False)", "by(auto simp add: Option.is_none_def split: option.splits)"], ["", "parametric_constant is_none_parametric [transfer_rule]: is_none_alt_def"], ["", "lemma merge_fun_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> B ===> rel_option C) ===> ((=) ===> A) ===> ((=) ===> B) ===> rel_option ((=) ===> C))\n   merge_fun merge_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B ===> rel_option C) ===>\n     ((=) ===> A) ===> ((=) ===> B) ===> rel_option ((=) ===> C))\n     merge_fun merge_fun", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "fix m :: \"'a merge\" and m' :: \"'b merge\" and f :: \"'c \\<Rightarrow> 'a\" and f' :: \"'c \\<Rightarrow> 'b\" and g :: \"'c \\<Rightarrow> 'a\" and g' :: \"'c \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "assume m: \"(A ===> B ===> rel_option C) m m'\"\n    and f: \"((=) ===> A) f f'\" and g: \"((=) ===> B) g g'\""], ["proof (state)\nthis:\n  (A ===> B ===> rel_option C) m m'\n  ((=) ===> A) f f'\n  ((=) ===> B) g g'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  (A ===> B ===> rel_option C) m m'\n  ((=) ===> A) f f'\n  ((=) ===> B) g g'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "have cond [unfolded Option.is_none_def]: \"(\\<forall>x. \\<not> Option.is_none (m (f x) (g x))) \\<longleftrightarrow> (\\<forall>x. \\<not> Option.is_none (m' (f' x) (g' x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<not> Option.is_none (m (f x) (g x))) =\n    (\\<forall>x. \\<not> Option.is_none (m' (f' x) (g' x)))", "by transfer_prover"], ["proof (state)\nthis:\n  (\\<forall>x. m (f x) (g x) \\<noteq> None) =\n  (\\<forall>x. m' (f' x) (g' x) \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x. m (f x) (g x) \\<noteq> None) =\n  (\\<forall>x. m' (f' x) (g' x) \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "have \"((=) ===> C) (\\<lambda>x. the (m (f x) (g x))) (\\<lambda>x. the (m' (f' x) (g' x)))\" if *: \"\\<forall>x. \\<not> m (f x) (g x) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n     (\\<lambda>x. the (m' (f' x) (g' x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n     (\\<lambda>x. the (m' (f' x) (g' x)))", "obtain fg fg' where m: \"m (f x) (g x) = Some (fg x)\" and m': \"m' (f' x) (g' x) = Some (fg' x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fg fg'.\n        \\<lbrakk>\\<And>x. m (f x) (g x) = Some (fg x);\n         \\<And>x. m' (f' x) (g' x) = Some (fg' x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using * *[simplified cond]"], ["proof (prove)\nusing this:\n  \\<forall>x. m (f x) (g x) \\<noteq> None\n  \\<forall>x. m' (f' x) (g' x) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>fg fg'.\n        \\<lbrakk>\\<And>x. m (f x) (g x) = Some (fg x);\n         \\<And>x. m' (f' x) (g' x) = Some (fg' x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp)(subst (asm) (1 2) choice_iff; clarsimp)"], ["proof (state)\nthis:\n  m (f ?x) (g ?x) = Some (fg ?x)\n  m' (f' ?x) (g' ?x) = Some (fg' ?x)\n\ngoal (1 subgoal):\n 1. ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n     (\\<lambda>x. the (m' (f' x) (g' x)))", "have \"rel_option C (Some (fg x)) (Some (fg' x))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option C (Some (fg x)) (Some (fg' x))", "unfolding m[symmetric] m'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option C (m (f x) (g x)) (m' (f' x) (g' x))", "by transfer_prover"], ["proof (state)\nthis:\n  rel_option C (Some (fg ?x)) (Some (fg' ?x))\n\ngoal (1 subgoal):\n 1. ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n     (\\<lambda>x. the (m' (f' x) (g' x)))", "then"], ["proof (chain)\npicking this:\n  rel_option C (Some (fg ?x)) (Some (fg' ?x))", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_option C (Some (fg ?x)) (Some (fg' ?x))\n\ngoal (1 subgoal):\n 1. ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n     (\\<lambda>x. the (m' (f' x) (g' x)))", "by(simp add: rel_fun_def m m')"], ["proof (state)\nthis:\n  ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n   (\\<lambda>x. the (m' (f' x) (g' x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. m (f x) (g x) \\<noteq> None \\<Longrightarrow>\n  ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n   (\\<lambda>x. the (m' (f' x) (g' x)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> B ===> rel_option C) x y; ((=) ===> A) xa ya;\n        ((=) ===> B) xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_option ((=) ===> C) (merge_fun x xa xb)\n                          (merge_fun y ya yb)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x. m (f x) (g x) \\<noteq> None) =\n  (\\<forall>x. m' (f' x) (g' x) \\<noteq> None)\n  \\<forall>x. m (f x) (g x) \\<noteq> None \\<Longrightarrow>\n  ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n   (\\<lambda>x. the (m' (f' x) (g' x)))", "show \"rel_option ((=) ===> C) (merge_fun m f g) (merge_fun m' f' g')\""], ["proof (prove)\nusing this:\n  (\\<forall>x. m (f x) (g x) \\<noteq> None) =\n  (\\<forall>x. m' (f' x) (g' x) \\<noteq> None)\n  \\<forall>x. m (f x) (g x) \\<noteq> None \\<Longrightarrow>\n  ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n   (\\<lambda>x. the (m' (f' x) (g' x)))\n\ngoal (1 subgoal):\n 1. rel_option ((=) ===> C) (merge_fun m f g) (merge_fun m' f' g')", "unfolding merge_fun_def"], ["proof (prove)\nusing this:\n  (\\<forall>x. m (f x) (g x) \\<noteq> None) =\n  (\\<forall>x. m' (f' x) (g' x) \\<noteq> None)\n  \\<forall>x. m (f x) (g x) \\<noteq> None \\<Longrightarrow>\n  ((=) ===> C) (\\<lambda>x. the (m (f x) (g x)))\n   (\\<lambda>x. the (m' (f' x) (g' x)))\n\ngoal (1 subgoal):\n 1. rel_option ((=) ===> C)\n     (if \\<forall>x. m (f x) (g x) \\<noteq> None\n      then Some (\\<lambda>x. the (m (f x) (g x))) else None)\n     (if \\<forall>x. m' (f' x) (g' x) \\<noteq> None\n      then Some (\\<lambda>x. the (m' (f' x) (g' x))) else None)", "by(simp)"], ["proof (state)\nthis:\n  rel_option ((=) ===> C) (merge_fun m f g) (merge_fun m' f' g')\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merkle Interface \\<close>"], ["", "(************************************************************)"], ["", "lemma merkle_fun [locale_witness]:\n  assumes \"merkle_interface rh bo m\"\n  shows \"merkle_interface (hash_fun rh) (blinding_of_fun bo) (merge_fun m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)", "interpret a: merge_on UNIV rh bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV rh bo m", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface rh bo m", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)", ".."], ["proof (state)\nthis:\n  merkle_interface ((\\<circ>) rh) (rel_fun (=) bo) (merge_fun m)\n\ngoal:\nNo subgoals!", "qed"], ["", "(************************************************************)"], ["", "subsection \\<open>Rose trees\\<close>"], ["", "(************************************************************)"], ["", "text \\<open> \nWe now define an ADS over rose trees, which is like a arbitrarily branching Merkle tree where each\nnode in the tree can be blinded, including the root. The number of children and the position of a\nchild among its siblings cannot be hidden. The construction allows to plug in further blindable\npositions in the labels of the nodes.\n\\<close>"], ["", "type_synonym ('a, 'b) rose_tree_F = \"'a \\<times> 'b list\""], ["", "abbreviation (input) map_rose_tree_F where\n  \"map_rose_tree_F f1 f2 \\<equiv> map_prod f1 (map f2)\""], ["", "definition map_rose_tree_F_const where\n  \"map_rose_tree_F_const f1 f2 \\<equiv> map_rose_tree_F f1 f2\""], ["", "datatype 'a rose_tree = Tree \"('a, 'a rose_tree) rose_tree_F\""], ["", "type_synonym ('a\\<^sub>h, 'b\\<^sub>h) rose_tree_F\\<^sub>h = \"('a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h list\\<^sub>h) blindable\\<^sub>h\""], ["", "datatype 'a\\<^sub>h rose_tree\\<^sub>h = Tree\\<^sub>h \"('a\\<^sub>h, 'a\\<^sub>h rose_tree\\<^sub>h) rose_tree_F\\<^sub>h\""], ["", "type_synonym ('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>m, 'b\\<^sub>h) rose_tree_F\\<^sub>m = \"('a\\<^sub>m \\<times>\\<^sub>m 'b\\<^sub>m list\\<^sub>m, 'a\\<^sub>h \\<times>\\<^sub>h 'b\\<^sub>h list\\<^sub>h) blindable\\<^sub>m\""], ["", "datatype ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m = Tree\\<^sub>m \"('a\\<^sub>m, 'a\\<^sub>h, ('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m, 'a\\<^sub>h rose_tree\\<^sub>h) rose_tree_F\\<^sub>m\""], ["", "abbreviation (input) map_rose_tree_F\\<^sub>m\n  :: \"('ma \\<Rightarrow> 'a) \\<Rightarrow> ('mr \\<Rightarrow> 'r) \\<Rightarrow> ('ma, 'ha, 'mr, 'hr) rose_tree_F\\<^sub>m \\<Rightarrow> ('a, 'ha, 'r, 'hr) rose_tree_F\\<^sub>m\"\n  where\n  \"map_rose_tree_F\\<^sub>m f g \\<equiv> map_blindable\\<^sub>m (map_prod f (map g)) id\""], ["", "(************************************************************)"], ["", "subsubsection \\<open> Hashes \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) hash_rt_F' \n  :: \"(('a\\<^sub>h, 'a\\<^sub>h, 'b\\<^sub>h, 'b\\<^sub>h) rose_tree_F\\<^sub>m, ('a\\<^sub>h, 'b\\<^sub>h) rose_tree_F\\<^sub>h) hash\"\n  where\n  \"hash_rt_F' \\<equiv> hash_blindable id\""], ["", "definition hash_rt_F\\<^sub>m\n  :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> \n    (('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>m, 'b\\<^sub>h) rose_tree_F\\<^sub>m, ('a\\<^sub>h, 'b\\<^sub>h) rose_tree_F\\<^sub>h) hash\" where\n  \"hash_rt_F\\<^sub>m h rhm \\<equiv> hash_rt_F' o map_rose_tree_F\\<^sub>m h rhm\""], ["", "lemma hash_rt_F\\<^sub>m_alt_def: \"hash_rt_F\\<^sub>m h rhm = hash_blindable (map_prod h (map rhm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_rt_F\\<^sub>m h rhm = hash_blindable (map_prod h (map rhm))", "by(simp add: hash_rt_F\\<^sub>m_def fun_eq_iff hash_map_blindable_simp)"], ["", "primrec (transfer) hash_rt_tree'\n  :: \"(('a\\<^sub>h, 'a\\<^sub>h) rose_tree\\<^sub>m, 'a\\<^sub>h rose_tree\\<^sub>h) hash\" where\n  \"hash_rt_tree' (Tree\\<^sub>m x) = Tree\\<^sub>h (hash_rt_F' (map_rose_tree_F\\<^sub>m id hash_rt_tree' x))\""], ["", "definition hash_tree\n  :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> (('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m, 'a\\<^sub>h rose_tree\\<^sub>h) hash\" where\n  \"hash_tree h = hash_rt_tree' o map_rose_tree\\<^sub>m h id\""], ["", "lemma blindable\\<^sub>m_map_compositionality:\n  \"map_blindable\\<^sub>m f g o map_blindable\\<^sub>m f' g' = map_blindable\\<^sub>m (f o f') (g o g')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_blindable\\<^sub>m f g \\<circ> map_blindable\\<^sub>m f' g' =\n    map_blindable\\<^sub>m (f \\<circ> f') (g \\<circ> g')", "by(rule ext) (simp add: blindable\\<^sub>m.map_comp)"], ["", "lemma hash_tree_simps [simp]:\n  \"hash_tree h (Tree\\<^sub>m x) = Tree\\<^sub>h (hash_rt_F\\<^sub>m h (hash_tree h) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_tree h (Tree\\<^sub>m x) =\n    Tree\\<^sub>h (hash_rt_F\\<^sub>m h (hash_tree h) x)", "by(simp add: hash_tree_def hash_rt_F\\<^sub>m_def \n      map_prod.comp map_sum.comp rose_tree\\<^sub>h.map_comp blindable\\<^sub>m.map_comp\n      prod.map_id0 rose_tree\\<^sub>h.map_id0)"], ["", "parametric_constant hash_rt_F\\<^sub>m_parametric [transfer_rule]: hash_rt_F\\<^sub>m_alt_def"], ["", "parametric_constant hash_tree_parametric [transfer_rule]: hash_tree_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Blinding \\<close>"], ["", "(************************************************************)"], ["", "abbreviation (input) blinding_of_rt_F\\<^sub>m\n  :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> 'a\\<^sub>m blinding_of \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> 'b\\<^sub>m blinding_of\n      \\<Rightarrow> ('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>m, 'b\\<^sub>h) rose_tree_F\\<^sub>m blinding_of\" where\n  \"blinding_of_rt_F\\<^sub>m ha boa hb bob \\<equiv> blinding_of_blindable (hash_prod ha (map hb))\n    (blinding_of_prod boa (blinding_of_list bob))\""], ["", "lemma blinding_of_rt_F\\<^sub>m_mono:\n  \"\\<lbrakk> boa \\<le> boa'; bob \\<le> bob' \\<rbrakk> \\<Longrightarrow> blinding_of_rt_F\\<^sub>m ha boa hb bob \\<le> blinding_of_rt_F\\<^sub>m ha boa' hb bob'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>boa \\<le> boa'; bob \\<le> bob'\\<rbrakk>\n    \\<Longrightarrow> blinding_of_blindable (map_prod ha (map hb))\n                       (rel_prod boa (list_all2 bob))\n                      \\<le> blinding_of_blindable (map_prod ha (map hb))\n                             (rel_prod boa' (list_all2 bob'))", "by(intro blinding_of_blindable_mono prod.rel_mono list.rel_mono)"], ["", "lemma blinding_of_rt_F\\<^sub>m_mono_inductive:\n  assumes \"\\<And>x y. boa x y \\<longrightarrow> boa' x y\" \"\\<And>x y. bob x y \\<longrightarrow> bob' x y\"\n  shows \"blinding_of_rt_F\\<^sub>m ha boa hb bob x y \\<longrightarrow> blinding_of_rt_F\\<^sub>m ha boa' hb bob' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa (list_all2 bob)) x y \\<longrightarrow>\n    blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa' (list_all2 bob')) x y", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa (list_all2 bob)) x y \\<Longrightarrow>\n    blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa' (list_all2 bob')) x y", "apply(erule blinding_of_rt_F\\<^sub>m_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. boa \\<le> boa'\n 2. bob \\<le> bob'", "using assms"], ["proof (prove)\nusing this:\n  boa ?x ?y \\<longrightarrow> boa' ?x ?y\n  bob ?x ?y \\<longrightarrow> bob' ?x ?y\n\ngoal (2 subgoals):\n 1. boa \\<le> boa'\n 2. bob \\<le> bob'", "by blast+"], ["", "context\n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\" \n    and bo :: \"'a\\<^sub>m blinding_of\"\nbegin"], ["", "inductive blinding_of_tree :: \"('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m blinding_of\" where\n  \"blinding_of_tree (Tree\\<^sub>m t1) (Tree\\<^sub>m t2)\" \n  if \"blinding_of_rt_F\\<^sub>m h bo (hash_tree h) blinding_of_tree t1 t2\"\nmonos blinding_of_rt_F\\<^sub>m_mono_inductive"], ["", "end"], ["", "inductive_simps blinding_of_tree_simps [simp]:\n  \"blinding_of_tree h bo (Tree\\<^sub>m t1) (Tree\\<^sub>m t2)\""], ["", "lemma blinding_of_rt_F\\<^sub>m_hash:\n  assumes \"boa \\<le> vimage2p ha ha (=)\" \"bob \\<le> vimage2p hb hb (=)\"\n  shows \"blinding_of_rt_F\\<^sub>m ha boa hb bob \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa (list_all2 bob))\n    \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb) (=)", "apply(rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. blinding_of_blindable (map_prod ha (map hb))\n     (rel_prod boa (list_all2 bob))\n    \\<le> ?y\n 2. ?y \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb)\n              (=)", "apply(rule blinding_of_blindable_hash)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_prod boa (list_all2 bob)\n    \\<le> vimage2p (map_prod ha (map hb)) (map_prod ha (map hb)) (=)\n 2. vimage2p (hash_blindable (map_prod ha (map hb)))\n     (hash_blindable (map_prod ha (map hb))) (=)\n    \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb) (=)", "apply(fold relator_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_prod boa (list_all2 bob)\n    \\<le> vimage2p (map_prod ha (map hb)) (map_prod ha (map hb))\n           (rel_prod (=) (list_all2 (=)))\n 2. vimage2p (hash_blindable (map_prod ha (map hb)))\n     (hash_blindable (map_prod ha (map hb)))\n     (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))\n    \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb)\n           (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))", "apply(unfold vimage2p_map_rel_prod vimage2p_map_list_all2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_prod boa (list_all2 bob)\n    \\<le> rel_prod (vimage2p ha ha (=)) (list_all2 (vimage2p hb hb (=)))\n 2. vimage2p (hash_blindable (map_prod ha (map hb)))\n     (hash_blindable (map_prod ha (map hb)))\n     (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))\n    \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb)\n           (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))", "apply(rule prod.rel_mono assms list.rel_mono)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. vimage2p (hash_blindable (map_prod ha (map hb)))\n     (hash_blindable (map_prod ha (map hb)))\n     (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))\n    \\<le> vimage2p (hash_rt_F\\<^sub>m ha hb) (hash_rt_F\\<^sub>m ha hb)\n           (rel_blindable\\<^sub>h (rel_prod (=) (list_all2 (=))))", "apply(simp only: hash_rt_F\\<^sub>m_def vimage2p_comp o_apply hash_blindable_def blindable\\<^sub>m.map_id0 id_def[symmetric] vimage2p_id id_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma blinding_of_tree_hash:\n  assumes \"bo \\<le> vimage2p h h (=)\"\n  shows \"blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)", "apply(rule predicate2I vimage2pI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       blinding_of_tree h bo x y \\<Longrightarrow>\n       hash_tree h x = hash_tree h y", "apply(erule blinding_of_tree.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y t1 t2.\n       blinding_of_blindable (map_prod h (map (hash_tree h)))\n        (rel_prod bo\n          (list_all2\n            (\\<lambda>x1 x2.\n                blinding_of_tree h bo x1 x2 \\<and>\n                hash_tree h x1 = hash_tree h x2)))\n        t1 t2 \\<Longrightarrow>\n       hash_tree h (Tree\\<^sub>m t1) = hash_tree h (Tree\\<^sub>m t2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       blinding_of_blindable (map_prod h (map (hash_tree h)))\n        (rel_prod bo\n          (list_all2\n            (\\<lambda>x1 x2.\n                blinding_of_tree h bo x1 x2 \\<and>\n                hash_tree h x1 = hash_tree h x2)))\n        t1 t2 \\<Longrightarrow>\n       hash_rt_F\\<^sub>m h (hash_tree h) t1 =\n       hash_rt_F\\<^sub>m h (hash_tree h) t2", "apply(erule blinding_of_rt_F\\<^sub>m_hash[OF assms, THEN predicate2D_vimage2p, rotated 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       (\\<lambda>x1 x2.\n           blinding_of_tree h bo x1 x2 \\<and>\n           hash_tree h x1 = hash_tree h x2)\n       \\<le> vimage2p (hash_tree h) (hash_tree h) (=)", "apply(blast intro: vimage2pI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation (input) set1_rt_F\\<^sub>m :: \"('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>h, 'b\\<^sub>m) rose_tree_F\\<^sub>m \\<Rightarrow> 'a\\<^sub>m set\" where\n  \"set1_rt_F\\<^sub>m x \\<equiv> set1_blindable\\<^sub>m x \\<bind> fsts\""], ["", "abbreviation (input) set3_rt_F\\<^sub>m :: \"('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>m, 'b\\<^sub>h) rose_tree_F\\<^sub>m \\<Rightarrow> 'b\\<^sub>m set\" where \n  \"set3_rt_F\\<^sub>m x \\<equiv> (set1_blindable\\<^sub>m x \\<bind> snds) \\<bind> set\""], ["", "lemma set_rt_F\\<^sub>m_eq: \n  \"{x. set1_rt_F\\<^sub>m x \\<subseteq> A \\<and> set3_rt_F\\<^sub>m x \\<subseteq> B} = \n   {x. set1_blindable\\<^sub>m x \\<subseteq> {x. fsts x \\<subseteq> A \\<and> snds x \\<subseteq> {x. set x \\<subseteq> B}}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. set1_blindable\\<^sub>m x \\<bind> fsts \\<subseteq> A \\<and>\n        set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set \\<subseteq> B} =\n    {x. set1_blindable\\<^sub>m x\n        \\<subseteq> {x. fsts x \\<subseteq> A \\<and>\n                        snds x \\<subseteq> {x. set x \\<subseteq> B}}}", "by force"], ["", "lemma hash_blindable_map: \"hash_blindable f \\<circ> map_blindable\\<^sub>m g id = hash_blindable (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hash_blindable f \\<circ> map_blindable\\<^sub>m g id =\n    hash_blindable (f \\<circ> g)", "by(rule ext) (simp add: hash_blindable_def blindable\\<^sub>m.map_comp)"], ["", "lemma blinding_of_on_tree [locale_witness]:\n  assumes \"blinding_of_on A h bo\"\n  shows \"blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h) (blinding_of_tree h bo)\"\n  (is \"blinding_of_on ?A ?h ?bo\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo)", "interpret a: blinding_of_on A h bo"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on A h bo", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)\n 2. \\<And>x.\n       x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n       blinding_of_tree h bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 4. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"?bo \\<le> vimage2p ?h ?h (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)", "using a.hash"], ["proof (prove)\nusing this:\n  bo \\<le> vimage2p h h (=)\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)", "by(rule blinding_of_tree_hash)"], ["proof (state)\nthis:\n  blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n       blinding_of_tree h bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 3. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"?bo x x \\<and> (?bo x y \\<longrightarrow> ?bo y z \\<longrightarrow> ?bo x z) \\<and> (?bo x y \\<longrightarrow> ?bo y x \\<longrightarrow> x = y)\" if \"x \\<in> ?A\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo x x \\<and>\n    (blinding_of_tree h bo x y \\<longrightarrow>\n     blinding_of_tree h bo y z \\<longrightarrow>\n     blinding_of_tree h bo x z) \\<and>\n    (blinding_of_tree h bo x y \\<longrightarrow>\n     blinding_of_tree h bo y x \\<longrightarrow> x = y)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo x x \\<and>\n    (blinding_of_tree h bo x y \\<longrightarrow>\n     blinding_of_tree h bo y z \\<longrightarrow>\n     blinding_of_tree h bo x z) \\<and>\n    (blinding_of_tree h bo x y \\<longrightarrow>\n     blinding_of_tree h bo y x \\<longrightarrow> x = y)", "proof(induction x arbitrary: y z)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa y z.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    xaaaa\n                    \\<in> {x. set1_rose_tree\\<^sub>m x\n                              \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo xaaaa\nxaaaa \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y z \\<longrightarrow>\nblinding_of_tree h bo xaaaa z) \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y xaaaa \\<longrightarrow> xaaaa = y);\n        Tree\\<^sub>m xa\n        \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (Tree\\<^sub>m xa)\n                          (Tree\\<^sub>m xa) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y z \\<longrightarrow>\n                          blinding_of_tree h bo (Tree\\<^sub>m xa) z) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y\n                           (Tree\\<^sub>m xa) \\<longrightarrow>\n                          Tree\\<^sub>m xa = y)", "case (Tree\\<^sub>m x)"], ["proof (state)\nthis:\n  \\<lbrakk>?xaa \\<in> set1_blindable\\<^sub>m x; ?xaaa \\<in> snds ?xaa;\n   ?xaaaa \\<in> set ?xaaa;\n   ?xaaaa \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo ?xaaaa ?xaaaa \\<and>\n                    (blinding_of_tree h bo ?xaaaa ?y \\<longrightarrow>\n                     blinding_of_tree h bo ?y ?z \\<longrightarrow>\n                     blinding_of_tree h bo ?xaaaa ?z) \\<and>\n                    (blinding_of_tree h bo ?xaaaa ?y \\<longrightarrow>\n                     blinding_of_tree h bo ?y ?xaaaa \\<longrightarrow>\n                     ?xaaaa = ?y)\n  Tree\\<^sub>m x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa y z.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    xaaaa\n                    \\<in> {x. set1_rose_tree\\<^sub>m x\n                              \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo xaaaa\nxaaaa \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y z \\<longrightarrow>\nblinding_of_tree h bo xaaaa z) \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y xaaaa \\<longrightarrow> xaaaa = y);\n        Tree\\<^sub>m xa\n        \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (Tree\\<^sub>m xa)\n                          (Tree\\<^sub>m xa) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y z \\<longrightarrow>\n                          blinding_of_tree h bo (Tree\\<^sub>m xa) z) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y\n                           (Tree\\<^sub>m xa) \\<longrightarrow>\n                          Tree\\<^sub>m xa = y)", "have [locale_witness]: \"blinding_of_on (set3_rt_F\\<^sub>m x) (hash_tree h) (blinding_of_tree h bo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on (set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set)\n     (hash_tree h) (blinding_of_tree h bo)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)\n 2. \\<And>x.\n       x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind>\n               set \\<Longrightarrow>\n       blinding_of_tree h bo x x\n 3. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 4. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_tree h bo \\<le> vimage2p (hash_tree h) (hash_tree h) (=)", "by(rule blinding_of_tree_hash)(rule a.hash)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind>\n               set \\<Longrightarrow>\n       blinding_of_tree h bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 3. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind>\n             set \\<Longrightarrow>\n    blinding_of_tree h bo x_ x_", "using Tree\\<^sub>m.IH Tree\\<^sub>m.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xaa \\<in> set1_blindable\\<^sub>m x; ?xaaa \\<in> snds ?xaa;\n   ?xaaaa \\<in> set ?xaaa;\n   ?xaaaa \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo ?xaaaa ?xaaaa \\<and>\n                    (blinding_of_tree h bo ?xaaaa ?y \\<longrightarrow>\n                     blinding_of_tree h bo ?y ?z \\<longrightarrow>\n                     blinding_of_tree h bo ?xaaaa ?z) \\<and>\n                    (blinding_of_tree h bo ?xaaaa ?y \\<longrightarrow>\n                     blinding_of_tree h bo ?y ?xaaaa \\<longrightarrow>\n                     ?xaaaa = ?y)\n  Tree\\<^sub>m x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. x_ \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind>\n             set \\<Longrightarrow>\n    blinding_of_tree h bo x_ x_", "by(fastforce simp add: eq_onp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 2. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n     x \\<in> set1_blindable\\<^sub>m xa__ \\<bind> snds \\<bind> set\\<rbrakk>\n    \\<Longrightarrow> blinding_of_tree h bo x z", "using Tree\\<^sub>m.IH[of _ _ x y z] Tree\\<^sub>m.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xaa \\<in> set1_blindable\\<^sub>m xa__; ?xaaa \\<in> snds ?xaa;\n   x \\<in> set ?xaaa;\n   x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo x x \\<and>\n                    (blinding_of_tree h bo x y \\<longrightarrow>\n                     blinding_of_tree h bo y z \\<longrightarrow>\n                     blinding_of_tree h bo x z) \\<and>\n                    (blinding_of_tree h bo x y \\<longrightarrow>\n                     blinding_of_tree h bo y x \\<longrightarrow> x = y)\n  Tree\\<^sub>m xa__ \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n     x \\<in> set1_blindable\\<^sub>m xa__ \\<bind> snds \\<bind> set\\<rbrakk>\n    \\<Longrightarrow> blinding_of_tree h bo x z", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> x = y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n     x \\<in> set1_blindable\\<^sub>m xa__ \\<bind> snds \\<bind> set\\<rbrakk>\n    \\<Longrightarrow> x = y", "using Tree\\<^sub>m.IH[of _ _ x y] Tree\\<^sub>m.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xaa \\<in> set1_blindable\\<^sub>m xa__; ?xaaa \\<in> snds ?xaa;\n   x \\<in> set ?xaaa;\n   x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo x x \\<and>\n                    (blinding_of_tree h bo x y \\<longrightarrow>\n                     blinding_of_tree h bo y ?z \\<longrightarrow>\n                     blinding_of_tree h bo x ?z) \\<and>\n                    (blinding_of_tree h bo x y \\<longrightarrow>\n                     blinding_of_tree h bo y x \\<longrightarrow> x = y)\n  Tree\\<^sub>m xa__ \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n     x \\<in> set1_blindable\\<^sub>m xa__ \\<bind> snds \\<bind> set\\<rbrakk>\n    \\<Longrightarrow> x = y", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  blinding_of_on (set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set)\n   (hash_tree h) (blinding_of_tree h bo)\n\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa y z.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    xaaaa\n                    \\<in> {x. set1_rose_tree\\<^sub>m x\n                              \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo xaaaa\nxaaaa \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y z \\<longrightarrow>\nblinding_of_tree h bo xaaaa z) \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y xaaaa \\<longrightarrow> xaaaa = y);\n        Tree\\<^sub>m xa\n        \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (Tree\\<^sub>m xa)\n                          (Tree\\<^sub>m xa) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y z \\<longrightarrow>\n                          blinding_of_tree h bo (Tree\\<^sub>m xa) z) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y\n                           (Tree\\<^sub>m xa) \\<longrightarrow>\n                          Tree\\<^sub>m xa = y)", "interpret blinding_of_on\n        \"{a. set1_rt_F\\<^sub>m a \\<subseteq> A \\<and> set3_rt_F\\<^sub>m a \\<subseteq> set3_rt_F\\<^sub>m x}\"\n        \"hash_rt_F\\<^sub>m h ?h\" \"blinding_of_rt_F\\<^sub>m h bo ?h ?bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on\n     {a. set1_blindable\\<^sub>m a \\<bind> fsts \\<subseteq> A \\<and>\n         set1_blindable\\<^sub>m a \\<bind> snds \\<bind> set\n         \\<subseteq> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set}\n     (hash_rt_F\\<^sub>m h (hash_tree h))\n     (blinding_of_blindable (map_prod h (map (hash_tree h)))\n       (rel_prod bo (list_all2 (blinding_of_tree h bo))))", "unfolding set_rt_F\\<^sub>m_eq hash_rt_F\\<^sub>m_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinding_of_on\n     {a. set1_blindable\\<^sub>m a\n         \\<subseteq> {a. fsts a \\<subseteq> A \\<and>\n                         snds a\n                         \\<subseteq> {a.\nset a \\<subseteq> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set}}}\n     (hash_blindable (map_prod h (map (hash_tree h))))\n     (blinding_of_blindable (map_prod h (map (hash_tree h)))\n       (rel_prod bo (list_all2 (blinding_of_tree h bo))))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa y z.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa y z.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    xaaaa\n                    \\<in> {x. set1_rose_tree\\<^sub>m x\n                              \\<subseteq> A}\\<rbrakk>\n                   \\<Longrightarrow> blinding_of_tree h bo xaaaa\nxaaaa \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y z \\<longrightarrow>\nblinding_of_tree h bo xaaaa z) \\<and>\n                                     (blinding_of_tree h bo xaaaa\n y \\<longrightarrow>\nblinding_of_tree h bo y xaaaa \\<longrightarrow> xaaaa = y);\n        Tree\\<^sub>m xa\n        \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo (Tree\\<^sub>m xa)\n                          (Tree\\<^sub>m xa) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y z \\<longrightarrow>\n                          blinding_of_tree h bo (Tree\\<^sub>m xa) z) \\<and>\n                         (blinding_of_tree h bo (Tree\\<^sub>m xa)\n                           y \\<longrightarrow>\n                          blinding_of_tree h bo y\n                           (Tree\\<^sub>m xa) \\<longrightarrow>\n                          Tree\\<^sub>m xa = y)", "from Tree\\<^sub>m.prems"], ["proof (chain)\npicking this:\n  Tree\\<^sub>m x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}", "show ?case"], ["proof (prove)\nusing this:\n  Tree\\<^sub>m x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. blinding_of_tree h bo (Tree\\<^sub>m x) (Tree\\<^sub>m x) \\<and>\n    (blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n     blinding_of_tree h bo y z \\<longrightarrow>\n     blinding_of_tree h bo (Tree\\<^sub>m x) z) \\<and>\n    (blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n     blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n     Tree\\<^sub>m x = y)", "apply(intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) (Tree\\<^sub>m x)\n 2. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y z \\<longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) z\n 3. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n    Tree\\<^sub>m x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) (Tree\\<^sub>m x)", "by(fastforce intro!: blinding_of_tree.intros refl[unfolded hash_rt_F\\<^sub>m_alt_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y z \\<longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) z\n 2. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n    Tree\\<^sub>m x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y z \\<longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) z", "by(fastforce elim!: blinding_of_tree.cases trans[unfolded hash_rt_F\\<^sub>m_alt_def] \n                    intro!: blinding_of_tree.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n    Tree\\<^sub>m x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tree\\<^sub>m x\n    \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n    blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n    blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n    Tree\\<^sub>m x = y", "by(fastforce elim!: blinding_of_tree.cases antisym[unfolded hash_rt_F\\<^sub>m_alt_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  blinding_of_tree h bo (Tree\\<^sub>m x) (Tree\\<^sub>m x) \\<and>\n  (blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n   blinding_of_tree h bo y z \\<longrightarrow>\n   blinding_of_tree h bo (Tree\\<^sub>m x) z) \\<and>\n  (blinding_of_tree h bo (Tree\\<^sub>m x) y \\<longrightarrow>\n   blinding_of_tree h bo y (Tree\\<^sub>m x) \\<longrightarrow>\n   Tree\\<^sub>m x = y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  blinding_of_tree h bo ?x ?x \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?z \\<longrightarrow>\n   blinding_of_tree h bo ?x ?z) \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?x \\<longrightarrow> ?x = ?y)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n       blinding_of_tree h bo x x\n 2. \\<And>x y z.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo x z\n 3. \\<And>x y.\n       \\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n        x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  blinding_of_tree h bo ?x ?x \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?z \\<longrightarrow>\n   blinding_of_tree h bo ?x ?z) \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?x \\<longrightarrow> ?x = ?y)", "show \"x \\<in> ?A \\<Longrightarrow> ?bo x x\"\n      and \"\\<lbrakk> ?bo x y; ?bo y z; x \\<in> ?A \\<rbrakk> \\<Longrightarrow> ?bo x z\"\n      and \"\\<lbrakk> ?bo x y; ?bo y x; x \\<in> ?A \\<rbrakk> \\<Longrightarrow> x = y\"\n      for x y z"], ["proof (prove)\nusing this:\n  ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  blinding_of_tree h bo ?x ?x \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?z \\<longrightarrow>\n   blinding_of_tree h bo ?x ?z) \\<and>\n  (blinding_of_tree h bo ?x ?y \\<longrightarrow>\n   blinding_of_tree h bo ?y ?x \\<longrightarrow> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n     blinding_of_tree h bo x x) &&&\n    (\\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y z;\n      x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n     \\<Longrightarrow> blinding_of_tree h bo x z) &&&\n    (\\<lbrakk>blinding_of_tree h bo x y; blinding_of_tree h bo y x;\n      x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n     \\<Longrightarrow> x = y)", "by blast+"], ["proof (state)\nthis:\n  ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  blinding_of_tree h bo ?x ?x\n  \\<lbrakk>blinding_of_tree h bo ?x ?y; blinding_of_tree h bo ?y ?z;\n   ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> blinding_of_tree h bo ?x ?z\n  \\<lbrakk>blinding_of_tree h bo ?x ?y; blinding_of_tree h bo ?y ?x;\n   ?x \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  blinding_of_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n   (blinding_of_tree h bo)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas blinding_of_tree [locale_witness] = blinding_of_on_tree[where A=UNIV, simplified]"], ["", "lemma blinding_of_tree_mono:\n  \"bo \\<le> bo' \\<Longrightarrow> blinding_of_tree h bo \\<le> blinding_of_tree h bo'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bo \\<le> bo' \\<Longrightarrow>\n    blinding_of_tree h bo \\<le> blinding_of_tree h bo'", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>bo \\<le> bo'; blinding_of_tree h bo x y\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo' x y", "apply(erule blinding_of_tree.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y t1 t2.\n       \\<lbrakk>bo \\<le> bo';\n        blinding_of_blindable (map_prod h (map (hash_tree h)))\n         (rel_prod bo\n           (list_all2\n             (\\<lambda>x1 x2.\n                 blinding_of_tree h bo x1 x2 \\<and>\n                 blinding_of_tree h bo' x1 x2)))\n         t1 t2\\<rbrakk>\n       \\<Longrightarrow> blinding_of_tree h bo' (Tree\\<^sub>m t1)\n                          (Tree\\<^sub>m t2)", "apply(rule blinding_of_tree.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y t1 t2.\n       \\<lbrakk>bo \\<le> bo';\n        blinding_of_blindable (map_prod h (map (hash_tree h)))\n         (rel_prod bo\n           (list_all2\n             (\\<lambda>x1 x2.\n                 blinding_of_tree h bo x1 x2 \\<and>\n                 blinding_of_tree h bo' x1 x2)))\n         t1 t2\\<rbrakk>\n       \\<Longrightarrow> blinding_of_blindable\n                          (map_prod h (map (hash_tree h)))\n                          (rel_prod bo'\n                            (list_all2 (blinding_of_tree h bo')))\n                          t1 t2", "apply(erule blinding_of_rt_F\\<^sub>m_mono[THEN predicate2D, rotated -1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y t1 t2. bo \\<le> bo' \\<Longrightarrow> bo \\<le> bo'\n 2. \\<And>x y t1 t2.\n       bo \\<le> bo' \\<Longrightarrow>\n       (\\<lambda>x1 x2.\n           blinding_of_tree h bo x1 x2 \\<and> blinding_of_tree h bo' x1 x2)\n       \\<le> blinding_of_tree h bo'", "apply(blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(************************************************************)"], ["", "subsubsection \\<open> Merging \\<close>"], ["", "(************************************************************)"], ["", "definition merge_rt_F\\<^sub>m \n  :: \"('a\\<^sub>m, 'a\\<^sub>h) hash \\<Rightarrow> 'a\\<^sub>m merge \\<Rightarrow> ('b\\<^sub>m, 'b\\<^sub>h) hash \\<Rightarrow> 'b\\<^sub>m merge \\<Rightarrow>\n      ('a\\<^sub>m, 'a\\<^sub>h, 'b\\<^sub>m, 'b\\<^sub>h) rose_tree_F\\<^sub>m merge\"\n  where\n  \"merge_rt_F\\<^sub>m ha ma hr mr \\<equiv> merge_blindable (hash_prod ha (hash_list hr)) (merge_prod ma (merge_list mr))\""], ["", "lemma merge_rt_F\\<^sub>m_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_rt_F\\<^sub>m x; b \\<in> set1_rt_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> ma a b = ma' a b\"\n    and \"\\<And>a b. \\<lbrakk> a \\<in> set3_rt_F\\<^sub>m x; b \\<in> set3_rt_F\\<^sub>m y \\<rbrakk> \\<Longrightarrow> mm a b = mm' a b\"\n  shows \"merge_rt_F\\<^sub>m ha ma hm mm x y = merge_rt_F\\<^sub>m ha ma' hm mm' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_rt_F\\<^sub>m ha ma hm mm x y =\n    merge_rt_F\\<^sub>m ha ma' hm mm' x y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set1_blindable\\<^sub>m x \\<bind> fsts;\n   ?b \\<in> set1_blindable\\<^sub>m y \\<bind> fsts\\<rbrakk>\n  \\<Longrightarrow> ma ?a ?b = ma' ?a ?b\n  \\<lbrakk>?a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set;\n   ?b \\<in> set1_blindable\\<^sub>m y \\<bind> snds \\<bind> set\\<rbrakk>\n  \\<Longrightarrow> mm ?a ?b = mm' ?a ?b\n\ngoal (1 subgoal):\n 1. merge_rt_F\\<^sub>m ha ma hm mm x y =\n    merge_rt_F\\<^sub>m ha ma' hm mm' x y", "apply(cases x; cases y; simp add: merge_rt_F\\<^sub>m_def bind_UNION)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>x = Unblinded x1; y = Unblinded x1a;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> fsts x1; b \\<in> fsts x1a\\<rbrakk>\n           \\<Longrightarrow> ma a b = ma' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>snds x1. a \\<in> set x;\n            \\<exists>x\\<in>snds x1a. b \\<in> set x\\<rbrakk>\n           \\<Longrightarrow> mm a b = mm' a b\\<rbrakk>\n       \\<Longrightarrow> map_option Unblinded\n                          (merge_prod ma (merge_list mm) x1 x1a) =\n                         map_option Unblinded\n                          (merge_prod ma' (merge_list mm') x1 x1a)", "apply(rule arg_cong[where f=\"map_option _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>x = Unblinded x1; y = Unblinded x1a;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> fsts x1; b \\<in> fsts x1a\\<rbrakk>\n           \\<Longrightarrow> ma a b = ma' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>snds x1. a \\<in> set x;\n            \\<exists>x\\<in>snds x1a. b \\<in> set x\\<rbrakk>\n           \\<Longrightarrow> mm a b = mm' a b\\<rbrakk>\n       \\<Longrightarrow> merge_prod ma (merge_list mm) x1 x1a =\n                         merge_prod ma' (merge_list mm') x1 x1a", "apply(blast intro: merge_prod_cong merge_list_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_set1_blindable\\<^sub>m_iff: \"x \\<in> set1_blindable\\<^sub>m y \\<longleftrightarrow> y = Unblinded x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set1_blindable\\<^sub>m y) = (y = Unblinded x)", "by(cases y) auto"], ["", "context \n  fixes h :: \"('a\\<^sub>m, 'a\\<^sub>h) hash\"\n    and ma :: \"'a\\<^sub>m merge\"\n  notes in_set1_blindable\\<^sub>m_iff[simp]\nbegin"], ["", "fun merge_tree :: \"('a\\<^sub>m, 'a\\<^sub>h) rose_tree\\<^sub>m merge\" where\n  \"merge_tree (Tree\\<^sub>m x) (Tree\\<^sub>m y) = map_option Tree\\<^sub>m (\n    merge_rt_F\\<^sub>m h ma (hash_tree h) merge_tree x y)\""], ["", "end"], ["", "lemma merge_on_tree [locale_witness]:\n  assumes \"merge_on A h bo m\"\n  shows \"merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)\"\n  (is \"merge_on ?A ?h ?bo ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo) (merge_tree h m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo) (merge_tree h m)", "interpret a: merge_on A h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on A h bo m", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo) (merge_tree h m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n     (blinding_of_tree h bo) (merge_tree h m)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "have \"(?h a = ?h b \\<longrightarrow> (\\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u))) \\<and>\n      (?h a \\<noteq> ?h b \\<longrightarrow> ?m a b = None)\"\n      if \"a \\<in> ?A\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_tree h m a b = Some ab \\<and>\n         blinding_of_tree h bo a ab \\<and>\n         blinding_of_tree h bo b ab \\<and>\n         (\\<forall>u.\n             blinding_of_tree h bo a u \\<longrightarrow>\n             blinding_of_tree h bo b u \\<longrightarrow>\n             blinding_of_tree h bo ab u))) \\<and>\n    (hash_tree h a \\<noteq> hash_tree h b \\<longrightarrow>\n     merge_tree h m a b = None)", "using that"], ["proof (prove)\nusing this:\n  a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_tree h m a b = Some ab \\<and>\n         blinding_of_tree h bo a ab \\<and>\n         blinding_of_tree h bo b ab \\<and>\n         (\\<forall>u.\n             blinding_of_tree h bo a u \\<longrightarrow>\n             blinding_of_tree h bo b u \\<longrightarrow>\n             blinding_of_tree h bo ab u))) \\<and>\n    (hash_tree h a \\<noteq> hash_tree h b \\<longrightarrow>\n     merge_tree h m a b = None)", "unfolding mem_Collect_eq"], ["proof (prove)\nusing this:\n  set1_rose_tree\\<^sub>m a \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<longrightarrow>\n     (\\<exists>ab.\n         merge_tree h m a b = Some ab \\<and>\n         blinding_of_tree h bo a ab \\<and>\n         blinding_of_tree h bo b ab \\<and>\n         (\\<forall>u.\n             blinding_of_tree h bo a u \\<longrightarrow>\n             blinding_of_tree h bo b u \\<longrightarrow>\n             blinding_of_tree h bo ab u))) \\<and>\n    (hash_tree h a \\<noteq> hash_tree h b \\<longrightarrow>\n     merge_tree h m a b = None)", "proof(induction a arbitrary: b rule: rose_tree\\<^sub>m.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa b.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa b.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    set1_rose_tree\\<^sub>m xaaaa \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (hash_tree h xaaaa =\nhash_tree h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_tree h m xaaaa b = Some ab \\<and>\n    blinding_of_tree h bo xaaaa ab \\<and>\n    blinding_of_tree h bo b ab \\<and>\n    (\\<forall>u.\n        blinding_of_tree h bo xaaaa u \\<longrightarrow>\n        blinding_of_tree h bo b u \\<longrightarrow>\n        blinding_of_tree h bo ab u))) \\<and>\n                                     (hash_tree h xaaaa \\<noteq>\nhash_tree h b \\<longrightarrow>\nmerge_tree h m xaaaa b = None);\n        set1_rose_tree\\<^sub>m (Tree\\<^sub>m xa) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (hash_tree h (Tree\\<^sub>m xa) =\n                          hash_tree h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_tree h m (Tree\\<^sub>m xa) b =\n                              Some ab \\<and>\n                              blinding_of_tree h bo (Tree\\<^sub>m xa)\n                               ab \\<and>\n                              blinding_of_tree h bo b ab \\<and>\n                              (\\<forall>u.\n                                  blinding_of_tree h bo (Tree\\<^sub>m xa)\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo b\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo ab u))) \\<and>\n                         (hash_tree h (Tree\\<^sub>m xa) \\<noteq>\n                          hash_tree h b \\<longrightarrow>\n                          merge_tree h m (Tree\\<^sub>m xa) b = None)", "case (Tree\\<^sub>m x y)"], ["proof (state)\nthis:\n  \\<lbrakk>?xaa \\<in> set1_blindable\\<^sub>m x; ?xaaa \\<in> snds ?xaa;\n   ?xaaaa \\<in> set ?xaaa;\n   set1_rose_tree\\<^sub>m ?xaaaa \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> (hash_tree h ?xaaaa = hash_tree h ?b \\<longrightarrow>\n                     (\\<exists>ab.\n                         merge_tree h m ?xaaaa ?b = Some ab \\<and>\n                         blinding_of_tree h bo ?xaaaa ab \\<and>\n                         blinding_of_tree h bo ?b ab \\<and>\n                         (\\<forall>u.\n                             blinding_of_tree h bo ?xaaaa\n                              u \\<longrightarrow>\n                             blinding_of_tree h bo ?b u \\<longrightarrow>\n                             blinding_of_tree h bo ab u))) \\<and>\n                    (hash_tree h ?xaaaa \\<noteq>\n                     hash_tree h ?b \\<longrightarrow>\n                     merge_tree h m ?xaaaa ?b = None)\n  set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>xa b.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa b.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    set1_rose_tree\\<^sub>m xaaaa \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (hash_tree h xaaaa =\nhash_tree h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_tree h m xaaaa b = Some ab \\<and>\n    blinding_of_tree h bo xaaaa ab \\<and>\n    blinding_of_tree h bo b ab \\<and>\n    (\\<forall>u.\n        blinding_of_tree h bo xaaaa u \\<longrightarrow>\n        blinding_of_tree h bo b u \\<longrightarrow>\n        blinding_of_tree h bo ab u))) \\<and>\n                                     (hash_tree h xaaaa \\<noteq>\nhash_tree h b \\<longrightarrow>\nmerge_tree h m xaaaa b = None);\n        set1_rose_tree\\<^sub>m (Tree\\<^sub>m xa) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (hash_tree h (Tree\\<^sub>m xa) =\n                          hash_tree h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_tree h m (Tree\\<^sub>m xa) b =\n                              Some ab \\<and>\n                              blinding_of_tree h bo (Tree\\<^sub>m xa)\n                               ab \\<and>\n                              blinding_of_tree h bo b ab \\<and>\n                              (\\<forall>u.\n                                  blinding_of_tree h bo (Tree\\<^sub>m xa)\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo b\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo ab u))) \\<and>\n                         (hash_tree h (Tree\\<^sub>m xa) \\<noteq>\n                          hash_tree h b \\<longrightarrow>\n                          merge_tree h m (Tree\\<^sub>m xa) b = None)", "interpret merge_on \n        \"{y. set1_rt_F\\<^sub>m y \\<subseteq> A \\<and> set3_rt_F\\<^sub>m y \\<subseteq> set3_rt_F\\<^sub>m x}\"\n        \"hash_rt_F\\<^sub>m h ?h\"\n        \"blinding_of_rt_F\\<^sub>m h bo ?h ?bo\"\n        \"merge_rt_F\\<^sub>m h m ?h ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on\n     {y. set1_blindable\\<^sub>m y \\<bind> fsts \\<subseteq> A \\<and>\n         set1_blindable\\<^sub>m y \\<bind> snds \\<bind> set\n         \\<subseteq> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set}\n     (hash_rt_F\\<^sub>m h (hash_tree h))\n     (blinding_of_blindable (map_prod h (map (hash_tree h)))\n       (rel_prod bo (list_all2 (blinding_of_tree h bo))))\n     (merge_rt_F\\<^sub>m h m (hash_tree h) (merge_tree h m))", "unfolding set_rt_F\\<^sub>m_eq hash_rt_F\\<^sub>m_alt_def merge_rt_F\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on\n     {y. set1_blindable\\<^sub>m y\n         \\<subseteq> {y. fsts y \\<subseteq> A \\<and>\n                         snds y\n                         \\<subseteq> {y.\nset y \\<subseteq> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set}}}\n     (hash_blindable (map_prod h (map (hash_tree h))))\n     (blinding_of_blindable (map_prod h (map (hash_tree h)))\n       (rel_prod bo (list_all2 (blinding_of_tree h bo))))\n     (merge_blindable (map_prod h (map (hash_tree h)))\n       (merge_prod m (merge_list (merge_tree h m))))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "assume a: \"a \\<in> set3_rt_F\\<^sub>m x\""], ["proof (state)\nthis:\n  a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "with Tree\\<^sub>m.prems"], ["proof (chain)\npicking this:\n  set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A\n  a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set", "have a': \"set1_rose_tree\\<^sub>m a \\<subseteq> A\""], ["proof (prove)\nusing this:\n  set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A\n  a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\n\ngoal (1 subgoal):\n 1. set1_rose_tree\\<^sub>m a \\<subseteq> A", "by(force simp add: bind_UNION)"], ["proof (state)\nthis:\n  set1_rose_tree\\<^sub>m a \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "from a"], ["proof (chain)\npicking this:\n  a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set", "obtain l and ab where a'': \"ab \\<in> set1_blindable\\<^sub>m x\" \"l \\<in> snds ab\" \"a \\<in> set l\""], ["proof (prove)\nusing this:\n  a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\n\ngoal (1 subgoal):\n 1. (\\<And>ab l.\n        \\<lbrakk>ab \\<in> set1_blindable\\<^sub>m x; l \\<in> snds ab;\n         a \\<in> set l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: bind_UNION)"], ["proof (state)\nthis:\n  ab \\<in> set1_blindable\\<^sub>m x\n  l \\<in> snds ab\n  a \\<in> set l\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> set1_blindable\\<^sub>m x \\<bind> snds \\<bind> set\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "from Tree\\<^sub>m.IH[OF a'' a', rule_format, of b]"], ["proof (chain)\npicking this:\n  (hash_tree h a = hash_tree h b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m a b = Some ab \\<and>\n       blinding_of_tree h bo a ab \\<and>\n       blinding_of_tree h bo b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo a u \\<longrightarrow>\n           blinding_of_tree h bo b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h a \\<noteq> hash_tree h b \\<longrightarrow>\n   merge_tree h m a b = None)", "show \"hash_tree h a = hash_tree h b\n           \\<Longrightarrow> \\<exists>ab. merge_tree h m a b = Some ab \\<and> blinding_of_tree h bo a ab \\<and> blinding_of_tree h bo b ab \\<and>\n                    (\\<forall>u. blinding_of_tree h bo a u \\<longrightarrow> blinding_of_tree h bo b u \\<longrightarrow> blinding_of_tree h bo ab u)\"\n          and \"hash_tree h a \\<noteq> hash_tree h b \\<Longrightarrow> merge_tree h m a b = None\""], ["proof (prove)\nusing this:\n  (hash_tree h a = hash_tree h b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m a b = Some ab \\<and>\n       blinding_of_tree h bo a ab \\<and>\n       blinding_of_tree h bo b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo a u \\<longrightarrow>\n           blinding_of_tree h bo b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h a \\<noteq> hash_tree h b \\<longrightarrow>\n   merge_tree h m a b = None)\n\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_tree h m a b = Some ab \\<and>\n        blinding_of_tree h bo a ab \\<and>\n        blinding_of_tree h bo b ab \\<and>\n        (\\<forall>u.\n            blinding_of_tree h bo a u \\<longrightarrow>\n            blinding_of_tree h bo b u \\<longrightarrow>\n            blinding_of_tree h bo ab u)) &&&\n    (hash_tree h a \\<noteq> hash_tree h b \\<Longrightarrow>\n     merge_tree h m a b = None)", "by(auto dest: sym)"], ["proof (state)\nthis:\n  hash_tree h a = hash_tree h b \\<Longrightarrow>\n  \\<exists>ab.\n     merge_tree h m a b = Some ab \\<and>\n     blinding_of_tree h bo a ab \\<and>\n     blinding_of_tree h bo b ab \\<and>\n     (\\<forall>u.\n         blinding_of_tree h bo a u \\<longrightarrow>\n         blinding_of_tree h bo b u \\<longrightarrow>\n         blinding_of_tree h bo ab u)\n  hash_tree h a \\<noteq> hash_tree h b \\<Longrightarrow>\n  merge_tree h m a b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa b.\n       \\<lbrakk>\\<And>xaa xaaa xaaaa b.\n                   \\<lbrakk>xaa \\<in> set1_blindable\\<^sub>m xa;\n                    xaaa \\<in> snds xaa; xaaaa \\<in> set xaaa;\n                    set1_rose_tree\\<^sub>m xaaaa \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> (hash_tree h xaaaa =\nhash_tree h b \\<longrightarrow>\n(\\<exists>ab.\n    merge_tree h m xaaaa b = Some ab \\<and>\n    blinding_of_tree h bo xaaaa ab \\<and>\n    blinding_of_tree h bo b ab \\<and>\n    (\\<forall>u.\n        blinding_of_tree h bo xaaaa u \\<longrightarrow>\n        blinding_of_tree h bo b u \\<longrightarrow>\n        blinding_of_tree h bo ab u))) \\<and>\n                                     (hash_tree h xaaaa \\<noteq>\nhash_tree h b \\<longrightarrow>\nmerge_tree h m xaaaa b = None);\n        set1_rose_tree\\<^sub>m (Tree\\<^sub>m xa) \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> (hash_tree h (Tree\\<^sub>m xa) =\n                          hash_tree h b \\<longrightarrow>\n                          (\\<exists>ab.\n                              merge_tree h m (Tree\\<^sub>m xa) b =\n                              Some ab \\<and>\n                              blinding_of_tree h bo (Tree\\<^sub>m xa)\n                               ab \\<and>\n                              blinding_of_tree h bo b ab \\<and>\n                              (\\<forall>u.\n                                  blinding_of_tree h bo (Tree\\<^sub>m xa)\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo b\n                                   u \\<longrightarrow>\n                                  blinding_of_tree h bo ab u))) \\<and>\n                         (hash_tree h (Tree\\<^sub>m xa) \\<noteq>\n                          hash_tree h b \\<longrightarrow>\n                          merge_tree h m (Tree\\<^sub>m xa) b = None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hash_tree h (Tree\\<^sub>m x) = hash_tree h y \\<longrightarrow>\n     (\\<exists>ab.\n         merge_tree h m (Tree\\<^sub>m x) y = Some ab \\<and>\n         blinding_of_tree h bo (Tree\\<^sub>m x) ab \\<and>\n         blinding_of_tree h bo y ab \\<and>\n         (\\<forall>u.\n             blinding_of_tree h bo (Tree\\<^sub>m x) u \\<longrightarrow>\n             blinding_of_tree h bo y u \\<longrightarrow>\n             blinding_of_tree h bo ab u))) \\<and>\n    (hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y \\<longrightarrow>\n     merge_tree h m (Tree\\<^sub>m x) y = None)", "using Tree\\<^sub>m.prems"], ["proof (prove)\nusing this:\n  set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (hash_tree h (Tree\\<^sub>m x) = hash_tree h y \\<longrightarrow>\n     (\\<exists>ab.\n         merge_tree h m (Tree\\<^sub>m x) y = Some ab \\<and>\n         blinding_of_tree h bo (Tree\\<^sub>m x) ab \\<and>\n         blinding_of_tree h bo y ab \\<and>\n         (\\<forall>u.\n             blinding_of_tree h bo (Tree\\<^sub>m x) u \\<longrightarrow>\n             blinding_of_tree h bo y u \\<longrightarrow>\n             blinding_of_tree h bo ab u))) \\<and>\n    (hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y \\<longrightarrow>\n     merge_tree h m (Tree\\<^sub>m x) y = None)", "apply(intro conjI strip)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A;\n     hash_tree h (Tree\\<^sub>m x) = hash_tree h y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ab.\n                         merge_tree h m (Tree\\<^sub>m x) y = Some ab \\<and>\n                         blinding_of_tree h bo (Tree\\<^sub>m x) ab \\<and>\n                         blinding_of_tree h bo y ab \\<and>\n                         (\\<forall>u.\n                             blinding_of_tree h bo (Tree\\<^sub>m x)\n                              u \\<longrightarrow>\n                             blinding_of_tree h bo y u \\<longrightarrow>\n                             blinding_of_tree h bo ab u)\n 2. \\<lbrakk>set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A;\n     hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y\\<rbrakk>\n    \\<Longrightarrow> merge_tree h m (Tree\\<^sub>m x) y = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A;\n     hash_tree h (Tree\\<^sub>m x) = hash_tree h y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ab.\n                         merge_tree h m (Tree\\<^sub>m x) y = Some ab \\<and>\n                         blinding_of_tree h bo (Tree\\<^sub>m x) ab \\<and>\n                         blinding_of_tree h bo y ab \\<and>\n                         (\\<forall>u.\n                             blinding_of_tree h bo (Tree\\<^sub>m x)\n                              u \\<longrightarrow>\n                             blinding_of_tree h bo y u \\<longrightarrow>\n                             blinding_of_tree h bo ab u)", "by(cases y)(fastforce dest!: join simp add: blinding_of_tree.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A;\n     hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y\\<rbrakk>\n    \\<Longrightarrow> merge_tree h m (Tree\\<^sub>m x) y = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set1_rose_tree\\<^sub>m (Tree\\<^sub>m x) \\<subseteq> A;\n     hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y\\<rbrakk>\n    \\<Longrightarrow> merge_tree h m (Tree\\<^sub>m x) y = None", "by (cases y) (fastforce dest!: undefined)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (hash_tree h (Tree\\<^sub>m x) = hash_tree h y \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m (Tree\\<^sub>m x) y = Some ab \\<and>\n       blinding_of_tree h bo (Tree\\<^sub>m x) ab \\<and>\n       blinding_of_tree h bo y ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo (Tree\\<^sub>m x) u \\<longrightarrow>\n           blinding_of_tree h bo y u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h (Tree\\<^sub>m x) \\<noteq> hash_tree h y \\<longrightarrow>\n   merge_tree h m (Tree\\<^sub>m x) y = None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  (hash_tree h ?a = hash_tree h ?b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m ?a ?b = Some ab \\<and>\n       blinding_of_tree h bo ?a ab \\<and>\n       blinding_of_tree h bo ?b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo ?a u \\<longrightarrow>\n           blinding_of_tree h bo ?b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h ?a \\<noteq> hash_tree h ?b \\<longrightarrow>\n   merge_tree h m ?a ?b = None)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>hash_tree h a = hash_tree h b;\n        a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ab.\n                            merge_tree h m a b = Some ab \\<and>\n                            blinding_of_tree h bo a ab \\<and>\n                            blinding_of_tree h bo b ab \\<and>\n                            (\\<forall>u.\n                                blinding_of_tree h bo a u \\<longrightarrow>\n                                blinding_of_tree h bo b u \\<longrightarrow>\n                                blinding_of_tree h bo ab u)\n 2. \\<And>a b.\n       \\<lbrakk>hash_tree h a \\<noteq> hash_tree h b;\n        a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m a b = None", "then"], ["proof (chain)\npicking this:\n  ?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  (hash_tree h ?a = hash_tree h ?b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m ?a ?b = Some ab \\<and>\n       blinding_of_tree h bo ?a ab \\<and>\n       blinding_of_tree h bo ?b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo ?a u \\<longrightarrow>\n           blinding_of_tree h bo ?b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h ?a \\<noteq> hash_tree h ?b \\<longrightarrow>\n   merge_tree h m ?a ?b = None)", "show\n      \"?h a = ?h b \\<Longrightarrow> \\<exists>ab. ?m a b = Some ab \\<and> ?bo a ab \\<and> ?bo b ab \\<and> (\\<forall>u. ?bo a u \\<longrightarrow> ?bo b u \\<longrightarrow> ?bo ab u)\"\n      \"?h a \\<noteq> ?h b \\<Longrightarrow> ?m a b = None\"\n      if \"a \\<in> ?A\" for a b"], ["proof (prove)\nusing this:\n  ?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  (hash_tree h ?a = hash_tree h ?b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m ?a ?b = Some ab \\<and>\n       blinding_of_tree h bo ?a ab \\<and>\n       blinding_of_tree h bo ?b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo ?a u \\<longrightarrow>\n           blinding_of_tree h bo ?b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h ?a \\<noteq> hash_tree h ?b \\<longrightarrow>\n   merge_tree h m ?a ?b = None)\n\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_tree h m a b = Some ab \\<and>\n        blinding_of_tree h bo a ab \\<and>\n        blinding_of_tree h bo b ab \\<and>\n        (\\<forall>u.\n            blinding_of_tree h bo a u \\<longrightarrow>\n            blinding_of_tree h bo b u \\<longrightarrow>\n            blinding_of_tree h bo ab u)) &&&\n    (hash_tree h a \\<noteq> hash_tree h b \\<Longrightarrow>\n     merge_tree h m a b = None)", "using that"], ["proof (prove)\nusing this:\n  ?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} \\<Longrightarrow>\n  (hash_tree h ?a = hash_tree h ?b \\<longrightarrow>\n   (\\<exists>ab.\n       merge_tree h m ?a ?b = Some ab \\<and>\n       blinding_of_tree h bo ?a ab \\<and>\n       blinding_of_tree h bo ?b ab \\<and>\n       (\\<forall>u.\n           blinding_of_tree h bo ?a u \\<longrightarrow>\n           blinding_of_tree h bo ?b u \\<longrightarrow>\n           blinding_of_tree h bo ab u))) \\<and>\n  (hash_tree h ?a \\<noteq> hash_tree h ?b \\<longrightarrow>\n   merge_tree h m ?a ?b = None)\n  a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. (hash_tree h a = hash_tree h b \\<Longrightarrow>\n     \\<exists>ab.\n        merge_tree h m a b = Some ab \\<and>\n        blinding_of_tree h bo a ab \\<and>\n        blinding_of_tree h bo b ab \\<and>\n        (\\<forall>u.\n            blinding_of_tree h bo a u \\<longrightarrow>\n            blinding_of_tree h bo b u \\<longrightarrow>\n            blinding_of_tree h bo ab u)) &&&\n    (hash_tree h a \\<noteq> hash_tree h b \\<Longrightarrow>\n     merge_tree h m a b = None)", "by blast+"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A};\n   hash_tree h ?a = hash_tree h ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ab.\n                       merge_tree h m ?a ?b = Some ab \\<and>\n                       blinding_of_tree h bo ?a ab \\<and>\n                       blinding_of_tree h bo ?b ab \\<and>\n                       (\\<forall>u.\n                           blinding_of_tree h bo ?a u \\<longrightarrow>\n                           blinding_of_tree h bo ?b u \\<longrightarrow>\n                           blinding_of_tree h bo ab u)\n  \\<lbrakk>?a \\<in> {x. set1_rose_tree\\<^sub>m x \\<subseteq> A};\n   hash_tree h ?a \\<noteq> hash_tree h ?b\\<rbrakk>\n  \\<Longrightarrow> merge_tree h m ?a ?b = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge_on {x. set1_rose_tree\\<^sub>m x \\<subseteq> A} (hash_tree h)\n   (blinding_of_tree h bo) (merge_tree h m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas merge_tree [locale_witness] = merge_on_tree[where A=UNIV, simplified]"], ["", "lemma option_bind_comm:\n \"((x :: 'a option) \\<bind> (\\<lambda>y. c \\<bind> (\\<lambda>z. f y z))) = (c \\<bind> (\\<lambda>y. x \\<bind> (\\<lambda>z. f z y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bind> (\\<lambda>y. c \\<bind> f y) =\n    c \\<bind> (\\<lambda>y. x \\<bind> (\\<lambda>z. f z y))", "by(cases x; cases c; auto)"], ["", "parametric_constant merge_rt_F\\<^sub>m_parametric [transfer_rule]: merge_rt_F\\<^sub>m_def"], ["", "(************************************************************)"], ["", "subsubsection \\<open>Merkle interface\\<close>"], ["", "(************************************************************)"], ["", "lemma merkle_tree [locale_witness]:\n  assumes \"merkle_interface h bo m\"\n  shows \"merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)", "interpret merge_on UNIV h bo m"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "using assms"], ["proof (prove)\nusing this:\n  merkle_interface h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "unfolding merkle_interface_aux"], ["proof (prove)\nusing this:\n  merge_on UNIV h bo m\n\ngoal (1 subgoal):\n 1. merge_on UNIV h bo m", "."], ["proof (state)\ngoal (1 subgoal):\n 1. merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)", "unfolding merkle_interface_aux[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)", ".."], ["proof (state)\nthis:\n  merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_tree_cong [fundef_cong]:\n  assumes \"\\<And>a b. \\<lbrakk> a \\<in> set1_rose_tree\\<^sub>m x; b \\<in> set1_rose_tree\\<^sub>m y \\<rbrakk> \\<Longrightarrow> m a b = m' a b\"\n  shows \"merge_tree h m x y = merge_tree h m' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_tree h m x y = merge_tree h m' x y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> set1_rose_tree\\<^sub>m x;\n   ?b \\<in> set1_rose_tree\\<^sub>m y\\<rbrakk>\n  \\<Longrightarrow> m ?a ?b = m' ?a ?b\n\ngoal (1 subgoal):\n 1. merge_tree h m x y = merge_tree h m' x y", "apply(induction x y rule: merge_tree.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>a \\<in> set1_blindable\\<^sub>m x \\<bind>\n                                    snds \\<bind>\n                                    set;\n                    b \\<in> set1_blindable\\<^sub>m y \\<bind> snds \\<bind>\n                            set;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set1_rose_tree\\<^sub>m a;\n                        ba \\<in> set1_rose_tree\\<^sub>m b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_tree h m a b =\n                                     merge_tree h m' a b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> set1_rose_tree\\<^sub>m (Tree\\<^sub>m x);\n            b \\<in> set1_rose_tree\\<^sub>m (Tree\\<^sub>m y)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> merge_tree h m (Tree\\<^sub>m x) (Tree\\<^sub>m y) =\n                         merge_tree h m' (Tree\\<^sub>m x) (Tree\\<^sub>m y)", "apply(simp add: bind_UNION)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>\\<exists>x\\<in>set1_blindable\\<^sub>m x.\n                               \\<exists>x\\<in>snds x. a \\<in> set x;\n                    \\<exists>x\\<in>set1_blindable\\<^sub>m y.\n                       \\<exists>x\\<in>snds x. b \\<in> set x;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set1_rose_tree\\<^sub>m a;\n                        ba \\<in> set1_rose_tree\\<^sub>m b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_tree h m a b =\n                                     merge_tree h m' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>set1_blindable\\<^sub>m x.\n                       a \\<in> fsts x \\<or>\n                       (\\<exists>x\\<in>snds x.\n                           \\<exists>x\\<in>set x.\n                              a \\<in> set1_rose_tree\\<^sub>m x);\n            \\<exists>x\\<in>set1_blindable\\<^sub>m y.\n               b \\<in> fsts x \\<or>\n               (\\<exists>x\\<in>snds x.\n                   \\<exists>x\\<in>set x.\n                      b \\<in> set1_rose_tree\\<^sub>m x)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> map_option Tree\\<^sub>m\n                          (merge_rt_F\\<^sub>m h m (hash_tree h)\n                            (merge_tree h m) x y) =\n                         map_option Tree\\<^sub>m\n                          (merge_rt_F\\<^sub>m h m' (hash_tree h)\n                            (merge_tree h m') x y)", "apply(rule arg_cong[where f=\"map_option _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>a b.\n                   \\<lbrakk>\\<exists>x\\<in>set1_blindable\\<^sub>m x.\n                               \\<exists>x\\<in>snds x. a \\<in> set x;\n                    \\<exists>x\\<in>set1_blindable\\<^sub>m y.\n                       \\<exists>x\\<in>snds x. b \\<in> set x;\n                    \\<And>aa ba.\n                       \\<lbrakk>aa \\<in> set1_rose_tree\\<^sub>m a;\n                        ba \\<in> set1_rose_tree\\<^sub>m b\\<rbrakk>\n                       \\<Longrightarrow> m aa ba = m' aa ba\\<rbrakk>\n                   \\<Longrightarrow> merge_tree h m a b =\n                                     merge_tree h m' a b;\n        \\<And>a b.\n           \\<lbrakk>\\<exists>x\\<in>set1_blindable\\<^sub>m x.\n                       a \\<in> fsts x \\<or>\n                       (\\<exists>x\\<in>snds x.\n                           \\<exists>x\\<in>set x.\n                              a \\<in> set1_rose_tree\\<^sub>m x);\n            \\<exists>x\\<in>set1_blindable\\<^sub>m y.\n               b \\<in> fsts x \\<or>\n               (\\<exists>x\\<in>snds x.\n                   \\<exists>x\\<in>set x.\n                      b \\<in> set1_rose_tree\\<^sub>m x)\\<rbrakk>\n           \\<Longrightarrow> m a b = m' a b\\<rbrakk>\n       \\<Longrightarrow> merge_rt_F\\<^sub>m h m (hash_tree h)\n                          (merge_tree h m) x y =\n                         merge_rt_F\\<^sub>m h m' (hash_tree h)\n                          (merge_tree h m') x y", "apply(rule merge_rt_F\\<^sub>m_cong; simp add: bind_UNION; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}