{"file_name": "/home/qj213/afp-2021-10-22/thys/IMO2019/IMO2019_Q5.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMO2019", "problem_names": ["lemma flip_Cons_pos [simp]: \"n > 0 \\<Longrightarrow> flip (x # xs) n = x # flip xs (n - 1)\"", "lemma flip_Cons_0 [simp]: \"flip (x # xs) 0 = (\\<not>x) # xs\"", "lemma flip_append1 [simp]: \"n < length xs \\<Longrightarrow> flip (xs @ ys) n = flip xs n @ ys\"\n  and flip_append2 [simp]: \"n \\<ge> length xs \\<Longrightarrow> n < length xs + length ys \\<Longrightarrow>\n                               flip (xs @ ys) n = xs @ flip ys (n - length xs)\"", "lemma length_flip [simp]: \"length (flip xs i) = length xs\"", "lemma heads_True [simp]: \"heads (True # xs) = 1 + heads xs\"\n  and heads_False [simp]: \"heads (False # xs) = heads xs\"\n  and heads_append [simp]: \"heads (xs @ ys) = heads xs + heads ys\"\n  and heads_Nil [simp]: \"heads [] = 0\"", "lemma heads_Cons: \"heads (x # xs) = (if x then heads xs + 1 else heads xs)\"", "lemma heads_pos: \"True \\<in> set xs \\<Longrightarrow> heads xs > 0\"", "lemma heads_eq_0 [simp]: \"True \\<notin> set xs \\<Longrightarrow> heads xs = 0\"", "lemma heads_eq_0_iff [simp]: \"heads xs = 0 \\<longleftrightarrow> True \\<notin> set xs\"", "lemma heads_pos_iff [simp]: \"heads xs > 0 \\<longleftrightarrow> True \\<in> set xs\"", "lemma heads_le_length: \"heads xs \\<le> length xs\"", "lemma length_harry_step [simp]: \"length (harry_step xs) = length xs\"", "lemmas [simp del] = harry_meas.simps", "lemma head_last_cases [case_names Nil True False False_True]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n  assumes \"\\<And>ys. xs = True # ys \\<Longrightarrow> P\" \"\\<And>ys. xs = ys @ [False] \\<Longrightarrow> P\"\n          \"\\<And>ys. xs = False # ys @ [True] \\<Longrightarrow> P\"\n  shows   \"P\"", "lemma harry_meas_Nil [simp]: \"harry_meas [] = 0\"", "lemma harry_meas_True_start [simp]: \"harry_meas (True # xs) = 1 + harry_meas xs\"", "lemma harry_meas_False_end [simp]: \"harry_meas (xs @ [False]) = harry_meas xs\"", "lemma harry_meas_False_True: \"harry_meas (False # xs @ [True]) = harry_meas xs + 2 * length xs + 3\"", "lemma harry_meas_eq_0 [simp]:\n  assumes \"True \\<notin> set xs\"\n  shows   \"harry_meas xs = 0\"", "lemma harry_step_True_start [simp]:\n  \"harry_step (True # xs) = (if True \\<in> set xs then True # harry_step xs else False # xs)\"", "lemma harry_step_False_end [simp]:\n  assumes \"True \\<in> set xs\"\n  shows   \"harry_step (xs @ [False]) = harry_step xs @ [False]\"", "lemma harry_step_False_True:\n  assumes \"True \\<in> set xs\"\n  shows \"harry_step (False # xs @ [True]) = False # harry_step xs @ [True]\"", "lemma harry_meas_Falses_True [simp]: \"harry_meas (replicate n False @ [True]) = 2 * n + 1\"", "lemma harry_step_Falses_True [simp]:\n  \"n > 0 \\<Longrightarrow> harry_step (replicate n False @ [True]) = True # replicate (n - 1) False @ [True]\"", "lemma harry_meas_step_aux:\n  assumes \"True \\<in> set xs\"\n  shows   \"harry_meas xs = Suc (harry_meas (harry_step xs))\"", "lemma harry_meas_step: \"True \\<in> set xs \\<Longrightarrow> harry_meas (harry_step xs) = harry_meas xs - 1\"", "lemma harry_meas_eq_0_iff [simp]: \"harry_meas xs = 0 \\<longleftrightarrow> True \\<notin> set xs\"", "lemma True_in_funpow_harry_step:\n  assumes \"n < harry_meas xs\"\n  shows   \"True \\<in> set ((harry_step ^^ n) xs)\"", "lemma True_notin_funpow_harry_step: \"True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\"", "theorem \"harry_meas xs = (LEAST n. True \\<notin> set ((harry_step ^^ n) xs))\"", "lemma length_seqs [dest]: \"xs \\<in> seqs n \\<Longrightarrow> length xs = n\"", "lemma seqs_0 [simp]: \"seqs 0 = {[]}\"", "lemma seqs_Suc: \"seqs (Suc n) = (\\<lambda>xs. True # xs) ` seqs n \\<union> (\\<lambda>xs. False # xs) ` seqs n\"", "lemma seqs_rev [simp]: \"rev ` seqs n = seqs n\"", "lemma seqs_Suc': \"seqs (Suc n) = (\\<lambda>xs. xs @ [True]) ` seqs n \\<union> (\\<lambda>xs. xs @ [False]) ` seqs n\"", "lemma finite_seqs [intro]: \"finite (seqs n)\"", "lemma card_seqs [simp]: \"card (seqs n) = 2 ^ n\"", "lemmas seqs_code [code] = seqs_0 seqs_Suc", "lemma Suc_Suc_induct: \"P 0 \\<Longrightarrow> P (Suc 0) \\<Longrightarrow> (\\<And>n. P n \\<Longrightarrow> P (Suc n) \\<Longrightarrow> P (Suc (Suc n))) \\<Longrightarrow> P n\"", "lemma harry_sum_correct: \"harry_sum n = sum harry_meas (seqs n)\"", "lemma harry_sum_closed_form_aux: \"4 * harry_sum n = n * (n + 1) * 2 ^ n\"", "theorem harry_sum_closed_form: \"harry_sum n = n * (n + 1) * 2 ^ n div 4\""], "translations": [["", "lemma flip_Cons_pos [simp]: \"n > 0 \\<Longrightarrow> flip (x # xs) n = x # flip xs (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> flip (x # xs) n = x # flip xs (n - 1)", "by (cases n) (auto simp: flip_def)"], ["", "lemma flip_Cons_0 [simp]: \"flip (x # xs) 0 = (\\<not>x) # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (x # xs) 0 = (\\<not> x) # xs", "by (simp add: flip_def)"], ["", "lemma flip_append1 [simp]: \"n < length xs \\<Longrightarrow> flip (xs @ ys) n = flip xs n @ ys\"\n  and flip_append2 [simp]: \"n \\<ge> length xs \\<Longrightarrow> n < length xs + length ys \\<Longrightarrow>\n                               flip (xs @ ys) n = xs @ flip ys (n - length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n < length xs \\<Longrightarrow> flip (xs @ ys) n = flip xs n @ ys) &&&\n    (\\<lbrakk>length xs \\<le> n; n < length xs + length ys\\<rbrakk>\n     \\<Longrightarrow> flip (xs @ ys) n = xs @ flip ys (n - length xs))", "by (auto simp: flip_def list_update_append nth_append)"], ["", "lemma length_flip [simp]: \"length (flip xs i) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (flip xs i) = length xs", "by (simp add: flip_def)"], ["", "text \\<open>\n  The following function computes the number of \\<open>H\\<close> in a coin sequence.\n\\<close>"], ["", "definition heads :: \"bool list \\<Rightarrow> nat\" where \"heads xs = length (filter id xs)\""], ["", "lemma heads_True [simp]: \"heads (True # xs) = 1 + heads xs\"\n  and heads_False [simp]: \"heads (False # xs) = heads xs\"\n  and heads_append [simp]: \"heads (xs @ ys) = heads xs + heads ys\"\n  and heads_Nil [simp]: \"heads [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (heads (True # xs) = 1 + heads xs &&& heads (False # xs) = heads xs) &&&\n    heads (xs @ ys) = heads xs + heads ys &&& heads [] = 0", "by (auto simp: heads_def)"], ["", "lemma heads_Cons: \"heads (x # xs) = (if x then heads xs + 1 else heads xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heads (x # xs) = (if x then heads xs + 1 else heads xs)", "by (auto simp: heads_def)"], ["", "lemma heads_pos: \"True \\<in> set xs \\<Longrightarrow> heads xs > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set xs \\<Longrightarrow> 0 < heads xs", "by (induction xs) (auto simp: heads_Cons)"], ["", "lemma heads_eq_0 [simp]: \"True \\<notin> set xs \\<Longrightarrow> heads xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<notin> set xs \\<Longrightarrow> heads xs = 0", "by (induction xs) (auto simp: heads_Cons)"], ["", "lemma heads_eq_0_iff [simp]: \"heads xs = 0 \\<longleftrightarrow> True \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (heads xs = 0) = (True \\<notin> set xs)", "by (induction xs) (auto simp: heads_Cons)"], ["", "lemma heads_pos_iff [simp]: \"heads xs > 0 \\<longleftrightarrow> True \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < heads xs) = (True \\<in> set xs)", "by (induction xs) (auto simp: heads_Cons)"], ["", "lemma heads_le_length: \"heads xs \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heads xs \\<le> length xs", "by (auto simp: heads_def)"], ["", "text \\<open>\n  The following function performs a single step of Harry's process.\n\\<close>"], ["", "definition harry_step :: \"bool list \\<Rightarrow> bool list\" where\n  \"harry_step xs = flip xs (heads xs - 1)\""], ["", "lemma length_harry_step [simp]: \"length (harry_step xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (harry_step xs) = length xs", "by (simp add: harry_step_def)"], ["", "text \\<open>\n  The following is the measure function for Harry's process, i.e. how many steps the process takes\n  to terminate starting from the given sequence. We define it like this now and prove the\n  correctness later.\n\\<close>"], ["", "function harry_meas where\n  \"harry_meas xs =\n     (if xs = [] then 0\n      else if hd xs then 1 + harry_meas (tl xs)\n      else if \\<not>last xs then harry_meas (butlast xs)\n      else let n = length xs in harry_meas (take (n - 2) (tl xs)) + 2 * n - 1)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xs. x = xs \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>xs xsa.\n       xs = xsa \\<Longrightarrow>\n       (if xs = [] then 0\n        else if hd xs then 1 + harry_meas_sumC (tl xs)\n             else if \\<not> last xs then harry_meas_sumC (butlast xs)\n                  else let n = length xs\n                       in harry_meas_sumC (take (n - 2) (tl xs)) + 2 * n -\n                          1) =\n       (if xsa = [] then 0\n        else if hd xsa then 1 + harry_meas_sumC (tl xsa)\n             else if \\<not> last xsa then harry_meas_sumC (butlast xsa)\n                  else let n = length xsa\n                       in harry_meas_sumC (take (n - 2) (tl xsa)) + 2 * n -\n                          1)", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All harry_meas_dom", "by (relation \"Wellfounded.measure length\") (auto simp: min_def)"], ["", "lemmas [simp del] = harry_meas.simps"], ["", "text \\<open>\n  We now prove some simple properties of @{const harry_meas} and @{const harry_step}.\n\\<close>"], ["", "text \\<open>\n  We prove a more convenient case distinction rule for lists that allows us to\n  distinguish between lists starting with @{term True}, ending with @{term False}, and\n  starting with @{term False} and ending with @{term True}.\n\\<close>"], ["", "lemma head_last_cases [case_names Nil True False False_True]:\n  assumes \"xs = [] \\<Longrightarrow> P\"\n  assumes \"\\<And>ys. xs = True # ys \\<Longrightarrow> P\" \"\\<And>ys. xs = ys @ [False] \\<Longrightarrow> P\"\n          \"\\<And>ys. xs = False # ys @ [True] \\<Longrightarrow> P\"\n  shows   \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "consider \"length xs = 0\" | \"length xs = 1\" | \"length xs \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = 0 \\<Longrightarrow> thesis;\n     length xs = 1 \\<Longrightarrow> thesis;\n     2 \\<le> length xs \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = 0 \\<Longrightarrow> ?thesis;\n   length xs = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> length xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs = 0 \\<Longrightarrow> ?thesis;\n   length xs = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> length xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. length xs = 1 \\<Longrightarrow> P\n 3. 2 \\<le> length xs \\<Longrightarrow> P", "assume \"length xs = 1\""], ["proof (state)\nthis:\n  length xs = 1\n\ngoal (3 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. length xs = 1 \\<Longrightarrow> P\n 3. 2 \\<le> length xs \\<Longrightarrow> P", "hence \"xs = [hd xs]\""], ["proof (prove)\nusing this:\n  length xs = 1\n\ngoal (1 subgoal):\n 1. xs = [hd xs]", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = [hd xs]\n\ngoal (3 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. length xs = 1 \\<Longrightarrow> P\n 3. 2 \\<le> length xs \\<Longrightarrow> P", "thus P"], ["proof (prove)\nusing this:\n  xs = [hd xs]\n\ngoal (1 subgoal):\n 1. P", "using assms(2)[of \"[]\"] assms(3)[of \"[]\"]"], ["proof (prove)\nusing this:\n  xs = [hd xs]\n  xs = [True] \\<Longrightarrow> P\n  xs = [] @ [False] \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (cases \"hd xs\") auto"], ["proof (state)\nthis:\n  P\n\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "assume len: \"length xs \\<ge> 2\""], ["proof (state)\nthis:\n  2 \\<le> length xs\n\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "from len"], ["proof (chain)\npicking this:\n  2 \\<le> length xs", "obtain x xs' where *: \"xs = x # xs'\""], ["proof (prove)\nusing this:\n  2 \\<le> length xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs'. xs = x # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  xs = x # xs'\n\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "have **: \"xs' = butlast xs' @ [last xs']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' = butlast xs' @ [last xs']", "using len"], ["proof (prove)\nusing this:\n  2 \\<le> length xs\n\ngoal (1 subgoal):\n 1. xs' = butlast xs' @ [last xs']", "by (subst append_butlast_last_id) (auto simp: *)"], ["proof (state)\nthis:\n  xs' = butlast xs' @ [last xs']\n\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "have [simp]: \"xs = x # butlast xs' @ [last xs']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = x # butlast xs' @ [last xs']", "by (subst *, subst **) auto"], ["proof (state)\nthis:\n  xs = x # butlast xs' @ [last xs']\n\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow> P\n 2. 2 \\<le> length xs \\<Longrightarrow> P", "show P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms(2)[of xs'] assms(3)[of \"x # butlast xs'\"] assms(4)[of \"butlast xs'\"] **"], ["proof (prove)\nusing this:\n  xs = True # xs' \\<Longrightarrow> P\n  xs = (x # butlast xs') @ [False] \\<Longrightarrow> P\n  xs = False # butlast xs' @ [True] \\<Longrightarrow> P\n  xs' = butlast xs' @ [last xs']\n\ngoal (1 subgoal):\n 1. P", "by (cases x; cases \"last xs'\") auto"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. length xs = 0 \\<Longrightarrow> P", "qed (use assms in auto)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma harry_meas_Nil [simp]: \"harry_meas [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas [] = 0", "by (simp add: harry_meas.simps)"], ["", "lemma harry_meas_True_start [simp]: \"harry_meas (True # xs) = 1 + harry_meas xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas (True # xs) = 1 + harry_meas xs", "by (subst harry_meas.simps) auto"], ["", "lemma harry_meas_False_end [simp]: \"harry_meas (xs @ [False]) = harry_meas xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas (xs @ [False]) = harry_meas xs", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. harry_meas ([] @ [False]) = harry_meas []\n 2. \\<And>a xs.\n       harry_meas (xs @ [False]) = harry_meas xs \\<Longrightarrow>\n       harry_meas ((a # xs) @ [False]) = harry_meas (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  harry_meas (xs @ [False]) = harry_meas xs\n\ngoal (2 subgoals):\n 1. harry_meas ([] @ [False]) = harry_meas []\n 2. \\<And>a xs.\n       harry_meas (xs @ [False]) = harry_meas xs \\<Longrightarrow>\n       harry_meas ((a # xs) @ [False]) = harry_meas (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  harry_meas (xs @ [False]) = harry_meas xs\n\ngoal (1 subgoal):\n 1. harry_meas ((x # xs) @ [False]) = harry_meas (x # xs)", "by (cases x) (auto simp: harry_meas.simps)"], ["proof (state)\nthis:\n  harry_meas ((x # xs) @ [False]) = harry_meas (x # xs)\n\ngoal (1 subgoal):\n 1. harry_meas ([] @ [False]) = harry_meas []", "qed (auto simp: harry_meas.simps)"], ["", "lemma harry_meas_False_True: \"harry_meas (False # xs @ [True]) = harry_meas xs + 2 * length xs + 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas (False # xs @ [True]) = harry_meas xs + 2 * length xs + 3", "by (subst harry_meas.simps) auto"], ["", "lemma harry_meas_eq_0 [simp]:\n  assumes \"True \\<notin> set xs\"\n  shows   \"harry_meas xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs = 0", "using assms"], ["proof (prove)\nusing this:\n  True \\<notin> set xs\n\ngoal (1 subgoal):\n 1. harry_meas xs = 0", "by (induction xs rule: rev_induct) auto"], ["", "text \\<open>\n  If the sequence starts with \\<open>H\\<close>, the process runs on the remaining sequence until it\n  terminates and then flips this \\<open>H\\<close> in another single step.\n\\<close>"], ["", "lemma harry_step_True_start [simp]:\n  \"harry_step (True # xs) = (if True \\<in> set xs then True # harry_step xs else False # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_step (True # xs) =\n    (if True \\<in> set xs then True # harry_step xs else False # xs)", "by (auto simp: harry_step_def)"], ["", "text \\<open>\n  If the sequence ends in \\<open>T\\<close>, the process simply runs on the remaining sequence as if it\n  were not present.\n\\<close>"], ["", "lemma harry_step_False_end [simp]:\n  assumes \"True \\<in> set xs\"\n  shows   \"harry_step (xs @ [False]) = harry_step xs @ [False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "have \"harry_step (xs @ [False]) = flip (xs @ [False]) (heads xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = flip (xs @ [False]) (heads xs - 1)", "using heads_le_length[of xs]"], ["proof (prove)\nusing this:\n  heads xs \\<le> length xs\n\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = flip (xs @ [False]) (heads xs - 1)", "by (auto simp: harry_step_def)"], ["proof (state)\nthis:\n  harry_step (xs @ [False]) = flip (xs @ [False]) (heads xs - 1)\n\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "also"], ["proof (state)\nthis:\n  harry_step (xs @ [False]) = flip (xs @ [False]) (heads xs - 1)\n\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "have \"\\<dots> = harry_step xs @ [False]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flip (xs @ [False]) (heads xs - 1) = harry_step xs @ [False]", "using Suc_less_eq assms heads_le_length[of xs]"], ["proof (prove)\nusing this:\n  (Suc ?m < Suc ?n) = (?m < ?n)\n  True \\<in> set xs\n  heads xs \\<le> length xs\n\ngoal (1 subgoal):\n 1. flip (xs @ [False]) (heads xs - 1) = harry_step xs @ [False]", "by (subst flip_append1; fastforce simp: harry_step_def)"], ["proof (state)\nthis:\n  flip (xs @ [False]) (heads xs - 1) = harry_step xs @ [False]\n\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "finally"], ["proof (chain)\npicking this:\n  harry_step (xs @ [False]) = harry_step xs @ [False]", "show ?thesis"], ["proof (prove)\nusing this:\n  harry_step (xs @ [False]) = harry_step xs @ [False]\n\ngoal (1 subgoal):\n 1. harry_step (xs @ [False]) = harry_step xs @ [False]", "."], ["proof (state)\nthis:\n  harry_step (xs @ [False]) = harry_step xs @ [False]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If the sequence starts with \\<open>T\\<close> and ends with \\<open>H\\<close>, the process runs on the remaining\n  sequence inbetween as if these two were not present, eventually leaving a sequence that\n  consists entirely if \\<open>T\\<close> except for a single final \\<open>H\\<close>.\n\\<close>"], ["", "lemma harry_step_False_True:\n  assumes \"True \\<in> set xs\"\n  shows \"harry_step (False # xs @ [True]) = False # harry_step xs @ [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "have \"harry_step (False # xs @ [True]) = False # flip (xs @ [True]) (heads xs - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) =\n    False # flip (xs @ [True]) (heads xs - 1)", "using assms heads_le_length[of xs]"], ["proof (prove)\nusing this:\n  True \\<in> set xs\n  heads xs \\<le> length xs\n\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) =\n    False # flip (xs @ [True]) (heads xs - 1)", "by (auto simp: harry_step_def heads_le_length)"], ["proof (state)\nthis:\n  harry_step (False # xs @ [True]) =\n  False # flip (xs @ [True]) (heads xs - 1)\n\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "also"], ["proof (state)\nthis:\n  harry_step (False # xs @ [True]) =\n  False # flip (xs @ [True]) (heads xs - 1)\n\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "have \"\\<dots> = False # harry_step xs @ [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False # flip (xs @ [True]) (heads xs - 1) =\n    False # harry_step xs @ [True]", "using assms"], ["proof (prove)\nusing this:\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. False # flip (xs @ [True]) (heads xs - 1) =\n    False # harry_step xs @ [True]", "by (subst flip_append1)\n                   (auto simp: harry_step_def Suc_less_SucD heads_le_length less_Suc_eq_le)"], ["proof (state)\nthis:\n  False # flip (xs @ [True]) (heads xs - 1) = False # harry_step xs @ [True]\n\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "finally"], ["proof (chain)\npicking this:\n  harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "show ?thesis"], ["proof (prove)\nusing this:\n  harry_step (False # xs @ [True]) = False # harry_step xs @ [True]\n\ngoal (1 subgoal):\n 1. harry_step (False # xs @ [True]) = False # harry_step xs @ [True]", "."], ["proof (state)\nthis:\n  harry_step (False # xs @ [True]) = False # harry_step xs @ [True]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  That sequence consisting only of \\<open>T\\<close> except for a single final \\<open>H\\<close> is then turned into\n  an all-\\<open>T\\<close> sequence in \\<open>2n+1\\<close> steps.\n\\<close>"], ["", "lemma harry_meas_Falses_True [simp]: \"harry_meas (replicate n False @ [True]) = 2 * n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas (replicate n False @ [True]) = 2 * n + 1", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "hence \"replicate n False @ [True] = False # replicate (n - 1) False @ [True]\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. replicate n False @ [True] = False # replicate (n - 1) False @ [True]", "by (cases n) auto"], ["proof (state)\nthis:\n  replicate n False @ [True] = False # replicate (n - 1) False @ [True]\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "also"], ["proof (state)\nthis:\n  replicate n False @ [True] = False # replicate (n - 1) False @ [True]\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "have \"harry_meas \\<dots> = 2 * n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas (False # replicate (n - 1) False @ [True]) = 2 * n + 1", "using False"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. harry_meas (False # replicate (n - 1) False @ [True]) = 2 * n + 1", "by (simp add: harry_meas_False_True algebra_simps)"], ["proof (state)\nthis:\n  harry_meas (False # replicate (n - 1) False @ [True]) = 2 * n + 1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "finally"], ["proof (chain)\npicking this:\n  harry_meas (replicate n False @ [True]) = 2 * n + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  harry_meas (replicate n False @ [True]) = 2 * n + 1\n\ngoal (1 subgoal):\n 1. harry_meas (replicate n False @ [True]) = 2 * n + 1", "."], ["proof (state)\nthis:\n  harry_meas (replicate n False @ [True]) = 2 * n + 1\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    harry_meas (replicate n False @ [True]) = 2 * n + 1", "qed auto"], ["", "lemma harry_step_Falses_True [simp]:\n  \"n > 0 \\<Longrightarrow> harry_step (replicate n False @ [True]) = True # replicate (n - 1) False @ [True]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    harry_step (replicate n False @ [True]) =\n    True # replicate (n - 1) False @ [True]", "by (cases n) (simp_all add: harry_step_def)"], ["", "subsection \\<open>Correctness of the measure\\<close>"], ["", "text \\<open>\n  We will now show that @{const harry_meas} indeed counts the length of the process.\n  As a first step, we will show that if there is a \\<open>H\\<close> in a sequence, applying a single step\n  decreases the measure by one.\n\\<close>"], ["", "lemma harry_meas_step_aux:\n  assumes \"True \\<in> set xs\"\n  shows   \"harry_meas xs = Suc (harry_meas (harry_step xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "using assms"], ["proof (prove)\nusing this:\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   True \\<in> set ys \\<longrightarrow>\n                   harry_meas ys = Suc (harry_meas (harry_step ys));\n        True \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     True \\<in> set ys \\<longrightarrow>\n     harry_meas ys = Suc (harry_meas (harry_step ys))\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   True \\<in> set ys \\<longrightarrow>\n                   harry_meas ys = Suc (harry_meas (harry_step ys));\n        True \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "hence IH: \"harry_meas ys = Suc (harry_meas (harry_step ys))\"\n    if \"length ys < length xs\" \"True \\<in> set ys\" for ys"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     True \\<in> set ys \\<longrightarrow>\n     harry_meas ys = Suc (harry_meas (harry_step ys))\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. harry_meas ys = Suc (harry_meas (harry_step ys))", "using that"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     True \\<in> set ys \\<longrightarrow>\n     harry_meas ys = Suc (harry_meas (harry_step ys))\n  True \\<in> set xs\n  length ys < length xs\n  True \\<in> set ys\n\ngoal (1 subgoal):\n 1. harry_meas ys = Suc (harry_meas (harry_step ys))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>length ?ys < length xs; True \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> harry_meas ?ys = Suc (harry_meas (harry_step ?ys))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   True \\<in> set ys \\<longrightarrow>\n                   harry_meas ys = Suc (harry_meas (harry_step ys));\n        True \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "proof (cases xs rule: head_last_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = True # ys \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 3. \\<And>ys.\n       xs = ys @ [False] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 4. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "case (True ys)"], ["proof (state)\nthis:\n  xs = True # ys\n\ngoal (4 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = True # ys \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 3. \\<And>ys.\n       xs = ys @ [False] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 4. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = True # ys\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "by (auto simp: IH)"], ["proof (state)\nthis:\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = ys @ [False] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 3. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = ys @ [False] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 3. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "case (False ys)"], ["proof (state)\nthis:\n  xs = ys @ [False]\n\ngoal (3 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = ys @ [False] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))\n 3. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = ys @ [False]\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "using \"1.prems\""], ["proof (prove)\nusing this:\n  xs = ys @ [False]\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "by (auto simp: IH)"], ["proof (state)\nthis:\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "case (False_True ys)"], ["proof (state)\nthis:\n  xs = False # ys @ [True]\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<And>ys.\n       xs = False # ys @ [True] \\<Longrightarrow>\n       harry_meas xs = Suc (harry_meas (harry_step xs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = False # ys @ [True]\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "proof (cases \"True \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "case False"], ["proof (state)\nthis:\n  True \\<notin> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "define n where \"n = length ys + 1\""], ["proof (state)\nthis:\n  n = length ys + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "have \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "by (simp add: n_def)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "from False"], ["proof (chain)\npicking this:\n  True \\<notin> set ys", "have \"ys = replicate (n - 1) False\""], ["proof (prove)\nusing this:\n  True \\<notin> set ys\n\ngoal (1 subgoal):\n 1. ys = replicate (n - 1) False", "unfolding n_def"], ["proof (prove)\nusing this:\n  True \\<notin> set ys\n\ngoal (1 subgoal):\n 1. ys = replicate (length ys + 1 - 1) False", "by (induction ys) auto"], ["proof (state)\nthis:\n  ys = replicate (n - 1) False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "with False_True \\<open>n > 0\\<close>"], ["proof (chain)\npicking this:\n  xs = False # ys @ [True]\n  0 < n\n  ys = replicate (n - 1) False", "have [simp]: \"xs = replicate n False @ [True]\""], ["proof (prove)\nusing this:\n  xs = False # ys @ [True]\n  0 < n\n  ys = replicate (n - 1) False\n\ngoal (1 subgoal):\n 1. xs = replicate n False @ [True]", "by (cases n) auto"], ["proof (state)\nthis:\n  xs = replicate n False @ [True]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))\n 2. \\<lbrakk>xs = False # ys @ [True]; True \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. harry_meas xs = Suc (harry_meas (harry_step xs))", "by auto"], ["proof (state)\nthis:\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = False # ys @ [True]; True \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> harry_meas xs = Suc (harry_meas (harry_step xs))", "qed (auto simp: IH False_True harry_step_False_True harry_meas_False_True)"], ["proof (state)\nthis:\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal (1 subgoal):\n 1. xs = [] \\<Longrightarrow>\n    harry_meas xs = Suc (harry_meas (harry_step xs))", "qed (use 1 in auto)"], ["proof (state)\nthis:\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma harry_meas_step: \"True \\<in> set xs \\<Longrightarrow> harry_meas (harry_step xs) = harry_meas xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set xs \\<Longrightarrow>\n    harry_meas (harry_step xs) = harry_meas xs - 1", "using harry_meas_step_aux[of xs]"], ["proof (prove)\nusing this:\n  True \\<in> set xs \\<Longrightarrow>\n  harry_meas xs = Suc (harry_meas (harry_step xs))\n\ngoal (1 subgoal):\n 1. True \\<in> set xs \\<Longrightarrow>\n    harry_meas (harry_step xs) = harry_meas xs - 1", "by simp"], ["", "text \\<open>\n  Next, we show that the measure is zero if and only if there is no \\<open>H\\<close> left in the sequence.\n\\<close>"], ["", "lemma harry_meas_eq_0_iff [simp]: \"harry_meas xs = 0 \\<longleftrightarrow> True \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_meas xs = 0) = (True \\<notin> set xs)", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          (harry_meas ys = 0) = (True \\<notin> set ys) \\<Longrightarrow>\n       (harry_meas xs = 0) = (True \\<notin> set xs)", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (harry_meas ys = 0) = (True \\<notin> set ys)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          (harry_meas ys = 0) = (True \\<notin> set ys) \\<Longrightarrow>\n       (harry_meas xs = 0) = (True \\<notin> set xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_meas xs = 0) = (True \\<notin> set xs)", "by (cases xs rule: head_last_cases) (auto simp: 1 harry_meas_False_True 1)"], ["proof (state)\nthis:\n  (harry_meas xs = 0) = (True \\<notin> set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It follows by induction that if the measure of a sequence is \\<open>n\\<close>, then iterating the step\n  less than \\<open>n\\<close> times yields a sequence with at least one \\<open>H\\<close> in it, but iterating it exactly\n  \\<open>n\\<close> times yields a sequence that contains no more \\<open>H\\<close>.\n\\<close>"], ["", "lemma True_in_funpow_harry_step:\n  assumes \"n < harry_meas xs\"\n  shows   \"True \\<in> set ((harry_step ^^ n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ n) xs)", "using assms"], ["proof (prove)\nusing this:\n  n < harry_meas xs\n\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ n) xs)", "proof (induction n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 < harry_meas xs \\<Longrightarrow>\n       True \\<in> set ((harry_step ^^ 0) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "case 0"], ["proof (state)\nthis:\n  0 < harry_meas xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 < harry_meas xs \\<Longrightarrow>\n       True \\<in> set ((harry_step ^^ 0) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ 0) xs)", "by (rule ccontr) (use 0 in auto)"], ["proof (state)\nthis:\n  True \\<in> set ((harry_step ^^ 0) xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "case (Suc n)"], ["proof (state)\nthis:\n  n < harry_meas ?xs \\<Longrightarrow>\n  True \\<in> set ((harry_step ^^ n) ?xs)\n  Suc n < harry_meas xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "have \"True \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set xs", "by (rule ccontr) (use Suc in auto)"], ["proof (state)\nthis:\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "have \"(harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)", "by (simp only: funpow_Suc_right o_def)"], ["proof (state)\nthis:\n  (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "also"], ["proof (state)\nthis:\n  (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "have \"True \\<in> set \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ n) (harry_step xs))", "using Suc \\<open>True \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  n < harry_meas ?xs \\<Longrightarrow>\n  True \\<in> set ((harry_step ^^ n) ?xs)\n  Suc n < harry_meas xs\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ n) (harry_step xs))", "by (intro Suc) (auto simp: harry_meas_step)"], ["proof (state)\nthis:\n  True \\<in> set ((harry_step ^^ n) (harry_step xs))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   n < harry_meas xs \\<Longrightarrow>\n                   True \\<in> set ((harry_step ^^ n) xs);\n        Suc n < harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True \\<in> set ((harry_step ^^ Suc n) xs)", "finally"], ["proof (chain)\npicking this:\n  True \\<in> set ((harry_step ^^ Suc n) xs)", "show ?case"], ["proof (prove)\nusing this:\n  True \\<in> set ((harry_step ^^ Suc n) xs)\n\ngoal (1 subgoal):\n 1. True \\<in> set ((harry_step ^^ Suc n) xs)", "."], ["proof (state)\nthis:\n  True \\<in> set ((harry_step ^^ Suc n) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma True_notin_funpow_harry_step: \"True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "proof (induction \"harry_meas xs\" arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "case (Suc n)"], ["proof (state)\nthis:\n  n = harry_meas ?xs \\<Longrightarrow>\n  True \\<notin> set ((harry_step ^^ harry_meas ?xs) ?xs)\n  Suc n = harry_meas xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"True \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<in> set xs", "by (rule ccontr) (use Suc in auto)"], ["proof (state)\nthis:\n  True \\<in> set xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"(harry_step ^^ harry_meas xs) xs = (harry_step ^^ Suc n) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_step ^^ harry_meas xs) xs = (harry_step ^^ Suc n) xs", "by (simp only: Suc)"], ["proof (state)\nthis:\n  (harry_step ^^ harry_meas xs) xs = (harry_step ^^ Suc n) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "also"], ["proof (state)\nthis:\n  (harry_step ^^ harry_meas xs) xs = (harry_step ^^ Suc n) xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"\\<dots> = (harry_step ^^ n) (harry_step xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)", "by (simp only: funpow_Suc_right o_def)"], ["proof (state)\nthis:\n  (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "also"], ["proof (state)\nthis:\n  (harry_step ^^ Suc n) xs = (harry_step ^^ n) (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"\\<dots> = (harry_step ^^ (harry_meas xs - 1)) (harry_step xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (harry_step ^^ n) (harry_step xs) =\n    (harry_step ^^ (harry_meas xs - 1)) (harry_step xs)", "by (simp flip: Suc(2))"], ["proof (state)\nthis:\n  (harry_step ^^ n) (harry_step xs) =\n  (harry_step ^^ (harry_meas xs - 1)) (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "also"], ["proof (state)\nthis:\n  (harry_step ^^ n) (harry_step xs) =\n  (harry_step ^^ (harry_meas xs - 1)) (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"harry_meas xs - 1 = harry_meas (harry_step xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs - 1 = harry_meas (harry_step xs)", "using \\<open>True \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. harry_meas xs - 1 = harry_meas (harry_step xs)", "by (subst harry_meas_step) auto"], ["proof (state)\nthis:\n  harry_meas xs - 1 = harry_meas (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "also"], ["proof (state)\nthis:\n  harry_meas xs - 1 = harry_meas (harry_step xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "have \"True \\<notin> set ((harry_step ^^ \\<dots>) (harry_step xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True\n    \\<notin> set ((harry_step ^^ harry_meas (harry_step xs))\n                   (harry_step xs))", "using Suc \\<open>True \\<in> set xs\\<close>"], ["proof (prove)\nusing this:\n  n = harry_meas ?xs \\<Longrightarrow>\n  True \\<notin> set ((harry_step ^^ harry_meas ?xs) ?xs)\n  Suc n = harry_meas xs\n  True \\<in> set xs\n\ngoal (1 subgoal):\n 1. True\n    \\<notin> set ((harry_step ^^ harry_meas (harry_step xs))\n                   (harry_step xs))", "by (intro Suc) (auto simp: harry_meas_step)"], ["proof (state)\nthis:\n  True\n  \\<notin> set ((harry_step ^^ harry_meas (harry_step xs)) (harry_step xs))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = harry_meas xs \\<Longrightarrow>\n                   True \\<notin> set ((harry_step ^^ harry_meas xs) xs);\n        Suc x = harry_meas xs\\<rbrakk>\n       \\<Longrightarrow> True\n                         \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "finally"], ["proof (chain)\npicking this:\n  True \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "show ?case"], ["proof (prove)\nusing this:\n  True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n\ngoal (1 subgoal):\n 1. True \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "."], ["proof (state)\nthis:\n  True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       0 = harry_meas xs \\<Longrightarrow>\n       True \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "qed auto"], ["", "text \\<open>\n  This shows that the measure is indeed the correct one: It is the smallest number such that\n  iterating Harry's step that often yields a sequence with no heads in it.\n\\<close>"], ["", "theorem \"harry_meas xs = (LEAST n. True \\<notin> set ((harry_step ^^ n) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs = (LEAST n. True \\<notin> set ((harry_step ^^ n) xs))", "proof (rule sym, rule Least_equality, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n 2. \\<And>y.\n       True \\<notin> set ((harry_step ^^ y) xs) \\<Longrightarrow>\n       harry_meas xs \\<le> y", "show \"True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<notin> set ((harry_step ^^ harry_meas xs) xs)", "by (rule True_notin_funpow_harry_step)"], ["proof (state)\nthis:\n  True \\<notin> set ((harry_step ^^ harry_meas xs) xs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       True \\<notin> set ((harry_step ^^ y) xs) \\<Longrightarrow>\n       harry_meas xs \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       True \\<notin> set ((harry_step ^^ y) xs) \\<Longrightarrow>\n       harry_meas xs \\<le> y", "case (2 y)"], ["proof (state)\nthis:\n  True \\<notin> set ((harry_step ^^ y) xs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       True \\<notin> set ((harry_step ^^ y) xs) \\<Longrightarrow>\n       harry_meas xs \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_meas xs \\<le> y", "by (rule ccontr) (use 2 True_in_funpow_harry_step[of y] in auto)"], ["proof (state)\nthis:\n  harry_meas xs \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Average-case analysis\\<close>"], ["", "text \\<open>\n  The set of all coin sequences of a given length.\n\\<close>"], ["", "definition seqs where \"seqs n = {xs :: bool list . length xs = n}\""], ["", "lemma length_seqs [dest]: \"xs \\<in> seqs n \\<Longrightarrow> length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> seqs n \\<Longrightarrow> length xs = n", "by (simp add: seqs_def)"], ["", "lemma seqs_0 [simp]: \"seqs 0 = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs 0 = {[]}", "by (auto simp: seqs_def)"], ["", "text \\<open>\n  The coin sequences of length \\<open>n + 1\\<close> are simply what is obtained by appending either \\<open>H\\<close>\n  or \\<open>T\\<close> to each coin sequence of length \\<open>n\\<close>.\n\\<close>"], ["", "lemma seqs_Suc: \"seqs (Suc n) = (\\<lambda>xs. True # xs) ` seqs n \\<union> (\\<lambda>xs. False # xs) ` seqs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs (Suc n) = (#) True ` seqs n \\<union> (#) False ` seqs n", "by (auto simp: seqs_def length_Suc_conv)"], ["", "text \\<open>\n  The set of coin sequences of length \\<open>n\\<close> is invariant under reversal.\n\\<close>"], ["", "lemma seqs_rev [simp]: \"rev ` seqs n = seqs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` seqs n = seqs n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rev ` seqs n \\<subseteq> seqs n\n 2. seqs n \\<subseteq> rev ` seqs n", "show \"rev ` seqs n \\<subseteq> seqs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` seqs n \\<subseteq> seqs n", "by (auto simp: seqs_def)"], ["proof (state)\nthis:\n  rev ` seqs n \\<subseteq> seqs n\n\ngoal (1 subgoal):\n 1. seqs n \\<subseteq> rev ` seqs n", "hence \"rev ` rev ` seqs n \\<subseteq> rev ` seqs n\""], ["proof (prove)\nusing this:\n  rev ` seqs n \\<subseteq> seqs n\n\ngoal (1 subgoal):\n 1. rev ` rev ` seqs n \\<subseteq> rev ` seqs n", "by blast"], ["proof (state)\nthis:\n  rev ` rev ` seqs n \\<subseteq> rev ` seqs n\n\ngoal (1 subgoal):\n 1. seqs n \\<subseteq> rev ` seqs n", "thus \"seqs n \\<subseteq> rev ` seqs n\""], ["proof (prove)\nusing this:\n  rev ` rev ` seqs n \\<subseteq> rev ` seqs n\n\ngoal (1 subgoal):\n 1. seqs n \\<subseteq> rev ` seqs n", "by (simp add: image_image)"], ["proof (state)\nthis:\n  seqs n \\<subseteq> rev ` seqs n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Hence we get a similar decomposition theorem that appends at the end.\n\\<close>"], ["", "lemma seqs_Suc': \"seqs (Suc n) = (\\<lambda>xs. xs @ [True]) ` seqs n \\<union> (\\<lambda>xs. xs @ [False]) ` seqs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "have \"rev ` rev ` ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union> (\\<lambda>xs. xs @ [False]) ` seqs n) =\n          rev ` ((\\<lambda>xs. True # xs) ` rev ` seqs n \\<union> (\\<lambda>xs. False # xs) ` rev ` seqs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev `\n    rev `\n    ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n     (\\<lambda>xs. xs @ [False]) ` seqs n) =\n    rev ` ((#) True ` rev ` seqs n \\<union> (#) False ` rev ` seqs n)", "unfolding image_Un image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. rev (rev (x @ [True]))) ` seqs n \\<union>\n    (\\<lambda>x. rev (rev (x @ [False]))) ` seqs n =\n    (\\<lambda>x. rev (True # rev x)) ` seqs n \\<union>\n    (\\<lambda>x. rev (False # rev x)) ` seqs n", "by simp"], ["proof (state)\nthis:\n  rev `\n  rev `\n  ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n   (\\<lambda>xs. xs @ [False]) ` seqs n) =\n  rev ` ((#) True ` rev ` seqs n \\<union> (#) False ` rev ` seqs n)\n\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "also"], ["proof (state)\nthis:\n  rev `\n  rev `\n  ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n   (\\<lambda>xs. xs @ [False]) ` seqs n) =\n  rev ` ((#) True ` rev ` seqs n \\<union> (#) False ` rev ` seqs n)\n\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "have \"(\\<lambda>xs. True # xs) ` rev ` seqs n \\<union> (\\<lambda>xs. False # xs) ` rev ` seqs n = seqs (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (#) True ` rev ` seqs n \\<union> (#) False ` rev ` seqs n = seqs (Suc n)", "by (simp add: seqs_Suc)"], ["proof (state)\nthis:\n  (#) True ` rev ` seqs n \\<union> (#) False ` rev ` seqs n = seqs (Suc n)\n\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "finally"], ["proof (chain)\npicking this:\n  rev `\n  rev `\n  ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n   (\\<lambda>xs. xs @ [False]) ` seqs n) =\n  rev ` seqs (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  rev `\n  rev `\n  ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n   (\\<lambda>xs. xs @ [False]) ` seqs n) =\n  rev ` seqs (Suc n)\n\ngoal (1 subgoal):\n 1. seqs (Suc n) =\n    (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. xs @ [False]) ` seqs n", "by (simp add: image_image)"], ["proof (state)\nthis:\n  seqs (Suc n) =\n  (\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n  (\\<lambda>xs. xs @ [False]) ` seqs n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_seqs [intro]: \"finite (seqs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (seqs n)", "by (induction n) (auto simp: seqs_Suc)"], ["", "lemma card_seqs [simp]: \"card (seqs n) = 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (seqs n) = 2 ^ n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. card (seqs 0) = 2 ^ 0\n 2. \\<And>n.\n       card (seqs n) = 2 ^ n \\<Longrightarrow>\n       card (seqs (Suc n)) = 2 ^ Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  card (seqs n) = 2 ^ n\n\ngoal (2 subgoals):\n 1. card (seqs 0) = 2 ^ 0\n 2. \\<And>n.\n       card (seqs n) = 2 ^ n \\<Longrightarrow>\n       card (seqs (Suc n)) = 2 ^ Suc n", "have \"card (seqs (Suc n)) = card ((#) True ` seqs n \\<union> (#) False ` seqs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (seqs (Suc n)) =\n    card ((#) True ` seqs n \\<union> (#) False ` seqs n)", "by (auto simp: seqs_Suc)"], ["proof (state)\nthis:\n  card (seqs (Suc n)) = card ((#) True ` seqs n \\<union> (#) False ` seqs n)\n\ngoal (2 subgoals):\n 1. card (seqs 0) = 2 ^ 0\n 2. \\<And>n.\n       card (seqs n) = 2 ^ n \\<Longrightarrow>\n       card (seqs (Suc n)) = 2 ^ Suc n", "also"], ["proof (state)\nthis:\n  card (seqs (Suc n)) = card ((#) True ` seqs n \\<union> (#) False ` seqs n)\n\ngoal (2 subgoals):\n 1. card (seqs 0) = 2 ^ 0\n 2. \\<And>n.\n       card (seqs n) = 2 ^ n \\<Longrightarrow>\n       card (seqs (Suc n)) = 2 ^ Suc n", "from Suc.IH"], ["proof (chain)\npicking this:\n  card (seqs n) = 2 ^ n", "have \"\\<dots> = 2 ^ Suc n\""], ["proof (prove)\nusing this:\n  card (seqs n) = 2 ^ n\n\ngoal (1 subgoal):\n 1. card ((#) True ` seqs n \\<union> (#) False ` seqs n) = 2 ^ Suc n", "by (subst card_Un_disjoint) (auto simp: card_image)"], ["proof (state)\nthis:\n  card ((#) True ` seqs n \\<union> (#) False ` seqs n) = 2 ^ Suc n\n\ngoal (2 subgoals):\n 1. card (seqs 0) = 2 ^ 0\n 2. \\<And>n.\n       card (seqs n) = 2 ^ n \\<Longrightarrow>\n       card (seqs (Suc n)) = 2 ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  card (seqs (Suc n)) = 2 ^ Suc n", "show ?case"], ["proof (prove)\nusing this:\n  card (seqs (Suc n)) = 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. card (seqs (Suc n)) = 2 ^ Suc n", "."], ["proof (state)\nthis:\n  card (seqs (Suc n)) = 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. card (seqs 0) = 2 ^ 0", "qed auto"], ["", "lemmas seqs_code [code] = seqs_0 seqs_Suc"], ["", "text \\<open>\n  The sum of the measures over all possible coin sequences of a given length (defined\n  as a recurrence relation; correctness proven later).\n\\<close>"], ["", "fun harry_sum :: \"nat \\<Rightarrow> nat\" where\n  \"harry_sum 0 = 0\"\n| \"harry_sum (Suc 0) = 1\"\n| \"harry_sum (Suc (Suc n)) = 2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n\""], ["", "lemma Suc_Suc_induct: \"P 0 \\<Longrightarrow> P (Suc 0) \\<Longrightarrow> (\\<And>n. P n \\<Longrightarrow> P (Suc n) \\<Longrightarrow> P (Suc (Suc n))) \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0; P (Suc 0);\n     \\<And>n.\n        \\<lbrakk>P n; P (Suc n)\\<rbrakk>\n        \\<Longrightarrow> P (Suc (Suc n))\\<rbrakk>\n    \\<Longrightarrow> P n", "by induction_schema (pat_completeness, rule wf_measure[of id], auto)"], ["", "text \\<open>\n  The recurrence relation really does describe the sum over all measures:\n\\<close>"], ["", "lemma harry_sum_correct: \"harry_sum n = sum harry_meas (seqs n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_sum n = sum harry_meas (seqs n)", "proof (induction n rule: Suc_Suc_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "case (3 n)"], ["proof (state)\nthis:\n  harry_sum n = sum harry_meas (seqs n)\n  harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "have \"seqs (Suc (Suc n)) =\n          (\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n          (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union> \n          (\\<lambda>xs. False # xs @ [True]) ` seqs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seqs (Suc (Suc n)) =\n    (\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n    (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n    (\\<lambda>xs. False # xs @ [True]) ` seqs n", "by (subst (1) seqs_Suc, subst (1 2) seqs_Suc') (simp add: image_Un image_image Un_ac seqs_Suc)"], ["proof (state)\nthis:\n  seqs (Suc (Suc n)) =\n  (\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n  (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n  (\\<lambda>xs. False # xs @ [True]) ` seqs n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "also"], ["proof (state)\nthis:\n  seqs (Suc (Suc n)) =\n  (\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n  (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n  (\\<lambda>xs. False # xs @ [True]) ` seqs n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "have \"int (sum harry_meas \\<dots>) =\n               int (harry_sum (Suc n)) +\n               int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) +\n               int (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (sum harry_meas\n          ((\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n           (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n           (\\<lambda>xs. False # xs @ [True]) ` seqs n)) =\n    int (harry_sum (Suc n)) +\n    int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) +\n    int (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True]))", "by (subst sum.union_disjoint sum.reindex, auto simp: inj_on_def 3)+"], ["proof (state)\nthis:\n  int (sum harry_meas\n        ((\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n         (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n         (\\<lambda>xs. False # xs @ [True]) ` seqs n)) =\n  int (harry_sum (Suc n)) +\n  int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) +\n  int (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True]))\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "also"], ["proof (state)\nthis:\n  int (sum harry_meas\n        ((\\<lambda>xs. xs @ [False]) ` seqs (Suc n) \\<union>\n         (\\<lambda>xs. True # xs @ [True]) ` seqs n \\<union>\n         (\\<lambda>xs. False # xs @ [True]) ` seqs n)) =\n  int (harry_sum (Suc n)) +\n  int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) +\n  int (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True]))\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "have \"int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) =\n                2 ^ n + int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) =\n    2 ^ n + int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True]))", "by (subst sum.distrib) auto"], ["proof (state)\nthis:\n  int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) =\n  2 ^ n + int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True]))\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "also"], ["proof (state)\nthis:\n  int (\\<Sum>xs\\<in>seqs n. 1 + harry_meas (xs @ [True])) =\n  2 ^ n + int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True]))\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "have \"(\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True])) = harry_sum n + (2 * n + 3) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True])) =\n    harry_sum n + (2 * n + 3) * 2 ^ n", "by (auto simp: 3 harry_meas_False_True sum.distrib algebra_simps length_seqs)"], ["proof (state)\nthis:\n  (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True])) =\n  harry_sum n + (2 * n + 3) * 2 ^ n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>xs\\<in>seqs n. harry_meas (False # xs @ [True])) =\n  harry_sum n + (2 * n + 3) * 2 ^ n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "have \"harry_sum (Suc n) = (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) + harry_sum n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_sum (Suc n) =\n    (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) + harry_sum n", "unfolding seqs_Suc' 3"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum harry_meas\n     ((\\<lambda>xs. xs @ [True]) ` seqs n \\<union>\n      (\\<lambda>xs. xs @ [False]) ` seqs n) =\n    (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) +\n    sum harry_meas (seqs n)", "by (subst sum.union_disjoint sum.reindex, auto simp: inj_on_def)+"], ["proof (state)\nthis:\n  harry_sum (Suc n) =\n  (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) + harry_sum n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "hence \"int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) = int (harry_sum (Suc n)) - int (harry_sum n)\""], ["proof (prove)\nusing this:\n  harry_sum (Suc n) =\n  (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) + harry_sum n\n\ngoal (1 subgoal):\n 1. int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) =\n    int (harry_sum (Suc n)) - int (harry_sum n)", "by simp"], ["proof (state)\nthis:\n  int (\\<Sum>xs\\<in>seqs n. harry_meas (xs @ [True])) =\n  int (harry_sum (Suc n)) - int (harry_sum n)\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "finally"], ["proof (chain)\npicking this:\n  int (sum harry_meas (seqs (Suc (Suc n)))) =\n  int (harry_sum (Suc n)) +\n  (2 ^ n + (int (harry_sum (Suc n)) - int (harry_sum n))) +\n  int (harry_sum n + (2 * n + 3) * 2 ^ n)", "have \"int (\\<Sum>x\\<in>seqs (Suc (Suc n)). harry_meas x) =\n                  int (2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n)\""], ["proof (prove)\nusing this:\n  int (sum harry_meas (seqs (Suc (Suc n)))) =\n  int (harry_sum (Suc n)) +\n  (2 ^ n + (int (harry_sum (Suc n)) - int (harry_sum n))) +\n  int (harry_sum n + (2 * n + 3) * 2 ^ n)\n\ngoal (1 subgoal):\n 1. int (sum harry_meas (seqs (Suc (Suc n)))) =\n    int (2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n)", "unfolding of_nat_add"], ["proof (prove)\nusing this:\n  int (sum harry_meas (seqs (Suc (Suc n)))) =\n  int (harry_sum (Suc n)) +\n  (2 ^ n + (int (harry_sum (Suc n)) - int (harry_sum n))) +\n  (int (harry_sum n) + int ((2 * n + 3) * 2 ^ n))\n\ngoal (1 subgoal):\n 1. int (sum harry_meas (seqs (Suc (Suc n)))) =\n    int (2 * harry_sum (Suc n)) + int ((2 * n + 4) * 2 ^ n)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  int (sum harry_meas (seqs (Suc (Suc n)))) =\n  int (2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n)\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "hence \"(\\<Sum>x\\<in>seqs (Suc (Suc n)). (harry_meas x)) =\n            (2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n)\""], ["proof (prove)\nusing this:\n  int (sum harry_meas (seqs (Suc (Suc n)))) =\n  int (2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n)\n\ngoal (1 subgoal):\n 1. sum harry_meas (seqs (Suc (Suc n))) =\n    2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n", "by linarith"], ["proof (state)\nthis:\n  sum harry_meas (seqs (Suc (Suc n))) =\n  2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n\n\ngoal (3 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))\n 3. \\<And>n.\n       \\<lbrakk>harry_sum n = sum harry_meas (seqs n);\n        harry_sum (Suc n) = sum harry_meas (seqs (Suc n))\\<rbrakk>\n       \\<Longrightarrow> harry_sum (Suc (Suc n)) =\n                         sum harry_meas (seqs (Suc (Suc n)))", "thus ?case"], ["proof (prove)\nusing this:\n  sum harry_meas (seqs (Suc (Suc n))) =\n  2 * harry_sum (Suc n) + (2 * n + 4) * 2 ^ n\n\ngoal (1 subgoal):\n 1. harry_sum (Suc (Suc n)) = sum harry_meas (seqs (Suc (Suc n)))", "by simp"], ["proof (state)\nthis:\n  harry_sum (Suc (Suc n)) = sum harry_meas (seqs (Suc (Suc n)))\n\ngoal (2 subgoals):\n 1. harry_sum 0 = sum harry_meas (seqs 0)\n 2. harry_sum (Suc 0) = sum harry_meas (seqs (Suc 0))", "qed (auto simp: seqs_Suc)"], ["", "lemma harry_sum_closed_form_aux: \"4 * harry_sum n = n * (n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * harry_sum n = n * (n + 1) * 2 ^ n", "by (induction n rule: harry_sum.induct) (auto simp: algebra_simps)"], ["", "text \\<open>\n  Solving the recurrence gives us the following solution:\n\\<close>"], ["", "theorem harry_sum_closed_form: \"harry_sum n = n * (n + 1) * 2 ^ n div 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_sum n = n * (n + 1) * 2 ^ n div 4", "using harry_sum_closed_form_aux[of n]"], ["proof (prove)\nusing this:\n  4 * harry_sum n = n * (n + 1) * 2 ^ n\n\ngoal (1 subgoal):\n 1. harry_sum n = n * (n + 1) * 2 ^ n div 4", "by simp"], ["", "text \\<open>\n  The average is now a simple consequence:\n\\<close>"], ["", "definition harry_avg where \"harry_avg n = harry_sum n / card (seqs n)\""], ["", "corollary \"harry_avg n = n * (n + 1) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harry_avg n = real n * (real n + 1) / 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. harry_avg n = real n * (real n + 1) / 4", "have \"real (4 * harry_sum n) = n * (n + 1) * 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (4 * harry_sum n) = real (n * (n + 1) * 2 ^ n)", "by (subst harry_sum_closed_form_aux) auto"], ["proof (state)\nthis:\n  real (4 * harry_sum n) = real (n * (n + 1) * 2 ^ n)\n\ngoal (1 subgoal):\n 1. harry_avg n = real n * (real n + 1) / 4", "hence \"real (harry_sum n) = n * (n + 1) * 2 ^ n / 4\""], ["proof (prove)\nusing this:\n  real (4 * harry_sum n) = real (n * (n + 1) * 2 ^ n)\n\ngoal (1 subgoal):\n 1. real (harry_sum n) = real (n * (n + 1) * 2 ^ n) / 4", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real (harry_sum n) = real (n * (n + 1) * 2 ^ n) / 4\n\ngoal (1 subgoal):\n 1. harry_avg n = real n * (real n + 1) / 4", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (harry_sum n) = real (n * (n + 1) * 2 ^ n) / 4\n\ngoal (1 subgoal):\n 1. harry_avg n = real n * (real n + 1) / 4", "by (simp add: harry_avg_def field_simps)"], ["proof (state)\nthis:\n  harry_avg n = real n * (real n + 1) / 4\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}