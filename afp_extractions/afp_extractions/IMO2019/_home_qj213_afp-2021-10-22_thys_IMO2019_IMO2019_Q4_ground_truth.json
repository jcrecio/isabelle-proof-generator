{"file_name": "/home/qj213/afp-2021-10-22/thys/IMO2019/IMO2019_Q4.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMO2019", "problem_names": ["lemma Sigma_insert: \"Sigma (insert x A) f = (\\<lambda>y. (x, y)) ` f x \\<union> Sigma A f\"", "lemma atLeastAtMost_nat_numeral:\n  \"{(m::nat)..numeral k} = \n     (if m \\<le> numeral k then insert (numeral k) {m..pred_numeral k} else {})\"", "lemma greaterThanAtMost_nat_numeral:\n  \"{(m::nat)<..numeral k} = \n     (if m < numeral k then insert (numeral k) {m<..pred_numeral k} else {})\"", "lemma fact_ge_power:\n  fixes c :: nat\n  assumes \"fact n0 \\<ge> c ^ n0\" \"c \\<le> n0 + 1\"\n  assumes \"n \\<ge> n0\"\n  shows   \"fact n \\<ge> c ^ n\"", "lemma prime_multiplicity_prime:\n  fixes p q :: \"'a :: factorial_semiring\"\n  assumes \"prime p\" \"prime q\"\n  shows   \"multiplicity p q = (if p = q then 1 else 0)\"", "lemma multiplicity_prime_fact:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows   \"multiplicity p (fact n) = legendre_aux n p\"", "lemma legendre_aux_ge:\n  assumes \"prime p\" \"k \\<ge> 1\"\n  shows   \"legendre_aux k p \\<ge> nat \\<lfloor>k / p\\<rfloor>\"", "lemma legendre_aux_less:\n  assumes \"prime p\" \"k \\<ge> 1\"\n  shows   \"legendre_aux k p < k / (p - 1)\"", "lemma rhs_altdef: \"rhs = 2 ^ T * (\\<Prod>i=1..n. 2 ^ i - 1)\"", "lemma multiplicity_2_rhs [simp]: \"multiplicity 2 rhs = T\"", "lemma k_gt_T: \"k > T\"", "lemma T_ge_half_k: \"T \\<ge> k div 2\"", "lemma rhs_less: \"rhs < 2 ^ n\\<^sup>2\"", "lemma n_less_7: \"n < 7\"", "lemma n_k_in_set: \"(n, k) \\<in> {(1, 1), (2, 3)}\"", "theorem \"{(n, k). n > 0 \\<and> k > 0 \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i :: nat)} = {(1, 1), (2, 3)}\"\n  (is \"?lhs = ?rhs\")"], "translations": [["", "lemma Sigma_insert: \"Sigma (insert x A) f = (\\<lambda>y. (x, y)) ` f x \\<union> Sigma A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma (insert x A) f = Pair x ` f x \\<union> Sigma A f", "by auto"], ["", "lemma atLeastAtMost_nat_numeral:\n  \"{(m::nat)..numeral k} = \n     (if m \\<le> numeral k then insert (numeral k) {m..pred_numeral k} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..numeral k} =\n    (if m \\<le> numeral k then insert (numeral k) {m..pred_numeral k}\n     else {})", "by (auto simp: numeral_eq_Suc)"], ["", "lemma greaterThanAtMost_nat_numeral:\n  \"{(m::nat)<..numeral k} = \n     (if m < numeral k then insert (numeral k) {m<..pred_numeral k} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m<..numeral k} =\n    (if m < numeral k then insert (numeral k) {m<..pred_numeral k} else {})", "by (auto simp: numeral_eq_Suc)"], ["", "lemma fact_ge_power:\n  fixes c :: nat\n  assumes \"fact n0 \\<ge> c ^ n0\" \"c \\<le> n0 + 1\"\n  assumes \"n \\<ge> n0\"\n  shows   \"fact n \\<ge> c ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ^ n \\<le> fact n", "using assms(3,1,2)"], ["proof (prove)\nusing this:\n  n0 \\<le> n\n  c ^ n0 \\<le> fact n0\n  c \\<le> n0 + 1\n\ngoal (1 subgoal):\n 1. c ^ n \\<le> fact n", "proof (induction n rule: dec_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n    \\<Longrightarrow> c ^ n0 \\<le> fact n0\n 2. \\<And>na.\n       \\<lbrakk>n0 \\<le> na; na < n;\n        \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n        \\<Longrightarrow> c ^ na \\<le> fact na;\n        c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n       \\<Longrightarrow> c ^ Suc na \\<le> fact (Suc na)", "case (step n)"], ["proof (state)\nthis:\n  n0 \\<le> n\n  n < n\n  \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n  \\<Longrightarrow> c ^ n \\<le> fact n\n  c ^ n0 \\<le> fact n0\n  c \\<le> n0 + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n    \\<Longrightarrow> c ^ n0 \\<le> fact n0\n 2. \\<And>na.\n       \\<lbrakk>n0 \\<le> na; na < n;\n        \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n        \\<Longrightarrow> c ^ na \\<le> fact na;\n        c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n       \\<Longrightarrow> c ^ Suc na \\<le> fact (Suc na)", "have \"c * c ^ n \\<le> Suc n * fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * c ^ n \\<le> Suc n * fact n", "using step"], ["proof (prove)\nusing this:\n  n0 \\<le> n\n  n < n\n  \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n  \\<Longrightarrow> c ^ n \\<le> fact n\n  c ^ n0 \\<le> fact n0\n  c \\<le> n0 + 1\n\ngoal (1 subgoal):\n 1. c * c ^ n \\<le> Suc n * fact n", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  c * c ^ n \\<le> Suc n * fact n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n    \\<Longrightarrow> c ^ n0 \\<le> fact n0\n 2. \\<And>na.\n       \\<lbrakk>n0 \\<le> na; na < n;\n        \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n        \\<Longrightarrow> c ^ na \\<le> fact na;\n        c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n       \\<Longrightarrow> c ^ Suc na \\<le> fact (Suc na)", "thus ?case"], ["proof (prove)\nusing this:\n  c * c ^ n \\<le> Suc n * fact n\n\ngoal (1 subgoal):\n 1. c ^ Suc n \\<le> fact (Suc n)", "by simp"], ["proof (state)\nthis:\n  c ^ Suc n \\<le> fact (Suc n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c ^ n0 \\<le> fact n0; c \\<le> n0 + 1\\<rbrakk>\n    \\<Longrightarrow> c ^ n0 \\<le> fact n0", "qed auto"], ["", "lemma prime_multiplicity_prime:\n  fixes p q :: \"'a :: factorial_semiring\"\n  assumes \"prime p\" \"prime q\"\n  shows   \"multiplicity p q = (if p = q then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p q = (if p = q then 1 else 0)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n\ngoal (1 subgoal):\n 1. multiplicity p q = (if p = q then 1 else 0)", "by (auto simp: prime_multiplicity_other)"], ["", "text \\<open>\n  We use Legendre's identity from the library. One could easily prove the property in question\n  without the library, but it probably still saves a few lines.\n\n  @{const legendre_aux} (related to Legendre's identity) is the multiplicity of a given prime\n  in the prime factorisation of \\<open>n!\\<close>.\n\\<close>"], ["", "(* TODO: Move? *)"], ["", "lemma multiplicity_prime_fact:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows   \"multiplicity p (fact n) = legendre_aux n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (fact n) = legendre_aux (real n) p", "proof (cases \"p \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "case True"], ["proof (state)\nthis:\n  p \\<le> n\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "have \"fact n = (\\<Prod>p | prime p \\<and> p \\<le> n. p ^ legendre_aux n p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact n =\n    (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n       p ^ legendre_aux (real n) p)", "using legendre_identity'[of \"real n\"]"], ["proof (prove)\nusing this:\n  fact (nat \\<lfloor>real n\\<rfloor>) =\n  (\\<Prod>p\\<in>{p. prime p \\<and> real p \\<le> real n}.\n     p ^ legendre_aux (real n) p)\n\ngoal (1 subgoal):\n 1. fact n =\n    (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n       p ^ legendre_aux (real n) p)", "by simp"], ["proof (state)\nthis:\n  fact n =\n  (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}. p ^ legendre_aux (real n) p)\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "also"], ["proof (state)\nthis:\n  fact n =\n  (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}. p ^ legendre_aux (real n) p)\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "have \"multiplicity p \\<dots> = (\\<Sum>q | prime q \\<and> q \\<le> n. multiplicity p (q ^ legendre_aux n q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p\n     (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n        p ^ legendre_aux (real n) p) =\n    (\\<Sum>q | prime q \\<and> q \\<le> n.\n       multiplicity p (q ^ legendre_aux (real n) q))", "using assms"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. multiplicity p\n     (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n        p ^ legendre_aux (real n) p) =\n    (\\<Sum>q | prime q \\<and> q \\<le> n.\n       multiplicity p (q ^ legendre_aux (real n) q))", "by (subst prime_elem_multiplicity_prod_distrib) auto"], ["proof (state)\nthis:\n  multiplicity p\n   (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n      p ^ legendre_aux (real n) p) =\n  (\\<Sum>q | prime q \\<and> q \\<le> n.\n     multiplicity p (q ^ legendre_aux (real n) q))\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "also"], ["proof (state)\nthis:\n  multiplicity p\n   (\\<Prod>p\\<in>{p. prime p \\<and> p \\<le> n}.\n      p ^ legendre_aux (real n) p) =\n  (\\<Sum>q | prime q \\<and> q \\<le> n.\n     multiplicity p (q ^ legendre_aux (real n) q))\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "have \"\\<dots> = (\\<Sum>q\\<in>{p}. legendre_aux n q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q | prime q \\<and> q \\<le> n.\n       multiplicity p (q ^ legendre_aux (real n) q)) =\n    sum (legendre_aux (real n)) {p}", "using assms \\<open>p \\<le> n\\<close> prime_multiplicity_other[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p \\<le> n\n  \\<lbrakk>prime p; prime ?q; p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> multiplicity p ?q = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>q | prime q \\<and> q \\<le> n.\n       multiplicity p (q ^ legendre_aux (real n) q)) =\n    sum (legendre_aux (real n)) {p}", "by (intro sum.mono_neutral_cong_right)\n       (auto simp: prime_elem_multiplicity_power_distrib prime_multiplicity_prime split: if_splits)"], ["proof (state)\nthis:\n  (\\<Sum>q | prime q \\<and> q \\<le> n.\n     multiplicity p (q ^ legendre_aux (real n) q)) =\n  sum (legendre_aux (real n)) {p}\n\ngoal (2 subgoals):\n 1. p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p\n 2. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "finally"], ["proof (chain)\npicking this:\n  multiplicity p (fact n) = sum (legendre_aux (real n)) {p}", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity p (fact n) = sum (legendre_aux (real n)) {p}\n\ngoal (1 subgoal):\n 1. multiplicity p (fact n) = legendre_aux (real n) p", "by simp"], ["proof (state)\nthis:\n  multiplicity p (fact n) = legendre_aux (real n) p\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "case False"], ["proof (state)\nthis:\n  \\<not> p \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "hence \"multiplicity p (fact n) = 0\""], ["proof (prove)\nusing this:\n  \\<not> p \\<le> n\n\ngoal (1 subgoal):\n 1. multiplicity p (fact n) = 0", "using assms"], ["proof (prove)\nusing this:\n  \\<not> p \\<le> n\n  prime p\n\ngoal (1 subgoal):\n 1. multiplicity p (fact n) = 0", "by (intro not_dvd_imp_multiplicity_0) (auto simp: prime_dvd_fact_iff)"], ["proof (state)\nthis:\n  multiplicity p (fact n) = 0\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "moreover"], ["proof (state)\nthis:\n  multiplicity p (fact n) = 0\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "from False"], ["proof (chain)\npicking this:\n  \\<not> p \\<le> n", "have \"legendre_aux (real n) p = 0\""], ["proof (prove)\nusing this:\n  \\<not> p \\<le> n\n\ngoal (1 subgoal):\n 1. legendre_aux (real n) p = 0", "by (intro legendre_aux_eq_0) auto"], ["proof (state)\nthis:\n  legendre_aux (real n) p = 0\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> n \\<Longrightarrow>\n    multiplicity p (fact n) = legendre_aux (real n) p", "ultimately"], ["proof (chain)\npicking this:\n  multiplicity p (fact n) = 0\n  legendre_aux (real n) p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity p (fact n) = 0\n  legendre_aux (real n) p = 0\n\ngoal (1 subgoal):\n 1. multiplicity p (fact n) = legendre_aux (real n) p", "by simp"], ["proof (state)\nthis:\n  multiplicity p (fact n) = legendre_aux (real n) p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following are simple and trivial lower and upper bounds for @{const legendre_aux}:\n\\<close>"], ["", "lemma legendre_aux_ge:\n  assumes \"prime p\" \"k \\<ge> 1\"\n  shows   \"legendre_aux k p \\<ge> nat \\<lfloor>k / p\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "proof (cases \"k \\<ge> p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p\n 2. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "case True"], ["proof (state)\nthis:\n  real p \\<le> k\n\ngoal (2 subgoals):\n 1. real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p\n 2. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "have \"(\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>) \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k. nat \\<lfloor>k / real p ^ m\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>)\n    \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k.\n             nat \\<lfloor>k / real p ^ m\\<rfloor>)", "using True finite_sum_legendre_aux[of p] assms"], ["proof (prove)\nusing this:\n  real p \\<le> k\n  prime p \\<Longrightarrow> finite {m. 0 < m \\<and> real (p ^ m) \\<le> ?x}\n  prime p\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>)\n    \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k.\n             nat \\<lfloor>k / real p ^ m\\<rfloor>)", "by (intro sum_mono2) auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>)\n  \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k.\n           nat \\<lfloor>k / real p ^ m\\<rfloor>)\n\ngoal (2 subgoals):\n 1. real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p\n 2. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "with assms True"], ["proof (chain)\npicking this:\n  prime p\n  1 \\<le> k\n  real p \\<le> k\n  (\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>)\n  \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k.\n           nat \\<lfloor>k / real p ^ m\\<rfloor>)", "show ?thesis"], ["proof (prove)\nusing this:\n  prime p\n  1 \\<le> k\n  real p \\<le> k\n  (\\<Sum>m\\<in>{1}. nat \\<lfloor>k / real p ^ m\\<rfloor>)\n  \\<le> (\\<Sum>m | 0 < m \\<and> real p ^ m \\<le> k.\n           nat \\<lfloor>k / real p ^ m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "by (simp add: legendre_aux_def)"], ["proof (state)\nthis:\n  nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p\n\ngoal (1 subgoal):\n 1. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "case False"], ["proof (state)\nthis:\n  \\<not> real p \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  1 \\<le> k\n  \\<not> real p \\<le> k", "have \"k / p < 1\""], ["proof (prove)\nusing this:\n  prime p\n  1 \\<le> k\n  \\<not> real p \\<le> k\n\ngoal (1 subgoal):\n 1. k / real p < 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  k / real p < 1\n\ngoal (1 subgoal):\n 1. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "hence \"nat \\<lfloor>k / p\\<rfloor> = 0\""], ["proof (prove)\nusing this:\n  k / real p < 1\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>k / real p\\<rfloor> = 0", "by simp"], ["proof (state)\nthis:\n  nat \\<lfloor>k / real p\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. \\<not> real p \\<le> k \\<Longrightarrow>\n    nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "with False"], ["proof (chain)\npicking this:\n  \\<not> real p \\<le> k\n  nat \\<lfloor>k / real p\\<rfloor> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> real p \\<le> k\n  nat \\<lfloor>k / real p\\<rfloor> = 0\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p", "by (simp add: legendre_aux_eq_0)"], ["proof (state)\nthis:\n  nat \\<lfloor>k / real p\\<rfloor> \\<le> legendre_aux k p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma legendre_aux_less:\n  assumes \"prime p\" \"k \\<ge> 1\"\n  shows   \"legendre_aux k p < k / (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"(\\<lambda>m. (k / p) * (1 / p) ^ m) sums ((k / p) * (1 / (1 - 1 / p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. k / real p * (1 / real p) ^ m) sums\n    (k / real p * (1 / (1 - 1 / real p)))", "using assms prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  prime p\n  1 \\<le> k\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. k / real p * (1 / real p) ^ m) sums\n    (k / real p * (1 / (1 - 1 / real p)))", "by (intro sums_mult geometric_sums) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (\\<lambda>m. k / real p * (1 / real p) ^ m) sums\n  (k / real p * (1 / (1 - 1 / real p)))\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "hence sums: \"(\\<lambda>m. k / p ^ Suc m) sums (k / (p - 1))\""], ["proof (prove)\nusing this:\n  (\\<lambda>m. k / real p * (1 / real p) ^ m) sums\n  (k / real p * (1 / (1 - 1 / real p)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. k / real (p ^ Suc m)) sums (k / real (p - 1))", "using assms prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  (\\<lambda>m. k / real p * (1 / real p) ^ m) sums\n  (k / real p * (1 / (1 - 1 / real p)))\n  prime p\n  1 \\<le> k\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. k / real (p ^ Suc m)) sums (k / real (p - 1))", "by (simp add: field_simps of_nat_diff)"], ["proof (state)\nthis:\n  (\\<lambda>m. k / real (p ^ Suc m)) sums (k / real (p - 1))\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"real (legendre_aux k p) = (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}. of_int \\<lfloor>k / real p ^ m\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (legendre_aux k p) =\n    (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n       real_of_int \\<lfloor>k / real p ^ m\\<rfloor>)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) =\n    (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n       real_of_int \\<lfloor>k / real p ^ m\\<rfloor>)", "by (simp add: legendre_aux_altdef1)"], ["proof (state)\nthis:\n  real (legendre_aux k p) =\n  (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n     real_of_int \\<lfloor>k / real p ^ m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "also"], ["proof (state)\nthis:\n  real (legendre_aux k p) =\n  (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n     real_of_int \\<lfloor>k / real p ^ m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"\\<dots> = (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n       real_of_int \\<lfloor>k / real p ^ m\\<rfloor>) =\n    (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n        real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)", "by (intro sum.reindex_bij_witness[of _ Suc \"\\<lambda>i. i - 1\"]) (auto simp flip: power_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n     real_of_int \\<lfloor>k / real p ^ m\\<rfloor>) =\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n      real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0<..nat \\<lfloor>log (real p) k\\<rfloor>}.\n     real_of_int \\<lfloor>k / real p ^ m\\<rfloor>) =\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n      real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"\\<dots> \\<le> (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n        real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\n    \\<le> (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)", "by (intro sum_mono) auto"], ["proof (state)\nthis:\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n      real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\n  \\<le> (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>.\n      real_of_int \\<lfloor>k / real p ^ Suc m\\<rfloor>)\n  \\<le> (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"\\<dots> < (\\<Sum>m. k / real p ^ Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n    < (\\<Sum>m. k / real p ^ Suc m)", "using sums assms prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  (\\<lambda>m. k / real (p ^ Suc m)) sums (k / real (p - 1))\n  prime p\n  1 \\<le> k\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n    < (\\<Sum>m. k / real p ^ Suc m)", "by (intro sum_less_suminf) (auto simp: sums_iff intro!: divide_pos_pos)"], ["proof (state)\nthis:\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n  < (\\<Sum>m. k / real p ^ Suc m)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<nat \\<lfloor>log (real p) k\\<rfloor>. k / real p ^ Suc m)\n  < (\\<Sum>m. k / real p ^ Suc m)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "have \"\\<dots> = k / (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. k / real p ^ Suc m) = k / real (p - 1)", "using sums"], ["proof (prove)\nusing this:\n  (\\<lambda>m. k / real (p ^ Suc m)) sums (k / real (p - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m. k / real p ^ Suc m) = k / real (p - 1)", "by (simp add: sums_iff)"], ["proof (state)\nthis:\n  (\\<Sum>m. k / real p ^ Suc m) = k / real (p - 1)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "finally"], ["proof (chain)\npicking this:\n  real (legendre_aux k p) < k / real (p - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (legendre_aux k p) < k / real (p - 1)\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "using assms prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  real (legendre_aux k p) < k / real (p - 1)\n  prime p\n  1 \\<le> k\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. real (legendre_aux k p) < k / (real p - 1)", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  real (legendre_aux k p) < k / (real p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Main result\\<close>"], ["", "text \\<open>\n  Now we move on to the main result: We fix two numbers \\<open>n\\<close> and \\<open>k\\<close> with the property\n  in question and derive facts from that.\n\n  The triangle number $T = n(n+1)/2$ is of particular importance here, so we introduce an\n  abbreviation for it.\n\\<close>"], ["", "context\n  fixes k n :: nat and rhs T :: nat\n  defines \"rhs \\<equiv> (\\<Prod>i<n. 2 ^ n - 2 ^ i)\"\n  defines \"T \\<equiv> (n * (n - 1)) div 2\"\n  assumes pos: \"k > 0\" \"n > 0\"\n  assumes k_n: \"fact k = rhs\"\nbegin"], ["", "text \\<open>\n  We can rewrite the right-hand side into a more convenient form:\n\\<close>"], ["", "lemma rhs_altdef: \"rhs = 2 ^ T * (\\<Prod>i=1..n. 2 ^ i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "have \"rhs = (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs = (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1))", "by (simp add: rhs_def algebra_simps flip: power_add)"], ["proof (state)\nthis:\n  rhs = (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1))\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "also"], ["proof (state)\nthis:\n  rhs = (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1))\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "have \"\\<dots> = 2 ^ (\\<Sum>i<n. i) * (\\<Prod>i<n. 2 ^ (n - i) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1)) =\n    2 ^ \\<Sum> {..<n} * (\\<Prod>i<n. 2 ^ (n - i) - 1)", "by (simp add: prod.distrib power_sum)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1)) =\n  2 ^ \\<Sum> {..<n} * (\\<Prod>i<n. 2 ^ (n - i) - 1)\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<n. 2 ^ i * (2 ^ (n - i) - 1)) =\n  2 ^ \\<Sum> {..<n} * (\\<Prod>i<n. 2 ^ (n - i) - 1)\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "have \"(\\<Sum>i<n. i) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {..<n} = T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {..<n} = n * (n - 1) div 2", "using Sum_Ico_nat[of 0 n]"], ["proof (prove)\nusing this:\n  \\<Sum> {0..<n} = (n * (n - 1) - 0 * (0 - 1)) div 2\n\ngoal (1 subgoal):\n 1. \\<Sum> {..<n} = n * (n - 1) div 2", "by (simp add: atLeast0LessThan)"], ["proof (state)\nthis:\n  \\<Sum> {..<n} = T\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "also"], ["proof (state)\nthis:\n  \\<Sum> {..<n} = T\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "have \"(\\<Prod>i<n. 2 ^ (n - i) - 1) = (\\<Prod>i=1..n. 2 ^ i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. (2::'a) ^ (n - i) - (1::'a)) =\n    (\\<Prod>i = 1..n. (2::'a) ^ i - (1::'a))", "by (rule prod.reindex_bij_witness[of _ \"\\<lambda>i. n - i\" \"\\<lambda>i. n - i\"]) auto"], ["proof (state)\nthis:\n  (\\<Prod>i<n. (2::?'a1) ^ (n - i) - (1::?'a1)) =\n  (\\<Prod>i = 1..n. (2::?'a1) ^ i - (1::?'a1))\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "finally"], ["proof (chain)\npicking this:\n  rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "."], ["proof (state)\nthis:\n  rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The multiplicity of 2 in the prime factorisation of the right-hand side is precisely \\<open>T\\<close>.\n\\<close>"], ["", "lemma multiplicity_2_rhs [simp]: \"multiplicity 2 rhs = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "have nz: \"2 ^ i - 1 \\<noteq> (0 :: nat)\" if \"i \\<ge> 1\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ i - 1 \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ i - 1 \\<noteq> 0", "from \\<open>i \\<ge> 1\\<close>"], ["proof (chain)\npicking this:\n  1 \\<le> i", "have \"2 ^ 0 < (2 ^ i :: nat)\""], ["proof (prove)\nusing this:\n  1 \\<le> i\n\ngoal (1 subgoal):\n 1. 2 ^ 0 < 2 ^ i", "by (intro power_strict_increasing) auto"], ["proof (state)\nthis:\n  2 ^ 0 < 2 ^ i\n\ngoal (1 subgoal):\n 1. 2 ^ i - 1 \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ 0 < 2 ^ i\n\ngoal (1 subgoal):\n 1. 2 ^ i - 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  2 ^ i - 1 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> ?i \\<Longrightarrow> 2 ^ ?i - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "have \"multiplicity 2 rhs = T + multiplicity 2 (\\<Prod>i=1..n. 2 ^ i - 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T + multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1)", "using nz"], ["proof (prove)\nusing this:\n  1 \\<le> ?i \\<Longrightarrow> 2 ^ ?i - 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T + multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1)", "by (simp add: rhs_altdef prime_elem_multiplicity_mult_distrib)"], ["proof (state)\nthis:\n  multiplicity 2 rhs = T + multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "also"], ["proof (state)\nthis:\n  multiplicity 2 rhs = T + multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "have \"multiplicity 2 (\\<Prod>i=1..n. 2 ^ i - 1 :: nat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1) = 0", "by (intro not_dvd_imp_multiplicity_0) (auto simp: prime_dvd_prod_iff)"], ["proof (state)\nthis:\n  multiplicity 2 (\\<Prod>i = 1..n. 2 ^ i - 1) = 0\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "finally"], ["proof (chain)\npicking this:\n  multiplicity 2 rhs = T + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity 2 rhs = T + 0\n\ngoal (1 subgoal):\n 1. multiplicity 2 rhs = T", "by simp"], ["proof (state)\nthis:\n  multiplicity 2 rhs = T\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  From Legendre's identities and the associated bounds, it can easily be seen that\n  \\<open>\\<lfloor>k/2\\<rfloor> \\<le> T < k\\<close>:\n\\<close>"], ["", "lemma k_gt_T: \"k > T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T < k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T < k", "have \"T = multiplicity 2 rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = multiplicity 2 rhs", "by simp"], ["proof (state)\nthis:\n  T = multiplicity 2 rhs\n\ngoal (1 subgoal):\n 1. T < k", "also"], ["proof (state)\nthis:\n  T = multiplicity 2 rhs\n\ngoal (1 subgoal):\n 1. T < k", "have \"rhs = fact k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs = fact k", "by (simp add: k_n)"], ["proof (state)\nthis:\n  rhs = fact k\n\ngoal (1 subgoal):\n 1. T < k", "also"], ["proof (state)\nthis:\n  rhs = fact k\n\ngoal (1 subgoal):\n 1. T < k", "have \"multiplicity 2 (fact k :: nat) = legendre_aux k 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 (fact k) = legendre_aux (real k) 2", "by (simp add: multiplicity_prime_fact)"], ["proof (state)\nthis:\n  multiplicity 2 (fact k) = legendre_aux (real k) 2\n\ngoal (1 subgoal):\n 1. T < k", "also"], ["proof (state)\nthis:\n  multiplicity 2 (fact k) = legendre_aux (real k) 2\n\ngoal (1 subgoal):\n 1. T < k", "have \"\\<dots> < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legendre_aux (real k) 2 < k", "using legendre_aux_less[of 2 k] pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime 2; 1 \\<le> real k\\<rbrakk>\n  \\<Longrightarrow> real (legendre_aux (real k) 2) < real k / (real 2 - 1)\n  0 < k\n  0 < n\n\ngoal (1 subgoal):\n 1. legendre_aux (real k) 2 < k", "by simp"], ["proof (state)\nthis:\n  legendre_aux (real k) 2 < k\n\ngoal (1 subgoal):\n 1. T < k", "finally"], ["proof (chain)\npicking this:\n  T < k", "show ?thesis"], ["proof (prove)\nusing this:\n  T < k\n\ngoal (1 subgoal):\n 1. T < k", "."], ["proof (state)\nthis:\n  T < k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma T_ge_half_k: \"T \\<ge> k div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "have \"k div 2 \\<le> legendre_aux k 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k div 2 \\<le> legendre_aux (real k) 2", "using legendre_aux_ge[of 2 k] pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime 2; 1 \\<le> real k\\<rbrakk>\n  \\<Longrightarrow> nat \\<lfloor>real k / real 2\\<rfloor>\n                    \\<le> legendre_aux (real k) 2\n  0 < k\n  0 < n\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> legendre_aux (real k) 2", "by simp linarith?"], ["proof (state)\nthis:\n  k div 2 \\<le> legendre_aux (real k) 2\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "also"], ["proof (state)\nthis:\n  k div 2 \\<le> legendre_aux (real k) 2\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "have \"\\<dots> = multiplicity 2 (fact k :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legendre_aux (real k) 2 = multiplicity 2 (fact k)", "by (simp add: multiplicity_prime_fact)"], ["proof (state)\nthis:\n  legendre_aux (real k) 2 = multiplicity 2 (fact k)\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "also"], ["proof (state)\nthis:\n  legendre_aux (real k) 2 = multiplicity 2 (fact k)\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "have \"\\<dots> = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 (fact k) = T", "by (simp add: k_n)"], ["proof (state)\nthis:\n  multiplicity 2 (fact k) = T\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "finally"], ["proof (chain)\npicking this:\n  k div 2 \\<le> T", "show \"T \\<ge> k div 2\""], ["proof (prove)\nusing this:\n  k div 2 \\<le> T\n\ngoal (1 subgoal):\n 1. k div 2 \\<le> T", "."], ["proof (state)\nthis:\n  k div 2 \\<le> T\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It can also be seen fairly easily that the right-hand side is strictly smaller than $2^{n^2}$:\n\\<close>"], ["", "lemma rhs_less: \"rhs < 2 ^ n\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"rhs = 2 ^ T * (\\<Prod>i=1..n. 2 ^ i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)", "by (simp add: rhs_altdef)"], ["proof (state)\nthis:\n  rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  rhs = 2 ^ T * (\\<Prod>i = 1..n. 2 ^ i - 1)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"(\\<Prod>i=1..n. 2 ^ i - 1 :: nat) < (\\<Prod>i=1..n. 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..n. 2 ^ i - 1) < prod ((^) 2) {1..n}", "using pos"], ["proof (prove)\nusing this:\n  0 < k\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..n. 2 ^ i - 1) < prod ((^) 2) {1..n}", "by (intro prod_mono_strict) auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 1..n. 2 ^ i - 1) < prod ((^) 2) {1..n}\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 1..n. 2 ^ i - 1) < prod ((^) 2) {1..n}\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"\\<dots> = (\\<Prod>i=0..<n. 2 * 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod ((^) 2) {1..n} = (\\<Prod>i = 0..<n. 2 * 2 ^ i)", "by (intro prod.reindex_bij_witness[of _ Suc \"\\<lambda>i. i - 1\"]) (auto simp flip: power_Suc)"], ["proof (state)\nthis:\n  prod ((^) 2) {1..n} = (\\<Prod>i = 0..<n. 2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  prod ((^) 2) {1..n} = (\\<Prod>i = 0..<n. 2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"\\<dots> = 2 ^ n * 2 ^ (\\<Sum>i=0..<n. i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<n. 2 * 2 ^ i) = 2 ^ n * 2 ^ \\<Sum> {0..<n}", "by (simp add: power_sum prod.distrib)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. 2 * 2 ^ i) = 2 ^ n * 2 ^ \\<Sum> {0..<n}\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<n. 2 * 2 ^ i) = 2 ^ n * 2 ^ \\<Sum> {0..<n}\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"(\\<Sum>i=0..<n. i) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {0..<n} = T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum> {0..<n} = n * (n - 1) div 2", "by (simp add: Sum_Ico_nat)"], ["proof (state)\nthis:\n  \\<Sum> {0..<n} = T\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<Sum> {0..<n} = T\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"2 ^ T * (2 ^ n * 2 ^ T :: nat) = 2 ^ (2 * T + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ T * (2 ^ n * 2 ^ T) = 2 ^ (2 * T + n)", "by (simp flip: power_add power_Suc add: algebra_simps)"], ["proof (state)\nthis:\n  2 ^ T * (2 ^ n * 2 ^ T) = 2 ^ (2 * T + n)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "also"], ["proof (state)\nthis:\n  2 ^ T * (2 ^ n * 2 ^ T) = 2 ^ (2 * T + n)\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "have \"2 * T + n = n ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * T + n = n\\<^sup>2", "by (cases \"even n\") (auto simp: T_def algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  2 * T + n = n\\<^sup>2\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow> 2 ^ T * x < 2 ^ T * y) \\<Longrightarrow>\n  rhs < 2 ^ n\\<^sup>2", "show \"rhs < 2 ^ n\\<^sup>2\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow> 2 ^ T * x < 2 ^ T * y) \\<Longrightarrow>\n  rhs < 2 ^ n\\<^sup>2\n\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  rhs < 2 ^ n\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  It is clear that $2^{n^2} \\leq 8^T$ and that $8^T < T!$ if $T$ is sufficiently big.\n  In this case, `sufficiently big' means \\<open>T \\<ge> 20\\<close> and thereby \\<open>n \\<ge> 7\\<close>. We can therefore\n  conclude that \\<open>n\\<close> must be less than 7.\n\\<close>"], ["", "lemma n_less_7: \"n < 7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 7", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "assume \"\\<not>n < 7\""], ["proof (state)\nthis:\n  \\<not> n < 7\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "hence \"n \\<ge> 7\""], ["proof (prove)\nusing this:\n  \\<not> n < 7\n\ngoal (1 subgoal):\n 1. 7 \\<le> n", "by simp"], ["proof (state)\nthis:\n  7 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"T \\<ge> (7 * 6) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 * 6 div 2 \\<le> T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 7 * 6 div 2 \\<le> n * (n - 1) div 2", "using \\<open>n \\<ge> 7\\<close>"], ["proof (prove)\nusing this:\n  7 \\<le> n\n\ngoal (1 subgoal):\n 1. 7 * 6 div 2 \\<le> n * (n - 1) div 2", "by (intro div_le_mono mult_mono) auto"], ["proof (state)\nthis:\n  7 * 6 div 2 \\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "hence \"T \\<ge> 21\""], ["proof (prove)\nusing this:\n  7 * 6 div 2 \\<le> T\n\ngoal (1 subgoal):\n 1. 21 \\<le> T", "by simp"], ["proof (state)\nthis:\n  21 \\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "from \\<open>n \\<ge> 7\\<close>"], ["proof (chain)\npicking this:\n  7 \\<le> n", "have \"(n * 2) div 2 \\<le> T\""], ["proof (prove)\nusing this:\n  7 \\<le> n\n\ngoal (1 subgoal):\n 1. n * 2 div 2 \\<le> T", "unfolding T_def"], ["proof (prove)\nusing this:\n  7 \\<le> n\n\ngoal (1 subgoal):\n 1. n * 2 div 2 \\<le> n * (n - 1) div 2", "by (intro div_le_mono) auto"], ["proof (state)\nthis:\n  n * 2 div 2 \\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "hence \"T \\<ge> n\""], ["proof (prove)\nusing this:\n  n * 2 div 2 \\<le> T\n\ngoal (1 subgoal):\n 1. n \\<le> T", "by simp"], ["proof (state)\nthis:\n  n \\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "from \\<open>T \\<ge> 21\\<close>"], ["proof (chain)\npicking this:\n  21 \\<le> T", "have \"sqrt (2 * pi * T) * (T / exp 1) ^ T \\<le> fact T\""], ["proof (prove)\nusing this:\n  21 \\<le> T\n\ngoal (1 subgoal):\n 1. sqrt (2 * pi * real T) * (real T / exp 1) ^ T \\<le> fact T", "using fact_bounds[of T]"], ["proof (prove)\nusing this:\n  21 \\<le> T\n  0 < T \\<Longrightarrow>\n  sqrt (2 * pi * real T) * (real T / exp 1) ^ T \\<le> fact T\n  0 < T \\<Longrightarrow>\n  fact T\n  \\<le> sqrt (2 * pi * real T) * (real T / exp 1) ^ T *\n        exp (1 / (12 * real T))\n\ngoal (1 subgoal):\n 1. sqrt (2 * pi * real T) * (real T / exp 1) ^ T \\<le> fact T", "by simp"], ["proof (state)\nthis:\n  sqrt (2 * pi * real T) * (real T / exp 1) ^ T \\<le> fact T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"fact T \\<le> (fact k :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact T \\<le> fact k", "using k_gt_T"], ["proof (prove)\nusing this:\n  T < k\n\ngoal (1 subgoal):\n 1. fact T \\<le> fact k", "by (intro fact_mono) (auto simp: T_def)"], ["proof (state)\nthis:\n  fact T \\<le> fact k\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  fact T \\<le> fact k\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"\\<dots> = rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact k = rhs", "by fact"], ["proof (state)\nthis:\n  fact k = rhs\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  fact k = rhs\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"rhs < 2 ^ n\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs < 2 ^ n\\<^sup>2", "by (rule rhs_less)"], ["proof (state)\nthis:\n  rhs < 2 ^ n\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  rhs < 2 ^ n\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"n\\<^sup>2 = 2 * T + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sup>2 = 2 * T + n", "by (cases \"even n\") (auto simp: T_def algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  n\\<^sup>2 = 2 * T + n\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  n\\<^sup>2 = 2 * T + n\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"\\<dots> \\<le> 3 * T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * T + n \\<le> 3 * T", "using \\<open>T \\<ge> n\\<close>"], ["proof (prove)\nusing this:\n  n \\<le> T\n\ngoal (1 subgoal):\n 1. 2 * T + n \\<le> 3 * T", "by (simp add: T_def)"], ["proof (state)\nthis:\n  2 * T + n \\<le> 3 * T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 * T + n \\<le> 3 * T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"2 ^ (3 * T) = (8 ^ T :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (3 * T) = 8 ^ T", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  2 ^ (3 * T) = 8 ^ T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 2 ^ x \\<le> 2 ^ y) \\<Longrightarrow>\n  fact T < 8 ^ T", "have \"fact T < (8 ^ T :: nat)\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 2 ^ x \\<le> 2 ^ y) \\<Longrightarrow>\n  fact T < 8 ^ T\n\ngoal (1 subgoal):\n 1. fact T < 8 ^ T", "by simp"], ["proof (state)\nthis:\n  fact T < 8 ^ T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fact T < 8 ^ T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "have \"fact T \\<ge> (8 ^ T :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 ^ T \\<le> fact T", "by (rule fact_ge_power[of _ 20]) (use \\<open>T \\<ge> 21\\<close> in \\<open>auto simp: fact_numeral\\<close>)"], ["proof (state)\nthis:\n  8 ^ T \\<le> fact T\n\ngoal (1 subgoal):\n 1. \\<not> n < 7 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fact T < 8 ^ T\n  8 ^ T \\<le> fact T", "show False"], ["proof (prove)\nusing this:\n  fact T < 8 ^ T\n  8 ^ T \\<le> fact T\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now only have 6 values for \\<open>n\\<close> to check. Together with the bounds that we obtained on \\<open>k\\<close>,\n  this only leaves a few combinations of \\<open>n\\<close> and \\<open>k\\<close> to check, and we do precisely that\n  and find that \\<open>n = k = 1\\<close> and \\<open>n = 2, k = 3\\<close> are the only possible combinations.\n\\<close>"], ["", "lemma n_k_in_set: \"(n, k) \\<in> {(1, 1), (2, 3)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "define T' where \"T' = (\\<lambda>n :: nat. n * (n - 1) div 2)\""], ["proof (state)\nthis:\n  T' = (\\<lambda>n. n * (n - 1) div 2)\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "define A :: \"(nat \\<times> nat) set\" where \"A = (SIGMA n:{1..6}. {T' n<..2 * T' n + 1})\""], ["proof (state)\nthis:\n  A = (SIGMA n:{1..6}. {T' n<..2 * T' n + 1})\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "define P where \"P = (\\<lambda>(n, k). fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i :: nat))\""], ["proof (state)\nthis:\n  P = (\\<lambda>(n, k). fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i))\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "have [simp]: \"{0<..Suc 0} = {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0<..Suc 0} = {1}", "by auto"], ["proof (state)\nthis:\n  {0<..Suc 0} = {1}\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "have \"(n, k) \\<in> Set.filter P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, k) \\<in> Set.filter P A", "using k_n pos T_ge_half_k k_gt_T n_less_7"], ["proof (prove)\nusing this:\n  fact k = rhs\n  0 < k\n  0 < n\n  k div 2 \\<le> T\n  T < k\n  n < 7\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> Set.filter P A", "by (auto simp: A_def T'_def T_def Set.filter_def P_def rhs_def)"], ["proof (state)\nthis:\n  (n, k) \\<in> Set.filter P A\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "also"], ["proof (state)\nthis:\n  (n, k) \\<in> Set.filter P A\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "have \"Set.filter P A = {(1, 1), (2, 3)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P A = {(1, 1), (2, 3)}", "by (simp add: P_def Set_filter_insert A_def atMost_nat_numeral atMost_Suc T'_def Sigma_insert \n          greaterThanAtMost_nat_numeral atLeastAtMost_nat_numeral lessThan_nat_numeral fact_numeral\n             cong: if_weak_cong)"], ["proof (state)\nthis:\n  Set.filter P A = {(1, 1), (2, 3)}\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "finally"], ["proof (chain)\npicking this:\n  (n, k) \\<in> {(1, 1), (2, 3)}", "show ?thesis"], ["proof (prove)\nusing this:\n  (n, k) \\<in> {(1, 1), (2, 3)}\n\ngoal (1 subgoal):\n 1. (n, k) \\<in> {(1, 1), (2, 3)}", "."], ["proof (state)\nthis:\n  (n, k) \\<in> {(1, 1), (2, 3)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  Using this, deriving the final result is now trivial:\n\\<close>"], ["", "theorem \"{(n, k). n > 0 \\<and> k > 0 \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i :: nat)} = {(1, 1), (2, 3)}\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(n, k).\n     0 < n \\<and> 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)} =\n    {(1, 1), (2, 3)}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {(n, k). 0 < n \\<and> 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}\n    \\<subseteq> {(1, 1), (2, 3)}\n 2. {(1, 1), (2, 3)}\n    \\<subseteq> {(n, k).\n                 0 < n \\<and>\n                 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(n, k). 0 < n \\<and> 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}\n    \\<subseteq> {(1, 1), (2, 3)}", "using n_k_in_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; 0 < ?n; fact ?k = (\\<Prod>i<?n. 2 ^ ?n - 2 ^ i)\\<rbrakk>\n  \\<Longrightarrow> (?n, ?k) \\<in> {(1, 1), (2, 3)}\n\ngoal (1 subgoal):\n 1. {(n, k). 0 < n \\<and> 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}\n    \\<subseteq> {(1, 1), (2, 3)}", "by blast"], ["proof (state)\nthis:\n  {(n, k). 0 < n \\<and> 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}\n  \\<subseteq> {(1, 1), (2, 3)}\n\ngoal (1 subgoal):\n 1. {(1, 1), (2, 3)}\n    \\<subseteq> {(n, k).\n                 0 < n \\<and>\n                 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(1, 1), (2, 3)}\n    \\<subseteq> {(n, k).\n                 0 < n \\<and>\n                 0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}", "by (auto simp: fact_numeral lessThan_nat_numeral)"], ["proof (state)\nthis:\n  {(1, 1), (2, 3)}\n  \\<subseteq> {(n, k).\n               0 < n \\<and>\n               0 < k \\<and> fact k = (\\<Prod>i<n. 2 ^ n - 2 ^ i)}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}