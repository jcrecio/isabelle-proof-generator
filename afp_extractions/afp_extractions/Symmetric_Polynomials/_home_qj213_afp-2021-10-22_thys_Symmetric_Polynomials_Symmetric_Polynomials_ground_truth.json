{"file_name": "/home/qj213/afp-2021-10-22/thys/Symmetric_Polynomials/Symmetric_Polynomials.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Symmetric_Polynomials", "problem_names": ["lemma infinite_infinite_subsets:\n  assumes \"infinite A\"\n  shows   \"infinite {X. X \\<subseteq> A \\<and> infinite X}\"", "lemma infinite_card_subsets:\n  assumes \"infinite A\" \"k > 0\"\n  shows   \"infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\"", "lemma comp_bij_eq_iff:\n  assumes \"bij f\"\n  shows   \"g \\<circ> f = h \\<circ> f \\<longleftrightarrow> g = h\"", "lemma sum_list_replicate [simp]:\n  \"sum_list (replicate n x) = of_nat n * (x :: 'a :: semiring_1)\"", "lemma ex_subset_of_card:\n  assumes \"finite A\" \"card A \\<ge> k\"\n  shows   \"\\<exists>B. B \\<subseteq> A \\<and> card B = k\"", "lemma length_sorted_list_of_set [simp]: \"length (sorted_list_of_set A) = card A\"", "lemma upt_add_eq_append': \"i \\<le> j \\<Longrightarrow> j \\<le> k \\<Longrightarrow> [i..<k] = [i..<j] @ [j..<k]\"", "lemma minus_closed [simp]: \"x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x - y \\<in> A\"", "lemma sum_closed [intro]: \"(\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow> sum f X \\<in> A\"", "lemma power_closed [intro]: \"x \\<in> A \\<Longrightarrow> x ^ n \\<in> A\"", "lemma Sum_any_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> Sum_any f \\<in> A\"", "lemma prod_closed [intro]: \"(\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow> prod f X \\<in> A\"", "lemma Prod_any_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> Prod_any f \\<in> A\"", "lemma prod_fun_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> (\\<And>x. g x \\<in> A) \\<Longrightarrow> prod_fun f g x \\<in> A\"", "lemma of_nat_closed [simp, intro]: \"of_nat n \\<in> A\"", "lemma of_int_closed [simp, intro]: \"of_int n \\<in> A\"", "lemma diff [simp]: \"f (x - y) = f x - f y\"", "lemma power [simp]: \"f (x ^ n) = f x ^ n\"", "lemma sum [simp]: \"f (sum g A) = (\\<Sum>x\\<in>A. f (g x))\"", "lemma prod [simp]: \"f (prod g A) = (\\<Prod>x\\<in>A. f (g x))\"", "lemma ring_homomorphism_id [intro]: \"ring_homomorphism id\"", "lemma ring_homomorphism_id' [intro]: \"ring_homomorphism (\\<lambda>x. x)\"", "lemma ring_homomorphism_of_int [intro]: \"ring_homomorphism of_int\"", "lemma poly_mapping_nat_ge_0 [simp]: \"(m :: nat \\<Rightarrow>\\<^sub>0 nat) \\<ge> 0\"", "lemma poly_mapping_nat_le_0 [simp]: \"(m :: nat \\<Rightarrow>\\<^sub>0 nat) \\<le> 0 \\<longleftrightarrow> m = 0\"", "lemma of_nat_diff_poly_mapping_nat:\n  assumes \"m \\<ge> n\"\n  shows   \"of_nat (m - n) = (of_nat m - of_nat n :: 'a :: monoid_add \\<Rightarrow>\\<^sub>0 nat)\"", "lemma mpoly_coeff_transfer [transfer_rule]:\n  \"rel_fun cr_mpoly (=) poly_mapping.lookup MPoly_Type.coeff\"", "lemma mapping_of_sum: \"(\\<Sum>x\\<in>A. mapping_of (f x)) = mapping_of (sum f A)\"", "lemma mapping_of_eq_0_iff [simp]: \"mapping_of p = 0 \\<longleftrightarrow> p = 0\"", "lemma Sum_any_mapping_of: \"Sum_any (\\<lambda>x. mapping_of (f x)) = mapping_of (Sum_any f)\"", "lemma Sum_any_parametric_cr_mpoly [transfer_rule]:\n  \"(rel_fun (rel_fun (=) cr_mpoly) cr_mpoly) Sum_any Sum_any\"", "lemma lookup_mult_of_nat [simp]: \"lookup (of_nat n * m) k = n * lookup m k\"", "lemma mpoly_eqI:\n  assumes \"\\<And>mon. MPoly_Type.coeff p mon = MPoly_Type.coeff q mon\"\n  shows   \"p = q\"", "lemma coeff_mpoly_times:\n  \"MPoly_Type.coeff (p * q) mon = prod_fun (MPoly_Type.coeff p) (MPoly_Type.coeff q) mon\"", "lemma (in ring_closed) coeff_mult_closed [intro]:\n  \"(\\<And>x. coeff p x \\<in> A) \\<Longrightarrow> (\\<And>x. coeff q x \\<in> A) \\<Longrightarrow> coeff (p * q) x \\<in> A\"", "lemma coeff_notin_vars:\n  assumes \"\\<not>(keys m \\<subseteq> vars p)\"\n  shows   \"coeff p m = 0\"", "lemma finite_coeff_support [intro]: \"finite {m. coeff p m \\<noteq> 0}\"", "lemma insertion_altdef:\n  \"insertion f p = Sum_any (\\<lambda>m. coeff p m * Prod_any (\\<lambda>i. f i ^ lookup m i))\"", "lemma mpoly_coeff_uminus [simp]: \"coeff (-p) m = -coeff p m\"", "lemma Sum_any_uminus: \"Sum_any (\\<lambda>x. -f x :: 'a :: ab_group_add) = -Sum_any f\"", "lemma insertion_uminus [simp]: \"insertion f (-p :: 'a :: comm_ring_1 mpoly) = -insertion f p\"", "lemma Sum_any_lookup: \"finite {x. g x \\<noteq> 0} \\<Longrightarrow> Sum_any (\\<lambda>x. lookup (g x) y) = lookup (Sum_any g) y\"", "lemma Sum_any_diff:\n  assumes \"finite {x. f x \\<noteq> 0}\"\n  assumes \"finite {x. g x \\<noteq> 0}\"\n  shows   \"Sum_any (\\<lambda>x. f x - g x :: 'a :: ab_group_add) = Sum_any f - Sum_any g\"", "lemma insertion_diff:\n  \"insertion f (p - q :: 'a :: comm_ring_1 mpoly) = insertion f p - insertion f q\"", "lemma insertion_power: \"insertion f (p ^ n) = insertion f p ^ n\"", "lemma insertion_sum: \"insertion f (sum g A) = (\\<Sum>x\\<in>A. insertion f (g x))\"", "lemma insertion_prod: \"insertion f (prod g A) = (\\<Prod>x\\<in>A. insertion f (g x))\"", "lemma coeff_Var: \"coeff (Var i) m = (1 when m = Poly_Mapping.single i 1)\"", "lemma vars_Var: \"vars (Var i :: 'a :: {one,zero} mpoly) = (if (0::'a) = 1 then {} else {i})\"", "lemma insertion_Var [simp]: \"insertion f (Var i) = f i\"", "lemma insertion_Sum_any:\n  assumes \"finite {x. g x \\<noteq> 0}\"\n  shows   \"insertion f (Sum_any g) = Sum_any (\\<lambda>x. insertion f (g x))\"", "lemma keys_diff_subset:\n  \"keys (f - g) \\<subseteq> keys f \\<union> keys g\"", "lemma keys_empty_iff [simp]: \"keys p = {} \\<longleftrightarrow> p = 0\"", "lemma mpoly_coeff_0 [simp]: \"MPoly_Type.coeff 0 m = 0\"", "lemma lookup_1: \"lookup 1 m = (if m = 0 then 1 else 0)\"", "lemma mpoly_coeff_1: \"MPoly_Type.coeff 1 m = (if m = 0 then 1 else 0)\"", "lemma lookup_Const\\<^sub>0: \"lookup (Const\\<^sub>0 c) m = (if m = 0 then c else 0)\"", "lemma mpoly_coeff_Const: \"MPoly_Type.coeff (Const c) m = (if m = 0 then c else 0)\"", "lemma coeff_smult [simp]: \"coeff (smult c p) m = (c :: 'a :: mult_zero) * coeff p m\"", "lemma in_keys_mapI: \"x \\<in> keys m \\<Longrightarrow> f (lookup m x) \\<noteq> 0 \\<Longrightarrow> x \\<in> keys (Poly_Mapping.map f m)\"", "lemma keys_uminus [simp]: \"keys (-m) = keys m\"", "lemma vars_uminus [simp]: \"vars (-p) = vars p\"", "lemma vars_smult: \"vars (smult c p) \\<subseteq> vars p\"", "lemma vars_0 [simp]: \"vars 0 = {}\"", "lemma vars_1 [simp]: \"vars 1 = {}\"", "lemma vars_sum: \"vars (sum f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))\"", "lemma vars_prod: \"vars (prod f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))\"", "lemma vars_Sum_any: \"vars (Sum_any h) \\<subseteq> (\\<Union>i. vars (h i))\"", "lemma vars_Prod_any: \"vars (Prod_any h) \\<subseteq> (\\<Union>i. vars (h i))\"", "lemma vars_power: \"vars (p ^ n) \\<subseteq> vars p\"", "lemma vars_diff: \"vars (p1 - p2) \\<subseteq> vars p1 \\<union> vars p2\"", "lemma insertion_smult [simp]: \"insertion f (smult c p) = c * insertion f p\"", "lemma coeff_add [simp]: \"coeff (p + q) m = coeff p m + coeff q m\"", "lemma coeff_diff [simp]: \"coeff (p - q) m = coeff p m - coeff q m\"", "lemma insertion_monom [simp]:\n  \"insertion f (monom m c) = c * Prod_any (\\<lambda>x. f x ^ lookup m x)\"", "lemma insertion_aux_Const\\<^sub>0 [simp]: \"insertion_aux f (Const\\<^sub>0 c) = c\"", "lemma insertion_Const [simp]: \"insertion f (Const c) = c\"", "lemma coeffs_0 [simp]: \"coeffs 0 = {}\"", "lemma coeffs_1 [simp]: \"coeffs 1 = {1}\"", "lemma coeffs_Const: \"coeffs (Const c) = (if c = 0 then {} else {c})\"", "lemma coeffs_subset: \"coeffs (Const c) \\<subseteq> {c}\"", "lemma keys_Const\\<^sub>0: \"keys (Const\\<^sub>0 c) = (if c = 0 then {} else {0})\"", "lemma vars_Const [simp]: \"vars (Const c) = {}\"", "lemma prod_fun_compose_bij:\n  assumes \"bij f\" and f: \"\\<And>x y. f (x + y) = f x + f y\"\n  shows   \"prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x\"", "lemma add_nat_poly_mapping_zero_iff [simp]:\n  \"(a + b :: 'a \\<Rightarrow>\\<^sub>0 nat) = 0 \\<longleftrightarrow> a = 0 \\<and> b = 0\"", "lemma prod_fun_nat_0:\n  fixes f g :: \"('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'b::semiring_0\"\n  shows   \"prod_fun f g 0 = f 0 * g 0\"", "lemma mpoly_coeff_times_0: \"coeff (p * q) 0 = coeff p 0 * coeff q 0\"", "lemma mpoly_coeff_prod_0: \"coeff (\\<Prod>x\\<in>A. f x) 0 = (\\<Prod>x\\<in>A. coeff (f x) 0)\"", "lemma mpoly_coeff_power_0: \"coeff (p ^ n) 0 = coeff p 0 ^ n\"", "lemma prod_fun_max:\n  fixes f g :: \"'a::{linorder, ordered_cancel_comm_monoid_add} \\<Rightarrow> 'b::semiring_0\"\n  assumes zero: \"\\<And>m. m > a \\<Longrightarrow> f m = 0\" \"\\<And>m. m > b \\<Longrightarrow> g m = 0\"\n  assumes fin: \"finite {m. f m \\<noteq> 0}\" \"finite {m. g m \\<noteq> 0}\"\n  shows   \"prod_fun f g (a + b) = f a * g b\"", "lemma prod_fun_gt_max_eq_zero:\n  fixes f g :: \"'a::{linorder, ordered_cancel_comm_monoid_add} \\<Rightarrow> 'b::semiring_0\"\n  assumes \"m > a + b\"\n  assumes zero: \"\\<And>m. m > a \\<Longrightarrow> f m = 0\" \"\\<And>m. m > b \\<Longrightarrow> g m = 0\"\n  assumes fin: \"finite {m. f m \\<noteq> 0}\" \"finite {m. g m \\<noteq> 0}\"\n  shows   \"prod_fun f g m = 0\"", "lemma lookup_restrictpm: \"lookup (restrictpm A m) x = (if x \\<in> A then lookup m x else 0)\"", "lemma lookup_restrictpm_in [simp]: \"x \\<in> A \\<Longrightarrow> lookup (restrictpm A m) x = lookup m x\"\n  and lookup_restrict_pm_not_in [simp]: \"x \\<notin> A \\<Longrightarrow> lookup (restrictpm A m) x = 0\"", "lemma keys_restrictpm [simp]: \"keys (restrictpm A m) = keys m \\<inter> A\"", "lemma restrictpm_add: \"restrictpm X (m1 + m2) = restrictpm X m1 + restrictpm X m2\"", "lemma restrictpm_id [simp]: \"keys m \\<subseteq> X \\<Longrightarrow> restrictpm X m = m\"", "lemma restrictpm_orthogonal [simp]: \"keys m \\<subseteq> -X \\<Longrightarrow> restrictpm X m = 0\"", "lemma restrictpm_add_disjoint:\n  \"X \\<inter> Y = {} \\<Longrightarrow> restrictpm X m + restrictpm Y m = restrictpm (X \\<union> Y) m\"", "lemma restrictpm_add_complements:\n  \"restrictpm X m + restrictpm (-X) m = m\" \"restrictpm (-X) m + restrictpm X m = m\"", "lemma poly_mapping_map_conv_mapp: \"Poly_Mapping.map f = Poly_Mapping.mapp (\\<lambda>_. f)\"", "lemma map_mpoly_conv_mapm_mpoly: \"map_mpoly f = mapm_mpoly (\\<lambda>_. f)\"", "lemma map_mpoly_comp: \"f 0 = 0 \\<Longrightarrow> map_mpoly f (map_mpoly g p) = map_mpoly (f \\<circ> g) p\"", "lemma mapp_mapp:\n  \"(\\<And>x. f x 0 = 0) \\<Longrightarrow> Poly_Mapping.mapp f (Poly_Mapping.mapp g m) =\n                          Poly_Mapping.mapp (\\<lambda>x y. f x (g x y)) m\"", "lemma mapm_mpoly_comp:\n  \"(\\<And>x. f x 0 = 0) \\<Longrightarrow> mapm_mpoly f (mapm_mpoly g p) = mapm_mpoly (\\<lambda>m c. f m (g m c)) p\"", "lemma coeff_map_mpoly:\n  \"coeff (map_mpoly f p) m = (if coeff p m = 0 then 0 else f (coeff p m))\"", "lemma coeff_map_mpoly' [simp]: \"f 0 = 0 \\<Longrightarrow> coeff (map_mpoly f p) m = f (coeff p m)\"", "lemma coeff_mapm_mpoly: \"coeff (mapm_mpoly f p) m = (if coeff p m = 0 then 0 else f m (coeff p m))\"", "lemma coeff_mapm_mpoly' [simp]: \"(\\<And>m. f m 0 = 0) \\<Longrightarrow> coeff (mapm_mpoly f p) m = f m (coeff p m)\"", "lemma vars_map_mpoly_subset: \"vars (map_mpoly f p) \\<subseteq> vars p\"", "lemma coeff_sum [simp]: \"coeff (sum f A) m = (\\<Sum>x\\<in>A. coeff (f x) m)\"", "lemma coeff_Sum_any: \"finite {x. f x \\<noteq> 0} \\<Longrightarrow> coeff (Sum_any f) m = Sum_any (\\<lambda>x. coeff (f x) m)\"", "lemma Sum_any_zeroI: \"(\\<And>x. f x = 0) \\<Longrightarrow> Sum_any f = 0\"", "lemma insertion_Prod_any:\n  \"finite {x. g x \\<noteq> 1} \\<Longrightarrow> insertion f (Prod_any g) = Prod_any (\\<lambda>x. insertion f (g x))\"", "lemma insertion_insertion:\n  \"insertion g (insertion k p) =\n     insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\" (is \"?lhs = ?rhs\")", "lemma insertion_substitute_linear:\n  \"insertion (\\<lambda>i. c i * f i) p =\n     insertion f (mapm_mpoly (\\<lambda>m d. Prod_any (\\<lambda>i. c i ^ lookup m i) * d) p)\"", "lemma vars_mapm_mpoly_subset: \"vars (mapm_mpoly f p) \\<subseteq> vars p\"", "lemma map_mpoly_cong:\n  assumes \"\\<And>m. f (coeff p m) = g (coeff p m)\" \"p = q\"\n  shows   \"map_mpoly f p = map_mpoly g q\"", "lemma lead_monom_geI [intro]:\n  assumes \"coeff p m \\<noteq> 0\"\n  shows   \"m \\<le> lead_monom p\"", "lemma coeff_gt_lead_monom_zero [simp]:\n  assumes \"m > lead_monom p\"\n  shows   \"coeff p m = 0\"", "lemma lead_monom_nonzero_eq:\n  assumes \"p \\<noteq> 0\"\n  shows   \"lead_monom p = Max (keys (mapping_of p))\"", "lemma lead_monom_0 [simp]: \"lead_monom 0 = 0\"", "lemma lead_monom_1 [simp]: \"lead_monom 1 = 0\"", "lemma lead_monom_Const [simp]: \"lead_monom (Const c) = 0\"", "lemma lead_monom_uminus [simp]: \"lead_monom (-p) = lead_monom p\"", "lemma keys_mult_const [simp]:\n  fixes c :: \"'a :: {semiring_0, semiring_no_zero_divisors}\"\n  assumes \"c \\<noteq> 0\"\n  shows \"keys (Poly_Mapping.map ((*) c) p) = keys p\"", "lemma lead_monom_eq_0_iff: \"lead_monom p = 0 \\<longleftrightarrow> vars p = {}\"", "lemma lead_monom_monom: \"lead_monom (monom m c) = (if c = 0 then 0 else m)\"", "lemma lead_monom_monom' [simp]: \"c \\<noteq> 0 \\<Longrightarrow> lead_monom (monom m c) = m\"", "lemma lead_monom_numeral [simp]: \"lead_monom (numeral n) = 0\"", "lemma lead_monom_add: \"lead_monom (p + q) \\<le> max (lead_monom p) (lead_monom q)\"", "lemma lead_monom_diff: \"lead_monom (p - q) \\<le> max (lead_monom p) (lead_monom q)\"", "lemma vars_empty_iff: \"vars p = {} \\<longleftrightarrow> p = Const (lead_coeff p)\"", "lemma lead_coeff_0 [simp]: \"lead_coeff 0 = 0\"", "lemma lead_coeff_1 [simp]: \"lead_coeff 1 = 1\"", "lemma lead_coeff_Const [simp]: \"lead_coeff (Const c) = c\"", "lemma lead_coeff_monom [simp]: \"lead_coeff (monom p c) = c\"", "lemma lead_coeff_nonzero [simp]: \"p \\<noteq> 0 \\<Longrightarrow> lead_coeff p \\<noteq> 0\"", "lemma\n  fixes c :: \"'a :: semiring_0\"\n  assumes \"c * lead_coeff p \\<noteq> 0\"\n  shows lead_monom_smult [simp]: \"lead_monom (smult c p) = lead_monom p\"\n    and lead_coeff_smult [simp]: \"lead_coeff (smult c p) = c * lead_coeff p\"", "lemma lead_coeff_mult_aux:\n  \"coeff (p * q) (lead_monom p + lead_monom q) = lead_coeff p * lead_coeff q\"", "lemma lead_monom_mult_le: \"lead_monom (p * q) \\<le> lead_monom p + lead_monom q\"", "lemma lead_monom_mult:\n  assumes \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows   \"lead_monom (p * q) = lead_monom p + lead_monom q\"", "lemma lead_coeff_mult:\n  assumes \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows   \"lead_coeff (p * q) = lead_coeff p * lead_coeff q\"", "lemma keys_lead_monom_subset: \"keys (lead_monom p) \\<subseteq> vars p\"", "lemma\n  assumes \"(\\<Prod>i\\<in>A. lead_coeff (f i)) \\<noteq> 0\"\n    shows lead_monom_prod: \"lead_monom (\\<Prod>i\\<in>A. f i) = (\\<Sum>i\\<in>A. lead_monom (f i))\" (is ?th1)\n      and lead_coeff_prod: \"lead_coeff (\\<Prod>i\\<in>A. f i) = (\\<Prod>i\\<in>A. lead_coeff (f i))\" (is ?th2)", "lemma lead_monom_sum_le: \"(\\<And>x. x \\<in> X \\<Longrightarrow> lead_monom (h x) \\<le> ub) \\<Longrightarrow> lead_monom (sum h X) \\<le> ub\"", "lemma lead_monom_sum:\n  assumes \"inj_on (lead_monom \\<circ> h) X\" and \"finite X\" and \"X \\<noteq> {}\" and \"\\<And>x. x \\<in> X \\<Longrightarrow> h x \\<noteq> 0\"\n  defines \"m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\"\n  shows   \"lead_monom (\\<Sum>x\\<in>X. h x) = m\"", "lemma lead_coeff_eq_0_iff [simp]: \"lead_coeff p = 0 \\<longleftrightarrow> p = 0\"", "lemma\n  fixes f :: \"_ \\<Rightarrow> 'a :: semidom mpoly\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> f i \\<noteq> 0\"\n    shows lead_monom_prod' [simp]: \"lead_monom (\\<Prod>i\\<in>A. f i) = (\\<Sum>i\\<in>A. lead_monom (f i))\" (is ?th1)\n      and lead_coeff_prod' [simp]: \"lead_coeff (\\<Prod>i\\<in>A. f i) = (\\<Prod>i\\<in>A. lead_coeff (f i))\" (is ?th2)", "lemma\n  fixes p :: \"'a :: comm_semiring_1 mpoly\"\n  assumes \"lead_coeff p ^ n \\<noteq> 0\"\n  shows   lead_monom_power: \"lead_monom (p ^ n) = of_nat n * lead_monom p\"\n  and     lead_coeff_power: \"lead_coeff (p ^ n) = lead_coeff p ^ n\"", "lemma\n  fixes p :: \"'a :: semidom mpoly\"\n  assumes \"p \\<noteq> 0\"\n  shows   lead_monom_power' [simp]: \"lead_monom (p ^ n) = of_nat n * lead_monom p\"\n  and     lead_coeff_power' [simp]: \"lead_coeff (p ^ n) = lead_coeff p ^ n\"", "lemma lookup_monom_of_set:\n  \"Poly_Mapping.lookup (monom_of_set X) i = (if finite X \\<and> i \\<in> X then 1 else 0)\"", "lemma lookup_monom_of_set_1 [simp]:\n        \"finite X \\<Longrightarrow> i \\<in> X \\<Longrightarrow> Poly_Mapping.lookup (monom_of_set X) i = 1\"\n  and lookup_monom_of_set_0 [simp]:\n        \"i \\<notin> X \\<Longrightarrow> Poly_Mapping.lookup (monom_of_set X) i = 0\"", "lemma keys_monom_of_set: \"keys (monom_of_set X) = (if finite X then X else {})\"", "lemma keys_monom_of_set_finite [simp]: \"finite X \\<Longrightarrow> keys (monom_of_set X) = X\"", "lemma monom_of_set_eq_iff [simp]: \"finite X \\<Longrightarrow> finite Y \\<Longrightarrow> monom_of_set X = monom_of_set Y \\<longleftrightarrow> X = Y\"", "lemma monom_of_set_empty [simp]: \"monom_of_set {} = 0\"", "lemma monom_of_set_eq_zero_iff [simp]: \"monom_of_set X = 0 \\<longleftrightarrow> infinite X \\<or> X = {}\"", "lemma zero_eq_monom_of_set_iff [simp]: \"0 = monom_of_set X \\<longleftrightarrow> infinite X \\<or> X = {}\"", "lemma keys_permutep: \"bij f \\<Longrightarrow> keys (permutep f m) = f -` keys m\"", "lemma permutep_id'' [simp]: \"permutep id = id\"", "lemma permutep_id''' [simp]: \"permutep (\\<lambda>x. x) = id\"", "lemma permutep_0 [simp]: \"permutep f 0 = 0\"", "lemma permutep_single:\n  \"bij f \\<Longrightarrow> permutep f (Poly_Mapping.single a b) = Poly_Mapping.single (inv_into UNIV f a) b\"", "lemma mpoly_map_vars_id [simp]: \"mpoly_map_vars id = id\"", "lemma mpoly_map_vars_id' [simp]: \"mpoly_map_vars (\\<lambda>x. x) = id\"", "lemma lookup_permutep:\n  \"Poly_Mapping.lookup (permutep f m) x = (if bij f then Poly_Mapping.lookup m (f x) else Poly_Mapping.lookup m x)\"", "lemma inj_permutep [intro]: \"inj (permutep (f :: 'a \\<Rightarrow> 'a) :: _ \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b :: zero)\"", "lemma surj_permutep [intro]: \"surj (permutep (f :: 'a \\<Rightarrow> 'a) :: _ \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b :: zero)\"", "lemma bij_permutep [intro]: \"bij (permutep f)\"", "lemma mpoly_map_vars_map_mpoly:\n  \"mpoly_map_vars f (map_mpoly g p) = map_mpoly g (mpoly_map_vars f p)\"", "lemma coeff_mpoly_map_vars:\n  fixes f :: \"nat \\<Rightarrow> nat\" and p :: \"'a :: zero mpoly\"\n  assumes \"bij f\"\n  shows   \"MPoly_Type.coeff (mpoly_map_vars f p) mon =\n             MPoly_Type.coeff p (permutep f mon)\"", "lemma permutep_monom_of_set:\n  assumes \"bij f\"\n  shows   \"permutep f (monom_of_set A) = monom_of_set (f -` A)\"", "lemma permutep_comp: \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> permutep (f \\<circ> g) = permutep g \\<circ> permutep f\"", "lemma permutep_comp': \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> permutep (f \\<circ> g) mon = permutep g (permutep f mon)\"", "lemma mpoly_map_vars_comp:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> mpoly_map_vars f (mpoly_map_vars g p) = mpoly_map_vars (f \\<circ> g) p\"", "lemma permutep_id [simp]: \"permutep id mon = mon\"", "lemma permutep_id' [simp]: \"permutep (\\<lambda>x. x) mon = mon\"", "lemma inv_permutep [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  assumes \"bij f\"\n  shows   \"inv_into UNIV (permutep f) = permutep (inv_into UNIV f)\"", "lemma mpoly_map_vars_monom:\n  \"bij f \\<Longrightarrow> mpoly_map_vars f (monom m c) = monom (permutep (inv_into UNIV f) m) c\"", "lemma vars_mpoly_map_vars:\n  fixes f :: \"nat \\<Rightarrow> nat\" and p :: \"'a :: zero mpoly\"\n  assumes \"bij f\"\n  shows   \"vars (mpoly_map_vars f p) = f ` vars p\"", "lemma permutep_eq_monom_of_set_iff [simp]:\n  assumes \"bij f\"\n  shows   \"permutep f mon = monom_of_set A \\<longleftrightarrow> mon = monom_of_set (f ` A)\"", "lemma permutep_monom_of_set_permutes [simp]:\n  assumes \"\\<pi> permutes A\"\n  shows   \"permutep \\<pi> (monom_of_set A) = monom_of_set A\"", "lemma mpoly_map_vars_0 [simp]: \"mpoly_map_vars f 0 = 0\"", "lemma permutep_eq_0_iff [simp]: \"permutep f m = 0 \\<longleftrightarrow> m = 0\"", "lemma mpoly_map_vars_1 [simp]: \"mpoly_map_vars f 1 = 1\"", "lemma permutep_Const\\<^sub>0 [simp]: \"(\\<And>x. f x = 0 \\<longleftrightarrow> x = 0) \\<Longrightarrow> permutep f (Const\\<^sub>0 c) = Const\\<^sub>0 c\"", "lemma permutep_add [simp]: \"permutep f (m1 + m2) = permutep f m1 + permutep f m2\"", "lemma permutep_diff [simp]: \"permutep f (m1 - m2) = permutep f m1 - permutep f m2\"", "lemma permutep_uminus [simp]: \"permutep f (-m) = -permutep f m\"", "lemma permutep_mult [simp]:\n  \"(\\<And>x y. f (x + y) = f x + f y) \\<Longrightarrow> permutep f (m1 * m2) = permutep f m1 * permutep f m2\"", "lemma mpoly_map_vars_Const [simp]: \"mpoly_map_vars f (Const c) = Const c\"", "lemma mpoly_map_vars_add [simp]: \"mpoly_map_vars f (p + q) = mpoly_map_vars f p + mpoly_map_vars f q\"", "lemma mpoly_map_vars_diff [simp]: \"mpoly_map_vars f (p - q) = mpoly_map_vars f p - mpoly_map_vars f q\"", "lemma mpoly_map_vars_uminus [simp]: \"mpoly_map_vars f (-p) = -mpoly_map_vars f p\"", "lemma permutep_smult:\n  \"permutep (permutep f) (Poly_Mapping.map ((*) c) p) =\n     Poly_Mapping.map ((*) c) (permutep (permutep f) p)\"", "lemma mpoly_map_vars_smult [simp]: \"mpoly_map_vars f (smult c p) = smult c (mpoly_map_vars f p)\"", "lemma mpoly_map_vars_mult [simp]: \"mpoly_map_vars f (p * q) = mpoly_map_vars f p * mpoly_map_vars f q\"", "lemma mpoly_map_vars_sum [simp]: \"mpoly_map_vars f (sum g A) = (\\<Sum>x\\<in>A. mpoly_map_vars f (g x))\"", "lemma mpoly_map_vars_prod [simp]: \"mpoly_map_vars f (prod g A) = (\\<Prod>x\\<in>A. mpoly_map_vars f (g x))\"", "lemma mpoly_map_vars_eq_0_iff [simp]: \"mpoly_map_vars f p = 0 \\<longleftrightarrow> p = 0\"", "lemma permutep_eq_iff [simp]: \"permutep f p = permutep f q \\<longleftrightarrow> p = q\"", "lemma mpoly_map_vars_Sum_any [simp]:\n  \"mpoly_map_vars f (Sum_any g) = Sum_any (\\<lambda>x. mpoly_map_vars f (g x))\"", "lemma mpoly_map_vars_power [simp]: \"mpoly_map_vars f (p ^ n) = mpoly_map_vars f p ^ n\"", "lemma mpoly_map_vars_monom_single [simp]:\n  assumes \"bij f\"\n  shows   \"mpoly_map_vars f (monom (Poly_Mapping.single i n) c) =\n             monom (Poly_Mapping.single (f i) n) c\"", "lemma insertion_mpoly_map_vars:\n  assumes \"bij f\"\n  shows   \"insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p\"", "lemma permutep_cong:\n  assumes \"f permutes (-keys p)\" \"g permutes (-keys p)\" \"p = q\"\n  shows   \"permutep f p = permutep g q\"", "lemma mpoly_map_vars_cong:\n  assumes \"f permutes (-vars p)\" \"g permutes (-vars q)\" \"p = q\"\n  shows   \"mpoly_map_vars f p = mpoly_map_vars g (q :: 'a :: zero mpoly)\"", "lemma symmetric_mpoly_empty [simp, intro]: \"symmetric_mpoly {} p\"", "lemma symmetric_mpoly_orthogonal:\n  assumes \"vars p \\<inter> A = {}\"\n  shows   \"symmetric_mpoly A p\"", "lemma symmetric_mpoly_monom [intro]:\n  assumes \"keys m \\<inter> A = {}\"\n  shows   \"symmetric_mpoly A (monom m c)\"", "lemma symmetric_mpoly_subset:\n  assumes \"symmetric_mpoly A p\" \"B \\<subseteq> A\"\n  shows   \"symmetric_mpoly B p\"", "lemma symmetric_mpoly_imp_orthogonal_or_subset:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\"", "lemma symmetric_mpoly_add [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p + q)\"", "lemma symmetric_mpoly_diff [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p - q)\"", "lemma symmetric_mpoly_uminus [intro]: \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (-p)\"", "lemma symmetric_mpoly_uminus_iff [simp]: \"symmetric_mpoly A (-p) \\<longleftrightarrow> symmetric_mpoly A p\"", "lemma symmetric_mpoly_smult [intro]: \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (smult c p)\"", "lemma symmetric_mpoly_mult [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p * q)\"", "lemma symmetric_mpoly_0 [simp, intro]: \"symmetric_mpoly A 0\"\n  and symmetric_mpoly_1 [simp, intro]: \"symmetric_mpoly A 1\"\n  and symmetric_mpoly_Const [simp, intro]: \"symmetric_mpoly A (Const c)\"", "lemma symmetric_mpoly_power [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (p ^ n)\"", "lemma symmetric_mpoly_sum [intro]:\n  \"(\\<And>i. i \\<in> B \\<Longrightarrow> symmetric_mpoly A (f i)) \\<Longrightarrow> symmetric_mpoly A (sum f B)\"", "lemma symmetric_mpoly_prod [intro]:\n  \"(\\<And>i. i \\<in> B \\<Longrightarrow> symmetric_mpoly A (f i)) \\<Longrightarrow> symmetric_mpoly A (prod f B)\"", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\"", "lemma symmetric_mpoly_symmetric_prod:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\"", "theorem lookup_lead_monom_decreasing:\n  assumes \"symmetric_mpoly A p\"\n  defines \"m \\<equiv> lead_monom p\"\n  assumes \"i \\<in> A\" \"j \\<in> A\" \"i \\<le> j\"\n  shows   \"lookup m i \\<ge> lookup m j\"", "lemma lookup_sym_mpoly_aux:\n  \"Poly_Mapping.lookup (sym_mpoly_aux X k) mon =\n     (if finite X \\<and> (\\<exists>Y. Y \\<subseteq> X \\<and> card Y = k \\<and> mon = monom_of_set Y) then 1 else 0)\"", "lemma lookup_sym_mpoly_aux_monom_of_set [simp]:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y = k\"\n  shows   \"Poly_Mapping.lookup (sym_mpoly_aux X k) (monom_of_set Y) = 1\"", "lemma keys_sym_mpoly_aux: \"m \\<in> keys (sym_mpoly_aux A k) \\<Longrightarrow> keys m \\<subseteq> A\"", "lemma vars_sym_mpoly_subset: \"vars (sym_mpoly A k) \\<subseteq> A\"", "lemma coeff_sym_mpoly:\n  \"MPoly_Type.coeff (sym_mpoly X k) mon =\n     (if finite X \\<and> (\\<exists>Y. Y \\<subseteq> X \\<and> card Y = k \\<and> mon = monom_of_set Y) then 1 else 0)\"", "lemma sym_mpoly_infinite: \"\\<not>finite A \\<Longrightarrow> sym_mpoly A k = 0\"", "lemma sym_mpoly_altdef: \"sym_mpoly A k = (\\<Sum>X | X \\<subseteq> A \\<and> card X = k. monom (monom_of_set X) 1)\"", "lemma coeff_sym_mpoly_monom_of_set [simp]:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y = k\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 1\"", "lemma coeff_sym_mpoly_0: \"coeff (sym_mpoly X k) 0 = (if finite X \\<and> k = 0 then 1 else 0)\"", "lemma symmetric_sym_mpoly [intro]:\n  assumes \"A \\<subseteq> B\"\n  shows   \"symmetric_mpoly A (sym_mpoly B k :: 'a :: zero_neq_one mpoly)\"", "lemma insertion_sym_mpoly:\n  assumes \"finite X\"\n  shows   \"insertion f (sym_mpoly X k) = (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\"", "lemma sym_mpoly_nz [simp]:\n  assumes \"finite A\" \"k \\<le> card A\"\n  shows   \"sym_mpoly A k \\<noteq> (0 :: 'a :: zero_neq_one mpoly)\"", "lemma coeff_sym_mpoly_0_or_1: \"coeff (sym_mpoly A k) m \\<in> {0, 1}\"", "lemma lead_coeff_sym_mpoly [simp]:\n  assumes \"finite A\" \"k \\<le> card A\"\n  shows   \"lead_coeff (sym_mpoly A k) = 1\"", "lemma lead_monom_sym_mpoly:\n  assumes \"sorted xs\" \"distinct xs\" \"k \\<le> length xs\"\n  shows   \"lead_monom (sym_mpoly (set xs) k :: 'a :: zero_neq_one mpoly) =\n             monom_of_set (set (take k xs))\" (is \"lead_monom ?p = _\")", "lemma wf_monom_less_on:\n  assumes \"finite A\"\n  shows   \"wf (monom_less_on A :: ((nat \\<Rightarrow>\\<^sub>0 'b :: {zero, wellorder}) \\<times> _) set)\"", "lemma lead_monom_induct [consumes 2, case_names less]:\n  fixes p :: \"'a :: zero mpoly\"\n  assumes fin: \"finite A\" and vars: \"vars p \\<subseteq> A\"\n  assumes IH: \"\\<And>p. vars p \\<subseteq> A \\<Longrightarrow>\n                 (\\<And>p'. vars p' \\<subseteq> A \\<Longrightarrow> lead_monom p' < lead_monom p \\<Longrightarrow> P p') \\<Longrightarrow> P p\"\n  shows   \"P p\"", "lemma lead_monom_induct' [case_names less]:\n  fixes p :: \"'a :: zero mpoly\"\n  assumes IH: \"\\<And>p. (\\<And>p'. vars p' \\<subseteq> vars p \\<Longrightarrow> lead_monom p' < lead_monom p \\<Longrightarrow> P p') \\<Longrightarrow> P p\"\n  shows   \"P p\"", "lemma lead_coeff_sym_mpoly_powerprod:\n  assumes \"finite A\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> {1..card A}\"\n  shows   \"lead_coeff (\\<Prod>x\\<in>X. sym_mpoly A (f (x::'a)) ^ g x) = 1\"", "lemma coeff_fund_sym_step_coeff: \"coeff (fund_sym_step_coeff p) m \\<in> {lead_coeff p, 0}\"", "lemma vars_fund_sym_step_coeff: \"vars (fund_sym_step_coeff p) \\<subseteq> vars p - A\"", "lemma keys_fund_sym_step_monom: \"keys (fund_sym_step_monom p) \\<subseteq> {1..n}\"", "lemma coeff_fund_sym_step_poly:\n  assumes C: \"\\<forall>m. coeff p m \\<in> C\" and \"ring_closed C\"\n  shows   \"coeff (fund_sym_step_poly p) m \\<in> C\"", "lemma fund_sym_step_poly:\n  shows   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> lead_monom (fund_sym_step_poly p) = lead_monom p\"\n    and   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> lead_coeff (fund_sym_step_poly p) = lead_coeff p\"\n    and   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> fund_sym_step_poly p =\n             fund_sym_step_coeff p * (\\<Prod>x. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x)\"\n    and   \"vars (fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\"\n    and   \"symmetric_mpoly A (fund_sym_step_poly p)\"", "lemma lead_monom_fund_sym_step_poly_less:\n  assumes \"finite A\" and \"lead_monom p \\<noteq> 0\" and \"decr p\"\n  shows   \"lead_monom (p - fund_sym_step_poly p) < lead_monom p\"", "lemma fund_sym_poly_wit_dom_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"A \\<subseteq> B\"\n  shows   \"fund_sym_poly_wit_dom p\"", "lemma fund_sym_poly_wit_dom [intro]: \"fund_sym_poly_wit_dom p\"", "lemmas [simp del] = fund_sym_poly_wit.simps", "lemma fund_sym_poly_wit_coeffs_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"symmetric_mpoly A p\" \"A \\<subseteq> B\"\n  shows   \"vars (coeff (fund_sym_poly_wit p) m) \\<subseteq> B - A\"", "lemma fund_sym_poly_wit_coeffs:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"vars (coeff (fund_sym_poly_wit p) m) \\<subseteq> vars p - A\"", "lemma fund_sym_poly_wit_vars: \"vars (fund_sym_poly_wit p) \\<subseteq> {1..n}\"", "lemma fund_sym_poly_wit_insertion_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"symmetric_mpoly A p\" \"A \\<subseteq> B\"\n  shows   \"insertion (sym_mpoly A) (fund_sym_poly_wit p) = p\"", "lemma fund_sym_poly_wit_insertion:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"insertion (sym_mpoly A) (fund_sym_poly_wit p) = p\"", "lemma fund_sym_poly_wit_coeff:\n  assumes \"\\<forall>m. coeff p m \\<in> C\" \"ring_closed C\"\n  shows   \"\\<forall>m m'. coeff (coeff (fund_sym_poly_wit p) m) m' \\<in> C\"", "lemma lead_monom_sym_mpoly_prod:\n  assumes \"finite A\"\n  shows   \"lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i :: 'a mpoly) =\n             (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i :: 'a mpoly))\"", "lemma lead_monom_sym_mpoly_prod_notin:\n  assumes \"finite A\" \"k \\<notin> A\"\n  shows   \"lookup (lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ h i :: 'a mpoly)) k = 0\"", "lemma lead_monom_sym_mpoly_prod_in:\n  assumes \"finite A\" \"k < n\"\n  shows   \"lookup (lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ h i :: 'a mpoly)) (xs ! k) =\n             (\\<Sum>i=k+1..n. h i)\"", "lemma lead_monom_sym_poly_powerprod_inj:\n  assumes \"lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i :: 'a mpoly) =\n             lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i :: 'a mpoly)\"\n  assumes \"finite A\" \"keys m1 \\<subseteq> {1..n}\" \"keys m2 \\<subseteq> {1..n}\"\n  shows   \"m1 = m2\"", "lemma sym_mpoly_representation_unique_aux:\n  fixes p :: \"'a mpoly mpoly\"\n  assumes \"finite A\" \"insertion (sym_mpoly A) p = 0\"\n          \"\\<And>m. vars (coeff p m) \\<inter> A = {}\" \"vars p \\<subseteq> {1..n}\"\n  shows   \"p = 0\"", "theorem sym_mpoly_representation_unique:\n  fixes p :: \"'a mpoly mpoly\"\n  assumes \"finite A\"\n          \"insertion (sym_mpoly A) p = insertion (sym_mpoly A) q\"\n          \"\\<And>m. vars (coeff p m) \\<inter> A = {}\" \"\\<And>m. vars (coeff q m) \\<inter> A = {}\"\n          \"vars p \\<subseteq> {1..n}\" \"vars q \\<subseteq> {1..n}\"\n  shows   \"p = q\"", "theorem eq_fund_sym_poly_witI:\n  fixes p :: \"'a mpoly\" and q :: \"'a mpoly mpoly\"\n  assumes \"finite A\" \"symmetric_mpoly A p\"\n          \"insertion (sym_mpoly A) q = p\"\n          \"\\<And>m. vars (coeff q m) \\<inter> A = {}\"\n          \"vars q \\<subseteq> {1..n}\"\n  shows   \"q = fund_sym_poly_wit p\"", "lemmas [fundef_cong] = disj_cong conj_cong", "lemma check_symmetric_mpoly_dom_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"A \\<subseteq> B\"\n  shows   \"check_symmetric_mpoly_dom p\"", "lemma check_symmetric_mpoly_dom [intro]: \"check_symmetric_mpoly_dom p\"", "lemmas [simp del] = check_symmetric_mpoly.simps", "lemma check_symmetric_mpoly_correct: \"check_symmetric_mpoly p \\<longleftrightarrow> symmetric_mpoly A p\"", "theorem symmetric_poly_of_roots_conv_poly_of_coeffs:\n  assumes c: \"cinv * l c = 1\" \"cinv \\<in> C\"\n  assumes \"p = Polynomial.smult c (\\<Prod>i\\<in>A. [:-root i, 1:])\"\n  obtains q' where \"vars q' \\<subseteq> {0..<n}\"\n               and \"\\<And>m. coeff q' m \\<in> C\"\n               and \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], "translations": [["", "lemma infinite_infinite_subsets:\n  assumes \"infinite A\"\n  shows   \"infinite {X. X \\<subseteq> A \\<and> infinite X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "have \"\\<forall>k. \\<exists>X. X \\<subseteq> A \\<and> infinite X \\<and> card (A - X) = k\" for k :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "obtain Y where \"finite Y\" \"card Y = k\" \"Y \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>finite Y; card Y = k; Y \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infinite_arbitrarily_large[of A k] assms"], ["proof (prove)\nusing this:\n  infinite A \\<Longrightarrow>\n  \\<exists>B. finite B \\<and> card B = k \\<and> B \\<subseteq> A\n  infinite A\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>finite Y; card Y = k; Y \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "moreover"], ["proof (state)\nthis:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "from this"], ["proof (chain)\npicking this:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A", "have \"A - (A - Y) = Y\""], ["proof (prove)\nusing this:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n\ngoal (1 subgoal):\n 1. A - (A - Y) = Y", "by auto"], ["proof (state)\nthis:\n  A - (A - Y) = Y\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "ultimately"], ["proof (chain)\npicking this:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n  A - (A - Y) = Y", "show \"\\<exists>X. X \\<subseteq> A \\<and> infinite X \\<and> card (A - X) = k\""], ["proof (prove)\nusing this:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n  A - (A - Y) = Y\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "using assms"], ["proof (prove)\nusing this:\n  finite Y\n  card Y = k\n  Y \\<subseteq> A\n  A - (A - Y) = Y\n  infinite A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k", "by (intro exI[of _ \"A - Y\"]) auto"], ["proof (state)\nthis:\n  \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k. \\<exists>X\\<subseteq>A. infinite X \\<and> card (A - X) = k\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        f x \\<subseteq> A \\<and> infinite (f x) \\<and> card (A - f x) = x", "obtain f\n    where f: \"\\<And>k. f k \\<subseteq> A \\<and> infinite (f k) \\<and> card (A - f k) = k\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        f x \\<subseteq> A \\<and> infinite (f x) \\<and> card (A - f x) = x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>k.\n            f k \\<subseteq> A \\<and>\n            infinite (f k) \\<and> card (A - f k) = k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f ?k \\<subseteq> A \\<and> infinite (f ?k) \\<and> card (A - f ?k) = ?k\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "have \"k = l\" if \"f k = f l\" for k l"], ["proof (prove)\ngoal (1 subgoal):\n 1. k = l", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> False", "assume \"k \\<noteq> l\""], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> False", "hence \"card (A - f k) \\<noteq> card (A - f l)\""], ["proof (prove)\nusing this:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. card (A - f k) \\<noteq> card (A - f l)", "using f[of k] f[of l]"], ["proof (prove)\nusing this:\n  k \\<noteq> l\n  f k \\<subseteq> A \\<and> infinite (f k) \\<and> card (A - f k) = k\n  f l \\<subseteq> A \\<and> infinite (f l) \\<and> card (A - f l) = l\n\ngoal (1 subgoal):\n 1. card (A - f k) \\<noteq> card (A - f l)", "by auto"], ["proof (state)\nthis:\n  card (A - f k) \\<noteq> card (A - f l)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow> False", "with \\<open>f k = f l\\<close>"], ["proof (chain)\npicking this:\n  f k = f l\n  card (A - f k) \\<noteq> card (A - f l)", "show False"], ["proof (prove)\nusing this:\n  f k = f l\n  card (A - f k) \\<noteq> card (A - f l)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ?k = f ?l \\<Longrightarrow> ?k = ?l\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "hence \"inj f\""], ["proof (prove)\nusing this:\n  f ?k = f ?l \\<Longrightarrow> ?k = ?l\n\ngoal (1 subgoal):\n 1. inj f", "by (auto intro: injI)"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "moreover"], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "have \"range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}", "using f"], ["proof (prove)\nusing this:\n  f ?k \\<subseteq> A \\<and> infinite (f ?k) \\<and> card (A - f ?k) = ?k\n\ngoal (1 subgoal):\n 1. range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}", "by auto"], ["proof (state)\nthis:\n  range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "ultimately"], ["proof (chain)\npicking this:\n  inj f\n  range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj f\n  range f \\<subseteq> {X. X \\<subseteq> A \\<and> infinite X}\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "by (subst infinite_iff_countable_subset) auto"], ["proof (state)\nthis:\n  infinite {X. X \\<subseteq> A \\<and> infinite X}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  An infinite set contains infinitely many finite subsets of any fixed nonzero cardinality.\n\\<close>"], ["", "lemma infinite_card_subsets:\n  assumes \"infinite A\" \"k > 0\"\n  shows   \"infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "obtain B where B: \"B \\<subseteq> A\" \"finite B\" \"card B = k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> A; finite B; card B = k - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infinite_arbitrarily_large[OF assms(1), of \"k - 1\"]"], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> card B = k - 1 \\<and> B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> A; finite B; card B = k - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  finite B\n  card B = k - 1\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "define f where \"f = (\\<lambda>x. insert x B)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. insert x B)\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "have \"f ` (A - B) \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (A - B)\n    \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "using assms B"], ["proof (prove)\nusing this:\n  infinite A\n  0 < k\n  B \\<subseteq> A\n  finite B\n  card B = k - 1\n\ngoal (1 subgoal):\n 1. f ` (A - B)\n    \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  f ` (A - B)\n  \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "moreover"], ["proof (state)\nthis:\n  f ` (A - B)\n  \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "have \"inj_on f (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (A - B)", "by (auto intro!: inj_onI simp: f_def)"], ["proof (state)\nthis:\n  inj_on f (A - B)\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "hence \"infinite (f ` (A - B))\""], ["proof (prove)\nusing this:\n  inj_on f (A - B)\n\ngoal (1 subgoal):\n 1. infinite (f ` (A - B))", "using assms B"], ["proof (prove)\nusing this:\n  inj_on f (A - B)\n  infinite A\n  0 < k\n  B \\<subseteq> A\n  finite B\n  card B = k - 1\n\ngoal (1 subgoal):\n 1. infinite (f ` (A - B))", "by (subst finite_image_iff) auto"], ["proof (state)\nthis:\n  infinite (f ` (A - B))\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "ultimately"], ["proof (chain)\npicking this:\n  f ` (A - B)\n  \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n  infinite (f ` (A - B))", "show ?thesis"], ["proof (prove)\nusing this:\n  f ` (A - B)\n  \\<subseteq> {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n  infinite (f ` (A - B))\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "by (rule infinite_super)"], ["proof (state)\nthis:\n  infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_bij_eq_iff:\n  assumes \"bij f\"\n  shows   \"g \\<circ> f = h \\<circ> f \\<longleftrightarrow> g = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ> f = h \\<circ> f) = (g = h)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<circ> f = h \\<circ> f \\<Longrightarrow> g = h\n 2. g = h \\<Longrightarrow> g \\<circ> f = h \\<circ> f", "assume *: \"g \\<circ> f = h \\<circ> f\""], ["proof (state)\nthis:\n  g \\<circ> f = h \\<circ> f\n\ngoal (2 subgoals):\n 1. g \\<circ> f = h \\<circ> f \\<Longrightarrow> g = h\n 2. g = h \\<Longrightarrow> g \\<circ> f = h \\<circ> f", "show \"g = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x = h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. g x = h x", "obtain y where [simp]: \"x = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. x = f y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using bij_is_surj[OF assms]"], ["proof (prove)\nusing this:\n  surj f\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = f y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x. g x = h x", "have \"(g \\<circ> f) y = (h \\<circ> f) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<circ> f) y = (h \\<circ> f) y", "by (simp only: *)"], ["proof (state)\nthis:\n  (g \\<circ> f) y = (h \\<circ> f) y\n\ngoal (1 subgoal):\n 1. \\<And>x. g x = h x", "thus \"g x = h x\""], ["proof (prove)\nusing this:\n  (g \\<circ> f) y = (h \\<circ> f) y\n\ngoal (1 subgoal):\n 1. g x = h x", "by simp"], ["proof (state)\nthis:\n  g x = h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g = h\n\ngoal (1 subgoal):\n 1. g = h \\<Longrightarrow> g \\<circ> f = h \\<circ> f", "qed auto"], ["", "lemma sum_list_replicate [simp]:\n  \"sum_list (replicate n x) = of_nat n * (x :: 'a :: semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate n x) = of_nat n * x", "by (induction n) (auto simp: algebra_simps)"], ["", "lemma ex_subset_of_card:\n  assumes \"finite A\" \"card A \\<ge> k\"\n  shows   \"\\<exists>B. B \\<subseteq> A \\<and> card B = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>A. card B = k", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  k \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>A. card B = k", "proof (induction arbitrary: k rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<le> card {} \\<Longrightarrow> \\<exists>B\\<subseteq>{}. card B = k\n 2. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           k \\<le> card F \\<Longrightarrow>\n           \\<exists>B\\<subseteq>F. card B = k;\n        k \\<le> card (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B\\<subseteq>insert x F. card B = k", "case empty"], ["proof (state)\nthis:\n  k \\<le> card {}\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       k \\<le> card {} \\<Longrightarrow> \\<exists>B\\<subseteq>{}. card B = k\n 2. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           k \\<le> card F \\<Longrightarrow>\n           \\<exists>B\\<subseteq>F. card B = k;\n        k \\<le> card (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B\\<subseteq>insert x F. card B = k", "thus ?case"], ["proof (prove)\nusing this:\n  k \\<le> card {}\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>{}. card B = k", "by auto"], ["proof (state)\nthis:\n  \\<exists>B\\<subseteq>{}. card B = k\n\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           k \\<le> card F \\<Longrightarrow>\n           \\<exists>B\\<subseteq>F. card B = k;\n        k \\<le> card (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B\\<subseteq>insert x F. card B = k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           k \\<le> card F \\<Longrightarrow>\n           \\<exists>B\\<subseteq>F. card B = k;\n        k \\<le> card (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B\\<subseteq>insert x F. card B = k", "case (insert x A k)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n\ngoal (1 subgoal):\n 1. \\<And>x F k.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>k.\n           k \\<le> card F \\<Longrightarrow>\n           \\<exists>B\\<subseteq>F. card B = k;\n        k \\<le> card (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B\\<subseteq>insert x F. card B = k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>insert x A. card B = k", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> \\<exists>B\\<subseteq>insert x A. card B = k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> \\<exists>B\\<subseteq>insert x A. card B = k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>insert x A. card B = k", "by (intro exI[of _ \"{}\"]) auto"], ["proof (state)\nthis:\n  \\<exists>B\\<subseteq>insert x A. card B = k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)", "have \"\\<exists>B\\<subseteq>A. card B = k - 1\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>A. card B = k - 1", "by (intro insert.IH) auto"], ["proof (state)\nthis:\n  \\<exists>B\\<subseteq>A. card B = k - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "then"], ["proof (chain)\npicking this:\n  \\<exists>B\\<subseteq>A. card B = k - 1", "obtain B where B: \"B \\<subseteq> A\" \"card B = k - 1\""], ["proof (prove)\nusing this:\n  \\<exists>B\\<subseteq>A. card B = k - 1\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> A; card B = k - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  card B = k - 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "with insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n  B \\<subseteq> A\n  card B = k - 1", "have [simp]: \"x \\<notin> B\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n  B \\<subseteq> A\n  card B = k - 1\n\ngoal (1 subgoal):\n 1. x \\<notin> B", "by auto"], ["proof (state)\nthis:\n  x \\<notin> B\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "have \"insert x B \\<subseteq> insert x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x B \\<subseteq> insert x A", "using B insert"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  card B = k - 1\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n\ngoal (1 subgoal):\n 1. insert x B \\<subseteq> insert x A", "by auto"], ["proof (state)\nthis:\n  insert x B \\<subseteq> insert x A\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "moreover"], ["proof (state)\nthis:\n  insert x B \\<subseteq> insert x A\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "have \"card (insert x B) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x B) = k", "using insert B finite_subset[of B A] False"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  ?k \\<le> card A \\<Longrightarrow> \\<exists>B\\<subseteq>A. card B = ?k\n  k \\<le> card (insert x A)\n  B \\<subseteq> A\n  card B = k - 1\n  \\<lbrakk>B \\<subseteq> A; finite A\\<rbrakk> \\<Longrightarrow> finite B\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (insert x B) = k", "by (subst card.insert_remove) auto"], ["proof (state)\nthis:\n  card (insert x B) = k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>B\\<subseteq>insert x A. card B = k", "ultimately"], ["proof (chain)\npicking this:\n  insert x B \\<subseteq> insert x A\n  card (insert x B) = k", "show ?thesis"], ["proof (prove)\nusing this:\n  insert x B \\<subseteq> insert x A\n  card (insert x B) = k\n\ngoal (1 subgoal):\n 1. \\<exists>B\\<subseteq>insert x A. card B = k", "by blast"], ["proof (state)\nthis:\n  \\<exists>B\\<subseteq>insert x A. card B = k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>B\\<subseteq>insert x A. card B = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_sorted_list_of_set [simp]: \"length (sorted_list_of_set A) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sorted_list_of_set A) = card A", "using distinct_card[of \"sorted_list_of_set A\"]"], ["proof (prove)\nusing this:\n  distinct (sorted_list_of_set A) \\<Longrightarrow>\n  card (set (sorted_list_of_set A)) = length (sorted_list_of_set A)\n\ngoal (1 subgoal):\n 1. length (sorted_list_of_set A) = card A", "by (cases \"finite A\") simp_all"], ["", "lemma upt_add_eq_append': \"i \\<le> j \\<Longrightarrow> j \\<le> k \\<Longrightarrow> [i..<k] = [i..<j] @ [j..<k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [i..<k] = [i..<j] @ [j..<k]", "using upt_add_eq_append[of i j \"k - j\"]"], ["proof (prove)\nusing this:\n  i \\<le> j \\<Longrightarrow>\n  [i..<j + (k - j)] = [i..<j] @ [j..<j + (k - j)]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; j \\<le> k\\<rbrakk>\n    \\<Longrightarrow> [i..<k] = [i..<j] @ [j..<k]", "by simp"], ["", "subsection \\<open>Subrings and ring homomorphisms\\<close>"], ["", "locale ring_closed =\n  fixes A :: \"'a :: comm_ring_1 set\"\n  assumes zero_closed [simp]: \"0 \\<in> A\"\n  assumes one_closed [simp]: \"1 \\<in> A\"\n  assumes add_closed [simp]: \"x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> (x + y) \\<in> A\"\n  assumes mult_closed [simp]: \"x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> (x * y) \\<in> A\"\n  assumes uminus_closed [simp]: \"x \\<in> A \\<Longrightarrow> -x \\<in> A\"\nbegin"], ["", "lemma minus_closed [simp]: \"x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x - y \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; y \\<in> A\\<rbrakk> \\<Longrightarrow> x - y \\<in> A", "using add_closed[of x \"-y\"] uminus_closed[of y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> A; - y \\<in> A\\<rbrakk> \\<Longrightarrow> x + - y \\<in> A\n  y \\<in> A \\<Longrightarrow> - y \\<in> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; y \\<in> A\\<rbrakk> \\<Longrightarrow> x - y \\<in> A", "by auto"], ["", "lemma sum_closed [intro]: \"(\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow> sum f X \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow>\n    sum f X \\<in> A", "by (induction X rule: infinite_finite_induct) auto"], ["", "lemma power_closed [intro]: \"x \\<in> A \\<Longrightarrow> x ^ n \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> x ^ n \\<in> A", "by (induction n) auto"], ["", "lemma Sum_any_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> Sum_any f \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<in> A) \\<Longrightarrow> Sum_any f \\<in> A", "unfolding Sum_any.expand_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<in> A) \\<Longrightarrow>\n    sum f {a. f a \\<noteq> (0::'a)} \\<in> A", "by (rule sum_closed)"], ["", "lemma prod_closed [intro]: \"(\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow> prod f X \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> A) \\<Longrightarrow>\n    prod f X \\<in> A", "by (induction X rule: infinite_finite_induct) auto"], ["", "lemma Prod_any_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> Prod_any f \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<in> A) \\<Longrightarrow> Prod_any f \\<in> A", "unfolding Prod_any.expand_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<in> A) \\<Longrightarrow>\n    prod f {a. f a \\<noteq> (1::'a)} \\<in> A", "by (rule prod_closed)"], ["", "lemma prod_fun_closed [intro]: \"(\\<And>x. f x \\<in> A) \\<Longrightarrow> (\\<And>x. g x \\<in> A) \\<Longrightarrow> prod_fun f g x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x \\<in> A; \\<And>x. g x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> prod_fun f g x \\<in> A", "by (auto simp: prod_fun_def when_def intro!: Sum_any_closed mult_closed)"], ["", "lemma of_nat_closed [simp, intro]: \"of_nat n \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n \\<in> A", "by (induction n) auto"], ["", "lemma of_int_closed [simp, intro]: \"of_int n \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int n \\<in> A", "by (induction n) auto"], ["", "end"], ["", "locale ring_homomorphism =\n  fixes f :: \"'a :: comm_ring_1 \\<Rightarrow> 'b :: comm_ring_1\"\n  assumes add[simp]: \"f (x + y) = f x + f y\"\n  assumes uminus[simp]: \"f (-x) = -f x\"\n  assumes mult[simp]: \"f (x * y) = f x * f y\"\n  assumes zero[simp]: \"f 0 = 0\"\n  assumes one [simp]: \"f 1 = 1\"\nbegin"], ["", "lemma diff [simp]: \"f (x - y) = f x - f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x - y) = f x - f y", "using add[of x \"-y\"]"], ["proof (prove)\nusing this:\n  f (x + - y) = f x + f (- y)\n\ngoal (1 subgoal):\n 1. f (x - y) = f x - f y", "by (simp del: add)"], ["", "lemma power [simp]: \"f (x ^ n) = f x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x ^ n) = f x ^ n", "by (induction n) auto"], ["", "lemma sum [simp]: \"f (sum g A) = (\\<Sum>x\\<in>A. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (sum g A) = (\\<Sum>x\\<in>A. f (g x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma prod [simp]: \"f (prod g A) = (\\<Prod>x\\<in>A. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (prod g A) = (\\<Prod>x\\<in>A. f (g x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "end"], ["", "lemma ring_homomorphism_id [intro]: \"ring_homomorphism id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism id", "by standard auto"], ["", "lemma ring_homomorphism_id' [intro]: \"ring_homomorphism (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism (\\<lambda>x. x)", "by standard auto"], ["", "lemma ring_homomorphism_of_int [intro]: \"ring_homomorphism of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism of_int", "by standard auto"], ["", "subsection \\<open>Various facts about multivariate polynomials\\<close>"], ["", "lemma poly_mapping_nat_ge_0 [simp]: \"(m :: nat \\<Rightarrow>\\<^sub>0 nat) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> m", "proof (cases \"m = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> 0 \\<le> m\n 2. m \\<noteq> 0 \\<Longrightarrow> 0 \\<le> m", "case False"], ["proof (state)\nthis:\n  m \\<noteq> 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> 0 \\<le> m\n 2. m \\<noteq> 0 \\<Longrightarrow> 0 \\<le> m", "hence \"Poly_Mapping.lookup m \\<noteq> Poly_Mapping.lookup 0\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lookup m \\<noteq> lookup 0", "by transfer auto"], ["proof (state)\nthis:\n  lookup m \\<noteq> lookup 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> 0 \\<le> m\n 2. m \\<noteq> 0 \\<Longrightarrow> 0 \\<le> m", "hence \"\\<exists>k. Poly_Mapping.lookup m k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lookup m \\<noteq> lookup 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. lookup m k \\<noteq> 0", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  \\<exists>k. lookup m k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow> 0 \\<le> m\n 2. m \\<noteq> 0 \\<Longrightarrow> 0 \\<le> m", "from LeastI_ex[OF this] Least_le[of \"\\<lambda>k. Poly_Mapping.lookup m k \\<noteq> 0\"]"], ["proof (chain)\npicking this:\n  lookup m (LEAST k. lookup m k \\<noteq> 0) \\<noteq> 0\n  lookup m ?k \\<noteq> 0 \\<Longrightarrow>\n  (LEAST x. lookup m x \\<noteq> 0) \\<le> ?k", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup m (LEAST k. lookup m k \\<noteq> 0) \\<noteq> 0\n  lookup m ?k \\<noteq> 0 \\<Longrightarrow>\n  (LEAST x. lookup m x \\<noteq> 0) \\<le> ?k\n\ngoal (1 subgoal):\n 1. 0 \\<le> m", "by (force simp: less_eq_poly_mapping_def less_fun_def)"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow> 0 \\<le> m", "qed auto"], ["", "lemma poly_mapping_nat_le_0 [simp]: \"(m :: nat \\<Rightarrow>\\<^sub>0 nat) \\<le> 0 \\<longleftrightarrow> m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<le> 0) = (m = 0)", "unfolding less_eq_poly_mapping_def poly_mapping_eq_iff less_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun lookup (map_fun lookup id)\n     (\\<lambda>f g.\n         (\\<exists>k. f k < g k \\<and> (\\<forall>k'<k. f k' = g k')) \\<or>\n         f = g)\n     m 0 =\n    (lookup m = lookup 0)", "by auto"], ["", "lemma of_nat_diff_poly_mapping_nat:\n  assumes \"m \\<ge> n\"\n  shows   \"of_nat (m - n) = (of_nat m - of_nat n :: 'a :: monoid_add \\<Rightarrow>\\<^sub>0 nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (m - n) = of_nat m - of_nat n", "by (auto intro!: poly_mapping_eqI simp: lookup_of_nat lookup_minus when_def)"], ["", "lemma mpoly_coeff_transfer [transfer_rule]:\n  \"rel_fun cr_mpoly (=) poly_mapping.lookup MPoly_Type.coeff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_mpoly (=) lookup MPoly_Type.coeff", "unfolding MPoly_Type.coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun cr_mpoly (=) lookup (\\<lambda>p. lookup (mapping_of p))", "by transfer_prover"], ["", "lemma mapping_of_sum: \"(\\<Sum>x\\<in>A. mapping_of (f x)) = mapping_of (sum f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. mapping_of (f x)) = mapping_of (sum f A)", "by (induction A rule: infinite_finite_induct) (auto simp: plus_mpoly.rep_eq zero_mpoly.rep_eq)"], ["", "lemma mapping_of_eq_0_iff [simp]: \"mapping_of p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mapping_of p = 0) = (p = 0)", "by transfer auto"], ["", "lemma Sum_any_mapping_of: \"Sum_any (\\<lambda>x. mapping_of (f x)) = mapping_of (Sum_any f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. mapping_of (f x)) = mapping_of (Sum_any f)", "by (simp add: Sum_any.expand_set mapping_of_sum)"], ["", "lemma Sum_any_parametric_cr_mpoly [transfer_rule]:\n  \"(rel_fun (rel_fun (=) cr_mpoly) cr_mpoly) Sum_any Sum_any\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_fun (=) cr_mpoly) cr_mpoly Sum_any Sum_any", "by (auto simp: rel_fun_def cr_mpoly_def Sum_any_mapping_of)"], ["", "lemma lookup_mult_of_nat [simp]: \"lookup (of_nat n * m) k = n * lookup m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "have \"of_nat n * m = (\\<Sum>i<n. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n * m = (\\<Sum>i<n. m)", "by simp"], ["proof (state)\nthis:\n  of_nat n * m = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "also"], ["proof (state)\nthis:\n  of_nat n * m = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "have \"lookup \\<dots> k = (\\<Sum>i<n. lookup m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<Sum>i<n. m) k = (\\<Sum>i<n. lookup m k)", "by (simp only: lookup_sum)"], ["proof (state)\nthis:\n  lookup (\\<Sum>i<n. m) k = (\\<Sum>i<n. lookup m k)\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "also"], ["proof (state)\nthis:\n  lookup (\\<Sum>i<n. m) k = (\\<Sum>i<n. lookup m k)\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "have \"\\<dots> = n * lookup m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. lookup m k) = n * lookup m k", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n. lookup m k) = n * lookup m k\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "finally"], ["proof (chain)\npicking this:\n  lookup (of_nat n * m) k = n * lookup m k", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (of_nat n * m) k = n * lookup m k\n\ngoal (1 subgoal):\n 1. lookup (of_nat n * m) k = n * lookup m k", "."], ["proof (state)\nthis:\n  lookup (of_nat n * m) k = n * lookup m k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_eqI:\n  assumes \"\\<And>mon. MPoly_Type.coeff p mon = MPoly_Type.coeff q mon\"\n  shows   \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p ?mon = MPoly_Type.coeff q ?mon\n\ngoal (1 subgoal):\n 1. p = q", "by (transfer, transfer) (auto simp: fun_eq_iff)"], ["", "lemma coeff_mpoly_times:\n  \"MPoly_Type.coeff (p * q) mon = prod_fun (MPoly_Type.coeff p) (MPoly_Type.coeff q) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p * q) mon =\n    prod_fun (MPoly_Type.coeff p) (MPoly_Type.coeff q) mon", "by (transfer', transfer') auto"], ["", "lemma (in ring_closed) coeff_mult_closed [intro]:\n  \"(\\<And>x. coeff p x \\<in> A) \\<Longrightarrow> (\\<And>x. coeff q x \\<in> A) \\<Longrightarrow> coeff (p * q) x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. MPoly_Type.coeff p x \\<in> A;\n     \\<And>x. MPoly_Type.coeff q x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (p * q) x \\<in> A", "by (auto simp: coeff_mpoly_times prod_fun_closed)"], ["", "lemma coeff_notin_vars:\n  assumes \"\\<not>(keys m \\<subseteq> vars p)\"\n  shows   \"coeff p m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m = (0::'a)", "unfolding vars_def"], ["proof (prove)\nusing this:\n  \\<not> keys m \\<subseteq> \\<Union> (keys ` keys (mapping_of p))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m = (0::'a)", "by transfer' (auto simp: in_keys_iff)"], ["", "lemma finite_coeff_support [intro]: \"finite {m. coeff p m \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {m. MPoly_Type.coeff p m \\<noteq> (0::'a)}", "by transfer simp"], ["", "lemma insertion_altdef:\n  \"insertion f p = Sum_any (\\<lambda>m. coeff p m * Prod_any (\\<lambda>i. f i ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f p =\n    (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. f i ^ lookup m i))", "by (transfer', transfer') (simp add: insertion_fun_def)"], ["", "lemma mpoly_coeff_uminus [simp]: \"coeff (-p) m = -coeff p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (- p) m = - MPoly_Type.coeff p m", "by transfer auto"], ["", "lemma Sum_any_uminus: \"Sum_any (\\<lambda>x. -f x :: 'a :: ab_group_add) = -Sum_any f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. - f x) = - Sum_any f", "by (simp add: Sum_any.expand_set sum_negf)"], ["", "lemma insertion_uminus [simp]: \"insertion f (-p :: 'a :: comm_ring_1 mpoly) = -insertion f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (- p) = - insertion f p", "by (simp add: insertion_altdef Sum_any_uminus)"], ["", "lemma Sum_any_lookup: \"finite {x. g x \\<noteq> 0} \\<Longrightarrow> Sum_any (\\<lambda>x. lookup (g x) y) = lookup (Sum_any g) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> 0} \\<Longrightarrow>\n    (\\<Sum>x. lookup (g x) y) = lookup (Sum_any g) y", "by (auto simp: Sum_any.expand_set lookup_sum intro!: sum.mono_neutral_left)"], ["", "lemma Sum_any_diff:\n  assumes \"finite {x. f x \\<noteq> 0}\"\n  assumes \"finite {x. g x \\<noteq> 0}\"\n  shows   \"Sum_any (\\<lambda>x. f x - g x :: 'a :: ab_group_add) = Sum_any f - Sum_any g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "have \"{x. f x - g x \\<noteq> 0} \\<subseteq> {x. f x \\<noteq> 0} \\<union> {x. g x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. f x - g x \\<noteq> (0::'a)}\n    \\<subseteq> {x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)}", "by auto"], ["proof (state)\nthis:\n  {x. f x - g x \\<noteq> (0::'a)}\n  \\<subseteq> {x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "moreover"], ["proof (state)\nthis:\n  {x. f x - g x \\<noteq> (0::'a)}\n  \\<subseteq> {x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "have \"finite ({x. f x \\<noteq> 0} \\<union> {x. g x \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)})", "by (subst finite_Un) (insert assms, auto)"], ["proof (state)\nthis:\n  finite ({x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "ultimately"], ["proof (chain)\npicking this:\n  {x. f x - g x \\<noteq> (0::'a)}\n  \\<subseteq> {x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)}\n  finite ({x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)})", "have \"finite {x. f x - g x \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {x. f x - g x \\<noteq> (0::'a)}\n  \\<subseteq> {x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)}\n  finite ({x. f x \\<noteq> (0::'a)} \\<union> {x. g x \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. finite {x. f x - g x \\<noteq> (0::'a)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {x. f x - g x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "with assms"], ["proof (chain)\npicking this:\n  finite {x. f x \\<noteq> (0::'a)}\n  finite {x. g x \\<noteq> (0::'a)}\n  finite {x. f x - g x \\<noteq> (0::'a)}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {x. f x \\<noteq> (0::'a)}\n  finite {x. g x \\<noteq> (0::'a)}\n  finite {x. f x - g x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g", "by (simp add: algebra_simps Sum_any.distrib [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>x. f x - g x) = Sum_any f - Sum_any g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_diff:\n  \"insertion f (p - q :: 'a :: comm_ring_1 mpoly) = insertion f p - insertion f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p - q) = insertion f p - insertion f q", "proof (transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "fix f :: \"nat \\<Rightarrow> 'a\" and p q :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "assume fin: \"finite {x. p x \\<noteq> 0}\" \"finite {x. q x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. p x \\<noteq> (0::'a)}\n  finite {x. q x \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "have \"insertion_fun f (\\<lambda>x. p x - q x) =\n          (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) - q m * (\\<Prod>v. f v ^ lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>x. p x - q x) =\n    (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n              q m * (\\<Prod>v. f v ^ lookup m v))", "by (simp add: insertion_fun_def algebra_simps Sum_any_diff)"], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>x. p x - q x) =\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n            q m * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "also"], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>x. p x - q x) =\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n            q m * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "have \"\\<dots> = (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) - (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n              q m * (\\<Prod>v. f v ^ lookup m v)) =\n    (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) -\n    (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v))", "by (subst Sum_any_diff) (auto intro: finite_subset[OF _ fin(1)] finite_subset[OF _ fin(2)])"], ["proof (state)\nthis:\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n            q m * (\\<Prod>v. f v ^ lookup m v)) =\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) -\n  (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v) -\n            q m * (\\<Prod>v. f v ^ lookup m v)) =\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) -\n  (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "have \"\\<dots> = insertion_fun f p - insertion_fun f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) -\n    (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v)) =\n    insertion_fun f p - insertion_fun f q", "by (simp add: insertion_fun_def)"], ["proof (state)\nthis:\n  (\\<Sum>m. p m * (\\<Prod>v. f v ^ lookup m v)) -\n  (\\<Sum>m. q m * (\\<Prod>v. f v ^ lookup m v)) =\n  insertion_fun f p - insertion_fun f q\n\ngoal (1 subgoal):\n 1. \\<And>f p q.\n       \\<lbrakk>finite {x. p x \\<noteq> (0::'a)};\n        finite {x. q x \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f (\\<lambda>k. p k - q k) =\n                         insertion_fun f p - insertion_fun f q", "finally"], ["proof (chain)\npicking this:\n  insertion_fun f (\\<lambda>x. p x - q x) =\n  insertion_fun f p - insertion_fun f q", "show \"insertion_fun f (\\<lambda>x. p x - q x) = \\<dots>\""], ["proof (prove)\nusing this:\n  insertion_fun f (\\<lambda>x. p x - q x) =\n  insertion_fun f p - insertion_fun f q\n\ngoal (1 subgoal):\n 1. insertion_fun f (\\<lambda>x. p x - q x) =\n    insertion_fun f p - insertion_fun f q", "."], ["proof (state)\nthis:\n  insertion_fun f (\\<lambda>x. p x - q x) =\n  insertion_fun f p - insertion_fun f q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_power: \"insertion f (p ^ n) = insertion f p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (p ^ n) = insertion f p ^ n", "by (induction n) (simp_all add: insertion_mult)"], ["", "lemma insertion_sum: \"insertion f (sum g A) = (\\<Sum>x\\<in>A. insertion f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (sum g A) = (\\<Sum>x\\<in>A. insertion f (g x))", "by (induction A rule: infinite_finite_induct) (auto simp: insertion_add)"], ["", "lemma insertion_prod: \"insertion f (prod g A) = (\\<Prod>x\\<in>A. insertion f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (prod g A) = (\\<Prod>x\\<in>A. insertion f (g x))", "by (induction A rule: infinite_finite_induct) (auto simp: insertion_mult)"], ["", "lemma coeff_Var: \"coeff (Var i) m = (1 when m = Poly_Mapping.single i 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var i) m = ((1::'a) when m = Poly_Mapping.single i 1)", "by transfer' (auto simp: Var\\<^sub>0_def lookup_single when_def)"], ["", "lemma vars_Var: \"vars (Var i :: 'a :: {one,zero} mpoly) = (if (0::'a) = 1 then {} else {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Var i) = (if (0::'a) = (1::'a) then {} else {i})", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (Var i))) =\n    (if (0::'a) = (1::'a) then {} else {i})", "by (auto simp: Var.rep_eq Var\\<^sub>0_def)"], ["", "lemma insertion_Var [simp]: \"insertion f (Var i) = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "have \"insertion f (Var i) = (\\<Sum>m. (1 when m = Poly_Mapping.single i 1) *\n                                       (\\<Prod>i. f i ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Var i) =\n    (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n              (\\<Prod>i. f i ^ lookup m i))", "by (simp add: insertion_altdef coeff_Var)"], ["proof (state)\nthis:\n  insertion f (Var i) =\n  (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n            (\\<Prod>i. f i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "also"], ["proof (state)\nthis:\n  insertion f (Var i) =\n  (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n            (\\<Prod>i. f i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "have \"\\<dots> = (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n              (\\<Prod>i. f i ^ lookup m i)) =\n    (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j)", "by (subst Sum_any.expand_superset[of \"{Poly_Mapping.single i 1}\"]) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n            (\\<Prod>i. f i ^ lookup m i)) =\n  (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j)\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. ((1::'a) when m = Poly_Mapping.single i 1) *\n            (\\<Prod>i. f i ^ lookup m i)) =\n  (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j)\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "have \"\\<dots> = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j) = f i", "by (subst Prod_any.expand_superset[of \"{i}\"]) (auto simp: when_def lookup_single)"], ["proof (state)\nthis:\n  (\\<Prod>j. f j ^ lookup (Poly_Mapping.single i 1) j) = f i\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "finally"], ["proof (chain)\npicking this:\n  insertion f (Var i) = f i", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f (Var i) = f i\n\ngoal (1 subgoal):\n 1. insertion f (Var i) = f i", "."], ["proof (state)\nthis:\n  insertion f (Var i) = f i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_Sum_any:\n  assumes \"finite {x. g x \\<noteq> 0}\"\n  shows   \"insertion f (Sum_any g) = Sum_any (\\<lambda>x. insertion f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Sum_any g) = (\\<Sum>x. insertion f (g x))", "unfolding Sum_any.expand_set insertion_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{a. g a \\<noteq> 0}. insertion f (g x)) =\n    (\\<Sum>x\\<in>{a. insertion f (g a) \\<noteq> (0::'b)}. insertion f (g x))", "by (intro sum.mono_neutral_right) (auto intro!: finite_subset[OF _ assms])"], ["", "lemma keys_diff_subset:\n  \"keys (f - g) \\<subseteq> keys f \\<union> keys g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (f - g) \\<subseteq> keys f \\<union> keys g", "by transfer auto"], ["", "lemma keys_empty_iff [simp]: \"keys p = {} \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (keys p = {}) = (p = 0)", "by transfer auto"], ["", "lemma mpoly_coeff_0 [simp]: \"MPoly_Type.coeff 0 m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff 0 m = (0::'a)", "by transfer auto"], ["", "lemma lookup_1: \"lookup 1 m = (if m = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup 1 m = (if m = (0::'b) then 1::'a else (0::'a))", "by transfer (simp add: when_def)"], ["", "lemma mpoly_coeff_1: \"MPoly_Type.coeff 1 m = (if m = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff 1 m = (if m = 0 then 1::'a else (0::'a))", "by (simp add: MPoly_Type.coeff_def one_mpoly.rep_eq lookup_1)"], ["", "lemma lookup_Const\\<^sub>0: \"lookup (Const\\<^sub>0 c) m = (if m = 0 then c else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Const\\<^sub>0 c) m = (if m = 0 then c else (0::'a))", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.single 0 c) m = (if m = 0 then c else (0::'a))", "by (simp add: lookup_single when_def)"], ["", "lemma mpoly_coeff_Const: \"MPoly_Type.coeff (Const c) m = (if m = 0 then c else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Const c) m = (if m = 0 then c else (0::'a))", "by (simp add: MPoly_Type.coeff_def Const.rep_eq lookup_Const\\<^sub>0)"], ["", "lemma coeff_smult [simp]: \"coeff (smult c p) m = (c :: 'a :: mult_zero) * coeff p m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.smult c p) m = c * MPoly_Type.coeff p m", "by transfer (auto simp: map_lookup)"], ["", "lemma in_keys_mapI: \"x \\<in> keys m \\<Longrightarrow> f (lookup m x) \\<noteq> 0 \\<Longrightarrow> x \\<in> keys (Poly_Mapping.map f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> keys m; f (lookup m x) \\<noteq> (0::'c)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> keys (Poly_Mapping.map f m)", "by transfer auto"], ["", "lemma keys_uminus [simp]: \"keys (-m) = keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (- m) = keys m", "by transfer auto"], ["", "lemma vars_uminus [simp]: \"vars (-p) = vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (- p) = vars p", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (- p))) =\n    \\<Union> (keys ` keys (mapping_of p))", "by transfer' auto"], ["", "lemma vars_smult: \"vars (smult c p) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (MPoly_Type.smult c p) \\<subseteq> vars p", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (MPoly_Type.smult c p)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "by (transfer', transfer') auto"], ["", "lemma vars_0 [simp]: \"vars 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars 0 = {}", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of 0)) = {}", "by transfer' simp"], ["", "lemma vars_1 [simp]: \"vars 1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars 1 = {}", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of 1)) = {}", "by transfer' simp"], ["", "lemma vars_sum: \"vars (sum f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (sum f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))", "using vars_add"], ["proof (prove)\nusing this:\n  vars (?p1.0 + ?p2.0) \\<subseteq> vars ?p1.0 \\<union> vars ?p2.0\n\ngoal (1 subgoal):\n 1. vars (sum f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma vars_prod: \"vars (prod f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (prod f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))", "using vars_mult"], ["proof (prove)\nusing this:\n  vars (?p * ?q) \\<subseteq> vars ?p \\<union> vars ?q\n\ngoal (1 subgoal):\n 1. vars (prod f A) \\<subseteq> (\\<Union>x\\<in>A. vars (f x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma vars_Sum_any: \"vars (Sum_any h) \\<subseteq> (\\<Union>i. vars (h i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Sum_any h) \\<subseteq> (\\<Union>i. vars (h i))", "unfolding Sum_any.expand_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (sum h {a. h a \\<noteq> 0}) \\<subseteq> (\\<Union>i. vars (h i))", "by (intro order.trans[OF vars_sum]) auto"], ["", "lemma vars_Prod_any: \"vars (Prod_any h) \\<subseteq> (\\<Union>i. vars (h i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Prod_any h) \\<subseteq> (\\<Union>i. vars (h i))", "unfolding Prod_any.expand_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (prod h {a. h a \\<noteq> 1}) \\<subseteq> (\\<Union>i. vars (h i))", "by (intro order.trans[OF vars_prod]) auto"], ["", "lemma vars_power: \"vars (p ^ n) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p ^ n) \\<subseteq> vars p", "using vars_mult"], ["proof (prove)\nusing this:\n  vars (?p * ?q) \\<subseteq> vars ?p \\<union> vars ?q\n\ngoal (1 subgoal):\n 1. vars (p ^ n) \\<subseteq> vars p", "by (induction n) auto"], ["", "lemma vars_diff: \"vars (p1 - p2) \\<subseteq> vars p1 \\<union> vars p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p1 - p2) \\<subseteq> vars p1 \\<union> vars p2", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (p1 - p2)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p1)) \\<union>\n                \\<Union> (keys ` keys (mapping_of p2))", "proof transfer'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<Union> (keys ` keys (p1 - p2))\n       \\<subseteq> \\<Union> (keys ` keys p1) \\<union>\n                   \\<Union> (keys ` keys p2)", "fix p1 p2 :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<Union> (keys ` keys (p1 - p2))\n       \\<subseteq> \\<Union> (keys ` keys p1) \\<union>\n                   \\<Union> (keys ` keys p2)", "show \"\\<Union> (keys ` keys (p1 - p2)) \\<subseteq> \\<Union>(keys ` (keys p1)) \\<union> \\<Union>(keys ` (keys p2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (p1 - p2))\n    \\<subseteq> \\<Union> (keys ` keys p1) \\<union> \\<Union> (keys ` keys p2)", "using keys_diff_subset[of p1 p2]"], ["proof (prove)\nusing this:\n  keys (p1 - p2) \\<subseteq> keys p1 \\<union> keys p2\n\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (p1 - p2))\n    \\<subseteq> \\<Union> (keys ` keys p1) \\<union> \\<Union> (keys ` keys p2)", "by (auto simp flip: not_in_keys_iff_lookup_eq_zero)"], ["proof (state)\nthis:\n  \\<Union> (keys ` keys (p1 - p2))\n  \\<subseteq> \\<Union> (keys ` keys p1) \\<union> \\<Union> (keys ` keys p2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_smult [simp]: \"insertion f (smult c p) = c * insertion f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.smult c p) = c * insertion f p", "unfolding insertion_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff (MPoly_Type.smult c p) m *\n              (\\<Prod>i. f i ^ lookup m i)) =\n    c * (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. f i ^ lookup m i))", "by (subst Sum_any_right_distrib)\n     (auto intro: finite_subset[OF _ finite_coeff_support[of p]] simp: mult.assoc)"], ["", "lemma coeff_add [simp]: \"coeff (p + q) m = coeff p m + coeff q m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p + q) m = MPoly_Type.coeff p m + MPoly_Type.coeff q m", "by transfer' (simp add: lookup_add)"], ["", "lemma coeff_diff [simp]: \"coeff (p - q) m = coeff p m - coeff q m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p - q) m = MPoly_Type.coeff p m - MPoly_Type.coeff q m", "by transfer' (simp add: lookup_minus)"], ["", "lemma insertion_monom [simp]:\n  \"insertion f (monom m c) = c * Prod_any (\\<lambda>x. f x ^ lookup m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "have \"insertion f (monom m c) =\n          (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) =\n    (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v))", "by (simp add: insertion_def insertion_aux_def insertion_fun_def lookup_single)"], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom m c) =\n  (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v))\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "also"], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom m c) =\n  (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v))\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "have \"\\<dots> = c * (\\<Prod>v. f v ^ lookup m v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v)) =\n    c * (\\<Prod>v. f v ^ lookup m v)", "by (subst Sum_any.expand_superset[of \"{m}\"]) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>m'. (c when m = m') * (\\<Prod>v. f v ^ lookup m' v)) =\n  c * (\\<Prod>v. f v ^ lookup m v)\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "finally"], ["proof (chain)\npicking this:\n  insertion f (MPoly_Type.monom m c) = c * (\\<Prod>v. f v ^ lookup m v)", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion f (MPoly_Type.monom m c) = c * (\\<Prod>v. f v ^ lookup m v)\n\ngoal (1 subgoal):\n 1. insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)", "."], ["proof (state)\nthis:\n  insertion f (MPoly_Type.monom m c) = c * (\\<Prod>x. f x ^ lookup m x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_aux_Const\\<^sub>0 [simp]: \"insertion_aux f (Const\\<^sub>0 c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "have \"insertion_aux f (Const\\<^sub>0 c) = (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) =\n    (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))", "by (simp add: Const\\<^sub>0_def insertion_aux_def insertion_fun_def lookup_single)"], ["proof (state)\nthis:\n  insertion_aux f (Const\\<^sub>0 c) =\n  (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "also"], ["proof (state)\nthis:\n  insertion_aux f (Const\\<^sub>0 c) =\n  (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "have \"\\<dots> = (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v)) =\n    (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))", "by (intro Sum_any.expand_superset) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v)) =\n  (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v)) =\n  (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v))\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "have \"\\<dots> = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v)) = c", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>{0}. (c when m = 0) * (\\<Prod>v. f v ^ lookup m v)) = c\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "finally"], ["proof (chain)\npicking this:\n  insertion_aux f (Const\\<^sub>0 c) = c", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion_aux f (Const\\<^sub>0 c) = c\n\ngoal (1 subgoal):\n 1. insertion_aux f (Const\\<^sub>0 c) = c", "."], ["proof (state)\nthis:\n  insertion_aux f (Const\\<^sub>0 c) = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_Const [simp]: \"insertion f (Const c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (Const c) = c", "by (simp add: insertion_def Const.rep_eq)"], ["", "lemma coeffs_0 [simp]: \"coeffs 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeffs 0 = {}", "by transfer auto"], ["", "lemma coeffs_1 [simp]: \"coeffs 1 = {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeffs 1 = {1::'a}", "by transfer auto"], ["", "lemma coeffs_Const: \"coeffs (Const c) = (if c = 0 then {} else {c})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeffs (Const c) = (if c = (0::'a) then {} else {c})", "unfolding Const_def Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeffs (map_fun id MPoly (Poly_Mapping.single 0) c) =\n    (if c = (0::'a) then {} else {c})", "by transfer' auto"], ["", "lemma coeffs_subset: \"coeffs (Const c) \\<subseteq> {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeffs (Const c) \\<subseteq> {c}", "by (auto simp: coeffs_Const)"], ["", "lemma keys_Const\\<^sub>0: \"keys (Const\\<^sub>0 c) = (if c = 0 then {} else {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Const\\<^sub>0 c) = (if c = (0::'b) then {} else {0})", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Poly_Mapping.single 0 c) = (if c = (0::'b) then {} else {0})", "by transfer' auto"], ["", "lemma vars_Const [simp]: \"vars (Const c) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Const c) = {}", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (Const c))) = {}", "by transfer' (auto simp: keys_Const\\<^sub>0)"], ["", "lemma prod_fun_compose_bij:\n  assumes \"bij f\" and f: \"\\<And>x y. f (x + y) = f x + f y\"\n  shows   \"prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "have [simp]: \"f x = f y \\<longleftrightarrow> x = y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x = f y) = (x = y)", "using \\<open>bij f\\<close>"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. (f x = f y) = (x = y)", "by (auto dest!: bij_is_inj inj_onD)"], ["proof (state)\nthis:\n  (f ?x = f ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "have \"prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x =\n          Sum_any ((\\<lambda>l. m1 l * Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x =\n    Sum_any\n     ((\\<lambda>l.\n          m1 l *\n          Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n      f)", "by (simp add: prod_fun_def f(1) [symmetric] o_def)"], ["proof (state)\nthis:\n  prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x =\n  Sum_any\n   ((\\<lambda>l.\n        m1 l *\n        Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n    f)\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "also"], ["proof (state)\nthis:\n  prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x =\n  Sum_any\n   ((\\<lambda>l.\n        m1 l *\n        Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n    f)\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "have \"\\<dots> = Sum_any ((\\<lambda>l. m1 l * Sum_any ((\\<lambda>q. m2 q when f x = l + q))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_any\n     ((\\<lambda>l.\n          m1 l *\n          Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n      f) =\n    (\\<Sum>l. m1 l * (\\<Sum>q. m2 q when f x = l + q))", "by (simp only: Sum_any.reindex_cong[OF assms(1) refl, symmetric])"], ["proof (state)\nthis:\n  Sum_any\n   ((\\<lambda>l.\n        m1 l *\n        Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n    f) =\n  (\\<Sum>l. m1 l * (\\<Sum>q. m2 q when f x = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "also"], ["proof (state)\nthis:\n  Sum_any\n   ((\\<lambda>l.\n        m1 l *\n        Sum_any ((\\<lambda>q. m2 q when f x = l + q) \\<circ> f)) \\<circ>\n    f) =\n  (\\<Sum>l. m1 l * (\\<Sum>q. m2 q when f x = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "have \"\\<dots> = prod_fun m1 m2 (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. m1 l * (\\<Sum>q. m2 q when f x = l + q)) =\n    prod_fun m1 m2 (f x)", "by (simp add: prod_fun_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. m1 l * (\\<Sum>q. m2 q when f x = l + q)) = prod_fun m1 m2 (f x)\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", "finally"], ["proof (chain)\npicking this:\n  prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x = prod_fun m1 m2 (f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x = prod_fun m1 m2 (f x)\n\ngoal (1 subgoal):\n 1. prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x", ".."], ["proof (state)\nthis:\n  prod_fun m1 m2 (f x) = prod_fun (m1 \\<circ> f) (m2 \\<circ> f) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_nat_poly_mapping_zero_iff [simp]:\n  \"(a + b :: 'a \\<Rightarrow>\\<^sub>0 nat) = 0 \\<longleftrightarrow> a = 0 \\<and> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b = 0) = (a = 0 \\<and> b = 0)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma prod_fun_nat_0:\n  fixes f g :: \"('a \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'b::semiring_0\"\n  shows   \"prod_fun f g 0 = f 0 * g 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "have \"prod_fun f g 0 = (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g 0 = (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q))", "unfolding prod_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q)) =\n    (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q))", ".."], ["proof (state)\nthis:\n  prod_fun f g 0 = (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "also"], ["proof (state)\nthis:\n  prod_fun f g 0 = (\\<Sum>l. f l * (\\<Sum>q. g q when 0 = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "have \"(\\<lambda>l. \\<Sum>q. g q when 0 = l + q) = (\\<lambda>l. \\<Sum>q\\<in>{0}. g q when 0 = l + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. \\<Sum>q. g q when 0 = l + q) =\n    (\\<lambda>l. \\<Sum>q\\<in>{0}. g q when 0 = l + q)", "by (intro ext Sum_any.expand_superset) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<lambda>l. \\<Sum>q. g q when 0 = l + q) =\n  (\\<lambda>l. \\<Sum>q\\<in>{0}. g q when 0 = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "also"], ["proof (state)\nthis:\n  (\\<lambda>l. \\<Sum>q. g q when 0 = l + q) =\n  (\\<lambda>l. \\<Sum>q\\<in>{0}. g q when 0 = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "have \"(\\<Sum>l. f l * \\<dots> l) = (\\<Sum>l\\<in>{0}. f l * \\<dots> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q)) =\n    (\\<Sum>l\\<in>{0}. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q))", "by (intro ext Sum_any.expand_superset) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q)) =\n  (\\<Sum>l\\<in>{0}. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "finally"], ["proof (chain)\npicking this:\n  prod_fun f g 0 =\n  (\\<Sum>l\\<in>{0}. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q))", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_fun f g 0 =\n  (\\<Sum>l\\<in>{0}. f l * (\\<Sum>q\\<in>{0}. g q when 0 = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g 0 = f 0 * g 0", "by simp"], ["proof (state)\nthis:\n  prod_fun f g 0 = f 0 * g 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_coeff_times_0: \"coeff (p * q) 0 = coeff p 0 * coeff q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p * q) 0 = MPoly_Type.coeff p 0 * MPoly_Type.coeff q 0", "by (simp add: coeff_mpoly_times prod_fun_nat_0)"], ["", "lemma mpoly_coeff_prod_0: \"coeff (\\<Prod>x\\<in>A. f x) 0 = (\\<Prod>x\\<in>A. coeff (f x) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (prod f A) 0 =\n    (\\<Prod>x\\<in>A. MPoly_Type.coeff (f x) 0)", "by (induction A rule: infinite_finite_induct) (auto simp: mpoly_coeff_times_0 mpoly_coeff_1)"], ["", "lemma mpoly_coeff_power_0: \"coeff (p ^ n) 0 = coeff p 0 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p ^ n) 0 = MPoly_Type.coeff p 0 ^ n", "by (induction n) (auto simp: mpoly_coeff_times_0 mpoly_coeff_1)"], ["", "lemma prod_fun_max:\n  fixes f g :: \"'a::{linorder, ordered_cancel_comm_monoid_add} \\<Rightarrow> 'b::semiring_0\"\n  assumes zero: \"\\<And>m. m > a \\<Longrightarrow> f m = 0\" \"\\<And>m. m > b \\<Longrightarrow> g m = 0\"\n  assumes fin: \"finite {m. f m \\<noteq> 0}\" \"finite {m. g m \\<noteq> 0}\"\n  shows   \"prod_fun f g (a + b) = f a * g b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "note fin' = finite_subset[OF _ fin(1)] finite_subset[OF _ fin(2)]"], ["proof (state)\nthis:\n  ?A \\<subseteq> {m. f m \\<noteq> (0::'b)} \\<Longrightarrow> finite ?A\n  ?A \\<subseteq> {m. g m \\<noteq> (0::'b)} \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "have \"prod_fun f g (a + b) = (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) =\n    (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q))", "by (simp add: prod_fun_def Sum_any_right_distrib)"], ["proof (state)\nthis:\n  prod_fun f g (a + b) = (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "also"], ["proof (state)\nthis:\n  prod_fun f g (a + b) = (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "have \"\\<dots> = (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q)) =\n    (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q)", "by (subst Sum_any_right_distrib) (auto intro!: Sum_any.cong fin'(2) simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "{"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when a + b = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "fix l q"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "assume lq: \"a + b = l + q\" \"(a, b) \\<noteq> (l, q)\" and nz: \"f l * g q \\<noteq> 0\""], ["proof (state)\nthis:\n  a + b = l + q\n  (a, b) \\<noteq> (l, q)\n  f l * g q \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "from nz and zero"], ["proof (chain)\npicking this:\n  f l * g q \\<noteq> (0::'b)\n  a < ?m \\<Longrightarrow> f ?m = (0::'b)\n  b < ?m \\<Longrightarrow> g ?m = (0::'b)", "have \"l \\<le> a\" \"q \\<le> b\""], ["proof (prove)\nusing this:\n  f l * g q \\<noteq> (0::'b)\n  a < ?m \\<Longrightarrow> f ?m = (0::'b)\n  b < ?m \\<Longrightarrow> g ?m = (0::'b)\n\ngoal (1 subgoal):\n 1. l \\<le> a &&& q \\<le> b", "by (auto intro: leI)"], ["proof (state)\nthis:\n  l \\<le> a\n  q \\<le> b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "moreover"], ["proof (state)\nthis:\n  l \\<le> a\n  q \\<le> b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "from this and lq(2)"], ["proof (chain)\npicking this:\n  l \\<le> a\n  q \\<le> b\n  (a, b) \\<noteq> (l, q)", "have \"l < a \\<or> q < b\""], ["proof (prove)\nusing this:\n  l \\<le> a\n  q \\<le> b\n  (a, b) \\<noteq> (l, q)\n\ngoal (1 subgoal):\n 1. l < a \\<or> q < b", "by auto"], ["proof (state)\nthis:\n  l < a \\<or> q < b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "ultimately"], ["proof (chain)\npicking this:\n  l \\<le> a\n  q \\<le> b\n  l < a \\<or> q < b", "have \"l + q < a + b\""], ["proof (prove)\nusing this:\n  l \\<le> a\n  q \\<le> b\n  l < a \\<or> q < b\n\ngoal (1 subgoal):\n 1. l + q < a + b", "by (auto intro: add_less_le_mono add_le_less_mono)"], ["proof (state)\nthis:\n  l + q < a + b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "with lq(1)"], ["proof (chain)\npicking this:\n  a + b = l + q\n  l + q < a + b", "have False"], ["proof (prove)\nusing this:\n  a + b = l + q\n  l + q < a + b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a + b = ?l2 + ?q2; (a, b) \\<noteq> (?l2, ?q2);\n   f ?l2 * g ?q2 \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "hence \"(\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q) = (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a + b = ?l2 + ?q2; (a, b) \\<noteq> (?l2, ?q2);\n   f ?l2 * g ?q2 \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q) =\n    (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q))", "by (intro Sum_any.cong refl) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when a + b = l + q) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "have \"\\<dots> = (\\<Sum>(l,q). f l * g q when (a, b) = (l, q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q)) =\n    (\\<Sum>(l, q). f l * g q when (a, b) = (l, q))", "by (intro Sum_any.cartesian_product[of \"{(a, b)}\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q)) =\n  (\\<Sum>(l, q). f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when (a, b) = (l, q)) =\n  (\\<Sum>(l, q). f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "have \"\\<dots> = (\\<Sum>(l,q)\\<in>{(a,b)}. f l * g q when (a, b) = (l, q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(l, q). f l * g q when (a, b) = (l, q)) =\n    (\\<Sum>(l, q)\\<in>{(a, b)}. f l * g q when (a, b) = (l, q))", "by (intro Sum_any.expand_superset) auto"], ["proof (state)\nthis:\n  (\\<Sum>(l, q). f l * g q when (a, b) = (l, q)) =\n  (\\<Sum>(l, q)\\<in>{(a, b)}. f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "also"], ["proof (state)\nthis:\n  (\\<Sum>(l, q). f l * g q when (a, b) = (l, q)) =\n  (\\<Sum>(l, q)\\<in>{(a, b)}. f l * g q when (a, b) = (l, q))\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "have \"\\<dots> = f a * g b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(l, q)\\<in>{(a, b)}. f l * g q when (a, b) = (l, q)) = f a * g b", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>(l, q)\\<in>{(a, b)}. f l * g q when (a, b) = (l, q)) = f a * g b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "finally"], ["proof (chain)\npicking this:\n  prod_fun f g (a + b) = f a * g b", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_fun f g (a + b) = f a * g b\n\ngoal (1 subgoal):\n 1. prod_fun f g (a + b) = f a * g b", "."], ["proof (state)\nthis:\n  prod_fun f g (a + b) = f a * g b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_fun_gt_max_eq_zero:\n  fixes f g :: \"'a::{linorder, ordered_cancel_comm_monoid_add} \\<Rightarrow> 'b::semiring_0\"\n  assumes \"m > a + b\"\n  assumes zero: \"\\<And>m. m > a \\<Longrightarrow> f m = 0\" \"\\<And>m. m > b \\<Longrightarrow> g m = 0\"\n  assumes fin: \"finite {m. f m \\<noteq> 0}\" \"finite {m. g m \\<noteq> 0}\"\n  shows   \"prod_fun f g m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "note fin' = finite_subset[OF _ fin(1)] finite_subset[OF _ fin(2)]"], ["proof (state)\nthis:\n  ?A \\<subseteq> {m. f m \\<noteq> (0::'b)} \\<Longrightarrow> finite ?A\n  ?A \\<subseteq> {m. g m \\<noteq> (0::'b)} \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "have \"prod_fun f g m = (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun f g m = (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q))", "by (simp add: prod_fun_def Sum_any_right_distrib)"], ["proof (state)\nthis:\n  prod_fun f g m = (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "also"], ["proof (state)\nthis:\n  prod_fun f g m = (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q))\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "have \"\\<dots> = (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q)) =\n    (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q)", "by (subst Sum_any_right_distrib) (auto intro!: Sum_any.cong fin'(2) simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "{"], ["proof (state)\nthis:\n  (\\<Sum>l. f l * (\\<Sum>q. g q when m = l + q)) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "fix l q"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "assume lq: \"m = l + q\" and nz: \"f l * g q \\<noteq> 0\""], ["proof (state)\nthis:\n  m = l + q\n  f l * g q \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "from nz and zero"], ["proof (chain)\npicking this:\n  f l * g q \\<noteq> (0::'b)\n  a < ?m \\<Longrightarrow> f ?m = (0::'b)\n  b < ?m \\<Longrightarrow> g ?m = (0::'b)", "have \"l \\<le> a\" \"q \\<le> b\""], ["proof (prove)\nusing this:\n  f l * g q \\<noteq> (0::'b)\n  a < ?m \\<Longrightarrow> f ?m = (0::'b)\n  b < ?m \\<Longrightarrow> g ?m = (0::'b)\n\ngoal (1 subgoal):\n 1. l \\<le> a &&& q \\<le> b", "by (auto intro: leI)"], ["proof (state)\nthis:\n  l \\<le> a\n  q \\<le> b\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "hence \"l + q \\<le> a + b\""], ["proof (prove)\nusing this:\n  l \\<le> a\n  q \\<le> b\n\ngoal (1 subgoal):\n 1. l + q \\<le> a + b", "by (intro add_mono)"], ["proof (state)\nthis:\n  l + q \\<le> a + b\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "also"], ["proof (state)\nthis:\n  l + q \\<le> a + b\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "have \"\\<dots> < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b < m", "by fact"], ["proof (state)\nthis:\n  a + b < m\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "finally"], ["proof (chain)\npicking this:\n  l + q < m", "have \"l + q < m\""], ["proof (prove)\nusing this:\n  l + q < m\n\ngoal (1 subgoal):\n 1. l + q < m", "."], ["proof (state)\nthis:\n  l + q < m\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>m = ?l2 + ?q2; f ?l2 * g ?q2 \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> ?l2 + ?q2 < m\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "hence \"(\\<Sum>l. \\<Sum>q. f l * g q when m = l + q) = (\\<Sum>l. \\<Sum>q. f l * g q when False)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m = ?l2 + ?q2; f ?l2 * g ?q2 \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> ?l2 + ?q2 < m\n\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q) =\n    (\\<Sum>l. \\<Sum>q. f l * g q when False)", "by (intro Sum_any.cong refl) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when False)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "also"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when m = l + q) =\n  (\\<Sum>l. \\<Sum>q. f l * g q when False)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. \\<Sum>q. f l * g q when False) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>l. \\<Sum>q. f l * g q when False) = (0::'b)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "finally"], ["proof (chain)\npicking this:\n  prod_fun f g m = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_fun f g m = (0::'b)\n\ngoal (1 subgoal):\n 1. prod_fun f g m = (0::'b)", "."], ["proof (state)\nthis:\n  prod_fun f g m = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Restricting a monomial to a subset of variables\\<close>"], ["", "lift_definition restrictpm :: \"'a set \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b :: zero) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)\" is\n  \"\\<lambda>A f x. if x \\<in> A then f x else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set fun.\n       finite {x. fun x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite {x. (if x \\<in> set then fun x else (0::'b)) \\<noteq> (0::'b)}", "by (erule finite_subset[rotated]) auto"], ["", "lemma lookup_restrictpm: \"lookup (restrictpm A m) x = (if x \\<in> A then lookup m x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (restrictpm A m) x = (if x \\<in> A then lookup m x else (0::'a))", "by transfer auto"], ["", "lemma lookup_restrictpm_in [simp]: \"x \\<in> A \\<Longrightarrow> lookup (restrictpm A m) x = lookup m x\"\n  and lookup_restrict_pm_not_in [simp]: \"x \\<notin> A \\<Longrightarrow> lookup (restrictpm A m) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> A \\<Longrightarrow> lookup (restrictpm A m) x = lookup m x) &&&\n    (x \\<notin> A \\<Longrightarrow> lookup (restrictpm A m) x = (0::'b))", "by (simp_all add: lookup_restrictpm)"], ["", "lemma keys_restrictpm [simp]: \"keys (restrictpm A m) = keys m \\<inter> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (restrictpm A m) = keys m \\<inter> A", "by transfer auto"], ["", "lemma restrictpm_add: \"restrictpm X (m1 + m2) = restrictpm X m1 + restrictpm X m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm X (m1 + m2) = restrictpm X m1 + restrictpm X m2", "by transfer auto"], ["", "lemma restrictpm_id [simp]: \"keys m \\<subseteq> X \\<Longrightarrow> restrictpm X m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys m \\<subseteq> X \\<Longrightarrow> restrictpm X m = m", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma restrictpm_orthogonal [simp]: \"keys m \\<subseteq> -X \\<Longrightarrow> restrictpm X m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys m \\<subseteq> - X \\<Longrightarrow> restrictpm X m = 0", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma restrictpm_add_disjoint:\n  \"X \\<inter> Y = {} \\<Longrightarrow> restrictpm X m + restrictpm Y m = restrictpm (X \\<union> Y) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> Y = {} \\<Longrightarrow>\n    restrictpm X m + restrictpm Y m = restrictpm (X \\<union> Y) m", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma restrictpm_add_complements:\n  \"restrictpm X m + restrictpm (-X) m = m\" \"restrictpm (-X) m + restrictpm X m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm X m + restrictpm (- X) m = m &&&\n    restrictpm (- X) m + restrictpm X m = m", "by (subst restrictpm_add_disjoint; force)+"], ["", "subsection \\<open>Mapping over a polynomial\\<close>"], ["", "lift_definition map_mpoly :: \"('a :: zero \\<Rightarrow> 'b :: zero) \\<Rightarrow> 'a mpoly \\<Rightarrow> 'b mpoly\" is\n  \"\\<lambda>(f :: 'a \\<Rightarrow> 'b) (p :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a). Poly_Mapping.map f p\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition mapm_mpoly :: \"((nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a :: zero \\<Rightarrow> 'b :: zero) \\<Rightarrow> 'a mpoly \\<Rightarrow> 'b mpoly\" is\n  \"\\<lambda>(f :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> 'a \\<Rightarrow> 'b) (p :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a).\n     Poly_Mapping.mapp f p\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma poly_mapping_map_conv_mapp: \"Poly_Mapping.map f = Poly_Mapping.mapp (\\<lambda>_. f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly_Mapping.map f = Poly_Mapping.mapp (\\<lambda>_. f)", "by (auto simp: Poly_Mapping.mapp_def Poly_Mapping.map_def map_fun_def\n                 o_def fun_eq_iff when_def in_keys_iff cong: if_cong)"], ["", "lemma map_mpoly_conv_mapm_mpoly: \"map_mpoly f = mapm_mpoly (\\<lambda>_. f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mpoly f = mapm_mpoly (\\<lambda>_. f)", "by transfer' (auto simp: poly_mapping_map_conv_mapp)"], ["", "lemma map_mpoly_comp: \"f 0 = 0 \\<Longrightarrow> map_mpoly f (map_mpoly g p) = map_mpoly (f \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow>\n    map_mpoly f (map_mpoly g p) = map_mpoly (f \\<circ> g) p", "by (transfer', transfer') (auto simp: when_def fun_eq_iff)"], ["", "lemma mapp_mapp:\n  \"(\\<And>x. f x 0 = 0) \\<Longrightarrow> Poly_Mapping.mapp f (Poly_Mapping.mapp g m) =\n                          Poly_Mapping.mapp (\\<lambda>x y. f x (g x y)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x (0::'c) = (0::'b)) \\<Longrightarrow>\n    Poly_Mapping.mapp f (Poly_Mapping.mapp g m) =\n    Poly_Mapping.mapp (\\<lambda>x y. f x (g x y)) m", "by transfer' (auto simp: fun_eq_iff lookup_mapp in_keys_iff)"], ["", "lemma mapm_mpoly_comp:\n  \"(\\<And>x. f x 0 = 0) \\<Longrightarrow> mapm_mpoly f (mapm_mpoly g p) = mapm_mpoly (\\<lambda>m c. f m (g m c)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x (0::'b) = (0::'a)) \\<Longrightarrow>\n    mapm_mpoly f (mapm_mpoly g p) = mapm_mpoly (\\<lambda>m c. f m (g m c)) p", "by transfer' (simp add: mapp_mapp)"], ["", "lemma coeff_map_mpoly:\n  \"coeff (map_mpoly f p) m = (if coeff p m = 0 then 0 else f (coeff p m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (map_mpoly f p) m =\n    (if MPoly_Type.coeff p m = (0::'b) then 0::'a\n     else f (MPoly_Type.coeff p m))", "by (transfer, transfer) auto"], ["", "lemma coeff_map_mpoly' [simp]: \"f 0 = 0 \\<Longrightarrow> coeff (map_mpoly f p) m = f (coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'b) = (0::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (map_mpoly f p) m = f (MPoly_Type.coeff p m)", "by (subst coeff_map_mpoly) auto"], ["", "lemma coeff_mapm_mpoly: \"coeff (mapm_mpoly f p) m = (if coeff p m = 0 then 0 else f m (coeff p m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mapm_mpoly f p) m =\n    (if MPoly_Type.coeff p m = (0::'b) then 0::'a\n     else f m (MPoly_Type.coeff p m))", "by (transfer, transfer') (auto simp: in_keys_iff)"], ["", "lemma coeff_mapm_mpoly' [simp]: \"(\\<And>m. f m 0 = 0) \\<Longrightarrow> coeff (mapm_mpoly f p) m = f m (coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. f m (0::'b) = (0::'a)) \\<Longrightarrow>\n    MPoly_Type.coeff (mapm_mpoly f p) m = f m (MPoly_Type.coeff p m)", "by (subst coeff_mapm_mpoly) auto"], ["", "lemma vars_map_mpoly_subset: \"vars (map_mpoly f p) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (map_mpoly f p) \\<subseteq> vars p", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (map_mpoly f p)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "by (transfer', transfer') (auto simp: map_mpoly.rep_eq)"], ["", "lemma coeff_sum [simp]: \"coeff (sum f A) m = (\\<Sum>x\\<in>A. coeff (f x) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sum f A) m = (\\<Sum>x\\<in>A. MPoly_Type.coeff (f x) m)", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma coeff_Sum_any: \"finite {x. f x \\<noteq> 0} \\<Longrightarrow> coeff (Sum_any f) m = Sum_any (\\<lambda>x. coeff (f x) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. f x \\<noteq> 0} \\<Longrightarrow>\n    MPoly_Type.coeff (Sum_any f) m = (\\<Sum>x. MPoly_Type.coeff (f x) m)", "by (auto simp add: Sum_any.expand_set intro!: sum.mono_neutral_right)"], ["", "lemma Sum_any_zeroI: \"(\\<And>x. f x = 0) \\<Longrightarrow> Sum_any f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x = (0::'b)) \\<Longrightarrow> Sum_any f = (0::'b)", "by (auto simp: Sum_any.expand_set)"], ["", "lemma insertion_Prod_any:\n  \"finite {x. g x \\<noteq> 1} \\<Longrightarrow> insertion f (Prod_any g) = Prod_any (\\<lambda>x. insertion f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. g x \\<noteq> 1} \\<Longrightarrow>\n    insertion f (Prod_any g) = (\\<Prod>x. insertion f (g x))", "by (auto simp: Prod_any.expand_set insertion_prod intro!: prod.mono_neutral_right)"], ["", "lemma insertion_insertion:\n  \"insertion g (insertion k p) =\n     insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "have \"insertion g (insertion k p) =\n          (\\<Sum>x. insertion g (coeff p x) * insertion g (\\<Prod>i. k i ^ lookup x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              insertion g (\\<Prod>i. k i ^ lookup x i))", "unfolding insertion_altdef[of k p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g\n     (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. k i ^ lookup m i)) =\n    (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              insertion g (\\<Prod>i. k i ^ lookup x i))", "by (subst insertion_Sum_any)\n       (auto intro: finite_subset[OF _ finite_coeff_support[of p]] simp: insertion_mult)"], ["proof (state)\nthis:\n  insertion g (insertion k p) =\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            insertion g (\\<Prod>i. k i ^ lookup x i))\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "also"], ["proof (state)\nthis:\n  insertion g (insertion k p) =\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            insertion g (\\<Prod>i. k i ^ lookup x i))\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "have \"\\<dots> = (\\<Sum>x. insertion g (coeff p x) * (\\<Prod>i. insertion g (k i) ^ lookup x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              insertion g (\\<Prod>i. k i ^ lookup x i)) =\n    (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              (\\<Prod>i. insertion g (k i) ^ lookup x i))", "proof (intro Sum_any.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       insertion g (MPoly_Type.coeff p a) *\n       insertion g (\\<Prod>i. k i ^ lookup a i) =\n       insertion g (MPoly_Type.coeff p a) *\n       (\\<Prod>i. insertion g (k i) ^ lookup a i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       insertion g (MPoly_Type.coeff p a) *\n       insertion g (\\<Prod>i. k i ^ lookup a i) =\n       insertion g (MPoly_Type.coeff p a) *\n       (\\<Prod>i. insertion g (k i) ^ lookup a i)", "show \"insertion g (coeff p x) * insertion g (\\<Prod>i. k i ^ lookup x i) =\n                  insertion g (coeff p x) * (\\<Prod>i. insertion g (k i) ^ lookup x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g (MPoly_Type.coeff p x) *\n    insertion g (\\<Prod>i. k i ^ lookup x i) =\n    insertion g (MPoly_Type.coeff p x) *\n    (\\<Prod>i. insertion g (k i) ^ lookup x i)", "by (subst insertion_Prod_any)\n         (auto simp: insertion_power intro!: finite_subset[OF _ finite_lookup[of x]] Nat.gr0I)"], ["proof (state)\nthis:\n  insertion g (MPoly_Type.coeff p x) *\n  insertion g (\\<Prod>i. k i ^ lookup x i) =\n  insertion g (MPoly_Type.coeff p x) *\n  (\\<Prod>i. insertion g (k i) ^ lookup x i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            insertion g (\\<Prod>i. k i ^ lookup x i)) =\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            (\\<Prod>i. insertion g (k i) ^ lookup x i))\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            insertion g (\\<Prod>i. k i ^ lookup x i)) =\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            (\\<Prod>i. insertion g (k i) ^ lookup x i))\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "have \"\\<dots> = insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              (\\<Prod>i. insertion g (k i) ^ lookup x i)) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "unfolding insertion_altdef[of _ \"map_mpoly f p\" for f]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n              (\\<Prod>i. insertion g (k i) ^ lookup x i)) =\n    (\\<Sum>m. MPoly_Type.coeff (map_mpoly (insertion g) p) m *\n              (\\<Prod>i. insertion g (k i) ^ lookup m i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x. insertion g (MPoly_Type.coeff p x) *\n            (\\<Prod>i. insertion g (k i) ^ lookup x i)) =\n  insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "finally"], ["proof (chain)\npicking this:\n  insertion g (insertion k p) =\n  insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion g (insertion k p) =\n  insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\n\ngoal (1 subgoal):\n 1. insertion g (insertion k p) =\n    insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)", "."], ["proof (state)\nthis:\n  insertion g (insertion k p) =\n  insertion (\\<lambda>x. insertion g (k x)) (map_mpoly (insertion g) p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_substitute_linear:\n  \"insertion (\\<lambda>i. c i * f i) p =\n     insertion f (mapm_mpoly (\\<lambda>m d. Prod_any (\\<lambda>i. c i ^ lookup m i) * d) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. c i * f i) p =\n    insertion f\n     (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p)", "unfolding insertion_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. (c i * f i) ^ lookup m i)) =\n    (\\<Sum>m. MPoly_Type.coeff\n               (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p)\n               m *\n              (\\<Prod>i. f i ^ lookup m i))", "proof (intro Sum_any.cong, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       MPoly_Type.coeff p a * (\\<Prod>i. (c i * f i) ^ lookup a i) =\n       MPoly_Type.coeff\n        (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) a *\n       (\\<Prod>i. f i ^ lookup a i)", "case (1 m)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>a.\n       MPoly_Type.coeff p a * (\\<Prod>i. (c i * f i) ^ lookup a i) =\n       MPoly_Type.coeff\n        (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) a *\n       (\\<Prod>i. f i ^ lookup a i)", "have \"coeff (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m * (\\<Prod>i. f i ^ lookup m i) =\n          MPoly_Type.coeff p m * ((\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n    (\\<Prod>i. f i ^ lookup m i) =\n    MPoly_Type.coeff p m *\n    ((\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i))", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n  (\\<Prod>i. f i ^ lookup m i) =\n  MPoly_Type.coeff p m *\n  ((\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       MPoly_Type.coeff p a * (\\<Prod>i. (c i * f i) ^ lookup a i) =\n       MPoly_Type.coeff\n        (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) a *\n       (\\<Prod>i. f i ^ lookup a i)", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n  (\\<Prod>i. f i ^ lookup m i) =\n  MPoly_Type.coeff p m *\n  ((\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       MPoly_Type.coeff p a * (\\<Prod>i. (c i * f i) ^ lookup a i) =\n       MPoly_Type.coeff\n        (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) a *\n       (\\<Prod>i. f i ^ lookup a i)", "have \"(\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i) =\n               (\\<Prod>i. (c i * f i) ^ lookup m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i) =\n    (\\<Prod>i. (c i * f i) ^ lookup m i)", "by (subst Prod_any.distrib [symmetric])\n       (auto simp: power_mult_distrib intro!: finite_subset[OF _ finite_lookup[of m]] Nat.gr0I)"], ["proof (state)\nthis:\n  (\\<Prod>i. c i ^ lookup m i) * (\\<Prod>i. f i ^ lookup m i) =\n  (\\<Prod>i. (c i * f i) ^ lookup m i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       MPoly_Type.coeff p a * (\\<Prod>i. (c i * f i) ^ lookup a i) =\n       MPoly_Type.coeff\n        (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) a *\n       (\\<Prod>i. f i ^ lookup a i)", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff\n   (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n  (\\<Prod>i. f i ^ lookup m i) =\n  MPoly_Type.coeff p m * (\\<Prod>i. (c i * f i) ^ lookup m i)", "show ?case"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n  (\\<Prod>i. f i ^ lookup m i) =\n  MPoly_Type.coeff p m * (\\<Prod>i. (c i * f i) ^ lookup m i)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m * (\\<Prod>i. (c i * f i) ^ lookup m i) =\n    MPoly_Type.coeff\n     (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n    (\\<Prod>i. f i ^ lookup m i)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff p m * (\\<Prod>i. (c i * f i) ^ lookup m i) =\n  MPoly_Type.coeff\n   (mapm_mpoly (\\<lambda>m. (*) (\\<Prod>i. c i ^ lookup m i)) p) m *\n  (\\<Prod>i. f i ^ lookup m i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_mapm_mpoly_subset: \"vars (mapm_mpoly f p) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (mapm_mpoly f p) \\<subseteq> vars p", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (mapm_mpoly f p)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "using keys_mapp_subset[of f]"], ["proof (prove)\nusing this:\n  keys (Poly_Mapping.mapp f ?p) \\<subseteq> keys ?p\n\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (mapm_mpoly f p)))\n    \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "by (auto simp: mapm_mpoly.rep_eq)"], ["", "lemma map_mpoly_cong:\n  assumes \"\\<And>m. f (coeff p m) = g (coeff p m)\" \"p = q\"\n  shows   \"map_mpoly f p = map_mpoly g q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mpoly f p = map_mpoly g q", "using assms"], ["proof (prove)\nusing this:\n  f (MPoly_Type.coeff p ?m) = g (MPoly_Type.coeff p ?m)\n  p = q\n\ngoal (1 subgoal):\n 1. map_mpoly f p = map_mpoly g q", "by (intro mpoly_eqI) (auto simp: coeff_map_mpoly)"], ["", "subsection \\<open>The leading monomial and leading coefficient\\<close>"], ["", "text \\<open>\n  The leading monomial of a multivariate polynomial is the one with the largest monomial\n  w.\\,r.\\,t.\\ the monomial ordering induced by the standard variable ordering. The\n  leading coefficient is the coefficient of the leading monomial.\n\n  As a convention, the leading monomial of the zero polynomial is defined to be the same as\n  that of any non-constant zero polynomial, i.\\,e.\\ the monomial $X_1^0 \\ldots X_n^0$.\n\\<close>"], ["", "lift_definition lead_monom :: \"'a :: zero mpoly \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat)\" is\n  \"\\<lambda>f :: (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a. Max (insert 0 (keys f))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lead_monom_geI [intro]:\n  assumes \"coeff p m \\<noteq> 0\"\n  shows   \"m \\<le> lead_monom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> lead_monom p", "using assms"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom p", "by (auto simp: lead_monom_def coeff_def in_keys_iff)"], ["", "lemma coeff_gt_lead_monom_zero [simp]:\n  assumes \"m > lead_monom p\"\n  shows   \"coeff p m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m = (0::'a)", "using lead_monom_geI[of p m] assms"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> (0::'a) \\<Longrightarrow>\n  m \\<le> lead_monom p\n  lead_monom p < m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m = (0::'a)", "by force"], ["", "lemma lead_monom_nonzero_eq:\n  assumes \"p \\<noteq> 0\"\n  shows   \"lead_monom p = Max (keys (mapping_of p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom p = Max (keys (mapping_of p))", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_monom p = Max (keys (mapping_of p))", "by transfer (simp add: max_def)"], ["", "lemma lead_monom_0 [simp]: \"lead_monom 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom 0 = 0", "by (simp add: lead_monom_def zero_mpoly.rep_eq)"], ["", "lemma lead_monom_1 [simp]: \"lead_monom 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom 1 = 0", "by (simp add: lead_monom_def one_mpoly.rep_eq)"], ["", "lemma lead_monom_Const [simp]: \"lead_monom (Const c) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (Const c) = 0", "by (simp add: lead_monom_def Const.rep_eq Const\\<^sub>0_def)"], ["", "lemma lead_monom_uminus [simp]: \"lead_monom (-p) = lead_monom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (- p) = lead_monom p", "by (simp add: lead_monom_def uminus_mpoly.rep_eq)"], ["", "lemma keys_mult_const [simp]:\n  fixes c :: \"'a :: {semiring_0, semiring_no_zero_divisors}\"\n  assumes \"c \\<noteq> 0\"\n  shows \"keys (Poly_Mapping.map ((*) c) p) = keys p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (Poly_Mapping.map ((*) c) p) = keys p", "using assms"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys (Poly_Mapping.map ((*) c) p) = keys p", "by transfer auto"], ["", "lemma lead_monom_eq_0_iff: \"lead_monom p = 0 \\<longleftrightarrow> vars p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lead_monom p = 0) = (vars p = {})", "unfolding vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lead_monom p = 0) = (\\<Union> (keys ` keys (mapping_of p)) = {})", "by transfer' (auto simp: Max_eq_iff)"], ["", "lemma lead_monom_monom: \"lead_monom (monom m c) = (if c = 0 then 0 else m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.monom m c) = (if c = (0::'a) then 0 else m)", "by (auto simp add: lead_monom_def monom.rep_eq Const\\<^sub>0_def max_def )"], ["", "lemma lead_monom_monom' [simp]: \"c \\<noteq> 0 \\<Longrightarrow> lead_monom (monom m c) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    lead_monom (MPoly_Type.monom m c) = m", "by (simp add: lead_monom_monom)"], ["", "lemma lead_monom_numeral [simp]: \"lead_monom (numeral n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (numeral n) = 0", "unfolding monom_numeral[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.monom 0 (numeral n)) = 0", "by (subst lead_monom_monom) auto"], ["", "lemma lead_monom_add: \"lead_monom (p + q) \\<le> max (lead_monom p) (lead_monom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p + q) \\<le> max (lead_monom p) (lead_monom q)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       Max (insert 0 (keys (p + q)))\n       \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "fix p q :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       Max (insert 0 (keys (p + q)))\n       \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "show \"Max (insert 0 (keys (p + q))) \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert 0 (keys (p + q)))\n    \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p + q)))\n 2. insert 0 (keys (p + q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p + q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p + q)))\n 2. insert 0 (keys (p + q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p + q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "assume m: \"m \\<in> insert 0 (keys (p + q))\""], ["proof (state)\nthis:\n  m \\<in> insert 0 (keys (p + q))\n\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p + q)))\n 2. insert 0 (keys (p + q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p + q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "thus \"m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\""], ["proof (prove)\nusing this:\n  m \\<in> insert 0 (keys (p + q))\n\ngoal (1 subgoal):\n 1. m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p + q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "assume \"m \\<in> keys (p + q)\""], ["proof (state)\nthis:\n  m \\<in> keys (p + q)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p + q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "with keys_add[of p q]"], ["proof (chain)\npicking this:\n  keys p \\<inter> keys q = {} \\<Longrightarrow>\n  keys p \\<union> keys q = keys (p + q)\n  m \\<in> keys (p + q)", "have \"m \\<in> keys p \\<or> m \\<in> keys q\""], ["proof (prove)\nusing this:\n  keys p \\<inter> keys q = {} \\<Longrightarrow>\n  keys p \\<union> keys q = keys (p + q)\n  m \\<in> keys (p + q)\n\ngoal (1 subgoal):\n 1. m \\<in> keys p \\<or> m \\<in> keys q", "by (auto simp: in_keys_iff plus_poly_mapping.rep_eq)"], ["proof (state)\nthis:\n  m \\<in> keys p \\<or> m \\<in> keys q\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p + q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> keys p \\<or> m \\<in> keys q\n\ngoal (1 subgoal):\n 1. m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "by (auto simp: le_max_iff_disj)"], ["proof (state)\nthis:\n  m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "qed auto"], ["proof (state)\nthis:\n  m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal (2 subgoals):\n 1. finite (insert 0 (keys (p + q)))\n 2. insert 0 (keys (p + q)) \\<noteq> {}", "qed auto"], ["proof (state)\nthis:\n  Max (insert 0 (keys (p + q)))\n  \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_diff: \"lead_monom (p - q) \\<le> max (lead_monom p) (lead_monom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p - q) \\<le> max (lead_monom p) (lead_monom q)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       Max (insert 0 (keys (p - q)))\n       \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "fix p q :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       Max (insert 0 (keys (p - q)))\n       \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "show \"Max (insert 0 (keys (p - q))) \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert 0 (keys (p - q)))\n    \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "proof (rule Max.boundedI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p - q)))\n 2. insert 0 (keys (p - q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p - q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p - q)))\n 2. insert 0 (keys (p - q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p - q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "assume m: \"m \\<in> insert 0 (keys (p - q))\""], ["proof (state)\nthis:\n  m \\<in> insert 0 (keys (p - q))\n\ngoal (3 subgoals):\n 1. finite (insert 0 (keys (p - q)))\n 2. insert 0 (keys (p - q)) \\<noteq> {}\n 3. \\<And>a.\n       a \\<in> insert 0 (keys (p - q)) \\<Longrightarrow>\n       a \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "thus \"m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\""], ["proof (prove)\nusing this:\n  m \\<in> insert 0 (keys (p - q))\n\ngoal (1 subgoal):\n 1. m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p - q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "assume \"m \\<in> keys (p - q)\""], ["proof (state)\nthis:\n  m \\<in> keys (p - q)\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p - q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "with keys_diff_subset[of p q]"], ["proof (chain)\npicking this:\n  keys (p - q) \\<subseteq> keys p \\<union> keys q\n  m \\<in> keys (p - q)", "have \"m \\<in> keys p \\<or> m \\<in> keys q\""], ["proof (prove)\nusing this:\n  keys (p - q) \\<subseteq> keys p \\<union> keys q\n  m \\<in> keys (p - q)\n\ngoal (1 subgoal):\n 1. m \\<in> keys p \\<or> m \\<in> keys q", "by auto"], ["proof (state)\nthis:\n  m \\<in> keys p \\<or> m \\<in> keys q\n\ngoal (2 subgoals):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n 2. m \\<in> keys (p - q) \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> keys p \\<or> m \\<in> keys q\n\ngoal (1 subgoal):\n 1. m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "by (auto simp: le_max_iff_disj)"], ["proof (state)\nthis:\n  m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal (1 subgoal):\n 1. m = 0 \\<Longrightarrow>\n    m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))", "qed auto"], ["proof (state)\nthis:\n  m \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal (2 subgoals):\n 1. finite (insert 0 (keys (p - q)))\n 2. insert 0 (keys (p - q)) \\<noteq> {}", "qed auto"], ["proof (state)\nthis:\n  Max (insert 0 (keys (p - q)))\n  \\<le> max (Max (insert 0 (keys p))) (Max (insert 0 (keys q)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition lead_coeff where \"lead_coeff p = coeff p (lead_monom p)\""], ["", "lemma vars_empty_iff: \"vars p = {} \\<longleftrightarrow> p = Const (lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vars p = {}) = (p = Const (Symmetric_Polynomials.lead_coeff p))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. vars p = {} \\<Longrightarrow>\n    p = Const (Symmetric_Polynomials.lead_coeff p)\n 2. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "assume \"vars p = {}\""], ["proof (state)\nthis:\n  vars p = {}\n\ngoal (2 subgoals):\n 1. vars p = {} \\<Longrightarrow>\n    p = Const (Symmetric_Polynomials.lead_coeff p)\n 2. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "hence [simp]: \"lead_monom p = 0\""], ["proof (prove)\nusing this:\n  vars p = {}\n\ngoal (1 subgoal):\n 1. lead_monom p = 0", "by (simp add: lead_monom_eq_0_iff)"], ["proof (state)\nthis:\n  lead_monom p = 0\n\ngoal (2 subgoals):\n 1. vars p = {} \\<Longrightarrow>\n    p = Const (Symmetric_Polynomials.lead_coeff p)\n 2. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "have [simp]: \"mon \\<noteq> 0 \\<longleftrightarrow> (mon > (0 :: nat \\<Rightarrow>\\<^sub>0 nat))\" for mon"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mon \\<noteq> 0) = (0 < mon)", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  (?mon \\<noteq> 0) = (0 < ?mon)\n\ngoal (2 subgoals):\n 1. vars p = {} \\<Longrightarrow>\n    p = Const (Symmetric_Polynomials.lead_coeff p)\n 2. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "thus \"p = Const (lead_coeff p)\""], ["proof (prove)\nusing this:\n  (?mon \\<noteq> 0) = (0 < ?mon)\n\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p)", "by (intro mpoly_eqI) (auto simp: mpoly_coeff_Const lead_coeff_def)"], ["proof (state)\nthis:\n  p = Const (Symmetric_Polynomials.lead_coeff p)\n\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "assume \"p = Const (lead_coeff p)\""], ["proof (state)\nthis:\n  p = Const (Symmetric_Polynomials.lead_coeff p)\n\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "also"], ["proof (state)\nthis:\n  p = Const (Symmetric_Polynomials.lead_coeff p)\n\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "have \"vars \\<dots> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Const (Symmetric_Polynomials.lead_coeff p)) = {}", "by simp"], ["proof (state)\nthis:\n  vars (Const (Symmetric_Polynomials.lead_coeff p)) = {}\n\ngoal (1 subgoal):\n 1. p = Const (Symmetric_Polynomials.lead_coeff p) \\<Longrightarrow>\n    vars p = {}", "finally"], ["proof (chain)\npicking this:\n  vars p = {}", "show \"vars p = {}\""], ["proof (prove)\nusing this:\n  vars p = {}\n\ngoal (1 subgoal):\n 1. vars p = {}", "."], ["proof (state)\nthis:\n  vars p = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_0 [simp]: \"lead_coeff 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff 0 = (0::'a)", "by (simp add: lead_coeff_def)"], ["", "lemma lead_coeff_1 [simp]: \"lead_coeff 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff 1 = (1::'a)", "by (simp add: lead_coeff_def mpoly_coeff_1)"], ["", "lemma lead_coeff_Const [simp]: \"lead_coeff (Const c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (Const c) = c", "by (simp add: lead_coeff_def mpoly_coeff_Const)"], ["", "lemma lead_coeff_monom [simp]: \"lead_coeff (monom p c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (MPoly_Type.monom p c) = c", "by (simp add: lead_coeff_def coeff_monom when_def lead_monom_monom)"], ["", "lemma lead_coeff_nonzero [simp]: \"p \\<noteq> 0 \\<Longrightarrow> lead_coeff p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)", "unfolding lead_coeff_def lead_monom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    MPoly_Type.coeff p\n     (map_fun mapping_of id (\\<lambda>f. Max (insert 0 (keys f)))\n       p) \\<noteq>\n    (0::'a)", "by (cases \"keys (mapping_of p) = {}\") (auto simp: coeff_def max_def)"], ["", "lemma\n  fixes c :: \"'a :: semiring_0\"\n  assumes \"c * lead_coeff p \\<noteq> 0\"\n  shows lead_monom_smult [simp]: \"lead_monom (smult c p) = lead_monom p\"\n    and lead_coeff_smult [simp]: \"lead_coeff (smult c p) = c * lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p &&&\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "from assms"], ["proof (chain)\npicking this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)", "have *: \"keys (mapping_of p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys (mapping_of p) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  keys (mapping_of p) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "from assms"], ["proof (chain)\npicking this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)", "have \"coeff (MPoly_Type.smult c p) (lead_monom p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.smult c p) (lead_monom p) \\<noteq> (0::'a)", "by (simp add: lead_coeff_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.smult c p) (lead_monom p) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "hence smult_nz: \"MPoly_Type.smult c p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (MPoly_Type.smult c p) (lead_monom p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.smult c p \\<noteq> 0", "by (auto simp del: coeff_smult)"], ["proof (state)\nthis:\n  MPoly_Type.smult c p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "with assms"], ["proof (chain)\npicking this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  MPoly_Type.smult c p \\<noteq> 0", "have **: \"keys (mapping_of (smult c p)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  MPoly_Type.smult c p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. keys (mapping_of (MPoly_Type.smult c p)) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  keys (mapping_of (MPoly_Type.smult c p)) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "have \"Max (keys (mapping_of (smult c p))) = Max (keys (mapping_of p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (keys (mapping_of (MPoly_Type.smult c p))) =\n    Max (keys (mapping_of p))", "proof (safe intro!: antisym Max.coboundedI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (keys (mapping_of p))\n 2. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n 3. finite (keys (mapping_of (MPoly_Type.smult c p)))\n 4. Max (keys (mapping_of p)) \\<in> keys (mapping_of (MPoly_Type.smult c p))", "have \"lookup (mapping_of p) (Max (keys (mapping_of p))) = lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (mapping_of p) (Max (keys (mapping_of p))) =\n    Symmetric_Polynomials.lead_coeff p", "using *"], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lookup (mapping_of p) (Max (keys (mapping_of p))) =\n    Symmetric_Polynomials.lead_coeff p", "by (simp add: lead_coeff_def lead_monom_def max_def coeff_def)"], ["proof (state)\nthis:\n  lookup (mapping_of p) (Max (keys (mapping_of p))) =\n  Symmetric_Polynomials.lead_coeff p\n\ngoal (4 subgoals):\n 1. finite (keys (mapping_of p))\n 2. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n 3. finite (keys (mapping_of (MPoly_Type.smult c p)))\n 4. Max (keys (mapping_of p)) \\<in> keys (mapping_of (MPoly_Type.smult c p))", "with assms"], ["proof (chain)\npicking this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  lookup (mapping_of p) (Max (keys (mapping_of p))) =\n  Symmetric_Polynomials.lead_coeff p", "show \"Max (keys (mapping_of p)) \\<in> keys (mapping_of (smult c p))\""], ["proof (prove)\nusing this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  lookup (mapping_of p) (Max (keys (mapping_of p))) =\n  Symmetric_Polynomials.lead_coeff p\n\ngoal (1 subgoal):\n 1. Max (keys (mapping_of p)) \\<in> keys (mapping_of (MPoly_Type.smult c p))", "using *"], ["proof (prove)\nusing this:\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  lookup (mapping_of p) (Max (keys (mapping_of p))) =\n  Symmetric_Polynomials.lead_coeff p\n  keys (mapping_of p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (keys (mapping_of p)) \\<in> keys (mapping_of (MPoly_Type.smult c p))", "by (auto simp: smult.rep_eq intro!: in_keys_mapI)"], ["proof (state)\nthis:\n  Max (keys (mapping_of p)) \\<in> keys (mapping_of (MPoly_Type.smult c p))\n\ngoal (3 subgoals):\n 1. finite (keys (mapping_of p))\n 2. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n 3. finite (keys (mapping_of (MPoly_Type.smult c p)))", "from smult_nz"], ["proof (chain)\npicking this:\n  MPoly_Type.smult c p \\<noteq> 0", "have \"lead_coeff (smult c p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  MPoly_Type.smult c p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) \\<noteq> (0::'a)", "by (intro lead_coeff_nonzero) auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. finite (keys (mapping_of p))\n 2. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n 3. finite (keys (mapping_of (MPoly_Type.smult c p)))", "hence \"coeff p (Max (keys (mapping_of (smult c p)))) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p\n     (Max (keys (mapping_of (MPoly_Type.smult c p)))) \\<noteq>\n    (0::'a)", "using assms * **"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) \\<noteq> (0::'a)\n  c * Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n  keys (mapping_of p) \\<noteq> {}\n  keys (mapping_of (MPoly_Type.smult c p)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p\n     (Max (keys (mapping_of (MPoly_Type.smult c p)))) \\<noteq>\n    (0::'a)", "by (auto simp: lead_coeff_def lead_monom_def max_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff p\n   (Max (keys (mapping_of (MPoly_Type.smult c p)))) \\<noteq>\n  (0::'a)\n\ngoal (3 subgoals):\n 1. finite (keys (mapping_of p))\n 2. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n 3. finite (keys (mapping_of (MPoly_Type.smult c p)))", "thus \"Max (keys (mapping_of (smult c p))) \\<in> keys (mapping_of p)\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p\n   (Max (keys (mapping_of (MPoly_Type.smult c p)))) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)", "by (auto simp: smult.rep_eq coeff_def in_keys_iff)"], ["proof (state)\nthis:\n  Max (keys (mapping_of (MPoly_Type.smult c p))) \\<in> keys (mapping_of p)\n\ngoal (2 subgoals):\n 1. finite (keys (mapping_of p))\n 2. finite (keys (mapping_of (MPoly_Type.smult c p)))", "qed auto"], ["proof (state)\nthis:\n  Max (keys (mapping_of (MPoly_Type.smult c p))) = Max (keys (mapping_of p))\n\ngoal (2 subgoals):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p\n 2. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "with * **"], ["proof (chain)\npicking this:\n  keys (mapping_of p) \\<noteq> {}\n  keys (mapping_of (MPoly_Type.smult c p)) \\<noteq> {}\n  Max (keys (mapping_of (MPoly_Type.smult c p))) = Max (keys (mapping_of p))", "show \"lead_monom (smult c p) = lead_monom p\""], ["proof (prove)\nusing this:\n  keys (mapping_of p) \\<noteq> {}\n  keys (mapping_of (MPoly_Type.smult c p)) \\<noteq> {}\n  Max (keys (mapping_of (MPoly_Type.smult c p))) = Max (keys (mapping_of p))\n\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.smult c p) = lead_monom p", "by (simp add: lead_monom_def max_def)"], ["proof (state)\nthis:\n  lead_monom (MPoly_Type.smult c p) = lead_monom p\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "thus \"lead_coeff (smult c p) = c * lead_coeff p\""], ["proof (prove)\nusing this:\n  lead_monom (MPoly_Type.smult c p) = lead_monom p\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n    c * Symmetric_Polynomials.lead_coeff p", "by (simp add: lead_coeff_def)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.smult c p) =\n  c * Symmetric_Polynomials.lead_coeff p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_mult_aux:\n  \"coeff (p * q) (lead_monom p + lead_monom q) = lead_coeff p * lead_coeff q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "proof (cases \"p = 0 \\<or> q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "case False"], ["proof (state)\nthis:\n  \\<not> (p = 0 \\<or> q = 0)\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "define a b where \"a = lead_monom p\" and \"b = lead_monom q\""], ["proof (state)\nthis:\n  a = lead_monom p\n  b = lead_monom q\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "have \"coeff (p * q) (a + b) = coeff p a * coeff q b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p * q) (a + b) =\n    MPoly_Type.coeff p a * MPoly_Type.coeff q b", "unfolding coeff_mpoly_times"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_fun (MPoly_Type.coeff p) (MPoly_Type.coeff q) (a + b) =\n    MPoly_Type.coeff p a * MPoly_Type.coeff q b", "by (rule prod_fun_max) (insert False, auto simp: a_def b_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (p * q) (a + b) =\n  MPoly_Type.coeff p a * MPoly_Type.coeff q b\n\ngoal (2 subgoals):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q\n 2. \\<not> (p = 0 \\<or> q = 0) \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (p * q) (a + b) =\n  MPoly_Type.coeff p a * MPoly_Type.coeff q b\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "by (simp add: a_def b_def lead_coeff_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n  Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q\n\ngoal (1 subgoal):\n 1. p = 0 \\<or> q = 0 \\<Longrightarrow>\n    MPoly_Type.coeff (p * q) (lead_monom p + lead_monom q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "qed auto"], ["", "lemma lead_monom_mult_le: \"lead_monom (p * q) \\<le> lead_monom p + lead_monom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p * q) \\<le> lead_monom p + lead_monom q", "proof (cases \"p * q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p * q = 0 \\<Longrightarrow>\n    lead_monom (p * q) \\<le> lead_monom p + lead_monom q\n 2. p * q \\<noteq> 0 \\<Longrightarrow>\n    lead_monom (p * q) \\<le> lead_monom p + lead_monom q", "case False"], ["proof (state)\nthis:\n  p * q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p * q = 0 \\<Longrightarrow>\n    lead_monom (p * q) \\<le> lead_monom p + lead_monom q\n 2. p * q \\<noteq> 0 \\<Longrightarrow>\n    lead_monom (p * q) \\<le> lead_monom p + lead_monom q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p * q) \\<le> lead_monom p + lead_monom q", "proof (intro leI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_monom p + lead_monom q < lead_monom (p * q) \\<Longrightarrow> False", "assume \"lead_monom p + lead_monom q < lead_monom (p * q)\""], ["proof (state)\nthis:\n  lead_monom p + lead_monom q < lead_monom (p * q)\n\ngoal (1 subgoal):\n 1. lead_monom p + lead_monom q < lead_monom (p * q) \\<Longrightarrow> False", "hence \"lead_coeff (p * q) = 0\""], ["proof (prove)\nusing this:\n  lead_monom p + lead_monom q < lead_monom (p * q)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (p * q) = (0::'a)", "unfolding lead_coeff_def coeff_mpoly_times"], ["proof (prove)\nusing this:\n  lead_monom p + lead_monom q < lead_monom (p * q)\n\ngoal (1 subgoal):\n 1. prod_fun (MPoly_Type.coeff p) (MPoly_Type.coeff q)\n     (lead_monom (p * q)) =\n    (0::'a)", "by (rule prod_fun_gt_max_eq_zero) auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (p * q) = (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom p + lead_monom q < lead_monom (p * q) \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  p * q \\<noteq> 0\n  Symmetric_Polynomials.lead_coeff (p * q) = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  p * q \\<noteq> 0\n  Symmetric_Polynomials.lead_coeff (p * q) = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lead_monom (p * q) \\<le> lead_monom p + lead_monom q\n\ngoal (1 subgoal):\n 1. p * q = 0 \\<Longrightarrow>\n    lead_monom (p * q) \\<le> lead_monom p + lead_monom q", "qed auto"], ["", "lemma lead_monom_mult:\n  assumes \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows   \"lead_monom (p * q) = lead_monom p + lead_monom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p * q) = lead_monom p + lead_monom q", "by (intro antisym lead_monom_mult_le lead_monom_geI)\n     (insert assms, auto simp: lead_coeff_mult_aux)"], ["", "lemma lead_coeff_mult:\n  assumes \"lead_coeff p * lead_coeff q \\<noteq> 0\"\n  shows   \"lead_coeff (p * q) = lead_coeff p * lead_coeff q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (p * q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "using assms"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff p *\n  Symmetric_Polynomials.lead_coeff q \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (p * q) =\n    Symmetric_Polynomials.lead_coeff p * Symmetric_Polynomials.lead_coeff q", "by (simp add: lead_monom_mult lead_coeff_mult_aux lead_coeff_def)"], ["", "lemma keys_lead_monom_subset: \"keys (lead_monom p) \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (lead_monom p) \\<subseteq> vars p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p", "hence \"lead_coeff p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p", "hence \"coeff p (lead_monom p) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)", "unfolding lead_coeff_def"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)", "."], ["proof (state)\nthis:\n  MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p\n 2. p \\<noteq> 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys (lead_monom p) \\<subseteq> vars p", "unfolding vars_def"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p (lead_monom p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. keys (lead_monom p) \\<subseteq> \\<Union> (keys ` keys (mapping_of p))", "by transfer' (auto simp: max_def in_keys_iff)"], ["proof (state)\nthis:\n  keys (lead_monom p) \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> keys (lead_monom p) \\<subseteq> vars p", "qed auto"], ["", "lemma\n  assumes \"(\\<Prod>i\\<in>A. lead_coeff (f i)) \\<noteq> 0\"\n    shows lead_monom_prod: \"lead_monom (\\<Prod>i\\<in>A. f i) = (\\<Sum>i\\<in>A. lead_monom (f i))\" (is ?th1)\n      and lead_coeff_prod: \"lead_coeff (\\<Prod>i\\<in>A. f i) = (\\<Prod>i\\<in>A. lead_coeff (f i))\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) &&&\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n 2. Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "have \"?th1 \\<and> ?th2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "using assms"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "proof (induction A rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a) \\<Longrightarrow>\n        lead_monom (prod f F) = (\\<Sum>i\\<in>F. lead_monom (f i)) \\<and>\n        Symmetric_Polynomials.lead_coeff (prod f F) =\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i));\n        (\\<Prod>i\\<in>insert x F.\n           Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff\n                          (prod f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F.\n                            Symmetric_Polynomials.lead_coeff (f i))", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a) \\<Longrightarrow>\n        lead_monom (prod f F) = (\\<Sum>i\\<in>F. lead_monom (f i)) \\<and>\n        Symmetric_Polynomials.lead_coeff (prod f F) =\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i));\n        (\\<Prod>i\\<in>insert x F.\n           Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff\n                          (prod f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F.\n                            Symmetric_Polynomials.lead_coeff (f i))", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)", "have nz: \"lead_coeff (f x) \\<noteq> 0\" \"(\\<Prod>i\\<in>A. lead_coeff (f i)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (f x) \\<noteq> (0::'a) &&&\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (f x) \\<noteq> (0::'a)\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a) \\<Longrightarrow>\n        lead_monom (prod f F) = (\\<Sum>i\\<in>F. lead_monom (f i)) \\<and>\n        Symmetric_Polynomials.lead_coeff (prod f F) =\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i));\n        (\\<Prod>i\\<in>insert x F.\n           Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff\n                          (prod f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F.\n                            Symmetric_Polynomials.lead_coeff (f i))", "note IH = insert.IH[OF this(2)]"], ["proof (state)\nthis:\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a) \\<Longrightarrow>\n        lead_monom (prod f F) = (\\<Sum>i\\<in>F. lead_monom (f i)) \\<and>\n        Symmetric_Polynomials.lead_coeff (prod f F) =\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i));\n        (\\<Prod>i\\<in>insert x F.\n           Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff\n                          (prod f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F.\n                            Symmetric_Polynomials.lead_coeff (f i))", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)", "have nz': \"lead_coeff (f x) * lead_coeff (\\<Prod>i\\<in>A. f i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (f x) *\n    Symmetric_Polynomials.lead_coeff (prod f A) \\<noteq>\n    (0::'a)", "by (subst IH) auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (f x) *\n  Symmetric_Polynomials.lead_coeff (prod f A) \\<noteq>\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a) \\<Longrightarrow>\n        lead_monom (prod f F) = (\\<Sum>i\\<in>F. lead_monom (f i)) \\<and>\n        Symmetric_Polynomials.lead_coeff (prod f F) =\n        (\\<Prod>i\\<in>F. Symmetric_Polynomials.lead_coeff (f i));\n        (\\<Prod>i\\<in>insert x F.\n           Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f (insert x F)) =\n                         (\\<Sum>i\\<in>insert x F. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff\n                          (prod f (insert x F)) =\n                         (\\<Prod>i\\<in>insert x F.\n                            Symmetric_Polynomials.lead_coeff (f i))", "from insert.prems insert.hyps nz nz'"], ["proof (chain)\npicking this:\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)\n  finite A\n  x \\<notin> A\n  Symmetric_Polynomials.lead_coeff (f x) \\<noteq> (0::'a)\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n  Symmetric_Polynomials.lead_coeff (f x) *\n  Symmetric_Polynomials.lead_coeff (prod f A) \\<noteq>\n  (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n  (0::'a)\n  finite A\n  x \\<notin> A\n  Symmetric_Polynomials.lead_coeff (f x) \\<noteq> (0::'a)\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n  Symmetric_Polynomials.lead_coeff (f x) *\n  Symmetric_Polynomials.lead_coeff (prod f A) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (prod f (insert x A)) =\n    (\\<Sum>i\\<in>insert x A. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f (insert x A)) =\n    (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i))", "by (auto simp: lead_monom_mult lead_coeff_mult IH)"], ["proof (state)\nthis:\n  lead_monom (prod f (insert x A)) =\n  (\\<Sum>i\\<in>insert x A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f (insert x A)) =\n  (\\<Prod>i\\<in>insert x A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> lead_monom (prod f A) =\n                         (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n                         Symmetric_Polynomials.lead_coeff (prod f A) =\n                         (\\<Prod>i\\<in>A.\n                            Symmetric_Polynomials.lead_coeff (f i))\n 2. (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a) \\<Longrightarrow>\n    lead_monom (prod f {}) = (\\<Sum>i\\<in>{}. lead_monom (f i)) \\<and>\n    Symmetric_Polynomials.lead_coeff (prod f {}) =\n    (\\<Prod>i\\<in>{}. Symmetric_Polynomials.lead_coeff (f i))", "qed auto"], ["proof (state)\nthis:\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal (2 subgoals):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n 2. Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "thus ?th1 ?th2"], ["proof (prove)\nusing this:\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) \\<and>\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) &&&\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "by blast+"], ["proof (state)\nthis:\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_sum_le: \"(\\<And>x. x \\<in> X \\<Longrightarrow> lead_monom (h x) \\<le> ub) \\<Longrightarrow> lead_monom (sum h X) \\<le> ub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> X \\<Longrightarrow>\n        lead_monom (h x) \\<le> ub) \\<Longrightarrow>\n    lead_monom (sum h X) \\<le> ub", "by (induction X rule: infinite_finite_induct) (auto intro!: order.trans[OF lead_monom_add])"], ["", "text \\<open>\n  The leading monomial of a sum where the leading monomial the summands are distinct is\n  simply the maximum of the leading monomials.\n\\<close>"], ["", "lemma lead_monom_sum:\n  assumes \"inj_on (lead_monom \\<circ> h) X\" and \"finite X\" and \"X \\<noteq> {}\" and \"\\<And>x. x \\<in> X \\<Longrightarrow> h x \\<noteq> 0\"\n  defines \"m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\"\n  shows   \"lead_monom (\\<Sum>x\\<in>X. h x) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sum h X) = m", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom (sum h X) \\<le> m\n 2. m \\<le> lead_monom (sum h X)", "show \"lead_monom (sum h X) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sum h X) \\<le> m", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sum h X) \\<le> Max ((lead_monom \\<circ> h) ` X)", "using assms"], ["proof (prove)\nusing this:\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n\ngoal (1 subgoal):\n 1. lead_monom (sum h X) \\<le> Max ((lead_monom \\<circ> h) ` X)", "by (intro lead_monom_sum_le Max_ge finite_imageI) auto"], ["proof (state)\nthis:\n  lead_monom (sum h X) \\<le> m\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "from assms"], ["proof (chain)\npicking this:\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  m \\<equiv> Max ((lead_monom \\<circ> h) ` X)", "have \"m \\<in> (lead_monom \\<circ> h) ` X\""], ["proof (prove)\nusing this:\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n\ngoal (1 subgoal):\n 1. m \\<in> (lead_monom \\<circ> h) ` X", "unfolding m_def"], ["proof (prove)\nusing this:\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  Max ((lead_monom \\<circ> h) ` X) \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n\ngoal (1 subgoal):\n 1. Max ((lead_monom \\<circ> h) ` X) \\<in> (lead_monom \\<circ> h) ` X", "by (intro Max_in finite_imageI) auto"], ["proof (state)\nthis:\n  m \\<in> (lead_monom \\<circ> h) ` X\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "then"], ["proof (chain)\npicking this:\n  m \\<in> (lead_monom \\<circ> h) ` X", "obtain x where x: \"x \\<in> X\" \"m = lead_monom (h x)\""], ["proof (prove)\nusing this:\n  m \\<in> (lead_monom \\<circ> h) ` X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> X; m = lead_monom (h x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n  m = lead_monom (h x)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "have \"coeff (\\<Sum>x\\<in>X. h x) m = (\\<Sum>x\\<in>X. coeff (h x) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sum h X) m = (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sum h X) m = (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sum h X) m = (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "have \"\\<dots> = (\\<Sum>x\\<in>{x}. coeff (h x) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m) =\n    (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m)", "proof (intro sum.mono_neutral_right ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "assume y: \"y \\<in> X - {x}\""], ["proof (state)\nthis:\n  y \\<in> X - {x}\n\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "hence \"(lead_monom \\<circ> h) y \\<le> m\""], ["proof (prove)\nusing this:\n  y \\<in> X - {x}\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) y \\<le> m", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> X - {x}\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) y \\<le> m", "unfolding m_def"], ["proof (prove)\nusing this:\n  y \\<in> X - {x}\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  Max ((lead_monom \\<circ> h) ` X) \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) y \\<le> Max ((lead_monom \\<circ> h) ` X)", "by (intro Max_ge finite_imageI) auto"], ["proof (state)\nthis:\n  (lead_monom \\<circ> h) y \\<le> m\n\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "moreover"], ["proof (state)\nthis:\n  (lead_monom \\<circ> h) y \\<le> m\n\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "have \"(lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x", "using \\<open>x \\<in> X\\<close> y inj_onD[OF assms(1), of x y]"], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> X - {x}\n  \\<lbrakk>(lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y; x \\<in> X;\n   y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x", "by auto"], ["proof (state)\nthis:\n  (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x\n\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  (lead_monom \\<circ> h) y \\<le> m\n  (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x", "have \"lead_monom (h y) < m\""], ["proof (prove)\nusing this:\n  (lead_monom \\<circ> h) y \\<le> m\n  (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x\n\ngoal (1 subgoal):\n 1. lead_monom (h y) < m", "using x"], ["proof (prove)\nusing this:\n  (lead_monom \\<circ> h) y \\<le> m\n  (lead_monom \\<circ> h) y \\<noteq> (lead_monom \\<circ> h) x\n  x \\<in> X\n  m = lead_monom (h x)\n\ngoal (1 subgoal):\n 1. lead_monom (h y) < m", "by auto"], ["proof (state)\nthis:\n  lead_monom (h y) < m\n\ngoal (3 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X\n 3. \\<And>i.\n       i \\<in> X - {x} \\<Longrightarrow> MPoly_Type.coeff (h i) m = (0::'b)", "thus \"coeff (h y) m = 0\""], ["proof (prove)\nusing this:\n  lead_monom (h y) < m\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (h y) m = (0::'b)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (h y) m = (0::'b)\n\ngoal (2 subgoals):\n 1. finite X\n 2. {x} \\<subseteq> X", "qed (insert x assms, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m) =\n  (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. MPoly_Type.coeff (h x) m) =\n  (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "have \"\\<dots> = coeff (h x) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m) = MPoly_Type.coeff (h x) m", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m) = MPoly_Type.coeff (h x) m\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>{x}. MPoly_Type.coeff (h x) m) = MPoly_Type.coeff (h x) m\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "have \"\\<dots> = lead_coeff (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (h x) m = Symmetric_Polynomials.lead_coeff (h x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> X\n  m = lead_monom (h x)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (h x) m = Symmetric_Polynomials.lead_coeff (h x)", "by (simp add: lead_coeff_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (h x) m = Symmetric_Polynomials.lead_coeff (h x)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (h x) m = Symmetric_Polynomials.lead_coeff (h x)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h x) \\<noteq> (0::'b)", "using assms x"], ["proof (prove)\nusing this:\n  inj_on (lead_monom \\<circ> h) X\n  finite X\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> h ?x \\<noteq> 0\n  m \\<equiv> Max ((lead_monom \\<circ> h) ` X)\n  x \\<in> X\n  m = lead_monom (h x)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h x) \\<noteq> (0::'b)", "by auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (h x) \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (sum h X) m \\<noteq> (0::'b)", "show \"lead_monom (sum h X) \\<ge> m\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sum h X) m \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. m \\<le> lead_monom (sum h X)", "by (intro lead_monom_geI)"], ["proof (state)\nthis:\n  m \\<le> lead_monom (sum h X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_eq_0_iff [simp]: \"lead_coeff p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Symmetric_Polynomials.lead_coeff p = (0::'a)) = (p = 0)", "by (cases \"p = 0\") auto"], ["", "lemma\n  fixes f :: \"_ \\<Rightarrow> 'a :: semidom mpoly\"\n  assumes \"\\<And>i. i \\<in> A \\<Longrightarrow> f i \\<noteq> 0\"\n    shows lead_monom_prod' [simp]: \"lead_monom (\\<Prod>i\\<in>A. f i) = (\\<Sum>i\\<in>A. lead_monom (f i))\" (is ?th1)\n      and lead_coeff_prod' [simp]: \"lead_coeff (\\<Prod>i\\<in>A. f i) = (\\<Prod>i\\<in>A. lead_coeff (f i))\" (is ?th2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) &&&\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n 2. Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "from assms"], ["proof (chain)\npicking this:\n  ?i \\<in> A \\<Longrightarrow> f ?i \\<noteq> 0", "have \"(\\<Prod>i\\<in>A. lead_coeff (f i)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow> f ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq>\n    (0::'a)", "by (cases \"finite A\") auto"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n 2. Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "thus ?th1 ?th2"], ["proof (prove)\nusing this:\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i)) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i)) &&&\n    Symmetric_Polynomials.lead_coeff (prod f A) =\n    (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))", "by (simp_all add: lead_monom_prod lead_coeff_prod)"], ["proof (state)\nthis:\n  lead_monom (prod f A) = (\\<Sum>i\\<in>A. lead_monom (f i))\n  Symmetric_Polynomials.lead_coeff (prod f A) =\n  (\\<Prod>i\\<in>A. Symmetric_Polynomials.lead_coeff (f i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  fixes p :: \"'a :: comm_semiring_1 mpoly\"\n  assumes \"lead_coeff p ^ n \\<noteq> 0\"\n  shows   lead_monom_power: \"lead_monom (p ^ n) = of_nat n * lead_monom p\"\n  and     lead_coeff_power: \"lead_coeff (p ^ n) = lead_coeff p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p ^ n) = of_nat n * lead_monom p &&&\n    Symmetric_Polynomials.lead_coeff (p ^ n) =\n    Symmetric_Polynomials.lead_coeff p ^ n", "using assms lead_monom_prod[of \"\\<lambda>_. p\" \"{..<n}\"] lead_coeff_prod[of \"\\<lambda>_. p\" \"{..<n}\"]"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff p ^ n \\<noteq> (0::'a)\n  (\\<Prod>i<n. Symmetric_Polynomials.lead_coeff p) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  lead_monom (\\<Prod>i<n. p) = (\\<Sum>i<n. lead_monom p)\n  (\\<Prod>i<n. Symmetric_Polynomials.lead_coeff p) \\<noteq>\n  (0::'a) \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i<n. p) =\n  (\\<Prod>i<n. Symmetric_Polynomials.lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_monom (p ^ n) = of_nat n * lead_monom p &&&\n    Symmetric_Polynomials.lead_coeff (p ^ n) =\n    Symmetric_Polynomials.lead_coeff p ^ n", "by simp_all"], ["", "lemma\n  fixes p :: \"'a :: semidom mpoly\"\n  assumes \"p \\<noteq> 0\"\n  shows   lead_monom_power' [simp]: \"lead_monom (p ^ n) = of_nat n * lead_monom p\"\n  and     lead_coeff_power' [simp]: \"lead_coeff (p ^ n) = lead_coeff p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p ^ n) = of_nat n * lead_monom p &&&\n    Symmetric_Polynomials.lead_coeff (p ^ n) =\n    Symmetric_Polynomials.lead_coeff p ^ n", "using assms lead_monom_prod'[of \"{..<n}\" \"\\<lambda>_. p\"] lead_coeff_prod'[of \"{..<n}\" \"\\<lambda>_. p\"]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (\\<And>i. i \\<in> {..<n} \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n  lead_monom (\\<Prod>i<n. p) = (\\<Sum>i<n. lead_monom p)\n  (\\<And>i. i \\<in> {..<n} \\<Longrightarrow> p \\<noteq> 0) \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i<n. p) =\n  (\\<Prod>i<n. Symmetric_Polynomials.lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_monom (p ^ n) = of_nat n * lead_monom p &&&\n    Symmetric_Polynomials.lead_coeff (p ^ n) =\n    Symmetric_Polynomials.lead_coeff p ^ n", "by simp_all"], ["", "subsection \\<open>Turning a set of variables into a monomial\\<close>"], ["", "text \\<open>\n  Given a finite set $\\{X_1,\\ldots,X_n\\}$ of variables, the following is the monomial\n  $X_1\\ldots X_n$:\n\\<close>"], ["", "lift_definition monom_of_set :: \"nat set \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat)\" is\n  \"\\<lambda>X x. if finite X \\<and> x \\<in> X then 1 else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       finite\n        {x. (if finite set \\<and> x \\<in> set then 1 else 0) \\<noteq> 0}", "by auto"], ["", "lemma lookup_monom_of_set:\n  \"Poly_Mapping.lookup (monom_of_set X) i = (if finite X \\<and> i \\<in> X then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (monom_of_set X) i = (if finite X \\<and> i \\<in> X then 1 else 0)", "by transfer auto"], ["", "lemma lookup_monom_of_set_1 [simp]:\n        \"finite X \\<Longrightarrow> i \\<in> X \\<Longrightarrow> Poly_Mapping.lookup (monom_of_set X) i = 1\"\n  and lookup_monom_of_set_0 [simp]:\n        \"i \\<notin> X \\<Longrightarrow> Poly_Mapping.lookup (monom_of_set X) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite X; i \\<in> X\\<rbrakk>\n     \\<Longrightarrow> lookup (monom_of_set X) i = 1) &&&\n    (i \\<notin> X \\<Longrightarrow> lookup (monom_of_set X) i = 0)", "by (simp_all add: lookup_monom_of_set)"], ["", "lemma keys_monom_of_set: \"keys (monom_of_set X) = (if finite X then X else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (monom_of_set X) = (if finite X then X else {})", "by transfer auto"], ["", "lemma keys_monom_of_set_finite [simp]: \"finite X \\<Longrightarrow> keys (monom_of_set X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> keys (monom_of_set X) = X", "by (simp add: keys_monom_of_set)"], ["", "lemma monom_of_set_eq_iff [simp]: \"finite X \\<Longrightarrow> finite Y \\<Longrightarrow> monom_of_set X = monom_of_set Y \\<longleftrightarrow> X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; finite Y\\<rbrakk>\n    \\<Longrightarrow> (monom_of_set X = monom_of_set Y) = (X = Y)", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma monom_of_set_empty [simp]: \"monom_of_set {} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_of_set {} = 0", "by transfer auto"], ["", "lemma monom_of_set_eq_zero_iff [simp]: \"monom_of_set X = 0 \\<longleftrightarrow> infinite X \\<or> X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (monom_of_set X = 0) = (infinite X \\<or> X = {})", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma zero_eq_monom_of_set_iff [simp]: \"0 = monom_of_set X \\<longleftrightarrow> infinite X \\<or> X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 = monom_of_set X) = (infinite X \\<or> X = {})", "by transfer (auto simp: fun_eq_iff)"], ["", "subsection \\<open>Permuting the variables of a polynomial\\<close>"], ["", "text \\<open>\n  Next, we define the operation of permuting the variables of a monomial and polynomial.\n\\<close>"], ["", "lift_definition permutep :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b :: zero)\" is\n  \"\\<lambda>f p. if bij f then p \\<circ> f else p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {x. fun2 x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite\n        {x. (if bij fun1 then fun2 \\<circ> fun1 else fun2) x \\<noteq>\n            (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {x. fun2 x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite\n        {x. (if bij fun1 then fun2 \\<circ> fun1 else fun2) x \\<noteq>\n            (0::'b)}", "fix f :: \"'a \\<Rightarrow> 'a\" and g :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {x. fun2 x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite\n        {x. (if bij fun1 then fun2 \\<circ> fun1 else fun2) x \\<noteq>\n            (0::'b)}", "assume *: \"finite {x. g x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. g x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       finite {x. fun2 x \\<noteq> (0::'b)} \\<Longrightarrow>\n       finite\n        {x. (if bij fun1 then fun2 \\<circ> fun1 else fun2) x \\<noteq>\n            (0::'b)}", "show \"finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "proof (cases \"bij f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}\n 2. \\<not> bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "case True"], ["proof (state)\nthis:\n  bij f\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}\n 2. \\<not> bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "with *"], ["proof (chain)\npicking this:\n  finite {x. g x \\<noteq> (0::'b)}\n  bij f", "have \"finite (f -` {x. g x \\<noteq> 0})\""], ["proof (prove)\nusing this:\n  finite {x. g x \\<noteq> (0::'b)}\n  bij f\n\ngoal (1 subgoal):\n 1. finite (f -` {x. g x \\<noteq> (0::'b)})", "by (intro finite_vimageI) (auto dest: bij_is_inj)"], ["proof (state)\nthis:\n  finite (f -` {x. g x \\<noteq> (0::'b)})\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}\n 2. \\<not> bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "with True"], ["proof (chain)\npicking this:\n  bij f\n  finite (f -` {x. g x \\<noteq> (0::'b)})", "show ?thesis"], ["proof (prove)\nusing this:\n  bij f\n  finite (f -` {x. g x \\<noteq> (0::'b)})\n\ngoal (1 subgoal):\n 1. finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "by auto"], ["proof (state)\nthis:\n  finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<not> bij f \\<Longrightarrow>\n    finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}", "qed (use * in auto)"], ["proof (state)\nthis:\n  finite {x. (if bij f then g \\<circ> f else g) x \\<noteq> (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition mpoly_map_vars :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> 'a :: zero mpoly \\<Rightarrow> 'a mpoly\" is\n  \"\\<lambda>f p. permutep (permutep f) p\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma keys_permutep: \"bij f \\<Longrightarrow> keys (permutep f m) = f -` keys m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> keys (permutep f m) = f -` keys m", "by transfer auto"], ["", "lemma permutep_id'' [simp]: \"permutep id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep id = id", "by transfer' (auto simp: fun_eq_iff)"], ["", "lemma permutep_id''' [simp]: \"permutep (\\<lambda>x. x) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (\\<lambda>x. x) = id", "by transfer' (auto simp: fun_eq_iff)"], ["", "lemma permutep_0 [simp]: \"permutep f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f 0 = 0", "by transfer auto"], ["", "lemma permutep_single:\n  \"bij f \\<Longrightarrow> permutep f (Poly_Mapping.single a b) = Poly_Mapping.single (inv_into UNIV f a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow>\n    permutep f (Poly_Mapping.single a b) = Poly_Mapping.single (inv f a) b", "by transfer (auto simp: fun_eq_iff when_def inv_f_f surj_f_inv_f bij_is_inj bij_is_surj)"], ["", "lemma mpoly_map_vars_id [simp]: \"mpoly_map_vars id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars id = id", "by transfer auto"], ["", "lemma mpoly_map_vars_id' [simp]: \"mpoly_map_vars (\\<lambda>x. x) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars (\\<lambda>x. x) = id", "by transfer auto"], ["", "lemma lookup_permutep:\n  \"Poly_Mapping.lookup (permutep f m) x = (if bij f then Poly_Mapping.lookup m (f x) else Poly_Mapping.lookup m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (permutep f m) x = (if bij f then lookup m (f x) else lookup m x)", "by transfer auto"], ["", "lemma inj_permutep [intro]: \"inj (permutep (f :: 'a \\<Rightarrow> 'a) :: _ \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b :: zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (permutep f)", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. permutep f x = permutep f y \\<longrightarrow> x = y", "proof (transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x y.\n       \\<lbrakk>finite {xa. x xa \\<noteq> (0::'b)};\n        finite {x. y x \\<noteq> (0::'b)};\n        (if bij f then x \\<circ> f else x) =\n        (if bij f then y \\<circ> f else y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix f :: \"'a \\<Rightarrow> 'a\" and x y :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x y.\n       \\<lbrakk>finite {xa. x xa \\<noteq> (0::'b)};\n        finite {x. y x \\<noteq> (0::'b)};\n        (if bij f then x \\<circ> f else x) =\n        (if bij f then y \\<circ> f else y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume eq: \"(if bij f then x \\<circ> f else x) = (if bij f then y \\<circ> f else y)\""], ["proof (state)\nthis:\n  (if bij f then x \\<circ> f else x) = (if bij f then y \\<circ> f else y)\n\ngoal (1 subgoal):\n 1. \\<And>f x y.\n       \\<lbrakk>finite {xa. x xa \\<noteq> (0::'b)};\n        finite {x. y x \\<noteq> (0::'b)};\n        (if bij f then x \\<circ> f else x) =\n        (if bij f then y \\<circ> f else y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"bij f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow> x = y\n 2. \\<not> bij f \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  bij f\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow> x = y\n 2. \\<not> bij f \\<Longrightarrow> x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. x xa = y xa", "fix t :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. x xa = y xa", "from \\<open>bij f\\<close>"], ["proof (chain)\npicking this:\n  bij f", "obtain s where \"t = f s\""], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. (\\<And>s. t = f s \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto dest!: bij_is_surj)"], ["proof (state)\nthis:\n  t = f s\n\ngoal (1 subgoal):\n 1. \\<And>xa. x xa = y xa", "with eq and True"], ["proof (chain)\npicking this:\n  (if bij f then x \\<circ> f else x) = (if bij f then y \\<circ> f else y)\n  bij f\n  t = f s", "show \"x t = y t\""], ["proof (prove)\nusing this:\n  (if bij f then x \\<circ> f else x) = (if bij f then y \\<circ> f else y)\n  bij f\n  t = f s\n\ngoal (1 subgoal):\n 1. x t = y t", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  x t = y t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> bij f \\<Longrightarrow> x = y", "qed (use eq in auto)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_permutep [intro]: \"surj (permutep (f :: 'a \\<Rightarrow> 'a) :: _ \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>0 'b :: zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (permutep f)", "unfolding surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = permutep f x", "proof (transfer, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f y.\n       finite {x. y x \\<noteq> (0::'b)} \\<Longrightarrow>\n       \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n          y = (if bij f then x \\<circ> f else x)", "fix f :: \"'a \\<Rightarrow> 'a\" and y :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f y.\n       finite {x. y x \\<noteq> (0::'b)} \\<Longrightarrow>\n       \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n          y = (if bij f then x \\<circ> f else x)", "assume fin: \"finite {t. y t \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {t. y t \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>f y.\n       finite {x. y x \\<noteq> (0::'b)} \\<Longrightarrow>\n       \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n          y = (if bij f then x \\<circ> f else x)", "show \"\\<exists>x\\<in>{f. finite {x. f x \\<noteq> 0}}. y = (if bij f then x \\<circ> f else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "proof (cases \"bij f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)\n 2. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "case True"], ["proof (state)\nthis:\n  bij f\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)\n 2. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "with fin"], ["proof (chain)\npicking this:\n  finite {t. y t \\<noteq> (0::'b)}\n  bij f", "have \"finite (the_inv f -` {t. y t \\<noteq> 0})\""], ["proof (prove)\nusing this:\n  finite {t. y t \\<noteq> (0::'b)}\n  bij f\n\ngoal (1 subgoal):\n 1. finite (the_inv f -` {t. y t \\<noteq> (0::'b)})", "by (intro finite_vimageI) (auto simp: bij_is_inj bij_betw_the_inv_into)"], ["proof (state)\nthis:\n  finite (the_inv f -` {t. y t \\<noteq> (0::'b)})\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)\n 2. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "moreover"], ["proof (state)\nthis:\n  finite (the_inv f -` {t. y t \\<noteq> (0::'b)})\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)\n 2. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "have \"y \\<circ> the_inv f \\<circ> f = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<circ> the_inv f \\<circ> f = y", "using True"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. y \\<circ> the_inv f \\<circ> f = y", "by (simp add: fun_eq_iff the_inv_f_f bij_is_inj)"], ["proof (state)\nthis:\n  y \\<circ> the_inv f \\<circ> f = y\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)\n 2. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "ultimately"], ["proof (chain)\npicking this:\n  finite (the_inv f -` {t. y t \\<noteq> (0::'b)})\n  y \\<circ> the_inv f \\<circ> f = y", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (the_inv f -` {t. y t \\<noteq> (0::'b)})\n  y \\<circ> the_inv f \\<circ> f = y\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "by (intro bexI[of _ \"y \\<circ> the_inv f\"]) (auto simp: True)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n     y = (if bij f then x \\<circ> f else x)\n\ngoal (1 subgoal):\n 1. \\<not> bij f \\<Longrightarrow>\n    \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n       y = (if bij f then x \\<circ> f else x)", "qed (use fin in auto)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{f. finite {x. f x \\<noteq> (0::'b)}}.\n     y = (if bij f then x \\<circ> f else x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_permutep [intro]: \"bij (permutep f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (permutep f)", "using inj_permutep[of f] surj_permutep[of f]"], ["proof (prove)\nusing this:\n  inj (permutep f)\n  surj (permutep f)\n\ngoal (1 subgoal):\n 1. bij (permutep f)", "by (simp add: bij_def)"], ["", "lemma mpoly_map_vars_map_mpoly:\n  \"mpoly_map_vars f (map_mpoly g p) = map_mpoly g (mpoly_map_vars f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (map_mpoly g p) = map_mpoly g (mpoly_map_vars f p)", "by (transfer', transfer') (auto simp: fun_eq_iff)"], ["", "lemma coeff_mpoly_map_vars:\n  fixes f :: \"nat \\<Rightarrow> nat\" and p :: \"'a :: zero mpoly\"\n  assumes \"bij f\"\n  shows   \"MPoly_Type.coeff (mpoly_map_vars f p) mon =\n             MPoly_Type.coeff p (permutep f mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff p (permutep f mon)", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff p (permutep f mon)", "by transfer' (simp add: lookup_permutep bij_permutep)"], ["", "lemma permutep_monom_of_set:\n  assumes \"bij f\"\n  shows   \"permutep f (monom_of_set A) = monom_of_set (f -` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (monom_of_set A) = monom_of_set (f -` A)", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. permutep f (monom_of_set A) = monom_of_set (f -` A)", "by transfer (auto simp: fun_eq_iff bij_is_inj finite_vimage_iff)"], ["", "lemma permutep_comp: \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> permutep (f \\<circ> g) = permutep g \\<circ> permutep f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> permutep (f \\<circ> g) = permutep g \\<circ> permutep f", "by transfer' (auto simp: fun_eq_iff bij_comp)"], ["", "lemma permutep_comp': \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> permutep (f \\<circ> g) mon = permutep g (permutep f mon)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> permutep (f \\<circ> g) mon =\n                      permutep g (permutep f mon)", "by transfer (auto simp: fun_eq_iff bij_comp)"], ["", "lemma mpoly_map_vars_comp:\n  \"bij f \\<Longrightarrow> bij g \\<Longrightarrow> mpoly_map_vars f (mpoly_map_vars g p) = mpoly_map_vars (f \\<circ> g) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> mpoly_map_vars f (mpoly_map_vars g p) =\n                      mpoly_map_vars (f \\<circ> g) p", "by transfer (auto simp: bij_permutep permutep_comp)"], ["", "lemma permutep_id [simp]: \"permutep id mon = mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep id mon = mon", "by transfer auto"], ["", "lemma permutep_id' [simp]: \"permutep (\\<lambda>x. x) mon = mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (\\<lambda>x. x) mon = mon", "by transfer auto"], ["", "lemma inv_permutep [simp]:\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n  assumes \"bij f\"\n  shows   \"inv_into UNIV (permutep f) = permutep (inv_into UNIV f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (permutep f) = permutep (inv f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. inv (permutep f) x = permutep (inv f) x", "fix m :: \"'a \\<Rightarrow>\\<^sub>0 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. inv (permutep f) x = permutep (inv f) x", "show \"inv_into UNIV (permutep f) m = permutep (inv_into UNIV f) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (permutep f) m = permutep (inv f) m", "using permutep_comp'[of \"inv_into UNIV f\" f m] assms inj_iff[of f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bij (inv f); bij f\\<rbrakk>\n  \\<Longrightarrow> permutep (inv f \\<circ> f) m =\n                    permutep f (permutep (inv f) m)\n  bij f\n  inj f = (inv f \\<circ> f = id)\n\ngoal (1 subgoal):\n 1. inv (permutep f) m = permutep (inv f) m", "by (intro inv_f_eq) (auto simp: bij_imp_bij_inv bij_is_inj)"], ["proof (state)\nthis:\n  inv (permutep f) m = permutep (inv f) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_map_vars_monom:\n  \"bij f \\<Longrightarrow> mpoly_map_vars f (monom m c) = monom (permutep (inv_into UNIV f) m) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow>\n    mpoly_map_vars f (MPoly_Type.monom m c) =\n    MPoly_Type.monom (permutep (inv f) m) c", "by transfer' (simp add: permutep_single bij_permutep)"], ["", "lemma vars_mpoly_map_vars:\n  fixes f :: \"nat \\<Rightarrow> nat\" and p :: \"'a :: zero mpoly\"\n  assumes \"bij f\"\n  shows   \"vars (mpoly_map_vars f p) = f ` vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (mpoly_map_vars f p) = f ` vars p", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. vars (mpoly_map_vars f p) = f ` vars p", "unfolding vars_def"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (mapping_of (mpoly_map_vars f p))) =\n    f ` \\<Union> (keys ` keys (mapping_of p))", "proof transfer'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f p.\n       bij f \\<Longrightarrow>\n       \\<Union> (keys ` keys (permutep (permutep f) p)) =\n       f ` \\<Union> (keys ` keys p)", "fix f :: \"nat \\<Rightarrow> nat\" and p :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f p.\n       bij f \\<Longrightarrow>\n       \\<Union> (keys ` keys (permutep (permutep f) p)) =\n       f ` \\<Union> (keys ` keys p)", "assume f: \"bij f\""], ["proof (state)\nthis:\n  bij f\n\ngoal (1 subgoal):\n 1. \\<And>f p.\n       bij f \\<Longrightarrow>\n       \\<Union> (keys ` keys (permutep (permutep f) p)) =\n       f ` \\<Union> (keys ` keys p)", "have eq: \"f (inv_into UNIV f x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (inv f x) = x", "using f"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. f (inv f x) = x", "by (subst surj_f_inv_f[of f]) (auto simp: bij_is_surj)"], ["proof (state)\nthis:\n  f (inv f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>f p.\n       bij f \\<Longrightarrow>\n       \\<Union> (keys ` keys (permutep (permutep f) p)) =\n       f ` \\<Union> (keys ` keys p)", "show \"\\<Union> (keys ` keys (permutep (permutep f) p)) = f ` \\<Union> (keys ` keys p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (keys ` keys (permutep (permutep f) p)) =\n    f ` \\<Union> (keys ` keys p)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys (permutep (permutep f) p);\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (keys ` keys p)\n 2. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "fix m x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys (permutep (permutep f) p);\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (keys ` keys p)\n 2. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "assume mx: \"m \\<in> keys (permutep (permutep f) p)\" \"x \\<in> keys m\""], ["proof (state)\nthis:\n  m \\<in> keys (permutep (permutep f) p)\n  x \\<in> keys m\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys (permutep (permutep f) p);\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (keys ` keys p)\n 2. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "from mx"], ["proof (chain)\npicking this:\n  m \\<in> keys (permutep (permutep f) p)\n  x \\<in> keys m", "have \"permutep f m \\<in> keys p\""], ["proof (prove)\nusing this:\n  m \\<in> keys (permutep (permutep f) p)\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. permutep f m \\<in> keys p", "by (auto simp: keys_permutep bij_permutep f)"], ["proof (state)\nthis:\n  permutep f m \\<in> keys p\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys (permutep (permutep f) p);\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (keys ` keys p)\n 2. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "with mx"], ["proof (chain)\npicking this:\n  m \\<in> keys (permutep (permutep f) p)\n  x \\<in> keys m\n  permutep f m \\<in> keys p", "have \"f (inv_into UNIV f x) \\<in> f ` (\\<Union>m\\<in>keys p. keys m)\""], ["proof (prove)\nusing this:\n  m \\<in> keys (permutep (permutep f) p)\n  x \\<in> keys m\n  permutep f m \\<in> keys p\n\ngoal (1 subgoal):\n 1. f (inv f x) \\<in> f ` \\<Union> (keys ` keys p)", "by (intro imageI) (auto intro!: bexI[of _ \"permutep f m\"] simp: keys_permutep f eq)"], ["proof (state)\nthis:\n  f (inv f x) \\<in> f ` \\<Union> (keys ` keys p)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> keys (permutep (permutep f) p);\n        x \\<in> keys xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f ` \\<Union> (keys ` keys p)\n 2. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "with eq"], ["proof (chain)\npicking this:\n  f (inv f ?x) = ?x\n  f (inv f x) \\<in> f ` \\<Union> (keys ` keys p)", "show \"x \\<in> f ` (\\<Union>m\\<in>keys p. keys m)\""], ["proof (prove)\nusing this:\n  f (inv f ?x) = ?x\n  f (inv f x) \\<in> f ` \\<Union> (keys ` keys p)\n\ngoal (1 subgoal):\n 1. x \\<in> f ` \\<Union> (keys ` keys p)", "by simp"], ["proof (state)\nthis:\n  x \\<in> f ` \\<Union> (keys ` keys p)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "fix m x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "assume mx: \"m \\<in> keys p\" \"x \\<in> keys m\""], ["proof (state)\nthis:\n  m \\<in> keys p\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "from mx"], ["proof (chain)\npicking this:\n  m \\<in> keys p\n  x \\<in> keys m", "have \"permutep id m \\<in> keys p\""], ["proof (prove)\nusing this:\n  m \\<in> keys p\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. permutep id m \\<in> keys p", "by simp"], ["proof (state)\nthis:\n  permutep id m \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "also"], ["proof (state)\nthis:\n  permutep id m \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "have \"id = inv_into UNIV f \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id = inv f \\<circ> f", "using f"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. id = inv f \\<circ> f", "by (intro ext) (auto simp: bij_is_inj inv_f_f)"], ["proof (state)\nthis:\n  id = inv f \\<circ> f\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "also"], ["proof (state)\nthis:\n  id = inv f \\<circ> f\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "have \"permutep \\<dots> m = permutep f (permutep (inv_into UNIV f) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (inv f \\<circ> f) m = permutep f (permutep (inv f) m)", "by (simp add: permutep_comp f bij_imp_bij_inv)"], ["proof (state)\nthis:\n  permutep (inv f \\<circ> f) m = permutep f (permutep (inv f) m)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "finally"], ["proof (chain)\npicking this:\n  permutep f (permutep (inv f) m) \\<in> keys p", "have **: \"permutep f (permutep (inv_into UNIV f) m) \\<in> keys p\""], ["proof (prove)\nusing this:\n  permutep f (permutep (inv f) m) \\<in> keys p\n\ngoal (1 subgoal):\n 1. permutep f (permutep (inv f) m) \\<in> keys p", "."], ["proof (state)\nthis:\n  permutep f (permutep (inv f) m) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "moreover"], ["proof (state)\nthis:\n  permutep f (permutep (inv f) m) \\<in> keys p\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "from f mx"], ["proof (chain)\npicking this:\n  bij f\n  m \\<in> keys p\n  x \\<in> keys m", "have \"f x \\<in> keys (permutep (inv_into UNIV f) m)\""], ["proof (prove)\nusing this:\n  bij f\n  m \\<in> keys p\n  x \\<in> keys m\n\ngoal (1 subgoal):\n 1. f x \\<in> keys (permutep (inv f) m)", "by (auto simp: keys_permutep bij_imp_bij_inv inv_f_f bij_is_inj)"], ["proof (state)\nthis:\n  f x \\<in> keys (permutep (inv f) m)\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> keys p; xa \\<in> keys xb\\<rbrakk>\n       \\<Longrightarrow> f xa\n                         \\<in> \\<Union>\n                                (keys ` keys (permutep (permutep f) p))", "ultimately"], ["proof (chain)\npicking this:\n  permutep f (permutep (inv f) m) \\<in> keys p\n  f x \\<in> keys (permutep (inv f) m)", "show \"f x \\<in> \\<Union> (keys ` keys (permutep (permutep f) p))\""], ["proof (prove)\nusing this:\n  permutep f (permutep (inv f) m) \\<in> keys p\n  f x \\<in> keys (permutep (inv f) m)\n\ngoal (1 subgoal):\n 1. f x \\<in> \\<Union> (keys ` keys (permutep (permutep f) p))", "using f"], ["proof (prove)\nusing this:\n  permutep f (permutep (inv f) m) \\<in> keys p\n  f x \\<in> keys (permutep (inv f) m)\n  bij f\n\ngoal (1 subgoal):\n 1. f x \\<in> \\<Union> (keys ` keys (permutep (permutep f) p))", "by (auto simp: keys_permutep bij_permutep)"], ["proof (state)\nthis:\n  f x \\<in> \\<Union> (keys ` keys (permutep (permutep f) p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (keys ` keys (permutep (permutep f) p)) =\n  f ` \\<Union> (keys ` keys p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutep_eq_monom_of_set_iff [simp]:\n  assumes \"bij f\"\n  shows   \"permutep f mon = monom_of_set A \\<longleftrightarrow> mon = monom_of_set (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (permutep f mon = monom_of_set A) = (mon = monom_of_set (f ` A))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "assume eq: \"permutep f mon = monom_of_set A\""], ["proof (state)\nthis:\n  permutep f mon = monom_of_set A\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "have \"permutep (inv_into UNIV f) (permutep f mon) = monom_of_set (inv_into UNIV f -` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (inv f) (permutep f mon) = monom_of_set (inv f -` A)", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. permutep (inv f) (permutep f mon) = monom_of_set (inv f -` A)", "by (simp add: eq bij_imp_bij_inv assms permutep_monom_of_set)"], ["proof (state)\nthis:\n  permutep (inv f) (permutep f mon) = monom_of_set (inv f -` A)\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "also"], ["proof (state)\nthis:\n  permutep (inv f) (permutep f mon) = monom_of_set (inv f -` A)\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "have \"inv_into UNIV f -` A = f ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f -` A = f ` A", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. inv f -` A = f ` A", "by (force simp: bij_is_surj image_iff inv_f_f bij_is_inj surj_f_inv_f)"], ["proof (state)\nthis:\n  inv f -` A = f ` A\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "also"], ["proof (state)\nthis:\n  inv f -` A = f ` A\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "have \"permutep (inv_into UNIV f) (permutep f mon) = permutep (f \\<circ> inv_into UNIV f) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (inv f) (permutep f mon) = permutep (f \\<circ> inv f) mon", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. permutep (inv f) (permutep f mon) = permutep (f \\<circ> inv f) mon", "by (simp add: permutep_comp bij_imp_bij_inv)"], ["proof (state)\nthis:\n  permutep (inv f) (permutep f mon) = permutep (f \\<circ> inv f) mon\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "also"], ["proof (state)\nthis:\n  permutep (inv f) (permutep f mon) = permutep (f \\<circ> inv f) mon\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "have \"f \\<circ> inv_into UNIV f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> inv f = id", "by (subst surj_iff [symmetric]) (insert assms, auto simp: bij_is_surj)"], ["proof (state)\nthis:\n  f \\<circ> inv f = id\n\ngoal (2 subgoals):\n 1. permutep f mon = monom_of_set A \\<Longrightarrow>\n    mon = monom_of_set (f ` A)\n 2. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "finally"], ["proof (chain)\npicking this:\n  permutep id mon = monom_of_set (f ` A)", "show \"mon = monom_of_set (f ` A)\""], ["proof (prove)\nusing this:\n  permutep id mon = monom_of_set (f ` A)\n\ngoal (1 subgoal):\n 1. mon = monom_of_set (f ` A)", "by simp"], ["proof (state)\nthis:\n  mon = monom_of_set (f ` A)\n\ngoal (1 subgoal):\n 1. mon = monom_of_set (f ` A) \\<Longrightarrow>\n    permutep f mon = monom_of_set A", "qed (insert assms, auto simp: permutep_monom_of_set inj_vimage_image_eq bij_is_inj)"], ["", "lemma permutep_monom_of_set_permutes [simp]:\n  assumes \"\\<pi> permutes A\"\n  shows   \"permutep \\<pi> (monom_of_set A) = monom_of_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep \\<pi> (monom_of_set A) = monom_of_set A", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. permutep \\<pi> (monom_of_set A) = monom_of_set A", "by transfer (auto simp: if_splits fun_eq_iff permutes_in_image)"], ["", "lemma mpoly_map_vars_0 [simp]: \"mpoly_map_vars f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f 0 = 0", "by (transfer, transfer') (simp add: o_def)"], ["", "lemma permutep_eq_0_iff [simp]: \"permutep f m = 0 \\<longleftrightarrow> m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (permutep f m = 0) = (m = 0)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f m.\n       finite {x. m x \\<noteq> (0::'b)} \\<Longrightarrow>\n       ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n       (m = (\\<lambda>k. 0::'b))", "fix f :: \"'a \\<Rightarrow> 'a\" and m :: \"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f m.\n       finite {x. m x \\<noteq> (0::'b)} \\<Longrightarrow>\n       ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n       (m = (\\<lambda>k. 0::'b))", "assume \"finite {x. m x \\<noteq> 0}\""], ["proof (state)\nthis:\n  finite {x. m x \\<noteq> (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<And>f m.\n       finite {x. m x \\<noteq> (0::'b)} \\<Longrightarrow>\n       ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n       (m = (\\<lambda>k. 0::'b))", "show \"((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0)) = (m = (\\<lambda>k. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "proof (cases \"bij f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))\n 2. \\<not> bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "case True"], ["proof (state)\nthis:\n  bij f\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))\n 2. \\<not> bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "hence \"(\\<forall>x. m (f x) = 0) \\<longleftrightarrow> (\\<forall>x. m x = 0)\""], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. (\\<forall>x. m (f x) = (0::'b)) = (\\<forall>x. m x = (0::'b))", "using bij_iff[of f]"], ["proof (prove)\nusing this:\n  bij f\n  bij f = (\\<forall>x. \\<exists>!y. f y = x)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. m (f x) = (0::'b)) = (\\<forall>x. m x = (0::'b))", "by metis"], ["proof (state)\nthis:\n  (\\<forall>x. m (f x) = (0::'b)) = (\\<forall>x. m x = (0::'b))\n\ngoal (2 subgoals):\n 1. bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))\n 2. \\<not> bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "with True"], ["proof (chain)\npicking this:\n  bij f\n  (\\<forall>x. m (f x) = (0::'b)) = (\\<forall>x. m x = (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  bij f\n  (\\<forall>x. m (f x) = (0::'b)) = (\\<forall>x. m x = (0::'b))\n\ngoal (1 subgoal):\n 1. ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n  (m = (\\<lambda>k. 0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> bij f \\<Longrightarrow>\n    ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n    (m = (\\<lambda>k. 0::'b))", "qed (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  ((if bij f then m \\<circ> f else m) = (\\<lambda>k. 0::'b)) =\n  (m = (\\<lambda>k. 0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_map_vars_1 [simp]: \"mpoly_map_vars f 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f 1 = 1", "by (transfer, transfer') (auto simp: o_def fun_eq_iff when_def)"], ["", "lemma permutep_Const\\<^sub>0 [simp]: \"(\\<And>x. f x = 0 \\<longleftrightarrow> x = 0) \\<Longrightarrow> permutep f (Const\\<^sub>0 c) = Const\\<^sub>0 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (f x = 0) = (x = 0)) \\<Longrightarrow>\n    permutep f (Const\\<^sub>0 c) = Const\\<^sub>0 c", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (f x = 0) = (x = 0)) \\<Longrightarrow>\n    permutep f (Poly_Mapping.single 0 c) = Poly_Mapping.single 0 c", "by transfer' (auto simp: when_def fun_eq_iff)"], ["", "lemma permutep_add [simp]: \"permutep f (m1 + m2) = permutep f m1 + permutep f m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (m1 + m2) = permutep f m1 + permutep f m2", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (m1 + m2) = permutep f m1 + permutep f m2", "by transfer' (auto simp: when_def fun_eq_iff)"], ["", "lemma permutep_diff [simp]: \"permutep f (m1 - m2) = permutep f m1 - permutep f m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (m1 - m2) = permutep f m1 - permutep f m2", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (m1 - m2) = permutep f m1 - permutep f m2", "by transfer' (auto simp: when_def fun_eq_iff)"], ["", "lemma permutep_uminus [simp]: \"permutep f (-m) = -permutep f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (- m) = - permutep f m", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f (- m) = - permutep f m", "by transfer' (auto simp: when_def fun_eq_iff)"], ["", "lemma permutep_mult [simp]:\n  \"(\\<And>x y. f (x + y) = f x + f y) \\<Longrightarrow> permutep f (m1 * m2) = permutep f m1 * permutep f m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f (x + y) = f x + f y) \\<Longrightarrow>\n    permutep f (m1 * m2) = permutep f m1 * permutep f m2", "unfolding Const\\<^sub>0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f (x + y) = f x + f y) \\<Longrightarrow>\n    permutep f (m1 * m2) = permutep f m1 * permutep f m2", "by transfer' (auto simp: when_def fun_eq_iff prod_fun_compose_bij)"], ["", "lemma mpoly_map_vars_Const [simp]: \"mpoly_map_vars f (Const c) = Const c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (Const c) = Const c", "by transfer (auto simp: o_def fun_eq_iff when_def)"], ["", "lemma mpoly_map_vars_add [simp]: \"mpoly_map_vars f (p + q) = mpoly_map_vars f p + mpoly_map_vars f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (p + q) = mpoly_map_vars f p + mpoly_map_vars f q", "by transfer simp"], ["", "lemma mpoly_map_vars_diff [simp]: \"mpoly_map_vars f (p - q) = mpoly_map_vars f p - mpoly_map_vars f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (p - q) = mpoly_map_vars f p - mpoly_map_vars f q", "by transfer simp"], ["", "lemma mpoly_map_vars_uminus [simp]: \"mpoly_map_vars f (-p) = -mpoly_map_vars f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (- p) = - mpoly_map_vars f p", "by transfer simp"], ["", "lemma permutep_smult:\n  \"permutep (permutep f) (Poly_Mapping.map ((*) c) p) =\n     Poly_Mapping.map ((*) c) (permutep (permutep f) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep (permutep f) (Poly_Mapping.map ((*) c) p) =\n    Poly_Mapping.map ((*) c) (permutep (permutep f) p)", "by transfer' (auto split: if_splits simp: fun_eq_iff)"], ["", "lemma mpoly_map_vars_smult [simp]: \"mpoly_map_vars f (smult c p) = smult c (mpoly_map_vars f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (MPoly_Type.smult c p) =\n    MPoly_Type.smult c (mpoly_map_vars f p)", "by transfer (simp add: permutep_smult)"], ["", "lemma mpoly_map_vars_mult [simp]: \"mpoly_map_vars f (p * q) = mpoly_map_vars f p * mpoly_map_vars f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (p * q) = mpoly_map_vars f p * mpoly_map_vars f q", "by transfer simp"], ["", "lemma mpoly_map_vars_sum [simp]: \"mpoly_map_vars f (sum g A) = (\\<Sum>x\\<in>A. mpoly_map_vars f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (sum g A) = (\\<Sum>x\\<in>A. mpoly_map_vars f (g x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma mpoly_map_vars_prod [simp]: \"mpoly_map_vars f (prod g A) = (\\<Prod>x\\<in>A. mpoly_map_vars f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (prod g A) = (\\<Prod>x\\<in>A. mpoly_map_vars f (g x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma mpoly_map_vars_eq_0_iff [simp]: \"mpoly_map_vars f p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpoly_map_vars f p = 0) = (p = 0)", "by transfer auto"], ["", "lemma permutep_eq_iff [simp]: \"permutep f p = permutep f q \\<longleftrightarrow> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (permutep f p = permutep f q) = (p = q)", "by transfer (auto simp: comp_bij_eq_iff)"], ["", "lemma mpoly_map_vars_Sum_any [simp]:\n  \"mpoly_map_vars f (Sum_any g) = Sum_any (\\<lambda>x. mpoly_map_vars f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (Sum_any g) = (\\<Sum>x. mpoly_map_vars f (g x))", "by (simp add: Sum_any.expand_set)"], ["", "lemma mpoly_map_vars_power [simp]: \"mpoly_map_vars f (p ^ n) = mpoly_map_vars f p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (p ^ n) = mpoly_map_vars f p ^ n", "by (induction n) auto"], ["", "lemma mpoly_map_vars_monom_single [simp]:\n  assumes \"bij f\"\n  shows   \"mpoly_map_vars f (monom (Poly_Mapping.single i n) c) =\n             monom (Poly_Mapping.single (f i) n) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (MPoly_Type.monom (Poly_Mapping.single i n) c) =\n    MPoly_Type.monom (Poly_Mapping.single (f i) n) c", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. mpoly_map_vars f (MPoly_Type.monom (Poly_Mapping.single i n) c) =\n    MPoly_Type.monom (Poly_Mapping.single (f i) n) c", "by (simp add: mpoly_map_vars_monom permutep_single bij_imp_bij_inv inv_inv_eq)"], ["", "lemma insertion_mpoly_map_vars:\n  assumes \"bij f\"\n  shows   \"insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "have \"insertion g (mpoly_map_vars f p) =\n          (\\<Sum>m. coeff p (permutep f m) * (\\<Prod>i. g i ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) =\n    (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n              (\\<Prod>i. g i ^ lookup m i))", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) =\n    (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n              (\\<Prod>i. g i ^ lookup m i))", "by (simp add: insertion_altdef coeff_mpoly_map_vars)"], ["proof (state)\nthis:\n  insertion g (mpoly_map_vars f p) =\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "also"], ["proof (state)\nthis:\n  insertion g (mpoly_map_vars f p) =\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "have \"\\<dots> = Sum_any (\\<lambda>m. coeff p (permutep f m) *\n                    Prod_any (\\<lambda>i. g (f i) ^ lookup m (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n              (\\<Prod>i. g i ^ lookup m i)) =\n    (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n              (\\<Prod>i. g (f i) ^ lookup m (f i)))", "by (intro Sum_any.cong arg_cong[where ?f = \"\\<lambda>y. x * y\" for x]\n          Prod_any.reindex_cong[OF assms]) (auto simp: o_def)"], ["proof (state)\nthis:\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g i ^ lookup m i)) =\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g (f i) ^ lookup m (f i)))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g i ^ lookup m i)) =\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g (f i) ^ lookup m (f i)))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "have \"\\<dots> = Sum_any (\\<lambda>m. coeff p m * (\\<Prod>i. g (f i) ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n              (\\<Prod>i. g (f i) ^ lookup m (f i))) =\n    (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. g (f i) ^ lookup m i))", "by (intro Sum_any.reindex_cong [OF bij_permutep[of f], symmetric])\n       (auto simp: o_def lookup_permutep assms)"], ["proof (state)\nthis:\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g (f i) ^ lookup m (f i))) =\n  (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. g (f i) ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. MPoly_Type.coeff p (permutep f m) *\n            (\\<Prod>i. g (f i) ^ lookup m (f i))) =\n  (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. g (f i) ^ lookup m i))\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "have \"\\<dots> = insertion (g \\<circ> f) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. g (f i) ^ lookup m i)) =\n    insertion (g \\<circ> f) p", "by (simp add: insertion_altdef)"], ["proof (state)\nthis:\n  (\\<Sum>m. MPoly_Type.coeff p m * (\\<Prod>i. g (f i) ^ lookup m i)) =\n  insertion (g \\<circ> f) p\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "finally"], ["proof (chain)\npicking this:\n  insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p\n\ngoal (1 subgoal):\n 1. insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p", "."], ["proof (state)\nthis:\n  insertion g (mpoly_map_vars f p) = insertion (g \\<circ> f) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma permutep_cong:\n  assumes \"f permutes (-keys p)\" \"g permutes (-keys p)\" \"p = q\"\n  shows   \"permutep f p = permutep g q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutep f p = permutep g q", "proof (intro poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (permutep f p) k = lookup (permutep g q) k", "fix k :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup (permutep f p) k = lookup (permutep g q) k", "show \"lookup (permutep f p) k = lookup (permutep g q) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (permutep f p) k = lookup (permutep g q) k", "proof (cases \"k \\<in> keys p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k\n 2. k \\<notin> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k", "case False"], ["proof (state)\nthis:\n  k \\<notin> keys p\n\ngoal (2 subgoals):\n 1. k \\<in> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k\n 2. k \\<notin> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k", "with assms"], ["proof (chain)\npicking this:\n  f permutes - keys p\n  g permutes - keys p\n  p = q\n  k \\<notin> keys p", "have \"f k \\<notin> keys p\" \"g k \\<notin> keys p\""], ["proof (prove)\nusing this:\n  f permutes - keys p\n  g permutes - keys p\n  p = q\n  k \\<notin> keys p\n\ngoal (1 subgoal):\n 1. f k \\<notin> keys p &&& g k \\<notin> keys p", "using permutes_in_image[of _ \"-keys p\" k]"], ["proof (prove)\nusing this:\n  f permutes - keys p\n  g permutes - keys p\n  p = q\n  k \\<notin> keys p\n  ?p permutes - keys p \\<Longrightarrow>\n  (?p k \\<in> - keys p) = (k \\<in> - keys p)\n\ngoal (1 subgoal):\n 1. f k \\<notin> keys p &&& g k \\<notin> keys p", "by auto"], ["proof (state)\nthis:\n  f k \\<notin> keys p\n  g k \\<notin> keys p\n\ngoal (2 subgoals):\n 1. k \\<in> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k\n 2. k \\<notin> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  f k \\<notin> keys p\n  g k \\<notin> keys p\n\ngoal (1 subgoal):\n 1. lookup (permutep f p) k = lookup (permutep g q) k", "using assms"], ["proof (prove)\nusing this:\n  f k \\<notin> keys p\n  g k \\<notin> keys p\n  f permutes - keys p\n  g permutes - keys p\n  p = q\n\ngoal (1 subgoal):\n 1. lookup (permutep f p) k = lookup (permutep g q) k", "by (auto simp: lookup_permutep permutes_bij in_keys_iff)"], ["proof (state)\nthis:\n  lookup (permutep f p) k = lookup (permutep g q) k\n\ngoal (1 subgoal):\n 1. k \\<in> keys p \\<Longrightarrow>\n    lookup (permutep f p) k = lookup (permutep g q) k", "qed (insert assms, auto simp: lookup_permutep permutes_bij permutes_not_in)"], ["proof (state)\nthis:\n  lookup (permutep f p) k = lookup (permutep g q) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_map_vars_cong:\n  assumes \"f permutes (-vars p)\" \"g permutes (-vars q)\" \"p = q\"\n  shows   \"mpoly_map_vars f p = mpoly_map_vars g (q :: 'a :: zero mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f p = mpoly_map_vars g q", "proof (intro mpoly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_map_vars f p) mon =\n       MPoly_Type.coeff (mpoly_map_vars g q) mon", "fix mon :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_map_vars f p) mon =\n       MPoly_Type.coeff (mpoly_map_vars g q) mon", "show \"coeff (mpoly_map_vars f p) mon = coeff (mpoly_map_vars g q) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "proof (cases \"keys mon \\<subseteq> vars p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon\n 2. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "case True"], ["proof (state)\nthis:\n  keys mon \\<subseteq> vars p\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon\n 2. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "with assms"], ["proof (chain)\npicking this:\n  f permutes - vars p\n  g permutes - vars q\n  p = q\n  keys mon \\<subseteq> vars p", "have \"permutep f mon = permutep g mon\""], ["proof (prove)\nusing this:\n  f permutes - vars p\n  g permutes - vars q\n  p = q\n  keys mon \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. permutep f mon = permutep g mon", "by (intro permutep_cong assms(1,2)[THEN permutes_subset]) auto"], ["proof (state)\nthis:\n  permutep f mon = permutep g mon\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon\n 2. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "thus ?thesis"], ["proof (prove)\nusing this:\n  permutep f mon = permutep g mon\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "using assms"], ["proof (prove)\nusing this:\n  permutep f mon = permutep g mon\n  f permutes - vars p\n  g permutes - vars q\n  p = q\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "by (simp add: coeff_mpoly_map_vars permutes_bij)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars f p) mon =\n  MPoly_Type.coeff (mpoly_map_vars g q) mon\n\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "case False"], ["proof (state)\nthis:\n  \\<not> keys mon \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "hence \"\\<not>(keys mon \\<subseteq> f ` vars q)\" \"\\<not>(keys mon \\<subseteq> g ` vars q)\""], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> f ` vars q &&&\n    \\<not> keys mon \\<subseteq> g ` vars q", "using assms"], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> vars p\n  f permutes - vars p\n  g permutes - vars q\n  p = q\n\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> f ` vars q &&&\n    \\<not> keys mon \\<subseteq> g ` vars q", "by (auto simp: subset_iff permutes_not_in)"], ["proof (state)\nthis:\n  \\<not> keys mon \\<subseteq> f ` vars q\n  \\<not> keys mon \\<subseteq> g ` vars q\n\ngoal (1 subgoal):\n 1. \\<not> keys mon \\<subseteq> vars p \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> f ` vars q\n  \\<not> keys mon \\<subseteq> g ` vars q\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "using assms"], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> f ` vars q\n  \\<not> keys mon \\<subseteq> g ` vars q\n  f permutes - vars p\n  g permutes - vars q\n  p = q\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f p) mon =\n    MPoly_Type.coeff (mpoly_map_vars g q) mon", "by (subst (1 2) coeff_notin_vars)\n         (auto simp: coeff_notin_vars vars_mpoly_map_vars permutes_bij)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars f p) mon =\n  MPoly_Type.coeff (mpoly_map_vars g q) mon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars f p) mon =\n  MPoly_Type.coeff (mpoly_map_vars g q) mon\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Symmetric polynomials\\<close>"], ["", "text \\<open>\n  A polynomial is symmetric on a set of variables if it is invariant under\n  any permutation of that set.\n\\<close>"], ["", "definition symmetric_mpoly :: \"nat set \\<Rightarrow> 'a :: zero mpoly \\<Rightarrow> bool\" where\n  \"symmetric_mpoly A p = (\\<forall>\\<pi>. \\<pi> permutes A \\<longrightarrow> mpoly_map_vars \\<pi> p = p)\""], ["", "lemma symmetric_mpoly_empty [simp, intro]: \"symmetric_mpoly {} p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {} p", "by (simp add: symmetric_mpoly_def)"], ["", "text \\<open>\n  A polynomial is trivially symmetric on any set of variables that do not occur in it.\n\\<close>"], ["", "lemma symmetric_mpoly_orthogonal:\n  assumes \"vars p \\<inter> A = {}\"\n  shows   \"symmetric_mpoly A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A p", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow> mpoly_map_vars \\<pi> p = p", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "with assms"], ["proof (chain)\npicking this:\n  vars p \\<inter> A = {}\n  \\<pi> permutes A", "have \"\\<pi> x = x\" if \"x \\<in> vars p\" for x"], ["proof (prove)\nusing this:\n  vars p \\<inter> A = {}\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<pi> x = x", "using that permutes_not_in[of \\<pi> A x]"], ["proof (prove)\nusing this:\n  vars p \\<inter> A = {}\n  \\<pi> permutes A\n  x \\<in> vars p\n  \\<lbrakk>\\<pi> permutes A; x \\<notin> A\\<rbrakk>\n  \\<Longrightarrow> \\<pi> x = x\n\ngoal (1 subgoal):\n 1. \\<pi> x = x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> vars p \\<Longrightarrow> \\<pi> ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "from assms"], ["proof (chain)\npicking this:\n  vars p \\<inter> A = {}", "have \"mpoly_map_vars \\<pi> p = mpoly_map_vars id p\""], ["proof (prove)\nusing this:\n  vars p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = mpoly_map_vars id p", "by (intro mpoly_map_vars_cong permutes_subset[OF \\<pi>] permutes_id) auto"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = mpoly_map_vars id p\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = mpoly_map_vars id p\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "have \"\\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars id p = p", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars id p = p\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> p = p", "show \"mpoly_map_vars \\<pi> p = p\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> p = p\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symmetric_mpoly_monom [intro]:\n  assumes \"keys m \\<inter> A = {}\"\n  shows   \"symmetric_mpoly A (monom m c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (MPoly_Type.monom m c)", "using assms vars_monom_subset[of m c]"], ["proof (prove)\nusing this:\n  keys m \\<inter> A = {}\n  vars (MPoly_Type.monom m c) \\<subseteq> keys m\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (MPoly_Type.monom m c)", "by (intro symmetric_mpoly_orthogonal) auto"], ["", "lemma symmetric_mpoly_subset:\n  assumes \"symmetric_mpoly A p\" \"B \\<subseteq> A\"\n  shows   \"symmetric_mpoly B p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly B p", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes B \\<longrightarrow> mpoly_map_vars \\<pi> p = p", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes B \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes B \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "assume \"\\<pi> permutes B\""], ["proof (state)\nthis:\n  \\<pi> permutes B\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes B \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "with assms"], ["proof (chain)\npicking this:\n  symmetric_mpoly A p\n  B \\<subseteq> A\n  \\<pi> permutes B", "have \"\\<pi> permutes A\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  B \\<subseteq> A\n  \\<pi> permutes B\n\ngoal (1 subgoal):\n 1. \\<pi> permutes A", "using permutes_subset"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  B \\<subseteq> A\n  \\<pi> permutes B\n  \\<lbrakk>?p permutes ?S; ?S \\<subseteq> ?T\\<rbrakk>\n  \\<Longrightarrow> ?p permutes ?T\n\ngoal (1 subgoal):\n 1. \\<pi> permutes A", "by blast"], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes B \\<Longrightarrow> mpoly_map_vars \\<pi> p = p", "with assms"], ["proof (chain)\npicking this:\n  symmetric_mpoly A p\n  B \\<subseteq> A\n  \\<pi> permutes A", "show \"mpoly_map_vars \\<pi> p = p\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  B \\<subseteq> A\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "by (auto simp: symmetric_mpoly_def)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If a polynomial is symmetric over some set of variables, that set must either be a subset\n  of the variables occurring in the polynomial or disjoint from it.\n\\<close>"], ["", "lemma symmetric_mpoly_imp_orthogonal_or_subset:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "assume \"\\<not>(vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p)\""], ["proof (state)\nthis:\n  \\<not> (vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p)\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p)", "obtain x y where xy: \"x \\<in> vars p \\<inter> A\" \"y \\<in> A - vars p\""], ["proof (prove)\nusing this:\n  \\<not> (vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> vars p \\<inter> A; y \\<in> A - vars p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "define \\<pi> where \"\\<pi> = Fun.swap x y id\""], ["proof (state)\nthis:\n  \\<pi> = Fun.swap x y id\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "from xy"], ["proof (chain)\npicking this:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p", "have \\<pi>: \"\\<pi> permutes A\""], ["proof (prove)\nusing this:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p\n\ngoal (1 subgoal):\n 1. \\<pi> permutes A", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p\n\ngoal (1 subgoal):\n 1. Fun.swap x y id permutes A", "by (intro permutes_swap_id) auto"], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "from xy"], ["proof (chain)\npicking this:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p", "have \"y \\<in> \\<pi> ` vars p\""], ["proof (prove)\nusing this:\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p\n\ngoal (1 subgoal):\n 1. y \\<in> \\<pi> ` vars p", "by (auto simp: \\<pi>_def Fun.swap_def)"], ["proof (state)\nthis:\n  y \\<in> \\<pi> ` vars p\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  y \\<in> \\<pi> ` vars p\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "from \\<pi>"], ["proof (chain)\npicking this:\n  \\<pi> permutes A", "have \"\\<pi> ` vars p = vars (mpoly_map_vars \\<pi> p)\""], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<pi> ` vars p = vars (mpoly_map_vars \\<pi> p)", "by (auto simp: vars_mpoly_map_vars permutes_bij)"], ["proof (state)\nthis:\n  \\<pi> ` vars p = vars (mpoly_map_vars \\<pi> p)\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  \\<pi> ` vars p = vars (mpoly_map_vars \\<pi> p)\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "have \"mpoly_map_vars \\<pi> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "using assms \\<pi>"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "by (simp add: symmetric_mpoly_def)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = p\n\ngoal (1 subgoal):\n 1. \\<not> (vars p \\<inter> A = {} \\<or>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  y \\<in> vars p", "show False"], ["proof (prove)\nusing this:\n  y \\<in> vars p\n\ngoal (1 subgoal):\n 1. False", "using xy"], ["proof (prove)\nusing this:\n  y \\<in> vars p\n  x \\<in> vars p \\<inter> A\n  y \\<in> A - vars p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Symmetric polynomials are closed under ring operations.\n\\<close>"], ["", "lemma symmetric_mpoly_add [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p + q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric_mpoly A p; symmetric_mpoly A q\\<rbrakk>\n    \\<Longrightarrow> symmetric_mpoly A (p + q)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<pi>.\n                \\<pi> permutes A \\<longrightarrow>\n                mpoly_map_vars \\<pi> p = p;\n     \\<forall>\\<pi>.\n        \\<pi> permutes A \\<longrightarrow>\n        mpoly_map_vars \\<pi> q = q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<pi>.\n                         \\<pi> permutes A \\<longrightarrow>\n                         mpoly_map_vars \\<pi> (p + q) = p + q", "by simp"], ["", "lemma symmetric_mpoly_diff [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p - q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric_mpoly A p; symmetric_mpoly A q\\<rbrakk>\n    \\<Longrightarrow> symmetric_mpoly A (p - q)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<pi>.\n                \\<pi> permutes A \\<longrightarrow>\n                mpoly_map_vars \\<pi> p = p;\n     \\<forall>\\<pi>.\n        \\<pi> permutes A \\<longrightarrow>\n        mpoly_map_vars \\<pi> q = q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<pi>.\n                         \\<pi> permutes A \\<longrightarrow>\n                         mpoly_map_vars \\<pi> (p - q) = p - q", "by simp"], ["", "lemma symmetric_mpoly_uminus [intro]: \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (-p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (- p)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> p = p \\<Longrightarrow>\n    \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow> mpoly_map_vars \\<pi> (- p) = - p", "by simp"], ["", "lemma symmetric_mpoly_uminus_iff [simp]: \"symmetric_mpoly A (-p) \\<longleftrightarrow> symmetric_mpoly A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (- p) = symmetric_mpoly A p", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<pi>.\n        \\<pi> permutes A \\<longrightarrow>\n        mpoly_map_vars \\<pi> (- p) = - p) =\n    (\\<forall>\\<pi>.\n        \\<pi> permutes A \\<longrightarrow> mpoly_map_vars \\<pi> p = p)", "by simp"], ["", "lemma symmetric_mpoly_smult [intro]: \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (smult c p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A p \\<Longrightarrow>\n    symmetric_mpoly A (MPoly_Type.smult c p)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> p = p \\<Longrightarrow>\n    \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (MPoly_Type.smult c p) = MPoly_Type.smult c p", "by simp"], ["", "lemma symmetric_mpoly_mult [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A q \\<Longrightarrow> symmetric_mpoly A (p * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric_mpoly A p; symmetric_mpoly A q\\<rbrakk>\n    \\<Longrightarrow> symmetric_mpoly A (p * q)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<pi>.\n                \\<pi> permutes A \\<longrightarrow>\n                mpoly_map_vars \\<pi> p = p;\n     \\<forall>\\<pi>.\n        \\<pi> permutes A \\<longrightarrow>\n        mpoly_map_vars \\<pi> q = q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<pi>.\n                         \\<pi> permutes A \\<longrightarrow>\n                         mpoly_map_vars \\<pi> (p * q) = p * q", "by simp"], ["", "lemma symmetric_mpoly_0 [simp, intro]: \"symmetric_mpoly A 0\"\n  and symmetric_mpoly_1 [simp, intro]: \"symmetric_mpoly A 1\"\n  and symmetric_mpoly_Const [simp, intro]: \"symmetric_mpoly A (Const c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A 0 &&&\n    symmetric_mpoly A 1 &&& symmetric_mpoly A (Const c)", "by (simp_all add: symmetric_mpoly_def)"], ["", "lemma symmetric_mpoly_power [intro]:\n  \"symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (p ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A p \\<Longrightarrow> symmetric_mpoly A (p ^ n)", "by (induction n) (auto intro!: symmetric_mpoly_mult)"], ["", "lemma symmetric_mpoly_sum [intro]:\n  \"(\\<And>i. i \\<in> B \\<Longrightarrow> symmetric_mpoly A (f i)) \\<Longrightarrow> symmetric_mpoly A (sum f B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> B \\<Longrightarrow>\n        symmetric_mpoly A (f i)) \\<Longrightarrow>\n    symmetric_mpoly A (sum f B)", "by (induction B rule: infinite_finite_induct) (auto intro!: symmetric_mpoly_add)"], ["", "lemma symmetric_mpoly_prod [intro]:\n  \"(\\<And>i. i \\<in> B \\<Longrightarrow> symmetric_mpoly A (f i)) \\<Longrightarrow> symmetric_mpoly A (prod f B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> B \\<Longrightarrow>\n        symmetric_mpoly A (f i)) \\<Longrightarrow>\n    symmetric_mpoly A (prod f B)", "by (induction B rule: infinite_finite_induct) (auto intro!: symmetric_mpoly_mult)"], ["", "text \\<open>\n  An symmetric sum or product over polynomials yields a symmetric polynomial:\n\\<close>"], ["", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (sum f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"mpoly_map_vars \\<pi> (sum f X) = (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) =\n    (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>X. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Sum>x\\<in>X. f (g x))", "by (intro sum.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Sum>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Sum>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>g`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g x)) = sum f (g ` X)", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g x)) = sum f (g ` X)", "by (subst sum.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g x)) = sum f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g x)) = sum f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"g ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` X = X", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. g ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X", "show \"mpoly_map_vars \\<pi> (sum f X) = sum f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) = sum f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symmetric_mpoly_symmetric_prod:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (prod f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"mpoly_map_vars \\<pi> (prod f X) = (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) =\n    (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>X. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))", "by (intro prod.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>g`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)", "by (subst prod.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"g ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` X = X", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. g ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X", "show \"mpoly_map_vars \\<pi> (prod f X) = prod f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) = prod f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If $p$ is a polynomial that is symmetric on some subset of variables $A$, then for the leading\n  monomial of $p$, the exponents of these variables are decreasing w.\\,r.\\,t.\\ the variable\n  ordering.\n\\<close>"], ["", "theorem lookup_lead_monom_decreasing:\n  assumes \"symmetric_mpoly A p\"\n  defines \"m \\<equiv> lead_monom p\"\n  assumes \"i \\<in> A\" \"j \\<in> A\" \"i \\<le> j\"\n  shows   \"lookup m i \\<ge> lookup m j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m j \\<le> lookup m i", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lookup m j \\<le> lookup m i\n 2. p \\<noteq> 0 \\<Longrightarrow> lookup m j \\<le> lookup m i", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> lookup m j \\<le> lookup m i\n 2. p \\<noteq> 0 \\<Longrightarrow> lookup m j \\<le> lookup m i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m j \\<le> lookup m i", "proof (intro leI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "assume less: \"lookup m i < lookup m j\""], ["proof (state)\nthis:\n  lookup m i < lookup m j\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "define \\<pi> where \"\\<pi> = Fun.swap i j id\""], ["proof (state)\nthis:\n  \\<pi> = Fun.swap i j id\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  symmetric_mpoly A p\n  m \\<equiv> lead_monom p\n  i \\<in> A\n  j \\<in> A\n  i \\<le> j", "have \\<pi>: \"\\<pi> permutes A\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  m \\<equiv> lead_monom p\n  i \\<in> A\n  j \\<in> A\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<pi> permutes A", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  m \\<equiv> lead_monom p\n  i \\<in> A\n  j \\<in> A\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. Fun.swap i j id permutes A", "by (intro permutes_swap_id) auto"], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "have [simp]: \"\\<pi> \\<circ> \\<pi> = id\" \"\\<pi> i = j\" \"\\<pi> j = i\" \"\\<And>k. k \\<noteq> i \\<Longrightarrow> k \\<noteq> j \\<Longrightarrow> \\<pi> k = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> \\<circ> \\<pi> = id &&& \\<pi> i = j) &&&\n    \\<pi> j = i &&&\n    (\\<And>k.\n        \\<lbrakk>k \\<noteq> i; k \\<noteq> j\\<rbrakk>\n        \\<Longrightarrow> \\<pi> k = k)", "by (auto simp: \\<pi>_def Fun.swap_def fun_eq_iff)"], ["proof (state)\nthis:\n  \\<pi> \\<circ> \\<pi> = id\n  \\<pi> i = j\n  \\<pi> j = i\n  \\<lbrakk>?k \\<noteq> i; ?k \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?k = ?k\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "have \"0 \\<noteq> lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff p", "by simp"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff p\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff p\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "have \"lead_coeff p = MPoly_Type.coeff (mpoly_map_vars \\<pi> p) (permutep \\<pi> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff p =\n    MPoly_Type.coeff (mpoly_map_vars \\<pi> p) (permutep \\<pi> m)", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff p =\n    MPoly_Type.coeff (mpoly_map_vars \\<pi> p) (permutep \\<pi> m)", "by (simp add: lead_coeff_def m_def coeff_mpoly_map_vars\n                            permutes_bij permutep_comp' [symmetric])"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff p =\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> p) (permutep \\<pi> m)\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff p =\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> p) (permutep \\<pi> m)\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "have \"mpoly_map_vars \\<pi> p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "using \\<pi> assms"], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n  symmetric_mpoly A p\n  m \\<equiv> lead_monom p\n  i \\<in> A\n  j \\<in> A\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> p = p", "by (simp add: symmetric_mpoly_def)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> p = p\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<noteq> MPoly_Type.coeff p (permutep \\<pi> m)", "have \"permutep \\<pi> m \\<le> m\""], ["proof (prove)\nusing this:\n  (0::'a) \\<noteq> MPoly_Type.coeff p (permutep \\<pi> m)\n\ngoal (1 subgoal):\n 1. permutep \\<pi> m \\<le> m", "by (auto simp: m_def)"], ["proof (state)\nthis:\n  permutep \\<pi> m \\<le> m\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  permutep \\<pi> m \\<le> m\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "have \"lookup m i < lookup (permutep \\<pi> m) i\"\n              and \"(\\<forall>k<i. lookup m k = lookup (permutep \\<pi> m) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m i < lookup (permutep \\<pi> m) i &&&\n    \\<forall>k<i. lookup m k = lookup (permutep \\<pi> m) k", "using assms \\<pi> less"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  m \\<equiv> lead_monom p\n  i \\<in> A\n  j \\<in> A\n  i \\<le> j\n  \\<pi> permutes A\n  lookup m i < lookup m j\n\ngoal (1 subgoal):\n 1. lookup m i < lookup (permutep \\<pi> m) i &&&\n    \\<forall>k<i. lookup m k = lookup (permutep \\<pi> m) k", "by (auto simp: lookup_permutep permutes_bij)"], ["proof (state)\nthis:\n  lookup m i < lookup (permutep \\<pi> m) i\n  \\<forall>k<i. lookup m k = lookup (permutep \\<pi> m) k\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "hence \"m < permutep \\<pi> m\""], ["proof (prove)\nusing this:\n  lookup m i < lookup (permutep \\<pi> m) i\n  \\<forall>k<i. lookup m k = lookup (permutep \\<pi> m) k\n\ngoal (1 subgoal):\n 1. m < permutep \\<pi> m", "by (auto simp: less_poly_mapping_def less_fun_def)"], ["proof (state)\nthis:\n  m < permutep \\<pi> m\n\ngoal (1 subgoal):\n 1. lookup m i < lookup m j \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  permutep \\<pi> m \\<le> m\n  m < permutep \\<pi> m", "show False"], ["proof (prove)\nusing this:\n  permutep \\<pi> m \\<le> m\n  m < permutep \\<pi> m\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup m j \\<le> lookup m i\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> lookup m j \\<le> lookup m i", "qed (auto simp: m_def)"], ["", "subsection \\<open>The elementary symmetric polynomials\\<close>"], ["", "text \\<open>\n  The $k$-th elementary symmetric polynomial for a finite set of variables $A$, with $k$ ranging\n  between 1 and $|A|$, is the sum of the product of all subsets of $A$ with cardinality $k$:\n\\<close>"], ["", "lift_definition sym_mpoly_aux :: \"nat set \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a :: {zero_neq_one}\" is\n  \"\\<lambda>X k mon. if finite X \\<and> (\\<exists>Y. Y \\<subseteq> X \\<and> card Y = k \\<and> mon = monom_of_set Y) then 1 else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set nat.\n       finite\n        {x. (if finite set \\<and>\n                (\\<exists>Y\\<subseteq>set.\n                    card Y = nat \\<and> x = monom_of_set Y)\n             then 1::'a else (0::'a)) \\<noteq>\n            (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>set nat.\n       finite\n        {x. (if finite set \\<and>\n                (\\<exists>Y\\<subseteq>set.\n                    card Y = nat \\<and> x = monom_of_set Y)\n             then 1::'a else (0::'a)) \\<noteq>\n            (0::'a)}", "fix k :: nat and X :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>set nat.\n       finite\n        {x. (if finite set \\<and>\n                (\\<exists>Y\\<subseteq>set.\n                    card Y = nat \\<and> x = monom_of_set Y)\n             then 1::'a else (0::'a)) \\<noteq>\n            (0::'a)}", "show \"finite {x. (if finite X \\<and> (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y) then 1 else 0) \\<noteq>\n           (0::'a)}\" (is \"finite ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}\n 2. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}\n 2. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "have \"?A \\<subseteq> monom_of_set ` Pow X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if finite X \\<and>\n            (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n         then 1::'a else (0::'a)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> monom_of_set ` Pow X", "by auto"], ["proof (state)\nthis:\n  {x. (if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n       then 1::'a else (0::'a)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> monom_of_set ` Pow X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}\n 2. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "moreover"], ["proof (state)\nthis:\n  {x. (if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n       then 1::'a else (0::'a)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> monom_of_set ` Pow X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}\n 2. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "from True"], ["proof (chain)\npicking this:\n  finite X", "have \"finite (monom_of_set ` Pow X)\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. finite (monom_of_set ` Pow X)", "by simp"], ["proof (state)\nthis:\n  finite (monom_of_set ` Pow X)\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}\n 2. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "ultimately"], ["proof (chain)\npicking this:\n  {x. (if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n       then 1::'a else (0::'a)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> monom_of_set ` Pow X\n  finite (monom_of_set ` Pow X)", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. (if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n       then 1::'a else (0::'a)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> monom_of_set ` Pow X\n  finite (monom_of_set ` Pow X)\n\ngoal (1 subgoal):\n 1. finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite\n   {x. (if finite X \\<and>\n           (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n        then 1::'a else (0::'a)) \\<noteq>\n       (0::'a)}\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    finite\n     {x. (if finite X \\<and>\n             (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n          then 1::'a else (0::'a)) \\<noteq>\n         (0::'a)}", "qed auto"], ["proof (state)\nthis:\n  finite\n   {x. (if finite X \\<and>\n           (\\<exists>Y\\<subseteq>X. card Y = k \\<and> x = monom_of_set Y)\n        then 1::'a else (0::'a)) \\<noteq>\n       (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_sym_mpoly_aux:\n  \"Poly_Mapping.lookup (sym_mpoly_aux X k) mon =\n     (if finite X \\<and> (\\<exists>Y. Y \\<subseteq> X \\<and> card Y = k \\<and> mon = monom_of_set Y) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (sym_mpoly_aux X k) mon =\n    (if finite X \\<and>\n        (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n     then 1::'a else (0::'a))", "by transfer' simp"], ["", "lemma lookup_sym_mpoly_aux_monom_of_set [simp]:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y = k\"\n  shows   \"Poly_Mapping.lookup (sym_mpoly_aux X k) (monom_of_set Y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (sym_mpoly_aux X k) (monom_of_set Y) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  Y \\<subseteq> X\n  card Y = k\n\ngoal (1 subgoal):\n 1. lookup (sym_mpoly_aux X k) (monom_of_set Y) = (1::'a)", "by (auto simp: lookup_sym_mpoly_aux)"], ["", "lemma keys_sym_mpoly_aux: \"m \\<in> keys (sym_mpoly_aux A k) \\<Longrightarrow> keys m \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> keys (sym_mpoly_aux A k) \\<Longrightarrow> keys m \\<subseteq> A", "by transfer' (auto split: if_splits simp: keys_monom_of_set)"], ["", "lift_definition sym_mpoly :: \"nat set \\<Rightarrow> nat \\<Rightarrow> 'a :: {zero_neq_one} mpoly\" is\n  \"sym_mpoly_aux\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma vars_sym_mpoly_subset: \"vars (sym_mpoly A k) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (sym_mpoly A k) \\<subseteq> A", "using keys_sym_mpoly_aux"], ["proof (prove)\nusing this:\n  ?m \\<in> keys (sym_mpoly_aux ?A ?k) \\<Longrightarrow>\n  keys ?m \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. vars (sym_mpoly A k) \\<subseteq> A", "by (auto simp: vars_def sym_mpoly.rep_eq)"], ["", "lemma coeff_sym_mpoly:\n  \"MPoly_Type.coeff (sym_mpoly X k) mon =\n     (if finite X \\<and> (\\<exists>Y. Y \\<subseteq> X \\<and> card Y = k \\<and> mon = monom_of_set Y) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) mon =\n    (if finite X \\<and>\n        (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n     then 1::'a else (0::'a))", "by transfer' (simp add: lookup_sym_mpoly_aux)"], ["", "lemma sym_mpoly_infinite: \"\\<not>finite A \\<Longrightarrow> sym_mpoly A k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> sym_mpoly A k = 0", "by (transfer, transfer) auto"], ["", "lemma sym_mpoly_altdef: \"sym_mpoly A k = (\\<Sum>X | X \\<subseteq> A \\<and> card X = k. monom (monom_of_set X) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "proof (cases \"finite A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "case False"], ["proof (state)\nthis:\n  infinite A\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "hence *: \"infinite {X. X \\<subseteq> A \\<and> infinite X}\""], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> infinite X}", "by (rule infinite_infinite_subsets)"], ["proof (state)\nthis:\n  infinite {X. X \\<subseteq> A \\<and> infinite X}\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "have \"infinite {X. X \\<subseteq> A \\<and> card X = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> card X = 0}", "by (rule infinite_super[OF _ *]) auto"], ["proof (state)\nthis:\n  infinite {X. X \\<subseteq> A \\<and> card X = 0}\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "moreover"], ["proof (state)\nthis:\n  infinite {X. X \\<subseteq> A \\<and> card X = 0}\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "have **: \"infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\" if \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "using that infinite_card_subsets[of A k] False"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  \\<lbrakk>infinite A; 0 < k\\<rbrakk>\n  \\<Longrightarrow> infinite\n                     {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0 \\<Longrightarrow>\n  infinite {X. X \\<subseteq> A \\<and> finite X \\<and> card X = k}\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "have \"infinite {X. X \\<subseteq> A \\<and> card X = k}\" if \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {X. X \\<subseteq> A \\<and> card X = k}", "by (rule infinite_super[OF _ **[OF that]]) auto"], ["proof (state)\nthis:\n  k \\<noteq> 0 \\<Longrightarrow>\n  infinite {X. X \\<subseteq> A \\<and> card X = k}\n\ngoal (2 subgoals):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))\n 2. infinite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "ultimately"], ["proof (chain)\npicking this:\n  infinite {X. X \\<subseteq> A \\<and> card X = 0}\n  k \\<noteq> 0 \\<Longrightarrow>\n  infinite {X. X \\<subseteq> A \\<and> card X = k}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite {X. X \\<subseteq> A \\<and> card X = 0}\n  k \\<noteq> 0 \\<Longrightarrow>\n  infinite {X. X \\<subseteq> A \\<and> card X = k}\n\ngoal (1 subgoal):\n 1. sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "using False"], ["proof (prove)\nusing this:\n  infinite {X. X \\<subseteq> A \\<and> card X = 0}\n  k \\<noteq> 0 \\<Longrightarrow>\n  infinite {X. X \\<subseteq> A \\<and> card X = k}\n  infinite A\n\ngoal (1 subgoal):\n 1. sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "by (cases \"k = 0\") (simp_all add: sym_mpoly_infinite)"], ["proof (state)\nthis:\n  sym_mpoly A k =\n  (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n     MPoly_Type.monom (monom_of_set X) (1::'a))\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "case True"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly A k =\n    (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n       MPoly_Type.monom (monom_of_set X) (1::'a))", "proof (intro mpoly_eqI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (sym_mpoly A k) mon =\n       MPoly_Type.coeff\n        (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n           MPoly_Type.monom (monom_of_set X) (1::'a))\n        mon", "case (1 m)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (sym_mpoly A k) mon =\n       MPoly_Type.coeff\n        (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n           MPoly_Type.monom (monom_of_set X) (1::'a))\n        mon", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "proof (cases \"\\<exists>X. X \\<subseteq> A \\<and> card X = k \\<and> m = monom_of_set X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m\n 2. \\<not> (\\<exists>X\\<subseteq>A.\n               card X = k \\<and> m = monom_of_set X) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>X\\<subseteq>A. card X = k \\<and> m = monom_of_set X)\n\ngoal (2 subgoals):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m\n 2. \\<not> (\\<exists>X\\<subseteq>A.\n               card X = k \\<and> m = monom_of_set X) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>X\\<subseteq>A. card X = k \\<and> m = monom_of_set X)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "by (auto simp: coeff_sym_mpoly coeff_sum coeff_monom)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly A k) m =\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::'a))\n   m\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "case True"], ["proof (state)\nthis:\n  \\<exists>X\\<subseteq>A. card X = k \\<and> m = monom_of_set X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<subseteq>A. card X = k \\<and> m = monom_of_set X", "obtain X where X: \"X \\<subseteq> A\" \"card X = k\" \"m = monom_of_set X\""], ["proof (prove)\nusing this:\n  \\<exists>X\\<subseteq>A. card X = k \\<and> m = monom_of_set X\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> A; card X = k; m = monom_of_set X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X \\<subseteq> A\n  card X = k\n  m = monom_of_set X\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "have \"coeff (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n               monom (monom_of_set X) 1) m = (\\<Sum>X\\<in>{X}. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'b))\n     m =\n    (\\<Sum>X\\<in>{X}. (1::'b))", "unfolding coeff_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{X. X \\<subseteq> A \\<and> card X = k}.\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m) =\n    (\\<Sum>X\\<in>{X}. (1::'b))", "proof (intro sum.mono_neutral_cong_right ballI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {X. X \\<subseteq> A \\<and> card X = k}\n 2. {X} \\<subseteq> {X. X \\<subseteq> A \\<and> card X = k}\n 3. \\<And>i.\n       i \\<in> {X. X \\<subseteq> A \\<and> card X = k} -\n               {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set i) (1::'b)) m =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m =\n       (1::'b)", "fix Y"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {X. X \\<subseteq> A \\<and> card X = k}\n 2. {X} \\<subseteq> {X. X \\<subseteq> A \\<and> card X = k}\n 3. \\<And>i.\n       i \\<in> {X. X \\<subseteq> A \\<and> card X = k} -\n               {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set i) (1::'b)) m =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m =\n       (1::'b)", "assume Y: \"Y \\<in> {X. X \\<subseteq> A \\<and> card X = k} - {X}\""], ["proof (state)\nthis:\n  Y \\<in> {X. X \\<subseteq> A \\<and> card X = k} - {X}\n\ngoal (4 subgoals):\n 1. finite {X. X \\<subseteq> A \\<and> card X = k}\n 2. {X} \\<subseteq> {X. X \\<subseteq> A \\<and> card X = k}\n 3. \\<And>i.\n       i \\<in> {X. X \\<subseteq> A \\<and> card X = k} -\n               {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set i) (1::'b)) m =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m =\n       (1::'b)", "hence \"X = Y\" if \"monom_of_set X = monom_of_set Y\""], ["proof (prove)\nusing this:\n  Y \\<in> {X. X \\<subseteq> A \\<and> card X = k} - {X}\n\ngoal (1 subgoal):\n 1. X = Y", "using that finite_subset[OF X(1)] finite_subset[of Y A] \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  Y \\<in> {X. X \\<subseteq> A \\<and> card X = k} - {X}\n  monom_of_set X = monom_of_set Y\n  finite A \\<Longrightarrow> finite X\n  \\<lbrakk>Y \\<subseteq> A; finite A\\<rbrakk> \\<Longrightarrow> finite Y\n  finite A\n\ngoal (1 subgoal):\n 1. X = Y", "by auto"], ["proof (state)\nthis:\n  monom_of_set X = monom_of_set Y \\<Longrightarrow> X = Y\n\ngoal (4 subgoals):\n 1. finite {X. X \\<subseteq> A \\<and> card X = k}\n 2. {X} \\<subseteq> {X. X \\<subseteq> A \\<and> card X = k}\n 3. \\<And>i.\n       i \\<in> {X. X \\<subseteq> A \\<and> card X = k} -\n               {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set i) (1::'b)) m =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m =\n       (1::'b)", "thus \"coeff (monom (monom_of_set Y) 1) m = 0\""], ["proof (prove)\nusing this:\n  monom_of_set X = monom_of_set Y \\<Longrightarrow> X = Y\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set Y) (1::'c)) m = (0::'c)", "using X Y"], ["proof (prove)\nusing this:\n  monom_of_set X = monom_of_set Y \\<Longrightarrow> X = Y\n  X \\<subseteq> A\n  card X = k\n  m = monom_of_set X\n  Y \\<in> {X. X \\<subseteq> A \\<and> card X = k} - {X}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.monom (monom_of_set Y) (1::'c)) m = (0::'c)", "by (auto simp: coeff_monom when_def )"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.monom (monom_of_set Y) (1::?'c1)) m =\n  (0::?'c1)\n\ngoal (3 subgoals):\n 1. finite {X. X \\<subseteq> A \\<and> card X = k}\n 2. {X} \\<subseteq> {X. X \\<subseteq> A \\<and> card X = k}\n 3. \\<And>x.\n       x \\<in> {X} \\<Longrightarrow>\n       MPoly_Type.coeff (MPoly_Type.monom (monom_of_set x) (1::'b)) m =\n       (1::'b)", "qed (insert X \\<open>finite A\\<close>, auto simp: coeff_monom)"], ["proof (state)\nthis:\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::?'b1))\n   m =\n  (\\<Sum>X\\<in>{X}. (1::?'b1))\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<subseteq>A.\n       card X = k \\<and> m = monom_of_set X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::?'b1))\n   m =\n  (\\<Sum>X\\<in>{X}. (1::?'b1))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::?'b1))\n   m =\n  (\\<Sum>X\\<in>{X}. (1::?'b1))\n  finite A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) m =\n    MPoly_Type.coeff\n     (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n        MPoly_Type.monom (monom_of_set X) (1::'a))\n     m", "by (auto simp: coeff_sym_mpoly coeff_sum coeff_monom)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly A k) m =\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::'a))\n   m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly A k) m =\n  MPoly_Type.coeff\n   (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n      MPoly_Type.monom (monom_of_set X) (1::'a))\n   m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sym_mpoly A k =\n  (\\<Sum>X | X \\<subseteq> A \\<and> card X = k.\n     MPoly_Type.monom (monom_of_set X) (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_sym_mpoly_monom_of_set [simp]:\n  assumes \"finite X\" \"Y \\<subseteq> X\" \"card Y = k\"\n  shows   \"MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n  Y \\<subseteq> X\n  card Y = k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set Y) = (1::'a)", "by (auto simp: coeff_sym_mpoly)"], ["", "lemma coeff_sym_mpoly_0: \"coeff (sym_mpoly X k) 0 = (if finite X \\<and> k = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "consider \"finite X\" \"k = 0\" | \"finite X\" \"k \\<noteq> 0\" | \"infinite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>finite X; k = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk> \\<Longrightarrow> thesis;\n     infinite X \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>finite X; k = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   infinite X \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>finite X; k = 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   infinite X \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>finite X; k = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 3. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "assume \"finite X\" \"k = 0\""], ["proof (state)\nthis:\n  finite X\n  k = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite X; k = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 3. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "hence \"coeff (sym_mpoly X k) (monom_of_set {}) = 1\""], ["proof (prove)\nusing this:\n  finite X\n  k = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) (monom_of_set {}) = (1::'b)", "by (subst coeff_sym_mpoly_monom_of_set) auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set {}) = (1::?'b1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite X; k = 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 3. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) (monom_of_set {}) = (1::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "unfolding monom_of_set_empty"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) 0 = (1::?'b1)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "using \\<open>finite X\\<close> \\<open>k = 0\\<close>"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly X k) 0 = (1::?'b1)\n  finite X\n  k = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) 0 =\n  (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "assume \"finite X\" \"k \\<noteq> 0\""], ["proof (state)\nthis:\n  finite X\n  k \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "hence \"\\<not>(\\<exists>Y. finite Y \\<and> Y \\<subseteq> X \\<and> card Y = k \\<and> monom_of_set Y = 0)\""], ["proof (prove)\nusing this:\n  finite X\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>Y.\n       finite Y \\<and>\n       Y \\<subseteq> X \\<and> card Y = k \\<and> monom_of_set Y = 0", "by auto"], ["proof (state)\nthis:\n  \\<nexists>Y.\n     finite Y \\<and>\n     Y \\<subseteq> X \\<and> card Y = k \\<and> monom_of_set Y = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite X; k \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MPoly_Type.coeff (sym_mpoly X k) 0 =\n                      (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n 2. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>Y.\n     finite Y \\<and>\n     Y \\<subseteq> X \\<and> card Y = k \\<and> monom_of_set Y = 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "using \\<open>k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<nexists>Y.\n     finite Y \\<and>\n     Y \\<subseteq> X \\<and> card Y = k \\<and> monom_of_set Y = 0\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "by (auto simp: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) 0 =\n  (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "assume \"infinite X\""], ["proof (state)\nthis:\n  infinite X\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  infinite X\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly X k) 0 =\n    (if finite X \\<and> k = 0 then 1::'a else (0::'a))", "by (simp add: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) 0 =\n  (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly X k) 0 =\n  (if finite X \\<and> k = 0 then 1::'a else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symmetric_sym_mpoly [intro]:\n  assumes \"A \\<subseteq> B\"\n  shows   \"symmetric_mpoly A (sym_mpoly B k :: 'a :: zero_neq_one mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (sym_mpoly B k)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (sym_mpoly B k) = sym_mpoly B k", "proof (safe intro!: mpoly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "fix \\<pi> and mon :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "from \\<pi>"], ["proof (chain)\npicking this:\n  \\<pi> permutes A", "have \\<pi>': \"\\<pi> permutes B\""], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<pi> permutes B", "by (rule permutes_subset) fact"], ["proof (state)\nthis:\n  \\<pi> permutes B\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "from \\<pi>"], ["proof (chain)\npicking this:\n  \\<pi> permutes A", "have \"MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k :: 'a mpoly)) mon =\n                 MPoly_Type.coeff (sym_mpoly B k :: 'a mpoly) (permutep \\<pi> mon)\""], ["proof (prove)\nusing this:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n    MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon)", "by (simp add: coeff_mpoly_map_vars permutes_bij)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "have \"\\<dots> = 1 \\<longleftrightarrow> MPoly_Type.coeff (sym_mpoly B k :: 'a mpoly) mon = 1\"\n    (is \"?lhs = 1 \\<longleftrightarrow> ?rhs = 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)) =\n    (MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n 2. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "assume \"?rhs = 1\""], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n\ngoal (2 subgoals):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n 2. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "obtain Y where \"finite B\" and Y: \"Y \\<subseteq> B\" \"card Y = k\" \"mon = monom_of_set Y\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>finite B; Y \\<subseteq> B; card Y = k;\n         mon = monom_of_set Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: coeff_sym_mpoly split: if_splits)"], ["proof (state)\nthis:\n  finite B\n  Y \\<subseteq> B\n  card Y = k\n  mon = monom_of_set Y\n\ngoal (2 subgoals):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n 2. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "with \\<pi>'"], ["proof (chain)\npicking this:\n  \\<pi> permutes B\n  finite B\n  Y \\<subseteq> B\n  card Y = k\n  mon = monom_of_set Y", "have \"\\<pi> -` Y \\<subseteq> B\" \"card (\\<pi> -` Y) = k\" \"permutep \\<pi> mon = monom_of_set (\\<pi> -` Y)\""], ["proof (prove)\nusing this:\n  \\<pi> permutes B\n  finite B\n  Y \\<subseteq> B\n  card Y = k\n  mon = monom_of_set Y\n\ngoal (1 subgoal):\n 1. \\<pi> -` Y \\<subseteq> B &&&\n    card (\\<pi> -` Y) = k &&& permutep \\<pi> mon = monom_of_set (\\<pi> -` Y)", "by (auto simp: permutes_in_image card_vimage_inj permutep_monom_of_set\n                     permutes_bij permutes_inj permutes_surj)"], ["proof (state)\nthis:\n  \\<pi> -` Y \\<subseteq> B\n  card (\\<pi> -` Y) = k\n  permutep \\<pi> mon = monom_of_set (\\<pi> -` Y)\n\ngoal (2 subgoals):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n 2. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "thus \"?lhs = 1\""], ["proof (prove)\nusing this:\n  \\<pi> -` Y \\<subseteq> B\n  card (\\<pi> -` Y) = k\n  permutep \\<pi> mon = monom_of_set (\\<pi> -` Y)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "using \\<open>finite B\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> -` Y \\<subseteq> B\n  card (\\<pi> -` Y) = k\n  permutep \\<pi> mon = monom_of_set (\\<pi> -` Y)\n  finite B\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "by (auto simp: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "assume \"?lhs = 1\""], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "then"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)", "obtain Y where \"finite B\" and Y: \"Y \\<subseteq> B\" \"card Y = k\" \"permutep \\<pi> mon = monom_of_set Y\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>finite B; Y \\<subseteq> B; card Y = k;\n         permutep \\<pi> mon = monom_of_set Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: coeff_sym_mpoly split: if_splits)"], ["proof (state)\nthis:\n  finite B\n  Y \\<subseteq> B\n  card Y = k\n  permutep \\<pi> mon = monom_of_set Y\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "from Y(1)"], ["proof (chain)\npicking this:\n  Y \\<subseteq> B", "have \"inj_on \\<pi> Y\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> B\n\ngoal (1 subgoal):\n 1. inj_on \\<pi> Y", "using inj_on_subset[of \\<pi> UNIV Y] \\<pi>'"], ["proof (prove)\nusing this:\n  Y \\<subseteq> B\n  \\<lbrakk>inj \\<pi>; Y \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> inj_on \\<pi> Y\n  \\<pi> permutes B\n\ngoal (1 subgoal):\n 1. inj_on \\<pi> Y", "by (auto simp: permutes_inj)"], ["proof (state)\nthis:\n  inj_on \\<pi> Y\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "with Y \\<pi>'"], ["proof (chain)\npicking this:\n  Y \\<subseteq> B\n  card Y = k\n  permutep \\<pi> mon = monom_of_set Y\n  \\<pi> permutes B\n  inj_on \\<pi> Y", "have \"\\<pi> ` Y \\<subseteq> B\" \"card (\\<pi> ` Y) = k\" \"mon = monom_of_set (\\<pi> ` Y)\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> B\n  card Y = k\n  permutep \\<pi> mon = monom_of_set Y\n  \\<pi> permutes B\n  inj_on \\<pi> Y\n\ngoal (1 subgoal):\n 1. \\<pi> ` Y \\<subseteq> B &&&\n    card (\\<pi> ` Y) = k &&& mon = monom_of_set (\\<pi> ` Y)", "by (auto simp: permutes_in_image card_image permutep_monom_of_set\n               permutes_bij permutes_inj permutes_surj)"], ["proof (state)\nthis:\n  \\<pi> ` Y \\<subseteq> B\n  card (\\<pi> ` Y) = k\n  mon = monom_of_set (\\<pi> ` Y)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    (1::'a) \\<Longrightarrow>\n    MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "thus \"?rhs = 1\""], ["proof (prove)\nusing this:\n  \\<pi> ` Y \\<subseteq> B\n  card (\\<pi> ` Y) = k\n  mon = monom_of_set (\\<pi> ` Y)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "using \\<open>finite B\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> ` Y \\<subseteq> B\n  card (\\<pi> ` Y) = k\n  mon = monom_of_set (\\<pi> ` Y)\n  finite B\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)", "by (auto simp: coeff_sym_mpoly)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)) =\n  (MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "hence \"?lhs = ?rhs\""], ["proof (prove)\nusing this:\n  (MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) = (1::'a)) =\n  (MPoly_Type.coeff (sym_mpoly B k) mon = (1::'a))\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n    MPoly_Type.coeff (sym_mpoly B k) mon", "by (auto simp: coeff_sym_mpoly split: if_splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly B k) (permutep \\<pi> mon) =\n  MPoly_Type.coeff (sym_mpoly B k) mon\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> mon.\n       \\<pi> permutes A \\<Longrightarrow>\n       MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n       MPoly_Type.coeff (sym_mpoly B k) mon", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n  MPoly_Type.coeff (sym_mpoly B k) mon", "show \"MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k :: 'a mpoly)) mon =\n                  MPoly_Type.coeff (sym_mpoly B k :: 'a mpoly) mon\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n  MPoly_Type.coeff (sym_mpoly B k) mon\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n    MPoly_Type.coeff (sym_mpoly B k) mon", "."], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars \\<pi> (sym_mpoly B k)) mon =\n  MPoly_Type.coeff (sym_mpoly B k) mon\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_sym_mpoly:\n  assumes \"finite X\"\n  shows   \"insertion f (sym_mpoly X k) = (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (sym_mpoly X k) =\n    (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. insertion f (sym_mpoly X k) =\n    (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)", "proof (transfer, transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "fix f :: \"nat \\<Rightarrow> 'a\" and k :: nat and X :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "assume X: \"finite X\""], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "have \"insertion_fun f (\\<lambda>mon.\n            if finite X \\<and> (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y) then 1 else 0) =\n        (\\<Sum>m. (\\<Prod>v. f v ^ poly_mapping.lookup m v) when (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_fun f\n     (\\<lambda>mon.\n         if finite X \\<and>\n            (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n         then 1::'a else (0::'a)) =\n    (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n              (\\<exists>Y\\<subseteq>X.\n                  card Y = k \\<and> m = monom_of_set Y))", "by (auto simp add: insertion_fun_def X when_def intro!: Sum_any.cong)"], ["proof (state)\nthis:\n  insertion_fun f\n   (\\<lambda>mon.\n       if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n       then 1::'a else (0::'a)) =\n  (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n            (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "also"], ["proof (state)\nthis:\n  insertion_fun f\n   (\\<lambda>mon.\n       if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n       then 1::'a else (0::'a)) =\n  (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n            (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "have \"\\<dots> = (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y. (\\<Prod>v. f v ^ poly_mapping.lookup m v) when (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n              (\\<exists>Y\\<subseteq>X.\n                  card Y = k \\<and> m = monom_of_set Y)) =\n    (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n       (\\<Prod>v. f v ^ lookup m v) when\n       (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))", "by (rule Sum_any.expand_superset) (use X in auto)"], ["proof (state)\nthis:\n  (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n            (\\<exists>Y\\<subseteq>X.\n                card Y = k \\<and> m = monom_of_set Y)) =\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     (\\<Prod>v. f v ^ lookup m v) when\n     (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "also"], ["proof (state)\nthis:\n  (\\<Sum>m. (\\<Prod>v. f v ^ lookup m v) when\n            (\\<exists>Y\\<subseteq>X.\n                card Y = k \\<and> m = monom_of_set Y)) =\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     (\\<Prod>v. f v ^ lookup m v) when\n     (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y))\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "have \"\\<dots> = (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y. (\\<Prod>v. f v ^ poly_mapping.lookup m v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n       (\\<Prod>v. f v ^ lookup m v) when\n       (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y)) =\n    (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n       \\<Prod>v. f v ^ lookup m v)", "by (intro sum.cong) (auto simp: when_def)"], ["proof (state)\nthis:\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     (\\<Prod>v. f v ^ lookup m v) when\n     (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y)) =\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     \\<Prod>v. f v ^ lookup m v)\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     (\\<Prod>v. f v ^ lookup m v) when\n     (\\<exists>Y\\<subseteq>X. card Y = k \\<and> m = monom_of_set Y)) =\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     \\<Prod>v. f v ^ lookup m v)\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "have \"\\<dots> = (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. (\\<Prod>v. f v ^ poly_mapping.lookup (monom_of_set Y) v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n       \\<Prod>v. f v ^ lookup m v) =\n    (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k.\n       \\<Prod>v. f v ^ lookup (monom_of_set Y) v)", "by (rule sum.reindex_bij_witness[of _ monom_of_set keys]) (auto simp: finite_subset[OF _ X])"], ["proof (state)\nthis:\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     \\<Prod>v. f v ^ lookup m v) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k.\n     \\<Prod>v. f v ^ lookup (monom_of_set Y) v)\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | \\<exists>Y\\<in>Pow X. card Y = k \\<and> m = monom_of_set Y.\n     \\<Prod>v. f v ^ lookup m v) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k.\n     \\<Prod>v. f v ^ lookup (monom_of_set Y) v)\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "have \"\\<dots> = (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. \\<Prod>v\\<in>Y. f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k.\n       \\<Prod>v. f v ^ lookup (monom_of_set Y) v) =\n    (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)", "proof (intro sum.cong when_cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "case (1 Y)"], ["proof (state)\nthis:\n  Y \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "hence \"finite Y\""], ["proof (prove)\nusing this:\n  Y \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k}\n\ngoal (1 subgoal):\n 1. finite Y", "by (auto dest: finite_subset[OF _ X])"], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "with 1"], ["proof (chain)\npicking this:\n  Y \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k}\n  finite Y", "have \"(\\<Prod>v. f v ^ poly_mapping.lookup (monom_of_set Y) v) =\n                   (\\<Prod>v::nat. if v \\<in> Y then f v else 1)\""], ["proof (prove)\nusing this:\n  Y \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k}\n  finite Y\n\ngoal (1 subgoal):\n 1. (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) =\n    (\\<Prod>v. if v \\<in> Y then f v else (1::'a))", "by (intro Prod_any.cong) (auto simp: lookup_monom_of_set)"], ["proof (state)\nthis:\n  (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) =\n  (\\<Prod>v. if v \\<in> Y then f v else (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "also"], ["proof (state)\nthis:\n  (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) =\n  (\\<Prod>v. if v \\<in> Y then f v else (1::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "have \"\\<dots> = (\\<Prod>v\\<in>Y. f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>v. if v \\<in> Y then f v else (1::'a)) = prod f Y", "by (rule Prod_any.conditionalize [symmetric]) fact+"], ["proof (state)\nthis:\n  (\\<Prod>v. if v \\<in> Y then f v else (1::'a)) = prod f Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {Y. Y \\<subseteq> X \\<and> card Y = k} \\<Longrightarrow>\n       (\\<Prod>v. f v ^ lookup (monom_of_set x) v) = prod f x", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) = prod f Y", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) = prod f Y\n\ngoal (1 subgoal):\n 1. (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) = prod f Y", "."], ["proof (state)\nthis:\n  (\\<Prod>v. f v ^ lookup (monom_of_set Y) v) = prod f Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k.\n     \\<Prod>v. f v ^ lookup (monom_of_set Y) v) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\n\ngoal (1 subgoal):\n 1. \\<And>X f k Xa.\n       \\<lbrakk>finite X; finite Xa\\<rbrakk>\n       \\<Longrightarrow> insertion_fun f\n                          (\\<lambda>mon.\n                              if finite X \\<and>\n                                 (\\<exists>Y\\<subseteq>X.\n                                     card Y = k \\<and> mon = monom_of_set Y)\n                              then 1::'a else (0::'a)) =\n                         sum (prod f) {Y. Y \\<subseteq> X \\<and> card Y = k}", "finally"], ["proof (chain)\npicking this:\n  insertion_fun f\n   (\\<lambda>mon.\n       if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n       then 1::'a else (0::'a)) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)", "show \"insertion_fun f\n                   (\\<lambda>mon. if finite X \\<and> (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y) then 1 else 0) =\n                 (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\""], ["proof (prove)\nusing this:\n  insertion_fun f\n   (\\<lambda>mon.\n       if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n       then 1::'a else (0::'a)) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\n\ngoal (1 subgoal):\n 1. insertion_fun f\n     (\\<lambda>mon.\n         if finite X \\<and>\n            (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n         then 1::'a else (0::'a)) =\n    (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)", "."], ["proof (state)\nthis:\n  insertion_fun f\n   (\\<lambda>mon.\n       if finite X \\<and>\n          (\\<exists>Y\\<subseteq>X. card Y = k \\<and> mon = monom_of_set Y)\n       then 1::'a else (0::'a)) =\n  (\\<Sum>Y | Y \\<subseteq> X \\<and> card Y = k. prod f Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_mpoly_nz [simp]:\n  assumes \"finite A\" \"k \\<le> card A\"\n  shows   \"sym_mpoly A k \\<noteq> (0 :: 'a :: zero_neq_one mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym_mpoly A k \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sym_mpoly A k \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  k \\<le> card A", "obtain B where B: \"B \\<subseteq> A\" \"card B = k\""], ["proof (prove)\nusing this:\n  finite A\n  k \\<le> card A\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> A; card B = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_subset_of_card"], ["proof (prove)\nusing this:\n  finite A\n  k \\<le> card A\n  \\<lbrakk>finite ?A; ?k \\<le> card ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B\\<subseteq>?A. card B = ?k\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> A; card B = k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  card B = k\n\ngoal (1 subgoal):\n 1. sym_mpoly A k \\<noteq> 0", "with assms"], ["proof (chain)\npicking this:\n  finite A\n  k \\<le> card A\n  B \\<subseteq> A\n  card B = k", "have \"coeff (sym_mpoly A k :: 'a mpoly) (monom_of_set B) = 1\""], ["proof (prove)\nusing this:\n  finite A\n  k \\<le> card A\n  B \\<subseteq> A\n  card B = k\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) (monom_of_set B) = (1::'a)", "by (intro coeff_sym_mpoly_monom_of_set)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (sym_mpoly A k) (monom_of_set B) = (1::'a)\n\ngoal (1 subgoal):\n 1. sym_mpoly A k \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly A k) (monom_of_set B) = (1::'a)\n\ngoal (1 subgoal):\n 1. sym_mpoly A k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  sym_mpoly A k \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_sym_mpoly_0_or_1: \"coeff (sym_mpoly A k) m \\<in> {0, 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) m \\<in> {0::'a, 1::'a}", "by (transfer, transfer) auto"], ["", "lemma lead_coeff_sym_mpoly [simp]:\n  assumes \"finite A\" \"k \\<le> card A\"\n  shows   \"lead_coeff (sym_mpoly A k) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  k \\<le> card A", "have \"lead_coeff (sym_mpoly A k) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  k \\<le> card A\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) \\<noteq> (0::'b)", "by simp"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A k) \\<noteq> (0::?'b1)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A k) \\<noteq> (0::?'b1)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)", "using coeff_sym_mpoly_0_or_1[of A k \"lead_monom (sym_mpoly A k)\"]"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A k) \\<noteq> (0::?'b1)\n  MPoly_Type.coeff (sym_mpoly A k) (lead_monom (sym_mpoly A k))\n  \\<in> {0::?'a, 1::?'a}\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)", "unfolding lead_coeff_def"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly A k) (lead_monom (sym_mpoly A k)) \\<noteq>\n  (0::?'b1)\n  MPoly_Type.coeff (sym_mpoly A k) (lead_monom (sym_mpoly A k))\n  \\<in> {0::?'a, 1::?'a}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (sym_mpoly A k) (lead_monom (sym_mpoly A k)) = (1::'a)", "by blast"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A k) = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_sym_mpoly:\n  assumes \"sorted xs\" \"distinct xs\" \"k \\<le> length xs\"\n  shows   \"lead_monom (sym_mpoly (set xs) k :: 'a :: zero_neq_one mpoly) =\n             monom_of_set (set (take k xs))\" (is \"lead_monom ?p = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "let ?m = \"lead_monom ?p\""], ["proof (state)\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have sym: \"symmetric_mpoly (set xs) (sym_mpoly (set xs) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly (set xs) (sym_mpoly (set xs) k)", "by (intro symmetric_sym_mpoly) auto"], ["proof (state)\nthis:\n  symmetric_mpoly (set xs) (sym_mpoly (set xs) k)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "from assms"], ["proof (chain)\npicking this:\n  sorted xs\n  distinct xs\n  k \\<le> length xs", "have [simp]: \"card (set xs) = length xs\""], ["proof (prove)\nusing this:\n  sorted xs\n  distinct xs\n  k \\<le> length xs\n\ngoal (1 subgoal):\n 1. card (set xs) = length xs", "by (subst distinct_card) auto"], ["proof (state)\nthis:\n  card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "from assms"], ["proof (chain)\npicking this:\n  sorted xs\n  distinct xs\n  k \\<le> length xs", "have \"lead_coeff ?p = 1\""], ["proof (prove)\nusing this:\n  sorted xs\n  distinct xs\n  k \\<le> length xs\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly (set xs) k) = (1::'a)", "by (subst lead_coeff_sym_mpoly) auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly (set xs) k) = (1::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "then"], ["proof (chain)\npicking this:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly (set xs) k) = (1::'a)", "obtain X where X: \"X \\<subseteq> set xs\" \"card X = k\" \"?m = monom_of_set X\""], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (sym_mpoly (set xs) k) = (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> set xs; card X = k;\n         lead_monom (sym_mpoly (set xs) k) = monom_of_set X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lead_coeff_def"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (sym_mpoly (set xs) k)\n   (lead_monom (sym_mpoly (set xs) k)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<subseteq> set xs; card X = k;\n         lead_monom (sym_mpoly (set xs) k) = monom_of_set X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) coeff_sym_mpoly) (auto split: if_splits)"], ["proof (state)\nthis:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "define ys where \"ys = map (\\<lambda>x. if x \\<in> X then 1 else 0 :: nat) xs\""], ["proof (state)\nthis:\n  ys = map (\\<lambda>x. if x \\<in> X then 1 else 0) xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have [simp]: \"length ys = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs", "by (simp add: ys_def)"], ["proof (state)\nthis:\n  length ys = length xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have ys_altdef: \"ys = map (lookup ?m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map (lookup (lead_monom (sym_mpoly (set xs) k))) xs", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. if x \\<in> X then 1 else 0) xs =\n    map (lookup (lead_monom (sym_mpoly (set xs) k))) xs", "using X finite_subset[OF X(1)]"], ["proof (prove)\nusing this:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n  finite (set xs) \\<Longrightarrow> finite X\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. if x \\<in> X then 1 else 0) xs =\n    map (lookup (lead_monom (sym_mpoly (set xs) k))) xs", "by (intro map_cong) (auto simp: lookup_monom_of_set)"], ["proof (state)\nthis:\n  ys = map (lookup (lead_monom (sym_mpoly (set xs) k))) xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "define i where \"i = Min (insert (length xs) {i. i < length xs \\<and> ys ! i = 0})\""], ["proof (state)\nthis:\n  i = Min (insert (length xs) {i. i < length xs \\<and> ys ! i = 0})\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"i \\<le> length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length xs", "by (auto simp: i_def)"], ["proof (state)\nthis:\n  i \\<le> length xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have in_X: \"xs ! j \\<in> X\" if \"j < i\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! j \\<in> X", "using that"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. xs ! j \\<in> X", "unfolding i_def"], ["proof (prove)\nusing this:\n  j < Min (insert (length xs) {i. i < length xs \\<and> ys ! i = 0})\n\ngoal (1 subgoal):\n 1. xs ! j \\<in> X", "by (auto simp: ys_def)"], ["proof (state)\nthis:\n  ?j1 < i \\<Longrightarrow> xs ! ?j1 \\<in> X\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have not_in_X: \"xs ! j \\<notin> X\" if \"i \\<le> j\" \"j < length xs\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "have ne: \"{i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> ys ! i = 0} = {} \\<Longrightarrow> False", "assume [simp]: \"{i. i < length xs \\<and> ys ! i = 0} = {}\""], ["proof (state)\nthis:\n  {i. i < length xs \\<and> ys ! i = 0} = {}\n\ngoal (1 subgoal):\n 1. {i. i < length xs \\<and> ys ! i = 0} = {} \\<Longrightarrow> False", "from that"], ["proof (chain)\npicking this:\n  i \\<le> j\n  j < length xs", "show False"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j < length xs\n\ngoal (1 subgoal):\n 1. False", "by (simp add: i_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "hence \"Min {i. i < length xs \\<and> ys ! i = 0} \\<in> {i. i < length xs \\<and> ys ! i = 0}\""], ["proof (prove)\nusing this:\n  {i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> ys ! i = 0}\n    \\<in> {i. i < length xs \\<and> ys ! i = 0}", "using that"], ["proof (prove)\nusing this:\n  {i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}\n  i \\<le> j\n  j < length xs\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> ys ! i = 0}\n    \\<in> {i. i < length xs \\<and> ys ! i = 0}", "by (intro Min_in) auto"], ["proof (state)\nthis:\n  Min {i. i < length xs \\<and> ys ! i = 0}\n  \\<in> {i. i < length xs \\<and> ys ! i = 0}\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "also"], ["proof (state)\nthis:\n  Min {i. i < length xs \\<and> ys ! i = 0}\n  \\<in> {i. i < length xs \\<and> ys ! i = 0}\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "have \"Min {i. i < length xs \\<and> ys ! i = 0} = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> ys ! i = 0} = i", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> ys ! i = 0} =\n    Min (insert (length xs) {i. i < length xs \\<and> ys ! i = 0})", "using ne"], ["proof (prove)\nusing this:\n  {i. i < length xs \\<and> ys ! i = 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min {i. i < length xs \\<and> ys ! i = 0} =\n    Min (insert (length xs) {i. i < length xs \\<and> ys ! i = 0})", "by (subst Min_insert) (auto simp: min_def)"], ["proof (state)\nthis:\n  Min {i. i < length xs \\<and> ys ! i = 0} = i\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "finally"], ["proof (chain)\npicking this:\n  i \\<in> {i. i < length xs \\<and> ys ! i = 0}", "have i: \"ys ! i = 0\" \"i < length xs\""], ["proof (prove)\nusing this:\n  i \\<in> {i. i < length xs \\<and> ys ! i = 0}\n\ngoal (1 subgoal):\n 1. ys ! i = 0 &&& i < length xs", "by simp_all"], ["proof (state)\nthis:\n  ys ! i = 0\n  i < length xs\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "have \"lookup ?m (xs ! j) \\<le> lookup ?m (xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j)\n    \\<le> lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i)", "using that assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j < length xs\n  sorted xs\n  distinct xs\n  k \\<le> length xs\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j)\n    \\<le> lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i)", "by (intro lookup_lead_monom_decreasing[OF sym])\n         (auto intro!: sorted_nth_mono simp: set_conv_nth)"], ["proof (state)\nthis:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j)\n  \\<le> lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i)\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "also"], ["proof (state)\nthis:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j)\n  \\<le> lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i)\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i) = 0", "using i"], ["proof (prove)\nusing this:\n  ys ! i = 0\n  i < length xs\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i) = 0", "by (simp add: ys_altdef)"], ["proof (state)\nthis:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! i) = 0\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "finally"], ["proof (chain)\npicking this:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j) \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j) \\<le> 0\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "using that X finite_subset[OF X(1)]"], ["proof (prove)\nusing this:\n  lookup (lead_monom (sym_mpoly (set xs) k)) (xs ! j) \\<le> 0\n  i \\<le> j\n  j < length xs\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n  finite (set xs) \\<Longrightarrow> finite X\n\ngoal (1 subgoal):\n 1. xs ! j \\<notin> X", "by (auto simp: lookup_monom_of_set)"], ["proof (state)\nthis:\n  xs ! j \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> ?j1; ?j1 < length xs\\<rbrakk>\n  \\<Longrightarrow> xs ! ?j1 \\<notin> X\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "from X"], ["proof (chain)\npicking this:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X", "have \"k = card X\""], ["proof (prove)\nusing this:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n\ngoal (1 subgoal):\n 1. k = card X", "by simp"], ["proof (state)\nthis:\n  k = card X\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  k = card X\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"X = (\\<lambda>i. xs ! i) ` {i. i < length xs \\<and> xs ! i \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = (!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n\ngoal (1 subgoal):\n 1. X = (!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  X = (!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  X = (!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"card \\<dots> = (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}) =\n    (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1)", "using assms"], ["proof (prove)\nusing this:\n  sorted xs\n  distinct xs\n  k \\<le> length xs\n\ngoal (1 subgoal):\n 1. card ((!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}) =\n    (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1)", "by (subst card_image) (auto intro!: inj_on_nth)"], ["proof (state)\nthis:\n  card ((!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}) =\n  (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  card ((!) xs ` {i. i < length xs \\<and> xs ! i \\<in> X}) =\n  (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"\\<dots> = (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1) =\n    (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0)", "by (intro sum.mono_neutral_cong_left) auto"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1) =\n  (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length xs \\<and> xs ! i \\<in> X. 1) =\n  (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"\\<dots> = sum_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0) = sum_list ys", "by (auto simp: sum_list_sum_nth ys_def intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0) = sum_list ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < length xs. if xs ! i \\<in> X then 1 else 0) = sum_list ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"ys = take i ys @ drop i ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = take i ys @ drop i ys", "by simp"], ["proof (state)\nthis:\n  ys = take i ys @ drop i ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  ys = take i ys @ drop i ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"sum_list \\<dots> = sum_list (take i ys) + sum_list (drop i ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (take i ys @ drop i ys) =\n    sum_list (take i ys) + sum_list (drop i ys)", "by (subst sum_list_append) auto"], ["proof (state)\nthis:\n  sum_list (take i ys @ drop i ys) =\n  sum_list (take i ys) + sum_list (drop i ys)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  sum_list (take i ys @ drop i ys) =\n  sum_list (take i ys) + sum_list (drop i ys)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"take i ys = replicate i 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i ys = replicate i 1", "using \\<open>i \\<le> length xs\\<close> in_X"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n  ?j1 < i \\<Longrightarrow> xs ! ?j1 \\<in> X\n\ngoal (1 subgoal):\n 1. take i ys = replicate i 1", "by (intro replicate_eqI) (auto simp: ys_def set_conv_nth)"], ["proof (state)\nthis:\n  take i ys = replicate i 1\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  take i ys = replicate i 1\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"sum_list \\<dots> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate i 1) = i", "by simp"], ["proof (state)\nthis:\n  sum_list (replicate i 1) = i\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  sum_list (replicate i 1) = i\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"drop i ys = replicate (length ys - i) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop i ys = replicate (length ys - i) 0", "using \\<open>i \\<le> length xs\\<close> not_in_X"], ["proof (prove)\nusing this:\n  i \\<le> length xs\n  \\<lbrakk>i \\<le> ?j1; ?j1 < length xs\\<rbrakk>\n  \\<Longrightarrow> xs ! ?j1 \\<notin> X\n\ngoal (1 subgoal):\n 1. drop i ys = replicate (length ys - i) 0", "by (intro replicate_eqI) (auto simp: ys_def set_conv_nth)"], ["proof (state)\nthis:\n  drop i ys = replicate (length ys - i) 0\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  drop i ys = replicate (length ys - i) 0\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"sum_list \\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate (length ys - i) 0) = 0", "by simp"], ["proof (state)\nthis:\n  sum_list (replicate (length ys - i) 0) = 0\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "finally"], ["proof (chain)\npicking this:\n  k = i + 0", "have \"i = k\""], ["proof (prove)\nusing this:\n  k = i + 0\n\ngoal (1 subgoal):\n 1. i = k", "by simp"], ["proof (state)\nthis:\n  i = k\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"X = set (filter (\\<lambda>x. x \\<in> X) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = set (filter (\\<lambda>x. x \\<in> X) xs)", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n\ngoal (1 subgoal):\n 1. X = set (filter (\\<lambda>x. x \\<in> X) xs)", "by auto"], ["proof (state)\nthis:\n  X = set (filter (\\<lambda>x. x \\<in> X) xs)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  X = set (filter (\\<lambda>x. x \\<in> X) xs)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"xs = take i xs @ drop i xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take i xs @ drop i xs", "by simp"], ["proof (state)\nthis:\n  xs = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  xs = take i xs @ drop i xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "note filter_append"], ["proof (state)\nthis:\n  filter ?P (?xs @ ?ys) = filter ?P ?xs @ filter ?P ?ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  filter ?P (?xs @ ?ys) = filter ?P ?xs @ filter ?P ?ys\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"filter (\\<lambda>x. x \\<in> X) (take i xs) = take i xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<in> X) (take i xs) = take i xs", "using in_X"], ["proof (prove)\nusing this:\n  ?j1 < i \\<Longrightarrow> xs ! ?j1 \\<in> X\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<in> X) (take i xs) = take i xs", "by (intro filter_True) (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<in> X) (take i xs) = take i xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "also"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<in> X) (take i xs) = take i xs\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "have \"filter (\\<lambda>x. x \\<in> X) (drop i xs) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<in> X) (drop i xs) = []", "using not_in_X"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> ?j1; ?j1 < length xs\\<rbrakk>\n  \\<Longrightarrow> xs ! ?j1 \\<notin> X\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<in> X) (drop i xs) = []", "by (intro filter_False) (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<in> X) (drop i xs) = []\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "finally"], ["proof (chain)\npicking this:\n  X = set (take i xs @ [])", "have \"X = set (take i xs)\""], ["proof (prove)\nusing this:\n  X = set (take i xs @ [])\n\ngoal (1 subgoal):\n 1. X = set (take i xs)", "by simp"], ["proof (state)\nthis:\n  X = set (take i xs)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "with \\<open>i = k\\<close> and X"], ["proof (chain)\npicking this:\n  i = k\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n  X = set (take i xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = k\n  X \\<subseteq> set xs\n  card X = k\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set X\n  X = set (take i xs)\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))", "by simp"], ["proof (state)\nthis:\n  lead_monom (sym_mpoly (set xs) k) = monom_of_set (set (take k xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Induction on the leading monomial\\<close>"], ["", "text \\<open>\n  We show that the monomial ordering for a fixed set of variables is well-founded,\n  so we can perform induction on the leading monomial of a polynomial.\n\\<close>"], ["", "definition monom_less_on where\n  \"monom_less_on A = {(m1, m2). m1 < m2 \\<and> keys m1 \\<subseteq> A \\<and> keys m2 \\<subseteq> A}\""], ["", "lemma wf_monom_less_on:\n  assumes \"finite A\"\n  shows   \"wf (monom_less_on A :: ((nat \\<Rightarrow>\\<^sub>0 'b :: {zero, wellorder}) \\<times> _) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (monom_less_on A)", "proof (rule wf_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?r\n 2. monom_less_on A \\<subseteq> ?r", "define n where \"n = Suc (Max (insert 0 A))\""], ["proof (state)\nthis:\n  n = Suc (Max (insert 0 A))\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. monom_less_on A \\<subseteq> ?r", "have less_n: \"k < n\" if \"k \\<in> A\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n", "using that assms"], ["proof (prove)\nusing this:\n  k \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. k < n", "by (auto simp: n_def less_Suc_eq_le Max_ge_iff)"], ["proof (state)\nthis:\n  ?k \\<in> A \\<Longrightarrow> ?k < n\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. monom_less_on A \\<subseteq> ?r", "define f :: \"(nat \\<Rightarrow>\\<^sub>0 'b) \\<Rightarrow> 'b list\" where \"f = (\\<lambda>m. map (lookup m) [0..<n])\""], ["proof (state)\nthis:\n  f = (\\<lambda>m. map (lookup m) [0..<n])\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. monom_less_on A \\<subseteq> ?r", "show \"wf (inv_image (lexn {(x,y). x < y} n) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (lexn {(x, y). x < y} n) f)", "by (intro wf_inv_image wf_lexn wellorder_class.wf)"], ["proof (state)\nthis:\n  wf (inv_image (lexn {(x, y). x < y} n) f)\n\ngoal (1 subgoal):\n 1. monom_less_on A\n    \\<subseteq> inv_image (lexn {(x, y). x < y} (Suc (Max (insert 0 A))))\n                 (\\<lambda>m. map (lookup m) [0..<Suc (Max (insert 0 A))])", "show \"monom_less_on A \\<subseteq> inv_image (lexn {(x, y). x < y} n) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_less_on A \\<subseteq> inv_image (lexn {(x, y). x < y} n) f", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "fix m1 m2 :: \"nat \\<Rightarrow>\\<^sub>0 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "assume \"(m1, m2) \\<in> monom_less_on A\""], ["proof (state)\nthis:\n  (m1, m2) \\<in> monom_less_on A\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "hence m12: \"m1 < m2\" \"keys m1 \\<subseteq> A\" \"keys m2 \\<subseteq> A\""], ["proof (prove)\nusing this:\n  (m1, m2) \\<in> monom_less_on A\n\ngoal (1 subgoal):\n 1. m1 < m2 &&& keys m1 \\<subseteq> A &&& keys m2 \\<subseteq> A", "by (auto simp: monom_less_on_def)"], ["proof (state)\nthis:\n  m1 < m2\n  keys m1 \\<subseteq> A\n  keys m2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "then"], ["proof (chain)\npicking this:\n  m1 < m2\n  keys m1 \\<subseteq> A\n  keys m2 \\<subseteq> A", "obtain k where k: \"lookup m1 k < lookup m2 k\" \"\\<forall>i<k. lookup m1 i = lookup m2 i\""], ["proof (prove)\nusing this:\n  m1 < m2\n  keys m1 \\<subseteq> A\n  keys m2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>lookup m1 k < lookup m2 k;\n         \\<forall>i<k. lookup m1 i = lookup m2 i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_poly_mapping_def less_fun_def)"], ["proof (state)\nthis:\n  lookup m1 k < lookup m2 k\n  \\<forall>i<k. lookup m1 i = lookup m2 i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "have \"\\<not>(lookup m1 k = 0 \\<and> lookup m2 k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b))", "proof (intro notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b) \\<Longrightarrow>\n    False", "assume \"lookup m1 k = 0 \\<and> lookup m2 k = 0\""], ["proof (state)\nthis:\n  lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b) \\<Longrightarrow>\n    False", "hence [simp]: \"lookup m1 k = 0\" \"lookup m2 k = 0\""], ["proof (prove)\nusing this:\n  lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup m1 k = (0::'b) &&& lookup m2 k = (0::'b)", "by blast+"], ["proof (state)\nthis:\n  lookup m1 k = (0::'b)\n  lookup m2 k = (0::'b)\n\ngoal (1 subgoal):\n 1. lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b) \\<Longrightarrow>\n    False", "from k(1)"], ["proof (chain)\npicking this:\n  lookup m1 k < lookup m2 k", "show False"], ["proof (prove)\nusing this:\n  lookup m1 k < lookup m2 k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "hence \"k \\<in> A\""], ["proof (prove)\nusing this:\n  \\<not> (lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b))\n\ngoal (1 subgoal):\n 1. k \\<in> A", "using m12"], ["proof (prove)\nusing this:\n  \\<not> (lookup m1 k = (0::'b) \\<and> lookup m2 k = (0::'b))\n  m1 < m2\n  keys m1 \\<subseteq> A\n  keys m2 \\<subseteq> A\n\ngoal (1 subgoal):\n 1. k \\<in> A", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  k \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "hence \"k < n\""], ["proof (prove)\nusing this:\n  k \\<in> A\n\ngoal (1 subgoal):\n 1. k < n", "by (simp add: less_n)"], ["proof (state)\nthis:\n  k < n\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "define as where \"as = map (lookup m1) [0..<k]\""], ["proof (state)\nthis:\n  as = map (lookup m1) [0..<k]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "define bs1 where \"bs1 = map (lookup m1) [Suc k..<n]\""], ["proof (state)\nthis:\n  bs1 = map (lookup m1) [Suc k..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "define bs2 where \"bs2 = map (lookup m2) [Suc k..<n]\""], ["proof (state)\nthis:\n  bs2 = map (lookup m2) [Suc k..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "have decomp: \"[0..<n] = [0..<k] @ [k] @ drop (Suc k) [0..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ [k] @ drop (Suc k) [0..<n]", "using \\<open>k < n\\<close>"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<k] @ [k] @ drop (Suc k) [0..<n]", "by (simp flip: upt_conv_Cons upt_add_eq_append')"], ["proof (state)\nthis:\n  [0..<n] = [0..<k] @ [k] @ drop (Suc k) [0..<n]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "have [simp]: \"length as = k\" \"length bs1 = n - Suc k\" \"length bs2 = n - Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length as = k &&& length bs1 = n - Suc k &&& length bs2 = n - Suc k", "by (simp_all add: as_def bs1_def bs2_def)"], ["proof (state)\nthis:\n  length as = k\n  length bs1 = n - Suc k\n  length bs2 = n - Suc k\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "have \"f m1 = as @ [lookup m1 k] @ bs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m1 = as @ [lookup m1 k] @ bs1", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (lookup m1) [0..<n] = as @ [lookup m1 k] @ bs1", "by (subst decomp) (simp add: as_def bs1_def)"], ["proof (state)\nthis:\n  f m1 = as @ [lookup m1 k] @ bs1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "moreover"], ["proof (state)\nthis:\n  f m1 = as @ [lookup m1 k] @ bs1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "have \"f m2 = as @ [lookup m2 k] @ bs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m2 = as @ [lookup m2 k] @ bs2", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (lookup m2) [0..<n] = as @ [lookup m2 k] @ bs2", "using k"], ["proof (prove)\nusing this:\n  lookup m1 k < lookup m2 k\n  \\<forall>i<k. lookup m1 i = lookup m2 i\n\ngoal (1 subgoal):\n 1. map (lookup m2) [0..<n] = as @ [lookup m2 k] @ bs2", "by (subst decomp) (simp add: as_def bs2_def)"], ["proof (state)\nthis:\n  f m2 = as @ [lookup m2 k] @ bs2\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> monom_less_on A \\<Longrightarrow>\n       (a, b) \\<in> inv_image (lexn {(x, y). x < y} n) f", "ultimately"], ["proof (chain)\npicking this:\n  f m1 = as @ [lookup m1 k] @ bs1\n  f m2 = as @ [lookup m2 k] @ bs2", "show \"(m1, m2) \\<in> inv_image (lexn {(x,y). x < y} n) f\""], ["proof (prove)\nusing this:\n  f m1 = as @ [lookup m1 k] @ bs1\n  f m2 = as @ [lookup m2 k] @ bs2\n\ngoal (1 subgoal):\n 1. (m1, m2) \\<in> inv_image (lexn {(x, y). x < y} n) f", "using k(1) \\<open>k < n\\<close>"], ["proof (prove)\nusing this:\n  f m1 = as @ [lookup m1 k] @ bs1\n  f m2 = as @ [lookup m2 k] @ bs2\n  lookup m1 k < lookup m2 k\n  k < n\n\ngoal (1 subgoal):\n 1. (m1, m2) \\<in> inv_image (lexn {(x, y). x < y} n) f", "unfolding lexn_conv"], ["proof (prove)\nusing this:\n  f m1 = as @ [lookup m1 k] @ bs1\n  f m2 = as @ [lookup m2 k] @ bs2\n  lookup m1 k < lookup m2 k\n  k < n\n\ngoal (1 subgoal):\n 1. (m1, m2)\n    \\<in> inv_image\n           {(xs, ys).\n            length xs = n \\<and>\n            length ys = n \\<and>\n            (\\<exists>xys x y xs' ys'.\n                xs = xys @ x # xs' \\<and>\n                ys = xys @ y # ys' \\<and> (x, y) \\<in> {(x, y). x < y})}\n           f", "by fastforce"], ["proof (state)\nthis:\n  (m1, m2) \\<in> inv_image (lexn {(x, y). x < y} n) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom_less_on A \\<subseteq> inv_image (lexn {(x, y). x < y} n) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_induct [consumes 2, case_names less]:\n  fixes p :: \"'a :: zero mpoly\"\n  assumes fin: \"finite A\" and vars: \"vars p \\<subseteq> A\"\n  assumes IH: \"\\<And>p. vars p \\<subseteq> A \\<Longrightarrow>\n                 (\\<And>p'. vars p' \\<subseteq> A \\<Longrightarrow> lead_monom p' < lead_monom p \\<Longrightarrow> P p') \\<Longrightarrow> P p\"\n  shows   \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using assms(2)"], ["proof (prove)\nusing this:\n  vars p \\<subseteq> A\n\ngoal (1 subgoal):\n 1. P p", "proof (induct m \\<equiv> \"lead_monom p\" arbitrary: p rule: wf_induct_rule[OF wf_monom_less_on[OF fin]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>(lead_monom pa, lead_monom p)\n                            \\<in> monom_less_on A;\n                    vars pa \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> P pa;\n        vars p \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> P p", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>(lead_monom ?p, lead_monom p) \\<in> monom_less_on A;\n   vars ?p \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P ?p\n  vars p \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>(lead_monom pa, lead_monom p)\n                            \\<in> monom_less_on A;\n                    vars pa \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> P pa;\n        vars p \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (rule IH)"], ["proof (state)\ngoal (2 subgoals):\n 1. vars p \\<subseteq> A\n 2. \\<And>p'.\n       \\<lbrakk>vars p' \\<subseteq> A; lead_monom p' < lead_monom p\\<rbrakk>\n       \\<Longrightarrow> P p'", "fix p' :: \"'a mpoly\""], ["proof (state)\ngoal (2 subgoals):\n 1. vars p \\<subseteq> A\n 2. \\<And>p'.\n       \\<lbrakk>vars p' \\<subseteq> A; lead_monom p' < lead_monom p\\<rbrakk>\n       \\<Longrightarrow> P p'", "assume *: \"vars p' \\<subseteq> A\" \"lead_monom p' < lead_monom p\""], ["proof (state)\nthis:\n  vars p' \\<subseteq> A\n  lead_monom p' < lead_monom p\n\ngoal (2 subgoals):\n 1. vars p \\<subseteq> A\n 2. \\<And>p'.\n       \\<lbrakk>vars p' \\<subseteq> A; lead_monom p' < lead_monom p\\<rbrakk>\n       \\<Longrightarrow> P p'", "show \"P p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p'", "by (rule 1) (insert * \"1.prems\" keys_lead_monom_subset, auto simp: monom_less_on_def)"], ["proof (state)\nthis:\n  P p'\n\ngoal (1 subgoal):\n 1. vars p \\<subseteq> A", "qed (insert 1, auto)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_induct' [case_names less]:\n  fixes p :: \"'a :: zero mpoly\"\n  assumes IH: \"\\<And>p. (\\<And>p'. vars p' \\<subseteq> vars p \\<Longrightarrow> lead_monom p' < lead_monom p \\<Longrightarrow> P p') \\<Longrightarrow> P p\"\n  shows   \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P p", "have \"finite (vars p)\" \"vars p \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars p) &&& vars p \\<subseteq> vars p", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  finite (vars p)\n  vars p \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. P p", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (vars p)\n  vars p \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. P p", "by (induction rule: lead_monom_induct) (use IH in blast)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The fundamental theorem of symmetric polynomials\\<close>"], ["", "lemma lead_coeff_sym_mpoly_powerprod:\n  assumes \"finite A\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x \\<in> {1..card A}\"\n  shows   \"lead_coeff (\\<Prod>x\\<in>X. sym_mpoly A (f (x::'a)) ^ g x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "have eq: \"lead_coeff (sym_mpoly A (f x) ^ g x :: 'b mpoly) = 1\" if \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x) = (1::'b)", "using that assms"], ["proof (prove)\nusing this:\n  x \\<in> X\n  finite A\n  ?x \\<in> X \\<Longrightarrow> f ?x \\<in> {1..card A}\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x) = (1::'b)", "by (subst lead_coeff_power) (auto simp: lead_coeff_sym_mpoly assms)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A (f ?x) ^ g ?x) = (1::'b)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "hence \"(\\<Prod>x\\<in>X. lead_coeff (sym_mpoly A (f x) ^ g x :: 'b mpoly)) = (\\<Prod>x\\<in>X. 1)\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (sym_mpoly A (f ?x) ^ g ?x) = (1::'b)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X.\n       Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n    (\\<Prod>x\\<in>X. (1::'b))", "by (intro prod.cong eq refl)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X.\n     Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n  (\\<Prod>x\\<in>X. (1::'b))\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X.\n     Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n  (\\<Prod>x\\<in>X. (1::'b))\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. (1::'b)) = (1::'b)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. (1::'b)) = (1::'b)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>x\\<in>X.\n     Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n  (1::'b)", "have eq': \"(\\<Prod>x\\<in>X. lead_coeff (sym_mpoly A (f x) ^ g x :: 'b mpoly)) = 1\""], ["proof (prove)\nusing this:\n  (\\<Prod>x\\<in>X.\n     Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X.\n       Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n    (1::'b)", "."], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X.\n     Symmetric_Polynomials.lead_coeff (sym_mpoly A (f x) ^ g x)) =\n  (1::'b)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n    (1::'b)", "by (subst lead_coeff_prod) (auto simp: eq eq')"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff\n   (\\<Prod>x\\<in>X. sym_mpoly A (f x) ^ g x) =\n  (1::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes A :: \"nat set\" and xs n f and decr :: \"'a :: comm_ring_1 mpoly \\<Rightarrow> bool\"\n  defines \"xs \\<equiv> sorted_list_of_set A\"\n  defines \"n \\<equiv> card A\"\n  defines \"f \\<equiv> (\\<lambda>i. if i < n then xs ! i else 0)\"\n  defines \"decr \\<equiv> (\\<lambda>p. \\<forall>i\\<in>A. \\<forall>j\\<in>A. i \\<le> j \\<longrightarrow>\n                   lookup (lead_monom p) i \\<ge> lookup (lead_monom p) j)\"\nbegin"], ["", "text \\<open>\n  The computation of the witness for the fundamental theorem works like this:\n  Given some polynomial $p$ (that is assumed to be symmetric in the variables in $A$),\n  we inspect its leading monomial, which is of the form $c X_1^{i_1}\\ldots X_n{i_n}$ where\n  the $A = \\{X_1,\\ldots, X_n\\}$, $c$ contains only variables not in $A$, and the sequence $i_j$\n  is decreasing. The latter holds because $p$ is symmetric.\n\n  Now, we form the polynomial $q := c e_1^{i_1 - i_2} e_2^{i_2 - i_3} \\ldots e_n^{i_n}$, which\n  has the same leading term as $p$. Then $p - q$ has a smaller leading monomial, so by induction,\n  we can assume it to be of the required form and obtain a witness for $p - q$.\n\n  Now, we only need to add $c Y_1^{i_1 - i_2} \\ldots Y_n^{i_n}$ to that witness and we\n  obtain a witness for $p$.\n\\<close>"], ["", "definition fund_sym_step_coeff :: \"'a mpoly \\<Rightarrow> 'a mpoly\" where\n  \"fund_sym_step_coeff p = monom (restrictpm (-A) (lead_monom p)) (lead_coeff p)\""], ["", "definition fund_sym_step_monom :: \"'a mpoly \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat)\" where\n  \"fund_sym_step_monom p = (\n     let g = (\\<lambda>i. if i < n then lookup (lead_monom p) (f i) else 0)\n     in  (\\<Sum>i<n. Poly_Mapping.single (Suc i) (g i - g (Suc i))))\""], ["", "definition fund_sym_step_poly :: \"'a mpoly \\<Rightarrow> 'a mpoly\" where\n  \"fund_sym_step_poly p = (\n      let g = (\\<lambda>i. if i < n then lookup (lead_monom p) (f i) else 0)\n      in  fund_sym_step_coeff p * (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\""], ["", "text \\<open>\n  The following function computes the witness, with the convention that it returns a constant\n  polynomial if the input was not symmetric:\n\\<close>"], ["", "function (domintros) fund_sym_poly_wit :: \"'a :: comm_ring_1 mpoly \\<Rightarrow> 'a mpoly mpoly\" where\n  \"fund_sym_poly_wit p =\n     (if \\<not>symmetric_mpoly A p \\<or> lead_monom p = 0 \\<or> vars p \\<inter> A = {} then Const p else\n        fund_sym_poly_wit (p - fund_sym_step_poly p) +\n        monom (fund_sym_step_monom p) (fund_sym_step_coeff p))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>p. x = p \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p pa.\n       p = pa \\<Longrightarrow>\n       (if \\<not> symmetric_mpoly A p \\<or>\n           lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n        then Const p\n        else fund_sym_poly_wit_sumC (p - local.fund_sym_step_poly p) +\n             MPoly_Type.monom (local.fund_sym_step_monom p)\n              (local.fund_sym_step_coeff p)) =\n       (if \\<not> symmetric_mpoly A pa \\<or>\n           lead_monom pa = 0 \\<or> vars pa \\<inter> A = {}\n        then Const pa\n        else fund_sym_poly_wit_sumC (pa - local.fund_sym_step_poly pa) +\n             MPoly_Type.monom (local.fund_sym_step_monom pa)\n              (local.fund_sym_step_coeff pa))", "by auto"], ["", "lemma coeff_fund_sym_step_coeff: \"coeff (fund_sym_step_coeff p) m \\<in> {lead_coeff p, 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_coeff p) m\n    \\<in> {Symmetric_Polynomials.lead_coeff p, 0::'a}", "by (auto simp: fund_sym_step_coeff_def coeff_monom when_def)"], ["", "lemma vars_fund_sym_step_coeff: \"vars (fund_sym_step_coeff p) \\<subseteq> vars p - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (local.fund_sym_step_coeff p) \\<subseteq> vars p - A", "unfolding fund_sym_step_coeff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n       (Symmetric_Polynomials.lead_coeff p))\n    \\<subseteq> vars p - A", "using keys_lead_monom_subset[of p]"], ["proof (prove)\nusing this:\n  keys (lead_monom p) \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n       (Symmetric_Polynomials.lead_coeff p))\n    \\<subseteq> vars p - A", "by (intro order.trans[OF vars_monom_subset]) auto"], ["", "lemma keys_fund_sym_step_monom: \"keys (fund_sym_step_monom p) \\<subseteq> {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys (local.fund_sym_step_monom p) \\<subseteq> {1..n}", "unfolding fund_sym_step_monom_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys\n     (\\<Sum>i<n.\n         Poly_Mapping.single (Suc i)\n          ((if i < n then lookup (lead_monom p) (f i) else 0) -\n           (if Suc i < n then lookup (lead_monom p) (f (Suc i)) else 0)))\n    \\<subseteq> {1..n}", "by (intro order.trans[OF keys_sum] UN_least, subst keys_single) auto"], ["", "lemma coeff_fund_sym_step_poly:\n  assumes C: \"\\<forall>m. coeff p m \\<in> C\" and \"ring_closed C\"\n  shows   \"coeff (fund_sym_step_poly p) m \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "interpret ring_closed C"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed C", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "have *: \"\\<And>m. coeff (p ^ x) m \\<in> C\" if \"\\<And>m. coeff p m \\<in> C\"  for p x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. MPoly_Type.coeff (p ^ x) m \\<in> C", "using that"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p ?m \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>m. MPoly_Type.coeff (p ^ x) m \\<in> C", "by (induction x)\n                  (auto simp: coeff_mpoly_times mpoly_coeff_1 intro!: prod_fun_closed)"], ["proof (state)\nthis:\n  (\\<And>m. MPoly_Type.coeff ?p1 m \\<in> C) \\<Longrightarrow>\n  MPoly_Type.coeff (?p1 ^ ?x1) ?m \\<in> C\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "have **: \"\\<And>m. coeff (prod f X) m \\<in> C\" if \"\\<And>i m. i \\<in> X \\<Longrightarrow> coeff (f i) m \\<in> C\"\n    for X and f :: \"nat \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. MPoly_Type.coeff (prod f X) m \\<in> C", "using that"], ["proof (prove)\nusing this:\n  ?i \\<in> X \\<Longrightarrow> MPoly_Type.coeff (f ?i) ?m \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>m. MPoly_Type.coeff (prod f X) m \\<in> C", "by (induction X rule: infinite_finite_induct)\n                  (auto simp: coeff_mpoly_times mpoly_coeff_1 intro!: prod_fun_closed)"], ["proof (state)\nthis:\n  (\\<And>i m.\n      i \\<in> ?X1 \\<Longrightarrow>\n      MPoly_Type.coeff (?f1 i) m \\<in> C) \\<Longrightarrow>\n  MPoly_Type.coeff (prod ?f1 ?X1) ?m \\<in> C\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "using C"], ["proof (prove)\nusing this:\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C", "unfolding fund_sym_step_poly_def Let_def fund_sym_step_coeff_def coeff_mpoly_times"], ["proof (prove)\nusing this:\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. prod_fun\n     (MPoly_Type.coeff\n       (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n         (Symmetric_Polynomials.lead_coeff p)))\n     (MPoly_Type.coeff\n       (\\<Prod>i<n.\n           sym_mpoly A (Suc i) ^\n           ((if i < n then lookup (lead_monom p) (f i) else 0) -\n            (if Suc i < n then lookup (lead_monom p) (f (Suc i)) else 0))))\n     m\n    \\<in> C", "by (intro prod_fun_closed)\n       (auto simp: coeff_monom when_def lead_coeff_def coeff_sym_mpoly intro!: * **)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (local.fund_sym_step_poly p) m \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now show various relevant properties of the subtracted polynomial:\n\n    \\<^enum> Its leading term is the same as that of the input polynomial.\n\n    \\<^enum> It contains now new variables.\n\n    \\<^enum> It is symmetric in the variables in \\<open>A\\<close>.\n\\<close>"], ["", "lemma fund_sym_step_poly:\n  shows   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> lead_monom (fund_sym_step_poly p) = lead_monom p\"\n    and   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> lead_coeff (fund_sym_step_poly p) = lead_coeff p\"\n    and   \"finite A \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> decr p \\<Longrightarrow> fund_sym_step_poly p =\n             fund_sym_step_coeff p * (\\<Prod>x. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x)\"\n    and   \"vars (fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\"\n    and   \"symmetric_mpoly A (fund_sym_step_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n      \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) =\n                        lead_monom p) &&&\n     (\\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n      \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                         (local.fund_sym_step_poly p) =\n                        Symmetric_Polynomials.lead_coeff p)) &&&\n    (\\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n     \\<Longrightarrow> local.fund_sym_step_poly p =\n                       local.fund_sym_step_coeff p *\n                       (\\<Prod>x. sym_mpoly A x ^\n                                  lookup (local.fund_sym_step_monom p)\n                                   x)) &&&\n    vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A &&&\n    symmetric_mpoly A (local.fund_sym_step_poly p)", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "define g where \"g = (\\<lambda>i. if i < n then lookup (lead_monom p) (f i) else 0)\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. if i < n then lookup (lead_monom p) (f i) else 0)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "define q where \"q = (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i)) :: 'a mpoly)\""], ["proof (state)\nthis:\n  q = (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i)))\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "define c where \"c = monom (restrictpm (-A) (lead_monom p)) (lead_coeff p)\""], ["proof (state)\nthis:\n  c =\n  MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n   (Symmetric_Polynomials.lead_coeff p)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "have [simp]: \"fund_sym_step_poly p = c * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fund_sym_step_poly p = c * q", "by (simp add: fund_sym_step_poly_def fund_sym_step_coeff_def c_def q_def f_def g_def)"], ["proof (state)\nthis:\n  local.fund_sym_step_poly p = c * q\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "have \"vars (c * q) \\<subseteq> vars p \\<union> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (c * q) \\<subseteq> vars p \\<union> A", "using keys_lead_monom_subset[of p]\n          vars_monom_subset[of \"restrictpm (-A) (lead_monom p)\" \"lead_coeff p\"]"], ["proof (prove)\nusing this:\n  keys (lead_monom p) \\<subseteq> vars p\n  vars\n   (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n     (Symmetric_Polynomials.lead_coeff p))\n  \\<subseteq> keys (restrictpm (- A) (lead_monom p))\n\ngoal (1 subgoal):\n 1. vars (c * q) \\<subseteq> vars p \\<union> A", "unfolding c_def q_def"], ["proof (prove)\nusing this:\n  keys (lead_monom p) \\<subseteq> vars p\n  vars\n   (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n     (Symmetric_Polynomials.lead_coeff p))\n  \\<subseteq> keys (restrictpm (- A) (lead_monom p))\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n       (Symmetric_Polynomials.lead_coeff p) *\n      (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\n    \\<subseteq> vars p \\<union> A", "by (intro order.trans[OF vars_mult] order.trans[OF vars_prod] order.trans[OF vars_power]\n              Un_least UN_least order.trans[OF vars_sym_mpoly_subset]) auto"], ["proof (state)\nthis:\n  vars (c * q) \\<subseteq> vars p \\<union> A\n\ngoal (5 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n 5. symmetric_mpoly A (local.fund_sym_step_poly p)", "thus \"vars (fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\""], ["proof (prove)\nusing this:\n  vars (c * q) \\<subseteq> vars p \\<union> A\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A", "by simp"], ["proof (state)\nthis:\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n\ngoal (4 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. symmetric_mpoly A (local.fund_sym_step_poly p)", "have \"symmetric_mpoly A (c * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (c * q)", "unfolding c_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A\n     (MPoly_Type.monom (restrictpm (- A) (lead_monom p))\n       (Symmetric_Polynomials.lead_coeff p) *\n      (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i))))", "by (intro symmetric_mpoly_mult symmetric_mpoly_monom symmetric_mpoly_prod\n              symmetric_mpoly_power symmetric_sym_mpoly) auto"], ["proof (state)\nthis:\n  symmetric_mpoly A (c * q)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)\n 4. symmetric_mpoly A (local.fund_sym_step_poly p)", "thus \"symmetric_mpoly A (fund_sym_step_poly p)\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A (c * q)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (local.fund_sym_step_poly p)", "by simp"], ["proof (state)\nthis:\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "assume finite: \"finite A\" and [simp]: \"p \\<noteq> 0\" and \"decr p\""], ["proof (state)\nthis:\n  finite A\n  p \\<noteq> 0\n  decr p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"set xs = A\" \"distinct xs\" and [simp]: \"length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs) &&& length xs = n", "using finite"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs) &&& length xs = n", "by (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  length xs = n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have [simp]: \"lead_coeff c = lead_coeff p\" \"lead_monom c = restrictpm (- A) (lead_monom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff c =\n    Symmetric_Polynomials.lead_coeff p &&&\n    lead_monom c = restrictpm (- A) (lead_monom p)", "by (simp_all add: c_def lead_monom_monom)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff c = Symmetric_Polynomials.lead_coeff p\n  lead_monom c = restrictpm (- A) (lead_monom p)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "hence f_range [simp]: \"f i \\<in> A\" if \"i < n\" for i"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff c = Symmetric_Polynomials.lead_coeff p\n  lead_monom c = restrictpm (- A) (lead_monom p)\n\ngoal (1 subgoal):\n 1. f i \\<in> A", "using that \\<open>set xs = A\\<close>"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff c = Symmetric_Polynomials.lead_coeff p\n  lead_monom c = restrictpm (- A) (lead_monom p)\n  i < n\n  set xs = A\n\ngoal (1 subgoal):\n 1. f i \\<in> A", "by (auto simp: f_def set_conv_nth)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> f ?i \\<in> A\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"sorted xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs", "by (simp add: xs_def)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "hence f_mono: \"f i \\<le> f j\" if \"i \\<le> j\" \"j < n\" for i j"], ["proof (prove)\nusing this:\n  sorted xs\n\ngoal (1 subgoal):\n 1. f i \\<le> f j", "using that"], ["proof (prove)\nusing this:\n  sorted xs\n  i \\<le> j\n  j < n\n\ngoal (1 subgoal):\n 1. f i \\<le> f j", "by (auto simp: f_def n_def intro: sorted_nth_mono)"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?i \\<le> f ?j\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "hence g_mono: \"g i \\<ge> g j\" if \"i \\<le> j\" for i j"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?i \\<le> f ?j\n\ngoal (1 subgoal):\n 1. g j \\<le> g i", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?i \\<le> f ?j\n\ngoal (1 subgoal):\n 1. (if j < n then lookup (lead_monom p) (f j) else 0)\n    \\<le> (if i < n then lookup (lead_monom p) (f i) else 0)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?i \\<le> f ?j\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (if j < n then lookup (lead_monom p) (f j) else 0)\n    \\<le> (if i < n then lookup (lead_monom p) (f i) else 0)", "using \\<open>decr p\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?j < n\\<rbrakk> \\<Longrightarrow> f ?i \\<le> f ?j\n  i \\<le> j\n  decr p\n\ngoal (1 subgoal):\n 1. (if j < n then lookup (lead_monom p) (f j) else 0)\n    \\<le> (if i < n then lookup (lead_monom p) (f i) else 0)", "by (auto simp: decr_def)"], ["proof (state)\nthis:\n  ?i \\<le> ?j \\<Longrightarrow> g ?j \\<le> g ?i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have *: \"(\\<Prod>i<n. lead_coeff (sym_mpoly A (Suc i) ^ (g i - g (Suc i)) :: 'a mpoly)) =\n              (\\<Prod>i<card A. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n.\n        Symmetric_Polynomials.lead_coeff\n         (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Prod>i<card A. (1::'a))", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>i<n.\n        Symmetric_Polynomials.lead_coeff\n         (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Prod>i<card A. (1::'a))", "by (intro prod.cong) (auto simp: n_def lead_coeff_power)"], ["proof (state)\nthis:\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Prod>i<card A. (1::'a))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "hence \"lead_coeff q = (\\<Prod>i<n. lead_coeff (sym_mpoly A (Suc i) ^ (g i - g (Suc i)) :: 'a mpoly))\""], ["proof (prove)\nusing this:\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Prod>i<card A. (1::'a))\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff q =\n    (\\<Prod>i<n.\n        Symmetric_Polynomials.lead_coeff\n         (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))", "by (simp add: lead_coeff_prod lead_coeff_power n_def q_def)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff q =\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff q =\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = (\\<Prod>i<n. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n.\n        Symmetric_Polynomials.lead_coeff\n         (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Prod>i<n. (1::'a))", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>i<n.\n        Symmetric_Polynomials.lead_coeff\n         (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Prod>i<n. (1::'a))", "by (intro prod.cong) (auto simp: lead_coeff_power n_def)"], ["proof (state)\nthis:\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Prod>i<n. (1::'a))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "finally"], ["proof (chain)\npicking this:\n  Symmetric_Polynomials.lead_coeff q = (\\<Prod>i<n. (1::'a))", "have [simp]: \"lead_coeff q = 1\""], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff q = (\\<Prod>i<n. (1::'a))\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff q = (1::'a)", "by simp"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff q = (1::'a)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"lead_monom q = (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i)) :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom q =\n    (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))", "using *"], ["proof (prove)\nusing this:\n  (\\<Prod>i<n.\n      Symmetric_Polynomials.lead_coeff\n       (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Prod>i<card A. (1::'a))\n\ngoal (1 subgoal):\n 1. lead_monom q =\n    (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))", "by (simp add: q_def lead_monom_prod lead_coeff_power n_def)"], ["proof (state)\nthis:\n  lead_monom q =\n  (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  lead_monom q =\n  (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i) :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)))", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n    (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)))", "by (intro sum.cong) (auto simp: lead_monom_power n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. lead_monom (sym_mpoly A (Suc i) ^ (g i - g (Suc i)))) =\n  (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = (\\<Sum>i<n. of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i))) =\n    (\\<Sum>i<n.\n        of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))", "proof (intro sum.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_nat (g x - g (Suc x)) * lead_monom (sym_mpoly A (Suc x)) =\n       of_nat (g x - g (Suc x)) * monom_of_set (set (take (Suc x) xs))", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_nat (g x - g (Suc x)) * lead_monom (sym_mpoly A (Suc x)) =\n       of_nat (g x - g (Suc x)) * monom_of_set (set (take (Suc x) xs))", "have \"lead_monom (sym_mpoly A (Suc i) :: 'a mpoly) =\n            lead_monom (sym_mpoly (set xs) (Suc i) :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly A (Suc i)) =\n    lead_monom (sym_mpoly (set xs) (Suc i))", "by (simp add: \\<open>set xs = A\\<close>)"], ["proof (state)\nthis:\n  lead_monom (sym_mpoly A (Suc i)) = lead_monom (sym_mpoly (set xs) (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_nat (g x - g (Suc x)) * lead_monom (sym_mpoly A (Suc x)) =\n       of_nat (g x - g (Suc x)) * monom_of_set (set (take (Suc x) xs))", "also"], ["proof (state)\nthis:\n  lead_monom (sym_mpoly A (Suc i)) = lead_monom (sym_mpoly (set xs) (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_nat (g x - g (Suc x)) * lead_monom (sym_mpoly A (Suc x)) =\n       of_nat (g x - g (Suc x)) * monom_of_set (set (take (Suc x) xs))", "from 1"], ["proof (chain)\npicking this:\n  i \\<in> {..<n}", "have \"\\<dots> = monom_of_set (set (take (Suc i) xs))\""], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. lead_monom (sym_mpoly (set xs) (Suc i)) =\n    monom_of_set (set (take (Suc i) xs))", "by (subst lead_monom_sym_mpoly) (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  lead_monom (sym_mpoly (set xs) (Suc i)) =\n  monom_of_set (set (take (Suc i) xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_nat (g x - g (Suc x)) * lead_monom (sym_mpoly A (Suc x)) =\n       of_nat (g x - g (Suc x)) * monom_of_set (set (take (Suc x) xs))", "finally"], ["proof (chain)\npicking this:\n  lead_monom (sym_mpoly A (Suc i)) = monom_of_set (set (take (Suc i) xs))", "show ?case"], ["proof (prove)\nusing this:\n  lead_monom (sym_mpoly A (Suc i)) = monom_of_set (set (take (Suc i) xs))\n\ngoal (1 subgoal):\n 1. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)) =\n    of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs))", "by simp"], ["proof (state)\nthis:\n  of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i)) =\n  of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_nat (g i - g (Suc i)) * lead_monom (sym_mpoly A (Suc i))) =\n  (\\<Sum>i<n.\n      of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "finally"], ["proof (chain)\npicking this:\n  lead_monom q =\n  (\\<Sum>i<n.\n      of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))", "have lead_monom_q:\n    \"lead_monom q = (\\<Sum>i<n. of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))\""], ["proof (prove)\nusing this:\n  lead_monom q =\n  (\\<Sum>i<n.\n      of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))\n\ngoal (1 subgoal):\n 1. lead_monom q =\n    (\\<Sum>i<n.\n        of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))", "."], ["proof (state)\nthis:\n  lead_monom q =\n  (\\<Sum>i<n.\n      of_nat (g i - g (Suc i)) * monom_of_set (set (take (Suc i) xs)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"lead_monom (c * q) = lead_monom c + lead_monom q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (c * q) = lead_monom c + lead_monom q", "by (simp add: lead_monom_mult)"], ["proof (state)\nthis:\n  lead_monom (c * q) = lead_monom c + lead_monom q\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  lead_monom (c * q) = lead_monom c + lead_monom q\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = lead_monom p\" (is \"?S = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom c + lead_monom q = lead_monom p", "proof (intro poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (lead_monom c + lead_monom q) k = lookup (lead_monom p) k", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       lookup (lead_monom c + lead_monom q) k = lookup (lead_monom p) k", "show \"lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "proof (cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n 2. i \\<notin> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n 2. i \\<notin> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "hence \"lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i +\n               (\\<Sum>j<n. (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\"\n        (is \"_ = _ + ?S\")"], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i =\n    lookup (lead_monom p) i +\n    (\\<Sum>j<n.\n        (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)", "by (simp add: lookup_add lead_monom_q lookup_sum)"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i =\n  lookup (lead_monom p) i +\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n 2. i \\<notin> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i =\n  lookup (lead_monom p) i +\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n 2. i \\<notin> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "from False"], ["proof (chain)\npicking this:\n  i \\<notin> A", "have \"?S = 0\""], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<n.\n        (g j - g (Suc j)) *\n        lookup (monom_of_set (set (take (Suc j) xs))) i) =\n    0", "by (intro sum.neutral) (auto simp: lookup_monom_of_set \\<open>set xs = A\\<close> dest!: in_set_takeD)"], ["proof (state)\nthis:\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i) =\n  0\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n 2. i \\<notin> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "finally"], ["proof (chain)\npicking this:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i + 0\n\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "by simp"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "with \\<open>set xs = A\\<close>"], ["proof (chain)\npicking this:\n  set xs = A\n  i \\<in> A", "obtain m where m: \"i = xs ! m\" \"m < n\""], ["proof (prove)\nusing this:\n  set xs = A\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>i = xs ! m; m < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  i = xs ! m\n  m < n\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"lookup (lead_monom c + lead_monom q) i =\n              (\\<Sum>j<n. (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i =\n    (\\<Sum>j<n.\n        (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)", "using True"], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i =\n    (\\<Sum>j<n.\n        (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)", "by (simp add: lookup_add lookup_sum lead_monom_q)"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i =\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i =\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i)\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"\\<dots> = (\\<Sum>j | j < n \\<and> i \\<in> set (take (Suc j) xs). g j - g (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n.\n        (g j - g (Suc j)) *\n        lookup (monom_of_set (set (take (Suc j) xs))) i) =\n    (\\<Sum>j | j < n \\<and> i \\<in> set (take (Suc j) xs). g j - g (Suc j))", "by (intro sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i) =\n  (\\<Sum>j | j < n \\<and> i \\<in> set (take (Suc j) xs). g j - g (Suc j))\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<n.\n      (g j - g (Suc j)) * lookup (monom_of_set (set (take (Suc j) xs))) i) =\n  (\\<Sum>j | j < n \\<and> i \\<in> set (take (Suc j) xs). g j - g (Suc j))\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"{j. j < n \\<and> i \\<in> set (take (Suc j) xs)} = {m..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. j < n \\<and> i \\<in> set (take (Suc j) xs)} = {m..<n}", "using m \\<open>distinct xs\\<close>"], ["proof (prove)\nusing this:\n  i = xs ! m\n  m < n\n  distinct xs\n\ngoal (1 subgoal):\n 1. {j. j < n \\<and> i \\<in> set (take (Suc j) xs)} = {m..<n}", "by (force simp: set_conv_nth nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  {j. j < n \\<and> i \\<in> set (take (Suc j) xs)} = {m..<n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  {j. j < n \\<and> i \\<in> set (take (Suc j) xs)} = {m..<n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"(\\<Sum>j\\<in>\\<dots>. g j - g (Suc j)) = (\\<Sum>j\\<in>\\<dots>. g j) - (\\<Sum>j\\<in>\\<dots>. g (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = m..<n. g j - g (Suc j)) =\n    sum g {m..<n} - (\\<Sum>j = m..<n. g (Suc j))", "by (subst sum_subtractf_nat) (auto intro!: g_mono)"], ["proof (state)\nthis:\n  (\\<Sum>j = m..<n. g j - g (Suc j)) =\n  sum g {m..<n} - (\\<Sum>j = m..<n. g (Suc j))\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = m..<n. g j - g (Suc j)) =\n  sum g {m..<n} - (\\<Sum>j = m..<n. g (Suc j))\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"(\\<Sum>j\\<in>{m..<n}. g (Suc j)) = (\\<Sum>j\\<in>{m<..n}. g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = m..<n. g (Suc j)) = sum g {m<..n}", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>j. j - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Sum>j = m..<n. g (Suc j)) = sum g {m<..n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = m..<n. g (Suc j)) = sum g {m<..n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"\\<dots> = (\\<Sum>j\\<in>{m<..<n}. g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {m<..n} = sum g {m<..<n}", "by (intro sum.mono_neutral_right) (auto simp: g_def)"], ["proof (state)\nthis:\n  sum g {m<..n} = sum g {m<..<n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  sum g {m<..n} = sum g {m<..<n}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"(\\<Sum>j\\<in>{m..<n}. g j) - \\<dots> = (\\<Sum>j\\<in>{m..<n}-{m<..<n}. g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {m..<n} - sum g {m<..<n} = sum g ({m..<n} - {m<..<n})", "by (intro sum_diff_nat [symmetric]) auto"], ["proof (state)\nthis:\n  sum g {m..<n} - sum g {m<..<n} = sum g ({m..<n} - {m<..<n})\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  sum g {m..<n} - sum g {m<..<n} = sum g ({m..<n} - {m<..<n})\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"{m..<n}-{m<..<n} = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..<n} - {m<..<n} = {m}", "using m"], ["proof (prove)\nusing this:\n  i = xs ! m\n  m < n\n\ngoal (1 subgoal):\n 1. {m..<n} - {m<..<n} = {m}", "by auto"], ["proof (state)\nthis:\n  {m..<n} - {m<..<n} = {m}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "also"], ["proof (state)\nthis:\n  {m..<n} - {m<..<n} = {m}\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "have \"(\\<Sum>j\\<in>\\<dots>. g j) = lookup (lead_monom p) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g {m} = lookup (lead_monom p) i", "using m"], ["proof (prove)\nusing this:\n  i = xs ! m\n  m < n\n\ngoal (1 subgoal):\n 1. sum g {m} = lookup (lead_monom p) i", "by (auto simp: g_def not_less le_Suc_eq f_def)"], ["proof (state)\nthis:\n  sum g {m} = lookup (lead_monom p) i\n\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow>\n    lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "finally"], ["proof (chain)\npicking this:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n\ngoal (1 subgoal):\n 1. lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i", "."], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (lead_monom c + lead_monom q) i = lookup (lead_monom p) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lead_monom c + lead_monom q = lead_monom p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 3. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "finally"], ["proof (chain)\npicking this:\n  lead_monom (c * q) = lead_monom p", "show \"lead_monom (fund_sym_step_poly p) = lead_monom p\""], ["proof (prove)\nusing this:\n  lead_monom (c * q) = lead_monom p\n\ngoal (1 subgoal):\n 1. lead_monom (local.fund_sym_step_poly p) = lead_monom p", "by simp"], ["proof (state)\nthis:\n  lead_monom (local.fund_sym_step_poly p) = lead_monom p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                       (local.fund_sym_step_poly p) =\n                      Symmetric_Polynomials.lead_coeff p\n 2. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "show \"lead_coeff (fund_sym_step_poly p) = lead_coeff p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (local.fund_sym_step_poly p) =\n    Symmetric_Polynomials.lead_coeff p", "by (simp add: lead_coeff_mult)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (local.fund_sym_step_poly p) =\n  Symmetric_Polynomials.lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have *: \"lookup (fund_sym_step_monom p) k = (if k \\<in> {1..n} then g (k - 1) - g k else 0)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.fund_sym_step_monom p) k =\n    (if k \\<in> {1..n} then g (k - 1) - g k else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (local.fund_sym_step_monom p) k =\n    (if k \\<in> {1..n} then g (k - 1) - g k else 0)", "have \"lookup (fund_sym_step_monom p) k =\n            (\\<Sum>x\\<in>(if k \\<in> {1..n} then {k - 1} else {}). g (k - 1) - g k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.fund_sym_step_monom p) k =\n    (\\<Sum>x\\<in>(if k \\<in> {1..n} then {k - 1} else {}). g (k - 1) - g k)", "unfolding fund_sym_step_monom_def lookup_sum Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<n.\n        lookup\n         (Poly_Mapping.single (Suc x)\n           ((if x < n then lookup (lead_monom p) (f x) else 0) -\n            (if Suc x < n then lookup (lead_monom p) (f (Suc x)) else 0)))\n         k) =\n    (\\<Sum>x\\<in>(if k \\<in> {1..n} then {k - 1} else {}). g (k - 1) - g k)", "by (intro sum.mono_neutral_cong_right)\n         (auto simp: g_def lookup_single when_def split: if_splits)"], ["proof (state)\nthis:\n  lookup (local.fund_sym_step_monom p) k =\n  (\\<Sum>x\\<in>(if k \\<in> {1..n} then {k - 1} else {}). g (k - 1) - g k)\n\ngoal (1 subgoal):\n 1. lookup (local.fund_sym_step_monom p) k =\n    (if k \\<in> {1..n} then g (k - 1) - g k else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup (local.fund_sym_step_monom p) k =\n  (\\<Sum>x\\<in>(if k \\<in> {1..n} then {k - 1} else {}). g (k - 1) - g k)\n\ngoal (1 subgoal):\n 1. lookup (local.fund_sym_step_monom p) k =\n    (if k \\<in> {1..n} then g (k - 1) - g k else 0)", "by simp"], ["proof (state)\nthis:\n  lookup (local.fund_sym_step_monom p) k =\n  (if k \\<in> {1..n} then g (k - 1) - g k else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (local.fund_sym_step_monom p) ?k =\n  (if ?k \\<in> {1..n} then g (?k - 1) - g ?k else 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "hence \"(\\<Prod>x. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x :: 'a mpoly) =\n           (\\<Prod>x\\<in>{1..n}. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x)\""], ["proof (prove)\nusing this:\n  lookup (local.fund_sym_step_monom p) ?k =\n  (if ?k \\<in> {1..n} then g (?k - 1) - g ?k else 0)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n    (\\<Prod>x = 1..n.\n        sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)", "by (intro Prod_any.expand_superset) auto"], ["proof (state)\nthis:\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n  (\\<Prod>x = 1..n. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n  (\\<Prod>x = 1..n. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = (\\<Prod>x<n. sym_mpoly A (Suc x) ^ lookup (fund_sym_step_monom p) (Suc x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x = 1..n.\n        sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n    (\\<Prod>x<n.\n        sym_mpoly A (Suc x) ^ lookup (local.fund_sym_step_monom p) (Suc x))", "by (intro prod.reindex_bij_witness[of _ Suc \"\\<lambda>i. i - 1\"]) auto"], ["proof (state)\nthis:\n  (\\<Prod>x = 1..n.\n      sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n  (\\<Prod>x<n.\n      sym_mpoly A (Suc x) ^ lookup (local.fund_sym_step_monom p) (Suc x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "also"], ["proof (state)\nthis:\n  (\\<Prod>x = 1..n.\n      sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) =\n  (\\<Prod>x<n.\n      sym_mpoly A (Suc x) ^ lookup (local.fund_sym_step_monom p) (Suc x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "have \"\\<dots> = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x<n.\n        sym_mpoly A (Suc x) ^\n        lookup (local.fund_sym_step_monom p) (Suc x)) =\n    q", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x<n.\n        sym_mpoly A (Suc x) ^\n        lookup (local.fund_sym_step_monom p) (Suc x)) =\n    (\\<Prod>i<n. sym_mpoly A (Suc i) ^ (g i - g (Suc i)))", "by (intro prod.cong) (auto simp: *)"], ["proof (state)\nthis:\n  (\\<Prod>x<n.\n      sym_mpoly A (Suc x) ^ lookup (local.fund_sym_step_monom p) (Suc x)) =\n  q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_step_poly p =\n                      local.fund_sym_step_coeff p *\n                      (\\<Prod>x. sym_mpoly A x ^\n                                 lookup (local.fund_sym_step_monom p) x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) = q", "show \"fund_sym_step_poly p =\n                  fund_sym_step_coeff p * (\\<Prod>x. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x)\""], ["proof (prove)\nusing this:\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x) = q\n\ngoal (1 subgoal):\n 1. local.fund_sym_step_poly p =\n    local.fund_sym_step_coeff p *\n    (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)", "by (simp add: c_def q_def f_def g_def fund_sym_step_monom_def fund_sym_step_coeff_def)"], ["proof (state)\nthis:\n  local.fund_sym_step_poly p =\n  local.fund_sym_step_coeff p *\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If the input is well-formed, a single step of the procedure always decreases the leading\n  monomial.\n\\<close>"], ["", "lemma lead_monom_fund_sym_step_poly_less:\n  assumes \"finite A\" and \"lead_monom p \\<noteq> 0\" and \"decr p\"\n  shows   \"lead_monom (p - fund_sym_step_poly p) < lead_monom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "proof (cases \"p = fund_sym_step_poly p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p\n 2. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "case True"], ["proof (state)\nthis:\n  p = local.fund_sym_step_poly p\n\ngoal (2 subgoals):\n 1. p = local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p\n 2. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = local.fund_sym_step_poly p\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "using assms"], ["proof (prove)\nusing this:\n  p = local.fund_sym_step_poly p\n  finite A\n  lead_monom p \\<noteq> 0\n  decr p\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  lead_monom (p - local.fund_sym_step_poly p) < lead_monom p\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> local.fund_sym_step_poly p\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  lead_monom p \\<noteq> 0\n  decr p", "have [simp]: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  finite A\n  lead_monom p \\<noteq> 0\n  decr p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "let ?q = \"fund_sym_step_poly p\" and ?m = \"lead_monom p\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "have \"coeff (p - ?q) ?m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) =\n    (0::'a)", "using fund_sym_step_poly[of p] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n  finite A\n  lead_monom p \\<noteq> 0\n  decr p\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) =\n    (0::'a)", "by (simp add: lead_coeff_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) = (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) = (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "have \"lead_coeff (p - ?q) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (p - local.fund_sym_step_poly p) \\<noteq>\n    (0::'a)", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> local.fund_sym_step_poly p\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (p - local.fund_sym_step_poly p) \\<noteq>\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (p - local.fund_sym_step_poly p) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "ultimately"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) = (0::'a)\n  Symmetric_Polynomials.lead_coeff (p - local.fund_sym_step_poly p) \\<noteq>\n  (0::'a)", "have \"lead_monom (p - ?q) \\<noteq> ?m\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) = (0::'a)\n  Symmetric_Polynomials.lead_coeff (p - local.fund_sym_step_poly p) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p", "unfolding lead_coeff_def"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p) (lead_monom p) = (0::'a)\n  MPoly_Type.coeff (p - local.fund_sym_step_poly p)\n   (lead_monom (p - local.fund_sym_step_poly p)) \\<noteq>\n  (0::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p", "by auto"], ["proof (state)\nthis:\n  lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "moreover"], ["proof (state)\nthis:\n  lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "have \"lead_monom (p - ?q) \\<le> ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) \\<le> lead_monom p", "using fund_sym_step_poly[of p] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n  finite A\n  lead_monom p \\<noteq> 0\n  decr p\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) \\<le> lead_monom p", "by (intro order.trans[OF lead_monom_diff] max.boundedI) auto"], ["proof (state)\nthis:\n  lead_monom (p - local.fund_sym_step_poly p) \\<le> lead_monom p\n\ngoal (1 subgoal):\n 1. p \\<noteq> local.fund_sym_step_poly p \\<Longrightarrow>\n    lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "ultimately"], ["proof (chain)\npicking this:\n  lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p\n  lead_monom (p - local.fund_sym_step_poly p) \\<le> lead_monom p", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_monom (p - local.fund_sym_step_poly p) \\<noteq> lead_monom p\n  lead_monom (p - local.fund_sym_step_poly p) \\<le> lead_monom p\n\ngoal (1 subgoal):\n 1. lead_monom (p - local.fund_sym_step_poly p) < lead_monom p", "by (auto simp: order.strict_iff_order)"], ["proof (state)\nthis:\n  lead_monom (p - local.fund_sym_step_poly p) < lead_monom p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Finally, we prove that the witness is indeed well-defined for all inputs.\n\\<close>"], ["", "lemma fund_sym_poly_wit_dom_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"A \\<subseteq> B\"\n  shows   \"fund_sym_poly_wit_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "using assms(1-3)"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "proof (induction p rule: lead_monom_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.fund_sym_poly_wit_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "case (less p)"], ["proof (state)\nthis:\n  vars p \\<subseteq> B\n  \\<lbrakk>vars ?p' \\<subseteq> B; lead_monom ?p' < lead_monom p;\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_poly_wit_dom ?p'\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.fund_sym_poly_wit_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "have [simp]: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by (rule finite_subset[of _ B]) fact+"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.fund_sym_poly_wit_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "proof (cases \"lead_monom p = 0 \\<or> \\<not>symmetric_mpoly A p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "case False"], ["proof (state)\nthis:\n  \\<not> (lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p)\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "hence [simp]: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "note decr = lookup_lead_monom_decreasing[of A p]"], ["proof (state)\nthis:\n  \\<lbrakk>symmetric_mpoly A p; ?i \\<in> A; ?j \\<in> A; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> lookup (lead_monom p) ?j \\<le> lookup (lead_monom p) ?i\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "have \"vars (p - fund_sym_step_poly p) \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "using fund_sym_step_poly[of p] decr False less.prems less.hyps \\<open>A \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n  \\<lbrakk>symmetric_mpoly A p; ?i \\<in> A; ?j \\<in> A; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> lookup (lead_monom p) ?j \\<le> lookup (lead_monom p) ?i\n  \\<not> (lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p)\n  A \\<subseteq> B\n  vars p \\<subseteq> B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "by (intro order.trans[OF vars_diff]) auto"], ["proof (state)\nthis:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "hence \"fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)\""], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)", "using False less.prems less.hyps decr"], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p)\n  A \\<subseteq> B\n  vars p \\<subseteq> B\n  \\<lbrakk>symmetric_mpoly A p; ?i \\<in> A; ?j \\<in> A; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> lookup (lead_monom p) ?j \\<le> lookup (lead_monom p) ?i\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)", "by (intro less.IH fund_sym_step_poly symmetric_mpoly_diff\n                lead_monom_fund_sym_step_poly_less) (auto simp: decr_def)"], ["proof (state)\nthis:\n  local.fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. \\<not> (lead_monom p = 0 \\<or>\n            \\<not> symmetric_mpoly A p) \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "using fund_sym_poly_wit.domintros"], ["proof (prove)\nusing this:\n  local.fund_sym_poly_wit_dom (p - local.fund_sym_step_poly p)\n  (\\<And>x.\n      \\<lbrakk>symmetric_mpoly A ?p; lead_monom ?p \\<noteq> 0;\n       \\<not> local.fund_sym_poly_wit_dom\n               (?p - local.fund_sym_step_poly ?p);\n       x \\<in> vars ?p; x \\<in> A\\<rbrakk>\n      \\<Longrightarrow> False) \\<Longrightarrow>\n  local.fund_sym_poly_wit_dom ?p\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "by blast"], ["proof (state)\nthis:\n  local.fund_sym_poly_wit_dom p\n\ngoal (1 subgoal):\n 1. lead_monom p = 0 \\<or> \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p", "qed (auto intro: fund_sym_poly_wit.domintros)"], ["proof (state)\nthis:\n  local.fund_sym_poly_wit_dom p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_dom [intro]: \"fund_sym_poly_wit_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "consider \"\\<not>symmetric_mpoly A p\" | \"vars p \\<inter> A = {}\"  | \"symmetric_mpoly A p\" \"A \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> thesis;\n     vars p \\<inter> A = {} \\<Longrightarrow> thesis;\n     \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using symmetric_mpoly_imp_orthogonal_or_subset[of A p]"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p \\<Longrightarrow>\n  vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> thesis;\n     vars p \\<inter> A = {} \\<Longrightarrow> thesis;\n     \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> ?thesis;\n   vars p \\<inter> A = {} \\<Longrightarrow> ?thesis;\n   \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> ?thesis;\n   vars p \\<inter> A = {} \\<Longrightarrow> ?thesis;\n   \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. vars p \\<inter> A = {} \\<Longrightarrow> local.fund_sym_poly_wit_dom p\n 3. \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "assume \"symmetric_mpoly A p\" \"A \\<subseteq> vars p\""], ["proof (state)\nthis:\n  symmetric_mpoly A p\n  A \\<subseteq> vars p\n\ngoal (3 subgoals):\n 1. \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. vars p \\<inter> A = {} \\<Longrightarrow> local.fund_sym_poly_wit_dom p\n 3. \\<lbrakk>symmetric_mpoly A p; A \\<subseteq> vars p\\<rbrakk>\n    \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "using fund_sym_poly_wit_dom_aux[of \"vars p\" p]"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n  A \\<subseteq> vars p\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_poly_wit_dom p\n\ngoal (1 subgoal):\n 1. local.fund_sym_poly_wit_dom p", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  local.fund_sym_poly_wit_dom p\n\ngoal (2 subgoals):\n 1. \\<not> symmetric_mpoly A p \\<Longrightarrow>\n    local.fund_sym_poly_wit_dom p\n 2. vars p \\<inter> A = {} \\<Longrightarrow> local.fund_sym_poly_wit_dom p", "qed (auto intro: fund_sym_poly_wit.domintros)"], ["proof (state)\nthis:\n  local.fund_sym_poly_wit_dom p\n\ngoal:\nNo subgoals!", "qed"], ["", "termination fund_sym_poly_wit"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.fund_sym_poly_wit_dom", "by (intro allI fund_sym_poly_wit_dom)"], ["", "(*<*)"], ["", "lemmas [simp del] = fund_sym_poly_wit.simps"], ["", "(*>*)"], ["", "text \\<open>\n  Next, we prove that our witness indeed fulfils all the properties stated by the fundamental\n  theorem:\n    \\<^enum> If the original polynomial was in $R[X_1,\\ldots,X_n,\\ldots, X_m]$ where the $X_1$ to\n      $X_n$ are the symmetric variables, then the witness is a polynomial in\n      $R[X_{n+1},\\ldots,X_m][Y_1,\\ldots,Y_n]$. This means that its coefficients are polynomials\n      in the variables of the original polynomial, minus the symmetric ones, and\n      the (new and independent) variables of the witness polynomial range from $1$ to $n$.\n    \\<^enum> Substituting the \\<open>i\\<close>-th symmetric polynomial $e_i(X_1,\\ldots,X_n)$ for the $Y_i$\n      variable for every \\<open>i\\<close> yields the original polynomial.\n    \\<^enum> The coefficient ring $R$ need not be the entire type; if the coefficients of the original\n      polynomial are in some subring, then the coefficients of the coefficients of the witness\n      also do.\n\\<close>"], ["", "lemma fund_sym_poly_wit_coeffs_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"symmetric_mpoly A p\" \"A \\<subseteq> B\"\n  shows   \"vars (coeff (fund_sym_poly_wit p) m) \\<subseteq> B - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "using assms"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "proof (induction p rule: fund_sym_poly_wit.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> vars\n                                   (MPoly_Type.coeff\n                                     (local.fund_sym_poly_wit\n (p - local.fund_sym_step_poly p))\n                                     m)\n                                  \\<subseteq> B - A;\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> vars\n                          (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n                         \\<subseteq> B - A", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> vars\n                     (MPoly_Type.coeff\n                       (local.fund_sym_poly_wit\n                         (p - local.fund_sym_step_poly p))\n                       m)\n                    \\<subseteq> B - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> vars\n                                   (MPoly_Type.coeff\n                                     (local.fund_sym_poly_wit\n (p - local.fund_sym_step_poly p))\n                                     m)\n                                  \\<subseteq> B - A;\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> vars\n                          (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n                         \\<subseteq> B - A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "proof (cases \"lead_monom p = 0 \\<or> vars p \\<inter> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "case False"], ["proof (state)\nthis:\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "have \"vars (p - fund_sym_step_poly p) \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "using \"1.prems\" fund_sym_step_poly[of p]"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "by (intro order.trans[OF vars_diff]) auto"], ["proof (state)\nthis:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "with 1 False"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> vars\n                     (MPoly_Type.coeff\n                       (local.fund_sym_poly_wit\n                         (p - local.fund_sym_step_poly p))\n                       m)\n                    \\<subseteq> B - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "have \"vars (coeff (fund_sym_poly_wit (p - fund_sym_step_poly p)) m) \\<subseteq> B - A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> vars\n                     (MPoly_Type.coeff\n                       (local.fund_sym_poly_wit\n                         (p - local.fund_sym_step_poly p))\n                       m)\n                    \\<subseteq> B - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.coeff\n       (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n    \\<subseteq> B - A", "by (intro 1 symmetric_mpoly_diff fund_sym_step_poly) auto"], ["proof (state)\nthis:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n  \\<subseteq> B - A\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "hence \"vars (coeff (fund_sym_poly_wit (p - fund_sym_step_poly p) +\n                monom (fund_sym_step_monom p) (fund_sym_step_coeff p)) m) \\<subseteq> B - A\""], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n  \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.coeff\n       (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n        MPoly_Type.monom (local.fund_sym_step_monom p)\n         (local.fund_sym_step_coeff p))\n       m)\n    \\<subseteq> B - A", "unfolding coeff_add coeff_monom"], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n  \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.coeff\n       (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m +\n      (local.fund_sym_step_coeff p when m = local.fund_sym_step_monom p))\n    \\<subseteq> B - A", "using vars_fund_sym_step_coeff[of p] \"1.prems\""], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n  \\<subseteq> B - A\n  vars (local.fund_sym_step_coeff p) \\<subseteq> vars p - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.coeff\n       (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m +\n      (local.fund_sym_step_coeff p when m = local.fund_sym_step_monom p))\n    \\<subseteq> B - A", "by (intro order.trans[OF vars_add] Un_least order.trans[OF vars_monom_subset])\n         (auto simp: when_def)"], ["proof (state)\nthis:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n      MPoly_Type.monom (local.fund_sym_step_monom p)\n       (local.fund_sym_step_coeff p))\n     m)\n  \\<subseteq> B - A\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n      MPoly_Type.monom (local.fund_sym_step_monom p)\n       (local.fund_sym_step_coeff p))\n     m)\n  \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "using \"1.prems\" False"], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n      MPoly_Type.monom (local.fund_sym_step_monom p)\n       (local.fund_sym_step_coeff p))\n     m)\n  \\<subseteq> B - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "unfolding fund_sym_poly_wit.simps[of p]"], ["proof (prove)\nusing this:\n  vars\n   (MPoly_Type.coeff\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n      MPoly_Type.monom (local.fund_sym_step_monom p)\n       (local.fund_sym_step_coeff p))\n     m)\n  \\<subseteq> B - A\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.coeff\n       (if \\<not> symmetric_mpoly A p \\<or>\n           lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n        then Const p\n        else local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n             MPoly_Type.monom (local.fund_sym_step_monom p)\n              (local.fund_sym_step_coeff p))\n       m)\n    \\<subseteq> B - A", "by simp"], ["proof (state)\nthis:\n  vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A", "qed (insert \"1.prems\",\n       auto simp: fund_sym_poly_wit.simps[of p] mpoly_coeff_Const lead_monom_eq_0_iff)"], ["proof (state)\nthis:\n  vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) \\<subseteq> B - A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_coeffs:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"vars (coeff (fund_sym_poly_wit p) m) \\<subseteq> vars p - A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "proof (cases \"A \\<subseteq> vars p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "case True"], ["proof (state)\nthis:\n  A \\<subseteq> vars p\n\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "with fund_sym_poly_wit_coeffs_aux[of \"vars p\" p m] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p; symmetric_mpoly A p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n                    \\<subseteq> vars p - A\n  symmetric_mpoly A p\n  A \\<subseteq> vars p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p; symmetric_mpoly A p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n                    \\<subseteq> vars p - A\n  symmetric_mpoly A p\n  A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n  \\<subseteq> vars p - A\n\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "hence \"vars p \\<inter> A = {}\""], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars p \\<inter> A = {}", "using symmetric_mpoly_imp_orthogonal_or_subset[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> vars p\n  vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars p \\<inter> A = {}", "by auto"], ["proof (state)\nthis:\n  vars p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n    \\<subseteq> vars p - A", "by (auto simp: fund_sym_poly_wit.simps[of p] mpoly_coeff_Const)"], ["proof (state)\nthis:\n  vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) m)\n  \\<subseteq> vars p - A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_vars: \"vars (fund_sym_poly_wit p) \\<subseteq> {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "proof (cases \"symmetric_mpoly A p \\<and> A \\<subseteq> vars p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. symmetric_mpoly A p \\<and> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "case True"], ["proof (state)\nthis:\n  symmetric_mpoly A p \\<and> A \\<subseteq> vars p\n\ngoal (2 subgoals):\n 1. symmetric_mpoly A p \\<and> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "define B where \"B = vars p\""], ["proof (state)\nthis:\n  B = vars p\n\ngoal (2 subgoals):\n 1. symmetric_mpoly A p \\<and> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "have \"finite B\" \"vars p \\<subseteq> B\" \"symmetric_mpoly A p\" \"A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite B &&& vars p \\<subseteq> B) &&&\n    symmetric_mpoly A p &&& A \\<subseteq> B", "using True"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p \\<and> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. (finite B &&& vars p \\<subseteq> B) &&&\n    symmetric_mpoly A p &&& A \\<subseteq> B", "unfolding B_def"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p \\<and> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. (finite (vars p) &&& vars p \\<subseteq> vars p) &&&\n    symmetric_mpoly A p &&& A \\<subseteq> vars p", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (2 subgoals):\n 1. symmetric_mpoly A p \\<and> A \\<subseteq> vars p \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "proof (induction p rule: fund_sym_poly_wit.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> vars\n                                   (local.fund_sym_poly_wit\n                                     (p - local.fund_sym_step_poly p))\n                                  \\<subseteq> {1..n};\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> vars\n                     (local.fund_sym_poly_wit\n                       (p - local.fund_sym_step_poly p))\n                    \\<subseteq> {1..n}\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> vars\n                                   (local.fund_sym_poly_wit\n                                     (p - local.fund_sym_step_poly p))\n                                  \\<subseteq> {1..n};\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "proof (cases \"lead_monom p = 0 \\<or> vars p \\<inter> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "case False"], ["proof (state)\nthis:\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "have \"vars (p - fund_sym_step_poly p) \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "using \"1.prems\" fund_sym_step_poly[of p]"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "by (intro order.trans[OF vars_diff]) auto"], ["proof (state)\nthis:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "hence \"vars (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) \\<subseteq> {1..n}\""], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n    \\<subseteq> {1..n}", "using False \"1.prems\""], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n    \\<subseteq> {1..n}", "by (intro 1 symmetric_mpoly_diff fund_sym_step_poly) (auto simp: lead_monom_eq_0_iff)"], ["proof (state)\nthis:\n  vars (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n  \\<subseteq> {1..n}\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "hence \"vars (fund_sym_poly_wit (p - fund_sym_step_poly p) +\n              monom (fund_sym_step_monom p) (local.fund_sym_step_coeff p)) \\<subseteq> {1..n}\""], ["proof (prove)\nusing this:\n  vars (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n  \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. vars\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n      MPoly_Type.monom (local.fund_sym_step_monom p)\n       (local.fund_sym_step_coeff p))\n    \\<subseteq> {1..n}", "by (intro order.trans[OF vars_add] Un_least order.trans[OF vars_monom_subset]\n                  keys_fund_sym_step_monom) auto"], ["proof (state)\nthis:\n  vars\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n    MPoly_Type.monom (local.fund_sym_step_monom p)\n     (local.fund_sym_step_coeff p))\n  \\<subseteq> {1..n}\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n    MPoly_Type.monom (local.fund_sym_step_monom p)\n     (local.fund_sym_step_coeff p))\n  \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "using \"1.prems\" False"], ["proof (prove)\nusing this:\n  vars\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n    MPoly_Type.monom (local.fund_sym_step_monom p)\n     (local.fund_sym_step_coeff p))\n  \\<subseteq> {1..n}\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "unfolding fund_sym_poly_wit.simps[of p]"], ["proof (prove)\nusing this:\n  vars\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n    MPoly_Type.monom (local.fund_sym_step_monom p)\n     (local.fund_sym_step_coeff p))\n  \\<subseteq> {1..n}\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. vars\n     (if \\<not> symmetric_mpoly A p \\<or>\n         lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n      then Const p\n      else local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n           MPoly_Type.monom (local.fund_sym_step_monom p)\n            (local.fund_sym_step_coeff p))\n    \\<subseteq> {1..n}", "by simp"], ["proof (state)\nthis:\n  vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "qed (insert \"1.prems\",\n         auto simp: fund_sym_poly_wit.simps[of p] mpoly_coeff_Const lead_monom_eq_0_iff)"], ["proof (state)\nthis:\n  vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "case False"], ["proof (state)\nthis:\n  \\<not> (symmetric_mpoly A p \\<and> A \\<subseteq> vars p)\n\ngoal (1 subgoal):\n 1. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "then"], ["proof (chain)\npicking this:\n  \\<not> (symmetric_mpoly A p \\<and> A \\<subseteq> vars p)", "consider \"\\<not>symmetric_mpoly A p\" | \"symmetric_mpoly A p\" \"vars p \\<inter> A = {}\""], ["proof (prove)\nusing this:\n  \\<not> (symmetric_mpoly A p \\<and> A \\<subseteq> vars p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> thesis;\n     \\<lbrakk>symmetric_mpoly A p; vars p \\<inter> A = {}\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using symmetric_mpoly_imp_orthogonal_or_subset[of A p]"], ["proof (prove)\nusing this:\n  \\<not> (symmetric_mpoly A p \\<and> A \\<subseteq> vars p)\n  symmetric_mpoly A p \\<Longrightarrow>\n  vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> thesis;\n     \\<lbrakk>symmetric_mpoly A p; vars p \\<inter> A = {}\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> ?thesis;\n   \\<lbrakk>symmetric_mpoly A p; vars p \\<inter> A = {}\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (symmetric_mpoly A p \\<and>\n            A \\<subseteq> vars p) \\<Longrightarrow>\n    vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> symmetric_mpoly A p \\<Longrightarrow> ?thesis;\n   \\<lbrakk>symmetric_mpoly A p; vars p \\<inter> A = {}\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}", "by cases (auto simp: fund_sym_poly_wit.simps[of p])"], ["proof (state)\nthis:\n  vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_insertion_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"symmetric_mpoly A p\" \"A \\<subseteq> B\"\n  shows   \"insertion (sym_mpoly A) (fund_sym_poly_wit p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "using assms"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "proof (induction p rule: fund_sym_poly_wit.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> insertion (sym_mpoly A)\n                                   (local.fund_sym_poly_wit\n                                     (p - local.fund_sym_step_poly p)) =\n                                  p - local.fund_sym_step_poly p;\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> insertion (sym_mpoly A)\n                          (local.fund_sym_poly_wit p) =\n                         p", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> insertion (sym_mpoly A)\n                     (local.fund_sym_poly_wit\n                       (p - local.fund_sym_step_poly p)) =\n                    p - local.fund_sym_step_poly p\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> insertion (sym_mpoly A)\n                                   (local.fund_sym_poly_wit\n                                     (p - local.fund_sym_step_poly p)) =\n                                  p - local.fund_sym_step_poly p;\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> insertion (sym_mpoly A)\n                          (local.fund_sym_poly_wit p) =\n                         p", "from \"1.prems\""], ["proof (chain)\npicking this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B", "have \"decr p\""], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. decr p", "using lookup_lead_monom_decreasing[of A p]"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<lbrakk>symmetric_mpoly A p; ?i \\<in> A; ?j \\<in> A; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> lookup (lead_monom p) ?j \\<le> lookup (lead_monom p) ?i\n\ngoal (1 subgoal):\n 1. decr p", "by (auto simp: decr_def)"], ["proof (state)\nthis:\n  decr p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 finite B;\n                 vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n                 symmetric_mpoly A (p - local.fund_sym_step_poly p);\n                 A \\<subseteq> B\\<rbrakk>\n                \\<Longrightarrow> insertion (sym_mpoly A)\n                                   (local.fund_sym_poly_wit\n                                     (p - local.fund_sym_step_poly p)) =\n                                  p - local.fund_sym_step_poly p;\n        finite B; vars p \\<subseteq> B; symmetric_mpoly A p;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> insertion (sym_mpoly A)\n                          (local.fund_sym_poly_wit p) =\n                         p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "proof (cases \"lead_monom p = 0 \\<or> vars p \\<inter> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "case False"], ["proof (state)\nthis:\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "have \"vars (p - fund_sym_step_poly p) \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "using \"1.prems\" fund_sym_step_poly[of p]"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "by (intro order.trans[OF vars_diff]) auto"], ["proof (state)\nthis:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "hence \"insertion (sym_mpoly A) (fund_sym_poly_wit (p - fund_sym_step_poly p)) =\n            p - fund_sym_step_poly p\""], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A)\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n    p - local.fund_sym_step_poly p", "using 1 False"], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   finite B; vars (p - local.fund_sym_step_poly p) \\<subseteq> B;\n   symmetric_mpoly A (p - local.fund_sym_step_poly p);\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> insertion (sym_mpoly A)\n                     (local.fund_sym_poly_wit\n                       (p - local.fund_sym_step_poly p)) =\n                    p - local.fund_sym_step_poly p\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A)\n     (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n    p - local.fund_sym_step_poly p", "by (intro 1 symmetric_mpoly_diff fund_sym_step_poly) auto"], ["proof (state)\nthis:\n  insertion (sym_mpoly A)\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n  p - local.fund_sym_step_poly p\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "moreover"], ["proof (state)\nthis:\n  insertion (sym_mpoly A)\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n  p - local.fund_sym_step_poly p\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "have \"fund_sym_step_poly p =\n                    fund_sym_step_coeff p * (\\<Prod>x. sym_mpoly A x ^ lookup (fund_sym_step_monom p) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fund_sym_step_poly p =\n    local.fund_sym_step_coeff p *\n    (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)", "using \"1.prems\" finite_subset[of A B] False \\<open>decr p\\<close>"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  symmetric_mpoly A p\n  A \\<subseteq> B\n  \\<lbrakk>A \\<subseteq> B; finite B\\<rbrakk> \\<Longrightarrow> finite A\n  \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  decr p\n\ngoal (1 subgoal):\n 1. local.fund_sym_step_poly p =\n    local.fund_sym_step_coeff p *\n    (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)", "by (intro fund_sym_step_poly) auto"], ["proof (state)\nthis:\n  local.fund_sym_step_poly p =\n  local.fund_sym_step_coeff p *\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> (lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "ultimately"], ["proof (chain)\npicking this:\n  insertion (sym_mpoly A)\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n  p - local.fund_sym_step_poly p\n  local.fund_sym_step_poly p =\n  local.fund_sym_step_coeff p *\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion (sym_mpoly A)\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n  p - local.fund_sym_step_poly p\n  local.fund_sym_step_poly p =\n  local.fund_sym_step_coeff p *\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "unfolding fund_sym_poly_wit.simps[of p]"], ["proof (prove)\nusing this:\n  insertion (sym_mpoly A)\n   (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) =\n  p - local.fund_sym_step_poly p\n  local.fund_sym_step_poly p =\n  local.fund_sym_step_coeff p *\n  (\\<Prod>x. sym_mpoly A x ^ lookup (local.fund_sym_step_monom p) x)\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A)\n     (if \\<not> symmetric_mpoly A p \\<or>\n         lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n      then Const p\n      else local.fund_sym_poly_wit (p - local.fund_sym_step_poly p) +\n           MPoly_Type.monom (local.fund_sym_step_monom p)\n            (local.fund_sym_step_coeff p)) =\n    p", "by (auto simp: insertion_add)"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n\ngoal (1 subgoal):\n 1. lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "qed (auto simp: fund_sym_poly_wit.simps[of p])"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_insertion:\n  assumes \"symmetric_mpoly A p\"\n  shows   \"insertion (sym_mpoly A) (fund_sym_poly_wit p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "proof (cases \"A \\<subseteq> vars p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<subseteq> vars p\n\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "hence \"vars p \\<inter> A = {}\""], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars p \\<inter> A = {}", "using symmetric_mpoly_imp_orthogonal_or_subset[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> vars p\n  vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. vars p \\<inter> A = {}", "by auto"], ["proof (state)\nthis:\n  vars p \\<inter> A = {}\n\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "by (auto simp: fund_sym_poly_wit.simps[of p])"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n\ngoal (1 subgoal):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "case True"], ["proof (state)\nthis:\n  A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. A \\<subseteq> vars p \\<Longrightarrow>\n    insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "with fund_sym_poly_wit_insertion_aux[of \"vars p\" p] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p; symmetric_mpoly A p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n  symmetric_mpoly A p\n  A \\<subseteq> vars p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p; symmetric_mpoly A p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n  symmetric_mpoly A p\n  A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fund_sym_poly_wit_coeff:\n  assumes \"\\<forall>m. coeff p m \\<in> C\" \"ring_closed C\"\n  shows   \"\\<forall>m m'. coeff (coeff (fund_sym_poly_wit p) m) m' \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "proof (induction p rule: fund_sym_poly_wit.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 \\<forall>m.\n                    MPoly_Type.coeff (p - local.fund_sym_step_poly p) m\n                    \\<in> C\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m m'.\n                                     MPoly_Type.coeff\n(MPoly_Type.coeff (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n  m)\nm'\n                                     \\<in> C;\n        \\<forall>m. MPoly_Type.coeff p m \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m m'.\n                            MPoly_Type.coeff\n                             (MPoly_Type.coeff (local.fund_sym_poly_wit p)\n                               m)\n                             m'\n                            \\<in> C", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                   lead_monom p = 0 \\<or> vars p \\<inter> A = {});\n   \\<forall>m.\n      MPoly_Type.coeff (p - local.fund_sym_step_poly p) m \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m m'.\n                       MPoly_Type.coeff\n                        (MPoly_Type.coeff\n                          (local.fund_sym_poly_wit\n                            (p - local.fund_sym_step_poly p))\n                          m)\n                        m'\n                       \\<in> C\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 \\<forall>m.\n                    MPoly_Type.coeff (p - local.fund_sym_step_poly p) m\n                    \\<in> C\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m m'.\n                                     MPoly_Type.coeff\n(MPoly_Type.coeff (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n  m)\nm'\n                                     \\<in> C;\n        \\<forall>m. MPoly_Type.coeff p m \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m m'.\n                            MPoly_Type.coeff\n                             (MPoly_Type.coeff (local.fund_sym_poly_wit p)\n                               m)\n                             m'\n                            \\<in> C", "interpret ring_closed C"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed C", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<lbrakk>\\<not> (\\<not> symmetric_mpoly A p \\<or>\n                                 lead_monom p = 0 \\<or>\n                                 vars p \\<inter> A = {});\n                 \\<forall>m.\n                    MPoly_Type.coeff (p - local.fund_sym_step_poly p) m\n                    \\<in> C\\<rbrakk>\n                \\<Longrightarrow> \\<forall>m m'.\n                                     MPoly_Type.coeff\n(MPoly_Type.coeff (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p))\n  m)\nm'\n                                     \\<in> C;\n        \\<forall>m. MPoly_Type.coeff p m \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>m m'.\n                            MPoly_Type.coeff\n                             (MPoly_Type.coeff (local.fund_sym_poly_wit p)\n                               m)\n                             m'\n                            \\<in> C", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "proof (cases \"\\<not>symmetric_mpoly A p \\<or> lead_monom p = 0 \\<or> vars p \\<inter> A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> symmetric_mpoly A p \\<or>\n    lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C\n 2. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "case True"], ["proof (state)\nthis:\n  \\<not> symmetric_mpoly A p \\<or>\n  lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n\ngoal (2 subgoals):\n 1. \\<not> symmetric_mpoly A p \\<or>\n    lead_monom p = 0 \\<or> vars p \\<inter> A = {} \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C\n 2. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> symmetric_mpoly A p \\<or>\n  lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "using \"1.prems\""], ["proof (prove)\nusing this:\n  \\<not> symmetric_mpoly A p \\<or>\n  lead_monom p = 0 \\<or> vars p \\<inter> A = {}\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "by (auto simp: fund_sym_poly_wit.simps[of p] mpoly_coeff_Const)"], ["proof (state)\nthis:\n  \\<forall>m m'.\n     MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n     \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<not> symmetric_mpoly A p \\<or>\n          lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "have *: \"\\<forall>m m'. coeff (coeff (fund_sym_poly_wit (p - fund_sym_step_poly p)) m) m' \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff\n        (MPoly_Type.coeff\n          (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n        m'\n       \\<in> C", "using False \"1.prems\" assms coeff_fund_sym_step_poly [of p]"], ["proof (prove)\nusing this:\n  \\<not> (\\<not> symmetric_mpoly A p \\<or>\n          lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n  ring_closed C\n  \\<lbrakk>\\<forall>m. MPoly_Type.coeff p m \\<in> ?C;\n   ring_closed ?C\\<rbrakk>\n  \\<Longrightarrow> MPoly_Type.coeff (local.fund_sym_step_poly p) ?m\n                    \\<in> ?C\n\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff\n        (MPoly_Type.coeff\n          (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n        m'\n       \\<in> C", "by (intro 1) auto"], ["proof (state)\nthis:\n  \\<forall>m m'.\n     MPoly_Type.coeff\n      (MPoly_Type.coeff\n        (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n      m'\n     \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<not> symmetric_mpoly A p \\<or>\n            lead_monom p = 0 \\<or> vars p \\<inter> A = {}) \\<Longrightarrow>\n    \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "proof (intro allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "case (1 m m')"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n       \\<in> C", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n    \\<in> C", "using * False coeff_fund_sym_step_coeff[of p m'] \"1.prems\""], ["proof (prove)\nusing this:\n  \\<forall>m m'.\n     MPoly_Type.coeff\n      (MPoly_Type.coeff\n        (local.fund_sym_poly_wit (p - local.fund_sym_step_poly p)) m)\n      m'\n     \\<in> C\n  \\<not> (\\<not> symmetric_mpoly A p \\<or>\n          lead_monom p = 0 \\<or> vars p \\<inter> A = {})\n  MPoly_Type.coeff (local.fund_sym_step_coeff p) m'\n  \\<in> {Symmetric_Polynomials.lead_coeff p, 0::'a}\n  \\<forall>m. MPoly_Type.coeff p m \\<in> C\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n    \\<in> C", "by (auto simp: fund_sym_poly_wit.simps[of p] coeff_monom lead_coeff_def when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n  \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m m'.\n     MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n     \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m m'.\n     MPoly_Type.coeff (MPoly_Type.coeff (local.fund_sym_poly_wit p) m) m'\n     \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Uniqueness\\<close>"], ["", "text \\<open>\n  Next, we show that the polynomial representation of a symmetric polynomial in terms of the\n  elementary symmetric polynomials not only exists, but is unique.\n\n  The key property here is that products of powers of elementary symmetric polynomials uniquely\n  determine the exponent vectors, i.\\,e.\\ if $e_1, \\ldots, e_n$ are the elementary symmetric\n  polynomials, $a = (a_1,\\ldots, a_n)$ and $b = (b_1,\\ldots,b_n)$ are vectors of natural numbers,\n  then:\n  \\[e_1^{a_1}\\ldots e_n^{a_n} = e_1^{b_1}\\ldots  e_n^{b_n} \\longleftrightarrow a = b\\]\n  We show this now.\n\\<close>"], ["", "lemma lead_monom_sym_mpoly_prod:\n  assumes \"finite A\"\n  shows   \"lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i :: 'a mpoly) =\n             (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "have \"(\\<Prod>i=1..n. lead_coeff (sym_mpoly A i ^ h i :: 'a mpoly)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..n.\n        Symmetric_Polynomials.lead_coeff (sym_mpoly A i ^ h i)) =\n    (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..n.\n        Symmetric_Polynomials.lead_coeff (sym_mpoly A i ^ h i)) =\n    (1::'a)", "unfolding n_def"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..card A.\n        Symmetric_Polynomials.lead_coeff (sym_mpoly A i ^ h i)) =\n    (1::'a)", "by (intro prod.neutral allI) (auto simp: lead_coeff_power)"], ["proof (state)\nthis:\n  (\\<Prod>i = 1..n.\n      Symmetric_Polynomials.lead_coeff (sym_mpoly A i ^ h i)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "hence \"lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ h i :: 'a mpoly) =\n           (\\<Sum>i=1..n. lead_monom (sym_mpoly A i ^ h i :: 'a mpoly))\""], ["proof (prove)\nusing this:\n  (\\<Prod>i = 1..n.\n      Symmetric_Polynomials.lead_coeff (sym_mpoly A i ^ h i)) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. lead_monom (sym_mpoly A i ^ h i))", "by (subst lead_monom_prod) auto"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. lead_monom (sym_mpoly A i ^ h i))\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "also"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. lead_monom (sym_mpoly A i ^ h i))\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "have \"\\<dots> = (\\<Sum>i=1..n. of_nat (h i) * lead_monom (sym_mpoly A i :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..n. lead_monom (sym_mpoly A i ^ h i)) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "by (intro sum.cong refl, subst lead_monom_power)\n       (auto simp: lead_coeff_power assms n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..n. lead_monom (sym_mpoly A i ^ h i)) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "finally"], ["proof (chain)\npicking this:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))", "."], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly A i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_sym_mpoly_prod_notin:\n  assumes \"finite A\" \"k \\<notin> A\"\n  shows   \"lookup (lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ h i :: 'a mpoly)) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "have xs: \"set xs = A\" \"distinct xs\" \"sorted xs\" and [simp]: \"length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  k \\<notin> A\n\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "by (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  sorted xs\n  length xs = n\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "have \"lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i :: 'a mpoly) =\n          (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))", "by (subst lead_monom_sym_mpoly_prod) (use xs assms in auto)"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "also"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "have \"lookup \\<dots> k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i)) k =\n    0", "unfolding lookup_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 1..n.\n        lookup (of_nat (h x) * lead_monom (sym_mpoly (set xs) x)) k) =\n    0", "by (intro sum.neutral ballI, subst lead_monom_sym_mpoly)\n      (insert xs assms, auto simp: xs lead_monom_sym_mpoly lookup_monom_of_set set_conv_nth)"], ["proof (state)\nthis:\n  lookup (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))\n   k =\n  0\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "finally"], ["proof (chain)\npicking this:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0", "."], ["proof (state)\nthis:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) k = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_sym_mpoly_prod_in:\n  assumes \"finite A\" \"k < n\"\n  shows   \"lookup (lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ h i :: 'a mpoly)) (xs ! k) =\n             (\\<Sum>i=k+1..n. h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "have xs: \"set xs = A\" \"distinct xs\" \"sorted xs\" and [simp]: \"length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  k < n\n\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "by (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  sorted xs\n  length xs = n\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "have \"lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i :: 'a mpoly) =\n             (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n    (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))", "by (subst lead_monom_sym_mpoly_prod) (use xs assms in simp_all)"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "also"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i) =\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "have \"\\<dots> = (\\<Sum>i=1..n. of_nat (h i) * monom_of_set (set (take i xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i)) =\n    (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))", "using xs"], ["proof (prove)\nusing this:\n  set xs = A\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i)) =\n    (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))", "by (intro sum.cong refl, subst lead_monom_sym_mpoly) auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i)) =\n  (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 1..n. of_nat (h i) * lead_monom (sym_mpoly (set xs) i)) =\n  (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "have \"lookup \\<dots> (xs ! k) = (\\<Sum>i | i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs). h i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))\n     (xs ! k) =\n    (\\<Sum>i | i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs). h i)", "unfolding lookup_sum lookup_monom_of_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 1..n.\n        lookup (of_nat (h x) * monom_of_set (set (take x xs))) (xs ! k)) =\n    (\\<Sum>i | i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs). h i)", "by (intro sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  lookup (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))\n   (xs ! k) =\n  (\\<Sum>i | i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs). h i)\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "also"], ["proof (state)\nthis:\n  lookup (\\<Sum>i = 1..n. of_nat (h i) * monom_of_set (set (take i xs)))\n   (xs ! k) =\n  (\\<Sum>i | i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs). h i)\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "have \"{i. i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs)} = {k+1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)} = {k + 1..n}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {i \\<in> {1..n}.\n                xs ! k \\<in> set (take i xs)} \\<Longrightarrow>\n       x \\<in> {k + 1..n}\n 2. \\<And>x.\n       x \\<in> {k + 1..n} \\<Longrightarrow>\n       x \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {i \\<in> {1..n}.\n                xs ! k \\<in> set (take i xs)} \\<Longrightarrow>\n       x \\<in> {k + 1..n}\n 2. \\<And>x.\n       x \\<in> {k + 1..n} \\<Longrightarrow>\n       x \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}", "assume i: \"i \\<in> {k+1..n}\""], ["proof (state)\nthis:\n  i \\<in> {k + 1..n}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {i \\<in> {1..n}.\n                xs ! k \\<in> set (take i xs)} \\<Longrightarrow>\n       x \\<in> {k + 1..n}\n 2. \\<And>x.\n       x \\<in> {k + 1..n} \\<Longrightarrow>\n       x \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}", "hence \"take i xs ! k = xs ! k\" \"k < n\" \"k < i\""], ["proof (prove)\nusing this:\n  i \\<in> {k + 1..n}\n\ngoal (1 subgoal):\n 1. take i xs ! k = xs ! k &&& k < n &&& k < i", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> {k + 1..n}\n  finite A\n  k < n\n\ngoal (1 subgoal):\n 1. take i xs ! k = xs ! k &&& k < n &&& k < i", "by auto"], ["proof (state)\nthis:\n  take i xs ! k = xs ! k\n  k < n\n  k < i\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {i \\<in> {1..n}.\n                xs ! k \\<in> set (take i xs)} \\<Longrightarrow>\n       x \\<in> {k + 1..n}\n 2. \\<And>x.\n       x \\<in> {k + 1..n} \\<Longrightarrow>\n       x \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}", "with i"], ["proof (chain)\npicking this:\n  i \\<in> {k + 1..n}\n  take i xs ! k = xs ! k\n  k < n\n  k < i", "show \"i \\<in> {i. i \\<in> {1..n} \\<and> xs ! k \\<in> set (take i xs)}\""], ["proof (prove)\nusing this:\n  i \\<in> {k + 1..n}\n  take i xs ! k = xs ! k\n  k < n\n  k < i\n\ngoal (1 subgoal):\n 1. i \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}", "by (force simp: set_conv_nth)"], ["proof (state)\nthis:\n  i \\<in> {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {i \\<in> {1..n}.\n                xs ! k \\<in> set (take i xs)} \\<Longrightarrow>\n       x \\<in> {k + 1..n}", "qed (insert assms xs, auto simp: set_conv_nth Suc_le_eq nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  {i \\<in> {1..n}. xs ! k \\<in> set (take i xs)} = {k + 1..n}\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "finally"], ["proof (chain)\npicking this:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n  sum h {k + 1..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n  sum h {k + 1..n}\n\ngoal (1 subgoal):\n 1. lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n    sum h {k + 1..n}", "."], ["proof (state)\nthis:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ h i)) (xs ! k) =\n  sum h {k + 1..n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_monom_sym_poly_powerprod_inj:\n  assumes \"lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i :: 'a mpoly) =\n             lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i :: 'a mpoly)\"\n  assumes \"finite A\" \"keys m1 \\<subseteq> {1..n}\" \"keys m2 \\<subseteq> {1..n}\"\n  shows   \"m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "proof (rule poly_mapping_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "have xs: \"set xs = A\" \"distinct xs\" \"sorted xs\" and [simp]: \"length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "using assms"], ["proof (prove)\nusing this:\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)\n  finite A\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "by (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  sorted xs\n  length xs = n\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "from assms(3,4)"], ["proof (chain)\npicking this:\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}", "have *: \"i \\<in> {1..n}\" if \"lookup m1 i \\<noteq> 0 \\<or> lookup m2 i \\<noteq> 0\" for i"], ["proof (prove)\nusing this:\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. i \\<in> {1..n}", "using that"], ["proof (prove)\nusing this:\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}\n  lookup m1 i \\<noteq> 0 \\<or> lookup m2 i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<in> {1..n}", "by (auto simp: subset_iff in_keys_iff)"], ["proof (state)\nthis:\n  lookup m1 ?i \\<noteq> 0 \\<or> lookup m2 ?i \\<noteq> 0 \\<Longrightarrow>\n  ?i \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "have **: \"(\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly) =\n              (\\<Prod>i=1..n. sym_mpoly A i ^ lookup m i :: 'a mpoly)\" if \"m \\<in> {m1, m2}\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n    (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i)", "using that *"], ["proof (prove)\nusing this:\n  m \\<in> {m1, m2}\n  lookup m1 ?i \\<noteq> 0 \\<or> lookup m2 ?i \\<noteq> 0 \\<Longrightarrow>\n  ?i \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n    (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i)", "by (intro Prod_any.expand_superset subsetI * ) (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  ?m \\<in> {m1, m2} \\<Longrightarrow>\n  (\\<Prod>i. sym_mpoly A i ^ lookup ?m i) =\n  (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup ?m i)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "have ***: \"lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ lookup m1 i :: 'a mpoly) =\n               lead_monom (\\<Prod>i=1..n. sym_mpoly A i ^ lookup m2 i :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m1 i) =\n    lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m2 i)", "using assms"], ["proof (prove)\nusing this:\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)\n  finite A\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m1 i) =\n    lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m2 i)", "by (simp add: ** )"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m2 i)\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "have sum_eq: \"sum (lookup m1) {Suc k..n} = sum (lookup m2) {Suc k..n}\" if \"k < n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m1) {Suc k..n} = sum (lookup m2) {Suc k..n}", "using arg_cong[OF ***, of \"\\<lambda>m. lookup m (xs ! k)\"] \\<open>finite A\\<close> that"], ["proof (prove)\nusing this:\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m1 i))\n   (xs ! k) =\n  lookup (lead_monom (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m2 i))\n   (xs ! k)\n  finite A\n  k < n\n\ngoal (1 subgoal):\n 1. sum (lookup m1) {Suc k..n} = sum (lookup m2) {Suc k..n}", "by (subst (asm) (1 2) lead_monom_sym_mpoly_prod_in) auto"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow>\n  sum (lookup m1) {Suc ?k..n} = sum (lookup m2) {Suc ?k..n}\n\ngoal (1 subgoal):\n 1. \\<And>k. lookup m1 k = lookup m2 k", "show \"lookup m1 k = lookup m2 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m1 k = lookup m2 k", "proof (cases \"k \\<in> {1..n}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k\n 2. k \\<notin> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "case False"], ["proof (state)\nthis:\n  k \\<notin> {1..n}\n\ngoal (2 subgoals):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k\n 2. k \\<notin> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "hence \"lookup m1 k = 0\" \"lookup m2 k = 0\""], ["proof (prove)\nusing this:\n  k \\<notin> {1..n}\n\ngoal (1 subgoal):\n 1. lookup m1 k = 0 &&& lookup m2 k = 0", "using assms"], ["proof (prove)\nusing this:\n  k \\<notin> {1..n}\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)\n  finite A\n  keys m1 \\<subseteq> {1..n}\n  keys m2 \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. lookup m1 k = 0 &&& lookup m2 k = 0", "by (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  lookup m1 k = 0\n  lookup m2 k = 0\n\ngoal (2 subgoals):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k\n 2. k \\<notin> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "thus ?thesis"], ["proof (prove)\nusing this:\n  lookup m1 k = 0\n  lookup m2 k = 0\n\ngoal (1 subgoal):\n 1. lookup m1 k = lookup m2 k", "by simp"], ["proof (state)\nthis:\n  lookup m1 k = lookup m2 k\n\ngoal (1 subgoal):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "case True"], ["proof (state)\nthis:\n  k \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. k \\<in> {1..n} \\<Longrightarrow> lookup m1 k = lookup m2 k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. lookup m1 k = lookup m2 k", "proof (induction \"n - k\" arbitrary: k rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "case (less l)"], ["proof (state)\nthis:\n  \\<lbrakk>n - ?k < n - l; ?k \\<in> {1..n}\\<rbrakk>\n  \\<Longrightarrow> lookup m1 ?k = lookup m2 ?k\n  l \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "have \"sum (lookup m1) {Suc (l - 1)..n} = sum (lookup m2) {Suc (l - 1)..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m1) {Suc (l - 1)..n} = sum (lookup m2) {Suc (l - 1)..n}", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>n - ?k < n - l; ?k \\<in> {1..n}\\<rbrakk>\n  \\<Longrightarrow> lookup m1 ?k = lookup m2 ?k\n  l \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. sum (lookup m1) {Suc (l - 1)..n} = sum (lookup m2) {Suc (l - 1)..n}", "by (intro sum_eq) auto"], ["proof (state)\nthis:\n  sum (lookup m1) {Suc (l - 1)..n} = sum (lookup m2) {Suc (l - 1)..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "also"], ["proof (state)\nthis:\n  sum (lookup m1) {Suc (l - 1)..n} = sum (lookup m2) {Suc (l - 1)..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "have \"{Suc (l - 1)..n} = insert l {Suc l..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Suc (l - 1)..n} = insert l {Suc l..n}", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>n - ?k < n - l; ?k \\<in> {1..n}\\<rbrakk>\n  \\<Longrightarrow> lookup m1 ?k = lookup m2 ?k\n  l \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. {Suc (l - 1)..n} = insert l {Suc l..n}", "by auto"], ["proof (state)\nthis:\n  {Suc (l - 1)..n} = insert l {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "also"], ["proof (state)\nthis:\n  {Suc (l - 1)..n} = insert l {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "have \"sum (lookup m1) \\<dots> = lookup m1 l + (\\<Sum>i=Suc l..n. lookup m1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m1) (insert l {Suc l..n}) =\n    lookup m1 l + sum (lookup m1) {Suc l..n}", "by (subst sum.insert) auto"], ["proof (state)\nthis:\n  sum (lookup m1) (insert l {Suc l..n}) =\n  lookup m1 l + sum (lookup m1) {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "also"], ["proof (state)\nthis:\n  sum (lookup m1) (insert l {Suc l..n}) =\n  lookup m1 l + sum (lookup m1) {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "have \"(\\<Sum>i=Suc l..n. lookup m1 i) = (\\<Sum>i=Suc l..n. lookup m2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m1) {Suc l..n} = sum (lookup m2) {Suc l..n}", "by (intro sum.cong less) auto"], ["proof (state)\nthis:\n  sum (lookup m1) {Suc l..n} = sum (lookup m2) {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "also"], ["proof (state)\nthis:\n  sum (lookup m1) {Suc l..n} = sum (lookup m2) {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "have \"sum (lookup m2) (insert l {Suc l..n}) = lookup m2 l + (\\<Sum>i=Suc l..n. lookup m2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m2) (insert l {Suc l..n}) =\n    lookup m2 l + sum (lookup m2) {Suc l..n}", "by (subst sum.insert) auto"], ["proof (state)\nthis:\n  sum (lookup m2) (insert l {Suc l..n}) =\n  lookup m2 l + sum (lookup m2) {Suc l..n}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>ka.\n                   \\<lbrakk>n - ka < n - k; ka \\<in> {1..n}\\<rbrakk>\n                   \\<Longrightarrow> lookup m1 ka = lookup m2 ka;\n        k \\<in> {1..n}\\<rbrakk>\n       \\<Longrightarrow> lookup m1 k = lookup m2 k", "finally"], ["proof (chain)\npicking this:\n  lookup m1 l + sum (lookup m2) {Suc l..n} =\n  lookup m2 l + sum (lookup m2) {Suc l..n}", "show \"lookup m1 l = lookup m2 l\""], ["proof (prove)\nusing this:\n  lookup m1 l + sum (lookup m2) {Suc l..n} =\n  lookup m2 l + sum (lookup m2) {Suc l..n}\n\ngoal (1 subgoal):\n 1. lookup m1 l = lookup m2 l", "by simp"], ["proof (state)\nthis:\n  lookup m1 l = lookup m2 l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup m1 k = lookup m2 k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup m1 k = lookup m2 k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now show uniqueness by first showing that the zero polynomial has a unique representation.\n  We fix some polynomial $p$ with $p(e_1,\\ldots, e_n) = 0$ and then show, by contradiction,\n  that $p = 0$.\n\n  We have\n  \\[p(e_1,\\ldots,e_n) = \\sum c_{a_1,\\ldots,a_n} e_1^{a_1}\\ldots e_n^{a_n}\\]\n  and due to the injectivity of products of powers of elementary symmetric polynomials,\n  the leading term of that sum is precisely the leading term of the summand with the biggest\n  leading monomial, since summands cannot cancel each other.\n\n  However, we also know that $p(e_1,\\ldots,e_n) = 0$, so it follows that all summands\n  must have leading term 0, and it is then easy to see that they must all be identically 0.\n\\<close>"], ["", "lemma sym_mpoly_representation_unique_aux:\n  fixes p :: \"'a mpoly mpoly\"\n  assumes \"finite A\" \"insertion (sym_mpoly A) p = 0\"\n          \"\\<And>m. vars (coeff p m) \\<inter> A = {}\" \"vars p \\<subseteq> {1..n}\"\n  shows   \"p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "assume p: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have xs: \"set xs = A\" \"distinct xs\" \"sorted xs\" and [simp]: \"length xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  insertion (sym_mpoly A) p = 0\n  vars (MPoly_Type.coeff p ?m) \\<inter> A = {}\n  vars p \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. (set xs = A &&& distinct xs &&& sorted xs) &&& length xs = n", "by (auto simp: xs_def n_def)"], ["proof (state)\nthis:\n  set xs = A\n  distinct xs\n  sorted xs\n  length xs = n\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "define h where \"h = (\\<lambda>m. coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>m.\n      MPoly_Type.coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "define M where \"M = {m. coeff p m \\<noteq> 0}\""], ["proof (state)\nthis:\n  M = {m. MPoly_Type.coeff p m \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "define maxm where \"maxm = Max ((lead_monom \\<circ> h) ` M)\""], ["proof (state)\nthis:\n  maxm = Max ((lead_monom \\<circ> h) ` M)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"finite M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite M", "by (auto intro!: finite_subset[OF _ finite_coeff_support[of p]] simp: h_def M_def)"], ["proof (state)\nthis:\n  finite M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have keys_subset: \"keys m \\<subseteq> {1..n}\" if \"coeff p m \\<noteq> 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {1..n}", "using that assms coeff_notin_vars[of m p]"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> 0\n  finite A\n  insertion (sym_mpoly A) p = 0\n  vars (MPoly_Type.coeff p ?m) \\<inter> A = {}\n  vars p \\<subseteq> {1..n}\n  \\<not> keys m \\<subseteq> vars p \\<Longrightarrow>\n  MPoly_Type.coeff p m = 0\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> {1..n}", "by blast"], ["proof (state)\nthis:\n  MPoly_Type.coeff p ?m \\<noteq> 0 \\<Longrightarrow>\n  keys ?m \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have lead_coeff: \"lead_coeff (h m) = lead_coeff (coeff p m)\" (is ?th1)\n   and lead_monom: \"lead_monom (h m) = lead_monom (coeff p m) +\n                      lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly)\" (is ?th2)\n   if [simp]: \"coeff p m \\<noteq> 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m) &&&\n    lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n 2. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "have \"(\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly) =\n            (\\<Prod>i | lookup m i \\<noteq> 0. sym_mpoly A i ^ lookup m i :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n    (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i)", "by (intro Prod_any.expand_superset) (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i)\n\ngoal (2 subgoals):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n 2. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i)\n\ngoal (2 subgoals):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n 2. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "have \"lead_coeff \\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i) =\n    (1::'a)", "using assms keys_subset[of m]"], ["proof (prove)\nusing this:\n  finite A\n  insertion (sym_mpoly A) p = 0\n  vars (MPoly_Type.coeff p ?m) \\<inter> A = {}\n  vars p \\<subseteq> {1..n}\n  MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n  keys m \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i) =\n    (1::'a)", "by (intro lead_coeff_sym_mpoly_powerprod) (auto simp: in_keys_iff subset_iff n_def)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff\n   (\\<Prod>i\\<in>{i. lookup m i \\<noteq> 0}. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n 2. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "finally"], ["proof (chain)\npicking this:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)", "have eq: \"lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly) = 1\""], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n    (1::'a)", "."], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n\ngoal (2 subgoals):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n 2. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "thus ?th1"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "unfolding h_def"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (MPoly_Type.coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "using \\<open>coeff p m \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Symmetric_Polynomials.lead_coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (1::'a)\n  MPoly_Type.coeff p m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff\n     (MPoly_Type.coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "by (subst lead_coeff_mult) auto"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (h m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (1 subgoal):\n 1. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "show ?th2"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (h m) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom\n     (MPoly_Type.coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n    lead_monom (MPoly_Type.coeff p m) +\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "by (subst lead_monom_mult) (auto simp: eq)"], ["proof (state)\nthis:\n  lead_monom (h m) =\n  lead_monom (MPoly_Type.coeff p m) +\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff p ?m \\<noteq> 0 \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (h ?m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p ?m)\n  MPoly_Type.coeff p ?m \\<noteq> 0 \\<Longrightarrow>\n  lead_monom (h ?m) =\n  lead_monom (MPoly_Type.coeff p ?m) +\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup ?m i)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"insertion (sym_mpoly A) p = (\\<Sum>m\\<in>M. h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) p = sum h M", "unfolding insertion_altdef h_def M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p m *\n              (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n    (\\<Sum>m | MPoly_Type.coeff p m \\<noteq> 0.\n       MPoly_Type.coeff p m * (\\<Prod>i. sym_mpoly A i ^ lookup m i))", "by (intro Sum_any.expand_superset) auto"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) p = sum h M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) p = sum h M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"lead_monom \\<dots> = maxm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sum h M) = maxm", "unfolding maxm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (sum h M) = Max ((lead_monom \\<circ> h) ` M)", "proof (rule lead_monom_sum)"], ["proof (state)\ngoal (4 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. M \\<noteq> {}\n 4. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "obtain m where \"coeff p m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mpoly_eqI[of p 0]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (\\<And>mon.\n      MPoly_Type.coeff p mon = MPoly_Type.coeff 0 mon) \\<Longrightarrow>\n  p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  MPoly_Type.coeff p m \\<noteq> 0\n\ngoal (4 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. M \\<noteq> {}\n 4. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "hence \"m \\<in> M\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m \\<in> M", "using \\<open>coeff p m \\<noteq> 0\\<close> lead_coeff[of m]"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> 0\n  MPoly_Type.coeff p m \\<noteq> 0\n  MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n  Symmetric_Polynomials.lead_coeff (h m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (1 subgoal):\n 1. m \\<in> M", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  m \\<in> M\n\ngoal (4 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. M \\<noteq> {}\n 4. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "thus \"M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  m \\<in> M\n\ngoal (1 subgoal):\n 1. M \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  M \\<noteq> {}\n\ngoal (3 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "have restrict_lead_monom:\n           \"restrictpm A (lead_monom (h m)) =\n             lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly)\"\n      if [simp]: \"coeff p m \\<noteq> 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "have \"restrictpm A (lead_monom (h m)) =\n              restrictpm A (lead_monom (coeff p m)) +\n              restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    restrictpm A (lead_monom (MPoly_Type.coeff p m)) +\n    restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i))", "by (auto simp: lead_monom restrictpm_add)"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (h m)) =\n  restrictpm A (lead_monom (MPoly_Type.coeff p m)) +\n  restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "also"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (h m)) =\n  restrictpm A (lead_monom (MPoly_Type.coeff p m)) +\n  restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i))\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "have \"restrictpm A (lead_monom (coeff p m)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (MPoly_Type.coeff p m)) = 0", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  insertion (sym_mpoly A) p = 0\n  vars (MPoly_Type.coeff p ?m) \\<inter> A = {}\n  vars p \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (MPoly_Type.coeff p m)) = 0", "by (intro restrictpm_orthogonal order.trans[OF keys_lead_monom_subset]) auto"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (MPoly_Type.coeff p m)) = 0\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "also"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (MPoly_Type.coeff p m)) = 0\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "have \"restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly)) =\n                   lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i :: 'a mpoly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "by (intro restrictpm_id order.trans[OF keys_lead_monom_subset]\n                  order.trans[OF vars_Prod_any] UN_least order.trans[OF vars_power]\n                  vars_sym_mpoly_subset)"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "finally"], ["proof (chain)\npicking this:\n  restrictpm A (lead_monom (h m)) =\n  0 + lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "show ?thesis"], ["proof (prove)\nusing this:\n  restrictpm A (lead_monom (h m)) =\n  0 + lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m)) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "by simp"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (h m)) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff p ?m \\<noteq> 0 \\<Longrightarrow>\n  restrictpm A (lead_monom (h ?m)) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup ?m i)\n\ngoal (3 subgoals):\n 1. inj_on (lead_monom \\<circ> h) M\n 2. finite M\n 3. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "show \"inj_on (lead_monom \\<circ> h) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (lead_monom \\<circ> h) M", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix m1 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume m12: \"m1 \\<in> M\" \"m2 \\<in> M\" \"(lead_monom \\<circ> h) m1 = (lead_monom \\<circ> h) m2\""], ["proof (state)\nthis:\n  m1 \\<in> M\n  m2 \\<in> M\n  (lead_monom \\<circ> h) m1 = (lead_monom \\<circ> h) m2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence [simp]: \"coeff p m1 \\<noteq> 0\" \"coeff p m2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m1 \\<in> M\n  m2 \\<in> M\n  (lead_monom \\<circ> h) m1 = (lead_monom \\<circ> h) m2\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m1 \\<noteq> 0 &&& MPoly_Type.coeff p m2 \\<noteq> 0", "by (auto simp: M_def h_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff p m1 \\<noteq> 0\n  MPoly_Type.coeff p m2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"restrictpm A (lead_monom (h m1)) = restrictpm A (lead_monom (h m2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m1)) = restrictpm A (lead_monom (h m2))", "using m12"], ["proof (prove)\nusing this:\n  m1 \\<in> M\n  m2 \\<in> M\n  (lead_monom \\<circ> h) m1 = (lead_monom \\<circ> h) m2\n\ngoal (1 subgoal):\n 1. restrictpm A (lead_monom (h m1)) = restrictpm A (lead_monom (h m2))", "by simp"], ["proof (state)\nthis:\n  restrictpm A (lead_monom (h m1)) = restrictpm A (lead_monom (h m2))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i :: 'a mpoly) =\n               lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i :: 'a mpoly)\""], ["proof (prove)\nusing this:\n  restrictpm A (lead_monom (h m1)) = restrictpm A (lead_monom (h m2))\n\ngoal (1 subgoal):\n 1. lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n    lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)", "by (simp add: restrict_lead_monom)"], ["proof (state)\nthis:\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> M; y \\<in> M;\n        (lead_monom \\<circ> h) x = (lead_monom \\<circ> h) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"m1 = m2\""], ["proof (prove)\nusing this:\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m1 i) =\n  lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m2 i)\n\ngoal (1 subgoal):\n 1. m1 = m2", "by (rule lead_monom_sym_poly_powerprod_inj)\n           (use \\<open>finite A\\<close> keys_subset[of m1] keys_subset[of m2] in auto)"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (lead_monom \\<circ> h) M\n\ngoal (2 subgoals):\n 1. finite M\n 2. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite M\n 2. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. finite M\n 2. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "assume \"m \\<in> M\""], ["proof (state)\nthis:\n  m \\<in> M\n\ngoal (2 subgoals):\n 1. finite M\n 2. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "hence \"lead_coeff (h m) = lead_coeff (coeff p m)\""], ["proof (prove)\nusing this:\n  m \\<in> M\n\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h m) =\n    Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "by (simp add: lead_coeff M_def)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (h m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (2 subgoals):\n 1. finite M\n 2. \\<And>m. m \\<in> M \\<Longrightarrow> h m \\<noteq> 0", "with \\<open>m \\<in> M\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> M\n  Symmetric_Polynomials.lead_coeff (h m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "show \"h m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<in> M\n  Symmetric_Polynomials.lead_coeff (h m) =\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (1 subgoal):\n 1. h m \\<noteq> 0", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  h m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite M", "qed fact+"], ["proof (state)\nthis:\n  lead_monom (sum h M) = maxm\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lead_monom (insertion (sym_mpoly A) p) = maxm", "have \"maxm = 0\""], ["proof (prove)\nusing this:\n  lead_monom (insertion (sym_mpoly A) p) = maxm\n\ngoal (1 subgoal):\n 1. maxm = 0", "by (simp add: assms)"], ["proof (state)\nthis:\n  maxm = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have only_zero: \"m = 0\" if \"m \\<in> M\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m = 0", "from that"], ["proof (chain)\npicking this:\n  m \\<in> M", "have nz [simp]: \"coeff p m \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<in> M\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m \\<noteq> 0", "by (auto simp: M_def h_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff p m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. m = 0", "from that"], ["proof (chain)\npicking this:\n  m \\<in> M", "have \"(lead_monom \\<circ> h) m \\<le> maxm\""], ["proof (prove)\nusing this:\n  m \\<in> M\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) m \\<le> maxm", "using \\<open>finite M\\<close>"], ["proof (prove)\nusing this:\n  m \\<in> M\n  finite M\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) m \\<le> maxm", "unfolding maxm_def"], ["proof (prove)\nusing this:\n  m \\<in> M\n  finite M\n\ngoal (1 subgoal):\n 1. (lead_monom \\<circ> h) m \\<le> Max ((lead_monom \\<circ> h) ` M)", "by (intro Max_ge imageI finite_imageI)"], ["proof (state)\nthis:\n  (lead_monom \\<circ> h) m \\<le> maxm\n\ngoal (1 subgoal):\n 1. m = 0", "with \\<open>maxm = 0\\<close>"], ["proof (chain)\npicking this:\n  maxm = 0\n  (lead_monom \\<circ> h) m \\<le> maxm", "have [simp]: \"lead_monom (h m) = 0\""], ["proof (prove)\nusing this:\n  maxm = 0\n  (lead_monom \\<circ> h) m \\<le> maxm\n\ngoal (1 subgoal):\n 1. lead_monom (h m) = 0", "by simp"], ["proof (state)\nthis:\n  lead_monom (h m) = 0\n\ngoal (1 subgoal):\n 1. m = 0", "have lookup_nzD: \"k \\<in> {1..n}\" if \"lookup m k \\<noteq> 0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> {1..n}", "using keys_subset[of m] that"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n  keys m \\<subseteq> {1..n}\n  lookup m k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<in> {1..n}", "by (auto simp: in_keys_iff subset_iff)"], ["proof (state)\nthis:\n  lookup m ?k \\<noteq> 0 \\<Longrightarrow> ?k \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. m = 0", "have \"lead_monom (coeff p m) + 0 \\<le> lead_monom (h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.coeff p m) + 0 \\<le> lead_monom (h m)", "unfolding lead_monom[OF nz]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.coeff p m) + 0\n    \\<le> lead_monom (MPoly_Type.coeff p m) +\n          lead_monom (\\<Prod>i. sym_mpoly A i ^ lookup m i)", "by (intro add_left_mono) auto"], ["proof (state)\nthis:\n  lead_monom (MPoly_Type.coeff p m) + 0 \\<le> lead_monom (h m)\n\ngoal (1 subgoal):\n 1. m = 0", "also"], ["proof (state)\nthis:\n  lead_monom (MPoly_Type.coeff p m) + 0 \\<le> lead_monom (h m)\n\ngoal (1 subgoal):\n 1. m = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_monom (h m) = 0", "by simp"], ["proof (state)\nthis:\n  lead_monom (h m) = 0\n\ngoal (1 subgoal):\n 1. m = 0", "finally"], ["proof (chain)\npicking this:\n  lead_monom (MPoly_Type.coeff p m) + 0 \\<le> 0", "have lead_monom_0: \"lead_monom (coeff p m) = 0\""], ["proof (prove)\nusing this:\n  lead_monom (MPoly_Type.coeff p m) + 0 \\<le> 0\n\ngoal (1 subgoal):\n 1. lead_monom (MPoly_Type.coeff p m) = 0", "by simp"], ["proof (state)\nthis:\n  lead_monom (MPoly_Type.coeff p m) = 0\n\ngoal (1 subgoal):\n 1. m = 0", "have \"sum (lookup m) {1..n} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "assume \"sum (lookup m) {1..n} \\<noteq> 0\""], ["proof (state)\nthis:\n  sum (lookup m) {1..n} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "hence \"sum (lookup m) {1..n} > 0\""], ["proof (prove)\nusing this:\n  sum (lookup m) {1..n} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < sum (lookup m) {1..n}", "by presburger"], ["proof (state)\nthis:\n  0 < sum (lookup m) {1..n}\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"0 \\<noteq> lead_coeff (MPoly_Type.coeff p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"lead_coeff (MPoly_Type.coeff p m) = lead_coeff (h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m) =\n    Symmetric_Polynomials.lead_coeff (h m)", "by (simp add: lead_coeff)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m) =\n  Symmetric_Polynomials.lead_coeff (h m)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (MPoly_Type.coeff p m) =\n  Symmetric_Polynomials.lead_coeff (h m)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"lead_coeff (h m) = coeff (h m) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Symmetric_Polynomials.lead_coeff (h m) = MPoly_Type.coeff (h m) 0", "by (simp add: lead_coeff_def)"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (h m) = MPoly_Type.coeff (h m) 0\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Symmetric_Polynomials.lead_coeff (h m) = MPoly_Type.coeff (h m) 0\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> = coeff (coeff p m) 0 * coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (h m) 0 =\n    MPoly_Type.coeff (MPoly_Type.coeff p m) 0 *\n    MPoly_Type.coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) 0", "by (simp add: h_def mpoly_coeff_times_0)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (h m) 0 =\n  MPoly_Type.coeff (MPoly_Type.coeff p m) 0 *\n  MPoly_Type.coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) 0\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (h m) 0 =\n  MPoly_Type.coeff (MPoly_Type.coeff p m) 0 *\n  MPoly_Type.coeff (\\<Prod>i. sym_mpoly A i ^ lookup m i) 0\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"(\\<Prod>i. sym_mpoly A i ^ lookup m i) = (\\<Prod>i=1..n. sym_mpoly A i ^ lookup m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n    (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i)", "by (intro Prod_any.expand_superset subsetI lookup_nzD) (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>i. sym_mpoly A i ^ lookup m i) =\n  (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"coeff \\<dots> 0 = (\\<Prod>i=1..n. 0 ^ lookup m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i) 0 =\n    (\\<Prod>i = 1..n. (0::'b) ^ lookup m i)", "unfolding mpoly_coeff_prod_0 mpoly_coeff_power_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x = 1..n. MPoly_Type.coeff (sym_mpoly A x) 0 ^ lookup m x) =\n    (\\<Prod>i = 1..n. (0::'b) ^ lookup m i)", "by (intro prod.cong) (auto simp: coeff_sym_mpoly_0)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i) 0 =\n  (\\<Prod>i = 1..n. (0::?'b2) ^ lookup m i)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (\\<Prod>i = 1..n. sym_mpoly A i ^ lookup m i) 0 =\n  (\\<Prod>i = 1..n. (0::?'b2) ^ lookup m i)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> = 0 ^ (\\<Sum>i=1..n. lookup m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 1..n. (0::'b) ^ lookup m i) =\n    (0::'b) ^ sum (lookup m) {1..n}", "by (simp add: power_sum)"], ["proof (state)\nthis:\n  (\\<Prod>i = 1..n. (0::?'b3) ^ lookup m i) =\n  (0::?'b3) ^ sum (lookup m) {1..n}\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 1..n. (0::?'b3) ^ lookup m i) =\n  (0::?'b3) ^ sum (lookup m) {1..n}\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) ^ sum (lookup m) {1..n} = (0::'b)", "using zero_power[OF \\<open>sum (lookup m) {1..n} > 0\\<close>]"], ["proof (prove)\nusing this:\n  (0::?'a) ^ sum (lookup m) {1..n} = (0::?'a)\n\ngoal (1 subgoal):\n 1. (0::'b) ^ sum (lookup m) {1..n} = (0::'b)", "by simp"], ["proof (state)\nthis:\n  (0::?'b4) ^ sum (lookup m) {1..n} = (0::?'b4)\n\ngoal (1 subgoal):\n 1. sum (lookup m) {1..n} \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (0::'a) \\<noteq> MPoly_Type.coeff (MPoly_Type.coeff p m) 0 * (0::'a)", "show False"], ["proof (prove)\nusing this:\n  (0::'a) \\<noteq> MPoly_Type.coeff (MPoly_Type.coeff p m) 0 * (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (lookup m) {1..n} = 0\n\ngoal (1 subgoal):\n 1. m = 0", "hence \"lookup m k = 0\" for k"], ["proof (prove)\nusing this:\n  sum (lookup m) {1..n} = 0\n\ngoal (1 subgoal):\n 1. lookup m k = 0", "using keys_subset[of m]"], ["proof (prove)\nusing this:\n  sum (lookup m) {1..n} = 0\n  MPoly_Type.coeff p m \\<noteq> 0 \\<Longrightarrow>\n  keys m \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. lookup m k = 0", "by (cases \"k \\<in> {1..n}\") (auto simp: in_keys_iff)"], ["proof (state)\nthis:\n  lookup m ?k = 0\n\ngoal (1 subgoal):\n 1. m = 0", "thus \"m = 0\""], ["proof (prove)\nusing this:\n  lookup m ?k = 0\n\ngoal (1 subgoal):\n 1. m = 0", "by (intro poly_mapping_eqI) auto"], ["proof (state)\nthis:\n  m = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m \\<in> M \\<Longrightarrow> ?m = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"0 = insertion (sym_mpoly A) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = insertion (sym_mpoly A) p", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  insertion (sym_mpoly A) p = 0\n  vars (MPoly_Type.coeff p ?m) \\<inter> A = {}\n  vars p \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. 0 = insertion (sym_mpoly A) p", "by simp"], ["proof (state)\nthis:\n  0 = insertion (sym_mpoly A) p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = insertion (sym_mpoly A) p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"insertion (sym_mpoly A) p = (\\<Sum>m\\<in>M. h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) p = sum h M", "by fact"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) p = sum h M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) p = sum h M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>m\\<in>{0}. h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h M = sum h {0}", "using only_zero"], ["proof (prove)\nusing this:\n  ?m \\<in> M \\<Longrightarrow> ?m = 0\n\ngoal (1 subgoal):\n 1. sum h M = sum h {0}", "by (intro sum.mono_neutral_left) (auto simp: h_def M_def)"], ["proof (state)\nthis:\n  sum h M = sum h {0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sum h M = sum h {0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> = coeff p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum h {0} = MPoly_Type.coeff p 0", "by (simp add: h_def)"], ["proof (state)\nthis:\n  sum h {0} = MPoly_Type.coeff p 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 = MPoly_Type.coeff p 0", "have \"0 \\<notin> M\""], ["proof (prove)\nusing this:\n  0 = MPoly_Type.coeff p 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> M", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  0 \\<notin> M\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "with only_zero"], ["proof (chain)\npicking this:\n  ?m \\<in> M \\<Longrightarrow> ?m = 0\n  0 \\<notin> M", "have \"M = {}\""], ["proof (prove)\nusing this:\n  ?m \\<in> M \\<Longrightarrow> ?m = 0\n  0 \\<notin> M\n\ngoal (1 subgoal):\n 1. M = {}", "by auto"], ["proof (state)\nthis:\n  M = {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "hence \"p = 0\""], ["proof (prove)\nusing this:\n  M = {}\n\ngoal (1 subgoal):\n 1. p = 0", "by (intro mpoly_eqI) (auto simp: M_def)"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The general uniqueness theorem now follows easily. This essentially shows that\n  the substitution $Y_i \\mapsto e_i(X_1,\\ldots,X_n)$ is an isomorphism between the\n  ring $R[Y_1,\\ldots, Y_n]$ and the ring $R[X_1,\\ldots,X_n]^{S_n}$ of symmetric polynomials.\n\\<close>"], ["", "theorem sym_mpoly_representation_unique:\n  fixes p :: \"'a mpoly mpoly\"\n  assumes \"finite A\"\n          \"insertion (sym_mpoly A) p = insertion (sym_mpoly A) q\"\n          \"\\<And>m. vars (coeff p m) \\<inter> A = {}\" \"\\<And>m. vars (coeff q m) \\<inter> A = {}\"\n          \"vars p \\<subseteq> {1..n}\" \"vars q \\<subseteq> {1..n}\"\n  shows   \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q", "have \"p - q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - q = 0", "proof (rule sym_mpoly_representation_unique_aux)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite A\n 2. insertion (sym_mpoly A) (p - q) = 0\n 3. \\<And>m. vars (MPoly_Type.coeff (p - q) m) \\<inter> A = {}\n 4. vars (p - q) \\<subseteq> {1..n}", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. finite A\n 2. insertion (sym_mpoly A) (p - q) = 0\n 3. \\<And>m. vars (MPoly_Type.coeff (p - q) m) \\<inter> A = {}\n 4. vars (p - q) \\<subseteq> {1..n}", "show \"vars (coeff (p - q) m) \\<inter> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (p - q) m) \\<inter> A = {}", "using vars_diff[of \"coeff p m\" \"coeff q m\"] assms(3,4)[of m]"], ["proof (prove)\nusing this:\n  vars (MPoly_Type.coeff p m - MPoly_Type.coeff q m)\n  \\<subseteq> vars (MPoly_Type.coeff p m) \\<union>\n              vars (MPoly_Type.coeff q m)\n  vars (MPoly_Type.coeff p m) \\<inter> A = {}\n  vars (MPoly_Type.coeff q m) \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. vars (MPoly_Type.coeff (p - q) m) \\<inter> A = {}", "by auto"], ["proof (state)\nthis:\n  vars (MPoly_Type.coeff (p - q) m) \\<inter> A = {}\n\ngoal (3 subgoals):\n 1. finite A\n 2. insertion (sym_mpoly A) (p - q) = 0\n 3. vars (p - q) \\<subseteq> {1..n}", "qed (insert assms vars_diff[of p q], auto simp: insertion_diff)"], ["proof (state)\nthis:\n  p - q = 0\n\ngoal (1 subgoal):\n 1. p = q", "thus ?thesis"], ["proof (prove)\nusing this:\n  p - q = 0\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem eq_fund_sym_poly_witI:\n  fixes p :: \"'a mpoly\" and q :: \"'a mpoly mpoly\"\n  assumes \"finite A\" \"symmetric_mpoly A p\"\n          \"insertion (sym_mpoly A) q = p\"\n          \"\\<And>m. vars (coeff q m) \\<inter> A = {}\"\n          \"vars q \\<subseteq> {1..n}\"\n  shows   \"q = fund_sym_poly_wit p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = local.fund_sym_poly_wit p", "using fund_sym_poly_wit_insertion[of p] fund_sym_poly_wit_vars[of p]\n        fund_sym_poly_wit_coeffs[of p]"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p \\<Longrightarrow>\n  insertion (sym_mpoly A) (local.fund_sym_poly_wit p) = p\n  vars (local.fund_sym_poly_wit p) \\<subseteq> {1..n}\n  symmetric_mpoly A p \\<Longrightarrow>\n  vars (MPoly_Type.coeff (local.fund_sym_poly_wit p) ?m)\n  \\<subseteq> vars p - A\n\ngoal (1 subgoal):\n 1. q = local.fund_sym_poly_wit p", "by (intro sym_mpoly_representation_unique)\n     (insert assms, auto simp: fund_sym_poly_wit_insertion)"], ["", "subsection \\<open>A recursive characterisation of symmetry\\<close>"], ["", "text \\<open>\n  In a similar spirit to the proof of the fundamental theorem, we obtain a nice\n  recursive and executable characterisation of symmetry.\n\\<close>"], ["", "(*<*)"], ["", "lemmas [fundef_cong] = disj_cong conj_cong"], ["", "(*>*)"], ["", "function (domintros) check_symmetric_mpoly where\n  \"check_symmetric_mpoly p \\<longleftrightarrow>\n     (vars p \\<inter> A = {} \\<or>\n      A \\<subseteq> vars p \\<and> decr p \\<and> check_symmetric_mpoly (p - fund_sym_step_poly p))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>p. x = p \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p pa.\n       p = pa \\<Longrightarrow>\n       (vars p \\<inter> A = {} \\<or>\n        A \\<subseteq> vars p \\<and>\n        decr p \\<and>\n        check_symmetric_mpoly_sumC (p - local.fund_sym_step_poly p)) =\n       (vars pa \\<inter> A = {} \\<or>\n        A \\<subseteq> vars pa \\<and>\n        decr pa \\<and>\n        check_symmetric_mpoly_sumC (pa - local.fund_sym_step_poly pa))", "by auto"], ["", "lemma check_symmetric_mpoly_dom_aux:\n  assumes \"finite B\" \"vars p \\<subseteq> B\" \"A \\<subseteq> B\"\n  shows   \"check_symmetric_mpoly_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "using assms(1-3)"], ["proof (prove)\nusing this:\n  finite B\n  vars p \\<subseteq> B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "proof (induction p rule: lead_monom_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.check_symmetric_mpoly_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.check_symmetric_mpoly_dom p", "case (less p)"], ["proof (state)\nthis:\n  vars p \\<subseteq> B\n  \\<lbrakk>vars ?p' \\<subseteq> B; lead_monom ?p' < lead_monom p;\n   A \\<subseteq> B\\<rbrakk>\n  \\<Longrightarrow> local.check_symmetric_mpoly_dom ?p'\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.check_symmetric_mpoly_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.check_symmetric_mpoly_dom p", "have [simp]: \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "by (rule finite_subset[of _ B]) fact+"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> B;\n        \\<And>p'.\n           \\<lbrakk>vars p' \\<subseteq> B; lead_monom p' < lead_monom p;\n            A \\<subseteq> B\\<rbrakk>\n           \\<Longrightarrow> local.check_symmetric_mpoly_dom p';\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> local.check_symmetric_mpoly_dom p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "proof (cases \"lead_monom p = 0 \\<or> \\<not>decr p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p\n 2. \\<not> (lead_monom p = 0 \\<or> \\<not> decr p) \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "case False"], ["proof (state)\nthis:\n  \\<not> (lead_monom p = 0 \\<or> \\<not> decr p)\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p\n 2. \\<not> (lead_monom p = 0 \\<or> \\<not> decr p) \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "hence [simp]: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (lead_monom p = 0 \\<or> \\<not> decr p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p\n 2. \\<not> (lead_monom p = 0 \\<or> \\<not> decr p) \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "have \"vars (p - fund_sym_step_poly p) \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "using fund_sym_step_poly[of p] False less.prems less.hyps \\<open>A \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> lead_monom (local.fund_sym_step_poly p) = lead_monom p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> Symmetric_Polynomials.lead_coeff\n                     (local.fund_sym_step_poly p) =\n                    Symmetric_Polynomials.lead_coeff p\n  \\<lbrakk>finite A; p \\<noteq> 0; decr p\\<rbrakk>\n  \\<Longrightarrow> local.fund_sym_step_poly p =\n                    local.fund_sym_step_coeff p *\n                    (\\<Prod>x. sym_mpoly A x ^\n                               lookup (local.fund_sym_step_monom p) x)\n  vars (local.fund_sym_step_poly p) \\<subseteq> vars p \\<union> A\n  symmetric_mpoly A (local.fund_sym_step_poly p)\n  \\<not> (lead_monom p = 0 \\<or> \\<not> decr p)\n  A \\<subseteq> B\n  vars p \\<subseteq> B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. vars (p - local.fund_sym_step_poly p) \\<subseteq> B", "by (intro order.trans[OF vars_diff]) auto"], ["proof (state)\nthis:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p\n 2. \\<not> (lead_monom p = 0 \\<or> \\<not> decr p) \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "hence \"check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)\""], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)", "using False less.prems less.hyps"], ["proof (prove)\nusing this:\n  vars (p - local.fund_sym_step_poly p) \\<subseteq> B\n  \\<not> (lead_monom p = 0 \\<or> \\<not> decr p)\n  A \\<subseteq> B\n  vars p \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)", "by (intro less.IH fund_sym_step_poly symmetric_mpoly_diff\n                lead_monom_fund_sym_step_poly_less) (auto simp: decr_def)"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)\n\ngoal (2 subgoals):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p\n 2. \\<not> (lead_monom p = 0 \\<or> \\<not> decr p) \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "using check_symmetric_mpoly.domintros"], ["proof (prove)\nusing this:\n  local.check_symmetric_mpoly_dom (p - local.fund_sym_step_poly p)\n  (\\<And>x.\n      \\<lbrakk>A \\<subseteq> vars ?p; decr ?p;\n       \\<not> local.check_symmetric_mpoly_dom\n               (?p - local.fund_sym_step_poly ?p);\n       x \\<in> vars ?p; x \\<in> A\\<rbrakk>\n      \\<Longrightarrow> False) \\<Longrightarrow>\n  local.check_symmetric_mpoly_dom ?p\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "by blast"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly_dom p\n\ngoal (1 subgoal):\n 1. lead_monom p = 0 \\<or> \\<not> decr p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "qed (auto intro: check_symmetric_mpoly.domintros simp: lead_monom_eq_0_iff)"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly_dom p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_symmetric_mpoly_dom [intro]: \"check_symmetric_mpoly_dom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "proof (cases \"A \\<subseteq> vars p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow> local.check_symmetric_mpoly_dom p\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "assume \"A \\<subseteq> vars p\""], ["proof (state)\nthis:\n  A \\<subseteq> vars p\n\ngoal (2 subgoals):\n 1. A \\<subseteq> vars p \\<Longrightarrow> local.check_symmetric_mpoly_dom p\n 2. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "thus ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "using check_symmetric_mpoly_dom_aux[of \"vars p\" p]"], ["proof (prove)\nusing this:\n  A \\<subseteq> vars p\n  \\<lbrakk>finite (vars p); vars p \\<subseteq> vars p;\n   A \\<subseteq> vars p\\<rbrakk>\n  \\<Longrightarrow> local.check_symmetric_mpoly_dom p\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly_dom p", "by (auto simp: vars_finite)"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly_dom p\n\ngoal (1 subgoal):\n 1. \\<not> A \\<subseteq> vars p \\<Longrightarrow>\n    local.check_symmetric_mpoly_dom p", "qed (auto intro: check_symmetric_mpoly.domintros)"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly_dom p\n\ngoal:\nNo subgoals!", "qed"], ["", "termination check_symmetric_mpoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.check_symmetric_mpoly_dom", "by (intro allI check_symmetric_mpoly_dom)"], ["", "lemmas [simp del] = check_symmetric_mpoly.simps"], ["", "lemma check_symmetric_mpoly_correct: \"check_symmetric_mpoly p \\<longleftrightarrow> symmetric_mpoly A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly p = symmetric_mpoly A p", "proof (induction p rule: check_symmetric_mpoly.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n         decr p\\<rbrakk>\n        \\<Longrightarrow> local.check_symmetric_mpoly\n                           (p - local.fund_sym_step_poly p) =\n                          symmetric_mpoly A\n                           (p -\n                            local.fund_sym_step_poly p)) \\<Longrightarrow>\n       local.check_symmetric_mpoly p = symmetric_mpoly A p", "case (1 p)"], ["proof (state)\nthis:\n  \\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n   decr p\\<rbrakk>\n  \\<Longrightarrow> local.check_symmetric_mpoly\n                     (p - local.fund_sym_step_poly p) =\n                    symmetric_mpoly A (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n         decr p\\<rbrakk>\n        \\<Longrightarrow> local.check_symmetric_mpoly\n                           (p - local.fund_sym_step_poly p) =\n                          symmetric_mpoly A\n                           (p -\n                            local.fund_sym_step_poly p)) \\<Longrightarrow>\n       local.check_symmetric_mpoly p = symmetric_mpoly A p", "have \"symmetric_mpoly A (p - fund_sym_step_poly p) \\<longleftrightarrow> symmetric_mpoly A p\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p\n 2. symmetric_mpoly A p \\<Longrightarrow>\n    symmetric_mpoly A (p - local.fund_sym_step_poly p)", "assume ?rhs"], ["proof (state)\nthis:\n  symmetric_mpoly A p\n\ngoal (2 subgoals):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p\n 2. symmetric_mpoly A p \\<Longrightarrow>\n    symmetric_mpoly A (p - local.fund_sym_step_poly p)", "thus ?lhs"], ["proof (prove)\nusing this:\n  symmetric_mpoly A p\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p)", "by (intro symmetric_mpoly_diff fund_sym_step_poly)"], ["proof (state)\nthis:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p", "assume ?lhs"], ["proof (state)\nthis:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p", "hence \"symmetric_mpoly A (p - fund_sym_step_poly p + fund_sym_step_poly p)\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A\n     (p - local.fund_sym_step_poly p + local.fund_sym_step_poly p)", "by (intro symmetric_mpoly_add fund_sym_step_poly)"], ["proof (state)\nthis:\n  symmetric_mpoly A\n   (p - local.fund_sym_step_poly p + local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A (p - local.fund_sym_step_poly p) \\<Longrightarrow>\n    symmetric_mpoly A p", "thus ?rhs"], ["proof (prove)\nusing this:\n  symmetric_mpoly A\n   (p - local.fund_sym_step_poly p + local.fund_sym_step_poly p)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly A p", "by simp"], ["proof (state)\nthis:\n  symmetric_mpoly A p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n         decr p\\<rbrakk>\n        \\<Longrightarrow> local.check_symmetric_mpoly\n                           (p - local.fund_sym_step_poly p) =\n                          symmetric_mpoly A\n                           (p -\n                            local.fund_sym_step_poly p)) \\<Longrightarrow>\n       local.check_symmetric_mpoly p = symmetric_mpoly A p", "moreover"], ["proof (state)\nthis:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n         decr p\\<rbrakk>\n        \\<Longrightarrow> local.check_symmetric_mpoly\n                           (p - local.fund_sym_step_poly p) =\n                          symmetric_mpoly A\n                           (p -\n                            local.fund_sym_step_poly p)) \\<Longrightarrow>\n       local.check_symmetric_mpoly p = symmetric_mpoly A p", "have \"decr p\" if \"symmetric_mpoly A p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decr p", "using lookup_lead_monom_decreasing[of A p] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>symmetric_mpoly A p; ?i \\<in> A; ?j \\<in> A; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> lookup (lead_monom p) ?j \\<le> lookup (lead_monom p) ?i\n  symmetric_mpoly A p\n\ngoal (1 subgoal):\n 1. decr p", "by (auto simp: decr_def)"], ["proof (state)\nthis:\n  symmetric_mpoly A p \\<Longrightarrow> decr p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n         decr p\\<rbrakk>\n        \\<Longrightarrow> local.check_symmetric_mpoly\n                           (p - local.fund_sym_step_poly p) =\n                          symmetric_mpoly A\n                           (p -\n                            local.fund_sym_step_poly p)) \\<Longrightarrow>\n       local.check_symmetric_mpoly p = symmetric_mpoly A p", "ultimately"], ["proof (chain)\npicking this:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p\n  symmetric_mpoly A p \\<Longrightarrow> decr p", "show \"check_symmetric_mpoly p \\<longleftrightarrow> symmetric_mpoly A p\""], ["proof (prove)\nusing this:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p\n  symmetric_mpoly A p \\<Longrightarrow> decr p\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly p = symmetric_mpoly A p", "using 1 symmetric_mpoly_imp_orthogonal_or_subset[of A p]"], ["proof (prove)\nusing this:\n  symmetric_mpoly A (p - local.fund_sym_step_poly p) = symmetric_mpoly A p\n  symmetric_mpoly A p \\<Longrightarrow> decr p\n  \\<lbrakk>vars p \\<inter> A \\<noteq> {}; A \\<subseteq> vars p;\n   decr p\\<rbrakk>\n  \\<Longrightarrow> local.check_symmetric_mpoly\n                     (p - local.fund_sym_step_poly p) =\n                    symmetric_mpoly A (p - local.fund_sym_step_poly p)\n  symmetric_mpoly A p \\<Longrightarrow>\n  vars p \\<inter> A = {} \\<or> A \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. local.check_symmetric_mpoly p = symmetric_mpoly A p", "by (auto simp: Let_def check_symmetric_mpoly.simps[of p] intro: symmetric_mpoly_orthogonal)"], ["proof (state)\nthis:\n  local.check_symmetric_mpoly p = symmetric_mpoly A p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Symmetric functions of roots of a univariate polynomial\\<close>"], ["", "text \\<open>\n  Consider a factored polynomial\n  \\[p(X) = c_n X^n + c_{n-1} X^{n-1} + \\ldots + c_1X + c_0 = (X - x_1)\\ldots(X - x_n)\\ .\\]\n  where $c_n$ is a unit.\n\n  Then any symmetric polynomial expression $q(x_1, \\ldots, x_n)$ in the roots $x_i$ can\n  be written as a polynomial expression $q'(c_0,\\ldots, c_{n-1})$ in the $c_i$.\n\n  Moreover, if the coefficients of $q$ and the inverse of $c_n$ all lie in some\n  subring, the coefficients of $q'$ do as well.\n\\<close>"], ["", "context\n  fixes C :: \"'b :: comm_ring_1 set\"\n    and A :: \"nat set\"\n    and root :: \"nat \\<Rightarrow> 'a :: comm_ring_1\"\n    and l :: \"'a \\<Rightarrow> 'b\"\n    and q :: \"'b mpoly\"\n    and n :: nat\n  defines \"n \\<equiv> card A\"\n  assumes C: \"ring_closed C\" \"\\<forall>m. coeff q m \\<in> C\"\n  assumes l: \"ring_homomorphism l\"\n  assumes finite: \"finite A\"\n  assumes sym: \"symmetric_mpoly A q\" and vars: \"vars q \\<subseteq> A\"\nbegin"], ["", "interpretation ring_closed C"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed C", "by fact"], ["", "interpretation ring_homomorphism l"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism l", "by fact"], ["", "theorem symmetric_poly_of_roots_conv_poly_of_coeffs:\n  assumes c: \"cinv * l c = 1\" \"cinv \\<in> C\"\n  assumes \"p = Polynomial.smult c (\\<Prod>i\\<in>A. [:-root i, 1:])\"\n  obtains q' where \"vars q' \\<subseteq> {0..<n}\"\n               and \"\\<And>m. coeff q' m \\<in> C\"\n               and \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q' where \"q' = fund_sym_poly_wit A q\""], ["proof (state)\nthis:\n  q' = fund_sym_poly_wit A q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q'' where \"q'' =\n     mapm_mpoly (\\<lambda>m x. (\\<Prod>i. (cinv * l (- 1) ^ i) ^ lookup m i) * insertion (\\<lambda>_. 0) x) q'\""], ["proof (state)\nthis:\n  q'' =\n  mapm_mpoly\n   (\\<lambda>m x.\n       (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n       insertion (\\<lambda>_. 0::'b) x)\n   q'\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define reindex where \"reindex = (\\<lambda>i. if i \\<le> n then n - i else i)\""], ["proof (state)\nthis:\n  reindex = (\\<lambda>i. if i \\<le> n then n - i else i)\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"bij reindex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij reindex", "by (intro bij_betwI[of reindex _ _ reindex]) (auto simp: reindex_def)"], ["proof (state)\nthis:\n  bij reindex\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"vars q' \\<subseteq> {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars q' \\<subseteq> {1..n}", "unfolding q'_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (fund_sym_poly_wit A q) \\<subseteq> {1..card A}", "by (intro fund_sym_poly_wit_vars)"], ["proof (state)\nthis:\n  vars q' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"vars q'' \\<subseteq> {1..n}\""], ["proof (prove)\nusing this:\n  vars q' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. vars q'' \\<subseteq> {1..n}", "unfolding q''_def"], ["proof (prove)\nusing this:\n  vars q' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. vars\n     (mapm_mpoly\n       (\\<lambda>m x.\n           (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n           insertion (\\<lambda>_. 0::'b) x)\n       q')\n    \\<subseteq> {1..n}", "using vars_mapm_mpoly_subset"], ["proof (prove)\nusing this:\n  vars q' \\<subseteq> {1..n}\n  vars (mapm_mpoly ?f ?p) \\<subseteq> vars ?p\n\ngoal (1 subgoal):\n 1. vars\n     (mapm_mpoly\n       (\\<lambda>m x.\n           (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n           insertion (\\<lambda>_. 0::'b) x)\n       q')\n    \\<subseteq> {1..n}", "by auto"], ["proof (state)\nthis:\n  vars q'' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (l \\<circ> root) (insertion (sym_mpoly A) q') =\n          insertion (\\<lambda>n. insertion (l \\<circ> root) (sym_mpoly A n))\n            (map_mpoly (insertion (l \\<circ> root)) q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (l \\<circ> root) (insertion (sym_mpoly A) q') =\n    insertion (\\<lambda>n. insertion (l \\<circ> root) (sym_mpoly A n))\n     (map_mpoly (insertion (l \\<circ> root)) q')", "by (rule insertion_insertion)"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) (insertion (sym_mpoly A) q') =\n  insertion (\\<lambda>n. insertion (l \\<circ> root) (sym_mpoly A n))\n   (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) (insertion (sym_mpoly A) q') =\n  insertion (\\<lambda>n. insertion (l \\<circ> root) (sym_mpoly A n))\n   (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (sym_mpoly A) q' = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) q' = q", "unfolding q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (sym_mpoly A) (fund_sym_poly_wit A q) = q", "by (intro fund_sym_poly_wit_insertion sym)"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) q' = q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  insertion (sym_mpoly A) q' = q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (\\<lambda>i. insertion (l \\<circ> root) (sym_mpoly A i))\n               (map_mpoly (insertion (l \\<circ> root)) q') =\n             insertion (\\<lambda>i. cinv * l ((- 1) ^ i) * l (poly.coeff p (n - i)))\n               (map_mpoly (insertion (l \\<circ> root)) q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. insertion (l \\<circ> root) (sym_mpoly A i))\n     (map_mpoly (insertion (l \\<circ> root)) q') =\n    insertion\n     (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n     (map_mpoly (insertion (l \\<circ> root)) q')", "proof (intro insertion_irrelevant_vars, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> vars (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "hence \"i \\<in> vars q'\""], ["proof (prove)\nusing this:\n  i \\<in> vars (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. i \\<in> vars q'", "using vars_map_mpoly_subset"], ["proof (prove)\nusing this:\n  i \\<in> vars (map_mpoly (insertion (l \\<circ> root)) q')\n  vars (map_mpoly ?f ?p) \\<subseteq> vars ?p\n\ngoal (1 subgoal):\n 1. i \\<in> vars q'", "by auto"], ["proof (state)\nthis:\n  i \\<in> vars q'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "also"], ["proof (state)\nthis:\n  i \\<in> vars q'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "have \"\\<dots> \\<subseteq> {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars q' \\<subseteq> {1..n}", "unfolding q'_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (fund_sym_poly_wit A q) \\<subseteq> {1..card A}", "by (intro fund_sym_poly_wit_vars)"], ["proof (state)\nthis:\n  vars q' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "finally"], ["proof (chain)\npicking this:\n  i \\<in> {1..n}", "have i: \"i \\<in> {1..n}\""], ["proof (prove)\nusing this:\n  i \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. i \\<in> {1..n}", "."], ["proof (state)\nthis:\n  i \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "have \"insertion (l \\<circ> root) (sym_mpoly A i) =\n             l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (l \\<circ> root) (sym_mpoly A i) =\n    l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y)", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. insertion (l \\<circ> root) (sym_mpoly A i) =\n    l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y)", "by (simp add: insertion_sym_mpoly)"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) (sym_mpoly A i) =\n  l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "also"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) (sym_mpoly A i) =\n  l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "have \"\\<dots> = cinv * l (c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n    cinv *\n    l (c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y))", "unfolding mult mult.assoc[symmetric] \\<open>cinv * l c = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n    (1::'b) * l (sum (prod root) {Y. Y \\<subseteq> A \\<and> card Y = i})", "by simp"], ["proof (state)\nthis:\n  l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n  cinv * l (c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "also"], ["proof (state)\nthis:\n  l (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n  cinv * l (c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y))\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "have \"c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) = ((-1) ^ i * poly.coeff p (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n    (- (1::'a)) ^ i * poly.coeff p (n - i)", "using coeff_poly_from_roots[of A \"n - i\" root] i assms finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite A; n - i \\<le> card A\\<rbrakk>\n  \\<Longrightarrow> poly.coeff (\\<Prod>x\\<in>A. [:- root x, 1::'a:])\n                     (n - i) =\n                    (- (1::'a)) ^ (card A - (n - i)) *\n                    (\\<Sum>X | X \\<subseteq> A \\<and>\n                               card X = card A - (n - i).\n                       prod root X)\n  i \\<in> {1..n}\n  cinv * l c = (1::'b)\n  cinv \\<in> C\n  p = Polynomial.smult c (\\<Prod>i\\<in>A. [:- root i, 1::'a:])\n  finite A\n\ngoal (1 subgoal):\n 1. c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n    (- (1::'a)) ^ i * poly.coeff p (n - i)", "by (auto simp: n_def minus_one_power_iff)"], ["proof (state)\nthis:\n  c * (\\<Sum>Y | Y \\<subseteq> A \\<and> card Y = i. prod root Y) =\n  (- (1::'a)) ^ i * poly.coeff p (n - i)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> vars\n                (map_mpoly (insertion (l \\<circ> root))\n                  q') \\<Longrightarrow>\n       insertion (l \\<circ> root) (sym_mpoly A v) =\n       cinv * l ((- (1::'a)) ^ v) * l (poly.coeff p (n - v))", "finally"], ["proof (chain)\npicking this:\n  insertion (l \\<circ> root) (sym_mpoly A i) =\n  cinv * l ((- (1::'a)) ^ i * poly.coeff p (n - i))", "show ?case"], ["proof (prove)\nusing this:\n  insertion (l \\<circ> root) (sym_mpoly A i) =\n  cinv * l ((- (1::'a)) ^ i * poly.coeff p (n - i))\n\ngoal (1 subgoal):\n 1. insertion (l \\<circ> root) (sym_mpoly A i) =\n    cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i))", "by (simp add: o_def)"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) (sym_mpoly A i) =\n  cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. insertion (l \\<circ> root) (sym_mpoly A i))\n   (map_mpoly (insertion (l \\<circ> root)) q') =\n  insertion\n   (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n   (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. insertion (l \\<circ> root) (sym_mpoly A i))\n   (map_mpoly (insertion (l \\<circ> root)) q') =\n  insertion\n   (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n   (map_mpoly (insertion (l \\<circ> root)) q')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map_mpoly (insertion (l \\<circ> root)) q' = map_mpoly (insertion (\\<lambda>_. 0)) q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mpoly (insertion (l \\<circ> root)) q' =\n    map_mpoly (insertion (\\<lambda>_. 0::'b)) q'", "using fund_sym_poly_wit_coeffs[OF sym] vars"], ["proof (prove)\nusing this:\n  vars (MPoly_Type.coeff (fund_sym_poly_wit A q) ?m) \\<subseteq> vars q - A\n  vars q \\<subseteq> A\n\ngoal (1 subgoal):\n 1. map_mpoly (insertion (l \\<circ> root)) q' =\n    map_mpoly (insertion (\\<lambda>_. 0::'b)) q'", "by (intro map_mpoly_cong insertion_irrelevant_vars) (auto simp: q'_def)"], ["proof (state)\nthis:\n  map_mpoly (insertion (l \\<circ> root)) q' =\n  map_mpoly (insertion (\\<lambda>_. 0::'b)) q'\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map_mpoly (insertion (l \\<circ> root)) q' =\n  map_mpoly (insertion (\\<lambda>_. 0::'b)) q'\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (\\<lambda>i. cinv * l ((- 1) ^ i) * l (poly.coeff p (n - i))) \\<dots> =\n               insertion (\\<lambda>i. l (poly.coeff p (n - i))) q''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion\n     (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n     (map_mpoly (insertion (\\<lambda>_. 0::'b)) q') =\n    insertion (\\<lambda>i. l (poly.coeff p (n - i))) q''", "unfolding insertion_substitute_linear map_mpoly_conv_mapm_mpoly q''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. l (poly.coeff p (n - i)))\n     (mapm_mpoly\n       (\\<lambda>m.\n           (*) (\\<Prod>i. (cinv * l ((- (1::'a)) ^ i)) ^ lookup m i))\n       (mapm_mpoly (\\<lambda>_. insertion (\\<lambda>_. 0::'b)) q')) =\n    insertion (\\<lambda>i. l (poly.coeff p (n - i)))\n     (mapm_mpoly\n       (\\<lambda>m x.\n           (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n           insertion (\\<lambda>_. 0::'b) x)\n       q')", "by (subst mapm_mpoly_comp) auto"], ["proof (state)\nthis:\n  insertion\n   (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n   (map_mpoly (insertion (\\<lambda>_. 0::'b)) q') =\n  insertion (\\<lambda>i. l (poly.coeff p (n - i))) q''\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  insertion\n   (\\<lambda>i. cinv * l ((- (1::'a)) ^ i) * l (poly.coeff p (n - i)))\n   (map_mpoly (insertion (\\<lambda>_. 0::'b)) q') =\n  insertion (\\<lambda>i. l (poly.coeff p (n - i))) q''\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. l (poly.coeff p (n - i))) q'' =\n    insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')", "using \\<open>bij reindex\\<close> and \\<open>vars q'' \\<subseteq> {1..n}\\<close>"], ["proof (prove)\nusing this:\n  bij reindex\n  vars q'' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. l (poly.coeff p (n - i))) q'' =\n    insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')", "by (subst insertion_mpoly_map_vars)\n       (auto simp: o_def reindex_def intro!: insertion_irrelevant_vars)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. l (poly.coeff p (n - i))) q'' =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')", "have \"insertion (l \\<circ> root) q =\n                  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\""], ["proof (prove)\nusing this:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n\ngoal (1 subgoal):\n 1. insertion (l \\<circ> root) q =\n    insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')", "."], ["proof (state)\nthis:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"coeff (mpoly_map_vars reindex q'') m \\<in> C\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars reindex q'') m \\<in> C", "unfolding q''_def q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (mpoly_map_vars reindex\n       (mapm_mpoly\n         (\\<lambda>m x.\n             (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n             insertion (\\<lambda>_. 0::'b) x)\n         (fund_sym_poly_wit A q)))\n     m\n    \\<in> C", "using \\<open>bij reindex\\<close> fund_sym_poly_wit_coeff[of q C A] C \\<open>cinv \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  bij reindex\n  \\<lbrakk>\\<forall>m. MPoly_Type.coeff q m \\<in> C; ring_closed C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m m'.\n                       MPoly_Type.coeff\n                        (MPoly_Type.coeff (fund_sym_poly_wit A q) m) m'\n                       \\<in> C\n  ring_closed C\n  \\<forall>m. MPoly_Type.coeff q m \\<in> C\n  cinv \\<in> C\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff\n     (mpoly_map_vars reindex\n       (mapm_mpoly\n         (\\<lambda>m x.\n             (\\<Prod>i. (cinv * l (- (1::'a)) ^ i) ^ lookup m i) *\n             insertion (\\<lambda>_. 0::'b) x)\n         (fund_sym_poly_wit A q)))\n     m\n    \\<in> C", "by (auto simp: coeff_mpoly_map_vars\n             intro!: mult_closed Prod_any_closed power_closed Sum_any_closed)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars reindex q'') ?m \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars reindex q'') ?m \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}", "using \\<open>bij reindex\\<close> and \\<open>vars q'' \\<subseteq> {1..n}\\<close>"], ["proof (prove)\nusing this:\n  bij reindex\n  vars q'' \\<subseteq> {1..n}\n\ngoal (1 subgoal):\n 1. vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}", "by (subst vars_mpoly_map_vars) (auto simp: reindex_def subset_iff)+"], ["proof (state)\nthis:\n  vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n  MPoly_Type.coeff (mpoly_map_vars reindex q'') ?m \\<in> C\n  vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n  MPoly_Type.coeff (mpoly_map_vars reindex q'') ?m \\<in> C\n  vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"mpoly_map_vars reindex q''\"]"], ["proof (prove)\nusing this:\n  insertion (l \\<circ> root) q =\n  insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'')\n  MPoly_Type.coeff (mpoly_map_vars reindex q'') ?m \\<in> C\n  vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n}\n  \\<lbrakk>vars (mpoly_map_vars reindex q'') \\<subseteq> {0..<n};\n   \\<And>m. MPoly_Type.coeff (mpoly_map_vars reindex q'') m \\<in> C;\n   insertion (l \\<circ> poly.coeff p) (mpoly_map_vars reindex q'') =\n   insertion (l \\<circ> root) q\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary symmetric_poly_of_roots_conv_poly_of_coeffs_monic:\n  assumes \"p = (\\<Prod>i\\<in>A. [:-root i, 1:])\"\n  obtains q' where \"vars q' \\<subseteq> {0..<n}\"\n               and \"\\<And>m. coeff q' m \\<in> C\"\n               and \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain q' where \"vars q' \\<subseteq> {0..<n}\"\n              and \"\\<And>m. coeff q' m \\<in> C\"\n              and \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule symmetric_poly_of_roots_conv_poly_of_coeffs[of 1 1 p])\n       (use assms in auto)"], ["proof (state)\nthis:\n  vars q' \\<subseteq> {0..<n}\n  MPoly_Type.coeff q' ?m \\<in> C\n  insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  vars q' \\<subseteq> {0..<n}\n  MPoly_Type.coeff q' ?m \\<in> C\n  insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of q']) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  As a corollary, we obtain the following: Let $R, S$ be rings with $R\\subseteq S$.\n  Consider a polynomial $p\\in R[X]$ whose leading coefficient $c$ is a unit in $R$ and\n  that has a full set of roots $x_1,\\ldots, x_n \\in S$,\n  i.\\,e.\\ $p(X) = c(X - x_1) \\ldots (X - x_n)$. Let $q \\in R[X_1,\\ldots, X_n]$ be some\n  symmetric polynomial expression in the roots. Then $q(x_1, \\ldots, x_n) \\in R$.\n\n  A typical use case is $R = \\mathbb{Q}$ and $S = \\mathbb{C}$, i.\\,e.\\ any symmetric\n  polynomial expression with rational coefficients in the roots of a rational polynomial is\n  again rational. Similarly, any symmetric polynomial expression with integer coefficients\n  in the roots of a monic integer polynomial is agan an integer.\n\n  This is remarkable, since the roots themselves are usually not rational (possibly not\n  even real). This particular fact is a key ingredient used in the standard proof\n  that $\\pi$ is transcendental.\n\\<close>"], ["", "corollary symmetric_poly_of_roots_in_subring:\n  assumes \"cinv * l c = 1\" \"cinv \\<in> C\"\n  assumes \"p = Polynomial.smult c (\\<Prod>i\\<in>A. [:-root i, 1:])\"\n  assumes \"\\<forall>i. l (poly.coeff p i) \\<in> C\"\n  shows   \"insertion (\\<lambda>x. l (root x)) q \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "obtain q'\n    where q': \"vars q' \\<subseteq> {0..<n}\" \"\\<And>m. coeff q' m \\<in> C\"\n              \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>vars q' \\<subseteq> {0..<n};\n         \\<And>m. MPoly_Type.coeff q' m \\<in> C;\n         insertion (l \\<circ> poly.coeff p) q' =\n         insertion (l \\<circ> root) q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule symmetric_poly_of_roots_conv_poly_of_coeffs[of cinv c p])\n       (use assms in simp_all)"], ["proof (state)\nthis:\n  vars q' \\<subseteq> {0..<n}\n  MPoly_Type.coeff q' ?m \\<in> C\n  insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "have \"insertion (l \\<circ> poly.coeff p) q' \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (l \\<circ> poly.coeff p) q' \\<in> C", "using C assms"], ["proof (prove)\nusing this:\n  ring_closed C\n  \\<forall>m. MPoly_Type.coeff q m \\<in> C\n  cinv * l c = (1::'b)\n  cinv \\<in> C\n  p = Polynomial.smult c (\\<Prod>i\\<in>A. [:- root i, 1::'a:])\n  \\<forall>i. l (poly.coeff p i) \\<in> C\n\ngoal (1 subgoal):\n 1. insertion (l \\<circ> poly.coeff p) q' \\<in> C", "unfolding insertion_altdef"], ["proof (prove)\nusing this:\n  ring_closed C\n  \\<forall>m. MPoly_Type.coeff q m \\<in> C\n  cinv * l c = (1::'b)\n  cinv \\<in> C\n  p = Polynomial.smult c (\\<Prod>i\\<in>A. [:- root i, 1::'a:])\n  \\<forall>i. l (poly.coeff p i) \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff q' m *\n              (\\<Prod>i. (l \\<circ> poly.coeff p) i ^ lookup m i))\n    \\<in> C", "by (intro Sum_any_closed mult_closed q' Prod_any_closed power_closed) auto"], ["proof (state)\nthis:\n  insertion (l \\<circ> poly.coeff p) q' \\<in> C\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "also"], ["proof (state)\nthis:\n  insertion (l \\<circ> poly.coeff p) q' \\<in> C\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "have \"insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q", "by fact"], ["proof (state)\nthis:\n  insertion (l \\<circ> poly.coeff p) q' = insertion (l \\<circ> root) q\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "finally"], ["proof (chain)\npicking this:\n  insertion (l \\<circ> root) q \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  insertion (l \\<circ> root) q \\<in> C\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "by (simp add: o_def)"], ["proof (state)\nthis:\n  insertion (\\<lambda>x. l (root x)) q \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary symmetric_poly_of_roots_in_subring_monic:\n  assumes \"p = (\\<Prod>i\\<in>A. [:-root i, 1:])\"\n  assumes \"\\<forall>i. l (poly.coeff p i) \\<in> C\"\n  shows   \"insertion (\\<lambda>x. l (root x)) q \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "interpret ring_closed C"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed C", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "interpret ring_homomorphism l"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism l", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. l (root x)) q \\<in> C", "by (rule symmetric_poly_of_roots_in_subring[of 1 1 p]) (use assms in auto)"], ["proof (state)\nthis:\n  insertion (\\<lambda>x. l (root x)) q \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}