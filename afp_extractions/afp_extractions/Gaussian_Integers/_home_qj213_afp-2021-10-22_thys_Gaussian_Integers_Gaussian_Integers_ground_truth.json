{"file_name": "/home/qj213/afp-2021-10-22/thys/Gaussian_Integers/Gaussian_Integers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gaussian_Integers", "problem_names": ["lemma coprime_iff_prime_factors_disjoint:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"coprime x y \\<longleftrightarrow> prime_factors x \\<inter> prime_factors y = {}\"", "lemma product_dvd_irreducibleD:\n  fixes a b x :: \"'a :: algebraic_semidom\"\n  assumes \"irreducible x\"\n  assumes \"a * b dvd x\"\n  shows \"a dvd 1 \\<or> b dvd 1\"", "lemma prime_elem_mult_dvdI:\n  assumes \"prime_elem p\" \"p dvd c\" \"b dvd c\" \"\\<not>p dvd b\"\n  shows   \"p * b dvd c\"", "lemma prime_elem_power_mult_dvdI:\n  fixes p :: \"'a :: algebraic_semidom\"\n  assumes \"prime_elem p\" \"p ^ n dvd c\" \"b dvd c\" \"\\<not>p dvd b\"\n  shows   \"p ^ n * b dvd c\"", "lemma prime_mod_4_cases:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows   \"p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\"", "lemma of_nat_prod_mset: \"of_nat (prod_mset A) = prod_mset (image_mset of_nat A)\"", "lemma multiplicity_0_left [simp]: \"multiplicity 0 x = 0\"", "lemma is_unit_power [intro]: \"is_unit x \\<Longrightarrow> is_unit (x ^ n)\"", "lemma (in factorial_semiring) pow_divides_pow_iff:\n  assumes \"n > 0\"\n  shows   \"a ^ n dvd b ^ n \\<longleftrightarrow> a dvd b\"", "lemma multiplicity_power_power:\n  fixes p :: \"'a :: {factorial_semiring, algebraic_semidom}\"\n  assumes \"n > 0\"\n  shows   \"multiplicity (p ^ n) (x ^ n) = multiplicity p x\"", "lemma even_square_cong_4_int:\n  fixes x :: int\n  assumes \"even x\"\n  shows   \"[x ^ 2 = 0] (mod 4)\"", "lemma even_square_cong_4_nat: \"even (x::nat) \\<Longrightarrow> [x ^ 2 = 0] (mod 4)\"", "lemma odd_square_cong_4_int:\n  fixes x :: int\n  assumes \"odd x\"\n  shows   \"[x ^ 2 = 1] (mod 4)\"", "lemma odd_square_cong_4_nat: \"odd (x::nat) \\<Longrightarrow> [x ^ 2 = 1] (mod 4)\"", "lemma is_nth_power_upto_unit_base: \"is_nth_power n x \\<Longrightarrow> is_nth_power_upto_unit n x\"", "lemma is_nth_power_upto_unitI:\n  assumes \"normalize (x ^ n) = normalize y\"\n  shows   \"is_nth_power_upto_unit n y\"", "lemma is_nth_power_upto_unit_conv_multiplicity: \n  fixes x :: \"'a :: factorial_semiring\"\n  assumes \"n > 0\"\n  shows   \"is_nth_power_upto_unit n x \\<longleftrightarrow> (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)\"", "lemma is_nth_power_upto_unit_0_left [simp, intro]: \"is_nth_power_upto_unit 0 x \\<longleftrightarrow> is_unit x\"", "lemma is_nth_power_upto_unit_unit [simp, intro]:\n  assumes \"is_unit x\"\n  shows   \"is_nth_power_upto_unit n x\"", "lemma is_nth_power_upto_unit_1_left [simp, intro]: \"is_nth_power_upto_unit 1 x\"", "lemma is_nth_power_upto_unit_mult_coprimeD1:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"coprime x y\" \"is_nth_power_upto_unit n (x * y)\"\n  shows   \"is_nth_power_upto_unit n x\"", "lemma is_nth_power_upto_unit_mult_coprimeD2:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"coprime x y\" \"is_nth_power_upto_unit n (x * y)\"\n  shows   \"is_nth_power_upto_unit n y\"", "lemma gauss_int_eq_iff: \"x = y \\<longleftrightarrow> ReZ x = ReZ y \\<and> ImZ x = ImZ y\"", "lemma gauss2complex_eq_iff [simp]: \"gauss2complex z = gauss2complex u \\<longleftrightarrow> z = u\"", "lemma gauss_i_times_i [simp]: \"\\<i>\\<^sub>\\<int> * \\<i>\\<^sub>\\<int> = (-1 :: gauss_int)\"\n  and gauss_cnj_i [simp]: \"gauss_cnj \\<i>\\<^sub>\\<int> = -\\<i>\\<^sub>\\<int>\"", "lemma gauss_cnj_eq_0_iff [simp]: \"gauss_cnj z = 0 \\<longleftrightarrow> z = 0\"", "lemma gauss_cnj_eq_self: \"Im z = 0 \\<Longrightarrow> gauss_cnj z = z\"\n  and gauss_cnj_eq_minus_self: \"Re z = 0 \\<Longrightarrow> gauss_cnj z = -z\"", "lemma ReZ_of_nat [simp]: \"ReZ (of_nat n) = of_nat n\"\n  and ImZ_of_nat [simp]: \"ImZ (of_nat n) = 0\"", "lemma ReZ_of_int [simp]: \"ReZ (of_int n) = n\"\n  and ImZ_of_int [simp]: \"ImZ (of_int n) = 0\"", "lemma ReZ_numeral [simp]: \"ReZ (numeral n) = numeral n\"\n  and ImZ_numeral [simp]: \"ImZ (numeral n) = 0\"", "lemma gauss2complex_0 [simp]: \"gauss2complex 0 = 0\"\n  and gauss2complex_1 [simp]: \"gauss2complex 1 = 1\"\n  and gauss2complex_i [simp]: \"gauss2complex \\<i>\\<^sub>\\<int> = \\<i>\"\n  and gauss2complex_add [simp]: \"gauss2complex (x + y) = gauss2complex x + gauss2complex y\"\n  and gauss2complex_diff [simp]: \"gauss2complex (x - y) = gauss2complex x - gauss2complex y\"\n  and gauss2complex_mult [simp]: \"gauss2complex (x * y) = gauss2complex x * gauss2complex y\"\n  and gauss2complex_uminus [simp]: \"gauss2complex (-x) = -gauss2complex x\"\n  and gauss2complex_cnj [simp]: \"gauss2complex (gauss_cnj x) = cnj (gauss2complex x)\"", "lemma gauss2complex_of_nat [simp]: \"gauss2complex (of_nat n) = of_nat n\"", "lemma gauss2complex_eq_0_iff [simp]: \"gauss2complex x = 0 \\<longleftrightarrow> x = 0\"\n  and gauss2complex_eq_1_iff [simp]: \"gauss2complex x = 1 \\<longleftrightarrow> x = 1\"\n  and zero_eq_gauss2complex_iff [simp]: \"0 = gauss2complex x \\<longleftrightarrow> x = 0\"\n  and one_eq_gauss2complex_iff [simp]: \"1 = gauss2complex x \\<longleftrightarrow> x = 1\"", "lemma gauss_i_times_gauss_i_times [simp]: \"\\<i>\\<^sub>\\<int> * (\\<i>\\<^sub>\\<int> * x) = (-x :: gauss_int)\"", "lemma gauss_i_neq_0 [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> 0\" \"0 \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_1 [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> 1\" \"1 \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_of_nat [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> of_nat n\" \"of_nat n \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_of_int [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> of_int n\" \"of_int n \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_numeral [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> numeral m\" \"numeral m \\<noteq> \\<i>\\<^sub>\\<int>\"", "lemma gauss_cnj_0 [simp]: \"gauss_cnj 0 = 0\"\n  and gauss_cnj_1 [simp]: \"gauss_cnj 1 = 1\"\n  and gauss_cnj_cnj [simp]: \"gauss_cnj (gauss_cnj z) = z\"\n  and gauss_cnj_uminus [simp]: \"gauss_cnj (-a) = -gauss_cnj a\"\n  and gauss_cnj_add [simp]: \"gauss_cnj (a + b) = gauss_cnj a + gauss_cnj b\"\n  and gauss_cnj_diff [simp]: \"gauss_cnj (a - b) = gauss_cnj a - gauss_cnj b\"\n  and gauss_cnj_mult [simp]: \"gauss_cnj (a * b) = gauss_cnj a * gauss_cnj b\"\n  and gauss_cnj_of_nat [simp]: \"gauss_cnj (of_nat n1) = of_nat n1\"\n  and gauss_cnj_of_int [simp]: \"gauss_cnj (of_int n2) = of_int n2\"\n  and gauss_cnj_numeral [simp]: \"gauss_cnj (numeral n3) = numeral n3\"", "lemma gauss_cnj_power [simp]: \"gauss_cnj (a ^ n) = gauss_cnj a ^ n\"", "lemma gauss_cnj_sum [simp]: \"gauss_cnj (sum f A) = (\\<Sum>x\\<in>A. gauss_cnj (f x))\"", "lemma gauss_cnj_prod [simp]: \"gauss_cnj (prod f A) = (\\<Prod>x\\<in>A. gauss_cnj (f x))\"", "lemma of_nat_dvd_of_nat:\n  assumes \"a dvd b\"\n  shows   \"of_nat a dvd (of_nat b :: 'a :: comm_semiring_1)\"", "lemma of_int_dvd_imp_dvd_gauss_cnj:\n  fixes z :: gauss_int\n  assumes \"of_int n dvd z\"\n  shows   \"of_int n dvd gauss_cnj z\"", "lemma of_nat_dvd_imp_dvd_gauss_cnj:\n  fixes z :: gauss_int\n  assumes \"of_nat n dvd z\"\n  shows   \"of_nat n dvd gauss_cnj z\"", "lemma of_int_dvd_of_int_gauss_int_iff:\n  \"(of_int m :: gauss_int) dvd of_int n \\<longleftrightarrow> m dvd n\"", "lemma of_nat_dvd_of_nat_gauss_int_iff:\n  \"(of_nat m :: gauss_int) dvd of_nat n \\<longleftrightarrow> m dvd n\"", "lemma gauss_cnj_dvd:\n  assumes \"a dvd b\"\n  shows   \"gauss_cnj a dvd gauss_cnj b\"", "lemma gauss_cnj_dvd_iff: \"gauss_cnj a dvd gauss_cnj b \\<longleftrightarrow> a dvd b\"", "lemma gauss_cnj_dvd_left_iff: \"gauss_cnj a dvd b \\<longleftrightarrow> a dvd gauss_cnj b\"", "lemma gauss_cnj_dvd_right_iff: \"a dvd gauss_cnj b \\<longleftrightarrow> gauss_cnj a dvd b\"", "lemma gauss_int_code_post [code_post]:\n  \"Gauss_Int 0 0 = 0\"\n  \"Gauss_Int 0 1 = \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (-1) = -\\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 0 = 1\"\n  \"Gauss_Int 1 1 = 1 + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (-1) = 1 - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) 0 = -1\"\n  \"Gauss_Int (-1) 1 = -1 + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (-1) = -1 - \\<i>\\<^sub>\\<int>\"  \n  \"Gauss_Int (numeral b) 0 = numeral b\"\n  \"Gauss_Int (-numeral b) 0 = -numeral b\"\n  \"Gauss_Int (numeral b) 1 = numeral b + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral b) 1 = -numeral b + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral b) (-1) = numeral b - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral b) (-1) = -numeral b - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (numeral b) = numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (-numeral b) = -numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (numeral b) = 1 + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (-numeral b) = 1 - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (numeral b) = -1 + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (-numeral b) = -1 - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral a) (numeral b) = numeral a + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral a) (-numeral b) = numeral a - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral a) (numeral b) = -numeral a + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral a) (-numeral b) = -numeral a - numeral b * \\<i>\\<^sub>\\<int>\"", "lemma gauss_int_norm_0 [simp]: \"gauss_int_norm 0 = 0\"\n  and gauss_int_norm_1 [simp]: \"gauss_int_norm 1 = 1\"\n  and gauss_int_norm_i [simp]: \"gauss_int_norm \\<i>\\<^sub>\\<int> = 1\"\n  and gauss_int_norm_cnj [simp]: \"gauss_int_norm (gauss_cnj z) = gauss_int_norm z\"\n  and gauss_int_norm_of_nat [simp]: \"gauss_int_norm (of_nat n) = n ^ 2\"\n  and gauss_int_norm_of_int [simp]: \"gauss_int_norm (of_int m) = nat (m ^ 2)\"\n  and gauss_int_norm_of_numeral [simp]: \"gauss_int_norm (numeral n') = numeral (Num.sqr n')\"", "lemma gauss_int_norm_uminus [simp]: \"gauss_int_norm (-z) = gauss_int_norm z\"", "lemma gauss_int_norm_eq_0_iff [simp]: \"gauss_int_norm z = 0 \\<longleftrightarrow> z = 0\"", "lemma gauss_int_norm_pos_iff [simp]: \"gauss_int_norm z > 0 \\<longleftrightarrow> z \\<noteq> 0\"", "lemma real_gauss_int_norm: \"real (gauss_int_norm z) = norm (gauss2complex z) ^ 2\"", "lemma gauss_int_norm_mult: \"gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u\"", "lemma self_mult_gauss_cnj: \"z * gauss_cnj z = of_nat (gauss_int_norm z)\"", "lemma gauss_cnj_mult_self: \"gauss_cnj z * z = of_nat (gauss_int_norm z)\"", "lemma self_plus_gauss_cnj: \"z + gauss_cnj z = of_int (2 * ReZ z)\"\n  and self_minus_gauss_cnj: \"z - gauss_cnj z = of_int (2 * ImZ z) * \\<i>\\<^sub>\\<int>\"", "lemma gauss_int_norm_dvd_mono:\n  assumes \"a dvd b\"\n  shows \"gauss_int_norm a dvd gauss_int_norm b\"", "lemma is_unit_gauss_int_iff: \"x dvd 1 \\<longleftrightarrow> x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int> :: gauss_int}\"\n  and is_unit_gauss_int_iff': \"x dvd 1 \\<longleftrightarrow> gauss_int_norm x = 1\"", "lemma is_unit_gauss_i [simp, intro]: \"(gauss_i :: gauss_int) dvd 1\"", "lemma gauss_int_norm_eq_Suc_0_iff: \"gauss_int_norm x = Suc 0 \\<longleftrightarrow> x dvd 1\"", "lemma is_unit_gauss_cnj [intro]: \"z dvd 1 \\<Longrightarrow> gauss_cnj z dvd 1\"", "lemma is_unit_gauss_cnj_iff [simp]: \"gauss_cnj z dvd 1 \\<longleftrightarrow> z dvd 1\"", "lemma norm_round_complex_le: \"norm (z - gauss2complex (round_complex z)) ^ 2 \\<le> 1 / 2\"", "lemma dist_round_complex_le: \"dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2\"", "lemma normalize_gauss_int_of_nat [simp]: \"normalize (of_nat n :: gauss_int) = of_nat n\"\n  and normalize_gauss_int_of_int [simp]: \"normalize (of_int m :: gauss_int) = of_int \\<bar>m\\<bar>\"\n  and normalize_gauss_int_of_numeral [simp]: \"normalize (numeral n' :: gauss_int) = numeral n'\"", "lemma normalize_gauss_i [simp]: \"normalize \\<i>\\<^sub>\\<int> = 1\"", "lemma gauss_int_norm_normalize [simp]: \"gauss_int_norm (normalize x) = gauss_int_norm x\"", "lemma normalized_gauss_int:\n  assumes \"normalize z = z\"\n  shows   \"ReZ z \\<ge> 0\" \"ImZ z \\<ge> 0\"", "lemma normalized_gauss_int':\n  assumes \"normalize z = z\" \"z \\<noteq> 0\"\n  shows   \"ReZ z > 0\" \"ImZ z \\<ge> 0\"", "lemma normalized_gauss_int_iff:\n  \"normalize z = z \\<longleftrightarrow> z = 0 \\<or> ReZ z > 0 \\<and> ImZ z \\<ge> 0\"", "lemma gauss_int_norm_mod_less_aux:\n  assumes [simp]: \"b \\<noteq> 0\"\n  shows   \"2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b\"", "lemma gauss_int_norm_mod_less:\n  assumes [simp]: \"b \\<noteq> 0\"\n  shows   \"gauss_int_norm (a mod b) < gauss_int_norm b\"", "lemma gauss_int_norm_dvd_imp_le:\n  assumes \"b \\<noteq> 0\"\n  shows   \"gauss_int_norm a \\<le> gauss_int_norm (a * b)\"", "lemma multiplicity_gauss_cnj: \"multiplicity (gauss_cnj a) (gauss_cnj b) = multiplicity a b\"", "lemma multiplicity_gauss_int_of_nat:\n  \"multiplicity (of_nat a) (of_nat b :: gauss_int) = multiplicity a b\"", "lemma gauss_int_dvd_same_norm_imp_associated:\n  assumes \"z1 dvd z2\" \"gauss_int_norm z1 = gauss_int_norm z2\"\n  shows   \"normalize z1 = normalize z2\"", "lemma gcd_of_int_gauss_int: \"gcd (of_int a :: gauss_int) (of_int b) = of_int (gcd a b)\"", "lemma coprime_of_int_gauss_int: \"coprime (of_int a :: gauss_int) (of_int b) = coprime a b\"", "lemma gcd_of_nat_gauss_int: \"gcd (of_nat a :: gauss_int) (of_nat b) = of_nat (gcd a b)\"", "lemma coprime_of_nat_gauss_int: \"coprime (of_nat a :: gauss_int) (of_nat b) = coprime a b\"", "lemma gauss_cnj_dvd_self_iff: \"gauss_cnj z dvd z \\<longleftrightarrow> ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\"", "lemma self_dvd_gauss_cnj_iff: \"z dvd gauss_cnj z \\<longleftrightarrow> ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\"", "lemma prime_gauss_int_norm_imp_prime_elem:\n  assumes \"prime (gauss_int_norm q)\"\n  shows   \"prime_elem q\"", "lemma prime_elem_gauss_cnj [intro]: \"prime_elem z \\<Longrightarrow> prime_elem (gauss_cnj z)\"", "lemma prime_elem_gauss_cnj_iff [simp]: \"prime_elem (gauss_cnj z) \\<longleftrightarrow> prime_elem z\"", "lemma gauss_int_2_eq: \"2 = -\\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>) ^ 2\"", "lemma prime_elem_one_plus_i_gauss_int: \"prime_elem (1 + \\<i>\\<^sub>\\<int>)\"", "lemma prime_one_plus_i_gauss_int: \"prime (1 + \\<i>\\<^sub>\\<int>)\"", "lemma prime_factorization_2_gauss_int:\n  \"prime_factorization (2 :: gauss_int) = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}\"", "lemma gauss_int_norm_not_3_mod_4: \"[gauss_int_norm z \\<noteq> 3] (mod 4)\"", "lemma prime_elem_gauss_int_of_nat:\n  fixes n :: nat\n  assumes prime: \"prime n\" and \"[n = 3] (mod 4)\"\n  shows   \"prime_elem (of_nat n :: gauss_int)\"", "theorem prime_gauss_int_of_nat:\n  fixes n :: nat\n  assumes prime: \"prime n\" and \"[n = 3] (mod 4)\"\n  shows   \"prime (of_nat n :: gauss_int)\"", "lemma minimal_QuadRes_neg1:\n  assumes \"QuadRes n (-1)\" \"n > 1\" \"odd n\"\n  obtains x :: nat where \"x \\<le> (n - 1) div 2\" and \"[x ^ 2 + 1 = 0] (mod n)\"", "lemma p_gt_2: \"p > 2\" and odd_p: \"odd p\"", "lemma minimal_QuadRes_neg1:\n  obtains x where \"x > 0\" \"x \\<le> (p - 1) div 2\" \"[x ^ 2 + 1 = 0] (mod p)\"", "lemma not_prime: \"\\<not>prime_elem (of_nat p :: gauss_int)\"", "lemma norm_prime_divisor:\n  fixes q :: gauss_int\n  assumes q: \"prime_elem q\" \"q dvd of_nat p\"\n  shows \"gauss_int_norm q = p\"", "lemma prime_divisor_exists:\n  obtains q where \"prime q\" \"prime_elem (gauss_cnj q)\" \"ReZ q > 0\" \"ImZ q > 0\"\n                  \"of_nat p = q * gauss_cnj q\" \"gauss_int_norm q = p\"", "theorem prime_factorization:\n  obtains q1 q2\n  where \"prime q1\" \"prime q2\" \"prime_factorization (of_nat p) = {#q1, q2#}\" \n        \"gauss_int_norm q1 = p\" \"gauss_int_norm q2 = p\" \"q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\"\n        \"ReZ q1 > 0\" \"ImZ q1 > 0\" \"ReZ q1 > 0\" \"ImZ q2 > 0\"", "lemma prime_cong_1_mod_4_gauss_int_norm_exists:\n  fixes p :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\"\n  shows   \"\\<exists>z. gauss_int_norm z = p \\<and> ReZ z > 0 \\<and> ImZ z > 0\"", "theorem gauss_int_prime_classification:\n  fixes x :: gauss_int\n  assumes \"prime x\"\n  obtains \n    (one_plus_i) \"x = 1 + \\<i>\\<^sub>\\<int>\"\n  | (cong_3_mod_4) p where \"x = of_nat p\" \"prime p\" \"[p = 3] (mod 4)\"\n  | (cong_1_mod_4) \"prime (gauss_int_norm x)\" \"[gauss_int_norm x = 1] (mod 4)\"\n                   \"ReZ x > 0\" \"ImZ x > 0\" \"ReZ x \\<noteq> ImZ x\"", "lemma prime_gauss_int_norm_squareD:\n  fixes z :: gauss_int\n  assumes \"prime z\" \"gauss_int_norm z = p ^ 2\"\n  shows   \"prime p \\<and> z = of_nat p\"", "lemma gauss_int_norm_eq_prime_squareD:\n  assumes \"prime p\" and \"[p = 3] (mod 4)\" and \"gauss_int_norm z = p ^ 2\"\n  shows   \"normalize z = of_nat p\" and \"prime_elem z\"", "lemma prime_elem_gauss_int_iff:\n  fixes z :: gauss_int\n  defines \"n \\<equiv> gauss_int_norm z\"\n  shows   \"prime_elem z \\<longleftrightarrow> prime n \\<or> (\\<exists>p. n = p ^ 2 \\<and> prime p \\<and> [p = 3] (mod 4))\"", "lemma multiplicity_prime_1_plus_i_aux: \"multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\"", "lemma multiplicity_prime_cong_3_mod_4:\n  assumes \"prime (of_nat q :: gauss_int)\"\n  shows   \"multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\"", "lemma multiplicity_prime_cong_1_mod_4_aux:\n  fixes p :: gauss_int\n  assumes \"prime_elem p\" \"ReZ p > 0\" \"ImZ p > 0\" \"ImZ p \\<noteq> ReZ p\"\n  shows \"multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c\"", "lemma multiplicity_prime_cong_1_mod_4:\n  fixes p :: gauss_int\n  assumes \"prime_elem p\" \"ReZ p > 0\" \"ImZ p > 0\" \"ImZ p \\<noteq> ReZ p\"\n  shows \"multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n           multiplicity p z + multiplicity (gauss_cnj p) z\"", "lemma multiplicity_prime_1_plus_i: \"multiplicity (1 + \\<i>\\<^sub>\\<int>) z = multiplicity 2 (gauss_int_norm z)\"", "lemma coprime_self_gauss_cnj:\n  assumes \"coprime (ReZ z) (ImZ z)\" and \"odd (gauss_int_norm z)\"\n  shows   \"coprime z (gauss_cnj z)\"", "lemma prime_1_mod_4_sum_of_squares_unique_aux:\n  fixes p x y :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\" \"x ^ 2 + y ^ 2 = p\"\n  shows   \"x > 0 \\<and> y > 0 \\<and> x \\<noteq> y\"", "lemma prime_1_mod_4_sum_of_squares_unique:\n  fixes p :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\"\n  shows   \"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\"", "lemma two_sum_of_squares_nat_iff: \"(x :: nat) ^ 2 + y ^ 2 = 2 \\<longleftrightarrow> x = 1 \\<and> y = 1\"", "lemma prime_sum_of_squares_unique:\n  fixes p :: nat\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  shows   \"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\"", "lemma prime_square_sum_nat_decomp_eqI:\n  assumes \"prime p\" \"x ^ 2 + y ^ 2 = p\" \"x \\<le> y\"\n  shows   \"prime_square_sum_nat_decomp p = (x, y)\"", "lemma prime_square_sum_nat_decomp_correct:\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  defines \"z \\<equiv> prime_square_sum_nat_decomp p\"\n  shows \"fst z ^ 2 + snd z ^ 2 = p\" \"fst z \\<le> snd z\"", "lemma sum_of_squares_nat_bound:\n  fixes x y n :: nat\n  assumes \"x ^ 2 + y ^ 2 = n\"\n  shows   \"x \\<le> n\"", "lemma sum_of_squares_nat_bound':\n  fixes x y n :: nat\n  assumes \"x ^ 2 + y ^ 2 = n\"\n  shows   \"y \\<le> n\"", "lemma is_singleton_conv_Ex1:\n  \"is_singleton A \\<longleftrightarrow> (\\<exists>!x. x \\<in> A)\"", "lemma the_elemI:\n  assumes \"is_singleton A\"\n  shows   \"the_elem A \\<in> A\"", "lemma prime_square_sum_nat_decomp_code_aux:\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  defines \"z \\<equiv> the_elem (Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p}))\"\n  shows \"prime_square_sum_nat_decomp p = z\"", "lemma prime_square_sum_nat_decomp_code [code]:\n  \"prime_square_sum_nat_decomp p =\n     (if prime p \\<and> (p = 2 \\<or> [p = 1] (mod 4))\n      then the_elem (Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p}))\n      else (0, 0))\"", "lemma factor_gauss_int_prime_nat_correct:\n  assumes \"prime p\"\n  shows   \"set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\"", "lemma prime_factors_gauss_int_of_nat_correct:\n  \"prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\"", "lemma prime_factors_gauss_int_correct [code_unfold]: \"prime_factors z = prime_factors_gauss_int z\""], "translations": [["", "lemma coprime_iff_prime_factors_disjoint:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"\n  shows \"coprime x y \\<longleftrightarrow> prime_factors x \\<inter> prime_factors y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime x y = (prime_factors x \\<inter> prime_factors y = {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. coprime x y \\<Longrightarrow>\n    prime_factors x \\<inter> prime_factors y = {}\n 2. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "assume \"coprime x y\""], ["proof (state)\nthis:\n  coprime x y\n\ngoal (2 subgoals):\n 1. coprime x y \\<Longrightarrow>\n    prime_factors x \\<inter> prime_factors y = {}\n 2. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "have False if \"p \\<in> prime_factors x\" \"p \\<in> prime_factors y\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that assms"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization x\n  p \\<in># prime_factorization y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)", "have \"p dvd x\" \"p dvd y\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization x\n  p \\<in># prime_factorization y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p dvd x &&& p dvd y", "by (auto simp: prime_factors_dvd)"], ["proof (state)\nthis:\n  p dvd x\n  p dvd y\n\ngoal (1 subgoal):\n 1. False", "with \\<open>coprime x y\\<close>"], ["proof (chain)\npicking this:\n  coprime x y\n  p dvd x\n  p dvd y", "have \"p dvd 1\""], ["proof (prove)\nusing this:\n  coprime x y\n  p dvd x\n  p dvd y\n\ngoal (1 subgoal):\n 1. is_unit p", "using coprime_common_divisor"], ["proof (prove)\nusing this:\n  coprime x y\n  p dvd x\n  p dvd y\n  \\<lbrakk>coprime ?a ?b; ?c dvd ?a; ?c dvd ?b\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c\n\ngoal (1 subgoal):\n 1. is_unit p", "by auto"], ["proof (state)\nthis:\n  is_unit p\n\ngoal (1 subgoal):\n 1. False", "with that assms"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization x\n  p \\<in># prime_factorization y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n  is_unit p", "show False"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization x\n  p \\<in># prime_factorization y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n  is_unit p\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: prime_factors_dvd)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in># prime_factorization x;\n   ?p \\<in># prime_factorization y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. coprime x y \\<Longrightarrow>\n    prime_factors x \\<inter> prime_factors y = {}\n 2. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "thus \"prime_factors x \\<inter> prime_factors y = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?p \\<in># prime_factorization x;\n   ?p \\<in># prime_factorization y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. prime_factors x \\<inter> prime_factors y = {}", "by auto"], ["proof (state)\nthis:\n  prime_factors x \\<inter> prime_factors y = {}\n\ngoal (1 subgoal):\n 1. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "assume disjoint: \"prime_factors x \\<inter> prime_factors y = {}\""], ["proof (state)\nthis:\n  prime_factors x \\<inter> prime_factors y = {}\n\ngoal (1 subgoal):\n 1. prime_factors x \\<inter> prime_factors y = {} \\<Longrightarrow>\n    coprime x y", "show \"coprime x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime x y", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd x; c dvd y\\<rbrakk> \\<Longrightarrow> is_unit c", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd x; c dvd y\\<rbrakk> \\<Longrightarrow> is_unit c", "assume d: \"d dvd x\" \"d dvd y\""], ["proof (state)\nthis:\n  d dvd x\n  d dvd y\n\ngoal (1 subgoal):\n 1. \\<And>c. \\<lbrakk>c dvd x; c dvd y\\<rbrakk> \\<Longrightarrow> is_unit c", "show \"is_unit d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "assume \"\\<not>is_unit d\""], ["proof (state)\nthis:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "from this and d assms"], ["proof (chain)\npicking this:\n  \\<not> is_unit d\n  d dvd x\n  d dvd y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)", "have \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  d dvd x\n  d dvd y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. d \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_unit d\n  d \\<noteq> (0::'a)", "obtain p where p: \"prime p\" \"p dvd d\""], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists"], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  d \\<noteq> (0::'a)\n  \\<lbrakk>?a \\<noteq> (0::?'a); \\<not> is_unit ?a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. b dvd ?a \\<and> prime b\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "with d and assms"], ["proof (chain)\npicking this:\n  d dvd x\n  d dvd y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n  prime p\n  p dvd d", "have \"p \\<in> prime_factors x \\<inter> prime_factors y\""], ["proof (prove)\nusing this:\n  d dvd x\n  d dvd y\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n  prime p\n  p dvd d\n\ngoal (1 subgoal):\n 1. p \\<in> prime_factors x \\<inter> prime_factors y", "by (auto simp: prime_factors_dvd)"], ["proof (state)\nthis:\n  p \\<in> prime_factors x \\<inter> prime_factors y\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "with disjoint"], ["proof (chain)\npicking this:\n  prime_factors x \\<inter> prime_factors y = {}\n  p \\<in> prime_factors x \\<inter> prime_factors y", "show False"], ["proof (prove)\nusing this:\n  prime_factors x \\<inter> prime_factors y = {}\n  p \\<in> prime_factors x \\<inter> prime_factors y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coprime x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma product_dvd_irreducibleD:\n  fixes a b x :: \"'a :: algebraic_semidom\"\n  assumes \"irreducible x\"\n  assumes \"a * b dvd x\"\n  shows \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "from assms"], ["proof (chain)\npicking this:\n  irreducible x\n  a * b dvd x", "obtain c where \"x = a * b * c\""], ["proof (prove)\nusing this:\n  irreducible x\n  a * b dvd x\n\ngoal (1 subgoal):\n 1. (\\<And>c. x = a * b * c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = a * b * c\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "hence \"x = a * (b * c)\""], ["proof (prove)\nusing this:\n  x = a * b * c\n\ngoal (1 subgoal):\n 1. x = a * (b * c)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  x = a * (b * c)\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "from irreducibleD[OF assms(1) this]"], ["proof (chain)\npicking this:\n  is_unit a \\<or> is_unit (b * c)", "show \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  is_unit a \\<or> is_unit (b * c)\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by (auto simp: is_unit_mult_iff)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_elem_mult_dvdI:\n  assumes \"prime_elem p\" \"p dvd c\" \"b dvd c\" \"\\<not>p dvd b\"\n  shows   \"p * b dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * b dvd c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p * b dvd c", "from assms(3)"], ["proof (chain)\npicking this:\n  b dvd c", "obtain a where c: \"c = a * b\""], ["proof (prove)\nusing this:\n  b dvd c\n\ngoal (1 subgoal):\n 1. (\\<And>a. c = a * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using mult.commute"], ["proof (prove)\nusing this:\n  b dvd c\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. (\\<And>a. c = a * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  c = a * b\n\ngoal (1 subgoal):\n 1. p * b dvd c", "with assms(2)"], ["proof (chain)\npicking this:\n  p dvd c\n  c = a * b", "have \"p dvd a * b\""], ["proof (prove)\nusing this:\n  p dvd c\n  c = a * b\n\ngoal (1 subgoal):\n 1. p dvd a * b", "by simp"], ["proof (state)\nthis:\n  p dvd a * b\n\ngoal (1 subgoal):\n 1. p * b dvd c", "with assms"], ["proof (chain)\npicking this:\n  prime_elem p\n  p dvd c\n  b dvd c\n  \\<not> p dvd b\n  p dvd a * b", "have \"p dvd a\""], ["proof (prove)\nusing this:\n  prime_elem p\n  p dvd c\n  b dvd c\n  \\<not> p dvd b\n  p dvd a * b\n\ngoal (1 subgoal):\n 1. p dvd a", "by (subst (asm) prime_elem_dvd_mult_iff) auto"], ["proof (state)\nthis:\n  p dvd a\n\ngoal (1 subgoal):\n 1. p * b dvd c", "with c"], ["proof (chain)\npicking this:\n  c = a * b\n  p dvd a", "show ?thesis"], ["proof (prove)\nusing this:\n  c = a * b\n  p dvd a\n\ngoal (1 subgoal):\n 1. p * b dvd c", "by (auto intro: mult_dvd_mono)"], ["proof (state)\nthis:\n  p * b dvd c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_elem_power_mult_dvdI:\n  fixes p :: \"'a :: algebraic_semidom\"\n  assumes \"prime_elem p\" \"p ^ n dvd c\" \"b dvd c\" \"\\<not>p dvd b\"\n  shows   \"p ^ n * b dvd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n * b dvd c", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c\n 2. n \\<noteq> 0 \\<Longrightarrow> p ^ n * b dvd c", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c\n 2. n \\<noteq> 0 \\<Longrightarrow> p ^ n * b dvd c", "from assms(3)"], ["proof (chain)\npicking this:\n  b dvd c", "obtain a where c: \"c = a * b\""], ["proof (prove)\nusing this:\n  b dvd c\n\ngoal (1 subgoal):\n 1. (\\<And>a. c = a * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using mult.commute"], ["proof (prove)\nusing this:\n  b dvd c\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. (\\<And>a. c = a * b \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  c = a * b\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c\n 2. n \\<noteq> 0 \\<Longrightarrow> p ^ n * b dvd c", "with assms(2)"], ["proof (chain)\npicking this:\n  p ^ n dvd c\n  c = a * b", "have \"p ^ n dvd b * a\""], ["proof (prove)\nusing this:\n  p ^ n dvd c\n  c = a * b\n\ngoal (1 subgoal):\n 1. p ^ n dvd b * a", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  p ^ n dvd b * a\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c\n 2. n \\<noteq> 0 \\<Longrightarrow> p ^ n * b dvd c", "hence \"p ^ n dvd a\""], ["proof (prove)\nusing this:\n  p ^ n dvd b * a\n\ngoal (1 subgoal):\n 1. p ^ n dvd a", "by (rule prime_power_dvd_multD[OF assms(1)]) (use assms False in auto)"], ["proof (state)\nthis:\n  p ^ n dvd a\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c\n 2. n \\<noteq> 0 \\<Longrightarrow> p ^ n * b dvd c", "with c"], ["proof (chain)\npicking this:\n  c = a * b\n  p ^ n dvd a", "show ?thesis"], ["proof (prove)\nusing this:\n  c = a * b\n  p ^ n dvd a\n\ngoal (1 subgoal):\n 1. p ^ n * b dvd c", "by (auto intro: mult_dvd_mono)"], ["proof (state)\nthis:\n  p ^ n * b dvd c\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> p ^ n * b dvd c", "qed (use assms in auto)"], ["", "lemma prime_mod_4_cases:\n  fixes p :: nat\n  assumes \"prime p\"\n  shows   \"p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "proof (cases \"p = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "with prime_gt_1_nat[of p] assms"], ["proof (chain)\npicking this:\n  prime p \\<Longrightarrow> 1 < p\n  prime p\n  p \\<noteq> 2", "have \"p > 2\""], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> 1 < p\n  prime p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p", "by auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "have \"\\<not>4 dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 4 dvd p", "using assms product_dvd_irreducibleD[of p 2 2]"], ["proof (prove)\nusing this:\n  prime p\n  \\<lbrakk>irreducible p; 2 * 2 dvd p\\<rbrakk>\n  \\<Longrightarrow> is_unit 2 \\<or> is_unit 2\n\ngoal (1 subgoal):\n 1. \\<not> 4 dvd p", "by (auto simp: prime_elem_iff_irreducible simp flip: prime_elem_nat_iff)"], ["proof (state)\nthis:\n  \\<not> 4 dvd p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "hence \"p mod 4 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> 4 dvd p\n\ngoal (1 subgoal):\n 1. p mod 4 \\<noteq> 0", "by (auto simp: mod_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  p mod 4 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "moreover"], ["proof (state)\nthis:\n  p mod 4 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "have \"p mod 4 \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 4 \\<noteq> 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p mod 4 = 2 \\<Longrightarrow> False", "assume \"p mod 4 = 2\""], ["proof (state)\nthis:\n  p mod 4 = 2\n\ngoal (1 subgoal):\n 1. p mod 4 = 2 \\<Longrightarrow> False", "hence \"p mod 4 mod 2 = 0\""], ["proof (prove)\nusing this:\n  p mod 4 = 2\n\ngoal (1 subgoal):\n 1. p mod 4 mod 2 = 0", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  p mod 4 mod 2 = 0\n\ngoal (1 subgoal):\n 1. p mod 4 = 2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  p mod 4 mod 2 = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>prime p\\<close> \\<open>p > 2\\<close> prime_odd_nat[of p]"], ["proof (prove)\nusing this:\n  p mod 4 mod 2 = 0\n  prime p\n  2 < p\n  \\<lbrakk>prime p; 2 < p\\<rbrakk> \\<Longrightarrow> odd p\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: mod_mod_cancel)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p mod 4 \\<noteq> 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "moreover"], ["proof (state)\nthis:\n  p mod 4 \\<noteq> 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "have \"p mod 4 \\<in> {0,1,2,3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 4 \\<in> {0, 1, 2, 3}", "by auto"], ["proof (state)\nthis:\n  p mod 4 \\<in> {0, 1, 2, 3}\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n 2. p \\<noteq> 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "ultimately"], ["proof (chain)\npicking this:\n  p mod 4 \\<noteq> 0\n  p mod 4 \\<noteq> 2\n  p mod 4 \\<in> {0, 1, 2, 3}", "show ?thesis"], ["proof (prove)\nusing this:\n  p mod 4 \\<noteq> 0\n  p mod 4 \\<noteq> 2\n  p mod 4 \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. p = 2 \\<Longrightarrow>\n    p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)", "qed auto"], ["", "lemma of_nat_prod_mset: \"of_nat (prod_mset A) = prod_mset (image_mset of_nat A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (\\<Prod>\\<^sub># A) = \\<Prod>\\<^sub># (image_mset of_nat A)", "by (induction A) auto"], ["", "lemma multiplicity_0_left [simp]: \"multiplicity 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (0::'a) x = 0", "by (cases \"x = 0\") (auto simp: not_dvd_imp_multiplicity_0)"], ["", "lemma is_unit_power [intro]: \"is_unit x \\<Longrightarrow> is_unit (x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x \\<Longrightarrow> is_unit (x ^ n)", "by (subst is_unit_power_iff) auto"], ["", "lemma (in factorial_semiring) pow_divides_pow_iff:\n  assumes \"n > 0\"\n  shows   \"a ^ n dvd b ^ n \\<longleftrightarrow> a dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ^ n dvd b ^ n) = (a dvd b)", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> (a ^ n dvd b ^ n) = (a dvd b)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> (a ^ n dvd b ^ n) = (a dvd b)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. b = (0::'a) \\<Longrightarrow> (a ^ n dvd b ^ n) = (a dvd b)\n 2. b \\<noteq> (0::'a) \\<Longrightarrow> (a ^ n dvd b ^ n) = (a dvd b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a ^ n dvd b ^ n) = (a dvd b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a ^ n dvd b ^ n \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> a ^ n dvd b ^ n", "assume dvd: \"a ^ n dvd b ^ n\""], ["proof (state)\nthis:\n  a ^ n dvd b ^ n\n\ngoal (2 subgoals):\n 1. a ^ n dvd b ^ n \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> a ^ n dvd b ^ n", "with \\<open>b \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  b \\<noteq> (0::'a)\n  a ^ n dvd b ^ n", "have \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  a ^ n dvd b ^ n\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  a ^ n dvd b ^ n\n  0 < n\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by (auto simp: power_0_left)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. a ^ n dvd b ^ n \\<Longrightarrow> a dvd b\n 2. a dvd b \\<Longrightarrow> a ^ n dvd b ^ n", "show \"a dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a dvd b", "proof (rule multiplicity_le_imp_dvd)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p a \\<le> multiplicity p b", "fix p :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p a \\<le> multiplicity p b", "assume p: \"prime p\""], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p a \\<le> multiplicity p b", "from dvd \\<open>b \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  a ^ n dvd b ^ n\n  b \\<noteq> (0::'a)", "have \"multiplicity p (a ^ n) \\<le> multiplicity p (b ^ n)\""], ["proof (prove)\nusing this:\n  a ^ n dvd b ^ n\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multiplicity p (a ^ n) \\<le> multiplicity p (b ^ n)", "by (intro dvd_imp_multiplicity_le) auto"], ["proof (state)\nthis:\n  multiplicity p (a ^ n) \\<le> multiplicity p (b ^ n)\n\ngoal (2 subgoals):\n 1. a \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p a \\<le> multiplicity p b", "thus \"multiplicity p a \\<le> multiplicity p b\""], ["proof (prove)\nusing this:\n  multiplicity p (a ^ n) \\<le> multiplicity p (b ^ n)\n\ngoal (1 subgoal):\n 1. multiplicity p a \\<le> multiplicity p b", "using p \\<open>a \\<noteq> 0\\<close> \\<open>b \\<noteq> 0\\<close> \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  multiplicity p (a ^ n) \\<le> multiplicity p (b ^ n)\n  prime p\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  0 < n\n\ngoal (1 subgoal):\n 1. multiplicity p a \\<le> multiplicity p b", "by (simp add: prime_elem_multiplicity_power_distrib)"], ["proof (state)\nthis:\n  multiplicity p a \\<le> multiplicity p b\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "qed fact+"], ["proof (state)\nthis:\n  a dvd b\n\ngoal (1 subgoal):\n 1. a dvd b \\<Longrightarrow> a ^ n dvd b ^ n", "qed (auto intro: dvd_power_same)"], ["proof (state)\nthis:\n  (a ^ n dvd b ^ n) = (a dvd b)\n\ngoal (1 subgoal):\n 1. b = (0::'a) \\<Longrightarrow> (a ^ n dvd b ^ n) = (a dvd b)", "qed (use assms in \\<open>auto simp: power_0_left\\<close>)"], ["", "lemma multiplicity_power_power:\n  fixes p :: \"'a :: {factorial_semiring, algebraic_semidom}\"\n  assumes \"n > 0\"\n  shows   \"multiplicity (p ^ n) (x ^ n) = multiplicity p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (p ^ n) (x ^ n) = multiplicity p x", "proof (cases \"x = 0 \\<or> p = 0 \\<or> is_unit p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x\n 2. \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p) \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x", "case True"], ["proof (state)\nthis:\n  x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x\n 2. \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p) \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p\n\ngoal (1 subgoal):\n 1. multiplicity (p ^ n) (x ^ n) = multiplicity p x", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p\n  0 < n\n\ngoal (1 subgoal):\n 1. multiplicity (p ^ n) (x ^ n) = multiplicity p x", "by (auto simp: power_0_left is_unit_power_iff multiplicity_unit_left)"], ["proof (state)\nthis:\n  multiplicity (p ^ n) (x ^ n) = multiplicity p x\n\ngoal (1 subgoal):\n 1. \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p) \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p) \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x", "case False"], ["proof (state)\nthis:\n  \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p)\n\ngoal (1 subgoal):\n 1. \\<not> (x = (0::'a) \\<or> p = (0::'a) \\<or> is_unit p) \\<Longrightarrow>\n    multiplicity (p ^ n) (x ^ n) = multiplicity p x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (p ^ n) (x ^ n) = multiplicity p x", "proof (intro antisym multiplicity_geI)"], ["proof (state)\ngoal (6 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)\n 6. (p ^ n) ^ multiplicity p x dvd x ^ n", "have \"(p ^ multiplicity p x) ^ n dvd x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ^ multiplicity p x) ^ n dvd x ^ n", "by (intro dvd_power_same) (simp add: multiplicity_dvd)"], ["proof (state)\nthis:\n  (p ^ multiplicity p x) ^ n dvd x ^ n\n\ngoal (6 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)\n 6. (p ^ n) ^ multiplicity p x dvd x ^ n", "thus \"(p ^ n) ^ multiplicity p x dvd x ^ n\""], ["proof (prove)\nusing this:\n  (p ^ multiplicity p x) ^ n dvd x ^ n\n\ngoal (1 subgoal):\n 1. (p ^ n) ^ multiplicity p x dvd x ^ n", "by (simp add: mult_ac flip: power_mult)"], ["proof (state)\nthis:\n  (p ^ n) ^ multiplicity p x dvd x ^ n\n\ngoal (5 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)", "have \"(p ^ n) ^ multiplicity (p ^ n) (x ^ n) dvd x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ^ n) ^ multiplicity (p ^ n) (x ^ n) dvd x ^ n", "by (simp add: multiplicity_dvd)"], ["proof (state)\nthis:\n  (p ^ n) ^ multiplicity (p ^ n) (x ^ n) dvd x ^ n\n\ngoal (5 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)", "hence \"(p ^ multiplicity (p ^ n) (x ^ n)) ^ n dvd x ^ n\""], ["proof (prove)\nusing this:\n  (p ^ n) ^ multiplicity (p ^ n) (x ^ n) dvd x ^ n\n\ngoal (1 subgoal):\n 1. (p ^ multiplicity (p ^ n) (x ^ n)) ^ n dvd x ^ n", "by (simp add: mult_ac flip: power_mult)"], ["proof (state)\nthis:\n  (p ^ multiplicity (p ^ n) (x ^ n)) ^ n dvd x ^ n\n\ngoal (5 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. p ^ multiplicity (p ^ n) (x ^ n) dvd x\n 4. x ^ n \\<noteq> (0::'a)\n 5. \\<not> is_unit (p ^ n)", "thus \"p ^ multiplicity (p ^ n) (x ^ n) dvd x\""], ["proof (prove)\nusing this:\n  (p ^ multiplicity (p ^ n) (x ^ n)) ^ n dvd x ^ n\n\ngoal (1 subgoal):\n 1. p ^ multiplicity (p ^ n) (x ^ n) dvd x", "by (subst (asm) pow_divides_pow_iff) (use assms in auto)"], ["proof (state)\nthis:\n  p ^ multiplicity (p ^ n) (x ^ n) dvd x\n\ngoal (4 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<not> is_unit p\n 3. x ^ n \\<noteq> (0::'a)\n 4. \\<not> is_unit (p ^ n)", "qed (use False \\<open>n > 0\\<close> in \\<open>auto simp: is_unit_power_iff\\<close>)"], ["proof (state)\nthis:\n  multiplicity (p ^ n) (x ^ n) = multiplicity p x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_square_cong_4_int:\n  fixes x :: int\n  assumes \"even x\"\n  shows   \"[x ^ 2 = 0] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "from assms"], ["proof (chain)\npicking this:\n  even x", "have \"even \\<bar>x\\<bar>\""], ["proof (prove)\nusing this:\n  even x\n\ngoal (1 subgoal):\n 1. even \\<bar>x\\<bar>", "by simp"], ["proof (state)\nthis:\n  even \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "hence [simp]: \"\\<bar>x\\<bar> mod 2 = 0\""], ["proof (prove)\nusing this:\n  even \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 2 = 0", "by presburger"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> mod 2 = 0\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "have \"(\\<bar>x\\<bar> ^ 2) mod 4 = ((\\<bar>x\\<bar> mod 4) ^ 2) mod 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4", "by (simp add: power_mod)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "from assms"], ["proof (chain)\npicking this:\n  even x", "have \"\\<bar>x\\<bar> mod 4 = 0 \\<or> \\<bar>x\\<bar> mod 4 = 2\""], ["proof (prove)\nusing this:\n  even x\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 4 = 0 \\<or> \\<bar>x\\<bar> mod 4 = 2", "using mod_double_modulus[of 2 \"\\<bar>x\\<bar>\"]"], ["proof (prove)\nusing this:\n  even x\n  \\<lbrakk>0 < 2; 0 \\<le> \\<bar>x\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>x\\<bar> mod (2 * 2) = \\<bar>x\\<bar> mod 2 \\<or>\n                    \\<bar>x\\<bar> mod (2 * 2) = \\<bar>x\\<bar> mod 2 + 2\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 4 = 0 \\<or> \\<bar>x\\<bar> mod 4 = 2", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> mod 4 = 0 \\<or> \\<bar>x\\<bar> mod 4 = 2\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "hence \"((\\<bar>x\\<bar> mod 4) ^ 2) mod 4 = 0\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> mod 4 = 0 \\<or> \\<bar>x\\<bar> mod 4 = 2\n\ngoal (1 subgoal):\n 1. (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4 = 0", "by auto"], ["proof (state)\nthis:\n  (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4 = 0\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = 0\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 0] (mod 4)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x\\<^sup>2 = 0] (mod 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma even_square_cong_4_nat: \"even (x::nat) \\<Longrightarrow> [x ^ 2 = 0] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even x \\<Longrightarrow> [x\\<^sup>2 = 0] (mod 4)", "using even_square_cong_4_int[of \"int x\"]"], ["proof (prove)\nusing this:\n  even (int x) \\<Longrightarrow> [(int x)\\<^sup>2 = 0] (mod 4)\n\ngoal (1 subgoal):\n 1. even x \\<Longrightarrow> [x\\<^sup>2 = 0] (mod 4)", "by (auto simp flip: cong_int_iff)"], ["", "lemma odd_square_cong_4_int:\n  fixes x :: int\n  assumes \"odd x\"\n  shows   \"[x ^ 2 = 1] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "from assms"], ["proof (chain)\npicking this:\n  odd x", "have \"odd \\<bar>x\\<bar>\""], ["proof (prove)\nusing this:\n  odd x\n\ngoal (1 subgoal):\n 1. odd \\<bar>x\\<bar>", "by simp"], ["proof (state)\nthis:\n  odd \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "hence [simp]: \"\\<bar>x\\<bar> mod 2 = 1\""], ["proof (prove)\nusing this:\n  odd \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 2 = 1", "by presburger"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> mod 2 = 1\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "have \"(\\<bar>x\\<bar> ^ 2) mod 4 = ((\\<bar>x\\<bar> mod 4) ^ 2) mod 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4", "by (simp add: power_mod)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "also"], ["proof (state)\nthis:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "from assms"], ["proof (chain)\npicking this:\n  odd x", "have \"\\<bar>x\\<bar> mod 4 = 1 \\<or> \\<bar>x\\<bar> mod 4 = 3\""], ["proof (prove)\nusing this:\n  odd x\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 4 = 1 \\<or> \\<bar>x\\<bar> mod 4 = 3", "using mod_double_modulus[of 2 \"\\<bar>x\\<bar>\"]"], ["proof (prove)\nusing this:\n  odd x\n  \\<lbrakk>0 < 2; 0 \\<le> \\<bar>x\\<bar>\\<rbrakk>\n  \\<Longrightarrow> \\<bar>x\\<bar> mod (2 * 2) = \\<bar>x\\<bar> mod 2 \\<or>\n                    \\<bar>x\\<bar> mod (2 * 2) = \\<bar>x\\<bar> mod 2 + 2\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> mod 4 = 1 \\<or> \\<bar>x\\<bar> mod 4 = 3", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> mod 4 = 1 \\<or> \\<bar>x\\<bar> mod 4 = 3\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "hence \"((\\<bar>x\\<bar> mod 4) ^ 2) mod 4 = 1\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> mod 4 = 1 \\<or> \\<bar>x\\<bar> mod 4 = 3\n\ngoal (1 subgoal):\n 1. (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4 = 1", "by auto"], ["proof (state)\nthis:\n  (\\<bar>x\\<bar> mod 4)\\<^sup>2 mod 4 = 1\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar>\\<^sup>2 mod 4 = 1\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 = 1] (mod 4)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x\\<^sup>2 = 1] (mod 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odd_square_cong_4_nat: \"odd (x::nat) \\<Longrightarrow> [x ^ 2 = 1] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd x \\<Longrightarrow> [x\\<^sup>2 = 1] (mod 4)", "using odd_square_cong_4_int[of \"int x\"]"], ["proof (prove)\nusing this:\n  odd (int x) \\<Longrightarrow> [(int x)\\<^sup>2 = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. odd x \\<Longrightarrow> [x\\<^sup>2 = 1] (mod 4)", "by (auto simp flip: cong_int_iff)"], ["", "text \\<open>\n  Gaussian integers will require a notion of an element being a power up to a unit,\n  so we introduce this here. This should go in the library eventually.\n\\<close>"], ["", "definition is_nth_power_upto_unit where\n  \"is_nth_power_upto_unit n x \\<longleftrightarrow> (\\<exists>u. is_unit u \\<and> is_nth_power n (u * x))\""], ["", "lemma is_nth_power_upto_unit_base: \"is_nth_power n x \\<Longrightarrow> is_nth_power_upto_unit n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power n x \\<Longrightarrow> is_nth_power_upto_unit n x", "by (auto simp: is_nth_power_upto_unit_def intro: exI[of _ 1])"], ["", "lemma is_nth_power_upto_unitI:\n  assumes \"normalize (x ^ n) = normalize y\"\n  shows   \"is_nth_power_upto_unit n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "from associatedE1[OF assms]"], ["proof (chain)\npicking this:\n  (\\<And>u.\n      \\<lbrakk>is_unit u; x ^ n = u * y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain u where \"is_unit u\" \"u * y = x ^ n\""], ["proof (prove)\nusing this:\n  (\\<And>u.\n      \\<lbrakk>is_unit u; x ^ n = u * y\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; u * y = x ^ n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  is_unit u\n  u * y = x ^ n\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_unit u\n  u * y = x ^ n\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "by (auto simp: is_nth_power_upto_unit_def intro!: exI[of _ u])"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_nth_power_upto_unit_conv_multiplicity: \n  fixes x :: \"'a :: factorial_semiring\"\n  assumes \"n > 0\"\n  shows   \"is_nth_power_upto_unit n x \\<longleftrightarrow> (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "fix p :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "assume p: \"prime p\""], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "assume \"is_nth_power_upto_unit n x\""], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "then"], ["proof (chain)\npicking this:\n  is_nth_power_upto_unit n x", "obtain u y where uy: \"is_unit u\" \"u * x = y ^ n\""], ["proof (prove)\nusing this:\n  is_nth_power_upto_unit n x\n\ngoal (1 subgoal):\n 1. (\\<And>u y.\n        \\<lbrakk>is_unit u; u * x = y ^ n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: is_nth_power_upto_unit_def elim!: is_nth_powerE)"], ["proof (state)\nthis:\n  is_unit u\n  u * x = y ^ n\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "from p uy assms False"], ["proof (chain)\npicking this:\n  prime p\n  is_unit u\n  u * x = y ^ n\n  0 < n\n  x \\<noteq> (0::'a)", "have [simp]: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime p\n  is_unit u\n  u * x = y ^ n\n  0 < n\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a)", "by (auto simp: power_0_left)"], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "have \"multiplicity p (u * x) = multiplicity p (y ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (u * x) = multiplicity p (y ^ n)", "by (subst uy(2) [symmetric]) simp"], ["proof (state)\nthis:\n  multiplicity p (u * x) = multiplicity p (y ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "also"], ["proof (state)\nthis:\n  multiplicity p (u * x) = multiplicity p (y ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "have \"multiplicity p (u * x) = multiplicity p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (u * x) = multiplicity p x", "by (simp add: multiplicity_times_unit_right uy(1))"], ["proof (state)\nthis:\n  multiplicity p (u * x) = multiplicity p x\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>is_nth_power_upto_unit n x; prime p\\<rbrakk>\n       \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "finally"], ["proof (chain)\npicking this:\n  multiplicity p x = multiplicity p (y ^ n)", "show \"n dvd multiplicity p x\""], ["proof (prove)\nusing this:\n  multiplicity p x = multiplicity p (y ^ n)\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "using False and p and uy and assms"], ["proof (prove)\nusing this:\n  multiplicity p x = multiplicity p (y ^ n)\n  x \\<noteq> (0::'a)\n  prime p\n  is_unit u\n  u * x = y ^ n\n  0 < n\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "by (auto simp: prime_elem_multiplicity_power_distrib)"], ["proof (state)\nthis:\n  n dvd multiplicity p x\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "assume *: \"\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\""], ["proof (state)\nthis:\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "have \"multiplicity p ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) = \n            multiplicity p x\" if \"prime p\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    multiplicity p x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity p\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    multiplicity p x", "from that and *"], ["proof (chain)\npicking this:\n  prime p\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x", "have \"n dvd multiplicity p x\""], ["proof (prove)\nusing this:\n  prime p\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "by blast"], ["proof (state)\nthis:\n  n dvd multiplicity p x\n\ngoal (1 subgoal):\n 1. multiplicity p\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    multiplicity p x", "have \"multiplicity p x = 0\" if \"p \\<notin> prime_factors x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p x = 0", "using that and \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  p \\<notin> prime_factors x\n  prime p\n\ngoal (1 subgoal):\n 1. multiplicity p x = 0", "by (simp add: prime_factors_multiplicity)"], ["proof (state)\nthis:\n  p \\<notin> prime_factors x \\<Longrightarrow> multiplicity p x = 0\n\ngoal (1 subgoal):\n 1. multiplicity p\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    multiplicity p x", "with that and * and assms"], ["proof (chain)\npicking this:\n  prime p\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\n  0 < n\n  p \\<notin> prime_factors x \\<Longrightarrow> multiplicity p x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  prime p\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\n  0 < n\n  p \\<notin> prime_factors x \\<Longrightarrow> multiplicity p x = 0\n\ngoal (1 subgoal):\n 1. multiplicity p\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    multiplicity p x", "unfolding prod_power_distrib power_mult [symmetric]"], ["proof (prove)\nusing this:\n  prime p\n  \\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x\n  0 < n\n  p \\<notin> prime_factors x \\<Longrightarrow> multiplicity p x = 0\n\ngoal (1 subgoal):\n 1. multiplicity p\n     (\\<Prod>xa\\<in>prime_factors x. xa ^ (multiplicity xa x div n * n)) =\n    multiplicity p x", "by (subst multiplicity_prod_prime_powers) (auto simp: in_prime_factors_imp_prime elim: dvdE)"], ["proof (state)\nthis:\n  multiplicity p\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  multiplicity p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime ?p \\<Longrightarrow>\n  multiplicity ?p\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  multiplicity ?p x\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "with assms False"], ["proof (chain)\npicking this:\n  0 < n\n  x \\<noteq> (0::'a)\n  prime ?p \\<Longrightarrow>\n  multiplicity ?p\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  multiplicity ?p x", "have \"normalize ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) = normalize x\""], ["proof (prove)\nusing this:\n  0 < n\n  x \\<noteq> (0::'a)\n  prime ?p \\<Longrightarrow>\n  multiplicity ?p\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  multiplicity ?p x\n\ngoal (1 subgoal):\n 1. normalize\n     ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n    normalize x", "by (intro multiplicity_eq_imp_eq) (auto simp: multiplicity_prod_prime_powers)"], ["proof (state)\nthis:\n  normalize\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  normalize x\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       prime p \\<longrightarrow> n dvd multiplicity p x \\<Longrightarrow>\n    is_nth_power_upto_unit n x", "thus \"is_nth_power_upto_unit n x\""], ["proof (prove)\nusing this:\n  normalize\n   ((\\<Prod>p\\<in>prime_factors x. p ^ (multiplicity p x div n)) ^ n) =\n  normalize x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "by (auto intro: is_nth_power_upto_unitI)"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x =\n  (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)\n\ngoal (1 subgoal):\n 1. x = (0::'a) \\<Longrightarrow>\n    is_nth_power_upto_unit n x =\n    (\\<forall>p. prime p \\<longrightarrow> n dvd multiplicity p x)", "qed (use assms in \\<open>auto simp: is_nth_power_upto_unit_def\\<close>)"], ["", "lemma is_nth_power_upto_unit_0_left [simp, intro]: \"is_nth_power_upto_unit 0 x \\<longleftrightarrow> is_unit x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x = is_unit x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x\n 2. is_unit x \\<Longrightarrow> is_nth_power_upto_unit 0 x", "assume \"is_unit x\""], ["proof (state)\nthis:\n  is_unit x\n\ngoal (2 subgoals):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x\n 2. is_unit x \\<Longrightarrow> is_nth_power_upto_unit 0 x", "thus \"is_nth_power_upto_unit 0 x\""], ["proof (prove)\nusing this:\n  is_unit x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x", "unfolding is_nth_power_upto_unit_def"], ["proof (prove)\nusing this:\n  is_unit x\n\ngoal (1 subgoal):\n 1. \\<exists>u. is_unit u \\<and> is_nth_power 0 (u * x)", "by (intro exI[of _ \"1 div x\"]) auto"], ["proof (state)\nthis:\n  is_nth_power_upto_unit 0 x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x", "assume \"is_nth_power_upto_unit 0 x\""], ["proof (state)\nthis:\n  is_nth_power_upto_unit 0 x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x", "then"], ["proof (chain)\npicking this:\n  is_nth_power_upto_unit 0 x", "obtain u where \"is_unit u\" \"u * x = 1\""], ["proof (prove)\nusing this:\n  is_nth_power_upto_unit 0 x\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; u * x = (1::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: is_nth_power_upto_unit_def)"], ["proof (state)\nthis:\n  is_unit u\n  u * x = (1::'a)\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 0 x \\<Longrightarrow> is_unit x", "thus \"is_unit x\""], ["proof (prove)\nusing this:\n  is_unit u\n  u * x = (1::'a)\n\ngoal (1 subgoal):\n 1. is_unit x", "by (metis dvd_triv_right)"], ["proof (state)\nthis:\n  is_unit x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_nth_power_upto_unit_unit [simp, intro]:\n  assumes \"is_unit x\"\n  shows   \"is_nth_power_upto_unit n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "using assms"], ["proof (prove)\nusing this:\n  is_unit x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "by (auto simp: is_nth_power_upto_unit_def intro!: exI[of _ \"1 div x\"])"], ["", "lemma is_nth_power_upto_unit_1_left [simp, intro]: \"is_nth_power_upto_unit 1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit 1 x", "by (auto simp: is_nth_power_upto_unit_def intro: exI[of _ 1])"], ["", "lemma is_nth_power_upto_unit_mult_coprimeD1:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"coprime x y\" \"is_nth_power_upto_unit n (x * y)\"\n  shows   \"is_nth_power_upto_unit n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "consider \"n = 0\" | \"x = 0\" \"n > 0\" | \"x \\<noteq> 0\" \"y = 0\" \"n > 0\" | \"n > 0\" \"x \\<noteq> 0\" \"y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. n = 0 \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 4. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "assume [simp]: \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (4 subgoals):\n 1. n = 0 \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 4. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "from assms"], ["proof (chain)\npicking this:\n  coprime x y\n  is_nth_power_upto_unit n (x * y)", "have \"is_unit (x * y)\""], ["proof (prove)\nusing this:\n  coprime x y\n  is_nth_power_upto_unit n (x * y)\n\ngoal (1 subgoal):\n 1. is_unit (x * y)", "by auto"], ["proof (state)\nthis:\n  is_unit (x * y)\n\ngoal (4 subgoals):\n 1. n = 0 \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 4. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "hence \"is_unit x\""], ["proof (prove)\nusing this:\n  is_unit (x * y)\n\ngoal (1 subgoal):\n 1. is_unit x", "using is_unit_mult_iff"], ["proof (prove)\nusing this:\n  is_unit (x * y)\n  is_unit (?a * ?b) = (is_unit ?a \\<and> is_unit ?b)\n\ngoal (1 subgoal):\n 1. is_unit x", "by blast"], ["proof (state)\nthis:\n  is_unit x\n\ngoal (4 subgoals):\n 1. n = 0 \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 4. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_unit x\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "using assms"], ["proof (prove)\nusing this:\n  is_unit x\n  coprime x y\n  is_nth_power_upto_unit n (x * y)\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "by auto"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "assume \"x = 0\" \"n > 0\""], ["proof (state)\nthis:\n  x = (0::'a)\n  0 < n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 3. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = (0::'a)\n  0 < n\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "by (auto simp: is_nth_power_upto_unit_def)"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "assume *: \"x \\<noteq> 0\" \"y = 0\" \"n > 0\""], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n  y = (0::'a)\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y = (0::'a); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x\n 2. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "with assms"], ["proof (chain)\npicking this:\n  coprime x y\n  is_nth_power_upto_unit n (x * y)\n  x \\<noteq> (0::'a)\n  y = (0::'a)\n  0 < n", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime x y\n  is_nth_power_upto_unit n (x * y)\n  x \\<noteq> (0::'a)\n  y = (0::'a)\n  0 < n\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "by auto"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "assume *: \"n > 0\" and [simp]: \"x \\<noteq> 0\" \"y \\<noteq> 0\""], ["proof (state)\nthis:\n  0 < n\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; x \\<noteq> (0::'a); y \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> is_nth_power_upto_unit n x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n x", "proof (subst is_nth_power_upto_unit_conv_multiplicity[OF \\<open>n > 0\\<close>]; safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. prime p \\<Longrightarrow> n dvd multiplicity p x", "fix p :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. prime p \\<Longrightarrow> n dvd multiplicity p x", "assume p: \"prime p\""], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>p. prime p \\<Longrightarrow> n dvd multiplicity p x", "show \"n dvd multiplicity p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "proof (cases \"p dvd x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<not> p dvd x \\<Longrightarrow> n dvd multiplicity p x", "case False"], ["proof (state)\nthis:\n  \\<not> p dvd x\n\ngoal (2 subgoals):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x\n 2. \\<not> p dvd x \\<Longrightarrow> n dvd multiplicity p x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> p dvd x\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "by (simp add: not_dvd_imp_multiplicity_0)"], ["proof (state)\nthis:\n  n dvd multiplicity p x\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "case True"], ["proof (state)\nthis:\n  p dvd x\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "have \"n dvd multiplicity p (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd multiplicity p (x * y)", "using assms(2) \\<open>n > 0\\<close> p"], ["proof (prove)\nusing this:\n  is_nth_power_upto_unit n (x * y)\n  0 < n\n  prime p\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p (x * y)", "by (auto simp: is_nth_power_upto_unit_conv_multiplicity)"], ["proof (state)\nthis:\n  n dvd multiplicity p (x * y)\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "also"], ["proof (state)\nthis:\n  n dvd multiplicity p (x * y)\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "have \"\\<dots> = multiplicity p x + multiplicity p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (x * y) = multiplicity p x + multiplicity p y", "using p"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. multiplicity p (x * y) = multiplicity p x + multiplicity p y", "by (subst prime_elem_multiplicity_mult_distrib) auto"], ["proof (state)\nthis:\n  multiplicity p (x * y) = multiplicity p x + multiplicity p y\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "also"], ["proof (state)\nthis:\n  multiplicity p (x * y) = multiplicity p x + multiplicity p y\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "have \"\\<not>p dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd y", "using \\<open>coprime x y\\<close> \\<open>p dvd x\\<close> p not_prime_unit coprime_common_divisor"], ["proof (prove)\nusing this:\n  coprime x y\n  p dvd x\n  prime p\n  is_unit ?x \\<Longrightarrow> \\<not> prime ?x\n  \\<lbrakk>coprime ?a ?b; ?c dvd ?a; ?c dvd ?b\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c\n\ngoal (1 subgoal):\n 1. \\<not> p dvd y", "by blast"], ["proof (state)\nthis:\n  \\<not> p dvd y\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "hence \"multiplicity p y = 0\""], ["proof (prove)\nusing this:\n  \\<not> p dvd y\n\ngoal (1 subgoal):\n 1. multiplicity p y = 0", "by (rule not_dvd_imp_multiplicity_0)"], ["proof (state)\nthis:\n  multiplicity p y = 0\n\ngoal (1 subgoal):\n 1. p dvd x \\<Longrightarrow> n dvd multiplicity p x", "finally"], ["proof (chain)\npicking this:\n  n dvd multiplicity p x + 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n dvd multiplicity p x + 0\n\ngoal (1 subgoal):\n 1. n dvd multiplicity p x", "by simp"], ["proof (state)\nthis:\n  n dvd multiplicity p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n dvd multiplicity p x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_nth_power_upto_unit n x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_nth_power_upto_unit_mult_coprimeD2:\n  fixes x y :: \"'a :: factorial_semiring\"\n  assumes \"coprime x y\" \"is_nth_power_upto_unit n (x * y)\"\n  shows   \"is_nth_power_upto_unit n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "using assms is_nth_power_upto_unit_mult_coprimeD1[of y x]"], ["proof (prove)\nusing this:\n  coprime x y\n  is_nth_power_upto_unit n (x * y)\n  \\<lbrakk>coprime y x; is_nth_power_upto_unit ?n (y * x)\\<rbrakk>\n  \\<Longrightarrow> is_nth_power_upto_unit ?n y\n\ngoal (1 subgoal):\n 1. is_nth_power_upto_unit n y", "by (simp_all add: mult_ac coprime_commute)"], ["", "subsection \\<open>Definition\\<close>"], ["", "text \\<open>\n  Gaussian integers are the ring $\\mathbb{Z}[i]$ which is formed either by formally adjoining\n  an element $i$ with $i^2 = -1$ to $\\mathbb{Z}$ or by taking all the complex numbers with\n  integer real and imaginary part.\n\n  We define them simply by giving an appropriate ring structure to $\\mathbb{Z}^2$, with the first\n  component representing the real part and the second component the imaginary part:\n\\<close>"], ["", "codatatype gauss_int = Gauss_Int (ReZ: int) (ImZ: int)"], ["", "text \\<open>\n  The following is the imaginary unit $i$ in the Gaussian integers, which we will denote as\n  \\<open>\\<i>\\<^sub>\\<int>\\<close>:\n\\<close>"], ["", "primcorec gauss_i where\n  \"ReZ gauss_i = 0\"\n| \"ImZ gauss_i = 1\""], ["", "lemma gauss_int_eq_iff: \"x = y \\<longleftrightarrow> ReZ x = ReZ y \\<and> ImZ x = ImZ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (ReZ x = ReZ y \\<and> ImZ x = ImZ y)", "by (cases x; cases y) auto"], ["", "(*<*)"], ["", "bundle gauss_int_notation\nbegin"], ["", "notation gauss_i (\"\\<i>\\<^sub>\\<int>\")"], ["", "end"], ["", "bundle no_gauss_int_notation\nbegin"], ["", "no_notation (output) gauss_i (\"\\<i>\\<^sub>\\<int>\")"], ["", "end"], ["", "bundle gauss_int_output_notation\nbegin"], ["", "notation (output) gauss_i (\"\\<ii>\")"], ["", "end"], ["", "unbundle gauss_int_notation"], ["", "(*>*)"], ["", "text \\<open>\n  Next, we define the canonical injective homomorphism from the Gaussian integers into the\n  complex numbers:\n\\<close>"], ["", "primcorec gauss2complex where\n  \"Re (gauss2complex z) = of_int (ReZ z)\"\n| \"Im (gauss2complex z) = of_int (ImZ z)\""], ["", "declare [[coercion gauss2complex]]"], ["", "lemma gauss2complex_eq_iff [simp]: \"gauss2complex z = gauss2complex u \\<longleftrightarrow> z = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss2complex z = gauss2complex u) = (z = u)", "by (simp add: complex_eq_iff gauss_int_eq_iff)"], ["", "text \\<open>\n  Gaussian integers also have conjugates, just like complex numbers:\n\\<close>"], ["", "primcorec gauss_cnj where\n  \"ReZ (gauss_cnj z) = ReZ z\"\n| \"ImZ (gauss_cnj z) = -ImZ z\""], ["", "text \\<open>\n  In the remainder of this section, we prove that Gaussian integers are a commutative ring\n  of characteristic 0 and several other trivial algebraic properties.\n\\<close>"], ["", "instantiation gauss_int :: comm_ring_1\nbegin"], ["", "primcorec zero_gauss_int where\n  \"ReZ zero_gauss_int = 0\"\n| \"ImZ zero_gauss_int = 0\""], ["", "primcorec one_gauss_int where\n  \"ReZ one_gauss_int = 1\"\n| \"ImZ one_gauss_int = 0\""], ["", "primcorec uminus_gauss_int where\n  \"ReZ (uminus_gauss_int x) = -ReZ x\"\n| \"ImZ (uminus_gauss_int x) = -ImZ x\""], ["", "primcorec plus_gauss_int where\n  \"ReZ (plus_gauss_int x y) = ReZ x + ReZ y\"\n| \"ImZ (plus_gauss_int x y) = ImZ x + ImZ y\""], ["", "primcorec minus_gauss_int where\n  \"ReZ (minus_gauss_int x y) = ReZ x - ReZ y\"\n| \"ImZ (minus_gauss_int x y) = ImZ x - ImZ y\""], ["", "primcorec times_gauss_int where\n  \"ReZ (times_gauss_int x y) = ReZ x * ReZ y - ImZ x * ImZ y\"\n| \"ImZ (times_gauss_int x y) = ReZ x * ImZ y + ImZ x * ReZ y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, comm_ring_1_class)", "by intro_classes (auto simp: gauss_int_eq_iff algebra_simps)"], ["", "end"], ["", "lemma gauss_i_times_i [simp]: \"\\<i>\\<^sub>\\<int> * \\<i>\\<^sub>\\<int> = (-1 :: gauss_int)\"\n  and gauss_cnj_i [simp]: \"gauss_cnj \\<i>\\<^sub>\\<int> = -\\<i>\\<^sub>\\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i>\\<^sub>\\<int> * \\<i>\\<^sub>\\<int> = - 1 &&&\n    gauss_cnj \\<i>\\<^sub>\\<int> = - \\<i>\\<^sub>\\<int>", "by (simp_all add: gauss_int_eq_iff)"], ["", "lemma gauss_cnj_eq_0_iff [simp]: \"gauss_cnj z = 0 \\<longleftrightarrow> z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_cnj z = 0) = (z = 0)", "by (auto simp: gauss_int_eq_iff)"], ["", "lemma gauss_cnj_eq_self: \"Im z = 0 \\<Longrightarrow> gauss_cnj z = z\"\n  and gauss_cnj_eq_minus_self: \"Re z = 0 \\<Longrightarrow> gauss_cnj z = -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im (gauss2complex z) = 0 \\<Longrightarrow> gauss_cnj z = z) &&&\n    (Re (gauss2complex z) = 0 \\<Longrightarrow> gauss_cnj z = - z)", "by (auto simp: gauss_int_eq_iff)"], ["", "lemma ReZ_of_nat [simp]: \"ReZ (of_nat n) = of_nat n\"\n  and ImZ_of_nat [simp]: \"ImZ (of_nat n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (of_nat n) = int n &&& ImZ (of_nat n) = 0", "by (induction n; simp)+"], ["", "lemma ReZ_of_int [simp]: \"ReZ (of_int n) = n\"\n  and ImZ_of_int [simp]: \"ImZ (of_int n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (of_int n) = n &&& ImZ (of_int n) = 0", "by (induction n; simp)+"], ["", "lemma ReZ_numeral [simp]: \"ReZ (numeral n) = numeral n\"\n  and ImZ_numeral [simp]: \"ImZ (numeral n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (numeral n) = numeral n &&& ImZ (numeral n) = 0", "by (subst of_nat_numeral [symmetric], subst ReZ_of_nat ImZ_of_nat, simp)+"], ["", "lemma gauss2complex_0 [simp]: \"gauss2complex 0 = 0\"\n  and gauss2complex_1 [simp]: \"gauss2complex 1 = 1\"\n  and gauss2complex_i [simp]: \"gauss2complex \\<i>\\<^sub>\\<int> = \\<i>\"\n  and gauss2complex_add [simp]: \"gauss2complex (x + y) = gauss2complex x + gauss2complex y\"\n  and gauss2complex_diff [simp]: \"gauss2complex (x - y) = gauss2complex x - gauss2complex y\"\n  and gauss2complex_mult [simp]: \"gauss2complex (x * y) = gauss2complex x * gauss2complex y\"\n  and gauss2complex_uminus [simp]: \"gauss2complex (-x) = -gauss2complex x\"\n  and gauss2complex_cnj [simp]: \"gauss2complex (gauss_cnj x) = cnj (gauss2complex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gauss2complex 0 = 0 &&& gauss2complex 1 = 1) &&&\n     gauss2complex \\<i>\\<^sub>\\<int> = \\<i> &&&\n     gauss2complex (x + y) = gauss2complex x + gauss2complex y) &&&\n    (gauss2complex (x - y) = gauss2complex x - gauss2complex y &&&\n     gauss2complex (x * y) = gauss2complex x * gauss2complex y) &&&\n    gauss2complex (- x) = - gauss2complex x &&&\n    gauss2complex (gauss_cnj x) = cnj (gauss2complex x)", "by (simp_all add: complex_eq_iff)"], ["", "lemma gauss2complex_of_nat [simp]: \"gauss2complex (of_nat n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss2complex (of_nat n) = of_nat n", "by (simp add: complex_eq_iff)"], ["", "lemma gauss2complex_eq_0_iff [simp]: \"gauss2complex x = 0 \\<longleftrightarrow> x = 0\"\n  and gauss2complex_eq_1_iff [simp]: \"gauss2complex x = 1 \\<longleftrightarrow> x = 1\"\n  and zero_eq_gauss2complex_iff [simp]: \"0 = gauss2complex x \\<longleftrightarrow> x = 0\"\n  and one_eq_gauss2complex_iff [simp]: \"1 = gauss2complex x \\<longleftrightarrow> x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gauss2complex x = 0) = (x = 0) &&&\n     (gauss2complex x = 1) = (x = 1)) &&&\n    (0 = gauss2complex x) = (x = 0) &&& (1 = gauss2complex x) = (x = 1)", "by (simp_all add: complex_eq_iff gauss_int_eq_iff)"], ["", "lemma gauss_i_times_gauss_i_times [simp]: \"\\<i>\\<^sub>\\<int> * (\\<i>\\<^sub>\\<int> * x) = (-x :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i>\\<^sub>\\<int> * (\\<i>\\<^sub>\\<int> * x) = - x", "by (subst mult.assoc [symmetric], subst gauss_i_times_i) auto"], ["", "lemma gauss_i_neq_0 [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> 0\" \"0 \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_1 [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> 1\" \"1 \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_of_nat [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> of_nat n\" \"of_nat n \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_of_int [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> of_int n\" \"of_int n \\<noteq> \\<i>\\<^sub>\\<int>\"\n  and gauss_i_neq_numeral [simp]: \"\\<i>\\<^sub>\\<int> \\<noteq> numeral m\" \"numeral m \\<noteq> \\<i>\\<^sub>\\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<i>\\<^sub>\\<int> \\<noteq> 0 &&& 0 \\<noteq> \\<i>\\<^sub>\\<int>) &&&\n     \\<i>\\<^sub>\\<int> \\<noteq> 1 &&& 1 \\<noteq> \\<i>\\<^sub>\\<int>) &&&\n    (\\<i>\\<^sub>\\<int> \\<noteq> of_nat n &&&\n     of_nat n \\<noteq> \\<i>\\<^sub>\\<int>) &&&\n    (\\<i>\\<^sub>\\<int> \\<noteq> of_int (int n) &&&\n     of_int (int n) \\<noteq> \\<i>\\<^sub>\\<int>) &&&\n    \\<i>\\<^sub>\\<int> \\<noteq> numeral m &&&\n    numeral m \\<noteq> \\<i>\\<^sub>\\<int>", "by (auto simp: gauss_int_eq_iff)"], ["", "lemma gauss_cnj_0 [simp]: \"gauss_cnj 0 = 0\"\n  and gauss_cnj_1 [simp]: \"gauss_cnj 1 = 1\"\n  and gauss_cnj_cnj [simp]: \"gauss_cnj (gauss_cnj z) = z\"\n  and gauss_cnj_uminus [simp]: \"gauss_cnj (-a) = -gauss_cnj a\"\n  and gauss_cnj_add [simp]: \"gauss_cnj (a + b) = gauss_cnj a + gauss_cnj b\"\n  and gauss_cnj_diff [simp]: \"gauss_cnj (a - b) = gauss_cnj a - gauss_cnj b\"\n  and gauss_cnj_mult [simp]: \"gauss_cnj (a * b) = gauss_cnj a * gauss_cnj b\"\n  and gauss_cnj_of_nat [simp]: \"gauss_cnj (of_nat n1) = of_nat n1\"\n  and gauss_cnj_of_int [simp]: \"gauss_cnj (of_int n2) = of_int n2\"\n  and gauss_cnj_numeral [simp]: \"gauss_cnj (numeral n3) = numeral n3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gauss_cnj 0 = 0 &&& gauss_cnj 1 = 1) &&&\n     gauss_cnj (gauss_cnj z) = z &&&\n     gauss_cnj (- a) = - gauss_cnj a &&&\n     gauss_cnj (a + b) = gauss_cnj a + gauss_cnj b) &&&\n    (gauss_cnj (a - b) = gauss_cnj a - gauss_cnj b &&&\n     gauss_cnj (a * b) = gauss_cnj a * gauss_cnj b) &&&\n    gauss_cnj (of_nat n1) = of_nat n1 &&&\n    gauss_cnj (of_int n2) = of_int n2 &&&\n    gauss_cnj (numeral n3) = numeral n3", "by (simp_all add: gauss_int_eq_iff)"], ["", "lemma gauss_cnj_power [simp]: \"gauss_cnj (a ^ n) = gauss_cnj a ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj (a ^ n) = gauss_cnj a ^ n", "by (induction n) auto"], ["", "lemma gauss_cnj_sum [simp]: \"gauss_cnj (sum f A) = (\\<Sum>x\\<in>A. gauss_cnj (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj (sum f A) = (\\<Sum>x\\<in>A. gauss_cnj (f x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma gauss_cnj_prod [simp]: \"gauss_cnj (prod f A) = (\\<Prod>x\\<in>A. gauss_cnj (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj (prod f A) = (\\<Prod>x\\<in>A. gauss_cnj (f x))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma of_nat_dvd_of_nat:\n  assumes \"a dvd b\"\n  shows   \"of_nat a dvd (of_nat b :: 'a :: comm_semiring_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat a dvd of_nat b", "using assms"], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. of_nat a dvd of_nat b", "by auto"], ["", "lemma of_int_dvd_imp_dvd_gauss_cnj:\n  fixes z :: gauss_int\n  assumes \"of_int n dvd z\"\n  shows   \"of_int n dvd gauss_cnj z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int n dvd gauss_cnj z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_int n dvd gauss_cnj z", "from assms"], ["proof (chain)\npicking this:\n  of_int n dvd z", "obtain u where \"z = of_int n * u\""], ["proof (prove)\nusing this:\n  of_int n dvd z\n\ngoal (1 subgoal):\n 1. (\\<And>u. z = of_int n * u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z = of_int n * u\n\ngoal (1 subgoal):\n 1. of_int n dvd gauss_cnj z", "hence \"gauss_cnj z = of_int n * gauss_cnj u\""], ["proof (prove)\nusing this:\n  z = of_int n * u\n\ngoal (1 subgoal):\n 1. gauss_cnj z = of_int n * gauss_cnj u", "by simp"], ["proof (state)\nthis:\n  gauss_cnj z = of_int n * gauss_cnj u\n\ngoal (1 subgoal):\n 1. of_int n dvd gauss_cnj z", "thus ?thesis"], ["proof (prove)\nusing this:\n  gauss_cnj z = of_int n * gauss_cnj u\n\ngoal (1 subgoal):\n 1. of_int n dvd gauss_cnj z", "by auto"], ["proof (state)\nthis:\n  of_int n dvd gauss_cnj z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_nat_dvd_imp_dvd_gauss_cnj:\n  fixes z :: gauss_int\n  assumes \"of_nat n dvd z\"\n  shows   \"of_nat n dvd gauss_cnj z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n dvd gauss_cnj z", "using of_int_dvd_imp_dvd_gauss_cnj[of \"int n\"] assms"], ["proof (prove)\nusing this:\n  of_int (int n) dvd ?z \\<Longrightarrow> of_int (int n) dvd gauss_cnj ?z\n  of_nat n dvd z\n\ngoal (1 subgoal):\n 1. of_nat n dvd gauss_cnj z", "by simp"], ["", "lemma of_int_dvd_of_int_gauss_int_iff:\n  \"(of_int m :: gauss_int) dvd of_int n \\<longleftrightarrow> m dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int m dvd of_int n) = (m dvd n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. of_int m dvd of_int n \\<Longrightarrow> m dvd n\n 2. m dvd n \\<Longrightarrow> of_int m dvd of_int n", "assume \"of_int m dvd (of_int n :: gauss_int)\""], ["proof (state)\nthis:\n  of_int m dvd of_int n\n\ngoal (2 subgoals):\n 1. of_int m dvd of_int n \\<Longrightarrow> m dvd n\n 2. m dvd n \\<Longrightarrow> of_int m dvd of_int n", "then"], ["proof (chain)\npicking this:\n  of_int m dvd of_int n", "obtain a :: gauss_int where \"of_int n = of_int m * a\""], ["proof (prove)\nusing this:\n  of_int m dvd of_int n\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        of_int n = of_int m * a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  of_int n = of_int m * a\n\ngoal (2 subgoals):\n 1. of_int m dvd of_int n \\<Longrightarrow> m dvd n\n 2. m dvd n \\<Longrightarrow> of_int m dvd of_int n", "thus \"m dvd n\""], ["proof (prove)\nusing this:\n  of_int n = of_int m * a\n\ngoal (1 subgoal):\n 1. m dvd n", "by (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  m dvd n\n\ngoal (1 subgoal):\n 1. m dvd n \\<Longrightarrow> of_int m dvd of_int n", "qed auto"], ["", "lemma of_nat_dvd_of_nat_gauss_int_iff:\n  \"(of_nat m :: gauss_int) dvd of_nat n \\<longleftrightarrow> m dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat m dvd of_nat n) = (m dvd n)", "using of_int_dvd_of_int_gauss_int_iff[of \"int m\" \"int n\"]"], ["proof (prove)\nusing this:\n  (of_int (int m) dvd of_int (int n)) = (int m dvd int n)\n\ngoal (1 subgoal):\n 1. (of_nat m dvd of_nat n) = (m dvd n)", "by simp"], ["", "lemma gauss_cnj_dvd:\n  assumes \"a dvd b\"\n  shows   \"gauss_cnj a dvd gauss_cnj b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj a dvd gauss_cnj b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_cnj a dvd gauss_cnj b", "from assms"], ["proof (chain)\npicking this:\n  a dvd b", "obtain c where \"b = a * c\""], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  b = a * c\n\ngoal (1 subgoal):\n 1. gauss_cnj a dvd gauss_cnj b", "hence \"gauss_cnj b = gauss_cnj a * gauss_cnj c\""], ["proof (prove)\nusing this:\n  b = a * c\n\ngoal (1 subgoal):\n 1. gauss_cnj b = gauss_cnj a * gauss_cnj c", "by simp"], ["proof (state)\nthis:\n  gauss_cnj b = gauss_cnj a * gauss_cnj c\n\ngoal (1 subgoal):\n 1. gauss_cnj a dvd gauss_cnj b", "thus ?thesis"], ["proof (prove)\nusing this:\n  gauss_cnj b = gauss_cnj a * gauss_cnj c\n\ngoal (1 subgoal):\n 1. gauss_cnj a dvd gauss_cnj b", "by auto"], ["proof (state)\nthis:\n  gauss_cnj a dvd gauss_cnj b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_cnj_dvd_iff: \"gauss_cnj a dvd gauss_cnj b \\<longleftrightarrow> a dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_cnj a dvd gauss_cnj b) = (a dvd b)", "using gauss_cnj_dvd[of a b] gauss_cnj_dvd[of \"gauss_cnj a\" \"gauss_cnj b\"]"], ["proof (prove)\nusing this:\n  a dvd b \\<Longrightarrow> gauss_cnj a dvd gauss_cnj b\n  gauss_cnj a dvd gauss_cnj b \\<Longrightarrow>\n  gauss_cnj (gauss_cnj a) dvd gauss_cnj (gauss_cnj b)\n\ngoal (1 subgoal):\n 1. (gauss_cnj a dvd gauss_cnj b) = (a dvd b)", "by auto"], ["", "lemma gauss_cnj_dvd_left_iff: \"gauss_cnj a dvd b \\<longleftrightarrow> a dvd gauss_cnj b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_cnj a dvd b) = (a dvd gauss_cnj b)", "by (subst gauss_cnj_dvd_iff [symmetric]) auto"], ["", "lemma gauss_cnj_dvd_right_iff: \"a dvd gauss_cnj b \\<longleftrightarrow> gauss_cnj a dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a dvd gauss_cnj b) = (gauss_cnj a dvd b)", "by (rule gauss_cnj_dvd_left_iff [symmetric])"], ["", "instance gauss_int :: idom"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, idom_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "fix z u :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "assume \"z \\<noteq> 0\" \"u \\<noteq> 0\""], ["proof (state)\nthis:\n  z \\<noteq> 0\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "hence \"gauss2complex z * gauss2complex u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss2complex z * gauss2complex u \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  gauss2complex z * gauss2complex u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "also"], ["proof (state)\nthis:\n  gauss2complex z * gauss2complex u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "have \"gauss2complex z * gauss2complex u = gauss2complex (z * u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss2complex z * gauss2complex u = gauss2complex (z * u)", "by simp"], ["proof (state)\nthis:\n  gauss2complex z * gauss2complex u = gauss2complex (z * u)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> 0; b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> a * b \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  gauss2complex (z * u) \\<noteq> 0", "show \"z * u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  gauss2complex (z * u) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z * u \\<noteq> 0", "unfolding gauss2complex_eq_0_iff"], ["proof (prove)\nusing this:\n  z * u \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z * u \\<noteq> 0", "."], ["proof (state)\nthis:\n  z * u \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "instance gauss_int :: ring_char_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, ring_char_0_class)", "by intro_classes (auto intro!: injI simp: gauss_int_eq_iff)"], ["", "subsection \\<open>Pretty-printing\\<close>"], ["", "text \\<open>\n  The following lemma collection provides better pretty-printing of Gaussian integers so that\n  e.g.\\ evaluation with the `value' command produces nicer results.\n\\<close>"], ["", "lemma gauss_int_code_post [code_post]:\n  \"Gauss_Int 0 0 = 0\"\n  \"Gauss_Int 0 1 = \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (-1) = -\\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 0 = 1\"\n  \"Gauss_Int 1 1 = 1 + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (-1) = 1 - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) 0 = -1\"\n  \"Gauss_Int (-1) 1 = -1 + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (-1) = -1 - \\<i>\\<^sub>\\<int>\"  \n  \"Gauss_Int (numeral b) 0 = numeral b\"\n  \"Gauss_Int (-numeral b) 0 = -numeral b\"\n  \"Gauss_Int (numeral b) 1 = numeral b + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral b) 1 = -numeral b + \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral b) (-1) = numeral b - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral b) (-1) = -numeral b - \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (numeral b) = numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 0 (-numeral b) = -numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (numeral b) = 1 + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int 1 (-numeral b) = 1 - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (numeral b) = -1 + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-1) (-numeral b) = -1 - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral a) (numeral b) = numeral a + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (numeral a) (-numeral b) = numeral a - numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral a) (numeral b) = -numeral a + numeral b * \\<i>\\<^sub>\\<int>\"\n  \"Gauss_Int (-numeral a) (-numeral b) = -numeral a - numeral b * \\<i>\\<^sub>\\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((Gauss_Int 0 0 = 0 &&&\n       Gauss_Int 0 1 = \\<i>\\<^sub>\\<int> &&&\n       Gauss_Int 0 (- 1) = - \\<i>\\<^sub>\\<int>) &&&\n      Gauss_Int 1 0 = 1 &&&\n      Gauss_Int 1 1 = 1 + \\<i>\\<^sub>\\<int> &&&\n      Gauss_Int 1 (- 1) = 1 - \\<i>\\<^sub>\\<int>) &&&\n     (Gauss_Int (- 1) 0 = - 1 &&&\n      Gauss_Int (- 1) 1 = - 1 + \\<i>\\<^sub>\\<int> &&&\n      Gauss_Int (- 1) (- 1) = - 1 - \\<i>\\<^sub>\\<int>) &&&\n     Gauss_Int (numeral b) 0 = numeral b &&&\n     Gauss_Int (- numeral b) 0 = - numeral b &&&\n     Gauss_Int (numeral b) 1 = numeral b + \\<i>\\<^sub>\\<int>) &&&\n    ((Gauss_Int (- numeral b) 1 = - numeral b + \\<i>\\<^sub>\\<int> &&&\n      Gauss_Int (numeral b) (- 1) = numeral b - \\<i>\\<^sub>\\<int> &&&\n      Gauss_Int (- numeral b) (- 1) = - numeral b - \\<i>\\<^sub>\\<int>) &&&\n     Gauss_Int 0 (numeral b) = numeral b * \\<i>\\<^sub>\\<int> &&&\n     Gauss_Int 0 (- numeral b) = - numeral b * \\<i>\\<^sub>\\<int> &&&\n     Gauss_Int 1 (numeral b) = 1 + numeral b * \\<i>\\<^sub>\\<int>) &&&\n    (Gauss_Int 1 (- numeral b) = 1 - numeral b * \\<i>\\<^sub>\\<int> &&&\n     Gauss_Int (- 1) (numeral b) = - 1 + numeral b * \\<i>\\<^sub>\\<int> &&&\n     Gauss_Int (- 1) (- numeral b) =\n     - 1 - numeral b * \\<i>\\<^sub>\\<int>) &&&\n    (Gauss_Int (numeral a) (numeral b) =\n     numeral a + numeral b * \\<i>\\<^sub>\\<int> &&&\n     Gauss_Int (numeral a) (- numeral b) =\n     numeral a - numeral b * \\<i>\\<^sub>\\<int>) &&&\n    Gauss_Int (- numeral a) (numeral b) =\n    - numeral a + numeral b * \\<i>\\<^sub>\\<int> &&&\n    Gauss_Int (- numeral a) (- numeral b) =\n    - numeral a - numeral b * \\<i>\\<^sub>\\<int>", "by (simp_all add: gauss_int_eq_iff)"], ["", "value \"\\<i>\\<^sub>\\<int> ^ 3\""], ["", "value \"2 * (3 + \\<i>\\<^sub>\\<int>)\""], ["", "value \"(2 + \\<i>\\<^sub>\\<int>) * (2 - \\<i>\\<^sub>\\<int>)\""], ["", "subsection \\<open>Norm\\<close>"], ["", "text \\<open>\n  The square of the complex norm (or complex modulus) on the Gaussian integers gives us a norm\n  that always returns a natural number. We will later show that this is also a Euclidean norm\n  (in the sense of a Euclidean ring).\n\\<close>"], ["", "definition gauss_int_norm :: \"gauss_int \\<Rightarrow> nat\" where\n  \"gauss_int_norm z = nat (ReZ z ^ 2 + ImZ z ^ 2)\""], ["", "lemma gauss_int_norm_0 [simp]: \"gauss_int_norm 0 = 0\"\n  and gauss_int_norm_1 [simp]: \"gauss_int_norm 1 = 1\"\n  and gauss_int_norm_i [simp]: \"gauss_int_norm \\<i>\\<^sub>\\<int> = 1\"\n  and gauss_int_norm_cnj [simp]: \"gauss_int_norm (gauss_cnj z) = gauss_int_norm z\"\n  and gauss_int_norm_of_nat [simp]: \"gauss_int_norm (of_nat n) = n ^ 2\"\n  and gauss_int_norm_of_int [simp]: \"gauss_int_norm (of_int m) = nat (m ^ 2)\"\n  and gauss_int_norm_of_numeral [simp]: \"gauss_int_norm (numeral n') = numeral (Num.sqr n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_int_norm 0 = 0 &&&\n     gauss_int_norm 1 = 1 &&& gauss_int_norm \\<i>\\<^sub>\\<int> = 1) &&&\n    (gauss_int_norm (gauss_cnj z) = gauss_int_norm z &&&\n     gauss_int_norm (of_nat n) = n\\<^sup>2) &&&\n    gauss_int_norm (of_int m) = nat (m\\<^sup>2) &&&\n    gauss_int_norm (numeral n') = numeral (Num.sqr n')", "by (simp_all add: gauss_int_norm_def nat_power_eq)"], ["", "lemma gauss_int_norm_uminus [simp]: \"gauss_int_norm (-z) = gauss_int_norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (- z) = gauss_int_norm z", "by (simp add: gauss_int_norm_def)"], ["", "lemma gauss_int_norm_eq_0_iff [simp]: \"gauss_int_norm z = 0 \\<longleftrightarrow> z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_int_norm z = 0) = (z = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "assume \"gauss_int_norm z = 0\""], ["proof (state)\nthis:\n  gauss_int_norm z = 0\n\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "hence \"ReZ z ^ 2 + ImZ z ^ 2 \\<le> 0\""], ["proof (prove)\nusing this:\n  gauss_int_norm z = 0\n\ngoal (1 subgoal):\n 1. (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<le> 0", "by (simp add: gauss_int_norm_def)"], ["proof (state)\nthis:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<le> 0\n\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "moreover"], ["proof (state)\nthis:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<le> 0\n\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "have \"ReZ z ^ 2 + ImZ z ^ 2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2\n\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "ultimately"], ["proof (chain)\npicking this:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<le> 0\n  0 \\<le> (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2", "have \"ReZ z ^ 2 + ImZ z ^ 2 = 0\""], ["proof (prove)\nusing this:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<le> 0\n  0 \\<le> (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 = 0", "by linarith"], ["proof (state)\nthis:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 = 0\n\ngoal (2 subgoals):\n 1. gauss_int_norm z = 0 \\<Longrightarrow> z = 0\n 2. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "thus \"z = 0\""], ["proof (prove)\nusing this:\n  (ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. z = 0", "by (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  z = 0\n\ngoal (1 subgoal):\n 1. z = 0 \\<Longrightarrow> gauss_int_norm z = 0", "qed auto"], ["", "lemma gauss_int_norm_pos_iff [simp]: \"gauss_int_norm z > 0 \\<longleftrightarrow> z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < gauss_int_norm z) = (z \\<noteq> 0)", "using gauss_int_norm_eq_0_iff[of z]"], ["proof (prove)\nusing this:\n  (gauss_int_norm z = 0) = (z = 0)\n\ngoal (1 subgoal):\n 1. (0 < gauss_int_norm z) = (z \\<noteq> 0)", "by (auto intro: Nat.gr0I)"], ["", "lemma real_gauss_int_norm: \"real (gauss_int_norm z) = norm (gauss2complex z) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (gauss_int_norm z) = (cmod (gauss2complex z))\\<^sup>2", "by (auto simp: cmod_def gauss_int_norm_def)"], ["", "lemma gauss_int_norm_mult: \"gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u", "have \"real (gauss_int_norm (z * u)) = real (gauss_int_norm z * gauss_int_norm u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (gauss_int_norm (z * u)) =\n    real (gauss_int_norm z * gauss_int_norm u)", "unfolding of_nat_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (gauss_int_norm (z * u)) =\n    real (gauss_int_norm z) * real (gauss_int_norm u)", "by (simp add: real_gauss_int_norm norm_power norm_mult power_mult_distrib)"], ["proof (state)\nthis:\n  real (gauss_int_norm (z * u)) = real (gauss_int_norm z * gauss_int_norm u)\n\ngoal (1 subgoal):\n 1. gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u", "thus ?thesis"], ["proof (prove)\nusing this:\n  real (gauss_int_norm (z * u)) = real (gauss_int_norm z * gauss_int_norm u)\n\ngoal (1 subgoal):\n 1. gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u", "by (subst (asm) of_nat_eq_iff)"], ["proof (state)\nthis:\n  gauss_int_norm (z * u) = gauss_int_norm z * gauss_int_norm u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma self_mult_gauss_cnj: \"z * gauss_cnj z = of_nat (gauss_int_norm z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * gauss_cnj z = of_nat (gauss_int_norm z)", "by (simp add: gauss_int_norm_def gauss_int_eq_iff algebra_simps power2_eq_square)"], ["", "lemma gauss_cnj_mult_self: \"gauss_cnj z * z = of_nat (gauss_int_norm z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj z * z = of_nat (gauss_int_norm z)", "by (subst mult.commute, rule self_mult_gauss_cnj)"], ["", "lemma self_plus_gauss_cnj: \"z + gauss_cnj z = of_int (2 * ReZ z)\"\n  and self_minus_gauss_cnj: \"z - gauss_cnj z = of_int (2 * ImZ z) * \\<i>\\<^sub>\\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + gauss_cnj z = of_int (2 * ReZ z) &&&\n    z - gauss_cnj z = of_int (2 * ImZ z) * \\<i>\\<^sub>\\<int>", "by (auto simp: gauss_int_eq_iff)"], ["", "lemma gauss_int_norm_dvd_mono:\n  assumes \"a dvd b\"\n  shows \"gauss_int_norm a dvd gauss_int_norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm a dvd gauss_int_norm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_int_norm a dvd gauss_int_norm b", "from assms"], ["proof (chain)\npicking this:\n  a dvd b", "obtain c where \"b = a * c\""], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. (\\<And>c. b = a * c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  b = a * c\n\ngoal (1 subgoal):\n 1. gauss_int_norm a dvd gauss_int_norm b", "hence \"gauss_int_norm b = gauss_int_norm (a * c)\""], ["proof (prove)\nusing this:\n  b = a * c\n\ngoal (1 subgoal):\n 1. gauss_int_norm b = gauss_int_norm (a * c)", "by metis"], ["proof (state)\nthis:\n  gauss_int_norm b = gauss_int_norm (a * c)\n\ngoal (1 subgoal):\n 1. gauss_int_norm a dvd gauss_int_norm b", "thus ?thesis"], ["proof (prove)\nusing this:\n  gauss_int_norm b = gauss_int_norm (a * c)\n\ngoal (1 subgoal):\n 1. gauss_int_norm a dvd gauss_int_norm b", "by (simp add: gauss_int_norm_mult)"], ["proof (state)\nthis:\n  gauss_int_norm a dvd gauss_int_norm b\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A Gaussian integer is a unit iff its norm is 1, and this is the case precisely for the four\n  elements \\<open>\\<plusminus>1\\<close> and \\<open>\\<plusminus>\\<i>\\<close>:\n\\<close>"], ["", "lemma is_unit_gauss_int_iff: \"x dvd 1 \\<longleftrightarrow> x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int> :: gauss_int}\"\n  and is_unit_gauss_int_iff': \"x dvd 1 \\<longleftrightarrow> gauss_int_norm x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x dvd 1) =\n    (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}) &&&\n    (x dvd 1) = (gauss_int_norm x = 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "have \"x dvd 1\" if \"x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x dvd 1", "from that"], ["proof (chain)\npicking this:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "have *: \"x * gauss_cnj x = 1\""], ["proof (prove)\nusing this:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. x * gauss_cnj x = 1", "by (auto simp: gauss_int_norm_def)"], ["proof (state)\nthis:\n  x * gauss_cnj x = 1\n\ngoal (1 subgoal):\n 1. x dvd 1", "show \"x dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd 1", "by (subst * [symmetric]) simp"], ["proof (state)\nthis:\n  x dvd 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>} \\<Longrightarrow>\n  x dvd 1\n\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "moreover"], ["proof (state)\nthis:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>} \\<Longrightarrow>\n  x dvd 1\n\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "have \"gauss_int_norm x = 1\" if \"x dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm x = 1", "using gauss_int_norm_dvd_mono[OF that]"], ["proof (prove)\nusing this:\n  gauss_int_norm x dvd gauss_int_norm 1\n\ngoal (1 subgoal):\n 1. gauss_int_norm x = 1", "by simp"], ["proof (state)\nthis:\n  x dvd 1 \\<Longrightarrow> gauss_int_norm x = 1\n\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "moreover"], ["proof (state)\nthis:\n  x dvd 1 \\<Longrightarrow> gauss_int_norm x = 1\n\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "have \"x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int>}\" if \"gauss_int_norm x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "from that"], ["proof (chain)\npicking this:\n  gauss_int_norm x = 1", "have *: \"(ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1\""], ["proof (prove)\nusing this:\n  gauss_int_norm x = 1\n\ngoal (1 subgoal):\n 1. (ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1", "by (auto simp: gauss_int_norm_def nat_eq_iff)"], ["proof (state)\nthis:\n  (ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "hence \"ReZ x ^ 2 \\<le> 1\" and \"ImZ x ^ 2 \\<le> 1\""], ["proof (prove)\nusing this:\n  (ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. (ReZ x)\\<^sup>2 \\<le> 1 &&& (ImZ x)\\<^sup>2 \\<le> 1", "using zero_le_power2[of \"ImZ x\"] zero_le_power2[of \"ReZ x\"]"], ["proof (prove)\nusing this:\n  (ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1\n  0 \\<le> (ImZ x)\\<^sup>2\n  0 \\<le> (ReZ x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (ReZ x)\\<^sup>2 \\<le> 1 &&& (ImZ x)\\<^sup>2 \\<le> 1", "by linarith+"], ["proof (state)\nthis:\n  (ReZ x)\\<^sup>2 \\<le> 1\n  (ImZ x)\\<^sup>2 \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "hence \"\\<bar>ReZ x\\<bar> \\<le> 1\" and \"\\<bar>ImZ x\\<bar> \\<le> 1\""], ["proof (prove)\nusing this:\n  (ReZ x)\\<^sup>2 \\<le> 1\n  (ImZ x)\\<^sup>2 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>ReZ x\\<bar> \\<le> 1 &&& \\<bar>ImZ x\\<bar> \\<le> 1", "by (auto simp: abs_square_le_1)"], ["proof (state)\nthis:\n  \\<bar>ReZ x\\<bar> \\<le> 1\n  \\<bar>ImZ x\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "hence \"ReZ x \\<in> {-1, 0, 1}\" and \"ImZ x \\<in> {-1, 0, 1}\""], ["proof (prove)\nusing this:\n  \\<bar>ReZ x\\<bar> \\<le> 1\n  \\<bar>ImZ x\\<bar> \\<le> 1\n\ngoal (1 subgoal):\n 1. ReZ x \\<in> {- 1, 0, 1} &&& ImZ x \\<in> {- 1, 0, 1}", "by auto"], ["proof (state)\nthis:\n  ReZ x \\<in> {- 1, 0, 1}\n  ImZ x \\<in> {- 1, 0, 1}\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "thus \"x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int> :: gauss_int}\""], ["proof (prove)\nusing this:\n  ReZ x \\<in> {- 1, 0, 1}\n  ImZ x \\<in> {- 1, 0, 1}\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "using *"], ["proof (prove)\nusing this:\n  ReZ x \\<in> {- 1, 0, 1}\n  ImZ x \\<in> {- 1, 0, 1}\n  (ReZ x)\\<^sup>2 + (ImZ x)\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "by (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gauss_int_norm x = 1 \\<Longrightarrow>\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (2 subgoals):\n 1. (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n 2. (x dvd 1) = (gauss_int_norm x = 1)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>} \\<Longrightarrow>\n  x dvd 1\n  x dvd 1 \\<Longrightarrow> gauss_int_norm x = 1\n  gauss_int_norm x = 1 \\<Longrightarrow>\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "show \"x dvd 1 \\<longleftrightarrow> x \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int> :: gauss_int}\"\n              and \"x dvd 1 \\<longleftrightarrow> gauss_int_norm x = 1\""], ["proof (prove)\nusing this:\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>} \\<Longrightarrow>\n  x dvd 1\n  x dvd 1 \\<Longrightarrow> gauss_int_norm x = 1\n  gauss_int_norm x = 1 \\<Longrightarrow>\n  x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. (x dvd 1) =\n    (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}) &&&\n    (x dvd 1) = (gauss_int_norm x = 1)", "by blast+"], ["proof (state)\nthis:\n  (x dvd 1) = (x \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>})\n  (x dvd 1) = (gauss_int_norm x = 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_unit_gauss_i [simp, intro]: \"(gauss_i :: gauss_int) dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i>\\<^sub>\\<int> dvd 1", "by (simp add: is_unit_gauss_int_iff)"], ["", "lemma gauss_int_norm_eq_Suc_0_iff: \"gauss_int_norm x = Suc 0 \\<longleftrightarrow> x dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_int_norm x = Suc 0) = (x dvd 1)", "by (simp add: is_unit_gauss_int_iff')"], ["", "lemma is_unit_gauss_cnj [intro]: \"z dvd 1 \\<Longrightarrow> gauss_cnj z dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z dvd 1 \\<Longrightarrow> gauss_cnj z dvd 1", "by (simp add: is_unit_gauss_int_iff')"], ["", "lemma is_unit_gauss_cnj_iff [simp]: \"gauss_cnj z dvd 1 \\<longleftrightarrow> z dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_cnj z dvd 1) = (z dvd 1)", "by (simp add: is_unit_gauss_int_iff')"], ["", "subsection \\<open>Division and normalisation\\<close>"], ["", "text \\<open>\n  We define a rounding operation that takes a complex number and returns a Gaussian integer\n  by rounding the real and imaginary parts separately:\n\\<close>"], ["", "primcorec round_complex :: \"complex \\<Rightarrow> gauss_int\" where\n  \"ReZ (round_complex z) = round (Re z)\"\n| \"ImZ (round_complex z) = round (Im z)\""], ["", "text \\<open>\n  The distance between a rounded complex number and the original one is no more than\n  $\\frac{1}{2}\\sqrt{2}$:\n\\<close>"], ["", "lemma norm_round_complex_le: \"norm (z - gauss2complex (round_complex z)) ^ 2 \\<le> 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "have \"(Re z - ReZ (round_complex z)) ^ 2 \\<le> (1 / 2) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2\n    \\<le> (1 / 2)\\<^sup>2", "using of_int_round_abs_le[of \"Re z\"]"], ["proof (prove)\nusing this:\n  \\<bar>real_of_int (round (Re z)) - Re z\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2\n    \\<le> (1 / 2)\\<^sup>2", "by (subst abs_le_square_iff [symmetric]) (auto simp: abs_minus_commute)"], ["proof (state)\nthis:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "moreover"], ["proof (state)\nthis:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "have \"(Im z - ImZ (round_complex z)) ^ 2 \\<le> (1 / 2) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2\n    \\<le> (1 / 2)\\<^sup>2", "using of_int_round_abs_le[of \"Im z\"]"], ["proof (prove)\nusing this:\n  \\<bar>real_of_int (round (Im z)) - Im z\\<bar> \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2\n    \\<le> (1 / 2)\\<^sup>2", "by (subst abs_le_square_iff [symmetric]) (auto simp: abs_minus_commute)"], ["proof (state)\nthis:\n  (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "ultimately"], ["proof (chain)\npicking this:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n  (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2", "have \"(Re z - ReZ (round_complex z)) ^ 2 + (Im z - ImZ (round_complex z)) ^ 2 \\<le>\n                     (1 / 2) ^ 2 + (1 / 2) ^ 2\""], ["proof (prove)\nusing this:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n  (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2 \\<le> (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 +\n    (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2\n    \\<le> (1 / 2)\\<^sup>2 + (1 / 2)\\<^sup>2", "by (rule add_mono)"], ["proof (state)\nthis:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 +\n  (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2\n  \\<le> (1 / 2)\\<^sup>2 + (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "thus \"norm (z - gauss2complex (round_complex z)) ^ 2 \\<le> 1 / 2\""], ["proof (prove)\nusing this:\n  (Re z - real_of_int (ReZ (round_complex z)))\\<^sup>2 +\n  (Im z - real_of_int (ImZ (round_complex z)))\\<^sup>2\n  \\<le> (1 / 2)\\<^sup>2 + (1 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "by (simp add: cmod_def power2_eq_square)"], ["proof (state)\nthis:\n  (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dist_round_complex_le: \"dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "have \"dist z (gauss2complex (round_complex z)) ^ 2 =\n        norm (z - gauss2complex (round_complex z)) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist z (gauss2complex (round_complex z)))\\<^sup>2 =\n    (cmod (z - gauss2complex (round_complex z)))\\<^sup>2", "by (simp add: dist_norm)"], ["proof (state)\nthis:\n  (dist z (gauss2complex (round_complex z)))\\<^sup>2 =\n  (cmod (z - gauss2complex (round_complex z)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "also"], ["proof (state)\nthis:\n  (dist z (gauss2complex (round_complex z)))\\<^sup>2 =\n  (cmod (z - gauss2complex (round_complex z)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "have \"\\<dots> \\<le> 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2", "by (rule norm_round_complex_le)"], ["proof (state)\nthis:\n  (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "also"], ["proof (state)\nthis:\n  (cmod (z - gauss2complex (round_complex z)))\\<^sup>2 \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "have \"\\<dots> = (sqrt 2 / 2) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 = (sqrt 2 / 2)\\<^sup>2", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  1 / 2 = (sqrt 2 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "finally"], ["proof (chain)\npicking this:\n  (dist z (gauss2complex (round_complex z)))\\<^sup>2\n  \\<le> (sqrt 2 / 2)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (dist z (gauss2complex (round_complex z)))\\<^sup>2\n  \\<le> (sqrt 2 / 2)\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2", "by (rule power2_le_imp_le) auto"], ["proof (state)\nthis:\n  dist z (gauss2complex (round_complex z)) \\<le> sqrt 2 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now define division on Gaussian integers simply by performing the division in the\n  complex numbers and rounding the result. This also gives us a remainder operation defined\n  accordingly for which the norm of the remainder is always smaller than the norm of the divisor.\n\n  We can also define a normalisation operation that returns a canonical representative for each\n  association class. Since the four units of the Gaussian integers are \\<open>\\<plusminus>1\\<close> and \\<open>\\<plusminus>\\<i>\\<close>, each\n  association class (other than \\<open>0\\<close>) has four representatives, one in each quadrant. We simply\n  define the on in the upper-right quadrant (i.e.\\ the one with non-negative imaginary part\n  and positive real part) as the canonical one.\n\n  Thus, the Gaussian integers form a Euclidean ring. This gives us many things, most importantly\n  the existence of GCDs and LCMs and unique factorisation.\n\\<close>"], ["", "instantiation gauss_int :: algebraic_semidom\nbegin"], ["", "definition divide_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int \\<Rightarrow> gauss_int\" where\n  \"divide_gauss_int a b = round_complex (gauss2complex a / gauss2complex b)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, algebraic_semidom_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a\n 2. \\<And>a. a div 0 = 0", "fix a :: gauss_int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a\n 2. \\<And>a. a div 0 = 0", "show \"a div 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 0 = 0", "by (auto simp: gauss_int_eq_iff divide_gauss_int_def)"], ["proof (state)\nthis:\n  a div 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a", "fix a b :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a", "assume \"b \\<noteq> 0\""], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>b a. b \\<noteq> 0 \\<Longrightarrow> a * b div b = a", "thus \"a * b div b = a\""], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * b div b = a", "by (auto simp: gauss_int_eq_iff divide_gauss_int_def)"], ["proof (state)\nthis:\n  a * b div b = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation gauss_int :: semidom_divide_unit_factor\nbegin"], ["", "definition unit_factor_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int\" where\n  \"unit_factor_gauss_int z =\n     (if z = 0 then 0 else \n      if ImZ z \\<ge> 0 \\<and> ReZ z > 0 then 1\n      else if ReZ z \\<le> 0 \\<and> ImZ z > 0 then \\<i>\\<^sub>\\<int>\n      else if ImZ z \\<le> 0 \\<and> ReZ z < 0 then -1\n      else -\\<i>\\<^sub>\\<int>)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, semidom_divide_unit_factor_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. unit_factor 0 = 0\n 2. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 3. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 4. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "show \"unit_factor (0 :: gauss_int) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor 0 = 0", "by (simp add: unit_factor_gauss_int_def)"], ["proof (state)\nthis:\n  unit_factor 0 = 0\n\ngoal (3 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 3. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 3. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "fix z :: gauss_int"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 3. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "assume \"is_unit z\""], ["proof (state)\nthis:\n  is_unit z\n\ngoal (3 subgoals):\n 1. \\<And>a. is_unit a \\<Longrightarrow> unit_factor a = a\n 2. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 3. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "thus \"unit_factor z = z\""], ["proof (prove)\nusing this:\n  is_unit z\n\ngoal (1 subgoal):\n 1. unit_factor z = z", "by (subst (asm) is_unit_gauss_int_iff) (auto simp: unit_factor_gauss_int_def)"], ["proof (state)\nthis:\n  unit_factor z = z\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "fix z :: gauss_int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "assume z: \"z \\<noteq> 0\""], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> is_unit (unit_factor a)\n 2. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "thus \"is_unit (unit_factor z)\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (unit_factor z)", "by (subst is_unit_gauss_int_iff) (auto simp: unit_factor_gauss_int_def)"], ["proof (state)\nthis:\n  is_unit (unit_factor z)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "fix z u :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "assume \"is_unit z\""], ["proof (state)\nthis:\n  is_unit z\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "hence \"z \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int>}\""], ["proof (prove)\nusing this:\n  is_unit z\n\ngoal (1 subgoal):\n 1. z \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "by (subst (asm) is_unit_gauss_int_iff)"], ["proof (state)\nthis:\n  z \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       is_unit a \\<Longrightarrow> unit_factor (a * b) = a * unit_factor b", "thus \"unit_factor (z * u) = z * unit_factor u\""], ["proof (prove)\nusing this:\n  z \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. unit_factor (z * u) = z * unit_factor u", "by (safe; auto simp: unit_factor_gauss_int_def gauss_int_eq_iff[of u 0])"], ["proof (state)\nthis:\n  unit_factor (z * u) = z * unit_factor u\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation gauss_int :: normalization_semidom\nbegin"], ["", "definition normalize_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int\" where\n  \"normalize_gauss_int z =\n     (if z = 0 then 0 else \n      if ImZ z \\<ge> 0 \\<and> ReZ z > 0 then z\n      else if ReZ z \\<le> 0 \\<and> ImZ z > 0 then -\\<i>\\<^sub>\\<int> * z\n      else if ImZ z \\<le> 0 \\<and> ReZ z < 0 then -z\n      else \\<i>\\<^sub>\\<int> * z)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, normalization_semidom_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. unit_factor a * normalize a = a\n 2. normalize 0 = 0", "show \"normalize (0 :: gauss_int) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize 0 = 0", "by (simp add: normalize_gauss_int_def)"], ["proof (state)\nthis:\n  normalize 0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>a. unit_factor a * normalize a = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. unit_factor a * normalize a = a", "fix z :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. unit_factor a * normalize a = a", "show \"unit_factor z * normalize z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor z * normalize z = z", "by (auto simp: normalize_gauss_int_def unit_factor_gauss_int_def algebra_simps)"], ["proof (state)\nthis:\n  unit_factor z * normalize z = z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma normalize_gauss_int_of_nat [simp]: \"normalize (of_nat n :: gauss_int) = of_nat n\"\n  and normalize_gauss_int_of_int [simp]: \"normalize (of_int m :: gauss_int) = of_int \\<bar>m\\<bar>\"\n  and normalize_gauss_int_of_numeral [simp]: \"normalize (numeral n' :: gauss_int) = numeral n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (of_nat n) = of_nat n &&&\n    normalize (of_int m) = of_int \\<bar>m\\<bar> &&&\n    normalize (numeral n') = numeral n'", "by (auto simp: normalize_gauss_int_def)"], ["", "lemma normalize_gauss_i [simp]: \"normalize \\<i>\\<^sub>\\<int> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize \\<i>\\<^sub>\\<int> = 1", "by (simp add: normalize_gauss_int_def)"], ["", "lemma gauss_int_norm_normalize [simp]: \"gauss_int_norm (normalize x) = gauss_int_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (normalize x) = gauss_int_norm x", "by (simp add: normalize_gauss_int_def gauss_int_norm_mult)"], ["", "lemma normalized_gauss_int:\n  assumes \"normalize z = z\"\n  shows   \"ReZ z \\<ge> 0\" \"ImZ z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ReZ z &&& 0 \\<le> ImZ z", "using assms"], ["proof (prove)\nusing this:\n  normalize z = z\n\ngoal (1 subgoal):\n 1. 0 \\<le> ReZ z &&& 0 \\<le> ImZ z", "by (cases \"ReZ z\" \"0 :: int\" rule: linorder_cases;\n      cases \"ImZ z\" \"0 :: int\" rule: linorder_cases;\n      simp add: normalize_gauss_int_def gauss_int_eq_iff)+"], ["", "lemma normalized_gauss_int':\n  assumes \"normalize z = z\" \"z \\<noteq> 0\"\n  shows   \"ReZ z > 0\" \"ImZ z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ReZ z &&& 0 \\<le> ImZ z", "using assms"], ["proof (prove)\nusing this:\n  normalize z = z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < ReZ z &&& 0 \\<le> ImZ z", "by (cases \"ReZ z\" \"0 :: int\" rule: linorder_cases;\n      cases \"ImZ z\" \"0 :: int\" rule: linorder_cases;\n      simp add: normalize_gauss_int_def gauss_int_eq_iff)+"], ["", "lemma normalized_gauss_int_iff:\n  \"normalize z = z \\<longleftrightarrow> z = 0 \\<or> ReZ z > 0 \\<and> ImZ z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (normalize z = z) = (z = 0 \\<or> 0 < ReZ z \\<and> 0 \\<le> ImZ z)", "by (cases \"ReZ z\" \"0 :: int\" rule: linorder_cases;\n      cases \"ImZ z\" \"0 :: int\" rule: linorder_cases;\n      simp add: normalize_gauss_int_def gauss_int_eq_iff)+"], ["", "instantiation gauss_int :: idom_modulo\nbegin"], ["", "definition modulo_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int \\<Rightarrow> gauss_int\" where\n  \"modulo_gauss_int a b = a - a div b * b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, idom_modulo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a div b * b + a mod b = a", "fix a b :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a div b * b + a mod b = a", "show \"a div b * b + a mod b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div b * b + a mod b = a", "by (simp add: modulo_gauss_int_def)"], ["proof (state)\nthis:\n  a div b * b + a mod b = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma gauss_int_norm_mod_less_aux:\n  assumes [simp]: \"b \\<noteq> 0\"\n  shows   \"2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "define a' b' where \"a' = gauss2complex a\" and \"b' = gauss2complex b\""], ["proof (state)\nthis:\n  a' = gauss2complex a\n  b' = gauss2complex b\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have [simp]: \"b' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' \\<noteq> 0", "by (simp add: b'_def)"], ["proof (state)\nthis:\n  b' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"gauss_int_norm (a mod b) = \n          norm (gauss2complex (a - round_complex (a' / b') * b)) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (gauss_int_norm (a mod b)) =\n    (cmod (gauss2complex (a - round_complex (a' / b') * b)))\\<^sup>2", "unfolding modulo_gauss_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (gauss_int_norm (a - a div b * b)) =\n    (cmod (gauss2complex (a - round_complex (a' / b') * b)))\\<^sup>2", "by (subst real_gauss_int_norm [symmetric]) (auto simp add: divide_gauss_int_def a'_def b'_def)"], ["proof (state)\nthis:\n  real (gauss_int_norm (a mod b)) =\n  (cmod (gauss2complex (a - round_complex (a' / b') * b)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "also"], ["proof (state)\nthis:\n  real (gauss_int_norm (a mod b)) =\n  (cmod (gauss2complex (a - round_complex (a' / b') * b)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"gauss2complex (a - round_complex (a' / b') * b) =\n               a' - gauss2complex (round_complex (a' / b')) * b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss2complex (a - round_complex (a' / b') * b) =\n    a' - gauss2complex (round_complex (a' / b')) * b'", "by (simp add: a'_def b'_def)"], ["proof (state)\nthis:\n  gauss2complex (a - round_complex (a' / b') * b) =\n  a' - gauss2complex (round_complex (a' / b')) * b'\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "also"], ["proof (state)\nthis:\n  gauss2complex (a - round_complex (a' / b') * b) =\n  a' - gauss2complex (round_complex (a' / b')) * b'\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"\\<dots> = (a' / b' - gauss2complex (round_complex (a' / b'))) * b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' - gauss2complex (round_complex (a' / b')) * b' =\n    (a' / b' - gauss2complex (round_complex (a' / b'))) * b'", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  a' - gauss2complex (round_complex (a' / b')) * b' =\n  (a' / b' - gauss2complex (round_complex (a' / b'))) * b'\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "also"], ["proof (state)\nthis:\n  a' - gauss2complex (round_complex (a' / b')) * b' =\n  (a' / b' - gauss2complex (round_complex (a' / b'))) * b'\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"norm \\<dots> ^ 2 = norm (a' / b' - gauss2complex (round_complex (a' / b'))) ^ 2 * norm b' ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod\n      ((a' / b' - gauss2complex (round_complex (a' / b'))) * b'))\\<^sup>2 =\n    (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n    (cmod b')\\<^sup>2", "by (simp add: norm_mult power_mult_distrib)"], ["proof (state)\nthis:\n  (cmod\n    ((a' / b' - gauss2complex (round_complex (a' / b'))) * b'))\\<^sup>2 =\n  (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n  (cmod b')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "also"], ["proof (state)\nthis:\n  (cmod\n    ((a' / b' - gauss2complex (round_complex (a' / b'))) * b'))\\<^sup>2 =\n  (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n  (cmod b')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"\\<dots> \\<le> 1 / 2 * norm b' ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n    (cmod b')\\<^sup>2\n    \\<le> 1 / 2 * (cmod b')\\<^sup>2", "by (intro mult_right_mono norm_round_complex_le) auto"], ["proof (state)\nthis:\n  (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n  (cmod b')\\<^sup>2\n  \\<le> 1 / 2 * (cmod b')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "also"], ["proof (state)\nthis:\n  (cmod (a' / b' - gauss2complex (round_complex (a' / b'))))\\<^sup>2 *\n  (cmod b')\\<^sup>2\n  \\<le> 1 / 2 * (cmod b')\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "have \"norm b' ^ 2 = gauss_int_norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod b')\\<^sup>2 = real (gauss_int_norm b)", "by (simp add: b'_def real_gauss_int_norm)"], ["proof (state)\nthis:\n  (cmod b')\\<^sup>2 = real (gauss_int_norm b)\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "finally"], ["proof (chain)\npicking this:\n  real (gauss_int_norm (a mod b)) \\<le> 1 / 2 * real (gauss_int_norm b)", "show ?thesis"], ["proof (prove)\nusing this:\n  real (gauss_int_norm (a mod b)) \\<le> 1 / 2 * real (gauss_int_norm b)\n\ngoal (1 subgoal):\n 1. 2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b", "by linarith"], ["proof (state)\nthis:\n  2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_int_norm_mod_less:\n  assumes [simp]: \"b \\<noteq> 0\"\n  shows   \"gauss_int_norm (a mod b) < gauss_int_norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (a mod b) < gauss_int_norm b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_int_norm (a mod b) < gauss_int_norm b", "have \"gauss_int_norm b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gauss_int_norm b", "by simp"], ["proof (state)\nthis:\n  0 < gauss_int_norm b\n\ngoal (1 subgoal):\n 1. gauss_int_norm (a mod b) < gauss_int_norm b", "thus \"gauss_int_norm (a mod b) < gauss_int_norm b\""], ["proof (prove)\nusing this:\n  0 < gauss_int_norm b\n\ngoal (1 subgoal):\n 1. gauss_int_norm (a mod b) < gauss_int_norm b", "using gauss_int_norm_mod_less_aux[OF assms, of a]"], ["proof (prove)\nusing this:\n  0 < gauss_int_norm b\n  2 * gauss_int_norm (a mod b) \\<le> gauss_int_norm b\n\ngoal (1 subgoal):\n 1. gauss_int_norm (a mod b) < gauss_int_norm b", "by presburger"], ["proof (state)\nthis:\n  gauss_int_norm (a mod b) < gauss_int_norm b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_int_norm_dvd_imp_le:\n  assumes \"b \\<noteq> 0\"\n  shows   \"gauss_int_norm a \\<le> gauss_int_norm (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm a \\<le> gauss_int_norm (a * b)", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> gauss_int_norm a \\<le> gauss_int_norm (a * b)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    gauss_int_norm a \\<le> gauss_int_norm (a * b)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> gauss_int_norm a \\<le> gauss_int_norm (a * b)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    gauss_int_norm a \\<le> gauss_int_norm (a * b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss_int_norm a \\<le> gauss_int_norm (a * b)", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss_int_norm a \\<le> gauss_int_norm (a * b)", "by (intro dvd_imp_le gauss_int_norm_dvd_mono) auto"], ["proof (state)\nthis:\n  gauss_int_norm a \\<le> gauss_int_norm (a * b)\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow> gauss_int_norm a \\<le> gauss_int_norm (a * b)", "qed auto"], ["", "instantiation gauss_int :: euclidean_ring\nbegin"], ["", "definition euclidean_size_gauss_int :: \"gauss_int \\<Rightarrow> nat\" where\n  [simp]: \"euclidean_size_gauss_int = gauss_int_norm\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, euclidean_ring_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. euclidean_size 0 = 0\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 3. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "show \"euclidean_size (0 :: gauss_int) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size 0 = 0", "by simp"], ["proof (state)\nthis:\n  euclidean_size 0 = 0\n\ngoal (2 subgoals):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "fix a b :: gauss_int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "assume [simp]: \"b \\<noteq> 0\""], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size (a mod b) < euclidean_size b\n 2. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "show \"euclidean_size (a mod b) < euclidean_size b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size (a mod b) < euclidean_size b", "using gauss_int_norm_mod_less[of b a]"], ["proof (prove)\nusing this:\n  b \\<noteq> 0 \\<Longrightarrow> gauss_int_norm (a mod b) < gauss_int_norm b\n\ngoal (1 subgoal):\n 1. euclidean_size (a mod b) < euclidean_size b", "by simp"], ["proof (state)\nthis:\n  euclidean_size (a mod b) < euclidean_size b\n\ngoal (1 subgoal):\n 1. \\<And>b a.\n       b \\<noteq> 0 \\<Longrightarrow>\n       euclidean_size a \\<le> euclidean_size (a * b)", "show \"euclidean_size a \\<le> euclidean_size (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_size a \\<le> euclidean_size (a * b)", "by (simp add: gauss_int_norm_dvd_imp_le)"], ["proof (state)\nthis:\n  euclidean_size a \\<le> euclidean_size (a * b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance gauss_int :: normalization_euclidean_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, normalization_euclidean_semiring_class)", ".."], ["", "instantiation gauss_int :: euclidean_ring_gcd\nbegin"], ["", "definition gcd_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int \\<Rightarrow> gauss_int\" where\n  \"gcd_gauss_int \\<equiv> normalization_euclidean_semiring_class.gcd\""], ["", "definition lcm_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int \\<Rightarrow> gauss_int\" where\n  \"lcm_gauss_int \\<equiv> normalization_euclidean_semiring_class.lcm\""], ["", "definition Gcd_gauss_int :: \"gauss_int set \\<Rightarrow> gauss_int\" where\n  \"Gcd_gauss_int \\<equiv> normalization_euclidean_semiring_class.Gcd\""], ["", "definition Lcm_gauss_int :: \"gauss_int set \\<Rightarrow> gauss_int\" where\n  \"Lcm_gauss_int \\<equiv> normalization_euclidean_semiring_class.Lcm\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(gauss_int, euclidean_ring_gcd_class)", "by intro_classes\n     (simp_all add: gcd_gauss_int_def lcm_gauss_int_def Gcd_gauss_int_def Lcm_gauss_int_def)"], ["", "end"], ["", "lemma multiplicity_gauss_cnj: \"multiplicity (gauss_cnj a) (gauss_cnj b) = multiplicity a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (gauss_cnj a) (gauss_cnj b) = multiplicity a b", "unfolding multiplicity_def gauss_cnj_power [symmetric] gauss_cnj_dvd_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if finite {n. a ^ n dvd b} then Max {n. a ^ n dvd b} else 0) =\n    (if finite {n. a ^ n dvd b} then Max {n. a ^ n dvd b} else 0)", ".."], ["", "lemma multiplicity_gauss_int_of_nat:\n  \"multiplicity (of_nat a) (of_nat b :: gauss_int) = multiplicity a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (of_nat a) (of_nat b) = multiplicity a b", "unfolding multiplicity_def of_nat_power [symmetric] of_nat_dvd_of_nat_gauss_int_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if finite {n. a ^ n dvd b} then Max {n. a ^ n dvd b} else 0) =\n    (if finite {n. a ^ n dvd b} then Max {n. a ^ n dvd b} else 0)", ".."], ["", "lemma gauss_int_dvd_same_norm_imp_associated:\n  assumes \"z1 dvd z2\" \"gauss_int_norm z1 = gauss_int_norm z2\"\n  shows   \"normalize z1 = normalize z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize z1 = normalize z2", "proof (cases \"z1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2\n 2. z1 \\<noteq> 0 \\<Longrightarrow> normalize z1 = normalize z2", "case [simp]: False"], ["proof (state)\nthis:\n  z1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2\n 2. z1 \\<noteq> 0 \\<Longrightarrow> normalize z1 = normalize z2", "from assms(1)"], ["proof (chain)\npicking this:\n  z1 dvd z2", "obtain u where u: \"z2 = z1 * u\""], ["proof (prove)\nusing this:\n  z1 dvd z2\n\ngoal (1 subgoal):\n 1. (\\<And>u. z2 = z1 * u \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  z2 = z1 * u\n\ngoal (2 subgoals):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2\n 2. z1 \\<noteq> 0 \\<Longrightarrow> normalize z1 = normalize z2", "from assms"], ["proof (chain)\npicking this:\n  z1 dvd z2\n  gauss_int_norm z1 = gauss_int_norm z2", "have \"gauss_int_norm u = 1\""], ["proof (prove)\nusing this:\n  z1 dvd z2\n  gauss_int_norm z1 = gauss_int_norm z2\n\ngoal (1 subgoal):\n 1. gauss_int_norm u = 1", "by (auto simp: gauss_int_norm_mult u)"], ["proof (state)\nthis:\n  gauss_int_norm u = 1\n\ngoal (2 subgoals):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2\n 2. z1 \\<noteq> 0 \\<Longrightarrow> normalize z1 = normalize z2", "hence \"is_unit u\""], ["proof (prove)\nusing this:\n  gauss_int_norm u = 1\n\ngoal (1 subgoal):\n 1. is_unit u", "by (simp add: is_unit_gauss_int_iff')"], ["proof (state)\nthis:\n  is_unit u\n\ngoal (2 subgoals):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2\n 2. z1 \\<noteq> 0 \\<Longrightarrow> normalize z1 = normalize z2", "with u"], ["proof (chain)\npicking this:\n  z2 = z1 * u\n  is_unit u", "show ?thesis"], ["proof (prove)\nusing this:\n  z2 = z1 * u\n  is_unit u\n\ngoal (1 subgoal):\n 1. normalize z1 = normalize z2", "by simp"], ["proof (state)\nthis:\n  normalize z1 = normalize z2\n\ngoal (1 subgoal):\n 1. z1 = 0 \\<Longrightarrow> normalize z1 = normalize z2", "qed (use assms in auto)"], ["", "lemma gcd_of_int_gauss_int: \"gcd (of_int a :: gauss_int) (of_int b) = of_int (gcd a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int a) (of_int b) = of_int (gcd a b)", "proof (induction \"nat \\<bar>b\\<bar>\" arbitrary: a b rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       (\\<And>ba a.\n           nat \\<bar>ba\\<bar> < nat \\<bar>b\\<bar> \\<Longrightarrow>\n           gcd (of_int a) (of_int ba) = of_int (gcd a ba)) \\<Longrightarrow>\n       gcd (of_int a) (of_int b) = of_int (gcd a b)", "case (less b a)"], ["proof (state)\nthis:\n  nat \\<bar>?b\\<bar> < nat \\<bar>b\\<bar> \\<Longrightarrow>\n  gcd (of_int ?a) (of_int ?b) = of_int (gcd ?a ?b)\n\ngoal (1 subgoal):\n 1. \\<And>b a.\n       (\\<And>ba a.\n           nat \\<bar>ba\\<bar> < nat \\<bar>b\\<bar> \\<Longrightarrow>\n           gcd (of_int a) (of_int ba) = of_int (gcd a ba)) \\<Longrightarrow>\n       gcd (of_int a) (of_int b) = of_int (gcd a b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int a) (of_int b) = of_int (gcd a b)", "proof (cases \"b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "case False"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "have \"of_int (gcd a b) = (of_int (gcd b (a mod b)) :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (gcd a b) = of_int (gcd b (a mod b))", "by (subst gcd_red_int) auto"], ["proof (state)\nthis:\n  of_int (gcd a b) = of_int (gcd b (a mod b))\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "also"], ["proof (state)\nthis:\n  of_int (gcd a b) = of_int (gcd b (a mod b))\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "have \"\\<dots> = gcd (of_int b) (of_int (a mod b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (gcd b (a mod b)) = gcd (of_int b) (of_int (a mod b))", "using False"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int (gcd b (a mod b)) = gcd (of_int b) (of_int (a mod b))", "by (intro less [symmetric]) (auto intro!: abs_mod_less)"], ["proof (state)\nthis:\n  of_int (gcd b (a mod b)) = gcd (of_int b) (of_int (a mod b))\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "also"], ["proof (state)\nthis:\n  of_int (gcd b (a mod b)) = gcd (of_int b) (of_int (a mod b))\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "have \"a mod b = (a - a div b * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod b = a - a div b * b", "by (simp add: minus_div_mult_eq_mod)"], ["proof (state)\nthis:\n  a mod b = a - a div b * b\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "also"], ["proof (state)\nthis:\n  a mod b = a - a div b * b\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "have \"of_int \\<dots> = of_int (-(a div b)) * of_int b + (of_int a :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (a - a div b * b) = of_int (- (a div b)) * of_int b + of_int a", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  of_int (a - a div b * b) = of_int (- (a div b)) * of_int b + of_int a\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "also"], ["proof (state)\nthis:\n  of_int (a - a div b * b) = of_int (- (a div b)) * of_int b + of_int a\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "have \"gcd (of_int b) \\<dots> = gcd (of_int b) (of_int a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int b) (of_int (- (a div b)) * of_int b + of_int a) =\n    gcd (of_int b) (of_int a)", "by (rule gcd_add_mult)"], ["proof (state)\nthis:\n  gcd (of_int b) (of_int (- (a div b)) * of_int b + of_int a) =\n  gcd (of_int b) (of_int a)\n\ngoal (2 subgoals):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)\n 2. b \\<noteq> 0 \\<Longrightarrow>\n    gcd (of_int a) (of_int b) = of_int (gcd a b)", "finally"], ["proof (chain)\npicking this:\n  of_int (gcd a b) = gcd (of_int b) (of_int a)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int (gcd a b) = gcd (of_int b) (of_int a)\n\ngoal (1 subgoal):\n 1. gcd (of_int a) (of_int b) = of_int (gcd a b)", "by (simp add: gcd.commute)"], ["proof (state)\nthis:\n  gcd (of_int a) (of_int b) = of_int (gcd a b)\n\ngoal (1 subgoal):\n 1. b = 0 \\<Longrightarrow> gcd (of_int a) (of_int b) = of_int (gcd a b)", "qed auto"], ["proof (state)\nthis:\n  gcd (of_int a) (of_int b) = of_int (gcd a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_of_int_gauss_int: \"coprime (of_int a :: gauss_int) (of_int b) = coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (of_int a) (of_int b) = coprime a b", "unfolding coprime_iff_gcd_eq_1 gcd_of_int_gauss_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int (gcd a b) = 1) = (gcd a b = 1)", "by auto"], ["", "lemma gcd_of_nat_gauss_int: \"gcd (of_nat a :: gauss_int) (of_nat b) = of_nat (gcd a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_nat a) (of_nat b) = of_nat (gcd a b)", "using gcd_of_int_gauss_int[of \"int a\" \"int b\"]"], ["proof (prove)\nusing this:\n  gcd (of_int (int a)) (of_int (int b)) = of_int (gcd (int a) (int b))\n\ngoal (1 subgoal):\n 1. gcd (of_nat a) (of_nat b) = of_nat (gcd a b)", "by simp"], ["", "lemma coprime_of_nat_gauss_int: \"coprime (of_nat a :: gauss_int) (of_nat b) = coprime a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (of_nat a) (of_nat b) = coprime a b", "unfolding coprime_iff_gcd_eq_1 gcd_of_nat_gauss_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat (gcd a b) = 1) = (gcd a b = 1)", "by auto"], ["", "lemma gauss_cnj_dvd_self_iff: \"gauss_cnj z dvd z \\<longleftrightarrow> ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gauss_cnj z dvd z) =\n    (ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gauss_cnj z dvd z \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "assume \"gauss_cnj z dvd z\""], ["proof (state)\nthis:\n  gauss_cnj z dvd z\n\ngoal (2 subgoals):\n 1. gauss_cnj z dvd z \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "hence \"normalize (gauss_cnj z) = normalize z\""], ["proof (prove)\nusing this:\n  gauss_cnj z dvd z\n\ngoal (1 subgoal):\n 1. normalize (gauss_cnj z) = normalize z", "by (rule gauss_int_dvd_same_norm_imp_associated) auto"], ["proof (state)\nthis:\n  normalize (gauss_cnj z) = normalize z\n\ngoal (2 subgoals):\n 1. gauss_cnj z dvd z \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "then"], ["proof (chain)\npicking this:\n  normalize (gauss_cnj z) = normalize z", "obtain u :: gauss_int where \"is_unit u\"  and u: \"gauss_cnj z = u * z\""], ["proof (prove)\nusing this:\n  normalize (gauss_cnj z) = normalize z\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; gauss_cnj z = u * z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using associatedE1"], ["proof (prove)\nusing this:\n  normalize (gauss_cnj z) = normalize z\n  \\<lbrakk>normalize ?a = normalize ?b;\n   \\<And>u.\n      \\<lbrakk>is_unit u; ?a = u * ?b\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; gauss_cnj z = u * z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is_unit u\n  gauss_cnj z = u * z\n\ngoal (2 subgoals):\n 1. gauss_cnj z dvd z \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "hence \"u \\<in> {1, -1, \\<i>\\<^sub>\\<int>, -\\<i>\\<^sub>\\<int>}\""], ["proof (prove)\nusing this:\n  is_unit u\n  gauss_cnj z = u * z\n\ngoal (1 subgoal):\n 1. u \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}", "by (simp add: is_unit_gauss_int_iff)"], ["proof (state)\nthis:\n  u \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (2 subgoals):\n 1. gauss_cnj z dvd z \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "thus \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\nusing this:\n  u \\<in> {1, - 1, \\<i>\\<^sub>\\<int>, - \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "proof (elim insertE emptyE)"], ["proof (state)\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "assume [simp]: \"u = \\<i>\\<^sub>\\<int>\""], ["proof (state)\nthis:\n  u = \\<i>\\<^sub>\\<int>\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ z = ReZ (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ z = ReZ (gauss_cnj z)", "by simp"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"gauss_cnj z = \\<i>\\<^sub>\\<int> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj z = \\<i>\\<^sub>\\<int> * z", "using u"], ["proof (prove)\nusing this:\n  gauss_cnj z = u * z\n\ngoal (1 subgoal):\n 1. gauss_cnj z = \\<i>\\<^sub>\\<int> * z", "by simp"], ["proof (state)\nthis:\n  gauss_cnj z = \\<i>\\<^sub>\\<int> * z\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  gauss_cnj z = \\<i>\\<^sub>\\<int> * z\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ \\<dots> = -ImZ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (\\<i>\\<^sub>\\<int> * z) = - ImZ z", "by simp"], ["proof (state)\nthis:\n  ReZ (\\<i>\\<^sub>\\<int> * z) = - ImZ z\n\ngoal (4 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 4. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "finally"], ["proof (chain)\npicking this:\n  ReZ z = - ImZ z", "show \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\nusing this:\n  ReZ z = - ImZ z\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "by auto"], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "assume [simp]: \"u = -\\<i>\\<^sub>\\<int>\""], ["proof (state)\nthis:\n  u = - \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ z = ReZ (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ z = ReZ (gauss_cnj z)", "by simp"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"gauss_cnj z = -\\<i>\\<^sub>\\<int> * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj z = - \\<i>\\<^sub>\\<int> * z", "using u"], ["proof (prove)\nusing this:\n  gauss_cnj z = u * z\n\ngoal (1 subgoal):\n 1. gauss_cnj z = - \\<i>\\<^sub>\\<int> * z", "by simp"], ["proof (state)\nthis:\n  gauss_cnj z = - \\<i>\\<^sub>\\<int> * z\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  gauss_cnj z = - \\<i>\\<^sub>\\<int> * z\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ \\<dots> = ImZ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (- \\<i>\\<^sub>\\<int> * z) = ImZ z", "by simp"], ["proof (state)\nthis:\n  ReZ (- \\<i>\\<^sub>\\<int> * z) = ImZ z\n\ngoal (3 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 3. u = - \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "finally"], ["proof (chain)\npicking this:\n  ReZ z = ImZ z", "show \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\nusing this:\n  ReZ z = ImZ z\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "by auto"], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "assume [simp]: \"u = 1\""], ["proof (state)\nthis:\n  u = 1\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ImZ z = -ImZ (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ImZ z = - ImZ (gauss_cnj z)", "by simp"], ["proof (state)\nthis:\n  ImZ z = - ImZ (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  ImZ z = - ImZ (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"gauss_cnj z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj z = z", "using u"], ["proof (prove)\nusing this:\n  gauss_cnj z = u * z\n\ngoal (1 subgoal):\n 1. gauss_cnj z = z", "by simp"], ["proof (state)\nthis:\n  gauss_cnj z = z\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n 2. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "finally"], ["proof (chain)\npicking this:\n  ImZ z = - ImZ z", "show \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\nusing this:\n  ImZ z = - ImZ z\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "by auto"], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "assume [simp]: \"u = -1\""], ["proof (state)\nthis:\n  u = - 1\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ z = ReZ (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ z = ReZ (gauss_cnj z)", "by simp"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  ReZ z = ReZ (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"gauss_cnj z = -z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj z = - z", "using u"], ["proof (prove)\nusing this:\n  gauss_cnj z = u * z\n\ngoal (1 subgoal):\n 1. gauss_cnj z = - z", "by simp"], ["proof (state)\nthis:\n  gauss_cnj z = - z\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "also"], ["proof (state)\nthis:\n  gauss_cnj z = - z\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "have \"ReZ \\<dots> = -ReZ z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ (- z) = - ReZ z", "by simp"], ["proof (state)\nthis:\n  ReZ (- z) = - ReZ z\n\ngoal (1 subgoal):\n 1. u = - 1 \\<Longrightarrow>\n    ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "finally"], ["proof (chain)\npicking this:\n  ReZ z = - ReZ z", "show \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\nusing this:\n  ReZ z = - ReZ z\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "by auto"], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "assume \"ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (state)\nthis:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. ReZ z = 0 \\<or>\n    ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "thus \"gauss_cnj z dvd z\""], ["proof (prove)\nusing this:\n  ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. gauss_cnj z dvd z", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 3. \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "assume \"\\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (state)\nthis:\n  \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (3 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 3. \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "then"], ["proof (chain)\npicking this:\n  \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>", "obtain u :: int where \"is_unit u\" and u: \"ImZ z = u * ReZ z\""], ["proof (prove)\nusing this:\n  \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; ImZ z = u * ReZ z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using associatedE2[of \"ReZ z\" \"ImZ z\"]"], ["proof (prove)\nusing this:\n  \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\n  \\<lbrakk>normalize (ReZ z) = normalize (ImZ z);\n   \\<And>u.\n      \\<lbrakk>is_unit u; ImZ z = u * ReZ z\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>is_unit u; ImZ z = u * ReZ z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_unit u\n  ImZ z = u * ReZ z\n\ngoal (3 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 3. \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "from \\<open>is_unit u\\<close>"], ["proof (chain)\npicking this:\n  is_unit u", "have \"u \\<in> {1, -1}\""], ["proof (prove)\nusing this:\n  is_unit u\n\ngoal (1 subgoal):\n 1. u \\<in> {1, - 1}", "by auto"], ["proof (state)\nthis:\n  u \\<in> {1, - 1}\n\ngoal (3 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 3. \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "hence \"z = gauss_cnj z * (of_int u * \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\nusing this:\n  u \\<in> {1, - 1}\n\ngoal (1 subgoal):\n 1. z = gauss_cnj z * (of_int u * \\<i>\\<^sub>\\<int>)", "using u"], ["proof (prove)\nusing this:\n  u \\<in> {1, - 1}\n  ImZ z = u * ReZ z\n\ngoal (1 subgoal):\n 1. z = gauss_cnj z * (of_int u * \\<i>\\<^sub>\\<int>)", "by (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  z = gauss_cnj z * (of_int u * \\<i>\\<^sub>\\<int>)\n\ngoal (3 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 3. \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    gauss_cnj z dvd z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = gauss_cnj z * (of_int u * \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. gauss_cnj z dvd z", "by (metis dvd_triv_left)"], ["proof (state)\nthis:\n  gauss_cnj z dvd z\n\ngoal (2 subgoals):\n 1. ReZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z\n 2. ImZ z = 0 \\<Longrightarrow> gauss_cnj z dvd z", "qed (auto simp: gauss_cnj_eq_self gauss_cnj_eq_minus_self)"], ["proof (state)\nthis:\n  gauss_cnj z dvd z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma self_dvd_gauss_cnj_iff: \"z dvd gauss_cnj z \\<longleftrightarrow> ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z dvd gauss_cnj z) =\n    (ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>)", "using gauss_cnj_dvd_self_iff[of z]"], ["proof (prove)\nusing this:\n  (gauss_cnj z dvd z) =\n  (ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>)\n\ngoal (1 subgoal):\n 1. (z dvd gauss_cnj z) =\n    (ReZ z = 0 \\<or> ImZ z = 0 \\<or> \\<bar>ReZ z\\<bar> = \\<bar>ImZ z\\<bar>)", "by (subst (asm) gauss_cnj_dvd_left_iff) auto"], ["", "subsection \\<open>Prime elements\\<close>"], ["", "text \\<open>\n  Next, we analyse what the prime elements of the Gaussian integers are. First, note that\n  according to the conventions of Isabelle's computational algebra library, a prime element\n  is called a prime iff it is also normalised, i.e.\\ in our case it lies in the upper right\n  quadrant.\n\n  As a first fact, we can show that a Gaussian integer whose norm is \\<open>\\<int>\\<close>-prime must be\n  $\\mathbb{Z}[i]$-prime:\n\\<close>"], ["", "lemma prime_gauss_int_norm_imp_prime_elem:\n  assumes \"prime (gauss_int_norm q)\"\n  shows   \"prime_elem q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_elem q", "have \"irreducible q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible q", "proof (rule irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<noteq> 0\n 2. \\<not> is_unit q\n 3. \\<And>a b. q = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "fix a b"], ["proof (state)\ngoal (3 subgoals):\n 1. q \\<noteq> 0\n 2. \\<not> is_unit q\n 3. \\<And>a b. q = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume \"q = a * b\""], ["proof (state)\nthis:\n  q = a * b\n\ngoal (3 subgoals):\n 1. q \\<noteq> 0\n 2. \\<not> is_unit q\n 3. \\<And>a b. q = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "hence \"gauss_int_norm q = gauss_int_norm a * gauss_int_norm b\""], ["proof (prove)\nusing this:\n  q = a * b\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = gauss_int_norm a * gauss_int_norm b", "by (simp_all add: gauss_int_norm_mult)"], ["proof (state)\nthis:\n  gauss_int_norm q = gauss_int_norm a * gauss_int_norm b\n\ngoal (3 subgoals):\n 1. q \\<noteq> 0\n 2. \\<not> is_unit q\n 3. \\<And>a b. q = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "thus \"is_unit a \\<or> is_unit b\""], ["proof (prove)\nusing this:\n  gauss_int_norm q = gauss_int_norm a * gauss_int_norm b\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "using assms"], ["proof (prove)\nusing this:\n  gauss_int_norm q = gauss_int_norm a * gauss_int_norm b\n  prime (gauss_int_norm q)\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by (auto dest!: prime_product simp: gauss_int_norm_eq_Suc_0_iff)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal (2 subgoals):\n 1. q \\<noteq> 0\n 2. \\<not> is_unit q", "qed (use assms in \\<open>auto simp: is_unit_gauss_int_iff'\\<close>)"], ["proof (state)\nthis:\n  irreducible q\n\ngoal (1 subgoal):\n 1. prime_elem q", "thus \"prime_elem q\""], ["proof (prove)\nusing this:\n  irreducible q\n\ngoal (1 subgoal):\n 1. prime_elem q", "using irreducible_imp_prime_elem_gcd"], ["proof (prove)\nusing this:\n  irreducible q\n  irreducible ?x \\<Longrightarrow> prime_elem ?x\n\ngoal (1 subgoal):\n 1. prime_elem q", "by blast"], ["proof (state)\nthis:\n  prime_elem q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Also, a conjugate is a prime element iff the original element is a prime element:\n\\<close>"], ["", "lemma prime_elem_gauss_cnj [intro]: \"prime_elem z \\<Longrightarrow> prime_elem (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem z \\<Longrightarrow> prime_elem (gauss_cnj z)", "by (auto simp: prime_elem_def gauss_cnj_dvd_left_iff)"], ["", "lemma prime_elem_gauss_cnj_iff [simp]: \"prime_elem (gauss_cnj z) \\<longleftrightarrow> prime_elem z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem (gauss_cnj z) = prime_elem z", "using prime_elem_gauss_cnj[of z] prime_elem_gauss_cnj[of \"gauss_cnj z\"]"], ["proof (prove)\nusing this:\n  prime_elem z \\<Longrightarrow> prime_elem (gauss_cnj z)\n  prime_elem (gauss_cnj z) \\<Longrightarrow>\n  prime_elem (gauss_cnj (gauss_cnj z))\n\ngoal (1 subgoal):\n 1. prime_elem (gauss_cnj z) = prime_elem z", "by auto"], ["", "subsubsection \\<open>The factorisation of 2\\<close>"], ["", "text \\<open>\n  2 factors as $-i (1 + i)^2$ in the Gaussian integers, where $-i$ is a unit and\n  $1 + i$ is prime.\n\\<close>"], ["", "lemma gauss_int_2_eq: \"2 = -\\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2", "by (simp add: gauss_int_eq_iff power2_eq_square)"], ["", "lemma prime_elem_one_plus_i_gauss_int: \"prime_elem (1 + \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem (1 + \\<i>\\<^sub>\\<int>)", "by (rule prime_gauss_int_norm_imp_prime_elem) (auto simp: gauss_int_norm_def)"], ["", "lemma prime_one_plus_i_gauss_int: \"prime (1 + \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (1 + \\<i>\\<^sub>\\<int>)", "by (simp add: prime_def prime_elem_one_plus_i_gauss_int\n                gauss_int_eq_iff normalize_gauss_int_def)"], ["", "lemma prime_factorization_2_gauss_int:\n  \"prime_factorization (2 :: gauss_int) = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "have \"prime_factorization (2 :: gauss_int) =\n        (prime_factorization (prod_mset {#1 + gauss_i, 1 + gauss_i#}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization 2 =\n    prime_factorization\n     (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#})", "by (subst prime_factorization_unique) (auto simp: gauss_int_eq_iff normalize_gauss_int_def)"], ["proof (state)\nthis:\n  prime_factorization 2 =\n  prime_factorization\n   (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#})\n\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "also"], ["proof (state)\nthis:\n  prime_factorization 2 =\n  prime_factorization\n   (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#})\n\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "have \"prime_factorization (prod_mset {#1 + gauss_i, 1 + gauss_i#}) =\n               {#1 + gauss_i, 1 + gauss_i#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization\n     (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}) =\n    {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "using prime_one_plus_i_gauss_int"], ["proof (prove)\nusing this:\n  prime (1 + \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. prime_factorization\n     (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}) =\n    {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "by (subst prime_factorization_prod_mset_primes) auto"], ["proof (state)\nthis:\n  prime_factorization\n   (\\<Prod>\\<^sub># {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}) =\n  {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}\n\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "finally"], ["proof (chain)\npicking this:\n  prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}\n\ngoal (1 subgoal):\n 1. prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}", "."], ["proof (state)\nthis:\n  prime_factorization 2 = {#1 + \\<i>\\<^sub>\\<int>, 1 + \\<i>\\<^sub>\\<int>#}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Inert primes\\<close>"], ["", "text \\<open>\n  Any \\<open>\\<int>\\<close>-prime congruent 3 modulo 4 is also a Gaussian prime. These primes are called\n  \\<^emph>\\<open>inert\\<close>, because they do not decompose when moving from \\<open>\\<int>\\<close> to $\\mathbb{Z}[i]$.\n\\<close>"], ["", "lemma gauss_int_norm_not_3_mod_4: \"[gauss_int_norm z \\<noteq> 3] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "have A: \"ReZ z mod 4 \\<in> {0..3}\" \"ImZ z mod 4 \\<in> {0..3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ z mod 4 \\<in> {0..3} &&& ImZ z mod 4 \\<in> {0..3}", "by auto"], ["proof (state)\nthis:\n  ReZ z mod 4 \\<in> {0..3}\n  ImZ z mod 4 \\<in> {0..3}\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "have B: \"{0..3} = {0, 1, 2, 3 :: int}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..3} = {0, 1, 2, 3}", "by auto"], ["proof (state)\nthis:\n  {0..3} = {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "have \"[ReZ z ^ 2 + ImZ z ^ 2 = (ReZ z mod 4) ^ 2 + (ImZ z mod 4) ^ 2] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(ReZ z)\\<^sup>2 +\n     (ImZ z)\\<^sup>2 = (ReZ z mod 4)\\<^sup>2 +\n                       (ImZ z mod 4)\\<^sup>2] (mod 4)", "by (intro cong_add cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [(ReZ z)\\<^sup>2 +\n   (ImZ z)\\<^sup>2 = (ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2] (mod 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "moreover"], ["proof (state)\nthis:\n  [(ReZ z)\\<^sup>2 +\n   (ImZ z)\\<^sup>2 = (ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2] (mod 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "have \"((ReZ z mod 4) ^ 2 + (ImZ z mod 4) ^ 2) mod 4 \\<noteq> 3 mod 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4", "using A"], ["proof (prove)\nusing this:\n  ReZ z mod 4 \\<in> {0..3}\n  ImZ z mod 4 \\<in> {0..3}\n\ngoal (1 subgoal):\n 1. ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4", "unfolding B"], ["proof (prove)\nusing this:\n  ReZ z mod 4 \\<in> {0, 1, 2, 3}\n  ImZ z mod 4 \\<in> {0, 1, 2, 3}\n\ngoal (1 subgoal):\n 1. ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4", "by auto"], ["proof (state)\nthis:\n  ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "ultimately"], ["proof (chain)\npicking this:\n  [(ReZ z)\\<^sup>2 +\n   (ImZ z)\\<^sup>2 = (ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2] (mod 4)\n  ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4", "have \"[ReZ z ^ 2 + ImZ z ^ 2 \\<noteq> 3] (mod 4)\""], ["proof (prove)\nusing this:\n  [(ReZ z)\\<^sup>2 +\n   (ImZ z)\\<^sup>2 = (ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2] (mod 4)\n  ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4\n\ngoal (1 subgoal):\n 1. [(ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<noteq> 3] (mod 4)", "unfolding cong_def"], ["proof (prove)\nusing this:\n  ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2) mod 4 =\n  ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4\n  ((ReZ z mod 4)\\<^sup>2 + (ImZ z mod 4)\\<^sup>2) mod 4 \\<noteq> 3 mod 4\n\ngoal (1 subgoal):\n 1. ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2) mod 4 \\<noteq> 3 mod 4", "by metis"], ["proof (state)\nthis:\n  [(ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "hence \"[int (nat (ReZ z ^ 2 + ImZ z ^ 2)) \\<noteq> int 3] (mod (int 4))\""], ["proof (prove)\nusing this:\n  [(ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2 \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. [int (nat ((ReZ z)\\<^sup>2 +\n               (ImZ z)\\<^sup>2)) \\<noteq> int 3] (mod int 4)", "by simp"], ["proof (state)\nthis:\n  [int (nat ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2)) \\<noteq> int 3] (mod int 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [int (nat ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2)) \\<noteq> int 3] (mod int 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm z \\<noteq> 3] (mod 4)", "unfolding gauss_int_norm_def"], ["proof (prove)\nusing this:\n  [int (nat ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2)) \\<noteq> int 3] (mod int 4)\n\ngoal (1 subgoal):\n 1. [nat ((ReZ z)\\<^sup>2 + (ImZ z)\\<^sup>2) \\<noteq> 3] (mod 4)", "by (subst (asm) cong_int_iff)"], ["proof (state)\nthis:\n  [gauss_int_norm z \\<noteq> 3] (mod 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_elem_gauss_int_of_nat:\n  fixes n :: nat\n  assumes prime: \"prime n\" and \"[n = 3] (mod 4)\"\n  shows   \"prime_elem (of_nat n :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem (of_nat n)", "proof (intro irreducible_imp_prime_elem irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. of_nat n \\<noteq> 0\n 2. \\<not> is_unit (of_nat n)\n 3. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from assms"], ["proof (chain)\npicking this:\n  prime n\n  [n = 3] (mod 4)", "show \"of_nat n \\<noteq> (0 :: gauss_int)\""], ["proof (prove)\nusing this:\n  prime n\n  [n = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. of_nat n \\<noteq> 0", "by (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  of_nat n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<not> is_unit (of_nat n)\n 2. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> is_unit (of_nat n)\n 2. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "show \"\\<not>is_unit (of_nat n :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit (of_nat n)", "using assms"], ["proof (prove)\nusing this:\n  prime n\n  [n = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit (of_nat n)", "by (subst is_unit_gauss_int_iff) (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  \\<not> is_unit (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "fix a b :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume *: \"of_nat n = a * b\""], ["proof (state)\nthis:\n  of_nat n = a * b\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "hence \"gauss_int_norm (a * b) = gauss_int_norm (of_nat n)\""], ["proof (prove)\nusing this:\n  of_nat n = a * b\n\ngoal (1 subgoal):\n 1. gauss_int_norm (a * b) = gauss_int_norm (of_nat n)", "by metis"], ["proof (state)\nthis:\n  gauss_int_norm (a * b) = gauss_int_norm (of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "hence *: \"gauss_int_norm a * gauss_int_norm b = n ^ 2\""], ["proof (prove)\nusing this:\n  gauss_int_norm (a * b) = gauss_int_norm (of_nat n)\n\ngoal (1 subgoal):\n 1. gauss_int_norm a * gauss_int_norm b = n\\<^sup>2", "by (simp add: gauss_int_norm_mult power2_eq_square flip: nat_mult_distrib)"], ["proof (state)\nthis:\n  gauss_int_norm a * gauss_int_norm b = n\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from prime_power_mult_nat[OF prime this]"], ["proof (chain)\npicking this:\n  \\<exists>i j. gauss_int_norm a = n ^ i \\<and> gauss_int_norm b = n ^ j", "obtain i j :: nat\n    where ij: \"gauss_int_norm a = n ^ i\" \"gauss_int_norm b = n ^ j\""], ["proof (prove)\nusing this:\n  \\<exists>i j. gauss_int_norm a = n ^ i \\<and> gauss_int_norm b = n ^ j\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>gauss_int_norm a = n ^ i; gauss_int_norm b = n ^ j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  gauss_int_norm a = n ^ i\n  gauss_int_norm b = n ^ j\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "have \"i + j = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + j = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + j = 2", "have \"n ^ (i + j) = n ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n ^ (i + j) = n\\<^sup>2", "using ij *"], ["proof (prove)\nusing this:\n  gauss_int_norm a = n ^ i\n  gauss_int_norm b = n ^ j\n  gauss_int_norm a * gauss_int_norm b = n\\<^sup>2\n\ngoal (1 subgoal):\n 1. n ^ (i + j) = n\\<^sup>2", "by (simp add: power_add)"], ["proof (state)\nthis:\n  n ^ (i + j) = n\\<^sup>2\n\ngoal (1 subgoal):\n 1. i + j = 2", "from prime_power_inj[OF prime this]"], ["proof (chain)\npicking this:\n  i + j = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  i + j = 2\n\ngoal (1 subgoal):\n 1. i + j = 2", "by simp"], ["proof (state)\nthis:\n  i + j = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i + j = 2\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "hence \"i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\""], ["proof (prove)\nusing this:\n  i + j = 2\n\ngoal (1 subgoal):\n 1. i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0", "by auto"], ["proof (state)\nthis:\n  i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. of_nat n = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "thus \"is_unit a \\<or> is_unit b\""], ["proof (prove)\nusing this:\n  i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume \"i = 1 \\<and> j = 1\""], ["proof (state)\nthis:\n  i = 1 \\<and> j = 1\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "with ij"], ["proof (chain)\npicking this:\n  gauss_int_norm a = n ^ i\n  gauss_int_norm b = n ^ j\n  i = 1 \\<and> j = 1", "have \"gauss_int_norm a = n\""], ["proof (prove)\nusing this:\n  gauss_int_norm a = n ^ i\n  gauss_int_norm b = n ^ j\n  i = 1 \\<and> j = 1\n\ngoal (1 subgoal):\n 1. gauss_int_norm a = n", "by auto"], ["proof (state)\nthis:\n  gauss_int_norm a = n\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "hence \"[gauss_int_norm a = n] (mod 4)\""], ["proof (prove)\nusing this:\n  gauss_int_norm a = n\n\ngoal (1 subgoal):\n 1. [gauss_int_norm a = n] (mod 4)", "by simp"], ["proof (state)\nthis:\n  [gauss_int_norm a = n] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "also"], ["proof (state)\nthis:\n  [gauss_int_norm a = n] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "have \"[n = 3] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [n = 3] (mod 4)", "by fact"], ["proof (state)\nthis:\n  [n = 3] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "finally"], ["proof (chain)\npicking this:\n  [gauss_int_norm a = 3] (mod 4)", "have \"[gauss_int_norm a = 3] (mod 4)\""], ["proof (prove)\nusing this:\n  [gauss_int_norm a = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. [gauss_int_norm a = 3] (mod 4)", "."], ["proof (state)\nthis:\n  [gauss_int_norm a = 3] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "moreover"], ["proof (state)\nthis:\n  [gauss_int_norm a = 3] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "have \"[gauss_int_norm a \\<noteq> 3] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [gauss_int_norm a \\<noteq> 3] (mod 4)", "by (rule gauss_int_norm_not_3_mod_4)"], ["proof (state)\nthis:\n  [gauss_int_norm a \\<noteq> 3] (mod 4)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "ultimately"], ["proof (chain)\npicking this:\n  [gauss_int_norm a = 3] (mod 4)\n  [gauss_int_norm a \\<noteq> 3] (mod 4)", "show ?thesis"], ["proof (prove)\nusing this:\n  [gauss_int_norm a = 3] (mod 4)\n  [gauss_int_norm a \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by contradiction"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal (2 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> is_unit a \\<or> is_unit b\n 2. i = 2 \\<and> j = 0 \\<Longrightarrow> is_unit a \\<or> is_unit b", "qed (use ij in \\<open>auto simp: is_unit_gauss_int_iff'\\<close>)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem prime_gauss_int_of_nat:\n  fixes n :: nat\n  assumes prime: \"prime n\" and \"[n = 3] (mod 4)\"\n  shows   \"prime (of_nat n :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (of_nat n)", "using prime_elem_gauss_int_of_nat[OF assms]"], ["proof (prove)\nusing this:\n  prime_elem (of_nat n)\n\ngoal (1 subgoal):\n 1. prime (of_nat n)", "unfolding prime_def"], ["proof (prove)\nusing this:\n  prime_elem (of_nat n)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat n) \\<and> normalize (of_nat n) = of_nat n", "by simp"], ["", "subsubsection \\<open>Non-inert primes\\<close>"], ["", "text \\<open>\n  Any \\<open>\\<int>\\<close>-prime congruent 1 modulo 4 factors into two conjugate Gaussian primes.\n\\<close>"], ["", "lemma minimal_QuadRes_neg1:\n  assumes \"QuadRes n (-1)\" \"n > 1\" \"odd n\"\n  obtains x :: nat where \"x \\<le> (n - 1) div 2\" and \"[x ^ 2 + 1 = 0] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>QuadRes n (-1)\\<close>"], ["proof (chain)\npicking this:\n  QuadRes (int n) (- 1)", "obtain x where \"[x ^ 2 = (-1)] (mod (int n))\""], ["proof (prove)\nusing this:\n  QuadRes (int n) (- 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        [x\\<^sup>2 = - 1] (mod int n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: QuadRes_def)"], ["proof (state)\nthis:\n  [x\\<^sup>2 = - 1] (mod int n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"[x ^ 2 + 1 = -1 + 1] (mod (int n))\""], ["proof (prove)\nusing this:\n  [x\\<^sup>2 = - 1] (mod int n)\n\ngoal (1 subgoal):\n 1. [x\\<^sup>2 + 1 = - 1 + 1] (mod int n)", "by (intro cong_add) auto"], ["proof (state)\nthis:\n  [x\\<^sup>2 + 1 = - 1 + 1] (mod int n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  [x\\<^sup>2 + 1 = - 1 + 1] (mod int n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x ^ 2 + 1 = int (nat \\<bar>x\\<bar> ^ 2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 = int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1)", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>2 + 1 = int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  [int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1) = - 1 + 1] (mod int n)", "have \"[int (nat \\<bar>x\\<bar> ^ 2 + 1) = int 0] (mod (int n))\""], ["proof (prove)\nusing this:\n  [int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1) = - 1 + 1] (mod int n)\n\ngoal (1 subgoal):\n 1. [int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1) = int 0] (mod int n)", "by simp"], ["proof (state)\nthis:\n  [int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1) = int 0] (mod int n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"[nat \\<bar>x\\<bar> ^ 2 + 1 = 0] (mod n)\""], ["proof (prove)\nusing this:\n  [int ((nat \\<bar>x\\<bar>)\\<^sup>2 + 1) = int 0] (mod int n)\n\ngoal (1 subgoal):\n 1. [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)", "by (subst (asm) cong_int_iff)"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define x' where\n    \"x' = (if nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 then nat \\<bar>x\\<bar> mod n else n - (nat \\<bar>x\\<bar> mod n))\""], ["proof (state)\nthis:\n  x' =\n  (if nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n   then nat \\<bar>x\\<bar> mod n else n - nat \\<bar>x\\<bar> mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have x'_quadres: \"[x' ^ 2 + 1 = 0] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x'\\<^sup>2 + 1 = 0] (mod n)", "proof (cases \"nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "case True"], ["proof (state)\nthis:\n  nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "hence \"[x' ^ 2 + 1 = (nat \\<bar>x\\<bar> mod n) ^ 2 + 1] (mod n)\""], ["proof (prove)\nusing this:\n  nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n\ngoal (1 subgoal):\n 1. [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)", "by (simp add: x'_def)"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[(nat \\<bar>x\\<bar> mod n) ^ 2 + 1 = nat \\<bar>x\\<bar> ^ 2 + 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n     1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)", "by (intro cong_add cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n   1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n   1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[nat \\<bar>x\\<bar> ^ 2 + 1 = 0] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)", "by fact"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (2 subgoals):\n 1. nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)\n 2. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "finally"], ["proof (chain)\npicking this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. [x'\\<^sup>2 + 1 = 0] (mod n)", "."], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "case False"], ["proof (state)\nthis:\n  \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "hence \"[int (x' ^ 2 + 1) = (int n - int (nat \\<bar>x\\<bar> mod n)) ^ 2 + 1] (mod int n)\""], ["proof (prove)\nusing this:\n  \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n\ngoal (1 subgoal):\n 1. [int (x'\\<^sup>2 +\n          1) = (int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n               1] (mod int n)", "using \\<open>n > 1\\<close>"], ["proof (prove)\nusing this:\n  \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2\n  1 < n\n\ngoal (1 subgoal):\n 1. [int (x'\\<^sup>2 +\n          1) = (int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n               1] (mod int n)", "by (simp add: x'_def of_nat_diff add_ac)"], ["proof (state)\nthis:\n  [int (x'\\<^sup>2 +\n        1) = (int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n             1] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [int (x'\\<^sup>2 +\n        1) = (int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n             1] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[(int n - int (nat \\<bar>x\\<bar> mod n)) ^ 2 + 1 =\n                (0 - int (nat \\<bar>x\\<bar> mod n)) ^ 2 + 1] (mod int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n     1 = (0 - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 + 1] (mod int n)", "by (intro cong_add cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [(int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n   1 = (0 - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 + 1] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [(int n - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n   1 = (0 - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 + 1] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[(0 - int (nat \\<bar>x\\<bar> mod n)) ^ 2 + 1 = int ((nat \\<bar>x\\<bar> mod n) ^ 2 + 1)] (mod (int n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(0 - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n     1 = int ((nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1)] (mod int n)", "by (simp add: add_ac)"], ["proof (state)\nthis:\n  [(0 - int (nat \\<bar>x\\<bar> mod n))\\<^sup>2 +\n   1 = int ((nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1)] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "finally"], ["proof (chain)\npicking this:\n  [int (x'\\<^sup>2 +\n        1) = int ((nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1)] (mod int n)", "have \"[x' ^ 2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)\""], ["proof (prove)\nusing this:\n  [int (x'\\<^sup>2 +\n        1) = int ((nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1)] (mod int n)\n\ngoal (1 subgoal):\n 1. [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)", "by (subst (asm) cong_int_iff)"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = (nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[(nat \\<bar>x\\<bar> mod n)\\<^sup>2 + 1 = nat \\<bar>x\\<bar> ^ 2 + 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n     1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)", "by (intro cong_add cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n   1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "also"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar> mod n)\\<^sup>2 +\n   1 = (nat \\<bar>x\\<bar>)\\<^sup>2 + 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "have \"[nat \\<bar>x\\<bar> ^ 2 + 1 = 0] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)", "by fact"], ["proof (state)\nthis:\n  [(nat \\<bar>x\\<bar>)\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. \\<not> nat \\<bar>x\\<bar> mod n \\<le> (n - 1) div 2 \\<Longrightarrow>\n    [x'\\<^sup>2 + 1 = 0] (mod n)", "finally"], ["proof (chain)\npicking this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. [x'\\<^sup>2 + 1 = 0] (mod n)", "."], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have x'_le: \"x' \\<le> (n - 1) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<le> (n - 1) div 2", "using \\<open>odd n\\<close>"], ["proof (prove)\nusing this:\n  odd n\n\ngoal (1 subgoal):\n 1. x' \\<le> (n - 1) div 2", "by (auto elim!: oddE simp: x'_def)"], ["proof (state)\nthis:\n  x' \\<le> (n - 1) div 2\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (n - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n  x' \\<le> (n - 1) div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  [x'\\<^sup>2 + 1 = 0] (mod n)\n  x' \\<le> (n - 1) div 2\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of x'])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Let \\<open>p\\<close> be some prime number that is congruent 1 modulo 4.\n\\<close>"], ["", "locale noninert_gauss_int_prime =\n  fixes p :: nat\n  assumes prime_p: \"prime p\" and cong_1_p: \"[p = 1] (mod 4)\"\nbegin"], ["", "lemma p_gt_2: \"p > 2\" and odd_p: \"odd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < p &&& odd p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 < p\n 2. odd p", "from prime_p and cong_1_p"], ["proof (chain)\npicking this:\n  prime p\n  [p = 1] (mod 4)", "have \"p > 1\" \"p \\<noteq> 2\""], ["proof (prove)\nusing this:\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. 1 < p &&& p \\<noteq> 2", "by (auto simp: prime_gt_Suc_0_nat cong_def)"], ["proof (state)\nthis:\n  1 < p\n  p \\<noteq> 2\n\ngoal (2 subgoals):\n 1. 2 < p\n 2. odd p", "thus \"p > 2\""], ["proof (prove)\nusing this:\n  1 < p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p", "by auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. odd p", "with prime_p"], ["proof (chain)\npicking this:\n  prime p\n  2 < p", "show \"odd p\""], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n\ngoal (1 subgoal):\n 1. odd p", "using primes_dvd_imp_eq two_is_prime_nat"], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n  \\<lbrakk>prime ?p; prime ?q; ?p dvd ?q\\<rbrakk> \\<Longrightarrow> ?p = ?q\n  prime 2\n\ngoal (1 subgoal):\n 1. odd p", "by blast"], ["proof (state)\nthis:\n  odd p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  -1 is a quadratic residue modulo \\<open>p\\<close>, so there exists some \\<open>x\\<close> such that\n  $x^2 + 1$ is divisible by \\<open>p\\<close>. Moreover, we can choose \\<open>x\\<close> such that it is positive and\n  no greater than $\\frac{1}{2}(p-1)$:\n\\<close>"], ["", "lemma minimal_QuadRes_neg1:\n  obtains x where \"x > 0\" \"x \\<le> (p - 1) div 2\" \"[x ^ 2 + 1 = 0] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"[Legendre (-1) (int p) = (- 1) ^ ((p - 1) div 2)] (mod (int p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)] (mod int p)", "using prime_p p_gt_2"], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n\ngoal (1 subgoal):\n 1. [Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)] (mod int p)", "by (intro euler_criterion) auto"], ["proof (state)\nthis:\n  [Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)] (mod int p)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  [Legendre (- 1) (int p) = (- 1) ^ ((p - 1) div 2)] (mod int p)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"[p - 1 = 1 - 1] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [p - 1 = 1 - 1] (mod 4)", "using p_gt_2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. [p - 1 = 1 - 1] (mod 4)", "by (intro cong_diff_nat cong_refl) (use cong_1_p in auto)"], ["proof (state)\nthis:\n  [p - 1 = 1 - 1] (mod 4)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"2 * 2 dvd p - 1\""], ["proof (prove)\nusing this:\n  [p - 1 = 1 - 1] (mod 4)\n\ngoal (1 subgoal):\n 1. 2 * 2 dvd p - 1", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  2 * 2 dvd p - 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"even ((p - 1) div 2)\""], ["proof (prove)\nusing this:\n  2 * 2 dvd p - 1\n\ngoal (1 subgoal):\n 1. even ((p - 1) div 2)", "using dvd_mult_imp_div"], ["proof (prove)\nusing this:\n  2 * 2 dvd p - 1\n  ?a * ?c dvd ?b \\<Longrightarrow> ?a dvd ?b div ?c\n\ngoal (1 subgoal):\n 1. even ((p - 1) div 2)", "by blast"], ["proof (state)\nthis:\n  even ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"(-1) ^ ((p - 1) div 2) = (1 :: int)\""], ["proof (prove)\nusing this:\n  even ((p - 1) div 2)\n\ngoal (1 subgoal):\n 1. (- 1) ^ ((p - 1) div 2) = 1", "by simp"], ["proof (state)\nthis:\n  (- 1) ^ ((p - 1) div 2) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  [Legendre (- 1) (int p) = 1] (mod int p)", "have \"Legendre (-1) (int p) mod p = 1\""], ["proof (prove)\nusing this:\n  [Legendre (- 1) (int p) = 1] (mod int p)\n\ngoal (1 subgoal):\n 1. Legendre (- 1) (int p) mod int p = 1", "using p_gt_2"], ["proof (prove)\nusing this:\n  [Legendre (- 1) (int p) = 1] (mod int p)\n  2 < p\n\ngoal (1 subgoal):\n 1. Legendre (- 1) (int p) mod int p = 1", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  Legendre (- 1) (int p) mod int p = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"Legendre (-1) (int p) = 1\""], ["proof (prove)\nusing this:\n  Legendre (- 1) (int p) mod int p = 1\n\ngoal (1 subgoal):\n 1. Legendre (- 1) (int p) = 1", "using p_gt_2"], ["proof (prove)\nusing this:\n  Legendre (- 1) (int p) mod int p = 1\n  2 < p\n\ngoal (1 subgoal):\n 1. Legendre (- 1) (int p) = 1", "by (auto simp: Legendre_def cong_def zmod_minus1 split: if_splits)"], ["proof (state)\nthis:\n  Legendre (- 1) (int p) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"QuadRes p (-1)\""], ["proof (prove)\nusing this:\n  Legendre (- 1) (int p) = 1\n\ngoal (1 subgoal):\n 1. QuadRes (int p) (- 1)", "by (simp add: Legendre_def split: if_splits)"], ["proof (state)\nthis:\n  QuadRes (int p) (- 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from minimal_QuadRes_neg1[OF this] p_gt_2 odd_p"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 < p; odd p;\n   \\<And>x.\n      \\<lbrakk>x \\<le> (p - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  2 < p\n  odd p", "obtain x where x: \"x \\<le> (p - 1) div 2\" \"[x ^ 2 + 1 = 0] (mod p)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < p; odd p;\n   \\<And>x.\n      \\<lbrakk>x \\<le> (p - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  2 < p\n  odd p\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<le> (p - 1) div 2; [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x", "using x p_gt_2"], ["proof (prove)\nusing this:\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n  2 < p\n\ngoal (1 subgoal):\n 1. 0 < x", "by (auto intro!: Nat.gr0I simp: cong_def)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from x and this"], ["proof (chain)\npicking this:\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n  0 < x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n  0 < x\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of x]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can show from this that \\<open>p\\<close> is not prime as a Gaussian integer.\n\\<close>"], ["", "lemma not_prime: \"\\<not>prime_elem (of_nat p :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prime_elem (of_nat p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "assume prime: \"prime_elem (of_nat p :: gauss_int)\""], ["proof (state)\nthis:\n  prime_elem (of_nat p)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "obtain x where x: \"x > 0\" \"x \\<le> (p - 1) div 2\" \"[x ^ 2 + 1 = 0] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  minimal_QuadRes_neg1"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n       [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x; x \\<le> (p - 1) div 2;\n         [x\\<^sup>2 + 1 = 0] (mod p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  0 < x\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "have \"of_nat p dvd (of_nat (x ^ 2 + 1) :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p dvd of_nat (x\\<^sup>2 + 1)", "using x"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n\ngoal (1 subgoal):\n 1. of_nat p dvd of_nat (x\\<^sup>2 + 1)", "by (intro of_nat_dvd_of_nat) (auto simp: cong_0_iff)"], ["proof (state)\nthis:\n  of_nat p dvd of_nat (x\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  of_nat p dvd of_nat (x\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "have eq: \"of_nat (x ^ 2 + 1) = ((of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>) :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (x\\<^sup>2 + 1) =\n    (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "using \\<open>x > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. of_nat (x\\<^sup>2 + 1) =\n    (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "by (simp add: algebra_simps gauss_int_eq_iff power2_eq_square of_nat_diff)"], ["proof (state)\nthis:\n  of_nat (x\\<^sup>2 + 1) =\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "have \"of_nat p dvd ((of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>) :: gauss_int)\""], ["proof (prove)\nusing this:\n  of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. of_nat p dvd\n    (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "."], ["proof (state)\nthis:\n  of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "from prime and this"], ["proof (chain)\npicking this:\n  prime_elem (of_nat p)\n  of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "have \"of_nat p dvd (of_nat x + \\<i>\\<^sub>\\<int> :: gauss_int) \\<or> of_nat p dvd (of_nat x - \\<i>\\<^sub>\\<int> :: gauss_int)\""], ["proof (prove)\nusing this:\n  prime_elem (of_nat p)\n  of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int> \\<or>\n    of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>", "by (rule prime_elem_dvd_multD)"], ["proof (state)\nthis:\n  of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int> \\<or>\n  of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "hence dvd: \"of_nat p dvd (of_nat x + \\<i>\\<^sub>\\<int> :: gauss_int)\" \"of_nat p dvd (of_nat x - \\<i>\\<^sub>\\<int> :: gauss_int)\""], ["proof (prove)\nusing this:\n  of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int> \\<or>\n  of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int> &&&\n    of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>", "by (auto dest: of_nat_dvd_imp_dvd_gauss_cnj)"], ["proof (state)\nthis:\n  of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int>\n  of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "have \"of_nat (p ^ 2) = (of_nat p * of_nat p :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (p\\<^sup>2) = of_nat p * of_nat p", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  of_nat (p\\<^sup>2) = of_nat p * of_nat p\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  of_nat (p\\<^sup>2) = of_nat p * of_nat p\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "from dvd"], ["proof (chain)\npicking this:\n  of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int>\n  of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>", "have \"\\<dots> dvd ((of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>))\""], ["proof (prove)\nusing this:\n  of_nat p dvd of_nat x + \\<i>\\<^sub>\\<int>\n  of_nat p dvd of_nat x - \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. of_nat p * of_nat p dvd\n    (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)", "by (intro mult_dvd_mono)"], ["proof (state)\nthis:\n  of_nat p * of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  of_nat p * of_nat p dvd\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "have \"\\<dots> = of_nat (x ^ 2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>) =\n    of_nat (x\\<^sup>2 + 1)", "by (rule eq [symmetric])"], ["proof (state)\nthis:\n  (of_nat x + \\<i>\\<^sub>\\<int>) * (of_nat x - \\<i>\\<^sub>\\<int>) =\n  of_nat (x\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  of_nat (p\\<^sup>2) dvd of_nat (x\\<^sup>2 + 1)", "have \"p ^ 2 dvd (x ^ 2 + 1)\""], ["proof (prove)\nusing this:\n  of_nat (p\\<^sup>2) dvd of_nat (x\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. p\\<^sup>2 dvd x\\<^sup>2 + 1", "by (subst (asm) of_nat_dvd_of_nat_gauss_int_iff)"], ["proof (state)\nthis:\n  p\\<^sup>2 dvd x\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "hence \"p ^ 2 \\<le> x ^ 2 + 1\""], ["proof (prove)\nusing this:\n  p\\<^sup>2 dvd x\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. p\\<^sup>2 \\<le> x\\<^sup>2 + 1", "by (intro dvd_imp_le) auto"], ["proof (state)\nthis:\n  p\\<^sup>2 \\<le> x\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  p\\<^sup>2 \\<le> x\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "have \"p ^ 2 > x ^ 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "have \"x ^ 2 + 1 \\<le> ((p - 1) div 2) ^ 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 \\<le> ((p - 1) div 2)\\<^sup>2 + 1", "using x"], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> (p - 1) div 2\n  [x\\<^sup>2 + 1 = 0] (mod p)\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 \\<le> ((p - 1) div 2)\\<^sup>2 + 1", "by (intro add_mono power_mono) auto"], ["proof (state)\nthis:\n  x\\<^sup>2 + 1 \\<le> ((p - 1) div 2)\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 + 1 \\<le> ((p - 1) div 2)\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "have \"\\<dots> \\<le> (p - 1) ^ 2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p - 1) div 2)\\<^sup>2 + 1 \\<le> (p - 1)\\<^sup>2 + 1", "by auto"], ["proof (state)\nthis:\n  ((p - 1) div 2)\\<^sup>2 + 1 \\<le> (p - 1)\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "also"], ["proof (state)\nthis:\n  ((p - 1) div 2)\\<^sup>2 + 1 \\<le> (p - 1)\\<^sup>2 + 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "have \"(p - 1) * (p - 1) < (p - 1) * (p + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p - 1) * (p - 1) < (p - 1) * (p + 1)", "using p_gt_2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. (p - 1) * (p - 1) < (p - 1) * (p + 1)", "by (intro mult_strict_left_mono) auto"], ["proof (state)\nthis:\n  (p - 1) * (p - 1) < (p - 1) * (p + 1)\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "hence \"(p - 1) ^ 2 + 1 < p ^ 2\""], ["proof (prove)\nusing this:\n  (p - 1) * (p - 1) < (p - 1) * (p + 1)\n\ngoal (1 subgoal):\n 1. (p - 1)\\<^sup>2 + 1 < p\\<^sup>2", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  (p - 1)\\<^sup>2 + 1 < p\\<^sup>2\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>2 + 1 < p\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>2 + 1 < p\\<^sup>2\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 1 < p\\<^sup>2", "."], ["proof (state)\nthis:\n  x\\<^sup>2 + 1 < p\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x\\<^sup>2 + 1 < p\\<^sup>2\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  p\\<^sup>2 \\<le> x\\<^sup>2 + 1\n  x\\<^sup>2 + 1 < p\\<^sup>2", "show False"], ["proof (prove)\nusing this:\n  p\\<^sup>2 \\<le> x\\<^sup>2 + 1\n  x\\<^sup>2 + 1 < p\\<^sup>2\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Any prime factor of \\<open>p\\<close> in the Gaussian integers must have norm \\<open>p\\<close>.\n\\<close>"], ["", "lemma norm_prime_divisor:\n  fixes q :: gauss_int\n  assumes q: \"prime_elem q\" \"q dvd of_nat p\"\n  shows \"gauss_int_norm q = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "from assms"], ["proof (chain)\npicking this:\n  prime_elem q\n  q dvd of_nat p", "obtain r where r: \"of_nat p = q * r\""], ["proof (prove)\nusing this:\n  prime_elem q\n  q dvd of_nat p\n\ngoal (1 subgoal):\n 1. (\\<And>r. of_nat p = q * r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  of_nat p = q * r\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "have \"p ^ 2 = gauss_int_norm (of_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sup>2 = gauss_int_norm (of_nat p)", "by simp"], ["proof (state)\nthis:\n  p\\<^sup>2 = gauss_int_norm (of_nat p)\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "also"], ["proof (state)\nthis:\n  p\\<^sup>2 = gauss_int_norm (of_nat p)\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "have \"\\<dots> = gauss_int_norm q * gauss_int_norm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat p) = gauss_int_norm q * gauss_int_norm r", "by (auto simp: r gauss_int_norm_mult)"], ["proof (state)\nthis:\n  gauss_int_norm (of_nat p) = gauss_int_norm q * gauss_int_norm r\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "finally"], ["proof (chain)\npicking this:\n  p\\<^sup>2 = gauss_int_norm q * gauss_int_norm r", "have *: \"gauss_int_norm q * gauss_int_norm r = p ^ 2\""], ["proof (prove)\nusing this:\n  p\\<^sup>2 = gauss_int_norm q * gauss_int_norm r\n\ngoal (1 subgoal):\n 1. gauss_int_norm q * gauss_int_norm r = p\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  gauss_int_norm q * gauss_int_norm r = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "hence \"\\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j\""], ["proof (prove)\nusing this:\n  gauss_int_norm q * gauss_int_norm r = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j", "using prime_p"], ["proof (prove)\nusing this:\n  gauss_int_norm q * gauss_int_norm r = p\\<^sup>2\n  prime p\n\ngoal (1 subgoal):\n 1. \\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j", "by (intro prime_power_mult_nat)"], ["proof (state)\nthis:\n  \\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "then"], ["proof (chain)\npicking this:\n  \\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j", "obtain i j where ij: \"gauss_int_norm q = p ^ i\" \"gauss_int_norm r = p ^ j\""], ["proof (prove)\nusing this:\n  \\<exists>i j. gauss_int_norm q = p ^ i \\<and> gauss_int_norm r = p ^ j\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>gauss_int_norm q = p ^ i; gauss_int_norm r = p ^ j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  gauss_int_norm q = p ^ i\n  gauss_int_norm r = p ^ j\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "have ij_eq_2: \"i + j = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + j = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + j = 2", "from *"], ["proof (chain)\npicking this:\n  gauss_int_norm q * gauss_int_norm r = p\\<^sup>2", "have \"p ^ (i + j) = p ^ 2\""], ["proof (prove)\nusing this:\n  gauss_int_norm q * gauss_int_norm r = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. p ^ (i + j) = p\\<^sup>2", "by (simp add: power_add ij)"], ["proof (state)\nthis:\n  p ^ (i + j) = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. i + j = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  p ^ (i + j) = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. i + j = 2", "using p_gt_2"], ["proof (prove)\nusing this:\n  p ^ (i + j) = p\\<^sup>2\n  2 < p\n\ngoal (1 subgoal):\n 1. i + j = 2", "by (subst (asm) power_inject_exp) auto"], ["proof (state)\nthis:\n  i + j = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i + j = 2\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "hence \"i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\""], ["proof (prove)\nusing this:\n  i + j = 2\n\ngoal (1 subgoal):\n 1. i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0", "by auto"], ["proof (state)\nthis:\n  i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "hence \"i = 1\""], ["proof (prove)\nusing this:\n  i = 0 \\<and> j = 2 \\<or> i = 1 \\<and> j = 1 \\<or> i = 2 \\<and> j = 0\n\ngoal (1 subgoal):\n 1. i = 1", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> i = 1\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> i = 1\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> i = 1", "assume \"i = 2 \\<and> j = 0\""], ["proof (state)\nthis:\n  i = 2 \\<and> j = 0\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> i = 1\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> i = 1\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> i = 1", "hence \"is_unit r\""], ["proof (prove)\nusing this:\n  i = 2 \\<and> j = 0\n\ngoal (1 subgoal):\n 1. is_unit r", "using ij"], ["proof (prove)\nusing this:\n  i = 2 \\<and> j = 0\n  gauss_int_norm q = p ^ i\n  gauss_int_norm r = p ^ j\n\ngoal (1 subgoal):\n 1. is_unit r", "by (simp add: gauss_int_norm_eq_Suc_0_iff)"], ["proof (state)\nthis:\n  is_unit r\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> i = 1\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> i = 1\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> i = 1", "hence \"prime_elem (of_nat p :: gauss_int)\""], ["proof (prove)\nusing this:\n  is_unit r\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p)", "using \\<open>prime_elem q\\<close>"], ["proof (prove)\nusing this:\n  is_unit r\n  prime_elem q\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat p)", "by (simp add: prime_elem_mult_unit_left r mult.commute[of _ r])"], ["proof (state)\nthis:\n  prime_elem (of_nat p)\n\ngoal (3 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> i = 1\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> i = 1\n 3. i = 2 \\<and> j = 0 \\<Longrightarrow> i = 1", "with not_prime"], ["proof (chain)\npicking this:\n  \\<not> prime_elem (of_nat p)\n  prime_elem (of_nat p)", "show \"i = 1\""], ["proof (prove)\nusing this:\n  \\<not> prime_elem (of_nat p)\n  prime_elem (of_nat p)\n\ngoal (1 subgoal):\n 1. i = 1", "by contradiction"], ["proof (state)\nthis:\n  i = 1\n\ngoal (2 subgoals):\n 1. i = 0 \\<and> j = 2 \\<Longrightarrow> i = 1\n 2. i = 1 \\<and> j = 1 \\<Longrightarrow> i = 1", "qed (use q ij in \\<open>auto simp: gauss_int_norm_eq_Suc_0_iff\\<close>)"], ["proof (state)\nthis:\n  i = 1\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 1\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "using ij"], ["proof (prove)\nusing this:\n  i = 1\n  gauss_int_norm q = p ^ i\n  gauss_int_norm r = p ^ j\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "by simp"], ["proof (state)\nthis:\n  gauss_int_norm q = p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now show two lemmas that characterise the two prime factors of \\<open>p\\<close> in the\n  Gaussian integers: they are two conjugates $x\\pm iy$ for positive integers \\<open>x\\<close> and \\<open>y\\<close> such\n  that $x^2 + y^2 = p$.\n\\<close>"], ["", "lemma prime_divisor_exists:\n  obtains q where \"prime q\" \"prime_elem (gauss_cnj q)\" \"ReZ q > 0\" \"ImZ q > 0\"\n                  \"of_nat p = q * gauss_cnj q\" \"gauss_int_norm q = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>q::gauss_int. q dvd of_nat p \\<and> prime q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. q dvd of_nat p \\<and> prime q", "by (rule prime_divisor_exists) (use prime_p in \\<open>auto simp: is_unit_gauss_int_iff'\\<close>)"], ["proof (state)\nthis:\n  \\<exists>q. q dvd of_nat p \\<and> prime q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. q dvd of_nat p \\<and> prime q", "obtain q :: gauss_int where q: \"prime q\" \"q dvd of_nat p\""], ["proof (prove)\nusing this:\n  \\<exists>q. q dvd of_nat p \\<and> prime q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; q dvd of_nat p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime q\n  q dvd of_nat p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>prime q\\<close>"], ["proof (chain)\npicking this:\n  prime q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"normalize q = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize q = q", "using q"], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n\ngoal (1 subgoal):\n 1. normalize q = q", "by simp"], ["proof (state)\nthis:\n  normalize q = q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence q_signs: \"ReZ q > 0\" \"ImZ q \\<ge> 0\""], ["proof (prove)\nusing this:\n  normalize q = q\n\ngoal (1 subgoal):\n 1. 0 < ReZ q &&& 0 \\<le> ImZ q", "by (subst (asm) normalized_gauss_int_iff; simp)+"], ["proof (state)\nthis:\n  0 < ReZ q\n  0 \\<le> ImZ q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from q"], ["proof (chain)\npicking this:\n  prime q\n  q dvd of_nat p", "have \"gauss_int_norm q = p\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "using norm_prime_divisor[of q]"], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n  \\<lbrakk>prime_elem q; q dvd of_nat p\\<rbrakk>\n  \\<Longrightarrow> gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p", "by simp"], ["proof (state)\nthis:\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  gauss_int_norm q = p", "have \"gauss_int_norm (gauss_cnj q) = p\""], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. gauss_int_norm (gauss_cnj q) = p", "by simp"], ["proof (state)\nthis:\n  gauss_int_norm (gauss_cnj q) = p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"prime_elem (gauss_cnj q)\""], ["proof (prove)\nusing this:\n  gauss_int_norm (gauss_cnj q) = p\n\ngoal (1 subgoal):\n 1. prime_elem (gauss_cnj q)", "using prime_p"], ["proof (prove)\nusing this:\n  gauss_int_norm (gauss_cnj q) = p\n  prime p\n\ngoal (1 subgoal):\n 1. prime_elem (gauss_cnj q)", "by (intro prime_gauss_int_norm_imp_prime_elem) auto"], ["proof (state)\nthis:\n  prime_elem (gauss_cnj q)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  prime_elem (gauss_cnj q)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"of_nat p = q * gauss_cnj q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p = q * gauss_cnj q", "using \\<open>gauss_int_norm q = p\\<close>"], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. of_nat p = q * gauss_cnj q", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  of_nat p = q * gauss_cnj q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  of_nat p = q * gauss_cnj q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"ImZ q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ImZ q \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "assume [simp]: \"ImZ q = 0\""], ["proof (state)\nthis:\n  ImZ q = 0\n\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "define m where \"m = nat (ReZ q)\""], ["proof (state)\nthis:\n  m = nat (ReZ q)\n\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "have [simp]: \"q = of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = of_nat m", "using q_signs"], ["proof (prove)\nusing this:\n  0 < ReZ q\n  0 \\<le> ImZ q\n\ngoal (1 subgoal):\n 1. q = of_nat m", "by (auto simp: gauss_int_eq_iff m_def)"], ["proof (state)\nthis:\n  q = of_nat m\n\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "with q"], ["proof (chain)\npicking this:\n  prime q\n  q dvd of_nat p\n  q = of_nat m", "have \"m dvd p\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n  q = of_nat m\n\ngoal (1 subgoal):\n 1. m dvd p", "by (simp add: of_nat_dvd_of_nat_gauss_int_iff)"], ["proof (state)\nthis:\n  m dvd p\n\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "with prime_p"], ["proof (chain)\npicking this:\n  prime p\n  m dvd p", "have \"m = 1 \\<or> m = p\""], ["proof (prove)\nusing this:\n  prime p\n  m dvd p\n\ngoal (1 subgoal):\n 1. m = 1 \\<or> m = p", "using prime_nat_iff"], ["proof (prove)\nusing this:\n  prime p\n  m dvd p\n  prime ?n =\n  (1 < ?n \\<and>\n   (\\<forall>m. m dvd ?n \\<longrightarrow> m = 1 \\<or> m = ?n))\n\ngoal (1 subgoal):\n 1. m = 1 \\<or> m = p", "by blast"], ["proof (state)\nthis:\n  m = 1 \\<or> m = p\n\ngoal (1 subgoal):\n 1. ImZ q = 0 \\<Longrightarrow> False", "with q"], ["proof (chain)\npicking this:\n  prime q\n  q dvd of_nat p\n  m = 1 \\<or> m = p", "show False"], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n  m = 1 \\<or> m = p\n\ngoal (1 subgoal):\n 1. False", "using not_prime"], ["proof (prove)\nusing this:\n  prime q\n  q dvd of_nat p\n  m = 1 \\<or> m = p\n  \\<not> prime_elem (of_nat p)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ImZ q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with q_signs"], ["proof (chain)\npicking this:\n  0 < ReZ q\n  0 \\<le> ImZ q\n  ImZ q \\<noteq> 0", "have \"ImZ q > 0\""], ["proof (prove)\nusing this:\n  0 < ReZ q\n  0 \\<le> ImZ q\n  ImZ q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < ImZ q", "by simp"], ["proof (state)\nthis:\n  0 < ImZ q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  gauss_int_norm q = p\n  prime_elem (gauss_cnj q)\n  of_nat p = q * gauss_cnj q\n  0 < ImZ q", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\n  prime_elem (gauss_cnj q)\n  of_nat p = q * gauss_cnj q\n  0 < ImZ q\n\ngoal (1 subgoal):\n 1. thesis", "using q q_signs"], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\n  prime_elem (gauss_cnj q)\n  of_nat p = q * gauss_cnj q\n  0 < ImZ q\n  prime q\n  q dvd of_nat p\n  0 < ReZ q\n  0 \\<le> ImZ q\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of q])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem prime_factorization:\n  obtains q1 q2\n  where \"prime q1\" \"prime q2\" \"prime_factorization (of_nat p) = {#q1, q2#}\" \n        \"gauss_int_norm q1 = p\" \"gauss_int_norm q2 = p\" \"q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\"\n        \"ReZ q1 > 0\" \"ImZ q1 > 0\" \"ReZ q1 > 0\" \"ImZ q2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain q where q: \"prime q\" \"prime_elem (gauss_cnj q)\" \"ReZ q > 0\" \"ImZ q > 0\"\n                    \"of_nat p = q * gauss_cnj q\" \"gauss_int_norm q = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisor_exists"], ["proof (prove)\nusing this:\n  (\\<And>q.\n      \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n       of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n         of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  prime q\n  prime_elem (gauss_cnj q)\n  0 < ReZ q\n  0 < ImZ q\n  of_nat p = q * gauss_cnj q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>prime q\\<close>"], ["proof (chain)\npicking this:\n  prime q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prime q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q' where \"q' = normalize (gauss_cnj q)\""], ["proof (state)\nthis:\n  q' = normalize (gauss_cnj q)\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"prime_factorization (of_nat p) = prime_factorization (prod_mset {#q, q'#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (of_nat p) =\n    prime_factorization (\\<Prod>\\<^sub># {#q, q'#})", "by (subst prime_factorization_unique) (auto simp: q q'_def)"], ["proof (state)\nthis:\n  prime_factorization (of_nat p) =\n  prime_factorization (\\<Prod>\\<^sub># {#q, q'#})\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  prime_factorization (of_nat p) =\n  prime_factorization (\\<Prod>\\<^sub># {#q, q'#})\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = {#q, q'#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (\\<Prod>\\<^sub># {#q, q'#}) = {#q, q'#}", "using q"], ["proof (prove)\nusing this:\n  prime q\n  prime_elem (gauss_cnj q)\n  0 < ReZ q\n  0 < ImZ q\n  of_nat p = q * gauss_cnj q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. prime_factorization (\\<Prod>\\<^sub># {#q, q'#}) = {#q, q'#}", "by (subst prime_factorization_prod_mset_primes) (auto simp: q'_def)"], ["proof (state)\nthis:\n  prime_factorization (\\<Prod>\\<^sub># {#q, q'#}) = {#q, q'#}\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  prime_factorization (of_nat p) = {#q, q'#}", "have \"prime_factorization (of_nat p) = {#q, q'#}\""], ["proof (prove)\nusing this:\n  prime_factorization (of_nat p) = {#q, q'#}\n\ngoal (1 subgoal):\n 1. prime_factorization (of_nat p) = {#q, q'#}", "."], ["proof (state)\nthis:\n  prime_factorization (of_nat p) = {#q, q'#}\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  prime_factorization (of_nat p) = {#q, q'#}\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q' = \\<i>\\<^sub>\\<int> * gauss_cnj q", "using q"], ["proof (prove)\nusing this:\n  prime q\n  prime_elem (gauss_cnj q)\n  0 < ReZ q\n  0 < ImZ q\n  of_nat p = q * gauss_cnj q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. q' = \\<i>\\<^sub>\\<int> * gauss_cnj q", "by (auto simp: normalize_gauss_int_def q'_def)"], ["proof (state)\nthis:\n  q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"prime q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime q'", "using q"], ["proof (prove)\nusing this:\n  prime q\n  prime_elem (gauss_cnj q)\n  0 < ReZ q\n  0 < ImZ q\n  of_nat p = q * gauss_cnj q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. prime q'", "by (auto simp: q'_def)"], ["proof (state)\nthis:\n  prime q'\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  prime_factorization (of_nat p) = {#q, q'#}\n  q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\n  prime q'", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factorization (of_nat p) = {#q, q'#}\n  q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\n  prime q'\n\ngoal (1 subgoal):\n 1. thesis", "using q"], ["proof (prove)\nusing this:\n  prime_factorization (of_nat p) = {#q, q'#}\n  q' = \\<i>\\<^sub>\\<int> * gauss_cnj q\n  prime q'\n  prime q\n  prime_elem (gauss_cnj q)\n  0 < ReZ q\n  0 < ImZ q\n  of_nat p = q * gauss_cnj q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of q q']) (auto simp: q'_def gauss_int_norm_mult)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  In particular, a consequence of this is that any prime congruent 1 modulo 4\n  can be written as a sum of squares of positive integers.\n\\<close>"], ["", "lemma prime_cong_1_mod_4_gauss_int_norm_exists:\n  fixes p :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\"\n  shows   \"\\<exists>z. gauss_int_norm z = p \\<and> ReZ z > 0 \\<and> ImZ z > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  [p = 1] (mod 4)", "interpret noninert_gauss_int_prime p"], ["proof (prove)\nusing this:\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. noninert_gauss_int_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "from prime_divisor_exists"], ["proof (chain)\npicking this:\n  (\\<And>q.\n      \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n       of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain q\n    where q: \"prime q\" \"of_nat p = q * gauss_cnj q\" \n             \"ReZ q > 0\" \"ImZ q > 0\" \"gauss_int_norm q = p\""], ["proof (prove)\nusing this:\n  (\\<And>q.\n      \\<lbrakk>prime q; prime_elem (gauss_cnj q); 0 < ReZ q; 0 < ImZ q;\n       of_nat p = q * gauss_cnj q; gauss_int_norm q = p\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; of_nat p = q * gauss_cnj q; 0 < ReZ q; 0 < ImZ q;\n         gauss_int_norm q = p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  prime q\n  of_nat p = q * gauss_cnj q\n  0 < ReZ q\n  0 < ImZ q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "have \"p = gauss_int_norm q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = gauss_int_norm q", "using q"], ["proof (prove)\nusing this:\n  prime q\n  of_nat p = q * gauss_cnj q\n  0 < ReZ q\n  0 < ImZ q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. p = gauss_int_norm q", "by simp"], ["proof (state)\nthis:\n  p = gauss_int_norm q\n\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = gauss_int_norm q\n\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "using q"], ["proof (prove)\nusing this:\n  p = gauss_int_norm q\n  prime q\n  of_nat p = q * gauss_cnj q\n  0 < ReZ q\n  0 < ImZ q\n  gauss_int_norm q = p\n\ngoal (1 subgoal):\n 1. \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z", "by blast"], ["proof (state)\nthis:\n  \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Full classification of Gaussian primes\\<close>"], ["", "text \\<open>\n  Any prime in the ring of Gaussian integers is of the form\n\n    \\<^item> \\<open>1 + \\<i>\\<^sub>\\<int>\\<close>\n\n    \\<^item> \\<open>p\\<close> where \\<open>p \\<in> \\<nat>\\<close> is prime in \\<open>\\<nat>\\<close> and congruent 1 modulo 4\n\n    \\<^item> $x + iy$ where $x,y$ are positive integers and $x^2 + y^2$ is a prime congruent 3 modulo 4\n\n  or an associated element of one of these.  \n\\<close>"], ["", "theorem gauss_int_prime_classification:\n  fixes x :: gauss_int\n  assumes \"prime x\"\n  obtains \n    (one_plus_i) \"x = 1 + \\<i>\\<^sub>\\<int>\"\n  | (cong_3_mod_4) p where \"x = of_nat p\" \"prime p\" \"[p = 3] (mod 4)\"\n  | (cong_1_mod_4) \"prime (gauss_int_norm x)\" \"[gauss_int_norm x = 1] (mod 4)\"\n                   \"ReZ x > 0\" \"ImZ x > 0\" \"ReZ x \\<noteq> ImZ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "define N where \"N = gauss_int_norm x\""], ["proof (state)\nthis:\n  N = gauss_int_norm x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"x dvd x * gauss_cnj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd x * gauss_cnj x", "by simp"], ["proof (state)\nthis:\n  x dvd x * gauss_cnj x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  x dvd x * gauss_cnj x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> = of_nat (gauss_int_norm x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * gauss_cnj x = of_nat (gauss_int_norm x)", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  x * gauss_cnj x = of_nat (gauss_int_norm x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  x dvd of_nat (gauss_int_norm x)", "have \"x \\<in> prime_factors (of_nat N)\""], ["proof (prove)\nusing this:\n  x dvd of_nat (gauss_int_norm x)\n\ngoal (1 subgoal):\n 1. x \\<in># prime_factorization (of_nat N)", "using assms"], ["proof (prove)\nusing this:\n  x dvd of_nat (gauss_int_norm x)\n  prime x\n\ngoal (1 subgoal):\n 1. x \\<in># prime_factorization (of_nat N)", "by (auto simp: in_prime_factors_iff N_def)"], ["proof (state)\nthis:\n  x \\<in># prime_factorization (of_nat N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  x \\<in># prime_factorization (of_nat N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"N = prod_mset (prime_factorization N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N = \\<Prod>\\<^sub># (prime_factorization N)", "using assms"], ["proof (prove)\nusing this:\n  prime x\n\ngoal (1 subgoal):\n 1. N = \\<Prod>\\<^sub># (prime_factorization N)", "unfolding N_def"], ["proof (prove)\nusing this:\n  prime x\n\ngoal (1 subgoal):\n 1. gauss_int_norm x =\n    \\<Prod>\\<^sub># (prime_factorization (gauss_int_norm x))", "by (subst prod_mset_prime_factorization_nat) auto"], ["proof (state)\nthis:\n  N = \\<Prod>\\<^sub># (prime_factorization N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  N = \\<Prod>\\<^sub># (prime_factorization N)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"(of_nat \\<dots> :: gauss_int) = \n               prod_mset (image_mset of_nat (prime_factorization N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (\\<Prod>\\<^sub># (prime_factorization N)) =\n    \\<Prod>\\<^sub># (image_mset of_nat (prime_factorization N))", "by (subst of_nat_prod_mset) auto"], ["proof (state)\nthis:\n  of_nat (\\<Prod>\\<^sub># (prime_factorization N)) =\n  \\<Prod>\\<^sub># (image_mset of_nat (prime_factorization N))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  of_nat (\\<Prod>\\<^sub># (prime_factorization N)) =\n  \\<Prod>\\<^sub># (image_mset of_nat (prime_factorization N))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"prime_factors \\<dots> = (\\<Union>p\\<in>prime_factors N. prime_factors (of_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors\n     (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization N))) =\n    (\\<Union>p\\<in>prime_factors N. prime_factors (of_nat p))", "by (subst prime_factorization_prod_mset) auto"], ["proof (state)\nthis:\n  prime_factors\n   (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization N))) =\n  (\\<Union>p\\<in>prime_factors N. prime_factors (of_nat p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>p\\<in>prime_factors N. prime_factors (of_nat p))", "obtain p where p: \"p \\<in> prime_factors N\" \"x \\<in> prime_factors (of_nat p)\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p\\<in>prime_factors N. prime_factors (of_nat p))\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in># prime_factorization N;\n         x \\<in># prime_factorization (of_nat p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p", "using p"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n\ngoal (1 subgoal):\n 1. prime p", "by auto"], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<not>(2 * 2) dvd p\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. \\<not> 2 * 2 dvd p", "using product_dvd_irreducibleD[of p 2 2]"], ["proof (prove)\nusing this:\n  prime p\n  \\<lbrakk>irreducible p; 2 * 2 dvd p\\<rbrakk>\n  \\<Longrightarrow> is_unit 2 \\<or> is_unit 2\n\ngoal (1 subgoal):\n 1. \\<not> 2 * 2 dvd p", "by (auto simp flip: prime_elem_iff_irreducible)"], ["proof (state)\nthis:\n  \\<not> 2 * 2 dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"[p \\<noteq> 0] (mod 4)\""], ["proof (prove)\nusing this:\n  \\<not> 2 * 2 dvd p\n\ngoal (1 subgoal):\n 1. [p \\<noteq> 0] (mod 4)", "using p"], ["proof (prove)\nusing this:\n  \\<not> 2 * 2 dvd p\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n\ngoal (1 subgoal):\n 1. [p \\<noteq> 0] (mod 4)", "by (auto simp: cong_0_iff in_prime_factors_iff)"], ["proof (state)\nthis:\n  [p \\<noteq> 0] (mod 4)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"p mod 4 \\<in> {1,2,3}\""], ["proof (prove)\nusing this:\n  [p \\<noteq> 0] (mod 4)\n\ngoal (1 subgoal):\n 1. p mod 4 \\<in> {1, 2, 3}", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  p mod 4 \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis;\n     \\<And>p.\n        \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n      0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  p mod 4 \\<in> {1, 2, 3}\n\ngoal (1 subgoal):\n 1. thesis", "proof (elim singletonE insertE)"], ["proof (state)\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "assume \"p mod 4 = 2\""], ["proof (state)\nthis:\n  p mod 4 = 2\n\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "hence \"p mod 4 mod 2 = 0\""], ["proof (prove)\nusing this:\n  p mod 4 = 2\n\ngoal (1 subgoal):\n 1. p mod 4 mod 2 = 0", "by simp"], ["proof (state)\nthis:\n  p mod 4 mod 2 = 0\n\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "hence \"p mod 2 = 0\""], ["proof (prove)\nusing this:\n  p mod 4 mod 2 = 0\n\ngoal (1 subgoal):\n 1. p mod 2 = 0", "by (simp add: mod_mod_cancel)"], ["proof (state)\nthis:\n  p mod 2 = 0\n\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "with \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  p mod 2 = 0", "have [simp]: \"p = 2\""], ["proof (prove)\nusing this:\n  prime p\n  p mod 2 = 0\n\ngoal (1 subgoal):\n 1. p = 2", "using prime_prime_factor two_is_prime_nat"], ["proof (prove)\nusing this:\n  prime p\n  p mod 2 = 0\n  prime ?n =\n  (?n \\<noteq> 1 \\<and>\n   (\\<forall>p. prime p \\<and> p dvd ?n \\<longrightarrow> p = ?n))\n  prime 2\n\ngoal (1 subgoal):\n 1. p = 2", "by blast"], ["proof (state)\nthis:\n  p = 2\n\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "have \"prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int> :: gauss_int}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int>}", "by (simp add: prime_factorization_2_gauss_int)"], ["proof (state)\nthis:\n  prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int>}\n\ngoal (3 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 2 \\<Longrightarrow> thesis\n 3. p mod 4 = 3 \\<Longrightarrow> thesis", "with p"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int>}", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int>}\n\ngoal (1 subgoal):\n 1. thesis", "using that(1)"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {1 + \\<i>\\<^sub>\\<int>}\n  x = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 3 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 3 \\<Longrightarrow> thesis", "assume *: \"p mod 4 = 3\""], ["proof (state)\nthis:\n  p mod 4 = 3\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 3 \\<Longrightarrow> thesis", "hence \"prime_factors (of_nat p) = {of_nat p :: gauss_int}\""], ["proof (prove)\nusing this:\n  p mod 4 = 3\n\ngoal (1 subgoal):\n 1. prime_factors (of_nat p) = {of_nat p}", "using prime_gauss_int_of_nat[of p] \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  p mod 4 = 3\n  \\<lbrakk>prime p; [p = 3] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> prime (of_nat p)\n  prime p\n\ngoal (1 subgoal):\n 1. prime_factors (of_nat p) = {of_nat p}", "by (subst prime_factorization_prime) (auto simp: cong_def)"], ["proof (state)\nthis:\n  prime_factors (of_nat p) = {of_nat p}\n\ngoal (2 subgoals):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis\n 2. p mod 4 = 3 \\<Longrightarrow> thesis", "with p"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {of_nat p}", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {of_nat p}\n\ngoal (1 subgoal):\n 1. thesis", "using that(2)[of p] *"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime_factors (of_nat p) = {of_nat p}\n  \\<lbrakk>x = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  p mod 4 = 3\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "assume *: \"p mod 4 = 1\""], ["proof (state)\nthis:\n  p mod 4 = 1\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p mod 4 = 1", "interpret noninert_gauss_int_prime p"], ["proof (prove)\nusing this:\n  p mod 4 = 1\n\ngoal (1 subgoal):\n 1. noninert_gauss_int_prime p", "by unfold_locales (use \\<open>prime p\\<close> in \\<open>auto simp: cong_def\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "obtain q1 q2 :: gauss_int where q12:\n      \"prime q1\" \"prime q2\" \"prime_factorization (of_nat p) = {#q1, q2#}\"\n      \"gauss_int_norm q1 = p\" \"gauss_int_norm q2 = p\" \"q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\"\n      \"ReZ q1 > 0\" \"ImZ q1 > 0\" \"ReZ q1 > 0\" \"ImZ q2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_factorization"], ["proof (prove)\nusing this:\n  (\\<And>q1 q2.\n      \\<lbrakk>prime q1; prime q2;\n       prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n       gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n       0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        \\<lbrakk>prime q1; prime q2;\n         prime_factorization (of_nat p) = {#q1, q2#}; gauss_int_norm q1 = p;\n         gauss_int_norm q2 = p; q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1;\n         0 < ReZ q1; 0 < ImZ q1; 0 < ReZ q1; 0 < ImZ q2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  prime q1\n  prime q2\n  prime_factorization (of_nat p) = {#q1, q2#}\n  gauss_int_norm q1 = p\n  gauss_int_norm q2 = p\n  q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\n  0 < ReZ q1\n  0 < ImZ q1\n  0 < ReZ q1\n  0 < ImZ q2\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "from p q12"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime q1\n  prime q2\n  prime_factorization (of_nat p) = {#q1, q2#}\n  gauss_int_norm q1 = p\n  gauss_int_norm q2 = p\n  q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\n  0 < ReZ q1\n  0 < ImZ q1\n  0 < ReZ q1\n  0 < ImZ q2", "have \"x = q1 \\<or> x = q2\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization N\n  x \\<in># prime_factorization (of_nat p)\n  prime q1\n  prime q2\n  prime_factorization (of_nat p) = {#q1, q2#}\n  gauss_int_norm q1 = p\n  gauss_int_norm q2 = p\n  q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\n  0 < ReZ q1\n  0 < ImZ q1\n  0 < ReZ q1\n  0 < ImZ q2\n\ngoal (1 subgoal):\n 1. x = q1 \\<or> x = q2", "by auto"], ["proof (state)\nthis:\n  x = q1 \\<or> x = q2\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "with q12"], ["proof (chain)\npicking this:\n  prime q1\n  prime q2\n  prime_factorization (of_nat p) = {#q1, q2#}\n  gauss_int_norm q1 = p\n  gauss_int_norm q2 = p\n  q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\n  0 < ReZ q1\n  0 < ImZ q1\n  0 < ReZ q1\n  0 < ImZ q2\n  x = q1 \\<or> x = q2", "have **: \"gauss_int_norm x = p\" \"ReZ x > 0\" \"ImZ x > 0\""], ["proof (prove)\nusing this:\n  prime q1\n  prime q2\n  prime_factorization (of_nat p) = {#q1, q2#}\n  gauss_int_norm q1 = p\n  gauss_int_norm q2 = p\n  q2 = \\<i>\\<^sub>\\<int> * gauss_cnj q1\n  0 < ReZ q1\n  0 < ImZ q1\n  0 < ReZ q1\n  0 < ImZ q2\n  x = q1 \\<or> x = q2\n\ngoal (1 subgoal):\n 1. gauss_int_norm x = p &&& 0 < ReZ x &&& 0 < ImZ x", "by auto"], ["proof (state)\nthis:\n  gauss_int_norm x = p\n  0 < ReZ x\n  0 < ImZ x\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "have \"ReZ x \\<noteq> ImZ x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ReZ x \\<noteq> ImZ x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ReZ x = ImZ x \\<Longrightarrow> False", "assume \"ReZ x = ImZ x\""], ["proof (state)\nthis:\n  ReZ x = ImZ x\n\ngoal (1 subgoal):\n 1. ReZ x = ImZ x \\<Longrightarrow> False", "hence \"even (gauss_int_norm x)\""], ["proof (prove)\nusing this:\n  ReZ x = ImZ x\n\ngoal (1 subgoal):\n 1. even (gauss_int_norm x)", "by (auto simp: gauss_int_norm_def nat_mult_distrib)"], ["proof (state)\nthis:\n  even (gauss_int_norm x)\n\ngoal (1 subgoal):\n 1. ReZ x = ImZ x \\<Longrightarrow> False", "hence \"even p\""], ["proof (prove)\nusing this:\n  even (gauss_int_norm x)\n\ngoal (1 subgoal):\n 1. even p", "using \\<open>gauss_int_norm x = p\\<close>"], ["proof (prove)\nusing this:\n  even (gauss_int_norm x)\n  gauss_int_norm x = p\n\ngoal (1 subgoal):\n 1. even p", "by simp"], ["proof (state)\nthis:\n  even p\n\ngoal (1 subgoal):\n 1. ReZ x = ImZ x \\<Longrightarrow> False", "with \\<open>p mod 4 = 1\\<close>"], ["proof (chain)\npicking this:\n  p mod 4 = 1\n  even p", "show False"], ["proof (prove)\nusing this:\n  p mod 4 = 1\n  even p\n\ngoal (1 subgoal):\n 1. False", "by presburger"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ReZ x \\<noteq> ImZ x\n\ngoal (1 subgoal):\n 1. p mod 4 = 1 \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  ReZ x \\<noteq> ImZ x\n\ngoal (1 subgoal):\n 1. thesis", "using that(3) \\<open>prime p\\<close> * **"], ["proof (prove)\nusing this:\n  ReZ x \\<noteq> ImZ x\n  \\<lbrakk>prime (gauss_int_norm x); [gauss_int_norm x = 1] (mod 4);\n   0 < ReZ x; 0 < ImZ x; ReZ x \\<noteq> ImZ x\\<rbrakk>\n  \\<Longrightarrow> thesis\n  prime p\n  p mod 4 = 1\n  gauss_int_norm x = p\n  0 < ReZ x\n  0 < ImZ x\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_gauss_int_norm_squareD:\n  fixes z :: gauss_int\n  assumes \"prime z\" \"gauss_int_norm z = p ^ 2\"\n  shows   \"prime p \\<and> z = of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "using assms(1)"], ["proof (prove)\nusing this:\n  prime z\n\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "proof (cases rule: gauss_int_prime_classification)"], ["proof (state)\ngoal (3 subgoals):\n 1. z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 3. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "case one_plus_i"], ["proof (state)\nthis:\n  z = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 3. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "have \"prime (2 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime 2", "by simp"], ["proof (state)\nthis:\n  prime 2\n\ngoal (3 subgoals):\n 1. z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 3. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "also"], ["proof (state)\nthis:\n  prime 2\n\ngoal (3 subgoals):\n 1. z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 3. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "from one_plus_i"], ["proof (chain)\npicking this:\n  z = 1 + \\<i>\\<^sub>\\<int>", "have \"2 = p ^ 2\""], ["proof (prove)\nusing this:\n  z = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. 2 = p\\<^sup>2", "using assms(2)"], ["proof (prove)\nusing this:\n  z = 1 + \\<i>\\<^sub>\\<int>\n  gauss_int_norm z = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 = p\\<^sup>2", "by (auto simp: gauss_int_norm_def)"], ["proof (state)\nthis:\n  2 = p\\<^sup>2\n\ngoal (3 subgoals):\n 1. z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 3. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "finally"], ["proof (chain)\npicking this:\n  prime (p\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  prime (p\\<^sup>2)\n\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "by (simp add: prime_power_iff)"], ["proof (state)\nthis:\n  prime p \\<and> z = of_nat p\n\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "case (cong_3_mod_4 p)"], ["proof (state)\nthis:\n  z = of_nat p\n  prime p\n  [p = 3] (mod 4)\n\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>z = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime p \\<and> z = of_nat p\n 2. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = of_nat p\n  prime p\n  [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "using assms"], ["proof (prove)\nusing this:\n  z = of_nat p\n  prime p\n  [p = 3] (mod 4)\n  prime z\n  gauss_int_norm z = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "by auto"], ["proof (state)\nthis:\n  prime p \\<and> z = of_nat p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "case cong_1_mod_4"], ["proof (state)\nthis:\n  prime (gauss_int_norm z)\n  [gauss_int_norm z = 1] (mod 4)\n  0 < ReZ z\n  0 < ImZ z\n  ReZ z \\<noteq> ImZ z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm z); [gauss_int_norm z = 1] (mod 4);\n     0 < ReZ z; 0 < ImZ z; ReZ z \\<noteq> ImZ z\\<rbrakk>\n    \\<Longrightarrow> prime p \\<and> z = of_nat p", "with assms"], ["proof (chain)\npicking this:\n  prime z\n  gauss_int_norm z = p\\<^sup>2\n  prime (gauss_int_norm z)\n  [gauss_int_norm z = 1] (mod 4)\n  0 < ReZ z\n  0 < ImZ z\n  ReZ z \\<noteq> ImZ z", "show ?thesis"], ["proof (prove)\nusing this:\n  prime z\n  gauss_int_norm z = p\\<^sup>2\n  prime (gauss_int_norm z)\n  [gauss_int_norm z = 1] (mod 4)\n  0 < ReZ z\n  0 < ImZ z\n  ReZ z \\<noteq> ImZ z\n\ngoal (1 subgoal):\n 1. prime p \\<and> z = of_nat p", "by (auto simp: prime_power_iff)"], ["proof (state)\nthis:\n  prime p \\<and> z = of_nat p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_int_norm_eq_prime_squareD:\n  assumes \"prime p\" and \"[p = 3] (mod 4)\" and \"gauss_int_norm z = p ^ 2\"\n  shows   \"normalize z = of_nat p\" and \"prime_elem z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize z = of_nat p &&& prime_elem z", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "have \"\\<exists>q::gauss_int. q dvd z \\<and> prime q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. q dvd z \\<and> prime q", "by (rule prime_divisor_exists) (use assms in \\<open>auto simp: is_unit_gauss_int_iff'\\<close>)"], ["proof (state)\nthis:\n  \\<exists>q. q dvd z \\<and> prime q\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. q dvd z \\<and> prime q", "obtain q :: gauss_int where q: \"q dvd z\" \"prime q\""], ["proof (prove)\nusing this:\n  \\<exists>q. q dvd z \\<and> prime q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q dvd z; prime q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q dvd z\n  prime q\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "have \"gauss_int_norm q dvd gauss_int_norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm q dvd gauss_int_norm z", "by (rule gauss_int_norm_dvd_mono) fact"], ["proof (state)\nthis:\n  gauss_int_norm q dvd gauss_int_norm z\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "also"], ["proof (state)\nthis:\n  gauss_int_norm q dvd gauss_int_norm z\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "have \"\\<dots> = p ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm z = p\\<^sup>2", "by fact"], ["proof (state)\nthis:\n  gauss_int_norm z = p\\<^sup>2\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "finally"], ["proof (chain)\npicking this:\n  gauss_int_norm q dvd p\\<^sup>2", "obtain i where i: \"i \\<le> 2\" \"gauss_int_norm q = p ^ i\""], ["proof (prove)\nusing this:\n  gauss_int_norm q dvd p\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> 2; gauss_int_norm q = p ^ i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) divides_primepow_nat) (use assms q in auto)"], ["proof (state)\nthis:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "from i assms q"], ["proof (chain)\npicking this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n  q dvd z\n  prime q", "have \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n  q dvd z\n  prime q\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by (auto intro!: Nat.gr0I simp: gauss_int_norm_eq_Suc_0_iff)"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "moreover"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "from i assms q"], ["proof (chain)\npicking this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n  q dvd z\n  prime q", "have \"i \\<noteq> 1\""], ["proof (prove)\nusing this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n  q dvd z\n  prime q\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1", "using gauss_int_norm_not_3_mod_4[of q]"], ["proof (prove)\nusing this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n  q dvd z\n  prime q\n  [gauss_int_norm q \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> 1\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "ultimately"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  i \\<noteq> 1", "have \"i = 2\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. i = 2", "using i"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  i \\<noteq> 1\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n\ngoal (1 subgoal):\n 1. i = 2", "by auto"], ["proof (state)\nthis:\n  i = 2\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "with i"], ["proof (chain)\npicking this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  i = 2", "have \"gauss_int_norm q = p ^ 2\""], ["proof (prove)\nusing this:\n  i \\<le> 2\n  gauss_int_norm q = p ^ i\n  i = 2\n\ngoal (1 subgoal):\n 1. gauss_int_norm q = p\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  gauss_int_norm q = p\\<^sup>2\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "hence [simp]: \"q = of_nat p\""], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. q = of_nat p", "using prime_gauss_int_norm_squareD[of q p] q"], ["proof (prove)\nusing this:\n  gauss_int_norm q = p\\<^sup>2\n  \\<lbrakk>prime q; gauss_int_norm q = p\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> prime p \\<and> q = of_nat p\n  q dvd z\n  prime q\n\ngoal (1 subgoal):\n 1. q = of_nat p", "by auto"], ["proof (state)\nthis:\n  q = of_nat p\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "have \"normalize (of_nat p) = normalize z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (of_nat p) = normalize z", "using q assms"], ["proof (prove)\nusing this:\n  q dvd z\n  prime q\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. normalize (of_nat p) = normalize z", "by (intro gauss_int_dvd_same_norm_imp_associated) auto"], ["proof (state)\nthis:\n  normalize (of_nat p) = normalize z\n\ngoal (2 subgoals):\n 1. normalize z = of_nat p\n 2. prime_elem z", "thus *: \"normalize z = of_nat p\""], ["proof (prove)\nusing this:\n  normalize (of_nat p) = normalize z\n\ngoal (1 subgoal):\n 1. normalize z = of_nat p", "by simp"], ["proof (state)\nthis:\n  normalize z = of_nat p\n\ngoal (1 subgoal):\n 1. prime_elem z", "have \"prime (normalize z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (normalize z)", "using prime_gauss_int_of_nat[of p] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; [p = 3] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> prime (of_nat p)\n  prime p\n  [p = 3] (mod 4)\n  gauss_int_norm z = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. prime (normalize z)", "by (subst *) auto"], ["proof (state)\nthis:\n  prime (normalize z)\n\ngoal (1 subgoal):\n 1. prime_elem z", "thus \"prime_elem z\""], ["proof (prove)\nusing this:\n  prime (normalize z)\n\ngoal (1 subgoal):\n 1. prime_elem z", "by simp"], ["proof (state)\nthis:\n  prime_elem z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following can be used as a primality test for Gaussian integers. It effectively\n  reduces checking the primality of a Gaussian integer to checking the primality of an\n  integer.\n\n  A Gaussian integer is prime if either its norm is either \\<open>\\<int>\\<close>-prime or the square of\n  a \\<open>\\<int>\\<close>-prime that is congruent 3 modulo 4.\n\\<close>"], ["", "lemma prime_elem_gauss_int_iff:\n  fixes z :: gauss_int\n  defines \"n \\<equiv> gauss_int_norm z\"\n  shows   \"prime_elem z \\<longleftrightarrow> prime n \\<or> (\\<exists>p. n = p ^ 2 \\<and> prime p \\<and> [p = 3] (mod 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem z =\n    (prime n \\<or>\n     (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. prime n \\<or>\n    (\\<exists>p.\n        n = p\\<^sup>2 \\<and>\n        prime p \\<and> [p = 3] (mod 4)) \\<Longrightarrow>\n    prime_elem z", "assume \"prime n \\<or> (\\<exists>p. n = p ^ 2 \\<and> prime p \\<and> [p = 3] (mod 4))\""], ["proof (state)\nthis:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal (2 subgoals):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. prime n \\<or>\n    (\\<exists>p.\n        n = p\\<^sup>2 \\<and>\n        prime p \\<and> [p = 3] (mod 4)) \\<Longrightarrow>\n    prime_elem z", "thus \"prime_elem z\""], ["proof (prove)\nusing this:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal (1 subgoal):\n 1. prime_elem z", "by (auto intro: gauss_int_norm_eq_prime_squareD(2)\n                    prime_gauss_int_norm_imp_prime_elem simp: n_def)"], ["proof (state)\nthis:\n  prime_elem z\n\ngoal (1 subgoal):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "assume \"prime_elem z\""], ["proof (state)\nthis:\n  prime_elem z\n\ngoal (1 subgoal):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "hence \"prime (normalize z)\""], ["proof (prove)\nusing this:\n  prime_elem z\n\ngoal (1 subgoal):\n 1. prime (normalize z)", "by simp"], ["proof (state)\nthis:\n  prime (normalize z)\n\ngoal (1 subgoal):\n 1. prime_elem z \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "thus \"prime n \\<or> (\\<exists>p. n = p ^ 2 \\<and> prime p \\<and> [p = 3] (mod 4))\""], ["proof (prove)\nusing this:\n  prime (normalize z)\n\ngoal (1 subgoal):\n 1. prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "proof (cases rule: gauss_int_prime_classification)"], ["proof (state)\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "case one_plus_i"], ["proof (state)\nthis:\n  normalize z = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"n = gauss_int_norm (normalize z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = gauss_int_norm (normalize z)", "by (simp add: n_def)"], ["proof (state)\nthis:\n  n = gauss_int_norm (normalize z)\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "also"], ["proof (state)\nthis:\n  n = gauss_int_norm (normalize z)\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"normalize z = 1 + \\<i>\\<^sub>\\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int>", "by fact"], ["proof (state)\nthis:\n  normalize z = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "also"], ["proof (state)\nthis:\n  normalize z = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"gauss_int_norm \\<dots> = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (1 + \\<i>\\<^sub>\\<int>) = 2", "by (simp add: gauss_int_norm_def)"], ["proof (state)\nthis:\n  gauss_int_norm (1 + \\<i>\\<^sub>\\<int>) = 2\n\ngoal (3 subgoals):\n 1. normalize z = 1 + \\<i>\\<^sub>\\<int> \\<Longrightarrow>\n    prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n 2. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 3. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "finally"], ["proof (chain)\npicking this:\n  n = 2", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 2\n\ngoal (1 subgoal):\n 1. prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "by simp"], ["proof (state)\nthis:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "case (cong_3_mod_4 p)"], ["proof (state)\nthis:\n  normalize z = of_nat p\n  prime p\n  [p = 3] (mod 4)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"n = gauss_int_norm (normalize z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = gauss_int_norm (normalize z)", "by (simp add: n_def)"], ["proof (state)\nthis:\n  n = gauss_int_norm (normalize z)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "also"], ["proof (state)\nthis:\n  n = gauss_int_norm (normalize z)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"normalize z = of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize z = of_nat p", "by fact"], ["proof (state)\nthis:\n  normalize z = of_nat p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "also"], ["proof (state)\nthis:\n  normalize z = of_nat p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "have \"gauss_int_norm \\<dots> = p ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat p) = p\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  gauss_int_norm (of_nat p) = p\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>normalize z = of_nat p; prime p; [p = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> prime n \\<or>\n                         (\\<exists>p.\n                             n = p\\<^sup>2 \\<and>\n                             prime p \\<and> [p = 3] (mod 4))\n 2. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "finally"], ["proof (chain)\npicking this:\n  n = p\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  n = p\\<^sup>2\n\ngoal (1 subgoal):\n 1. prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "using cong_3_mod_4"], ["proof (prove)\nusing this:\n  n = p\\<^sup>2\n  normalize z = of_nat p\n  prime p\n  [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "by simp"], ["proof (state)\nthis:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "case cong_1_mod_4"], ["proof (state)\nthis:\n  prime (gauss_int_norm (normalize z))\n  [gauss_int_norm (normalize z) = 1] (mod 4)\n  0 < ReZ (normalize z)\n  0 < ImZ (normalize z)\n  ReZ (normalize z) \\<noteq> ImZ (normalize z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime (gauss_int_norm (normalize z));\n     [gauss_int_norm (normalize z) = 1] (mod 4); 0 < ReZ (normalize z);\n     0 < ImZ (normalize z);\n     ReZ (normalize z) \\<noteq> ImZ (normalize z)\\<rbrakk>\n    \\<Longrightarrow> prime n \\<or>\n                      (\\<exists>p.\n                          n = p\\<^sup>2 \\<and>\n                          prime p \\<and> [p = 3] (mod 4))", "thus ?thesis"], ["proof (prove)\nusing this:\n  prime (gauss_int_norm (normalize z))\n  [gauss_int_norm (normalize z) = 1] (mod 4)\n  0 < ReZ (normalize z)\n  0 < ImZ (normalize z)\n  ReZ (normalize z) \\<noteq> ImZ (normalize z)\n\ngoal (1 subgoal):\n 1. prime n \\<or>\n    (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))", "by (simp add: n_def)"], ["proof (state)\nthis:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime n \\<or>\n  (\\<exists>p. n = p\\<^sup>2 \\<and> prime p \\<and> [p = 3] (mod 4))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Multiplicities of primes\\<close>"], ["", "text \\<open>\n  In this section, we will show some results connecting the multiplicity of a Gaussian prime \\<open>p\\<close>\n  in a Gaussian integer \\<open>z\\<close> to the \\<open>\\<int>\\<close>-multiplicity of the norm of \\<open>p\\<close> in the norm of \\<open>z\\<close>.\n\\<close>"], ["", "text \\<open>\n  The multiplicity of the Gaussian prime \\<^term>\\<open>1 + \\<i>\\<^sub>\\<int>\\<close> in an integer \\<open>c\\<close> is simply\n  twice the \\<open>\\<int>\\<close>-multiplicity of 2 in \\<open>c\\<close>:\n\\<close>"], ["", "lemma multiplicity_prime_1_plus_i_aux: \"multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "case [simp]: False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "have \"2 * multiplicity 2 c = multiplicity 2 (c ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * multiplicity 2 c = multiplicity 2 (c\\<^sup>2)", "by (simp add: prime_elem_multiplicity_power_distrib)"], ["proof (state)\nthis:\n  2 * multiplicity 2 c = multiplicity 2 (c\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "also"], ["proof (state)\nthis:\n  2 * multiplicity 2 c = multiplicity 2 (c\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "have \"multiplicity 2 (c ^ 2) = multiplicity (of_nat 2) (of_nat c ^ 2 :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity 2 (c\\<^sup>2) =\n    multiplicity (of_nat 2) ((of_nat c)\\<^sup>2)", "by (simp flip: multiplicity_gauss_int_of_nat)"], ["proof (state)\nthis:\n  multiplicity 2 (c\\<^sup>2) = multiplicity (of_nat 2) ((of_nat c)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "also"], ["proof (state)\nthis:\n  multiplicity 2 (c\\<^sup>2) = multiplicity (of_nat 2) ((of_nat c)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "have \"of_nat 2 = (-\\<i>\\<^sub>\\<int>) * (1 + \\<i>\\<^sub>\\<int>) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat 2 = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  of_nat 2 = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "also"], ["proof (state)\nthis:\n  of_nat 2 = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "have \"multiplicity \\<dots> (of_nat c ^ 2) = multiplicity ((1 + \\<i>\\<^sub>\\<int>) ^ 2) (of_nat c ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2)\n     ((of_nat c)\\<^sup>2) =\n    multiplicity ((1 + \\<i>\\<^sub>\\<int>)\\<^sup>2) ((of_nat c)\\<^sup>2)", "by (subst multiplicity_times_unit_left) auto"], ["proof (state)\nthis:\n  multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2)\n   ((of_nat c)\\<^sup>2) =\n  multiplicity ((1 + \\<i>\\<^sub>\\<int>)\\<^sup>2) ((of_nat c)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "also"], ["proof (state)\nthis:\n  multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\\<^sup>2)\n   ((of_nat c)\\<^sup>2) =\n  multiplicity ((1 + \\<i>\\<^sub>\\<int>)\\<^sup>2) ((of_nat c)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "have \"\\<dots> = multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity ((1 + \\<i>\\<^sub>\\<int>)\\<^sup>2) ((of_nat c)\\<^sup>2) =\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c)", "by (subst multiplicity_power_power) auto"], ["proof (state)\nthis:\n  multiplicity ((1 + \\<i>\\<^sub>\\<int>)\\<^sup>2) ((of_nat c)\\<^sup>2) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "finally"], ["proof (chain)\npicking this:\n  2 * multiplicity 2 c = multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * multiplicity 2 c = multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c)\n\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", ".."], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c\n\ngoal (1 subgoal):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat c) = 2 * multiplicity 2 c", "qed auto"], ["", "text \\<open>\n  Tha multiplicity of an inert Gaussian prime $q\\in\\mathbb{Z}$ in a Gaussian integer \\<open>z\\<close> is \n  precisely half the \\<open>\\<int>\\<close>-multiplicity of \\<open>q\\<close> in the norm of \\<open>z\\<close>.\n\\<close>"], ["", "lemma multiplicity_prime_cong_3_mod_4:\n  assumes \"prime (of_nat q :: gauss_int)\"\n  shows   \"multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "case [simp]: False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "have \"multiplicity q (gauss_int_norm z) =\n          multiplicity (of_nat q) (of_nat (gauss_int_norm z) :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity q (gauss_int_norm z) =\n    multiplicity (of_nat q) (of_nat (gauss_int_norm z))", "by (simp add: multiplicity_gauss_int_of_nat)"], ["proof (state)\nthis:\n  multiplicity q (gauss_int_norm z) =\n  multiplicity (of_nat q) (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "also"], ["proof (state)\nthis:\n  multiplicity q (gauss_int_norm z) =\n  multiplicity (of_nat q) (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "have \"\\<dots> = multiplicity (of_nat q) (z * gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (of_nat q) (of_nat (gauss_int_norm z)) =\n    multiplicity (of_nat q) (z * gauss_cnj z)", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  multiplicity (of_nat q) (of_nat (gauss_int_norm z)) =\n  multiplicity (of_nat q) (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "also"], ["proof (state)\nthis:\n  multiplicity (of_nat q) (of_nat (gauss_int_norm z)) =\n  multiplicity (of_nat q) (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "have \"\\<dots> = multiplicity (of_nat q) z + multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (of_nat q) (z * gauss_cnj z) =\n    multiplicity (of_nat q) z +\n    multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z)", "using assms"], ["proof (prove)\nusing this:\n  prime (of_nat q)\n\ngoal (1 subgoal):\n 1. multiplicity (of_nat q) (z * gauss_cnj z) =\n    multiplicity (of_nat q) z +\n    multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z)", "by (subst prime_elem_multiplicity_mult_distrib) auto"], ["proof (state)\nthis:\n  multiplicity (of_nat q) (z * gauss_cnj z) =\n  multiplicity (of_nat q) z +\n  multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "also"], ["proof (state)\nthis:\n  multiplicity (of_nat q) (z * gauss_cnj z) =\n  multiplicity (of_nat q) z +\n  multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "have \"multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z) = multiplicity (of_nat q) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z) =\n    multiplicity (of_nat q) z", "by (subst multiplicity_gauss_cnj) auto"], ["proof (state)\nthis:\n  multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z) =\n  multiplicity (of_nat q) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "also"], ["proof (state)\nthis:\n  multiplicity (gauss_cnj (of_nat q)) (gauss_cnj z) =\n  multiplicity (of_nat q) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "have \"\\<dots> + \\<dots> = 2 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (of_nat q) z + multiplicity (of_nat q) z =\n    2 * multiplicity (of_nat q) z", "by simp"], ["proof (state)\nthis:\n  multiplicity (of_nat q) z + multiplicity (of_nat q) z =\n  2 * multiplicity (of_nat q) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "finally"], ["proof (chain)\npicking this:\n  multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n\ngoal (1 subgoal):\n 1. multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "."], ["proof (state)\nthis:\n  multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z\n\ngoal (1 subgoal):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity q (gauss_int_norm z) = 2 * multiplicity (of_nat q) z", "qed auto"], ["", "text \\<open>\n  For Gaussian primes \\<open>p\\<close> whose norm is congruent 1 modulo 4, the $\\mathbb{Z}[i]$-multiplicity\n  of \\<open>p\\<close> in an integer \\<open>c\\<close> is just the \\<open>\\<int>\\<close>-multiplicity of their norm in \\<open>c\\<close>.\n\\<close>"], ["", "lemma multiplicity_prime_cong_1_mod_4_aux:\n  fixes p :: gauss_int\n  assumes \"prime_elem p\" \"ReZ p > 0\" \"ImZ p > 0\" \"ImZ p \\<noteq> ReZ p\"\n  shows \"multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c", "case [simp]: False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c", "proof (intro antisym multiplicity_geI)"], ["proof (state)\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "define k where \"k = multiplicity p (of_nat c)\""], ["proof (state)\nthis:\n  k = multiplicity p (of_nat c)\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"p ^ k dvd of_nat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ k dvd of_nat c", "by (simp add: multiplicity_dvd k_def)"], ["proof (state)\nthis:\n  p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "moreover"], ["proof (state)\nthis:\n  p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"gauss_cnj p ^ k dvd of_nat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_cnj p ^ k dvd of_nat c", "using multiplicity_dvd[of \"gauss_cnj p\" \"of_nat c\"]\n            multiplicity_gauss_cnj[of p \"of_nat c\"]"], ["proof (prove)\nusing this:\n  gauss_cnj p ^ multiplicity (gauss_cnj p) (of_nat c) dvd of_nat c\n  multiplicity (gauss_cnj p) (gauss_cnj (of_nat c)) =\n  multiplicity p (of_nat c)\n\ngoal (1 subgoal):\n 1. gauss_cnj p ^ k dvd of_nat c", "by (simp add: k_def)"], ["proof (state)\nthis:\n  gauss_cnj p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "moreover"], ["proof (state)\nthis:\n  gauss_cnj p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"\\<not>p dvd gauss_cnj p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd gauss_cnj p", "using assms"], ["proof (prove)\nusing this:\n  prime_elem p\n  0 < ReZ p\n  0 < ImZ p\n  ImZ p \\<noteq> ReZ p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd gauss_cnj p", "by (subst self_dvd_gauss_cnj_iff) auto"], ["proof (state)\nthis:\n  \\<not> p dvd gauss_cnj p\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "hence \"\\<not>p dvd gauss_cnj p ^ k\""], ["proof (prove)\nusing this:\n  \\<not> p dvd gauss_cnj p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd gauss_cnj p ^ k", "using assms prime_elem_dvd_power"], ["proof (prove)\nusing this:\n  \\<not> p dvd gauss_cnj p\n  prime_elem p\n  0 < ReZ p\n  0 < ImZ p\n  ImZ p \\<noteq> ReZ p\n  \\<lbrakk>prime_elem ?p; ?p dvd ?x ^ ?n\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?x\n\ngoal (1 subgoal):\n 1. \\<not> p dvd gauss_cnj p ^ k", "by blast"], ["proof (state)\nthis:\n  \\<not> p dvd gauss_cnj p ^ k\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "ultimately"], ["proof (chain)\npicking this:\n  p ^ k dvd of_nat c\n  gauss_cnj p ^ k dvd of_nat c\n  \\<not> p dvd gauss_cnj p ^ k", "have \"p ^ k * gauss_cnj p ^ k dvd of_nat c\""], ["proof (prove)\nusing this:\n  p ^ k dvd of_nat c\n  gauss_cnj p ^ k dvd of_nat c\n  \\<not> p dvd gauss_cnj p ^ k\n\ngoal (1 subgoal):\n 1. p ^ k * gauss_cnj p ^ k dvd of_nat c", "using assms"], ["proof (prove)\nusing this:\n  p ^ k dvd of_nat c\n  gauss_cnj p ^ k dvd of_nat c\n  \\<not> p dvd gauss_cnj p ^ k\n  prime_elem p\n  0 < ReZ p\n  0 < ImZ p\n  ImZ p \\<noteq> ReZ p\n\ngoal (1 subgoal):\n 1. p ^ k * gauss_cnj p ^ k dvd of_nat c", "by (intro prime_elem_power_mult_dvdI) auto"], ["proof (state)\nthis:\n  p ^ k * gauss_cnj p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "also"], ["proof (state)\nthis:\n  p ^ k * gauss_cnj p ^ k dvd of_nat c\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"p ^ k * gauss_cnj p ^ k = of_nat (gauss_int_norm p ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ k * gauss_cnj p ^ k = of_nat (gauss_int_norm p ^ k)", "by (simp flip: self_mult_gauss_cnj add: power_mult_distrib)"], ["proof (state)\nthis:\n  p ^ k * gauss_cnj p ^ k = of_nat (gauss_int_norm p ^ k)\n\ngoal (6 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. gauss_int_norm p ^ multiplicity p (of_nat c) dvd c\n 4. of_nat c \\<noteq> 0\n 5. \\<not> is_unit p\n 6. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "finally"], ["proof (chain)\npicking this:\n  of_nat (gauss_int_norm p ^ k) dvd of_nat c", "show \"gauss_int_norm p ^ k dvd c\""], ["proof (prove)\nusing this:\n  of_nat (gauss_int_norm p ^ k) dvd of_nat c\n\ngoal (1 subgoal):\n 1. gauss_int_norm p ^ k dvd c", "by (subst (asm) of_nat_dvd_of_nat_gauss_int_iff)"], ["proof (state)\nthis:\n  gauss_int_norm p ^ k dvd c\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "define k where \"k = multiplicity (gauss_int_norm p) c\""], ["proof (state)\nthis:\n  k = multiplicity (gauss_int_norm p) c\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"p ^ k dvd (p * gauss_cnj p) ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ k dvd (p * gauss_cnj p) ^ k", "by (intro dvd_power_same) auto"], ["proof (state)\nthis:\n  p ^ k dvd (p * gauss_cnj p) ^ k\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "also"], ["proof (state)\nthis:\n  p ^ k dvd (p * gauss_cnj p) ^ k\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"\\<dots> = of_nat (gauss_int_norm p ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * gauss_cnj p) ^ k = of_nat (gauss_int_norm p ^ k)", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  (p * gauss_cnj p) ^ k = of_nat (gauss_int_norm p ^ k)\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "also"], ["proof (state)\nthis:\n  (p * gauss_cnj p) ^ k = of_nat (gauss_int_norm p ^ k)\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "have \"\\<dots> dvd of_nat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (gauss_int_norm p ^ k) dvd of_nat c", "unfolding of_nat_dvd_of_nat_gauss_int_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm p ^ k dvd c", "by (auto simp: k_def multiplicity_dvd)"], ["proof (state)\nthis:\n  of_nat (gauss_int_norm p ^ k) dvd of_nat c\n\ngoal (5 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p\n 5. p ^ multiplicity (gauss_int_norm p) c dvd of_nat c", "finally"], ["proof (chain)\npicking this:\n  p ^ k dvd of_nat c", "show \"p ^ k dvd of_nat c\""], ["proof (prove)\nusing this:\n  p ^ k dvd of_nat c\n\ngoal (1 subgoal):\n 1. p ^ k dvd of_nat c", "."], ["proof (state)\nthis:\n  p ^ k dvd of_nat c\n\ngoal (4 subgoals):\n 1. c \\<noteq> 0\n 2. \\<not> is_unit (gauss_int_norm p)\n 3. of_nat c \\<noteq> 0\n 4. \\<not> is_unit p", "qed (use assms in \\<open>auto simp: gauss_int_norm_eq_Suc_0_iff\\<close>)"], ["proof (state)\nthis:\n  multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c\n\ngoal (1 subgoal):\n 1. c = 0 \\<Longrightarrow>\n    multiplicity p (of_nat c) = multiplicity (gauss_int_norm p) c", "qed auto"], ["", "text \\<open>\n  The multiplicity of a Gaussian prime with norm congruent 1 modulo 4 in some Gaussian integer \\<open>z\\<close>\n  and the multiplicity of its conjugate in \\<open>z\\<close> sum to the the \\<open>\\<int>\\<close>-multiplicity of their norm in\n  the norm of \\<open>z\\<close>:\n\\<close>"], ["", "lemma multiplicity_prime_cong_1_mod_4:\n  fixes p :: gauss_int\n  assumes \"prime_elem p\" \"ReZ p > 0\" \"ImZ p > 0\" \"ImZ p \\<noteq> ReZ p\"\n  shows \"multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n           multiplicity p z + multiplicity (gauss_cnj p) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "case [simp]: False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "have \"multiplicity (gauss_int_norm p) (gauss_int_norm z) = \n          multiplicity p (of_nat (gauss_int_norm z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p (of_nat (gauss_int_norm z))", "using assms"], ["proof (prove)\nusing this:\n  prime_elem p\n  0 < ReZ p\n  0 < ImZ p\n  ImZ p \\<noteq> ReZ p\n\ngoal (1 subgoal):\n 1. multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p (of_nat (gauss_int_norm z))", "by (subst multiplicity_prime_cong_1_mod_4_aux) auto"], ["proof (state)\nthis:\n  multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n  multiplicity p (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "also"], ["proof (state)\nthis:\n  multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n  multiplicity p (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "have \"\\<dots> = multiplicity p (z * gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (of_nat (gauss_int_norm z)) =\n    multiplicity p (z * gauss_cnj z)", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  multiplicity p (of_nat (gauss_int_norm z)) =\n  multiplicity p (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "also"], ["proof (state)\nthis:\n  multiplicity p (of_nat (gauss_int_norm z)) =\n  multiplicity p (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "have \"\\<dots> = multiplicity p z + multiplicity p (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (z * gauss_cnj z) =\n    multiplicity p z + multiplicity p (gauss_cnj z)", "using assms"], ["proof (prove)\nusing this:\n  prime_elem p\n  0 < ReZ p\n  0 < ImZ p\n  ImZ p \\<noteq> ReZ p\n\ngoal (1 subgoal):\n 1. multiplicity p (z * gauss_cnj z) =\n    multiplicity p z + multiplicity p (gauss_cnj z)", "by (subst prime_elem_multiplicity_mult_distrib) auto"], ["proof (state)\nthis:\n  multiplicity p (z * gauss_cnj z) =\n  multiplicity p z + multiplicity p (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "also"], ["proof (state)\nthis:\n  multiplicity p (z * gauss_cnj z) =\n  multiplicity p z + multiplicity p (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "have \"multiplicity p (gauss_cnj z) = multiplicity (gauss_cnj p) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (gauss_cnj z) = multiplicity (gauss_cnj p) z", "by (subst multiplicity_gauss_cnj [symmetric]) auto"], ["proof (state)\nthis:\n  multiplicity p (gauss_cnj z) = multiplicity (gauss_cnj p) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "finally"], ["proof (chain)\npicking this:\n  multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n  multiplicity p z + multiplicity (gauss_cnj p) z", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n  multiplicity p z + multiplicity (gauss_cnj p) z\n\ngoal (1 subgoal):\n 1. multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "."], ["proof (state)\nthis:\n  multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n  multiplicity p z + multiplicity (gauss_cnj p) z\n\ngoal (1 subgoal):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (gauss_int_norm p) (gauss_int_norm z) =\n    multiplicity p z + multiplicity (gauss_cnj p) z", "qed auto"], ["", "text \\<open>\n  The multiplicity of the Gaussian prime \\<^term>\\<open>1 + \\<i>\\<^sub>\\<int>\\<close> in a Gaussian integer \\<open>z\\<close> is precisely\n  the \\<open>\\<int>\\<close>-multiplicity of 2 in the norm of \\<open>z\\<close>:\n\\<close>"], ["", "lemma multiplicity_prime_1_plus_i: \"multiplicity (1 + \\<i>\\<^sub>\\<int>) z = multiplicity 2 (gauss_int_norm z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "case [simp]: False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "note [simp] = prime_elem_one_plus_i_gauss_int"], ["proof (state)\nthis:\n  prime_elem (1 + \\<i>\\<^sub>\\<int>)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"2 * multiplicity 2 (gauss_int_norm z) = multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * multiplicity 2 (gauss_int_norm z) =\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z))", "by (rule multiplicity_prime_1_plus_i_aux [symmetric])"], ["proof (state)\nthis:\n  2 * multiplicity 2 (gauss_int_norm z) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  2 * multiplicity 2 (gauss_int_norm z) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"\\<dots> = multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z)) =\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z)", "by (simp add: self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z)) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (of_nat (gauss_int_norm z)) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"\\<dots> = multiplicity (1 + \\<i>\\<^sub>\\<int>) z + multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z) =\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z +\n    multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z)", "by (subst prime_elem_multiplicity_mult_distrib) auto"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z +\n  multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) (z * gauss_cnj z) =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z +\n  multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z) = multiplicity (1 - \\<i>\\<^sub>\\<int>) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z) =\n    multiplicity (1 - \\<i>\\<^sub>\\<int>) z", "by (subst multiplicity_gauss_cnj) auto"], ["proof (state)\nthis:\n  multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z) =\n  multiplicity (1 - \\<i>\\<^sub>\\<int>) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  multiplicity (gauss_cnj (1 - \\<i>\\<^sub>\\<int>)) (gauss_cnj z) =\n  multiplicity (1 - \\<i>\\<^sub>\\<int>) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"1 - \\<i>\\<^sub>\\<int> = (-\\<i>\\<^sub>\\<int>) * (1 + \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - \\<i>\\<^sub>\\<int> = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  1 - \\<i>\\<^sub>\\<int> = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  1 - \\<i>\\<^sub>\\<int> = - \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"multiplicity \\<dots> z = multiplicity (1 + \\<i>\\<^sub>\\<int>) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)) z =\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z", "by (subst multiplicity_times_unit_left) auto"], ["proof (state)\nthis:\n  multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)) z =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "also"], ["proof (state)\nthis:\n  multiplicity (- \\<i>\\<^sub>\\<int> * (1 + \\<i>\\<^sub>\\<int>)) z =\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "have \"\\<dots> + \\<dots> = 2 * \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) z +\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    2 * multiplicity (1 + \\<i>\\<^sub>\\<int>) z", "by simp"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z +\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n  2 * multiplicity (1 + \\<i>\\<^sub>\\<int>) z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "finally"], ["proof (chain)\npicking this:\n  2 * multiplicity 2 (gauss_int_norm z) =\n  2 * multiplicity (1 + \\<i>\\<^sub>\\<int>) z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * multiplicity 2 (gauss_int_norm z) =\n  2 * multiplicity (1 + \\<i>\\<^sub>\\<int>) z\n\ngoal (1 subgoal):\n 1. multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "by simp"], ["proof (state)\nthis:\n  multiplicity (1 + \\<i>\\<^sub>\\<int>) z = multiplicity 2 (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. z = 0 \\<Longrightarrow>\n    multiplicity (1 + \\<i>\\<^sub>\\<int>) z =\n    multiplicity 2 (gauss_int_norm z)", "qed auto"], ["", "subsection \\<open>Coprimality of an element and its conjugate\\<close>"], ["", "text \\<open>\n  Using the classification of the primes, we now show that if the real and imaginary parts of a\n  Gaussian integer are coprime and its norm is odd, then it is coprime to its own conjugate.\n\\<close>"], ["", "lemma coprime_self_gauss_cnj:\n  assumes \"coprime (ReZ z) (ImZ z)\" and \"odd (gauss_int_norm z)\"\n  shows   \"coprime z (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime z (gauss_cnj z)", "proof (rule coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "assume \"d dvd z\" \"d dvd gauss_cnj z\""], ["proof (state)\nthis:\n  d dvd z\n  d dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "have *: False if \"p \\<in> prime_factors z\" \"p \\<in> prime_factors (gauss_cnj z)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from that"], ["proof (chain)\npicking this:\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)", "have p: \"prime p\" \"p dvd z\" \"p dvd gauss_cnj z\""], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. prime p &&& p dvd z &&& p dvd gauss_cnj z", "by auto"], ["proof (state)\nthis:\n  prime p\n  p dvd z\n  p dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. False", "define p' where \"p' = gauss_cnj p\""], ["proof (state)\nthis:\n  p' = gauss_cnj p\n\ngoal (1 subgoal):\n 1. False", "define d where \"d = gauss_int_norm p\""], ["proof (state)\nthis:\n  d = gauss_int_norm p\n\ngoal (1 subgoal):\n 1. False", "have of_nat_d_eq: \"of_nat d = p * p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat d = p * p'", "by (simp add: p'_def self_mult_gauss_cnj d_def)"], ["proof (state)\nthis:\n  of_nat d = p * p'\n\ngoal (1 subgoal):\n 1. False", "have \"prime_elem p\" \"prime_elem p'\" \"p dvd z\" \"p' dvd z\" \"p dvd gauss_cnj z\" \"p' dvd gauss_cnj z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prime_elem p &&& prime_elem p' &&& p dvd z) &&&\n    p' dvd z &&& p dvd gauss_cnj z &&& p' dvd gauss_cnj z", "using that"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. (prime_elem p &&& prime_elem p' &&& p dvd z) &&&\n    p' dvd z &&& p dvd gauss_cnj z &&& p' dvd gauss_cnj z", "by (auto simp: in_prime_factors_iff p'_def gauss_cnj_dvd_left_iff)"], ["proof (state)\nthis:\n  prime_elem p\n  prime_elem p'\n  p dvd z\n  p' dvd z\n  p dvd gauss_cnj z\n  p' dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. False", "have \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p", "using that"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. prime p", "by auto"], ["proof (state)\nthis:\n  prime p\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  prime p", "obtain q where q: \"prime q\" \"of_nat q dvd z\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases rule: gauss_int_prime_classification)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case one_plus_i"], ["proof (state)\nthis:\n  p = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"2 = gauss_int_norm p\""], ["proof (prove)\nusing this:\n  p = 1 + \\<i>\\<^sub>\\<int>\n\ngoal (1 subgoal):\n 1. 2 = gauss_int_norm p", "by (auto simp: gauss_int_norm_def)"], ["proof (state)\nthis:\n  2 = gauss_int_norm p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  2 = gauss_int_norm p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"gauss_int_norm p dvd gauss_int_norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm p dvd gauss_int_norm z", "using p"], ["proof (prove)\nusing this:\n  prime p\n  p dvd z\n  p dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. gauss_int_norm p dvd gauss_int_norm z", "by (intro gauss_int_norm_dvd_mono) auto"], ["proof (state)\nthis:\n  gauss_int_norm p dvd gauss_int_norm z\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  even (gauss_int_norm z)", "have \"even (gauss_int_norm z)\""], ["proof (prove)\nusing this:\n  even (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. even (gauss_int_norm z)", "."], ["proof (state)\nthis:\n  even (gauss_int_norm z)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 1 + \\<i>\\<^sub>\\<int>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<open>odd (gauss_int_norm z)\\<close>"], ["proof (chain)\npicking this:\n  odd (gauss_int_norm z)\n  even (gauss_int_norm z)", "show ?thesis"], ["proof (prove)\nusing this:\n  odd (gauss_int_norm z)\n  even (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. thesis", "by contradiction"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (cong_3_mod_4 q)"], ["proof (state)\nthis:\n  p = of_nat q\n  prime q\n  [q = 3] (mod 4)\n\ngoal (2 subgoals):\n 1. \\<And>pa.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = of_nat pa; prime pa; [pa = 3] (mod 4)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = of_nat q\n  prime q\n  [q = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. thesis", "using that[of q] p"], ["proof (prove)\nusing this:\n  p = of_nat q\n  prime q\n  [q = 3] (mod 4)\n  \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk> \\<Longrightarrow> thesis\n  prime p\n  p dvd z\n  p dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "case cong_1_mod_4"], ["proof (state)\nthis:\n  prime (gauss_int_norm p)\n  [gauss_int_norm p = 1] (mod 4)\n  0 < ReZ p\n  0 < ImZ p\n  ReZ p \\<noteq> ImZ p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<not>p dvd p'\""], ["proof (prove)\nusing this:\n  prime (gauss_int_norm p)\n  [gauss_int_norm p = 1] (mod 4)\n  0 < ReZ p\n  0 < ImZ p\n  ReZ p \\<noteq> ImZ p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd p'", "unfolding p'_def"], ["proof (prove)\nusing this:\n  prime (gauss_int_norm p)\n  [gauss_int_norm p = 1] (mod 4)\n  0 < ReZ p\n  0 < ImZ p\n  ReZ p \\<noteq> ImZ p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd gauss_cnj p", "by (subst self_dvd_gauss_cnj_iff) auto"], ["proof (state)\nthis:\n  \\<not> p dvd p'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"p * p' dvd z\""], ["proof (prove)\nusing this:\n  \\<not> p dvd p'\n\ngoal (1 subgoal):\n 1. p * p' dvd z", "using p"], ["proof (prove)\nusing this:\n  \\<not> p dvd p'\n  prime p\n  p dvd z\n  p dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. p * p' dvd z", "by (intro prime_elem_mult_dvdI) (auto simp: p'_def gauss_cnj_dvd_left_iff)"], ["proof (state)\nthis:\n  p * p' dvd z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  p * p' dvd z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"p * p' = of_nat (gauss_int_norm p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * p' = of_nat (gauss_int_norm p)", "by (simp add: p'_def self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  p * p' = of_nat (gauss_int_norm p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q.\n                \\<lbrakk>prime q; of_nat q dvd z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     prime (gauss_int_norm p); [gauss_int_norm p = 1] (mod 4); 0 < ReZ p;\n     0 < ImZ p; ReZ p \\<noteq> ImZ p\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  of_nat (gauss_int_norm p) dvd z", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat (gauss_int_norm p) dvd z\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"gauss_int_norm p\"] cong_1_mod_4"], ["proof (prove)\nusing this:\n  of_nat (gauss_int_norm p) dvd z\n  \\<lbrakk>prime (gauss_int_norm p);\n   of_nat (gauss_int_norm p) dvd z\\<rbrakk>\n  \\<Longrightarrow> thesis\n  prime (gauss_int_norm p)\n  [gauss_int_norm p = 1] (mod 4)\n  0 < ReZ p\n  0 < ImZ p\n  ReZ p \\<noteq> ImZ p\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime q\n  of_nat q dvd z\n\ngoal (1 subgoal):\n 1. False", "have \"of_nat q dvd gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat q dvd\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z))", "proof (rule gcd_greatest)"], ["proof (state)\ngoal (2 subgoals):\n 1. of_nat q dvd 2 * of_int (ReZ z)\n 2. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "have \"of_nat q dvd (z + gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat q dvd z + gauss_cnj z", "using q"], ["proof (prove)\nusing this:\n  prime q\n  of_nat q dvd z\n\ngoal (1 subgoal):\n 1. of_nat q dvd z + gauss_cnj z", "by (auto simp: gauss_cnj_dvd_right_iff)"], ["proof (state)\nthis:\n  of_nat q dvd z + gauss_cnj z\n\ngoal (2 subgoals):\n 1. of_nat q dvd 2 * of_int (ReZ z)\n 2. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "also"], ["proof (state)\nthis:\n  of_nat q dvd z + gauss_cnj z\n\ngoal (2 subgoals):\n 1. of_nat q dvd 2 * of_int (ReZ z)\n 2. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "have \"\\<dots> = 2 * of_int (ReZ z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + gauss_cnj z = 2 * of_int (ReZ z)", "by (simp add: self_plus_gauss_cnj)"], ["proof (state)\nthis:\n  z + gauss_cnj z = 2 * of_int (ReZ z)\n\ngoal (2 subgoals):\n 1. of_nat q dvd 2 * of_int (ReZ z)\n 2. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "finally"], ["proof (chain)\npicking this:\n  of_nat q dvd 2 * of_int (ReZ z)", "show \"of_nat q dvd (2 * of_int (ReZ z) :: gauss_int)\""], ["proof (prove)\nusing this:\n  of_nat q dvd 2 * of_int (ReZ z)\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * of_int (ReZ z)", "."], ["proof (state)\nthis:\n  of_nat q dvd 2 * of_int (ReZ z)\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "have \"of_nat q dvd (z - gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat q dvd z - gauss_cnj z", "using q"], ["proof (prove)\nusing this:\n  prime q\n  of_nat q dvd z\n\ngoal (1 subgoal):\n 1. of_nat q dvd z - gauss_cnj z", "by (auto simp: gauss_cnj_dvd_right_iff)"], ["proof (state)\nthis:\n  of_nat q dvd z - gauss_cnj z\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "also"], ["proof (state)\nthis:\n  of_nat q dvd z - gauss_cnj z\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "have \"\\<dots> = 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z - gauss_cnj z = 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "by (simp add: self_minus_gauss_cnj)"], ["proof (state)\nthis:\n  z - gauss_cnj z = 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "finally"], ["proof (chain)\npicking this:\n  of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "show \"of_nat q dvd (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z))\""], ["proof (prove)\nusing this:\n  of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)\n\ngoal (1 subgoal):\n 1. of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)", "."], ["proof (state)\nthis:\n  of_nat q dvd 2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat q dvd\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z))\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  of_nat q dvd\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z))\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "have \"odd (ReZ z) \\<or> odd (ImZ z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd (ReZ z) \\<or> odd (ImZ z)", "using assms"], ["proof (prove)\nusing this:\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. odd (ReZ z) \\<or> odd (ImZ z)", "by (auto simp: gauss_int_norm_def even_nat_iff)"], ["proof (state)\nthis:\n  odd (ReZ z) \\<or> odd (ImZ z)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  odd (ReZ z) \\<or> odd (ImZ z)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. odd (ReZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n 2. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "assume \"odd (ReZ z)\""], ["proof (state)\nthis:\n  odd (ReZ z)\n\ngoal (2 subgoals):\n 1. odd (ReZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n 2. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "hence \"coprime (of_int (ReZ z)) (of_int 2 :: gauss_int)\""], ["proof (prove)\nusing this:\n  odd (ReZ z)\n\ngoal (1 subgoal):\n 1. coprime (of_int (ReZ z)) (of_int 2)", "unfolding coprime_of_int_gauss_int coprime_right_2_iff_odd"], ["proof (prove)\nusing this:\n  odd (ReZ z)\n\ngoal (1 subgoal):\n 1. odd (ReZ z)", "."], ["proof (state)\nthis:\n  coprime (of_int (ReZ z)) (of_int 2)\n\ngoal (2 subgoals):\n 1. odd (ReZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n 2. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  coprime (of_int (ReZ z)) (of_int 2)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "using assms"], ["proof (prove)\nusing this:\n  coprime (of_int (ReZ z)) (of_int 2)\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "by (subst gcd_mult_left_right_cancel)\n             (auto simp: coprime_of_int_gauss_int coprime_commute is_unit_left_imp_coprime\n                         is_unit_right_imp_coprime gcd_proj1_if_dvd gcd_proj2_if_dvd)"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "assume \"odd (ImZ z)\""], ["proof (state)\nthis:\n  odd (ImZ z)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "hence \"coprime (of_int (ImZ z)) (of_int 2 :: gauss_int)\""], ["proof (prove)\nusing this:\n  odd (ImZ z)\n\ngoal (1 subgoal):\n 1. coprime (of_int (ImZ z)) (of_int 2)", "unfolding coprime_of_int_gauss_int coprime_right_2_iff_odd"], ["proof (prove)\nusing this:\n  odd (ImZ z)\n\ngoal (1 subgoal):\n 1. odd (ImZ z)", "."], ["proof (state)\nthis:\n  coprime (of_int (ImZ z)) (of_int 2)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "hence \"gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\nusing this:\n  coprime (of_int (ImZ z)) (of_int 2)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>)", "using assms"], ["proof (prove)\nusing this:\n  coprime (of_int (ImZ z)) (of_int 2)\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>)", "by (subst gcd_mult_right_right_cancel)\n             (auto simp: coprime_of_int_gauss_int coprime_commute is_unit_left_imp_coprime\n                         is_unit_right_imp_coprime)"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "also"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "have \"\\<dots> = normalize (2 * gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>) =\n    normalize (2 * gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int>)", "by (subst gcd_mult_left) auto"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>) =\n  normalize (2 * gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "also"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int>) =\n  normalize (2 * gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int>)\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "have \"gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int> = 1", "by (subst coprime_iff_gcd_eq_1 [symmetric], rule is_unit_right_imp_coprime) auto"], ["proof (state)\nthis:\n  gcd (of_int (ReZ z)) \\<i>\\<^sub>\\<int> = 1\n\ngoal (1 subgoal):\n 1. odd (ImZ z) \\<Longrightarrow>\n    gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "finally"], ["proof (chain)\npicking this:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n  normalize (2 * 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) =\n  normalize (2 * 1)\n\ngoal (1 subgoal):\n 1. gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2", "by simp"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd (2 * of_int (ReZ z)) (2 * \\<i>\\<^sub>\\<int> * of_int (ImZ z)) = 2\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  of_nat q dvd 2", "have \"of_nat q dvd (of_nat 2 :: gauss_int)\""], ["proof (prove)\nusing this:\n  of_nat q dvd 2\n\ngoal (1 subgoal):\n 1. of_nat q dvd of_nat 2", "by simp"], ["proof (state)\nthis:\n  of_nat q dvd of_nat 2\n\ngoal (1 subgoal):\n 1. False", "hence \"q dvd 2\""], ["proof (prove)\nusing this:\n  of_nat q dvd of_nat 2\n\ngoal (1 subgoal):\n 1. q dvd 2", "by (simp only: of_nat_dvd_of_nat_gauss_int_iff)"], ["proof (state)\nthis:\n  q dvd 2\n\ngoal (1 subgoal):\n 1. False", "with \\<open>prime q\\<close>"], ["proof (chain)\npicking this:\n  prime q\n  q dvd 2", "have \"q = 2\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2\n\ngoal (1 subgoal):\n 1. q = 2", "using primes_dvd_imp_eq two_is_prime_nat"], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2\n  \\<lbrakk>prime ?p; prime ?q; ?p dvd ?q\\<rbrakk> \\<Longrightarrow> ?p = ?q\n  prime 2\n\ngoal (1 subgoal):\n 1. q = 2", "by blast"], ["proof (state)\nthis:\n  q = 2\n\ngoal (1 subgoal):\n 1. False", "with q"], ["proof (chain)\npicking this:\n  prime q\n  of_nat q dvd z\n  q = 2", "have \"2 dvd z\""], ["proof (prove)\nusing this:\n  prime q\n  of_nat q dvd z\n  q = 2\n\ngoal (1 subgoal):\n 1. 2 dvd z", "by auto"], ["proof (state)\nthis:\n  2 dvd z\n\ngoal (1 subgoal):\n 1. False", "have \"2 dvd gauss_int_norm 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. even (gauss_int_norm 2)", "by simp"], ["proof (state)\nthis:\n  even (gauss_int_norm 2)\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  even (gauss_int_norm 2)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> dvd gauss_int_norm z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm 2 dvd gauss_int_norm z", "using \\<open>2 dvd z\\<close>"], ["proof (prove)\nusing this:\n  2 dvd z\n\ngoal (1 subgoal):\n 1. gauss_int_norm 2 dvd gauss_int_norm z", "by (intro gauss_int_norm_dvd_mono)"], ["proof (state)\nthis:\n  gauss_int_norm 2 dvd gauss_int_norm z\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  even (gauss_int_norm z)", "show False"], ["proof (prove)\nusing this:\n  even (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>odd (gauss_int_norm z)\\<close>"], ["proof (prove)\nusing this:\n  even (gauss_int_norm z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?p \\<in># prime_factorization z;\n   ?p \\<in># prime_factorization (gauss_cnj z)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "fix d :: gauss_int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "assume d: \"d dvd z\" \"d dvd gauss_cnj z\""], ["proof (state)\nthis:\n  d dvd z\n  d dvd gauss_cnj z\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd z; c dvd gauss_cnj z\\<rbrakk>\n       \\<Longrightarrow> is_unit c", "show \"is_unit d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "assume \"\\<not>is_unit d\""], ["proof (state)\nthis:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> is_unit d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "from d assms"], ["proof (chain)\npicking this:\n  d dvd z\n  d dvd gauss_cnj z\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)", "have \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  d dvd z\n  d dvd gauss_cnj z\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_unit d\n  d \\<noteq> 0", "obtain p where p: \"prime p\" \"p dvd d\""], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_divisorE"], ["proof (prove)\nusing this:\n  \\<not> is_unit d\n  d \\<noteq> 0\n  \\<lbrakk>?a \\<noteq> (0::?'a); \\<not> is_unit ?a;\n   \\<And>p.\n      \\<lbrakk>prime p; p dvd ?a\\<rbrakk> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime p\n  p dvd d\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "with d"], ["proof (chain)\npicking this:\n  d dvd z\n  d dvd gauss_cnj z\n  prime p\n  p dvd d", "have \"p \\<in> prime_factors z\" \"p \\<in> prime_factors (gauss_cnj z)\""], ["proof (prove)\nusing this:\n  d dvd z\n  d dvd gauss_cnj z\n  prime p\n  p dvd d\n\ngoal (1 subgoal):\n 1. p \\<in># prime_factorization z &&&\n    p \\<in># prime_factorization (gauss_cnj z)", "using assms"], ["proof (prove)\nusing this:\n  d dvd z\n  d dvd gauss_cnj z\n  prime p\n  p dvd d\n  coprime (ReZ z) (ImZ z)\n  odd (gauss_int_norm z)\n\ngoal (1 subgoal):\n 1. p \\<in># prime_factorization z &&&\n    p \\<in># prime_factorization (gauss_cnj z)", "by (auto simp: in_prime_factors_iff)"], ["proof (state)\nthis:\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit d \\<Longrightarrow> False", "with *[of p]"], ["proof (chain)\npicking this:\n  \\<lbrakk>p \\<in># prime_factorization z;\n   p \\<in># prime_factorization (gauss_cnj z)\\<rbrakk>\n  \\<Longrightarrow> False\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<in># prime_factorization z;\n   p \\<in># prime_factorization (gauss_cnj z)\\<rbrakk>\n  \\<Longrightarrow> False\n  p \\<in># prime_factorization z\n  p \\<in># prime_factorization (gauss_cnj z)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Square decompositions of prime numbers congruent 1 mod 4\\<close>"], ["", "lemma prime_1_mod_4_sum_of_squares_unique_aux:\n  fixes p x y :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\" \"x ^ 2 + y ^ 2 = p\"\n  shows   \"x > 0 \\<and> y > 0 \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<and> 0 < y \\<and> x \\<noteq> y", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < x\n 2. 0 < y\n 3. x = y \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  [p = 1] (mod 4)\n  x\\<^sup>2 + y\\<^sup>2 = p", "show \"x > 0\" \"y > 0\""], ["proof (prove)\nusing this:\n  prime p\n  [p = 1] (mod 4)\n  x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. 0 < x &&& 0 < y", "by (auto intro!: Nat.gr0I simp: prime_power_iff)"], ["proof (state)\nthis:\n  0 < x\n  0 < y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> False", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  [p = 1] (mod 4)\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x = y", "have \"p = 2 * x ^ 2\""], ["proof (prove)\nusing this:\n  prime p\n  [p = 1] (mod 4)\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x = y\n\ngoal (1 subgoal):\n 1. p = 2 * x\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  p = 2 * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> False", "with \\<open>prime p\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  p = 2 * x\\<^sup>2", "have \"p = 2\""], ["proof (prove)\nusing this:\n  prime p\n  p = 2 * x\\<^sup>2\n\ngoal (1 subgoal):\n 1. p = 2", "by (auto dest: prime_product)"], ["proof (state)\nthis:\n  p = 2\n\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> False", "with \\<open>[p = 1] (mod 4)\\<close>"], ["proof (chain)\npicking this:\n  [p = 1] (mod 4)\n  p = 2", "show False"], ["proof (prove)\nusing this:\n  [p = 1] (mod 4)\n  p = 2\n\ngoal (1 subgoal):\n 1. False", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Any prime number congruent 1 modulo 4 can be written \\<^emph>\\<open>uniquely\\<close> as a sum of two squares\n  $x^2 + y^2$ (up to commutativity of the addition). Additionally, we have shown above that\n  \\<open>x\\<close> and \\<open>y\\<close> are both positive and \\<open>x \\<noteq> y\\<close>.\n\\<close>"], ["", "lemma prime_1_mod_4_sum_of_squares_unique:\n  fixes p :: nat\n  assumes \"prime p\" \"[p = 1] (mod 4)\"\n  shows   \"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       case x of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "obtain z where z: \"gauss_int_norm z = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        gauss_int_norm z = p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_cong_1_mod_4_gauss_int_norm_exists[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>z. gauss_int_norm z = p \\<and> 0 < ReZ z \\<and> 0 < ImZ z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        gauss_int_norm z = p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  gauss_int_norm z = p\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       case x of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"\\<exists>z. case z of (x,y) \\<Rightarrow> x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "proof (cases \"\\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "case True"], ["proof (state)\nthis:\n  \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>\n\ngoal (2 subgoals):\n 1. \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "with z"], ["proof (chain)\npicking this:\n  gauss_int_norm z = p\n  \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_int_norm z = p\n  \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by\n      (intro exI[of _ \"(nat \\<bar>ReZ z\\<bar>, nat \\<bar>ImZ z\\<bar>)\"])\n      (auto simp: gauss_int_norm_def nat_add_distrib simp flip: nat_power_eq)"], ["proof (state)\nthis:\n  \\<exists>z.\n     case z of\n     (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "case False"], ["proof (state)\nthis:\n  \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar> \\<Longrightarrow>\n    \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "with z"], ["proof (chain)\npicking this:\n  gauss_int_norm z = p\n  \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_int_norm z = p\n  \\<not> \\<bar>ReZ z\\<bar> \\<le> \\<bar>ImZ z\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       case z of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by\n      (intro exI[of _ \"(nat \\<bar>ImZ z\\<bar>, nat \\<bar>ReZ z\\<bar>)\"])\n      (auto simp: gauss_int_norm_def nat_add_distrib simp flip: nat_power_eq)"], ["proof (state)\nthis:\n  \\<exists>z.\n     case z of\n     (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z.\n     case z of\n     (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix z1 z2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume z1: \"case z1 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\""], ["proof (state)\nthis:\n  case z1 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume z2: \"case z2 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\""], ["proof (state)\nthis:\n  case z2 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "define z1' :: gauss_int where \"z1' = of_nat (fst z1) + \\<i>\\<^sub>\\<int> * of_nat (snd z1)\""], ["proof (state)\nthis:\n  z1' = of_nat (fst z1) + \\<i>\\<^sub>\\<int> * of_nat (snd z1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "define z2' :: gauss_int where \"z2' = of_nat (fst z2) + \\<i>\\<^sub>\\<int> * of_nat (snd z2)\""], ["proof (state)\nthis:\n  z2' = of_nat (fst z2) + \\<i>\\<^sub>\\<int> * of_nat (snd z2)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  [p = 1] (mod 4)", "interpret noninert_gauss_int_prime p"], ["proof (prove)\nusing this:\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. noninert_gauss_int_prime p", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have norm_z1': \"gauss_int_norm z1' = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm z1' = p", "using z1"], ["proof (prove)\nusing this:\n  case z1 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. gauss_int_norm z1' = p", "by (simp add: z1'_def gauss_int_norm_def case_prod_unfold nat_add_distrib nat_power_eq)"], ["proof (state)\nthis:\n  gauss_int_norm z1' = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have norm_z2': \"gauss_int_norm z2' = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm z2' = p", "using z2"], ["proof (prove)\nusing this:\n  case z2 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. gauss_int_norm z2' = p", "by (simp add: z2'_def gauss_int_norm_def case_prod_unfold nat_add_distrib nat_power_eq)"], ["proof (state)\nthis:\n  gauss_int_norm z2' = p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have sgns: \"fst z1 > 0\" \"snd z1 > 0\" \"fst z2 > 0\" \"snd z2 > 0\" \"fst z1 \\<noteq> snd z1\" \"fst z2 \\<noteq> snd z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < fst z1 &&& 0 < snd z1 &&& 0 < fst z2) &&&\n    0 < snd z2 &&& fst z1 \\<noteq> snd z1 &&& fst z2 \\<noteq> snd z2", "using prime_1_mod_4_sum_of_squares_unique_aux[OF assms, of \"fst z1\" \"snd z1\"] z1\n          prime_1_mod_4_sum_of_squares_unique_aux[OF assms, of \"fst z2\" \"snd z2\"] z2"], ["proof (prove)\nusing this:\n  (fst z1)\\<^sup>2 + (snd z1)\\<^sup>2 = p \\<Longrightarrow>\n  0 < fst z1 \\<and> 0 < snd z1 \\<and> fst z1 \\<noteq> snd z1\n  case z1 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n  (fst z2)\\<^sup>2 + (snd z2)\\<^sup>2 = p \\<Longrightarrow>\n  0 < fst z2 \\<and> 0 < snd z2 \\<and> fst z2 \\<noteq> snd z2\n  case z2 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. (0 < fst z1 &&& 0 < snd z1 &&& 0 < fst z2) &&&\n    0 < snd z2 &&& fst z1 \\<noteq> snd z1 &&& fst z2 \\<noteq> snd z2", "by auto"], ["proof (state)\nthis:\n  0 < fst z1\n  0 < snd z1\n  0 < fst z2\n  0 < snd z2\n  fst z1 \\<noteq> snd z1\n  fst z2 \\<noteq> snd z2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have [simp]: \"normalize z1' = z1'\" \"normalize z2' = z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize z1' = z1' &&& normalize z2' = z2'", "using sgns"], ["proof (prove)\nusing this:\n  0 < fst z1\n  0 < snd z1\n  0 < fst z2\n  0 < snd z2\n  fst z1 \\<noteq> snd z1\n  fst z2 \\<noteq> snd z2\n\ngoal (1 subgoal):\n 1. normalize z1' = z1' &&& normalize z2' = z2'", "by (subst normalized_gauss_int_iff; simp add: z1'_def z2'_def)+"], ["proof (state)\nthis:\n  normalize z1' = z1'\n  normalize z2' = z2'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"prime z1'\" \"prime z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime z1' &&& prime z2'", "using norm_z1' norm_z2' assms"], ["proof (prove)\nusing this:\n  gauss_int_norm z1' = p\n  gauss_int_norm z2' = p\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. prime z1' &&& prime z2'", "unfolding prime_def"], ["proof (prove)\nusing this:\n  gauss_int_norm z1' = p\n  gauss_int_norm z2' = p\n  prime_elem p \\<and> normalize p = p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. prime_elem z1' \\<and> normalize z1' = z1' &&&\n    prime_elem z2' \\<and> normalize z2' = z2'", "by (auto simp: prime_gauss_int_norm_imp_prime_elem)"], ["proof (state)\nthis:\n  prime z1'\n  prime z2'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"of_nat p = z1' * gauss_cnj z1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p = z1' * gauss_cnj z1'", "by (simp add: self_mult_gauss_cnj norm_z1')"], ["proof (state)\nthis:\n  of_nat p = z1' * gauss_cnj z1'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"z1' dvd of_nat p\""], ["proof (prove)\nusing this:\n  of_nat p = z1' * gauss_cnj z1'\n\ngoal (1 subgoal):\n 1. z1' dvd of_nat p", "by simp"], ["proof (state)\nthis:\n  z1' dvd of_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  z1' dvd of_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"of_nat p = z2' * gauss_cnj z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p = z2' * gauss_cnj z2'", "by (simp add: self_mult_gauss_cnj norm_z2')"], ["proof (state)\nthis:\n  of_nat p = z2' * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  z1' dvd z2' * gauss_cnj z2'", "have \"z1' dvd z2' \\<or> z1' dvd gauss_cnj z2'\""], ["proof (prove)\nusing this:\n  z1' dvd z2' * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd z2' \\<or> z1' dvd gauss_cnj z2'", "using assms"], ["proof (prove)\nusing this:\n  z1' dvd z2' * gauss_cnj z2'\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. z1' dvd z2' \\<or> z1' dvd gauss_cnj z2'", "by (subst (asm) prime_elem_dvd_mult_iff)\n       (simp add: norm_z1' prime_gauss_int_norm_imp_prime_elem)"], ["proof (state)\nthis:\n  z1' dvd z2' \\<or> z1' dvd gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, y) \\<Rightarrow>\n                  x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p;\n        case y of\n        (x, y) \\<Rightarrow>\n          x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"z1 = z2\""], ["proof (prove)\nusing this:\n  z1' dvd z2' \\<or> z1' dvd gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1 = z2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z1' dvd z2' \\<Longrightarrow> z1 = z2\n 2. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "assume \"z1' dvd z2'\""], ["proof (state)\nthis:\n  z1' dvd z2'\n\ngoal (2 subgoals):\n 1. z1' dvd z2' \\<Longrightarrow> z1 = z2\n 2. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "with \\<open>prime z1'\\<close> \\<open>prime z2'\\<close>"], ["proof (chain)\npicking this:\n  prime z1'\n  prime z2'\n  z1' dvd z2'", "have \"z1' = z2'\""], ["proof (prove)\nusing this:\n  prime z1'\n  prime z2'\n  z1' dvd z2'\n\ngoal (1 subgoal):\n 1. z1' = z2'", "by (simp add: primes_dvd_imp_eq)"], ["proof (state)\nthis:\n  z1' = z2'\n\ngoal (2 subgoals):\n 1. z1' dvd z2' \\<Longrightarrow> z1 = z2\n 2. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  z1' = z2'\n\ngoal (1 subgoal):\n 1. z1 = z2", "by (simp add: z1'_def z2'_def gauss_int_eq_iff prod_eq_iff)"], ["proof (state)\nthis:\n  z1 = z2\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "assume dvd: \"z1' dvd gauss_cnj z2'\""], ["proof (state)\nthis:\n  z1' dvd gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "have \"normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') = \\<i>\\<^sub>\\<int> * gauss_cnj z2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n    \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "using sgns"], ["proof (prove)\nusing this:\n  0 < fst z1\n  0 < snd z1\n  0 < fst z2\n  0 < snd z2\n  fst z1 \\<noteq> snd z1\n  fst z2 \\<noteq> snd z2\n\ngoal (1 subgoal):\n 1. normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n    \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "by (subst normalized_gauss_int_iff) (auto simp: z2'_def)"], ["proof (state)\nthis:\n  normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n  \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "moreover"], ["proof (state)\nthis:\n  normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n  \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "have \"prime_elem (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem (\\<i>\\<^sub>\\<int> * gauss_cnj z2')", "by (rule prime_gauss_int_norm_imp_prime_elem)\n         (simp add: gauss_int_norm_mult norm_z2' \\<open>prime p\\<close>)"], ["proof (state)\nthis:\n  prime_elem (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "ultimately"], ["proof (chain)\npicking this:\n  normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n  \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n  prime_elem (\\<i>\\<^sub>\\<int> * gauss_cnj z2')", "have \"prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\""], ["proof (prove)\nusing this:\n  normalize (\\<i>\\<^sub>\\<int> * gauss_cnj z2') =\n  \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n  prime_elem (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n\ngoal (1 subgoal):\n 1. prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')", "by (simp add: prime_def)"], ["proof (state)\nthis:\n  prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "moreover"], ["proof (state)\nthis:\n  prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "from dvd"], ["proof (chain)\npicking this:\n  z1' dvd gauss_cnj z2'", "have \"z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'\""], ["proof (prove)\nusing this:\n  z1' dvd gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "by simp"], ["proof (state)\nthis:\n  z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "ultimately"], ["proof (chain)\npicking this:\n  prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n  z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "have \"z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'\""], ["proof (prove)\nusing this:\n  prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n  z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "using \\<open>prime z1'\\<close>"], ["proof (prove)\nusing this:\n  prime (\\<i>\\<^sub>\\<int> * gauss_cnj z2')\n  z1' dvd \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n  prime z1'\n\ngoal (1 subgoal):\n 1. z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'", "by (simp add: primes_dvd_imp_eq)"], ["proof (state)\nthis:\n  z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "hence False"], ["proof (prove)\nusing this:\n  z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n\ngoal (1 subgoal):\n 1. False", "using z1 z2 sgns"], ["proof (prove)\nusing this:\n  z1' = \\<i>\\<^sub>\\<int> * gauss_cnj z2'\n  case z1 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n  case z2 of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n  0 < fst z1\n  0 < snd z1\n  0 < fst z2\n  0 < snd z2\n  fst z1 \\<noteq> snd z1\n  fst z2 \\<noteq> snd z2\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: gauss_int_eq_iff z1'_def z2'_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. z1' dvd gauss_cnj z2' \\<Longrightarrow> z1 = z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. z1 = z2", ".."], ["proof (state)\nthis:\n  z1 = z2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z1 = z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_sum_of_squares_nat_iff: \"(x :: nat) ^ 2 + y ^ 2 = 2 \\<longleftrightarrow> x = 1 \\<and> y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 + y\\<^sup>2 = 2) = (x = 1 \\<and> y = 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "assume eq: \"x ^ 2 + y ^ 2 = 2\""], ["proof (state)\nthis:\n  x\\<^sup>2 + y\\<^sup>2 = 2\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "have square_neq_2: \"n ^ 2 \\<noteq> 2\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sup>2 \\<noteq> 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n\\<^sup>2 = 2 \\<Longrightarrow> False", "assume *: \"n ^ 2 = 2\""], ["proof (state)\nthis:\n  n\\<^sup>2 = 2\n\ngoal (1 subgoal):\n 1. n\\<^sup>2 = 2 \\<Longrightarrow> False", "have \"prime (2 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime 2", "by simp"], ["proof (state)\nthis:\n  prime 2\n\ngoal (1 subgoal):\n 1. n\\<^sup>2 = 2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  prime 2\n\ngoal (1 subgoal):\n 1. False", "by (subst (asm) * [symmetric]) (auto simp: prime_power_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n\\<^sup>2 \\<noteq> 2\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "from eq"], ["proof (chain)\npicking this:\n  x\\<^sup>2 + y\\<^sup>2 = 2", "have \"x ^ 2 < 2 ^ 2\" \"y ^ 2 < 2 ^ 2\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 + y\\<^sup>2 = 2\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 < 2\\<^sup>2 &&& y\\<^sup>2 < 2\\<^sup>2", "by simp_all"], ["proof (state)\nthis:\n  x\\<^sup>2 < 2\\<^sup>2\n  y\\<^sup>2 < 2\\<^sup>2\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "hence \"x < 2\" \"y < 2\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 < 2\\<^sup>2\n  y\\<^sup>2 < 2\\<^sup>2\n\ngoal (1 subgoal):\n 1. x < 2 &&& y < 2", "using power2_less_imp_less[of x 2] power2_less_imp_less[of y 2]"], ["proof (prove)\nusing this:\n  x\\<^sup>2 < 2\\<^sup>2\n  y\\<^sup>2 < 2\\<^sup>2\n  \\<lbrakk>x\\<^sup>2 < 2\\<^sup>2; 0 \\<le> 2\\<rbrakk> \\<Longrightarrow> x < 2\n  \\<lbrakk>y\\<^sup>2 < 2\\<^sup>2; 0 \\<le> 2\\<rbrakk> \\<Longrightarrow> y < 2\n\ngoal (1 subgoal):\n 1. x < 2 &&& y < 2", "by auto"], ["proof (state)\nthis:\n  x < 2\n  y < 2\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "moreover"], ["proof (state)\nthis:\n  x < 2\n  y < 2\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "have \"x > 0\" \"y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x &&& 0 < y", "using eq square_neq_2[of x] square_neq_2[of y]"], ["proof (prove)\nusing this:\n  x\\<^sup>2 + y\\<^sup>2 = 2\n  x\\<^sup>2 \\<noteq> 2\n  y\\<^sup>2 \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 0 < x &&& 0 < y", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  0 < x\n  0 < y\n\ngoal (2 subgoals):\n 1. x\\<^sup>2 + y\\<^sup>2 = 2 \\<Longrightarrow> x = 1 \\<and> y = 1\n 2. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "ultimately"], ["proof (chain)\npicking this:\n  x < 2\n  y < 2\n  0 < x\n  0 < y", "show \"x = 1 \\<and> y = 1\""], ["proof (prove)\nusing this:\n  x < 2\n  y < 2\n  0 < x\n  0 < y\n\ngoal (1 subgoal):\n 1. x = 1 \\<and> y = 1", "by auto"], ["proof (state)\nthis:\n  x = 1 \\<and> y = 1\n\ngoal (1 subgoal):\n 1. x = 1 \\<and> y = 1 \\<Longrightarrow> x\\<^sup>2 + y\\<^sup>2 = 2", "qed auto"], ["", "lemma prime_sum_of_squares_unique:\n  fixes p :: nat\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  shows   \"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "using assms(2)"], ["proof (prove)\nusing this:\n  p = 2 \\<or> [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. [p = 1] (mod 4) \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "assume [simp]: \"p = 2\""], ["proof (state)\nthis:\n  p = 2\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. [p = 1] (mod 4) \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "have **: \"(\\<lambda>(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p) = (\\<lambda>z. z = (1,1 :: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) =\n    (\\<lambda>z. z = (1, 1))", "using two_sum_of_squares_nat_iff"], ["proof (prove)\nusing this:\n  (?x\\<^sup>2 + ?y\\<^sup>2 = 2) = (?x = 1 \\<and> ?y = 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) =\n    (\\<lambda>z. z = (1, 1))", "by (auto simp: fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) =\n  (\\<lambda>z. z = (1, 1))\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. [p = 1] (mod 4) \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) =\n  (\\<lambda>z. z = (1, 1))\n\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by (subst **) auto"], ["proof (state)\nthis:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "qed (use prime_1_mod_4_sum_of_squares_unique[of p] assms in auto)"], ["", "text \\<open>\n  We now give a simple and inefficient algorithm to compute the canonical decomposition\n  $x ^ 2 + y ^ 2$ with $x\\leq y$.\n\\<close>"], ["", "definition prime_square_sum_nat_decomp :: \"nat \\<Rightarrow> nat \\<times> nat\" where\n  \"prime_square_sum_nat_decomp p =\n     (if prime p \\<and> (p = 2 \\<or> [p = 1] (mod 4))\n      then THE (x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p else (0, 0))\""], ["", "lemma prime_square_sum_nat_decomp_eqI:\n  assumes \"prime p\" \"x ^ 2 + y ^ 2 = p\" \"x \\<le> y\"\n  shows   \"prime_square_sum_nat_decomp p = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "have \"[gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<noteq> 3] (mod 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [gauss_int_norm\n      (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<noteq> 3] (mod 4)", "by (rule gauss_int_norm_not_3_mod_4)"], ["proof (state)\nthis:\n  [gauss_int_norm\n    (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "also"], ["proof (state)\nthis:\n  [gauss_int_norm\n    (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "have \"gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p", "by (auto simp: gauss_int_norm_def nat_add_distrib nat_power_eq)"], ["proof (state)\nthis:\n  gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "finally"], ["proof (chain)\npicking this:\n  [p \\<noteq> 3] (mod 4)", "have \"[p \\<noteq> 3] (mod 4)\""], ["proof (prove)\nusing this:\n  [p \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. [p \\<noteq> 3] (mod 4)", "."], ["proof (state)\nthis:\n  [p \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "with prime_mod_4_cases[of p] assms"], ["proof (chain)\npicking this:\n  prime p \\<Longrightarrow>\n  p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n  prime p\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n  [p \\<noteq> 3] (mod 4)", "have *: \"p = 2 \\<or> [p = 1] (mod 4)\""], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow>\n  p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n  prime p\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n  [p \\<noteq> 3] (mod 4)\n\ngoal (1 subgoal):\n 1. p = 2 \\<or> [p = 1] (mod 4)", "by auto"], ["proof (state)\nthis:\n  p = 2 \\<or> [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "have \"prime_square_sum_nat_decomp p = (THE (x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)", "using * \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  p = 2 \\<or> [p = 1] (mod 4)\n  prime p\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)", "by (simp add: prime_square_sum_nat_decomp_def)"], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p =\n  (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "also"], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p =\n  (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "have \"\\<dots> = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) = (x, y)", "proof (rule the1_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x.\n       case x of\n       (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n 2. case (x, y) of\n    (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "show \"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "using \\<open>prime p\\<close> *"], ["proof (prove)\nusing this:\n  prime p\n  p = 2 \\<or> [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by (rule prime_sum_of_squares_unique)"], ["proof (state)\nthis:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. case (x, y) of\n    (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "qed (use assms in auto)"], ["proof (state)\nthis:\n  (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p) = (x, y)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "finally"], ["proof (chain)\npicking this:\n  prime_square_sum_nat_decomp p = (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_square_sum_nat_decomp p = (x, y)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (x, y)", "."], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p = (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_square_sum_nat_decomp_correct:\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  defines \"z \\<equiv> prime_square_sum_nat_decomp p\"\n  shows \"fst z ^ 2 + snd z ^ 2 = p\" \"fst z \\<le> snd z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p &&& fst z \\<le> snd z", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "define z' where \"z' = (THE (x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p)\""], ["proof (state)\nthis:\n  z' = (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)\n\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "have \"z = z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = z'", "unfolding z_def z'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  p = 2 \\<or> [p = 1] (mod 4)\n  z \\<equiv> prime_square_sum_nat_decomp p\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p)", "by (simp add: prime_square_sum_nat_decomp_def)"], ["proof (state)\nthis:\n  z = z'\n\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "also"], ["proof (state)\nthis:\n  z = z'\n\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "have\"\\<exists>!(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  p = 2 \\<or> [p = 1] (mod 4)\n  z \\<equiv> prime_square_sum_nat_decomp p\n\ngoal (1 subgoal):\n 1. \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by (intro prime_sum_of_squares_unique)"], ["proof (state)\nthis:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "hence \"case z' of (x, y) \\<Rightarrow> x \\<le> y \\<and> x ^ 2 + y ^ 2 = p\""], ["proof (prove)\nusing this:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. case z' of\n    (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "unfolding z'_def"], ["proof (prove)\nusing this:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. case THE (x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p of\n    (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "by (rule theI')"], ["proof (state)\nthis:\n  case z' of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (2 subgoals):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n 2. fst z \\<le> snd z", "finally"], ["proof (chain)\npicking this:\n  case z of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p", "show \"fst z ^ 2 + snd z ^ 2 = p\" \"fst z \\<le> snd z\""], ["proof (prove)\nusing this:\n  case z of (x, y) \\<Rightarrow> x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p &&& fst z \\<le> snd z", "by auto"], ["proof (state)\nthis:\n  (fst z)\\<^sup>2 + (snd z)\\<^sup>2 = p\n  fst z \\<le> snd z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_of_squares_nat_bound:\n  fixes x y n :: nat\n  assumes \"x ^ 2 + y ^ 2 = n\"\n  shows   \"x \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> n", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "hence \"x * 1 \\<le> x ^ 2\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * 1 \\<le> x\\<^sup>2", "unfolding power2_eq_square"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * 1 \\<le> x * x", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  x * 1 \\<le> x\\<^sup>2\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "also"], ["proof (state)\nthis:\n  x * 1 \\<le> x\\<^sup>2\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "have \"\\<dots> \\<le> x ^ 2 + y ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 \\<le> x\\<^sup>2 + y\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>2 \\<le> x\\<^sup>2 + y\\<^sup>2\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 \\<le> x\\<^sup>2 + y\\<^sup>2\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + y\\<^sup>2 = n", "by fact"], ["proof (state)\nthis:\n  x\\<^sup>2 + y\\<^sup>2 = n\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<le> n\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<le> n", "finally"], ["proof (chain)\npicking this:\n  x * 1 \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  x * 1 \\<le> n\n\ngoal (1 subgoal):\n 1. x \\<le> n", "by simp"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> x \\<le> n", "qed auto"], ["", "lemma sum_of_squares_nat_bound':\n  fixes x y n :: nat\n  assumes \"x ^ 2 + y ^ 2 = n\"\n  shows   \"y \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> n", "using sum_of_squares_nat_bound[of y x] assms"], ["proof (prove)\nusing this:\n  y\\<^sup>2 + x\\<^sup>2 = ?n \\<Longrightarrow> y \\<le> ?n\n  x\\<^sup>2 + y\\<^sup>2 = n\n\ngoal (1 subgoal):\n 1. y \\<le> n", "by (simp add: add.commute)"], ["", "lemma is_singleton_conv_Ex1:\n  \"is_singleton A \\<longleftrightarrow> (\\<exists>!x. x \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_singleton A = (\\<exists>!x. x \\<in> A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_singleton A \\<Longrightarrow> \\<exists>!x. x \\<in> A\n 2. \\<exists>!x. x \\<in> A \\<Longrightarrow> is_singleton A", "assume \"is_singleton A\""], ["proof (state)\nthis:\n  is_singleton A\n\ngoal (2 subgoals):\n 1. is_singleton A \\<Longrightarrow> \\<exists>!x. x \\<in> A\n 2. \\<exists>!x. x \\<in> A \\<Longrightarrow> is_singleton A", "thus \"\\<exists>!x. x \\<in> A\""], ["proof (prove)\nusing this:\n  is_singleton A\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> A", "by (auto elim!: is_singletonE)"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> A \\<Longrightarrow> is_singleton A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> A \\<Longrightarrow> is_singleton A", "assume \"\\<exists>!x. x \\<in> A\""], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> A \\<Longrightarrow> is_singleton A", "thus \"is_singleton A\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> A\n\ngoal (1 subgoal):\n 1. is_singleton A", "by (metis equals0D is_singletonI')"], ["proof (state)\nthis:\n  is_singleton A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_elemI:\n  assumes \"is_singleton A\"\n  shows   \"the_elem A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_elem A \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  is_singleton A\n\ngoal (1 subgoal):\n 1. the_elem A \\<in> A", "by (elim is_singletonE) auto"], ["", "lemma prime_square_sum_nat_decomp_code_aux:\n  assumes \"prime p\" \"p = 2 \\<or> [p = 1] (mod 4)\"\n  defines \"z \\<equiv> the_elem (Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p}))\"\n  shows \"prime_square_sum_nat_decomp p = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "let ?A = \"Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p})\""], ["proof (state)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "have eq: \"?A = {(x,y). x \\<le> y \\<and> x ^ 2 + y ^ 2 = p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n     (SIGMA x:{0..p}. {x..p}) =\n    {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}", "using sum_of_squares_nat_bound [of _ _ p] sum_of_squares_nat_bound' [of _ _ p]"], ["proof (prove)\nusing this:\n  ?x\\<^sup>2 + ?y\\<^sup>2 = p \\<Longrightarrow> ?x \\<le> p\n  ?x\\<^sup>2 + ?y\\<^sup>2 = p \\<Longrightarrow> ?y \\<le> p\n\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n     (SIGMA x:{0..p}. {x..p}) =\n    {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}", "by auto"], ["proof (state)\nthis:\n  Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n   (SIGMA x:{0..p}. {x..p}) =\n  {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "have z: \"z \\<in> Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n             (SIGMA x:{0..p}. {x..p})", "unfolding z_def eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_elem {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}\n    \\<in> {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}", "using prime_sum_of_squares_unique[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  \\<exists>!(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p\n\ngoal (1 subgoal):\n 1. the_elem {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}\n    \\<in> {(x, y). x \\<le> y \\<and> x\\<^sup>2 + y\\<^sup>2 = p}", "by (intro the_elemI) (simp add: is_singleton_conv_Ex1)"], ["proof (state)\nthis:\n  z \\<in> Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n           (SIGMA x:{0..p}. {x..p})\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "have \"prime_square_sum_nat_decomp p = (fst z, snd z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (fst z, snd z)", "using z"], ["proof (prove)\nusing this:\n  z \\<in> Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n           (SIGMA x:{0..p}. {x..p})\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = (fst z, snd z)", "by (intro prime_square_sum_nat_decomp_eqI[OF assms(1)]) auto"], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p = (fst z, snd z)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "also"], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p = (fst z, snd z)\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "have \"\\<dots> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst z, snd z) = z", "by simp"], ["proof (state)\nthis:\n  (fst z, snd z) = z\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "finally"], ["proof (chain)\npicking this:\n  prime_square_sum_nat_decomp p = z", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_square_sum_nat_decomp p = z\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p = z", "."], ["proof (state)\nthis:\n  prime_square_sum_nat_decomp p = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_square_sum_nat_decomp_code [code]:\n  \"prime_square_sum_nat_decomp p =\n     (if prime p \\<and> (p = 2 \\<or> [p = 1] (mod 4))\n      then the_elem (Set.filter (\\<lambda>(x,y). x ^ 2 + y ^ 2 = p) (SIGMA x:{0..p}. {x..p}))\n      else (0, 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (if prime p \\<and> (p = 2 \\<or> [p = 1] (mod 4))\n     then the_elem\n           (Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n             (SIGMA x:{0..p}. {x..p}))\n     else (0, 0))", "using prime_square_sum_nat_decomp_code_aux[of p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; p = 2 \\<or> [p = 1] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> prime_square_sum_nat_decomp p =\n                    the_elem\n                     (Set.filter\n                       (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n                       (SIGMA x:{0..p}. {x..p}))\n\ngoal (1 subgoal):\n 1. prime_square_sum_nat_decomp p =\n    (if prime p \\<and> (p = 2 \\<or> [p = 1] (mod 4))\n     then the_elem\n           (Set.filter (\\<lambda>(x, y). x\\<^sup>2 + y\\<^sup>2 = p)\n             (SIGMA x:{0..p}. {x..p}))\n     else (0, 0))", "by (auto simp: prime_square_sum_nat_decomp_def)"], ["", "subsection \\<open>Executable factorisation of Gaussian integers\\<close>"], ["", "text \\<open>\n  Lastly, we use all of the above to give an executable (albeit not very efficient) factorisation\n  algorithm for Gaussian integers based on factorisation of regular integers. Note that we will\n  only compute the set of prime factors without multiplicity, but given that, it would be fairly\n  easy to determine the multiplicity as well.\n\n  First, we need the following function that computes the Gaussian integer factors of a \n  \\<open>\\<int>\\<close>-prime \\<open>p\\<close>:\n\\<close>"], ["", "definition factor_gauss_int_prime_nat :: \"nat \\<Rightarrow> gauss_int list\" where\n  \"factor_gauss_int_prime_nat p =\n     (if p = 2 then [1 + \\<i>\\<^sub>\\<int>]\n      else if [p = 3] (mod 4) then [of_nat p]\n      else case prime_square_sum_nat_decomp p of\n             (x, y) \\<Rightarrow> [of_nat x + \\<i>\\<^sub>\\<int> * of_nat y, of_nat y + \\<i>\\<^sub>\\<int> * of_nat x])\""], ["", "lemma factor_gauss_int_prime_nat_correct:\n  assumes \"prime p\"\n  shows   \"set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "using prime_mod_4_cases[OF assms]"], ["proof (prove)\nusing this:\n  p = 2 \\<or> [p = 1] (mod 4) \\<or> [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 3. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "assume \"p = 2\""], ["proof (state)\nthis:\n  p = 2\n\ngoal (3 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 3. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 2\n\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "by (auto simp: prime_factorization_2_gauss_int factor_gauss_int_prime_nat_def)"], ["proof (state)\nthis:\n  set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n\ngoal (2 subgoals):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "assume *: \"[p = 3] (mod 4)\""], ["proof (state)\nthis:\n  [p = 3] (mod 4)\n\ngoal (2 subgoals):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "with assms"], ["proof (chain)\npicking this:\n  prime p\n  [p = 3] (mod 4)", "have \"prime (of_nat p :: gauss_int)\""], ["proof (prove)\nusing this:\n  prime p\n  [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. prime (of_nat p)", "by (intro prime_gauss_int_of_nat)"], ["proof (state)\nthis:\n  prime (of_nat p)\n\ngoal (2 subgoals):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n 2. [p = 3] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  prime (of_nat p)\n\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "using assms *"], ["proof (prove)\nusing this:\n  prime (of_nat p)\n  prime p\n  [p = 3] (mod 4)\n\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "by (auto simp: prime_factorization_prime factor_gauss_int_prime_nat_def cong_def)"], ["proof (state)\nthis:\n  set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "assume *: \"[p = 1] (mod 4)\""], ["proof (state)\nthis:\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "then"], ["proof (chain)\npicking this:\n  [p = 1] (mod 4)", "interpret noninert_gauss_int_prime p"], ["proof (prove)\nusing this:\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. noninert_gauss_int_prime p", "using \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  [p = 1] (mod 4)\n  prime p\n\ngoal (1 subgoal):\n 1. noninert_gauss_int_prime p", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "define z where \"z = prime_square_sum_nat_decomp p\""], ["proof (state)\nthis:\n  z = prime_square_sum_nat_decomp p\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "define x y where \"x = fst z\" and \"y = snd z\""], ["proof (state)\nthis:\n  x = fst z\n  y = snd z\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have xy: \"x ^ 2 + y ^ 2 = p\" \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 + y\\<^sup>2 = p &&& x \\<le> y", "using prime_square_sum_nat_decomp_correct[of p] * assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; p = 2 \\<or> [p = 1] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> (fst (prime_square_sum_nat_decomp p))\\<^sup>2 +\n                    (snd (prime_square_sum_nat_decomp p))\\<^sup>2 =\n                    p\n  \\<lbrakk>prime p; p = 2 \\<or> [p = 1] (mod 4)\\<rbrakk>\n  \\<Longrightarrow> fst (prime_square_sum_nat_decomp p)\n                    \\<le> snd (prime_square_sum_nat_decomp p)\n  [p = 1] (mod 4)\n  prime p\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 + y\\<^sup>2 = p &&& x \\<le> y", "by (auto simp: x_def y_def z_def)"], ["proof (state)\nthis:\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "from xy"], ["proof (chain)\npicking this:\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y", "have xy_signs: \"x > 0\" \"y > 0\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < x &&& 0 < y", "using prime_1_mod_4_sum_of_squares_unique_aux[of p x y] assms *"], ["proof (prove)\nusing this:\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n  \\<lbrakk>prime p; [p = 1] (mod 4); x\\<^sup>2 + y\\<^sup>2 = p\\<rbrakk>\n  \\<Longrightarrow> 0 < x \\<and> 0 < y \\<and> x \\<noteq> y\n  prime p\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. 0 < x &&& 0 < y", "by auto"], ["proof (state)\nthis:\n  0 < x\n  0 < y\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have norms: \"gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\"\n              \"gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p &&&\n    gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p", "using xy"], ["proof (prove)\nusing this:\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p &&&\n    gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p", "by (auto simp: gauss_int_norm_def nat_add_distrib nat_power_eq)"], ["proof (state)\nthis:\n  gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\n  gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have prime: \"prime (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y)\" \"prime (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) &&&\n    prime (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)", "using norms xy_signs \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\n  gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p\n  0 < x\n  0 < y\n  prime p\n\ngoal (1 subgoal):\n 1. prime (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) &&&\n    prime (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)", "unfolding prime_def normalized_gauss_int_iff"], ["proof (prove)\nusing this:\n  gauss_int_norm (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) = p\n  gauss_int_norm (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = p\n  0 < x\n  0 < y\n  prime_elem p \\<and> normalize p = p\n\ngoal (1 subgoal):\n 1. prime_elem (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<and>\n    (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y = 0 \\<or>\n     0 < ReZ (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) \\<and>\n     0 \\<le> ImZ (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y)) &&&\n    prime_elem (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) \\<and>\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x = 0 \\<or>\n     0 < ReZ (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) \\<and>\n     0 \\<le> ImZ (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x))", "by (auto intro!: prime_gauss_int_norm_imp_prime_elem)"], ["proof (state)\nthis:\n  prime (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y)\n  prime (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have \"normalize ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) * (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) = of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "have \"(of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) * (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) = (\\<i>\\<^sub>\\<int> * of_nat p :: gauss_int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) =\n    \\<i>\\<^sub>\\<int> * of_nat p", "by (subst xy(1) [symmetric]) (auto simp: gauss_int_eq_iff power2_eq_square)"], ["proof (state)\nthis:\n  (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n  (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) =\n  \\<i>\\<^sub>\\<int> * of_nat p\n\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "also"], ["proof (state)\nthis:\n  (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n  (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x) =\n  \\<i>\\<^sub>\\<int> * of_nat p\n\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "have \"normalize \\<dots> = of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (\\<i>\\<^sub>\\<int> * of_nat p) = of_nat p", "by simp"], ["proof (state)\nthis:\n  normalize (\\<i>\\<^sub>\\<int> * of_nat p) = of_nat p\n\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "finally"], ["proof (chain)\npicking this:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p", "show ?thesis"], ["proof (prove)\nusing this:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p\n\ngoal (1 subgoal):\n 1. normalize\n     ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n      (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n    of_nat p", "."], ["proof (state)\nthis:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "hence \"prime_factorization (of_nat p) =\n         prime_factorization (prod_mset {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y, of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#})\""], ["proof (prove)\nusing this:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p\n\ngoal (1 subgoal):\n 1. prime_factorization (of_nat p) =\n    prime_factorization\n     (\\<Prod>\\<^sub>#\n       {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n         of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#})", "using assms xy"], ["proof (prove)\nusing this:\n  normalize\n   ((of_nat x + \\<i>\\<^sub>\\<int> * of_nat y) *\n    (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)) =\n  of_nat p\n  prime p\n  x\\<^sup>2 + y\\<^sup>2 = p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. prime_factorization (of_nat p) =\n    prime_factorization\n     (\\<Prod>\\<^sub>#\n       {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n         of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#})", "by (subst prime_factorization_unique) (auto simp: gauss_int_eq_iff)"], ["proof (state)\nthis:\n  prime_factorization (of_nat p) =\n  prime_factorization\n   (\\<Prod>\\<^sub>#\n     {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n       of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#})\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "also"], ["proof (state)\nthis:\n  prime_factorization (of_nat p) =\n  prime_factorization\n   (\\<Prod>\\<^sub>#\n     {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n       of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#})\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have \"\\<dots> = {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y, of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization\n     (\\<Prod>\\<^sub>#\n       {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n         of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}) =\n    {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n      of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}", "using prime"], ["proof (prove)\nusing this:\n  prime (of_nat x + \\<i>\\<^sub>\\<int> * of_nat y)\n  prime (of_nat y + \\<i>\\<^sub>\\<int> * of_nat x)\n\ngoal (1 subgoal):\n 1. prime_factorization\n     (\\<Prod>\\<^sub>#\n       {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n         of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}) =\n    {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n      of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}", "by (subst prime_factorization_prod_mset_primes) auto"], ["proof (state)\nthis:\n  prime_factorization\n   (\\<Prod>\\<^sub>#\n     {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n       of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}) =\n  {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n    of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "finally"], ["proof (chain)\npicking this:\n  prime_factorization (of_nat p) =\n  {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n    of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}", "have \"prime_factors (of_nat p) = {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y, of_nat y + \\<i>\\<^sub>\\<int> * of_nat x}\""], ["proof (prove)\nusing this:\n  prime_factorization (of_nat p) =\n  {#of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n    of_nat y + \\<i>\\<^sub>\\<int> * of_nat x#}\n\ngoal (1 subgoal):\n 1. prime_factors (of_nat p) =\n    {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n     of_nat y + \\<i>\\<^sub>\\<int> * of_nat x}", "by simp"], ["proof (state)\nthis:\n  prime_factors (of_nat p) =\n  {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n   of_nat y + \\<i>\\<^sub>\\<int> * of_nat x}\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "also"], ["proof (state)\nthis:\n  prime_factors (of_nat p) =\n  {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n   of_nat y + \\<i>\\<^sub>\\<int> * of_nat x}\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "have \"\\<dots> = set (factor_gauss_int_prime_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n     of_nat y + \\<i>\\<^sub>\\<int> * of_nat x} =\n    set (factor_gauss_int_prime_nat p)", "using *"], ["proof (prove)\nusing this:\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n     of_nat y + \\<i>\\<^sub>\\<int> * of_nat x} =\n    set (factor_gauss_int_prime_nat p)", "unfolding factor_gauss_int_prime_nat_def case_prod_unfold"], ["proof (prove)\nusing this:\n  [p = 1] (mod 4)\n\ngoal (1 subgoal):\n 1. {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n     of_nat y + \\<i>\\<^sub>\\<int> * of_nat x} =\n    set (if p = 2 then [1 + \\<i>\\<^sub>\\<int>]\n         else if [p = 3] (mod 4) then [of_nat p]\n              else [of_nat (fst (prime_square_sum_nat_decomp p)) +\n                    \\<i>\\<^sub>\\<int> *\n                    of_nat (snd (prime_square_sum_nat_decomp p)),\n                    of_nat (snd (prime_square_sum_nat_decomp p)) +\n                    \\<i>\\<^sub>\\<int> *\n                    of_nat (fst (prime_square_sum_nat_decomp p))])", "by (auto simp: cong_def x_def y_def z_def)"], ["proof (state)\nthis:\n  {of_nat x + \\<i>\\<^sub>\\<int> * of_nat y,\n   of_nat y + \\<i>\\<^sub>\\<int> * of_nat x} =\n  set (factor_gauss_int_prime_nat p)\n\ngoal (1 subgoal):\n 1. [p = 1] (mod 4) \\<Longrightarrow>\n    set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", "finally"], ["proof (chain)\npicking this:\n  prime_factors (of_nat p) = set (factor_gauss_int_prime_nat p)", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factors (of_nat p) = set (factor_gauss_int_prime_nat p)\n\ngoal (1 subgoal):\n 1. set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)", ".."], ["proof (state)\nthis:\n  set (factor_gauss_int_prime_nat p) = prime_factors (of_nat p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we lift this to compute the prime factorisation of any integer in the Gaussian integers:\n\\<close>"], ["", "definition prime_factors_gauss_int_of_nat :: \"nat \\<Rightarrow> gauss_int set\" where\n  \"prime_factors_gauss_int_of_nat n = (if n = 0 then {} else \n     (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p)))\""], ["", "lemma prime_factors_gauss_int_of_nat_correct:\n  \"prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "from False"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have [simp]: \"n > 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "have \"prime_factors (of_nat n :: gauss_int) =\n          prime_factors (of_nat (prod_mset (prime_factorization n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (of_nat n) =\n    prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n)))", "by (subst prod_mset_prime_factorization_nat [symmetric]) auto"], ["proof (state)\nthis:\n  prime_factors (of_nat n) =\n  prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "also"], ["proof (state)\nthis:\n  prime_factors (of_nat n) =\n  prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "have \"\\<dots> = prime_factors (prod_mset (image_mset of_nat (prime_factorization n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n))) =\n    prime_factors\n     (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n)))", "by (subst of_nat_prod_mset) auto"], ["proof (state)\nthis:\n  prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n))) =\n  prime_factors\n   (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "also"], ["proof (state)\nthis:\n  prime_factors (of_nat (\\<Prod>\\<^sub># (prime_factorization n))) =\n  prime_factors\n   (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n)))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "have \"\\<dots> = (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors\n     (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n))) =\n    (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p))", "by (subst prime_factorization_prod_mset) auto"], ["proof (state)\nthis:\n  prime_factors\n   (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n))) =\n  (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "also"], ["proof (state)\nthis:\n  prime_factors\n   (\\<Prod>\\<^sub># (image_mset of_nat (prime_factorization n))) =\n  (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "have \"\\<dots> = (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p)) =\n    (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p))", "by (intro SUP_cong refl factor_gauss_int_prime_nat_correct [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>prime_factors n. prime_factors (of_nat p)) =\n  (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "finally"], ["proof (chain)\npicking this:\n  prime_factors (of_nat n) =\n  (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p))", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factors (of_nat n) =\n  (\\<Union>p\\<in>prime_factors n. set (factor_gauss_int_prime_nat p))\n\ngoal (1 subgoal):\n 1. prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "by (simp add: prime_factors_gauss_int_of_nat_def)"], ["proof (state)\nthis:\n  prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    prime_factors_gauss_int_of_nat n = prime_factors (of_nat n)", "qed (auto simp:  prime_factors_gauss_int_of_nat_def)"], ["", "text \\<open>\n  We can now use this to factor any Gaussian integer by computing a factorisation of its\n  norm and removing all the prime divisors that do not actually divide it.\n\\<close>"], ["", "definition prime_factors_gauss_int :: \"gauss_int \\<Rightarrow> gauss_int set\" where\n  \"prime_factors_gauss_int z = (if z = 0 then {} \n     else Set.filter (\\<lambda>p. p dvd z) (prime_factors_gauss_int_of_nat (gauss_int_norm z)))\""], ["", "lemma prime_factors_gauss_int_correct [code_unfold]: \"prime_factors z = prime_factors_gauss_int z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors z = prime_factors_gauss_int z", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "case [simp]: False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "define n where \"n = gauss_int_norm z\""], ["proof (state)\nthis:\n  n = gauss_int_norm z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "from False"], ["proof (chain)\npicking this:\n  z \\<noteq> 0", "have [simp]: \"n > 0\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "have \"prime_factors_gauss_int z = Set.filter (\\<lambda>p. p dvd z) (prime_factors (of_nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors_gauss_int z =\n    Set.filter (\\<lambda>p. p dvd z) (prime_factors (of_nat n))", "by (simp add: prime_factors_gauss_int_of_nat_correct prime_factors_gauss_int_def n_def)"], ["proof (state)\nthis:\n  prime_factors_gauss_int z =\n  Set.filter (\\<lambda>p. p dvd z) (prime_factors (of_nat n))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "also"], ["proof (state)\nthis:\n  prime_factors_gauss_int z =\n  Set.filter (\\<lambda>p. p dvd z) (prime_factors (of_nat n))\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "have \"of_nat n = z * gauss_cnj z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = z * gauss_cnj z", "by (simp add: n_def self_mult_gauss_cnj)"], ["proof (state)\nthis:\n  of_nat n = z * gauss_cnj z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "also"], ["proof (state)\nthis:\n  of_nat n = z * gauss_cnj z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "have \"prime_factors \\<dots> = prime_factors z \\<union> prime_factors (gauss_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (z * gauss_cnj z) =\n    prime_factors z \\<union> prime_factors (gauss_cnj z)", "by (subst prime_factors_product) auto"], ["proof (state)\nthis:\n  prime_factors (z * gauss_cnj z) =\n  prime_factors z \\<union> prime_factors (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "also"], ["proof (state)\nthis:\n  prime_factors (z * gauss_cnj z) =\n  prime_factors z \\<union> prime_factors (gauss_cnj z)\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "have \"Set.filter (\\<lambda>p. p dvd z) \\<dots> = prime_factors z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter (\\<lambda>p. p dvd z)\n     (prime_factors z \\<union> prime_factors (gauss_cnj z)) =\n    prime_factors z", "by (auto simp: in_prime_factors_iff)"], ["proof (state)\nthis:\n  Set.filter (\\<lambda>p. p dvd z)\n   (prime_factors z \\<union> prime_factors (gauss_cnj z)) =\n  prime_factors z\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z\n 2. z \\<noteq> 0 \\<Longrightarrow>\n    prime_factors z = prime_factors_gauss_int z", "finally"], ["proof (chain)\npicking this:\n  prime_factors_gauss_int z = prime_factors z", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factors_gauss_int z = prime_factors z\n\ngoal (1 subgoal):\n 1. prime_factors z = prime_factors_gauss_int z", "by simp"], ["proof (state)\nthis:\n  prime_factors z = prime_factors_gauss_int z\n\ngoal (1 subgoal):\n 1. z = 0 \\<Longrightarrow> prime_factors z = prime_factors_gauss_int z", "qed (auto simp: prime_factors_gauss_int_def)"], ["", "(*<*)"], ["", "unbundle no_gauss_int_notation"], ["", "(*>*)"], ["", "end"]]}