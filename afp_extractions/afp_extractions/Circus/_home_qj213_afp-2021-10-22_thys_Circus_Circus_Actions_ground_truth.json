{"file_name": "/home/qj213/afp-2021-10-22/thys/Circus/Circus_Actions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Circus", "problem_names": ["lemma relation_of_CSP: \"is_CSP_process (relation_of x)\"", "lemma relation_of_CSP1: \"(relation_of x) is CSP1 healthy\"", "lemma relation_of_CSP2: \"(relation_of x) is CSP2 healthy\"", "lemma relation_of_R: \"(relation_of x) is R healthy\"", "lemma relation_of_spec_f_f: \n\"\\<forall>a b. (relation_of y \\<longrightarrow> relation_of x) (a, b) \\<Longrightarrow>\n           (relation_of y)\\<^sup>f\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b) \\<Longrightarrow>\n                      (relation_of x)\\<^sup>f\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b)\"", "lemma relation_of_spec_t_f: \n\"\\<forall>a b. (relation_of y \\<longrightarrow> relation_of x) (a, b) \\<Longrightarrow>\n           (relation_of y)\\<^sup>t\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b) \\<Longrightarrow>\n                     (relation_of x)\\<^sup>t\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b)\"", "lemma bot_is_action: \"R (false \\<turnstile> true) \\<in> {p. is_CSP_process p}\"", "lemma bot_eq_true: \"R (false \\<turnstile> true) = R true\"", "lemma relation_of_top: \"relation_of top = R(true \\<turnstile> false)\"", "lemma relation_of_bot: \"relation_of bot = R true\"", "lemma non_emptyE: assumes \"A \\<noteq> {}\" obtains x where \"x : A\"", "lemma CSP1_Inf: \nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is CSP1 healthy\"", "lemma CSP2_Inf:\nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is CSP2 healthy\"", "lemma R_Inf:\nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is R healthy\"", "lemma CSP_Inf: \n  assumes \"A \\<noteq> {}\"\n  shows \"is_CSP_process (\\<Sqinter> relation_of ` A)\"", "lemma Inf_is_action: \"A \\<noteq> {} \\<Longrightarrow> \\<Sqinter> relation_of ` A \\<in> {p. is_CSP_process p}\"", "lemma CSP1_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is CSP1 healthy\"", "lemma CSP2_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is CSP2 healthy\"", "lemma R_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is R healthy\"", "lemma CSP_Sup: \"A \\<noteq> {} \\<Longrightarrow> is_CSP_process (\\<Squnion> relation_of ` A)\"", "lemma Sup_is_action: \"A \\<noteq> {} \\<Longrightarrow> \\<Squnion> relation_of ` A \\<in> {p. is_CSP_process p}\"", "lemma relation_of_Sup: \n  \"A \\<noteq> {} \\<Longrightarrow> relation_of (action_of \\<Squnion> relation_of ` A) = \\<Squnion> relation_of ` A\""], "translations": [["", "lemma relation_of_CSP: \"is_CSP_process (relation_of x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (action.relation_of x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_CSP_process (action.relation_of x)", "have \"(relation_of x) :{p. is_CSP_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of x \\<in> {p. is_CSP_process p}", "by (rule relation_of)"], ["proof (state)\nthis:\n  action.relation_of x \\<in> {p. is_CSP_process p}\n\ngoal (1 subgoal):\n 1. is_CSP_process (action.relation_of x)", "then"], ["proof (chain)\npicking this:\n  action.relation_of x \\<in> {p. is_CSP_process p}", "show \"is_CSP_process (relation_of x)\""], ["proof (prove)\nusing this:\n  action.relation_of x \\<in> {p. is_CSP_process p}\n\ngoal (1 subgoal):\n 1. is_CSP_process (action.relation_of x)", ".."], ["proof (state)\nthis:\n  is_CSP_process (action.relation_of x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma relation_of_CSP1: \"(relation_of x) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of x is CSP1 healthy", "by (rule CSP_is_CSP1[OF relation_of_CSP])"], ["", "lemma relation_of_CSP2: \"(relation_of x) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of x is CSP2 healthy", "by (rule CSP_is_CSP2[OF relation_of_CSP])"], ["", "lemma relation_of_R: \"(relation_of x) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of x is R healthy", "by (rule CSP_is_R[OF relation_of_CSP])"], ["", "subsection \\<open>Proofs\\<close>"], ["", "text \\<open>In the following, Circus actions are proved to be an instance of the $Complete\\_Lattice$ class.\\<close>"], ["", "lemma relation_of_spec_f_f: \n\"\\<forall>a b. (relation_of y \\<longrightarrow> relation_of x) (a, b) \\<Longrightarrow>\n           (relation_of y)\\<^sup>f\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b) \\<Longrightarrow>\n                      (relation_of x)\\<^sup>f\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                (action.relation_of y \\<longrightarrow>\n                 action.relation_of x)\n                 (a, b);\n     action.relation_of y\\<^sup>f\\<^sub>f\n      (a\\<lparr>tr := []\\<rparr>, b)\\<rbrakk>\n    \\<Longrightarrow> action.relation_of x\\<^sup>f\\<^sub>f\n                       (a\\<lparr>tr := []\\<rparr>, b)", "by (auto simp: spec_def)"], ["", "lemma relation_of_spec_t_f: \n\"\\<forall>a b. (relation_of y \\<longrightarrow> relation_of x) (a, b) \\<Longrightarrow>\n           (relation_of y)\\<^sup>t\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b) \\<Longrightarrow>\n                     (relation_of x)\\<^sup>t\\<^sub>f (a\\<lparr>tr := []\\<rparr>, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                (action.relation_of y \\<longrightarrow>\n                 action.relation_of x)\n                 (a, b);\n     action.relation_of y\\<^sup>t\\<^sub>f\n      (a\\<lparr>tr := []\\<rparr>, b)\\<rbrakk>\n    \\<Longrightarrow> action.relation_of x\\<^sup>t\\<^sub>f\n                       (a\\<lparr>tr := []\\<rparr>, b)", "by (auto simp: spec_def)"], ["", "instantiation \"action\"::(ev_eq, type) below\nbegin"], ["", "definition ref_def : \"P \\<sqsubseteq> Q \\<equiv> [(relation_of Q) \\<longrightarrow> (relation_of P)]\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) action, below_class)", ".."], ["", "end"], ["", "instance \"action\" :: (ev_eq, type) po"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) action, po_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y z::\"('a, 'b) action\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqsubseteq> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x", "by (simp add: ref_def utp_defs)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<sqsubseteq> y\" and \"y \\<sqsubseteq> z\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> z", "show \" x \\<sqsubseteq> z\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> z", "by (simp add: ref_def utp_defs)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume A:\"x \\<sqsubseteq> y\" and B:\"y \\<sqsubseteq> x\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> x", "show \" x = y\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  y \\<sqsubseteq> x\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp add: ref_def relation_of_inject[symmetric] fun_eq_iff)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> x\\<rbrakk>\n  \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation \"action\"  ::  (ev_eq, type) lattice\nbegin"], ["", "definition inf_action : \"(inf P Q \\<equiv> action_of ((relation_of P) \\<sqinter> (relation_of Q)))\""], ["", "definition sup_action : \"(sup P Q \\<equiv> action_of ((relation_of P) \\<squnion> (relation_of Q)))\""], ["", "definition less_eq_action : \"(less_eq (P::('a, 'b) action) Q \\<equiv> P \\<sqsubseteq> Q)\""], ["", "definition less_action : \"(less (P::('a, 'b) action) Q \\<equiv> P \\<sqsubseteq> Q \\<and> \\<not> Q \\<sqsubseteq> P)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) action, lattice_class)", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 8. \\<And>x y. x \\<le> sup x y\n 9. \\<And>y x. y \\<le> sup x y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> sup y z \\<le> x", "fix x y z::\"('a, 'b) action\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 8. \\<And>x y. x \\<le> sup x y\n 9. \\<And>y x. y \\<le> sup x y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> sup y z \\<le> x", "{"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. inf x y \\<le> x\n 6. \\<And>x y. inf x y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 8. \\<And>x y. x \\<le> sup x y\n 9. \\<And>y x. y \\<le> sup x y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> sup y z \\<le> x", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: less_action less_eq_action)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (9 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. inf x y \\<le> x\n 5. \\<And>x y. inf x y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 7. \\<And>x y. x \\<le> sup x y\n 8. \\<And>y x. y \\<le> sup x y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. inf x y \\<le> x\n 5. \\<And>x y. inf x y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 7. \\<And>x y. x \\<le> sup x y\n 8. \\<And>y x. y \\<le> sup x y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "show \"(x \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: less_eq_action)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. inf x y \\<le> x\n 4. \\<And>x y. inf x y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 6. \\<And>x y. x \\<le> sup x y\n 7. \\<And>y x. y \\<le> sup x y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. inf x y \\<le> x\n 4. \\<And>x y. inf x y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 6. \\<And>x y. x \\<le> sup x y\n 7. \\<And>y x. y \\<le> sup x y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "assume \"x \\<le> y\" and \"y \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (8 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. inf x y \\<le> x\n 4. \\<And>x y. inf x y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 6. \\<And>x y. x \\<le> sup x y\n 7. \\<And>y x. y \\<le> sup x y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z", "show \" x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (simp add: less_eq_action ref_def utp_defs)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. inf x y \\<le> x\n 3. \\<And>x y. inf x y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 5. \\<And>x y. x \\<le> sup x y\n 6. \\<And>y x. y \\<le> sup x y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. inf x y \\<le> x\n 3. \\<And>x y. inf x y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 5. \\<And>x y. x \\<le> sup x y\n 6. \\<And>y x. y \\<le> sup x y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "assume \"x \\<le> y\" and \"y \\<le> x\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (7 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. inf x y \\<le> x\n 3. \\<And>x y. inf x y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 5. \\<And>x y. x \\<le> sup x y\n 6. \\<And>y x. y \\<le> sup x y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> x", "show \" x = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp add: less_eq_action ref_def relation_of_inject[symmetric] utp_defs)"], ["proof (state)\nthis:\n  x = y\n\ngoal (6 subgoals):\n 1. \\<And>x y. inf x y \\<le> x\n 2. \\<And>x y. inf x y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 4. \\<And>x y. x \\<le> sup x y\n 5. \\<And>y x. y \\<le> sup x y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. inf x y \\<le> x\n 2. \\<And>x y. inf x y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 4. \\<And>x y. x \\<le> sup x y\n 5. \\<And>y x. y \\<le> sup x y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "show \"inf x y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x y \\<le> x", "apply (auto simp add: less_eq_action inf_action ref_def\n        csp_defs design_defs rp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       action.relation_of\n        (action_of (action.relation_of x \\<or> action.relation_of y)) (a, b)", "apply (subst action_of_inverse, simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       is_CSP_process (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       (action.relation_of x \\<or> action.relation_of y) (a, b)", "apply (insert relation_of_CSP[where x=\"x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (simp_all add: CSP_join)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (simp add: utp_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inf x y \\<le> x\n\ngoal (5 subgoals):\n 1. \\<And>x y. inf x y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 3. \\<And>x y. x \\<le> sup x y\n 4. \\<And>y x. y \\<le> sup x y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. inf x y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 3. \\<And>x y. x \\<le> sup x y\n 4. \\<And>y x. y \\<le> sup x y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "show \"inf x y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf x y \\<le> y", "apply (auto simp add: less_eq_action inf_action ref_def csp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of y (a, b) \\<Longrightarrow>\n       action.relation_of\n        (action_of (action.relation_of x \\<or> action.relation_of y)) (a, b)", "apply (subst action_of_inverse, simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       action.relation_of y (a, b) \\<Longrightarrow>\n       is_CSP_process (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       action.relation_of y (a, b) \\<Longrightarrow>\n       (action.relation_of x \\<or> action.relation_of y) (a, b)", "apply (insert relation_of_CSP[where x=\"x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of x \\<or> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (simp_all add: CSP_join)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of x \\<or> action.relation_of y)\n                          (a, b)", "apply (simp add: utp_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inf x y \\<le> y\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 2. \\<And>x y. x \\<le> sup x y\n 3. \\<And>y x. y \\<le> sup x y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 2. \\<And>x y. x \\<le> sup x y\n 3. \\<And>y x. y \\<le> sup x y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "assume \"x \\<le> y\" and \"x \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  x \\<le> z\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> inf y z\n 2. \\<And>x y. x \\<le> sup x y\n 3. \\<And>y x. y \\<le> sup x y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  x \\<le> z", "show \"x \\<le> inf y z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> inf y z", "apply (auto simp add: less_eq_action inf_action ref_def impl_def csp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   action.relation_of y (a, b) \\<longrightarrow>\n                   action.relation_of x (a, b);\n        \\<forall>a b.\n           action.relation_of z (a, b) \\<longrightarrow>\n           action.relation_of x (a, b);\n        action.relation_of\n         (action_of (action.relation_of y \\<or> action.relation_of z))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (erule_tac x=\"a\" in allE, erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of\n                 (action_of\n                   (action.relation_of y \\<or> action.relation_of z))\n                 (a, b);\n        \\<forall>b.\n           action.relation_of y (a, b) \\<longrightarrow>\n           action.relation_of x (a, b);\n        \\<forall>b.\n           action.relation_of z (a, b) \\<longrightarrow>\n           action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (erule_tac x=\"b\" in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of\n                 (action_of\n                   (action.relation_of y \\<or> action.relation_of z))\n                 (a, b);\n        action.relation_of y (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b) \\<longrightarrow>\n                action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<or> action.relation_of z)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of y \\<or> action.relation_of z) (a, b);\n        action.relation_of y (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b) \\<longrightarrow>\n                action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<or> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of y \\<or> action.relation_of z) (a, b);\n        action.relation_of y (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (insert relation_of_CSP[where x=\"z\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b) \\<longrightarrow>\n                action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        is_CSP_process (action.relation_of z)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<or> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of y \\<or> action.relation_of z) (a, b);\n        action.relation_of y (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        is_CSP_process (action.relation_of z)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of y (a, b) \\<longrightarrow>\n                action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        is_CSP_process (action.relation_of z);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<or> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of y \\<or> action.relation_of z) (a, b);\n        action.relation_of y (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        action.relation_of z (a, b) \\<longrightarrow>\n        action.relation_of x (a, b);\n        is_CSP_process (action.relation_of z);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (auto simp add: CSP_join)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> inf y z\n\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> sup x y\n 2. \\<And>y x. y \\<le> sup x y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> sup x y\n 2. \\<And>y x. y \\<le> sup x y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "show \"x \\<le> sup x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> sup x y", "apply (auto simp add: less_eq_action sup_action ref_def \n         impl_def csp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of\n        (action_of (action.relation_of x \\<and> action.relation_of y))\n        (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n       \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n        (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n        (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (insert relation_of_CSP[where x=\"x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (action.relation_of x) \\<Longrightarrow>\n    is_CSP_process (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of x \\<and> action.relation_of y) (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_CSP_process (action.relation_of x);\n     is_CSP_process (action.relation_of y)\\<rbrakk>\n    \\<Longrightarrow> is_CSP_process\n                       (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of x \\<and> action.relation_of y) (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (auto simp add: CSP_meet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> sup x y\n\ngoal (2 subgoals):\n 1. \\<And>y x. y \\<le> sup x y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y x. y \\<le> sup x y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "show \"y \\<le> sup x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> sup x y", "apply (auto simp add: less_eq_action sup_action ref_def\n         impl_def csp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of\n        (action_of (action.relation_of x \\<and> action.relation_of y))\n        (a, b) \\<Longrightarrow>\n       action.relation_of y (a, b)", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n       \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n        (a, b) \\<Longrightarrow>\n       action.relation_of y (a, b)", "apply (simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       (action.relation_of x \\<and> action.relation_of y)\n        (a, b) \\<Longrightarrow>\n       action.relation_of y (a, b)", "apply (insert relation_of_CSP[where x=\"x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (action.relation_of x) \\<Longrightarrow>\n    is_CSP_process (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of x \\<and> action.relation_of y) (a, b);\n        is_CSP_process (action.relation_of x)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of y (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_CSP_process (action.relation_of x);\n     is_CSP_process (action.relation_of y)\\<rbrakk>\n    \\<Longrightarrow> is_CSP_process\n                       (action.relation_of x \\<and> action.relation_of y)\n 2. \\<And>a b.\n       \\<lbrakk>(action.relation_of x \\<and> action.relation_of y) (a, b);\n        is_CSP_process (action.relation_of x);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of y (a, b)", "apply (auto simp add: CSP_meet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y \\<le> sup x y\n\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "assume \"y \\<le> x\" and \"z \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> sup y z \\<le> x", "then"], ["proof (chain)\npicking this:\n  y \\<le> x\n  z \\<le> x", "show \"sup y z \\<le> x\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. sup y z \\<le> x", "apply (auto simp add: less_eq_action sup_action ref_def  impl_def csp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   action.relation_of x (a, b) \\<longrightarrow>\n                   action.relation_of y (a, b);\n        \\<forall>a b.\n           action.relation_of x (a, b) \\<longrightarrow>\n           action.relation_of z (a, b);\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of\n                          (action_of\n                            (action.relation_of y \\<and>\n                             action.relation_of z))\n                          (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   action.relation_of x (a, b) \\<longrightarrow>\n                   action.relation_of z (a, b);\n        action.relation_of x (a, b);\n        \\<forall>b.\n           action.relation_of x (a, b) \\<longrightarrow>\n           action.relation_of y (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of\n                          (action_of\n                            (action.relation_of y \\<and>\n                             action.relation_of z))\n                          (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        \\<forall>b.\n           action.relation_of x (a, b) \\<longrightarrow>\n           action.relation_of y (a, b);\n        \\<forall>b.\n           action.relation_of x (a, b) \\<longrightarrow>\n           action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of\n                          (action_of\n                            (action.relation_of y \\<and>\n                             action.relation_of z))\n                          (a, b)", "apply (erule_tac x=\"b\" in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of\n                          (action_of\n                            (action.relation_of y \\<and>\n                             action.relation_of z))\n                          (a, b)", "apply (subst action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<and> action.relation_of z)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<and> action.relation_of z)\n                          (a, b)", "apply (simp add: Healthy_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b); action.relation_of y (a, b);\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<and> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<and> action.relation_of z)\n                          (a, b)", "apply (insert relation_of_CSP[where x=\"z\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b); action.relation_of y (a, b);\n        action.relation_of z (a, b);\n        is_CSP_process (action.relation_of z)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<and> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b);\n        is_CSP_process (action.relation_of z)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<and> action.relation_of z)\n                          (a, b)", "apply (insert relation_of_CSP[where x=\"y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b); action.relation_of y (a, b);\n        action.relation_of z (a, b); is_CSP_process (action.relation_of z);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process\n                          (action.relation_of y \\<and> action.relation_of z)\n 2. \\<And>a b.\n       \\<lbrakk>action.relation_of x (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of y (a, b);\n        action.relation_of x (a, b) \\<longrightarrow>\n        action.relation_of z (a, b);\n        is_CSP_process (action.relation_of z);\n        is_CSP_process (action.relation_of y)\\<rbrakk>\n       \\<Longrightarrow> (action.relation_of y \\<and> action.relation_of z)\n                          (a, b)", "apply (auto simp add: CSP_meet)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sup y z \\<le> x\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk> \\<Longrightarrow> sup y z \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma bot_is_action: \"R (false \\<turnstile> true) \\<in> {p. is_CSP_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (false \\<turnstile> true) \\<in> {p. is_CSP_process p}", "by (auto intro: rd_is_CSP)"], ["", "lemma bot_eq_true: \"R (false \\<turnstile> true) = R true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (false \\<turnstile> true) = R true", "by (auto simp: fun_eq_iff design_defs rp_defs split: cond_splits)"], ["", "instantiation \"action\"  ::  (ev_eq, type) bounded_lattice\nbegin"], ["", "definition bot_action : \"(bot::('a, 'b) action) \\<equiv> action_of (R(false \\<turnstile> true))\""], ["", "definition top_action : \"(top::('a, 'b) action) \\<equiv> action_of (R(true \\<turnstile> false))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) action, bounded_lattice_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "fix x::\"('a, 'b) action\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. bot \\<le> a\n 2. \\<And>a. a \\<le> top", "show \"bot \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot \\<le> x", "unfolding bot_action"], ["proof (prove)\ngoal (1 subgoal):\n 1. action_of (R (false \\<turnstile> true)) \\<le> x", "apply (auto simp add: less_action less_eq_action ref_def bot_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       action.relation_of (action_of (R (false \\<turnstile> true))) (a, b)", "apply (subst action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       R (false \\<turnstile> true) \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       R (false \\<turnstile> true) (a, b)", "apply (rule bot_is_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of x (a, b) \\<Longrightarrow>\n       R (false \\<turnstile> true) (a, b)", "apply (subst bot_eq_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. action.relation_of x (a, b) \\<Longrightarrow> R true (a, b)", "apply (subst (asm) CSP_is_rd)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. is_CSP_process (action.relation_of x)\n 2. \\<And>a b.\n       R (\\<not> action.relation_of\n                  x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n            x\\<^sup>t\\<^sub>f)\n        (a, b) \\<Longrightarrow>\n       R true (a, b)", "apply (rule relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       R (\\<not> action.relation_of\n                  x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n            x\\<^sup>t\\<^sub>f)\n        (a, b) \\<Longrightarrow>\n       R true (a, b)", "apply (auto simp add: csp_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bot \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> top", "show \"x \\<le> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> top", "apply (auto simp add: less_action less_eq_action ref_def top_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       action.relation_of (action_of (R (true \\<turnstile> false)))\n        (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. R (true \\<turnstile> false) \\<in> Collect is_CSP_process\n 2. \\<And>a b.\n       R (true \\<turnstile> false) (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (R (true \\<turnstile> false))\n 2. \\<And>a b.\n       R (true \\<turnstile> false) (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (rule rd_is_CSP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       true (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow>\n       true (a, b\\<lparr>ok := False\\<rparr>)\n 2. \\<And>a b.\n       R (true \\<turnstile> false) (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       R (true \\<turnstile> false) (a, b) \\<Longrightarrow>\n       action.relation_of x (a, b)", "apply (subst action_of_cases[where x=x], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>R (true \\<turnstile> false) (a, b); x = action_of y;\n        is_CSP_process y\\<rbrakk>\n       \\<Longrightarrow> action.relation_of (action_of y) (a, b)", "apply (subst action_of_inverse, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>R (true \\<turnstile> false) (a, b); x = action_of y;\n        is_CSP_process y\\<rbrakk>\n       \\<Longrightarrow> y (a, b)", "apply (subst CSP_is_rd[where P=y], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>R (true \\<turnstile> false) (a, b); x = action_of y;\n        is_CSP_process y\\<rbrakk>\n       \\<Longrightarrow> R (\\<lambda>A.\n                               \\<not> y\\<^sup>f\\<^sub>f\n A \\<turnstile> y\\<^sup>t\\<^sub>f)\n                          (a, b)", "apply (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> top\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  x \\<le> top\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma relation_of_top: \"relation_of top = R(true \\<turnstile> false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of top = R (true \\<turnstile> false)", "apply (simp add: top_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of (action_of (R (true \\<turnstile> false))) =\n    R (true \\<turnstile> false)", "apply (subst action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. R (true \\<turnstile> false) \\<in> Collect is_CSP_process\n 2. R (true \\<turnstile> false) = R (true \\<turnstile> false)", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_CSP_process (R (true \\<turnstile> false))\n 2. R (true \\<turnstile> false) = R (true \\<turnstile> false)", "apply (rule rd_is_CSP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>a b.\n       true (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow>\n       true (a, b\\<lparr>ok := False\\<rparr>)\n 2. R (true \\<turnstile> false) = R (true \\<turnstile> false)", "apply (auto simp add: utp_defs design_defs rp_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma relation_of_bot: \"relation_of bot = R true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of bot = R true", "apply (simp add: bot_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. action.relation_of (action_of (R (false \\<turnstile> true))) = R true", "apply (subst action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. R (false \\<turnstile> true) \\<in> Collect is_CSP_process\n 2. R (false \\<turnstile> true) = R true", "apply (simp add: bot_is_action[simplified], rule bot_eq_true)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma non_emptyE: assumes \"A \\<noteq> {}\" obtains x where \"x : A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp add: ex_in_conv [symmetric])"], ["", "lemma CSP1_Inf: \nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy", "have \"(\\<Sqinter> relation_of ` A) = CSP1 (\\<Sqinter> relation_of ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    CSP1\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP1\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP1\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "note *"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP1\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "show \"(P \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) = CSP1 (\\<lambda>Aa. Aa \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) P\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    CSP1\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n     P", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {};\n     P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}\\<rbrakk>\n    \\<Longrightarrow> CSP1\n                       (\\<lambda>Aa.\n                           Aa \\<in> \\<Union>\n                                     {{p. P p} |P.\nP \\<in> action.relation_of ` A})\n                       P\n 2. \\<lbrakk>A \\<noteq> {};\n     CSP1\n      (\\<lambda>Aa.\n          Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n      P\\<rbrakk>\n    \\<Longrightarrow> P \\<in> \\<Union>\n                               {{p. P p} |P. P \\<in> action.relation_of ` A}", "apply (simp_all add: csp_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {};\n     \\<exists>x.\n        (\\<exists>P.\n            x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n        P \\<in> x\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>Aa.\n                           \\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              Aa \\<in> x) \\<or>\n                       (\\<lambda>(A, A').\n                           \\<not> ok A \\<and> tr A \\<le> tr A'))\n                       P\n 2. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) \\<or>\n      (\\<lambda>(A, A'). \\<not> ok A \\<and> tr A \\<le> tr A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (rule disj_introC, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) \\<or>\n      (\\<lambda>(A, A'). \\<not> ok A \\<and> tr A \\<le> tr A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (erule disj_elim, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {};\n     case P of\n     (A, A') \\<Rightarrow> \\<not> ok A \\<and> tr A \\<le> tr A'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (cases P, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> ok a \\<and> tr a \\<le> tr b;\n        P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule non_emptyE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"Collect (relation_of x)\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             Collect (action.relation_of x) =\n                             Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         action.relation_of x (a, b)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            Collect (action.relation_of x) =\n                            Collect P \\<and>\n                            P \\<in> action.relation_of ` A\n 2. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (rule_tac x=\"(relation_of x)\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> ok a \\<and> tr a \\<le> tr b; P = (a, b);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                              x\\<^sup>t\\<^sub>f)\n                          (a, b)", "apply (auto simp add: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP1\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n   P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP1\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP1\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "show \"(\\<Sqinter> relation_of ` A) is CSP1 healthy\""], ["proof (prove)\nusing this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP1\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy", "by (simp add: design_defs)"], ["proof (state)\nthis:\n  \\<lambda>Aa.\n     Aa \\<in> \\<Union>\n               {{p. P p} |P. P \\<in> action.relation_of ` A} is CSP1 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CSP2_Inf:\nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "have \"(\\<Sqinter> relation_of ` A) = CSP2 (\\<Sqinter> relation_of ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    CSP2\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP2\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP2\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "note *"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       CSP2\n        (\\<lambda>Aa.\n            Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "show \"(P \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) = CSP2 (\\<lambda>Aa. Aa \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) P\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    CSP2\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n     P", "apply (intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {};\n     P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}\\<rbrakk>\n    \\<Longrightarrow> CSP2\n                       (\\<lambda>Aa.\n                           Aa \\<in> \\<Union>\n                                     {{p. P p} |P.\nP \\<in> action.relation_of ` A})\n                       P\n 2. \\<lbrakk>A \\<noteq> {};\n     CSP2\n      (\\<lambda>Aa.\n          Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n      P\\<rbrakk>\n    \\<Longrightarrow> P \\<in> \\<Union>\n                               {{p. P p} |P. P \\<in> action.relation_of ` A}", "apply (simp_all add: csp_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<noteq> {};\n     \\<exists>x.\n        (\\<exists>P.\n            x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n        P \\<in> x\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>Aa.\n                           \\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              Aa \\<in> x) ;;\n                       (\\<lambda>(A, A').\n                           (ok A \\<longrightarrow> ok A') \\<and>\n                           tr A = tr A' \\<and>\n                           wait A = wait A' \\<and>\n                           ref A = ref A' \\<and>\n                           alpha_rp.more A = alpha_rp.more A'))\n                       P\n 2. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) ;;\n      (\\<lambda>(A, A').\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (cases P, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<exists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x;\n        P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>Aa.\n                              \\<exists>x.\n                                 (\\<exists>P.\n                                     x = Collect P \\<and>\n                                     P \\<in> action.relation_of ` A) \\<and>\n                                 Aa \\<in> x) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)\n 2. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) ;;\n      (\\<lambda>(A, A').\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; P = (a, b);\n        (\\<exists>P.\n            x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n        (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>Aa.\n                              \\<exists>x.\n                                 (\\<exists>P.\n                                     x = Collect P \\<and>\n                                     P \\<in> action.relation_of ` A) \\<and>\n                                 Aa \\<in> x) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)\n 2. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) ;;\n      (\\<lambda>(A, A').\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (rule_tac b=b in comp_intro, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; P = (a, b);\n        (\\<exists>P.\n            x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n        (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 2. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) ;;\n      (\\<lambda>(A, A').\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (rule_tac x=x in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<noteq> {};\n     ((\\<lambda>Aa.\n          \\<exists>x.\n             (\\<exists>P.\n                 x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n             Aa \\<in> x) ;;\n      (\\<lambda>(A, A').\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n      P\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         P \\<in> x", "apply (erule comp_elim, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c);\n        \\<exists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x;\n        (ok b \\<longrightarrow> ok c) \\<and>\n        tr b = tr c \\<and>\n        wait b = wait c \\<and>\n        ref b = ref c \\<and> alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, c) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        (a, b) \\<in> x; tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, c) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        Pa (a, b); tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, c) \\<in> x", "apply (rule_tac x=\"Collect Pa\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        Pa (a, b); tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             Collect Pa = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         Pa (a, c)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        Pa (a, b); tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            Collect Pa = Collect P \\<and>\n                            P \\<in> action.relation_of ` A\n 2. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        Pa (a, b); tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> Pa (a, c)", "apply (rule_tac x=\"Pa\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        Pa (a, b); tr b = tr c; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A; wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> Pa (a, c)", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa xa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        action.relation_of xa (a, b); tr b = tr c;\n        x = Collect (action.relation_of xa); wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c; Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, c)", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa xa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        action.relation_of xa (a, b); tr b = tr c;\n        x = Collect (action.relation_of xa); wait b = wait c; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c; Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a, c)", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x Pa xa.\n       \\<lbrakk>A \\<noteq> {}; P = (a, c); ok b \\<longrightarrow> ok c;\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a, b);\n        tr b = tr c; x = Collect (action.relation_of xa); wait b = wait c;\n        ref b = ref c; alpha_rp.more b = alpha_rp.more c;\n        Pa = action.relation_of xa; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a, c)", "apply (auto simp add: csp_defs rp_defs prefix_def design_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; wait b; wait c; \\<not> ok c;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c; \\<not> ok c;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 8. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c; \\<not> ok c;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 7. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c; \\<not> ok c;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 6. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok b; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 5. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait b; wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 4. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait b; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := True\\<rparr>);\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 3. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = c\\<lparr>tr := zs, ok := False\\<rparr>\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        wait b; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)\n 2. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := True\\<rparr> = c\\<lparr>tr := zs, ok := True\\<rparr>\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c Pa xa zs xb.\n       \\<lbrakk>tr b = tr a @ zs; ref b = ref c;\n        alpha_rp.more b = alpha_rp.more c;\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, c); \\<not> wait a; tr c = tr a @ zs; ok a;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := zs, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok b;\n        action.relation_of xa\n         (a\\<lparr>tr := [], wait := False\\<rparr>, b\n          \\<lparr>tr := zs, ok := True\\<rparr>);\n        \\<not> wait b; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := True\\<rparr> = c\\<lparr>tr := zs, ok := True\\<rparr>\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP2\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n   P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP2\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP2\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "show \"(\\<Sqinter> relation_of ` A) is CSP2 healthy\""], ["proof (prove)\nusing this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  CSP2\n   (\\<lambda>Aa.\n       Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "by (simp add: design_defs)"], ["proof (state)\nthis:\n  \\<lambda>Aa.\n     Aa \\<in> \\<Union>\n               {{p. P p} |P. P \\<in> action.relation_of ` A} is CSP2 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_Inf:\nassumes *:\"A \\<noteq> {}\"\nshows \"(\\<Sqinter> relation_of ` A) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy", "have \"(\\<Sqinter> relation_of ` A) = R (\\<Sqinter> relation_of ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    R (\\<lambda>Aa.\n          Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       R (\\<lambda>Aa.\n             Aa \\<in> \\<Union>\n                       {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       (Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n       R (\\<lambda>Aa.\n             Aa \\<in> \\<Union>\n                       {{p. P p} |P. P \\<in> action.relation_of ` A})\n        Aa", "show \"(P \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) = R (\\<lambda>Aa. Aa \\<in> \\<Union>{{p. P p} |P. P \\<in> relation_of ` A}) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n    R (\\<lambda>Aa.\n          Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n     P", "apply (cases P, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       P = (a, b) \\<Longrightarrow>\n       (\\<exists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x) =\n       R (\\<lambda>Aa.\n             \\<exists>x.\n                (\\<exists>P.\n                    x = Collect P \\<and>\n                    P \\<in> action.relation_of ` A) \\<and>\n                Aa \\<in> x)\n        (a, b)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P = (a, b);\n        \\<exists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> R (\\<lambda>Aa.\n                               \\<exists>x.\n                                  (\\<exists>P.\nx = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n                                  Aa \\<in> x)\n                          (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b);\n        R (\\<lambda>Aa.\n              \\<exists>x.\n                 (\\<exists>P.\n                     x = Collect P \\<and>\n                     P \\<in> action.relation_of ` A) \\<and>\n                 Aa \\<in> x)\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp_all add: csp_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P = (a, b);\n        \\<exists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b);\n        (\\<exists>P.\n            x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n        (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa.\n       \\<lbrakk>P = (a, b); (a, b) \\<in> x; x = Collect Pa;\n        Pa \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa.\n       \\<lbrakk>P = (a, b); Pa (a, b); x = Collect Pa;\n        Pa \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); action.relation_of xa (a, b);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b);\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a, b);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<exists>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of ` A) \\<and>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs prefix_def design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a\\<lparr>tr := []\\<rparr>, b\n                             \\<lparr>tr := tr b - tr a\\<rparr>)\n                            \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"x\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             Collect (action.relation_of xa) =\n                             Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         action.relation_of xa\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            Collect (action.relation_of xa) =\n                            Collect P \\<and>\n                            P \\<in> action.relation_of ` A\n 2. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 4. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"relation_of xa\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b); xa \\<in> A;\n        P = (a, b); \\<not> wait a;\n        (ok a \\<and>\n         \\<not> action.relation_of xa\n                 (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a,\n                     ok := False\\<rparr>) \\<longrightarrow>\n         ok b \\<and>\n         action.relation_of xa\n          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)) \\<and>\n        (\\<exists>zs. tr b = tr a @ zs)\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs prefix_def design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (insert *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule non_emptyE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"Collect (relation_of x)\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             Collect (action.relation_of x) =\n                             Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         action.relation_of x (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            Collect (action.relation_of x) =\n                            Collect P \\<and>\n                            P \\<in> action.relation_of ` A\n 2. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)\n 3. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"(relation_of x)\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of x (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P = (a, b); wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                              x\\<^sup>t\\<^sub>f)\n                          (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs prefix_def design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>P = (a, b); \\<not> wait a;\n        (\\<exists>x.\n            (\\<exists>P.\n                x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n        \\<in> x;\n        x = Collect Pa; Pa \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        Pa (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect Pa; Pa \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of ` A) \\<and>\n                            (a, b) \\<in> x", "apply (rule_tac x=\"x\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             Collect (action.relation_of xa) =\n                             Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         action.relation_of xa (a, b)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            Collect (action.relation_of xa) =\n                            Collect P \\<and>\n                            P \\<in> action.relation_of ` A\n 2. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (rule_tac x=\"(relation_of xa)\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {}; tr a \\<le> tr b;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa); Pa = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a, b)", "apply (simp add: csp_defs prefix_def design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {};\n        \\<exists>zs. tr b = tr a @ zs;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ok a \\<and>\n                         \\<not> action.relation_of xa\n                                 (a\\<lparr>tr := [], wait := False\\<rparr>,\n                                  b\\<lparr>tr := tr b - tr a,\nok := False\\<rparr>) \\<longrightarrow>\n                         ok b \\<and>\n                         action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x Pa xa.\n       \\<lbrakk>P = (a, b); \\<not> wait a; A \\<noteq> {};\n        \\<exists>zs. tr b = tr a @ zs;\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        x = Collect (action.relation_of xa);\n        \\<forall>a b. Pa (a, b) = action.relation_of xa (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ok a \\<and>\n                         \\<not> action.relation_of xa\n                                 (a\\<lparr>tr := [], wait := False\\<rparr>,\n                                  b\\<lparr>tr := tr b - tr a,\nok := False\\<rparr>) \\<longrightarrow>\n                         ok b \\<and>\n                         action.relation_of xa\n                          (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (simp add: csp_defs prefix_def design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (P \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  R (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n   P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  R (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  R (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "show \"(\\<Sqinter> relation_of ` A) is R healthy\""], ["proof (prove)\nusing this:\n  (\\<lambda>Aa.\n      Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A}) =\n  R (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy", "by (simp add: design_defs)"], ["proof (state)\nthis:\n  \\<lambda>Aa.\n     Aa \\<in> \\<Union>\n               {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CSP_Inf: \n  assumes \"A \\<noteq> {}\"\n  shows \"is_CSP_process (\\<Sqinter> relation_of ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})", "unfolding is_CSP_process_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P. P \\<in> action.relation_of ` A} is R healthy", "using assms CSP1_Inf CSP2_Inf R_Inf"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Union>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is CSP1 healthy\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Union>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is CSP2 healthy\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Union>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is R healthy\n\ngoal (1 subgoal):\n 1. \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Union>\n                 {Collect P |P. P \\<in> action.relation_of ` A} is R healthy", "by auto"], ["", "lemma Inf_is_action: \"A \\<noteq> {} \\<Longrightarrow> \\<Sqinter> relation_of ` A \\<in> {p. is_CSP_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    (\\<lambda>Aa.\n        Aa \\<in> \\<Union> {{p. P p} |P. P \\<in> action.relation_of ` A})\n    \\<in> {p. is_CSP_process p}", "by (auto dest!: CSP_Inf)"], ["", "lemma CSP1_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy", "apply (auto simp add: design_defs csp_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x xb.\n       \\<lbrakk>x \\<in> A; xb \\<in> A; \\<not> ok a; tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xb (a, b)", "apply (subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x xb.\n       \\<lbrakk>x \\<in> A; xb \\<in> A; \\<not> ok a; tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xb\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xb\\<^sup>t\\<^sub>f)\n                          (a, b)", "apply (simp add: csp_defs prefix_def design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP2_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {{p. P p} |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy", "apply (simp add: design_defs csp_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<forall>a b.\n       (\\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x) =\n       ((\\<lambda>Aa.\n            \\<forall>x.\n               (\\<exists>P.\n                   x = Collect P \\<and>\n                   P \\<in> action.relation_of ` A) \\<longrightarrow>\n               Aa \\<in> x) ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n        (a, b)", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       A \\<noteq> {} \\<Longrightarrow>\n       (\\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x) =\n       ((\\<lambda>Aa.\n            \\<forall>x.\n               (\\<exists>P.\n                   x = Collect P \\<and>\n                   P \\<in> action.relation_of ` A) \\<longrightarrow>\n               Aa \\<in> x) ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n        (a, b)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>Aa.\n                              \\<forall>x.\n                                 (\\<exists>P.\n                                     x = Collect P \\<and>\n                                     P \\<in> action.relation_of `\n       A) \\<longrightarrow>\n                                 Aa \\<in> x) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>Aa.\n             \\<forall>x.\n                (\\<exists>P.\n                    x = Collect P \\<and>\n                    P \\<in> action.relation_of ` A) \\<longrightarrow>\n                Aa \\<in> x) ;;\n         (\\<lambda>(A, A').\n             (ok A \\<longrightarrow> ok A') \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule_tac b=b in comp_intro, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>Aa.\n             \\<forall>x.\n                (\\<exists>P.\n                    x = Collect P \\<and>\n                    P \\<in> action.relation_of ` A) \\<longrightarrow>\n                Aa \\<in> x) ;;\n         (\\<lambda>(A, A').\n             (ok A \\<longrightarrow> ok A') \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule comp_elim, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c.\n       \\<lbrakk>A \\<noteq> {}; a = aa \\<and> b = c;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (aa, ba) \\<in> x;\n        (ok ba \\<longrightarrow> ok c) \\<and>\n        tr ba = tr c \\<and>\n        wait ba = wait c \\<and>\n        ref ba = ref c \\<and> alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (aa, c) \\<in> x", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x.\n       \\<lbrakk>A \\<noteq> {}; a = aa \\<and> b = c;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (aa, ba) \\<in> x;\n        (ok ba \\<longrightarrow> ok c) \\<and>\n        tr ba = tr c \\<and>\n        wait ba = wait c \\<and>\n        ref ba = ref c \\<and> alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (aa, c) \\<in> x", "apply (erule_tac x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x.\n       \\<lbrakk>A \\<noteq> {}; a = aa \\<and> b = c;\n        (ok ba \\<longrightarrow> ok c) \\<and>\n        tr ba = tr c \\<and>\n        wait ba = wait c \\<and>\n        ref ba = ref c \\<and> alpha_rp.more ba = alpha_rp.more c;\n        (\\<exists>P.\n            x = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        (aa, ba) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (aa, c) \\<in> x", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x.\n       \\<lbrakk>A \\<noteq> {}; a = aa \\<and> b = c;\n        (ok ba \\<longrightarrow> ok c) \\<and>\n        tr ba = tr c \\<and>\n        wait ba = wait c \\<and>\n        ref ba = ref c \\<and> alpha_rp.more ba = alpha_rp.more c;\n        (\\<exists>P.\n            x = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        (aa, ba) \\<in> x;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (aa, c) \\<in> x", "apply (case_tac \"(\\<exists>P. x = Collect P & P \\<in> relation_of ` A)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x.\n       \\<lbrakk>A \\<noteq> {}; a = aa \\<and> b = c;\n        (ok ba \\<longrightarrow> ok c) \\<and>\n        tr ba = tr c \\<and>\n        wait ba = wait c \\<and>\n        ref ba = ref c \\<and> alpha_rp.more ba = alpha_rp.more c;\n        (aa, ba) \\<in> x;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (aa, c) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x P.\n       \\<lbrakk>A \\<noteq> {}; (aa, ba) \\<in> x; a = aa; b = c;\n        ok ba \\<longrightarrow> ok c; x = Collect P;\n        P \\<in> action.relation_of ` A; tr ba = tr c; wait ba = wait c;\n        ref ba = ref c; alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> (aa, c) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x P.\n       \\<lbrakk>A \\<noteq> {}; P (aa, ba); a = aa; b = c;\n        ok ba \\<longrightarrow> ok c; x = Collect P;\n        P \\<in> action.relation_of ` A; tr ba = tr c; wait ba = wait c;\n        ref ba = ref c; alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> P (aa, c)", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x P xa.\n       \\<lbrakk>A \\<noteq> {}; action.relation_of xa (aa, ba); a = aa;\n        b = c; ok ba \\<longrightarrow> ok c;\n        x = Collect (action.relation_of xa); tr ba = tr c; wait ba = wait c;\n        ref ba = ref c; alpha_rp.more ba = alpha_rp.more c;\n        P = action.relation_of xa; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (aa, c)", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP, subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c x P xa.\n       \\<lbrakk>A \\<noteq> {};\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (aa, ba);\n        a = aa; b = c; ok ba \\<longrightarrow> ok c;\n        x = Collect (action.relation_of xa); tr ba = tr c; wait ba = wait c;\n        ref ba = ref c; alpha_rp.more ba = alpha_rp.more c;\n        P = action.relation_of xa; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (aa, c)", "apply (auto simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; wait ba; wait c; \\<not> ok c;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> ok c;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 8. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> ok c;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 7. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> ok c;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 6. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; \\<not> ok ba; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 5. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; wait ba; wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 4. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; \\<not> wait ba; \\<not> wait c;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 3. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := False\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := False\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        wait ba; wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)\n 2. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := True\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := True\\<rparr>\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba c xa xb.\n       \\<lbrakk>tr ba = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; xa \\<in> A; \\<not> wait aa;\n        tr aa \\<le> tr c; ok aa;\n        \\<not> action.relation_of xa\n                (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                 \\<lparr>tr := tr c - tr aa, ok := False\\<rparr>);\n        xb \\<in> A; ok c; ok ba;\n        action.relation_of xa\n         (aa\\<lparr>tr := [], wait := False\\<rparr>, ba\n          \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>);\n        \\<not> wait ba; \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (aa\\<lparr>tr := [], wait := False\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa, ok := True\\<rparr>)", "apply (subgoal_tac \"ba\\<lparr>tr := tr c - tr aa, ok := True\\<rparr> = c\\<lparr>tr := tr c - tr aa, ok := True\\<rparr>\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R_Sup: \"A \\<noteq> {} \\<Longrightarrow> (\\<Squnion> relation_of ` A) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {{p. P p} |P. P \\<in> action.relation_of ` A} is R healthy", "apply (simp add: rp_defs design_defs csp_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<forall>a b.\n       (\\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x) =\n       ((\\<lambda>(A, A').\n            \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n            ok A' \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and>\n            alpha_rp.more A =\n            alpha_rp.more\n             A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n           (\\<lambda>(Aa, A').\n               (\\<forall>x.\n                   (\\<exists>P.\n                       x = Collect P \\<and>\n                       P \\<in> action.relation_of ` A) \\<longrightarrow>\n                   (Aa\\<lparr>tr := []\\<rparr>, A'\n                    \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                   \\<in> x) \\<and>\n               tr Aa \\<le> tr A'))\n        (a, b)", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       A \\<noteq> {} \\<Longrightarrow>\n       (\\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x) =\n       ((\\<lambda>(A, A').\n            \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n            ok A' \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and>\n            alpha_rp.more A =\n            alpha_rp.more\n             A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n           (\\<lambda>(Aa, A').\n               (\\<forall>x.\n                   (\\<exists>P.\n                       x = Collect P \\<and>\n                       P \\<in> action.relation_of ` A) \\<longrightarrow>\n                   (Aa\\<lparr>tr := []\\<rparr>, A'\n                    \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                   \\<in> x) \\<and>\n               tr Aa \\<le> tr A'))\n        (a, b)", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                              ok A' \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A =\n                              alpha_rp.more\n                               A') \\<triangleleft> wait \\<circ>\n             fst \\<triangleright> \n                             (\\<lambda>(Aa, A').\n                                 (\\<forall>x.\n                                     (\\<exists>P.\n   x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<longrightarrow>\n                                     (Aa\\<lparr>tr := []\\<rparr>, A'\n\\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                                     \\<in> x) \\<and>\n                                 tr Aa \\<le> tr A'))\n                          (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp split: cond_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (wait a \\<longrightarrow>\n                          \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                          ok b \\<and>\n                          tr a = tr b \\<and>\n                          wait b \\<and>\n                          ref a = ref b \\<and>\n                          alpha_rp.more a = alpha_rp.more b) \\<and>\n                         (\\<not> wait a \\<longrightarrow>\n                          (\\<forall>x.\n                              (\\<exists>P.\n                                  x = Collect P \\<and>\n                                  P \\<in> action.relation_of `\n    A) \\<longrightarrow>\n                              (a\\<lparr>tr := []\\<rparr>, b\n                               \\<lparr>tr := tr b - tr a\\<rparr>)\n                              \\<in> x) \\<and>\n                          tr a \\<le> tr b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (case_tac \"wait a\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        wait a\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule non_emptyE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>P.\n                       x = Collect P \\<and>\n                       P \\<in> action.relation_of ` A) \\<longrightarrow>\n                   (a, b) \\<in> x;\n        wait a; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule_tac x=\"Collect (relation_of x)\" in allE, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A;\n        (\\<exists>P.\n            Collect (action.relation_of x) = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (case_tac \"relation_of x (a, b)\", simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A; action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 4. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A;\n        R (\\<not> action.relation_of\n                   x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n             x\\<^sup>t\\<^sub>f)\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 4. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n                         ok b \\<and>\n                         tr a = tr b \\<and>\n                         wait b \\<and>\n                         ref a = ref b \\<and>\n                         alpha_rp.more a = alpha_rp.more b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule_tac x=\"(relation_of x)\" in allE, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of `\n   A) \\<longrightarrow>\n                             (a\\<lparr>tr := []\\<rparr>, b\n                              \\<lparr>tr := tr b - tr a\\<rparr>)\n                             \\<in> x) \\<and>\n                         tr a \\<le> tr b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a\\<lparr>tr := []\\<rparr>, b\n                             \\<lparr>tr := tr b - tr a\\<rparr>)\n                            \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (a\\<lparr>tr := []\\<rparr>, b\n                          \\<lparr>tr := tr b - tr a\\<rparr>)\n                         \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule_tac x=x in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<exists>P.\n            x = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        (a, b) \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (a\\<lparr>tr := []\\<rparr>, b\n                          \\<lparr>tr := tr b - tr a\\<rparr>)\n                         \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<exists>P.\n            x = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        (a, b) \\<in> x;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a\\<lparr>tr := []\\<rparr>, b\n                          \\<lparr>tr := tr b - tr a\\<rparr>)\n                         \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (case_tac \"(\\<exists>P. x = Collect P & P \\<in> relation_of ` A)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; (a, b) \\<in> x;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a\\<lparr>tr := []\\<rparr>, b\n                          \\<lparr>tr := tr b - tr a\\<rparr>)\n                         \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; (a, b) \\<in> x; x = Collect P;\n        P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a\\<lparr>tr := []\\<rparr>, b\n                          \\<lparr>tr := tr b - tr a\\<rparr>)\n                         \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; P (a, b); x = Collect P;\n        P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; action.relation_of xa (a, b);\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP, subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a, b);\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> wait a\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule non_emptyE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<forall>x.\n                   (\\<exists>P.\n                       x = Collect P \\<and>\n                       P \\<in> action.relation_of ` A) \\<longrightarrow>\n                   (a, b) \\<in> x;\n        \\<not> wait a; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule_tac x=\"Collect (relation_of x)\" in allE, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        (\\<exists>P.\n            Collect (action.relation_of x) = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (case_tac \"relation_of x (a, b)\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        R (\\<not> action.relation_of\n                   x\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n             x\\<^sup>t\\<^sub>f)\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 3. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>\\<not> wait a; x \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of x) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> tr a \\<le> tr b\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule_tac x=\"(relation_of x)\" in allE, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {};\n        ((\\<lambda>(A, A').\n             \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n             ok A' \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and>\n             alpha_rp.more A =\n             alpha_rp.more\n              A') \\<triangleleft> wait \\<circ> fst \\<triangleright> \n            (\\<lambda>(Aa, A').\n                (\\<forall>x.\n                    (\\<exists>P.\n                        x = Collect P \\<and>\n                        P \\<in> action.relation_of ` A) \\<longrightarrow>\n                    (Aa\\<lparr>tr := []\\<rparr>, A'\n                     \\<lparr>tr := tr A' - tr Aa\\<rparr>)\n                    \\<in> x) \\<and>\n                tr Aa \\<le> tr A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp split: cond_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x = Collect P; P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> x\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x = Collect P; P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> P (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (subst (asm) CSP_is_rd, simp add: relation_of_CSP, subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; wait a;\n        \\<not> ok a \\<and> tr a \\<le> tr b \\<or>\n        ok b \\<and>\n        tr a = tr b \\<and>\n        wait b \\<and>\n        ref a = ref b \\<and> alpha_rp.more a = alpha_rp.more b;\n        x =\n        Collect\n         (R (\\<not> action.relation_of\n                     xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                xa\\<^sup>t\\<^sub>f));\n        P = action.relation_of xa; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a, b)\n 2. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>P.\n                                x = Collect P \\<and>\n                                P \\<in> action.relation_of `\n  A) \\<longrightarrow>\n                            (a, b) \\<in> x", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         (a, b) \\<in> x", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        (\\<forall>x.\n            (\\<exists>P.\n                x = Collect P \\<and>\n                P \\<in> action.relation_of ` A) \\<longrightarrow>\n            (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n            \\<in> x) \\<and>\n        tr a \\<le> tr b;\n        \\<exists>P.\n           x = Collect P \\<and> P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> x", "apply (erule exE | erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n           \\<in> x;\n        tr a \\<le> tr b; x = Collect P;\n        P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> x", "apply (simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n           \\<in> x;\n        tr a \\<le> tr b; x = Collect P;\n        P \\<in> action.relation_of ` A\\<rbrakk>\n       \\<Longrightarrow> P (a, b)", "apply (erule Set.imageE, simp add: relation_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\n           \\<in> x;\n        tr a \\<le> tr b; x = Collect (action.relation_of xa);\n        P = action.relation_of xa; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (erule_tac x=\"x\" in allE, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        (\\<exists>P.\n            Collect (action.relation_of xa) = Collect P \\<and>\n            P \\<in> action.relation_of ` A) \\<longrightarrow>\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (case_tac \"relation_of xa (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>)\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (subst (asm) CSP_is_rd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>P = action.relation_of xa; xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process (action.relation_of xa)\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x =\n        Collect\n         (R (\\<not> action.relation_of\n                     xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                xa\\<^sup>t\\<^sub>f));\n        P = action.relation_of xa; xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 3. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "back"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process P\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa);\n        R (\\<not> P\\<^sup>f\\<^sub>f \\<turnstile> P\\<^sup>t\\<^sub>f) =\n        action.relation_of xa;\n        xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 3. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "back"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := tr b - tr a\\<rparr>);\n        A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa)\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process (action.relation_of xa)\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa);\n        P =\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f);\n        xa \\<in> A;\n        action.relation_of xa\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 3. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "back"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> is_CSP_process (action.relation_of xa)\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)\n 3. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (simp add: relation_of_CSP, subst CSP_is_rd, simp add: relation_of_CSP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        R (\\<not> action.relation_of\n                   xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n              xa\\<^sup>t\\<^sub>f)\n         (a\\<lparr>tr := []\\<rparr>, b\n          \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> R (\\<not> action.relation_of\n                                    xa\\<^sup>f\\<^sub>f \\<turnstile> action.relation_of\n                               xa\\<^sup>t\\<^sub>f)\n                          (a, b)\n 2. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (simp add: csp_defs design_defs rp_defs split: cond_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x P xa.\n       \\<lbrakk>A \\<noteq> {}; \\<not> wait a; tr a \\<le> tr b;\n        x = Collect (action.relation_of xa); P = action.relation_of xa;\n        xa \\<in> A;\n        \\<forall>P.\n           Collect (action.relation_of xa) = Collect P \\<longrightarrow>\n           P \\<notin> action.relation_of ` A;\n        \\<not> action.relation_of xa\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> action.relation_of xa (a, b)", "apply (erule_tac x=\"P\" in allE, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP_Sup: \"A \\<noteq> {} \\<Longrightarrow> is_CSP_process (\\<Squnion> relation_of ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    is_CSP_process\n     (\\<lambda>Aa.\n         Aa \\<in> \\<Inter> {{p. P p} |P. P \\<in> action.relation_of ` A})", "unfolding is_CSP_process_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P. P \\<in> action.relation_of ` A} is R healthy", "using CSP1_Sup CSP2_Sup R_Sup"], ["proof (prove)\nusing this:\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Inter>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is CSP1 healthy\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Inter>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is CSP2 healthy\n  ?A \\<noteq> {} \\<Longrightarrow>\n  \\<lambda>A.\n     A \\<in> \\<Inter>\n              {{p. P p} |P. P \\<in> action.relation_of ` ?A} is R healthy\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP1 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P.\n                  P \\<in> action.relation_of ` A} is CSP2 healthy \\<and>\n    \\<lambda>Aa.\n       Aa \\<in> \\<Inter>\n                 {Collect P |P. P \\<in> action.relation_of ` A} is R healthy", "by auto"], ["", "lemma Sup_is_action: \"A \\<noteq> {} \\<Longrightarrow> \\<Squnion> relation_of ` A \\<in> {p. is_CSP_process p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    (\\<lambda>Aa.\n        Aa \\<in> \\<Inter> {{p. P p} |P. P \\<in> action.relation_of ` A})\n    \\<in> {p. is_CSP_process p}", "by (auto dest!: CSP_Sup)"], ["", "lemma relation_of_Sup: \n  \"A \\<noteq> {} \\<Longrightarrow> relation_of (action_of \\<Squnion> relation_of ` A) = \\<Squnion> relation_of ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    action.relation_of\n     (action_of\n       (\\<lambda>Aa.\n           Aa \\<in> \\<Inter>\n                     {{p. P p} |P. P \\<in> action.relation_of ` A})) =\n    (\\<lambda>Aa.\n        Aa \\<in> \\<Inter> {{p. P p} |P. P \\<in> action.relation_of ` A})", "by (auto simp: action_of_inverse dest!: Sup_is_action)"], ["", "instantiation \"action\"  ::  (ev_eq, type) complete_lattice\nbegin"], ["", "definition Sup_action : \n\"(Sup (S:: ('a, 'b) action set) \\<equiv> if S={} then bot else action_of \\<Squnion> (relation_of ` S))\""], ["", "definition Inf_action : \n\"(Inf (S:: ('a, 'b) action set) \\<equiv> if S={} then top else action_of \\<Sqinter> (relation_of ` S))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) action, complete_lattice_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "fix A::\"('a, 'b) action set\" and z::\"('a, 'b) action\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "fix x::\"('a, 'b) action\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> Inf A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 5. Inf {} = top\n 6. Sup {} = bot", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "show \"Inf A \\<le> x\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. Inf A \\<le> x", "apply (auto simp add: less_action less_eq_action Inf_action ref_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa.\n       \\<lbrakk>x \\<in> A; action.relation_of x (a, b);\n        \\<not> action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<exists>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of ` A) \\<and>\n                         Aa \\<in> x))\n                (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa.\n       \\<lbrakk>xa \\<in> A; x \\<in> A; action.relation_of x (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<exists>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of ` A) \\<and>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>a b xa.\n       \\<lbrakk>x \\<in> A; action.relation_of x (a, b);\n        \\<nexists>x.\n           (\\<exists>P.\n               x = Collect P \\<and> P \\<in> action.relation_of ` A) \\<and>\n           (a, b) \\<in> x;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto intro: Inf_is_action[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Inf A \\<le> x\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> Inf A \\<le> ?x2\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "note rule1 = this"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> Inf A \\<le> ?x2\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> Inf A \\<le> ?x2\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "assume *: \"\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x\""], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> z \\<le> ?x\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> Inf A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 4. Inf {} = top\n 5. Sup {} = bot", "show \"z \\<le> Inf A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> z \\<le> Inf A\n 2. A \\<noteq> {} \\<Longrightarrow> z \\<le> Inf A", "case True"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> z \\<le> Inf A\n 2. A \\<noteq> {} \\<Longrightarrow> z \\<le> Inf A", "then"], ["proof (chain)\npicking this:\n  A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "by (simp add: Inf_action)"], ["proof (state)\nthis:\n  z \\<le> Inf A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> z \\<le> Inf A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> z \\<le> Inf A", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> z \\<le> Inf A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "using *"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> z \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> Inf A", "apply (auto simp add: Inf_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> z \\<le> action_of\n                        (\\<lambda>Aa.\n                            \\<exists>x.\n                               (\\<exists>P.\n                                   x = Collect P \\<and>\n                                   P \\<in> action.relation_of ` A) \\<and>\n                               Aa \\<in> x);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "using \\<open>A \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x;\n        \\<not> z \\<le> action_of\n                        (\\<lambda>Aa.\n                            \\<exists>x.\n                               (\\<exists>P.\n                                   x = Collect P \\<and>\n                                   P \\<in> action.relation_of ` A) \\<and>\n                               Aa \\<in> x);\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: less_eq_action Inf_action ref_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> A \\<Longrightarrow>\n                   \\<forall>a b.\n                      (action.relation_of x \\<longrightarrow>\n                       action.relation_of z)\n                       (a, b);\n        \\<exists>a b.\n           \\<not> (action.relation_of\n                    (action_of\n                      (\\<lambda>Aa.\n                          \\<exists>x.\n                             (\\<exists>P.\n                                 x = Collect P \\<and>\n                                 P \\<in> action.relation_of ` A) \\<and>\n                             Aa \\<in> x)) \\<longrightarrow>\n                   action.relation_of z)\n                   (a, b);\n        x \\<in> A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; A \\<noteq> {};\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              (action.relation_of x \\<longrightarrow> action.relation_of z)\n               (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<exists>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of ` A) \\<and>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> A \\<Longrightarrow>\n                   \\<forall>a b.\n                      (action.relation_of x \\<longrightarrow>\n                       action.relation_of z)\n                       (a, b);\n        \\<exists>a b.\n           \\<not> ((\\<lambda>Aa.\n                       \\<exists>x.\n                          (\\<exists>P.\n                              x = Collect P \\<and>\n                              P \\<in> action.relation_of ` A) \\<and>\n                          Aa \\<in> x) \\<longrightarrow>\n                   action.relation_of z)\n                   (a, b);\n        x \\<in> A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) ex_in_conv[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> A; \\<exists>x. x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              (action.relation_of x \\<longrightarrow> action.relation_of z)\n               (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<exists>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of ` A) \\<and>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> A \\<Longrightarrow>\n                   \\<forall>a b.\n                      (action.relation_of x \\<longrightarrow>\n                       action.relation_of z)\n                       (a, b);\n        \\<exists>a b.\n           \\<not> ((\\<lambda>Aa.\n                       \\<exists>x.\n                          (\\<exists>P.\n                              x = Collect P \\<and>\n                              P \\<in> action.relation_of ` A) \\<and>\n                          Aa \\<in> x) \\<longrightarrow>\n                   action.relation_of z)\n                   (a, b);\n        x \\<in> A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              (action.relation_of x \\<longrightarrow> action.relation_of z)\n               (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<exists>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of ` A) \\<and>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> A \\<Longrightarrow>\n                   \\<forall>a b.\n                      (action.relation_of x \\<longrightarrow>\n                       action.relation_of z)\n                       (a, b);\n        \\<exists>a b.\n           \\<not> ((\\<lambda>Aa.\n                       \\<exists>x.\n                          (\\<exists>P.\n                              x = Collect P \\<and>\n                              P \\<in> action.relation_of ` A) \\<and>\n                          Aa \\<in> x) \\<longrightarrow>\n                   action.relation_of z)\n                   (a, b);\n        x \\<in> A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto intro: Inf_is_action[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  z \\<le> Inf A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<le> Inf A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "}"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n  z \\<le> Inf A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "{"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n  z \\<le> Inf A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "fix x::\"('a, 'b) action\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 3. Inf {} = top\n 4. Sup {} = bot", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "show \"x \\<le> (Sup A)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<le> Sup A", "apply (auto simp add: less_action less_eq_action Sup_action ref_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa.\n       \\<lbrakk>x \\<in> A;\n        action.relation_of\n         (action_of\n           (\\<lambda>Aa.\n               \\<forall>x.\n                  (\\<exists>P.\n                      x = Collect P \\<and>\n                      P \\<in> action.relation_of ` A) \\<longrightarrow>\n                  Aa \\<in> x))\n         (a, b);\n        \\<not> action.relation_of x (a, b); xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b xa.\n       \\<lbrakk>\\<not> action.relation_of x (a, b); xa \\<in> A;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<forall>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of `\n      A) \\<longrightarrow>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>a b xa.\n       \\<lbrakk>x \\<in> A;\n        \\<forall>x.\n           (\\<exists>P.\n               x = Collect P \\<and>\n               P \\<in> action.relation_of ` A) \\<longrightarrow>\n           (a, b) \\<in> x;\n        \\<not> action.relation_of x (a, b); xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto intro: Sup_is_action[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<le> Sup A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> ?x2 \\<le> Sup A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "note rule2 = this"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> ?x2 \\<le> Sup A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "{"], ["proof (state)\nthis:\n  ?x2 \\<in> A \\<Longrightarrow> ?x2 \\<le> Sup A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "assume \"\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\""], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       Sup A \\<le> z\n 2. Inf {} = top\n 3. Sup {} = bot", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z", "show \"Sup A \\<le> z\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z\n\ngoal (1 subgoal):\n 1. Sup A \\<le> z", "apply (auto simp add: Sup_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z;\n        \\<not> action_of\n                (\\<lambda>Aa.\n                    \\<forall>x.\n                       (\\<exists>P.\n                           x = Collect P \\<and>\n                           P \\<in> action.relation_of ` A) \\<longrightarrow>\n                       Aa \\<in> x)\n               \\<le> z;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply atomize"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. x \\<in> A \\<longrightarrow> x \\<le> z;\n        \\<not> action_of\n                (\\<lambda>Aa.\n                    \\<forall>x.\n                       (\\<exists>P.\n                           x = Collect P \\<and>\n                           P \\<in> action.relation_of ` A) \\<longrightarrow>\n                       Aa \\<in> x)\n               \\<le> z;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"A = {}\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. x \\<in> A \\<longrightarrow> x \\<le> z;\n        \\<not> action_of\n                (\\<lambda>Aa.\n                    \\<forall>x.\n                       (\\<exists>P.\n                           x = Collect P \\<and>\n                           P \\<in> action.relation_of ` A) \\<longrightarrow>\n                       Aa \\<in> x)\n               \\<le> z;\n        x \\<in> A; A \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (insert rule2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. x \\<in> A \\<longrightarrow> x \\<le> z;\n        \\<not> action_of\n                (\\<lambda>Aa.\n                    \\<forall>x.\n                       (\\<exists>P.\n                           x = Collect P \\<and>\n                           P \\<in> action.relation_of ` A) \\<longrightarrow>\n                       Aa \\<in> x)\n               \\<le> z;\n        x \\<in> A; A \\<noteq> {};\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> Sup A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: less_action less_eq_action Sup_action ref_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b xa.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<longrightarrow>\n                   (\\<forall>a b.\n                       (action.relation_of z \\<longrightarrow>\n                        action.relation_of x)\n                        (a, b));\n        x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              (action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<forall>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         Aa \\<in> x)) \\<longrightarrow>\n               action.relation_of x)\n               (a, b);\n        action.relation_of z (a, b);\n        \\<not> action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<forall>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         Aa \\<in> x))\n                (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b xa.\n       \\<lbrakk>action.relation_of z (a, b);\n        \\<not> action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<forall>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         Aa \\<in> x))\n                (a, b);\n        xa \\<in> A;\n        \\<forall>x.\n           x \\<in> A \\<longrightarrow>\n           (\\<forall>a b.\n               (action.relation_of z \\<longrightarrow> action.relation_of x)\n                (a, b));\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<forall>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of `\n      A) \\<longrightarrow>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>x a b xa.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<longrightarrow>\n                   (\\<forall>a b.\n                       (action.relation_of z \\<longrightarrow>\n                        action.relation_of x)\n                        (a, b));\n        x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              ((\\<lambda>Aa.\n                   \\<forall>x.\n                      (\\<exists>P.\n                          x = Collect P \\<and>\n                          P \\<in> action.relation_of ` A) \\<longrightarrow>\n                      Aa \\<in> x) \\<longrightarrow>\n               action.relation_of x)\n               (a, b);\n        action.relation_of z (a, b);\n        \\<not> action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<forall>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         Aa \\<in> x))\n                (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto intro: Sup_is_action[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b xa.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<longrightarrow>\n                   (\\<forall>a b.\n                       (action.relation_of z \\<longrightarrow>\n                        action.relation_of x)\n                        (a, b));\n        x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              ((\\<lambda>Aa.\n                   \\<forall>x.\n                      (\\<exists>P.\n                          x = Collect P \\<and>\n                          P \\<in> action.relation_of ` A) \\<longrightarrow>\n                      Aa \\<in> x) \\<longrightarrow>\n               action.relation_of x)\n               (a, b);\n        action.relation_of z (a, b);\n        \\<not> action.relation_of\n                (action_of\n                  (\\<lambda>Aa.\n                      \\<forall>x.\n                         (\\<exists>P.\n                             x = Collect P \\<and>\n                             P \\<in> action.relation_of `\n                                     A) \\<longrightarrow>\n                         Aa \\<in> x))\n                (a, b);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) action_of_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b xa.\n       \\<lbrakk>xa \\<in> A;\n        \\<forall>x.\n           x \\<in> A \\<longrightarrow>\n           (\\<forall>a b.\n               (action.relation_of z \\<longrightarrow> action.relation_of x)\n                (a, b));\n        x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              ((\\<lambda>Aa.\n                   \\<forall>x.\n                      (\\<exists>P.\n                          x = Collect P \\<and>\n                          P \\<in> action.relation_of ` A) \\<longrightarrow>\n                      Aa \\<in> x) \\<longrightarrow>\n               action.relation_of x)\n               (a, b);\n        action.relation_of z (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>Aa.\n                             \\<forall>x.\n                                (\\<exists>P.\n                                    x = Collect P \\<and>\n                                    P \\<in> action.relation_of `\n      A) \\<longrightarrow>\n                                Aa \\<in> x)\n                         \\<in> Collect is_CSP_process\n 2. \\<And>x a b xa.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> A \\<longrightarrow>\n                   (\\<forall>a b.\n                       (action.relation_of z \\<longrightarrow>\n                        action.relation_of x)\n                        (a, b));\n        x \\<in> A;\n        \\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           \\<forall>a b.\n              ((\\<lambda>Aa.\n                   \\<forall>x.\n                      (\\<exists>P.\n                          x = Collect P \\<and>\n                          P \\<in> action.relation_of ` A) \\<longrightarrow>\n                      Aa \\<in> x) \\<longrightarrow>\n               action.relation_of x)\n               (a, b);\n        action.relation_of z (a, b);\n        \\<not> (\\<forall>x.\n                   (\\<exists>P.\n                       x = Collect P \\<and>\n                       P \\<in> action.relation_of ` A) \\<longrightarrow>\n                   (a, b) \\<in> x);\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto intro: Sup_is_action[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Sup A \\<le> z\n\ngoal (2 subgoals):\n 1. Inf {} = top\n 2. Sup {} = bot", "}"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n  Sup A \\<le> z\n\ngoal (2 subgoals):\n 1. Inf {} = top\n 2. Sup {} = bot", "{"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n  Sup A \\<le> z\n\ngoal (2 subgoals):\n 1. Inf {} = top\n 2. Sup {} = bot", "show \"Inf ({}::('a, 'b) action set) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {} = top", "by(simp add:Inf_action)"], ["proof (state)\nthis:\n  Inf {} = top\n\ngoal (1 subgoal):\n 1. Sup {} = bot", "}"], ["proof (state)\nthis:\n  Inf {} = top\n\ngoal (1 subgoal):\n 1. Sup {} = bot", "{"], ["proof (state)\nthis:\n  Inf {} = top\n\ngoal (1 subgoal):\n 1. Sup {} = bot", "show \"Sup ({}::('a, 'b) action set) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {} = bot", "by(simp add:Sup_action)"], ["proof (state)\nthis:\n  Sup {} = bot\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Sup {} = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}