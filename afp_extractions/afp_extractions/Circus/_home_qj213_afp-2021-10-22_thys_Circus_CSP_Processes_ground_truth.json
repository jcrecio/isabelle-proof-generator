{"file_name": "/home/qj213/afp-2021-10-22/thys/Circus/CSP_Processes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Circus", "problem_names": ["lemmas csp_defs = CSP1_def J_csp_def CSP2_def is_CSP_process_def", "lemma is_CSP_processE1 [elim?]:\n  assumes \"is_CSP_process P\"\n  obtains \"P is CSP1 healthy\" \"P is CSP2 healthy\" \"P is R healthy\"", "lemma is_CSP_processE2 [elim?]:\n  assumes \"is_CSP_process P\"\n  obtains \"CSP1 P = P\" \"CSP2 P = P\" \"R P = P\"", "lemma CSP1_CSP2_commute: \"CSP1 o CSP2 = CSP2 o CSP1\"", "lemma CSP2_is_H2: \"H2 = CSP2\"", "lemma H2_CSP1_commute: \"H2 o CSP1 = CSP1 o H2\"", "lemma H2_CSP1_commute2: \"H2 (CSP1 P) = CSP1 (H2 P)\"", "lemma CSP1_R_commute:\n  \"CSP1 (R P) = R (CSP1 P)\"", "lemma CSP2_R_commute:\n  \"CSP2 (R P) = R (CSP2 P)\"", "lemma CSP1_idem: \"CSP1 = CSP1 o CSP1\"", "lemma CSP2_idem: \"CSP2 = CSP2 o CSP2\"", "lemma CSP_is_CSP1:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is CSP1 healthy\"", "lemma CSP_is_CSP2:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is CSP2 healthy\"", "lemma CSP_is_R:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is R healthy\"", "lemma t_or_f_a: \"P(a, b) \\<Longrightarrow> ((P(a, b\\<lparr>ok := True\\<rparr>)) \\<or> (P(a, b\\<lparr>ok := False\\<rparr>)))\"", "lemma CSP2_ok_a: \n\"(CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>) \\<Longrightarrow> (P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>))\"", "lemma CSP2_ok_b: \n\"(P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>)) \\<Longrightarrow> (CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>)\"", "lemma CSP2_ok: \n\"(CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>) = (P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>))\"", "lemma CSP2_notok_a: \"(CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>) \\<Longrightarrow> P(a, b\\<lparr>ok:=False\\<rparr>)\"", "lemma CSP2_notok_b: \"P(a, b\\<lparr>ok:=False\\<rparr>) \\<Longrightarrow> (CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>)\"", "lemma CSP2_notok: \"(CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>) = P(a, b\\<lparr>ok:=False\\<rparr>)\"", "lemma CSP2_t_f: \n  assumes A:\"(CSP2 (R (r \\<turnstile> p)))(a, b)\"\n  and B: \"((CSP2 (R (r \\<turnstile> p)))(a, b\\<lparr>ok:=False\\<rparr>)) \\<or> \n          ((CSP2 (R (r \\<turnstile> p)))(a, b\\<lparr>ok:=True\\<rparr>)) \\<Longrightarrow> Q\"\n  shows \"Q\"", "lemma disj_CSP1:\n  assumes \"P is CSP1 healthy\"\n    and \"Q is CSP1 healthy\"\n  shows \"(P \\<or> Q) is CSP1 healthy\"", "lemma disj_CSP2:\n  \"P is CSP2 healthy ==> Q is CSP2 healthy ==> (P \\<or> Q) is CSP2 healthy\"", "lemma disj_CSP:\n  assumes A: \"is_CSP_process P\"\n  assumes B: \"is_CSP_process Q\"\n  shows \"is_CSP_process (P \\<or> Q)\"", "lemma seq_CSP1:\n  assumes A: \"P is CSP1 healthy\"\n  assumes B: \"Q is CSP1 healthy\"\n  shows \"(P ;; Q) is CSP1 healthy\"", "lemma seq_CSP2:\n  assumes A: \"Q is CSP2 healthy\"\n  shows \"(P ;; Q) is CSP2 healthy\"", "lemma seq_R:\n  assumes \"P is R healthy\"\n  and \"Q is R healthy\"\n  shows \"(P ;; Q) is R healthy\"", "lemma seq_CSP:\n  assumes A: \"P is CSP1 healthy\"\n  and B: \"P is R healthy\"\n  and C: \"is_CSP_process Q\"\n  shows \"is_CSP_process (P ;; Q)\"", "lemma rd_ind_wait: \"(R(\\<not>(P \\<^sup>f\\<^sub>f) \\<turnstile> (P \\<^sup>t\\<^sub>f)))\n                        = (R((\\<not>(\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\"", "lemma rd_H1: \"(R((\\<not>(\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                              \\<turnstile> (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n                      (R ((\\<not> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                              \\<turnstile> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\"", "lemma rd_H1_H2: \"(R((\\<not> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n                        (R((\\<not>(H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\"", "lemma rd_H1_H2_R_H1_H2:\n   \"(R ((\\<not> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n            \\<turnstile> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n    (R o H1 o H2) P\"", "lemma CSP1_is_R1_H1:\n  assumes \"P is R1 healthy\"\n  shows \"CSP1 P = R1 (H1 P)\"", "lemma CSP1_is_R1_H1_2: \"CSP1 (R1 P) = R1 (H1 P)\"", "lemma CSP1_R1_commute: \"CSP1 o R1 = R1 o CSP1\"", "lemma CSP1_R1_commute2: \"CSP1 (R1 P) = R1 (CSP1 P)\"", "lemma CSP1_is_R1_H1_b: \n\"(P = (R \\<circ> R1 \\<circ> H1 \\<circ> H2) P) = (P = (R \\<circ> CSP1 \\<circ> H2) P)\"", "lemma CSP1_join: \n  assumes A: \"x is CSP1 healthy\"\n  and B: \"y is CSP1 healthy\"\n  shows \"(x \\<sqinter> y) is CSP1 healthy\"", "lemma CSP2_join:\n  assumes A: \"x is CSP2 healthy\"\n  and B: \"y is CSP2 healthy\"\n  shows \"(x \\<sqinter> y) is CSP2 healthy\"", "lemma CSP1_meet:\n  assumes A: \"x is CSP1 healthy\"\n  and B: \"y is CSP1 healthy\"\n  shows \"(x \\<squnion> y) is CSP1 healthy\"", "lemma CSP2_meet:\n  assumes A: \"x is CSP2 healthy\"\n  and B: \"y is CSP2 healthy\"\n  shows \"(x \\<squnion> y) is CSP2 healthy\"", "lemma CSP_join: \n  assumes A: \"is_CSP_process x\"\n  and B: \"is_CSP_process y\"\n  shows \"is_CSP_process (x \\<sqinter> y)\"", "lemma CSP_meet:\n  assumes A: \"is_CSP_process x\"\n  and B: \"is_CSP_process y\"\n  shows \"is_CSP_process (x \\<squnion> y)\"", "lemma rd_is_CSP1: \"(R (r \\<turnstile> p)) is CSP1 healthy\"", "lemma rd_is_CSP2:\n  assumes A: \"\\<forall> a b. r (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow> r (a, b\\<lparr>ok := False\\<rparr>)\"\n  shows \"(R (r \\<turnstile> p)) is CSP2 healthy\"", "lemma rd_is_CSP:\n  assumes A: \"\\<forall> a b. r (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow> r (a, b\\<lparr>ok := False\\<rparr>)\"\n  shows \"is_CSP_process (R (r \\<turnstile> p))\"", "lemma CSP_is_rd:\n  assumes A: \"is_CSP_process P\"\n  shows \"P = (R (\\<not>(P \\<^sup>f\\<^sub>f) \\<turnstile> (P \\<^sup>t\\<^sub>f)))\""], "translations": [["", "lemmas csp_defs = CSP1_def J_csp_def CSP2_def is_CSP_process_def"], ["", "lemma is_CSP_processE1 [elim?]:\n  assumes \"is_CSP_process P\"\n  obtains \"P is CSP1 healthy\" \"P is CSP2 healthy\" \"P is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>P is CSP1 healthy; P is CSP2 healthy; P is R healthy\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_CSP_process P\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P is CSP1 healthy; P is CSP2 healthy; P is R healthy\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_CSP_process_def"], ["proof (prove)\nusing this:\n  P is CSP1 healthy \\<and> P is CSP2 healthy \\<and> P is R healthy\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P is CSP1 healthy; P is CSP2 healthy; P is R healthy\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["", "lemma is_CSP_processE2 [elim?]:\n  assumes \"is_CSP_process P\"\n  obtains \"CSP1 P = P\" \"CSP2 P = P\" \"R P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>CSP1 P = P; CSP2 P = P; R P = P\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_CSP_process P\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>CSP1 P = P; CSP2 P = P; R P = P\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_CSP_process_def"], ["proof (prove)\nusing this:\n  P is CSP1 healthy \\<and> P is CSP2 healthy \\<and> P is R healthy\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>CSP1 P = P; CSP2 P = P; R P = P\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: Healthy_def')"], ["", "subsection \\<open>Proofs\\<close>"], ["", "text \\<open>Theorems and lemmas relative to CSP processes are introduced here.\\<close>"], ["", "lemma CSP1_CSP2_commute: \"CSP1 o CSP2 = CSP2 o CSP1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 \\<circ> CSP2 = CSP2 \\<circ> CSP1", "by (auto simp: csp_defs fun_eq_iff)"], ["", "lemma CSP2_is_H2: \"H2 = CSP2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2 = CSP2", "apply (clarsimp simp add: csp_defs design_defs rp_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            alpha_d.more A = alpha_d.more A'))\n        (a, b) =\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n        (a, b)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b.\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            alpha_d.more A = alpha_d.more A'))\n        (a, b) \\<Longrightarrow>\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n        (a, b)\n 2. \\<And>x a b.\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            tr A = tr A' \\<and>\n            wait A = wait A' \\<and>\n            ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n        (a, b) \\<Longrightarrow>\n       (x ;;\n        (\\<lambda>(A, A').\n            (ok A \\<longrightarrow> ok A') \\<and>\n            alpha_d.more A = alpha_d.more A'))\n        (a, b)", "apply (erule_tac [!] comp_elim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          alpha_d.more A = alpha_d.more A'\\<rbrakk>\n       \\<Longrightarrow> (x ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)\n 2. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'\\<rbrakk>\n       \\<Longrightarrow> (x ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac [!] b=ba in comp_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          alpha_d.more A = alpha_d.more A'\\<rbrakk>\n       \\<Longrightarrow> x (a, ba)\n 2. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          alpha_d.more A = alpha_d.more A'\\<rbrakk>\n       \\<Longrightarrow> case (ba, b) of\n                         (A, A') \\<Rightarrow>\n                           (ok A \\<longrightarrow> ok A') \\<and>\n                           tr A = tr A' \\<and>\n                           wait A = wait A' \\<and>\n                           ref A = ref A' \\<and>\n                           alpha_rp.more A = alpha_rp.more A'\n 3. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'\\<rbrakk>\n       \\<Longrightarrow> x (a, ba)\n 4. \\<And>x a b aa ba c.\n       \\<lbrakk>(a, b) = (aa, c); x (aa, ba);\n        case (ba, c) of\n        (A, A') \\<Rightarrow>\n          (ok A \\<longrightarrow> ok A') \\<and>\n          tr A = tr A' \\<and>\n          wait A = wait A' \\<and>\n          ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'\\<rbrakk>\n       \\<Longrightarrow> case (ba, b) of\n                         (A, A') \\<Rightarrow>\n                           (ok A \\<longrightarrow> ok A') \\<and>\n                           alpha_d.more A = alpha_d.more A'", "apply (auto elim!: alpha_d_more_eqE intro!: alpha_d_more_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma H2_CSP1_commute: \"H2 o CSP1 = CSP1 o H2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2 \\<circ> CSP1 = CSP1 \\<circ> H2", "apply (subst CSP2_is_H2[simplified Healthy_def])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 \\<circ> CSP1 = CSP1 \\<circ> CSP2", "apply (rule CSP1_CSP2_commute[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma H2_CSP1_commute2: \"H2 (CSP1 P) = CSP1 (H2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H2 (CSP1 P) = CSP1 (H2 P)", "by (simp add: H2_CSP1_commute[simplified Fun.comp_def fun_eq_iff, rule_format] fun_eq_iff)"], ["", "lemma CSP1_R_commute:\n  \"CSP1 (R P) = R (CSP1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 (R P) = R (CSP1 P)", "by (auto simp: csp_defs rp_defs fun_eq_iff prefix_def split: cond_splits)"], ["", "lemma CSP2_R_commute:\n  \"CSP2 (R P) = R (CSP2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 (R P) = R (CSP2 P)", "apply (subst CSP2_is_H2[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. H2 (R P) = R (H2 P)", "apply (rule R_H2_commute2[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP1_idem: \"CSP1 = CSP1 o CSP1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 = CSP1 \\<circ> CSP1", "by (auto simp: csp_defs fun_eq_iff)"], ["", "lemma CSP2_idem: \"CSP2 = CSP2 o CSP2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 = CSP2 \\<circ> CSP2", "by (auto simp: csp_defs fun_eq_iff)"], ["", "lemma CSP_is_CSP1:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is CSP1 healthy", "using A"], ["proof (prove)\nusing this:\n  is_CSP_process P\n\ngoal (1 subgoal):\n 1. P is CSP1 healthy", "by (auto simp: is_CSP_process_def design_defs)"], ["", "lemma CSP_is_CSP2:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is CSP2 healthy", "using A"], ["proof (prove)\nusing this:\n  is_CSP_process P\n\ngoal (1 subgoal):\n 1. P is CSP2 healthy", "by (simp add: design_defs prefix_def is_CSP_process_def)"], ["", "lemma CSP_is_R:\n  assumes A: \"is_CSP_process P\"\n  shows \"P is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is R healthy", "using A"], ["proof (prove)\nusing this:\n  is_CSP_process P\n\ngoal (1 subgoal):\n 1. P is R healthy", "by (simp add: design_defs prefix_def is_CSP_process_def)"], ["", "lemma t_or_f_a: \"P(a, b) \\<Longrightarrow> ((P(a, b\\<lparr>ok := True\\<rparr>)) \\<or> (P(a, b\\<lparr>ok := False\\<rparr>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b) \\<Longrightarrow>\n    P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>)", "apply (case_tac \"ok b\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P (a, b); ok b;\n     \\<not> P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)\n 2. \\<lbrakk>P (a, b); \\<not> ok b;\n     \\<not> P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "apply (rule_tac t=\"b\\<lparr>ok := True\\<rparr>\" and s=\"b\" in ssubst, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (a, b); \\<not> ok b;\n     \\<not> P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n    \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "by (subgoal_tac \"b = b\\<lparr>ok := False\\<rparr>\", simp_all)"], ["", "lemma CSP2_ok_a: \n\"(CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>) \\<Longrightarrow> (P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 P (a, b\\<lparr>ok := True\\<rparr>) \\<Longrightarrow>\n    P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>)", "apply (clarsimp simp: csp_defs design_defs rp_defs split: cond_splits elim: prefixE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "apply (case_tac \"ok ba\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>); ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)\n 2. \\<And>ba.\n       \\<lbrakk>P (a, ba); tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>); \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "apply (rule_tac t=\"b\\<lparr>ok := True\\<rparr>\" and s=\"ba\" in ssubst, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>); \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "apply (drule_tac b=\"b\\<lparr>ok := False\\<rparr>\" and a=\"ba\" in back_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba.\n       \\<lbrakk>tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>); \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ba = b\\<lparr>ok := False\\<rparr>\n 2. \\<And>ba.\n       \\<lbrakk>tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b;\n        \\<not> P (a, b\\<lparr>ok := False\\<rparr>); \\<not> ok ba;\n        P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := True\\<rparr>)", "apply (auto intro: alpha_rp.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP2_ok_b: \n\"(P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>)) \\<Longrightarrow> (CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := True\\<rparr>)", "by (auto simp: csp_defs design_defs rp_defs)"], ["", "lemma CSP2_ok: \n\"(CSP2 P)(a, b\\<lparr>ok:=True\\<rparr>) = (P(a, b\\<lparr>ok:=True\\<rparr>) \\<or> P(a, b\\<lparr>ok:=False\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 P (a, b\\<lparr>ok := True\\<rparr>) =\n    (P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n     P (a, b\\<lparr>ok := False\\<rparr>))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. CSP2 P (a, b\\<lparr>ok := True\\<rparr>) \\<Longrightarrow>\n    P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>)\n 2. P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := True\\<rparr>)", "apply (simp add: CSP2_ok_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b\\<lparr>ok := True\\<rparr>) \\<or>\n    P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := True\\<rparr>)", "by (simp add: CSP2_ok_b)"], ["", "lemma CSP2_notok_a: \"(CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>) \\<Longrightarrow> P(a, b\\<lparr>ok:=False\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    P (a, b\\<lparr>ok := False\\<rparr>)", "apply (clarsimp simp: csp_defs design_defs rp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); \\<not> ok ba; tr ba = tr b; wait ba = wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := False\\<rparr>)", "apply (case_tac \"ok ba\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); \\<not> ok ba; tr ba = tr b; wait ba = wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := False\\<rparr>)\n 2. \\<And>ba.\n       \\<lbrakk>P (a, ba); \\<not> ok ba; tr ba = tr b; wait ba = wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b;\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := False\\<rparr>)", "apply (rule_tac t=\"b\\<lparr>ok := True\\<rparr>\" and s=\"ba\" in ssubst, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba.\n       \\<lbrakk>P (a, ba); tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := False\\<rparr>)", "apply (drule_tac b=\"b\\<lparr>ok := False\\<rparr>\" and a=\"ba\" in back_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba.\n       \\<lbrakk>tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ba = b\\<lparr>ok := False\\<rparr>\n 2. \\<And>ba.\n       \\<lbrakk>tr ba = tr b; wait ba = wait b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; \\<not> ok ba;\n        P (a, b\\<lparr>ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a, b\\<lparr>ok := False\\<rparr>)", "apply (auto intro: alpha_rp.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP2_notok_b: \"P(a, b\\<lparr>ok:=False\\<rparr>) \\<Longrightarrow> (CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := False\\<rparr>)", "by (auto simp: csp_defs design_defs rp_defs)"], ["", "lemma CSP2_notok: \"(CSP2 P)(a, b\\<lparr>ok:=False\\<rparr>) = P(a, b\\<lparr>ok:=False\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 P (a, b\\<lparr>ok := False\\<rparr>) =\n    P (a, b\\<lparr>ok := False\\<rparr>)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. CSP2 P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    P (a, b\\<lparr>ok := False\\<rparr>)\n 2. P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := False\\<rparr>)", "apply (simp add: CSP2_notok_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (a, b\\<lparr>ok := False\\<rparr>) \\<Longrightarrow>\n    CSP2 P (a, b\\<lparr>ok := False\\<rparr>)", "by (simp add: CSP2_notok_b)"], ["", "lemma CSP2_t_f: \n  assumes A:\"(CSP2 (R (r \\<turnstile> p)))(a, b)\"\n  and B: \"((CSP2 (R (r \\<turnstile> p)))(a, b\\<lparr>ok:=False\\<rparr>)) \\<or> \n          ((CSP2 (R (r \\<turnstile> p)))(a, b\\<lparr>ok:=True\\<rparr>)) \\<Longrightarrow> Q\"\n  shows \"Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q", "apply (rule B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 (R (r \\<turnstile> p)) (a, b\\<lparr>ok := False\\<rparr>) \\<or>\n    CSP2 (R (r \\<turnstile> p)) (a, b\\<lparr>ok := True\\<rparr>)", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 (R (r \\<turnstile> p)) (a, b\\<lparr>ok := True\\<rparr>)", "apply (insert A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP2 (R (r \\<turnstile> p)) (a, b) \\<Longrightarrow>\n    CSP2 (R (r \\<turnstile> p)) (a, b\\<lparr>ok := True\\<rparr>)", "apply (auto simp add: csp_defs design_defs rp_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma disj_CSP1:\n  assumes \"P is CSP1 healthy\"\n    and \"Q is CSP1 healthy\"\n  shows \"(P \\<or> Q) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<or> Q is CSP1 healthy", "using assms"], ["proof (prove)\nusing this:\n  P is CSP1 healthy\n  Q is CSP1 healthy\n\ngoal (1 subgoal):\n 1. P \\<or> Q is CSP1 healthy", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff)"], ["", "lemma disj_CSP2:\n  \"P is CSP2 healthy ==> Q is CSP2 healthy ==> (P \\<or> Q) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P is CSP2 healthy; Q is CSP2 healthy\\<rbrakk>\n    \\<Longrightarrow> P \\<or> Q is CSP2 healthy", "by (simp add: CSP2_is_H2[symmetric] Healthy_def' design_defs comp_ndet_l_distr)"], ["", "lemma disj_CSP:\n  assumes A: \"is_CSP_process P\"\n  assumes B: \"is_CSP_process Q\"\n  shows \"is_CSP_process (P \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (P \\<or> Q)", "apply (simp add: is_CSP_process_def Healthy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = CSP1 (P \\<or> Q) \\<and>\n    (P \\<or> Q) = CSP2 (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (subst disj_CSP2[simplified Healthy_def, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. P = CSP2 P\n 2. Q = CSP2 Q\n 3. (P \\<or> Q) = CSP1 (P \\<or> Q) \\<and>\n    (P \\<or> Q) = (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (rule A[THEN CSP_is_CSP2, simplified Healthy_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q = CSP2 Q\n 2. (P \\<or> Q) = CSP1 (P \\<or> Q) \\<and>\n    (P \\<or> Q) = (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (rule B[THEN CSP_is_CSP2, simplified Healthy_def], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = CSP1 (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (subst disj_CSP1[simplified Healthy_def, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. P = CSP1 P\n 2. Q = CSP1 Q\n 3. (P \\<or> Q) = (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (rule A[THEN CSP_is_CSP1, simplified Healthy_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q = CSP1 Q\n 2. (P \\<or> Q) = (P \\<or> Q) \\<and> (P \\<or> Q) = R (P \\<or> Q)", "apply (rule B[THEN CSP_is_CSP1, simplified Healthy_def], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = R (P \\<or> Q)", "apply (subst R_disj[simplified Healthy_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. P = R P\n 2. Q = R Q\n 3. R (P \\<or> Q) = R (P \\<or> Q)", "apply (rule A[THEN CSP_is_R, simplified Healthy_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q = R Q\n 2. R (P \\<or> Q) = R (P \\<or> Q)", "apply (rule B[THEN CSP_is_R, simplified Healthy_def], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma seq_CSP1:\n  assumes A: \"P is CSP1 healthy\"\n  assumes B: \"Q is CSP1 healthy\"\n  shows \"(P ;; Q) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q is CSP1 healthy", "using A B"], ["proof (prove)\nusing this:\n  P is CSP1 healthy\n  Q is CSP1 healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is CSP1 healthy", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff)"], ["", "lemma seq_CSP2:\n  assumes A: \"Q is CSP2 healthy\"\n  shows \"(P ;; Q) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q is CSP2 healthy", "using A"], ["proof (prove)\nusing this:\n  Q is CSP2 healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is CSP2 healthy", "by (auto simp: CSP2_is_H2[symmetric] H2_J[symmetric])"], ["", "lemma seq_R:\n  assumes \"P is R healthy\"\n  and \"Q is R healthy\"\n  shows \"(P ;; Q) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "have \"R P = P\" and \"R Q = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P = P &&& R Q = Q", "using assms"], ["proof (prove)\nusing this:\n  P is R healthy\n  Q is R healthy\n\ngoal (1 subgoal):\n 1. R P = P &&& R Q = Q", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R P = P\n  R Q = Q\n\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "moreover"], ["proof (state)\nthis:\n  R P = P\n  R Q = Q\n\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "have \"(R P ;; R Q) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P ;; R Q is R healthy", "apply (auto simp add: design_defs rp_defs prefix_def fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b zs.\n       \\<lbrakk>wait a; \\<not> ok a; tr b = tr a @ zs\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 2. \\<And>aa ba c zs zsa.\n       \\<lbrakk>\\<not> wait aa; wait ba;\n        P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        tr ba = tr aa @ zs; \\<not> ok ba; tr c = tr aa @ zs @ zsa\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := zs @ zsa\\<rparr>)\n 3. \\<And>aa ba c zs.\n       \\<lbrakk>\\<not> wait aa; wait ba;\n        P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        tr ba = tr c; ok c; tr aa @ zs = tr c; wait c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := zs\\<rparr>)\n 4. \\<And>aa ba c zs zsa.\n       \\<lbrakk>\\<not> wait aa; \\<not> wait ba;\n        P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        tr ba = tr aa @ zs;\n        Q (ba\\<lparr>tr := []\\<rparr>, c\\<lparr>tr := zsa\\<rparr>);\n        tr c = tr aa @ zs @ zsa\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := zs @ zsa\\<rparr>)\n 5. \\<And>aa ba c zs.\n       \\<lbrakk>\\<not> wait aa; wait ba;\n        P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        tr ba = tr c; ok c; tr aa @ zs = tr c; wait c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 6. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 7. \\<And>a b ba.\n       \\<lbrakk>tr b = tr a @ tr ba; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; ok b; wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 8. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); \\<not> wait ba;\n        Q (ba\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := zsa\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)", "apply (rule_tac b=a in comp_intro, auto split: cond_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba c zs.\n       \\<lbrakk>\\<not> wait aa; wait ba;\n        P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        tr ba = tr c; ok c; tr aa @ zs = tr c; wait c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 2. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 3. \\<And>a b ba.\n       \\<lbrakk>tr b = tr a @ tr ba; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; ok b; wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 4. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); \\<not> wait ba;\n        Q (ba\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := zsa\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)", "apply (rule_tac x=\"zs\" in exI, auto split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 2. \\<And>a b ba.\n       \\<lbrakk>tr b = tr a @ tr ba; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); wait ba; ok b; wait b;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)\n 3. \\<And>a b ba zsa.\n       \\<lbrakk>tr b = tr a @ tr ba @ zsa; \\<not> wait a;\n        P (a\\<lparr>tr := []\\<rparr>, ba); \\<not> wait ba;\n        Q (ba\\<lparr>tr := []\\<rparr>, b\\<lparr>tr := zsa\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  P (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))) ;;\n                          ((\\<lambda>(A, A').\n                               \\<not> ok A \\<and>\n                               (\\<exists>zs. tr A' = tr A @ zs) \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  Q (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  (\\<exists>zs. tr A' = tr A @ zs))))\n                          (a, b)", "apply (rule_tac b=\"ba\\<lparr>tr := tr a @ tr ba\\<rparr>\" in comp_intro, auto split: cond_splits)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  R P ;; R Q is R healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "ultimately"], ["proof (chain)\npicking this:\n  R P = P\n  R Q = Q\n  R P ;; R Q is R healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R P = P\n  R Q = Q\n  R P ;; R Q is R healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "by simp"], ["proof (state)\nthis:\n  P ;; Q is R healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seq_CSP:\n  assumes A: \"P is CSP1 healthy\"\n  and B: \"P is R healthy\"\n  and C: \"is_CSP_process Q\"\n  shows \"is_CSP_process (P ;; Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (P ;; Q)", "apply (auto simp add: is_CSP_process_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. P ;; Q is CSP1 healthy\n 2. P ;; Q is CSP2 healthy\n 3. P ;; Q is R healthy", "apply (subst seq_CSP1[simplified Healthy_def])"], ["proof (prove)\ngoal (5 subgoals):\n 1. P = CSP1 P\n 2. Q = CSP1 Q\n 3. CSP1 (P ;; Q) is CSP1 healthy\n 4. P ;; Q is CSP2 healthy\n 5. P ;; Q is R healthy", "apply (rule A[simplified Healthy_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. Q = CSP1 Q\n 2. CSP1 (P ;; Q) is CSP1 healthy\n 3. P ;; Q is CSP2 healthy\n 4. P ;; Q is R healthy", "apply (rule CSP_is_CSP1[OF C, simplified Healthy_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. CSP1 (P ;; Q) is CSP1 healthy\n 2. P ;; Q is CSP2 healthy\n 3. P ;; Q is R healthy", "apply (simp add: Healthy_def, subst CSP1_idem, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. P ;; Q is CSP2 healthy\n 2. P ;; Q is R healthy", "apply (subst seq_CSP2[simplified Healthy_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. Q = CSP2 Q\n 2. CSP2 (P ;; Q) is CSP2 healthy\n 3. P ;; Q is R healthy", "apply (rule CSP_is_CSP2[OF C, simplified Healthy_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. CSP2 (P ;; Q) is CSP2 healthy\n 2. P ;; Q is R healthy", "apply (simp add: Healthy_def, subst CSP2_idem, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q is R healthy", "apply (subst seq_R[simplified Healthy_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. P = R P\n 2. Q = R Q\n 3. R (P ;; Q) is R healthy", "apply (rule B[simplified Healthy_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q = R Q\n 2. R (P ;; Q) is R healthy", "apply (rule CSP_is_R[OF C, simplified Healthy_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (P ;; Q) is R healthy", "apply (simp add: Healthy_def, subst R_idem2, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rd_ind_wait: \"(R(\\<not>(P \\<^sup>f\\<^sub>f) \\<turnstile> (P \\<^sup>t\\<^sub>f)))\n                        = (R((\\<not>(\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<not> P\\<^sup>f\\<^sub>f \\<turnstile> P\\<^sup>t\\<^sub>f) =\n    R (\\<not> (\\<lambda>(A, A').\n                  P (A, A'\n                     \\<lparr>ok :=\n                               False\\<rparr>)) \\<turnstile> \\<lambda>(A,\n                         A'). P (A, A'\\<lparr>ok := True\\<rparr>))", "apply (auto simp: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 2. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 3. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 4. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 5. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 6. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subgoal_tac \"a\\<lparr>tr := [], wait := False\\<rparr> = a\\<lparr>tr := []\\<rparr>\", auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 3. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 4. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 5. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subgoal_tac \"a\\<lparr>tr := [], wait := False\\<rparr> = a\\<lparr>tr := []\\<rparr>\", auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 3. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 4. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subgoal_tac \"a\\<lparr>tr := [], wait := False\\<rparr> = a\\<lparr>tr := []\\<rparr>\", auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 2. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 3. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subgoal_tac \"a\\<lparr>tr := [], wait := False\\<rparr> = a\\<lparr>tr := []\\<rparr>\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := False\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)\n 2. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (subgoal_tac \"a\\<lparr>tr := [], wait := False\\<rparr> = a\\<lparr>tr := []\\<rparr>\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, b\n           \\<lparr>tr := tr b - tr a, ok := True\\<rparr>);\n        ok a;\n        \\<not> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                  \\<lparr>tr := tr b - tr a, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := [], wait := False\\<rparr>, b\n                            \\<lparr>tr := tr b - tr a, ok := True\\<rparr>)", "apply (rule_tac t=\"a\\<lparr>tr := [], wait := False\\<rparr>\" and s=\"a\\<lparr>tr := []\\<rparr>\" in subst, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rd_H1: \"(R((\\<not>(\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                              \\<turnstile> (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n                      (R ((\\<not> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                              \\<turnstile> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<not> (\\<lambda>(A, A').\n                  P (A, A'\n                     \\<lparr>ok :=\n                               False\\<rparr>)) \\<turnstile> \\<lambda>(A,\n                         A'). P (A, A'\\<lparr>ok := True\\<rparr>)) =\n    R (\\<not> H1 (\\<lambda>(A, A').\n                     P (A, A'\n                        \\<lparr>ok :=\n                                  False\\<rparr>)) \\<turnstile> H1\n                          (\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)))", "by (auto simp: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["", "lemma rd_H1_H2: \"(R((\\<not> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> H1 (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n                        (R((\\<not>(H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n                                  \\<turnstile> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<not> H1 (\\<lambda>(A, A').\n                     P (A, A'\n                        \\<lparr>ok :=\n                                  False\\<rparr>)) \\<turnstile> H1\n                          (\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>))) =\n    R (\\<not> (H1 \\<circ> H2)\n               (\\<lambda>(A, A').\n                   P (A, A'\n                      \\<lparr>ok :=\n                                False\\<rparr>)) \\<turnstile> (H1 \\<circ> H2)\n                        (\\<lambda>(A, A').\n                            P (A, A'\\<lparr>ok := True\\<rparr>)))", "apply (auto simp: design_defs rp_defs prefix_def fun_eq_iff split: cond_splits elim: alpha_d_more_eqE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 2. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 3. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok b;\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 4. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 5. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = ba\\<lparr>ok := False\\<rparr>\", auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 2. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok b;\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 3. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 4. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = ba\\<lparr>ok := False\\<rparr>\", auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := False\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok b;\n        ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 2. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 3. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := False\\<rparr> = ba\\<lparr>ok := False\\<rparr>\", auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)\n 2. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := True\\<rparr> = ba\\<lparr>ok := True\\<rparr>\", auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b zs ba.\n       \\<lbrakk>\\<not> wait a; tr b = tr a @ zs; ok b;\n        P (a\\<lparr>tr := []\\<rparr>, ba\\<lparr>ok := True\\<rparr>);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := zs\\<rparr>); ok a;\n        \\<not> P (a\\<lparr>tr := []\\<rparr>, b\n                  \\<lparr>tr := zs, ok := False\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, b\n                            \\<lparr>tr := zs, ok := True\\<rparr>)", "apply (subgoal_tac \"b\\<lparr>tr := zs, ok := True\\<rparr> = ba\\<lparr>ok := True\\<rparr>\", auto intro: alpha_d.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rd_H1_H2_R_H1_H2:\n   \"(R ((\\<not> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := False\\<rparr>))) \n            \\<turnstile> (H1 o H2) (\\<lambda> (A, A'). P (A, A'\\<lparr>ok := True\\<rparr>)))) = \n    (R o H1 o H2) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<not> (H1 \\<circ> H2)\n               (\\<lambda>(A, A').\n                   P (A, A'\n                      \\<lparr>ok :=\n                                False\\<rparr>)) \\<turnstile> (H1 \\<circ> H2)\n                        (\\<lambda>(A, A').\n                            P (A, A'\\<lparr>ok := True\\<rparr>))) =\n    (R \\<circ> H1 \\<circ> H2) P", "apply (auto simp: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok b\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (erule notE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> wait a\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "back"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok ba\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "back"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac b=\"ba\" in comp_intro, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>ok := False\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac t=\"ba\\<lparr>ok := False\\<rparr>\" and s=ba in subst, auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (erule notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> wait a\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ok ba\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac b=\"ba\" in comp_intro, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba; ok a\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>ok := False\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac t=\"ba\\<lparr>ok := False\\<rparr>\" and s=ba in subst, auto intro: alpha_d.equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (case_tac \"ok ba\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac b=\"ba\" in comp_intro, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>ok := True\\<rparr>)\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac t=\"ba\\<lparr>ok := True\\<rparr>\" and s=ba in subst, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a;\n        \\<not> ((\\<lambda>(A, A'). P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                (\\<lambda>(A, A').\n                    (ok A \\<longrightarrow> ok A') \\<and>\n                    alpha_d.more A = alpha_d.more A'))\n                (a\\<lparr>tr := []\\<rparr>, b\n                 \\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> wait a", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := False\\<rparr>)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a\\<lparr>tr := []\\<rparr>, b\n                           \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac b=\"ba\" in comp_intro, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b; ok a; \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> P (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>ok := False\\<rparr>)", "apply (rule_tac t=\"ba\\<lparr>ok := False\\<rparr>\" and s=ba in subst, auto intro: alpha_d.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP1_is_R1_H1:\n  assumes \"P is R1 healthy\"\n  shows \"CSP1 P = R1 (H1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 P = R1 (H1 P)", "using assms"], ["proof (prove)\nusing this:\n  P is R1 healthy\n\ngoal (1 subgoal):\n 1. CSP1 P = R1 (H1 P)", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits)"], ["", "lemma CSP1_is_R1_H1_2: \"CSP1 (R1 P) = R1 (H1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 (R1 P) = R1 (H1 P)", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits)"], ["", "lemma CSP1_R1_commute: \"CSP1 o R1 = R1 o CSP1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 \\<circ> R1 = R1 \\<circ> CSP1", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits)"], ["", "lemma CSP1_R1_commute2: \"CSP1 (R1 P) = R1 (CSP1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSP1 (R1 P) = R1 (CSP1 P)", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits)"], ["", "lemma CSP1_is_R1_H1_b: \n\"(P = (R \\<circ> R1 \\<circ> H1 \\<circ> H2) P) = (P = (R \\<circ> CSP1 \\<circ> H2) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P = (R \\<circ> R1 \\<circ> H1 \\<circ> H2) P) =\n    (P = (R \\<circ> CSP1 \\<circ> H2) P)", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (R1 (H1 (H2 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst H1_H2_commute2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (R1 (H2 (H1 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst R1_H2_commute2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (H2 (R1 (H1 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst CSP1_is_R1_H1_2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (H2 (CSP1 (R1 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst H2_CSP1_commute2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (CSP1 (H2 (R1 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst R1_H2_commute2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (CSP1 (R1 (H2 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst CSP1_R1_commute2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (R1 (CSP1 (H2 P))) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (subst R_abs_R1[simplified Fun.comp_def fun_eq_iff])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b)) =\n    (\\<forall>a b. P (a, b) = R (CSP1 (H2 P)) (a, b))", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP1_join: \n  assumes A: \"x is CSP1 healthy\"\n  and B: \"y is CSP1 healthy\"\n  shows \"(x \\<sqinter> y) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<or> y is CSP1 healthy", "using A B"], ["proof (prove)\nusing this:\n  x is CSP1 healthy\n  y is CSP1 healthy\n\ngoal (1 subgoal):\n 1. x \\<or> y is CSP1 healthy", "by (simp add: Healthy_def CSP1_def fun_eq_iff utp_defs)"], ["", "lemma CSP2_join:\n  assumes A: \"x is CSP2 healthy\"\n  and B: \"y is CSP2 healthy\"\n  shows \"(x \\<sqinter> y) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<or> y is CSP2 healthy", "using A B"], ["proof (prove)\nusing this:\n  x is CSP2 healthy\n  y is CSP2 healthy\n\ngoal (1 subgoal):\n 1. x \\<or> y is CSP2 healthy", "apply (simp add: design_defs csp_defs fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                x (a, b) =\n                (x ;;\n                 (\\<lambda>(A, A').\n                     (ok A \\<longrightarrow> ok A') \\<and>\n                     tr A = tr A' \\<and>\n                     wait A = wait A' \\<and>\n                     ref A = ref A' \\<and>\n                     alpha_rp.more A = alpha_rp.more A'))\n                 (a, b);\n     \\<forall>a b.\n        y (a, b) =\n        (y ;;\n         (\\<lambda>(A, A').\n             (ok A \\<longrightarrow> ok A') \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n         (a, b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (x \\<or> y) (a, b) =\n                         (x \\<or> y ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a b.\n                   x (a, b) =\n                   (x ;;\n                    (\\<lambda>(A, A').\n                        (ok A \\<longrightarrow> ok A') \\<and>\n                        tr A = tr A' \\<and>\n                        wait A = wait A' \\<and>\n                        ref A = ref A' \\<and>\n                        alpha_rp.more A = alpha_rp.more A'))\n                    (a, b);\n        \\<forall>a b.\n           y (a, b) =\n           (y ;;\n            (\\<lambda>(A, A').\n                (ok A \\<longrightarrow> ok A') \\<and>\n                tr A = tr A' \\<and>\n                wait A = wait A' \\<and>\n                ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n            (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b.\n                            (x \\<or> y) (a, b) =\n                            (x \\<or> y ;;\n                             (\\<lambda>(A, A').\n                                 (ok A \\<longrightarrow> ok A') \\<and>\n                                 tr A = tr A' \\<and>\n                                 wait A = wait A' \\<and>\n                                 ref A = ref A' \\<and>\n                                 alpha_rp.more A = alpha_rp.more A'))\n                             (a, b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   x (a, b) =\n                   (x ;;\n                    (\\<lambda>(A, A').\n                        (ok A \\<longrightarrow> ok A') \\<and>\n                        tr A = tr A' \\<and>\n                        wait A = wait A' \\<and>\n                        ref A = ref A' \\<and>\n                        alpha_rp.more A = alpha_rp.more A'))\n                    (a, b);\n        \\<forall>a b.\n           y (a, b) =\n           (y ;;\n            (\\<lambda>(A, A').\n                (ok A \\<longrightarrow> ok A') \\<and>\n                tr A = tr A' \\<and>\n                wait A = wait A' \\<and>\n                ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n            (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<or> y) (a, b) =\n                         (x \\<or> y ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   y (a, b) =\n                   (y ;;\n                    (\\<lambda>(A, A').\n                        (ok A \\<longrightarrow> ok A') \\<and>\n                        tr A = tr A' \\<and>\n                        wait A = wait A' \\<and>\n                        ref A = ref A' \\<and>\n                        alpha_rp.more A = alpha_rp.more A'))\n                    (a, b);\n        \\<forall>b.\n           x (a, b) =\n           (x ;;\n            (\\<lambda>(A, A').\n                (ok A \\<longrightarrow> ok A') \\<and>\n                tr A = tr A' \\<and>\n                wait A = wait A' \\<and>\n                ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n            (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<or> y) (a, b) =\n                         (x \\<or> y ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>b.\n                   x (a, b) =\n                   (x ;;\n                    (\\<lambda>(A, A').\n                        (ok A \\<longrightarrow> ok A') \\<and>\n                        tr A = tr A' \\<and>\n                        wait A = wait A' \\<and>\n                        ref A = ref A' \\<and>\n                        alpha_rp.more A = alpha_rp.more A'))\n                    (a, b);\n        \\<forall>b.\n           y (a, b) =\n           (y ;;\n            (\\<lambda>(A, A').\n                (ok A \\<longrightarrow> ok A') \\<and>\n                tr A = tr A' \\<and>\n                wait A = wait A' \\<and>\n                ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n            (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<or> y) (a, b) =\n                         (x \\<or> y ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)", "apply (erule_tac x=\"b\" in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x (a, b) =\n                (x ;;\n                 (\\<lambda>(A, A').\n                     (ok A \\<longrightarrow> ok A') \\<and>\n                     tr A = tr A' \\<and>\n                     wait A = wait A' \\<and>\n                     ref A = ref A' \\<and>\n                     alpha_rp.more A = alpha_rp.more A'))\n                 (a, b);\n        y (a, b) =\n        (y ;;\n         (\\<lambda>(A, A').\n             (ok A \\<longrightarrow> ok A') \\<and>\n             tr A = tr A' \\<and>\n             wait A = wait A' \\<and>\n             ref A = ref A' \\<and> alpha_rp.more A = alpha_rp.more A'))\n         (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<or> y) (a, b) =\n                         (x \\<or> y ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              tr A = tr A' \\<and>\n                              wait A = wait A' \\<and>\n                              ref A = ref A' \\<and>\n                              alpha_rp.more A = alpha_rp.more A'))\n                          (a, b)", "by (auto)"], ["", "lemma CSP1_meet:\n  assumes A: \"x is CSP1 healthy\"\n  and B: \"y is CSP1 healthy\"\n  shows \"(x \\<squnion> y) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<and> y is CSP1 healthy", "using A B"], ["proof (prove)\nusing this:\n  x is CSP1 healthy\n  y is CSP1 healthy\n\ngoal (1 subgoal):\n 1. x \\<and> y is CSP1 healthy", "apply (simp add: Healthy_def CSP1_def fun_eq_iff utp_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                x (a, b) =\n                (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n     \\<forall>a b.\n        y (a, b) =\n        (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (x (a, b) \\<and> y (a, b)) =\n                         (x (a, b) \\<and> y (a, b) \\<or>\n                          \\<not> ok a \\<and> tr a \\<le> tr b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>a b.\n                   x (a, b) =\n                   (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n        \\<forall>a b.\n           y (a, b) =\n           (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>b.\n                            (x (a, b) \\<and> y (a, b)) =\n                            (x (a, b) \\<and> y (a, b) \\<or>\n                             \\<not> ok a \\<and> tr a \\<le> tr b)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   x (a, b) =\n                   (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n        \\<forall>a b.\n           y (a, b) =\n           (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n       \\<Longrightarrow> (x (a, b) \\<and> y (a, b)) =\n                         (x (a, b) \\<and> y (a, b) \\<or>\n                          \\<not> ok a \\<and> tr a \\<le> tr b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b.\n                   y (a, b) =\n                   (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n        \\<forall>b.\n           x (a, b) =\n           (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n       \\<Longrightarrow> (x (a, b) \\<and> y (a, b)) =\n                         (x (a, b) \\<and> y (a, b) \\<or>\n                          \\<not> ok a \\<and> tr a \\<le> tr b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>b.\n                   x (a, b) =\n                   (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n        \\<forall>b.\n           y (a, b) =\n           (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n       \\<Longrightarrow> (x (a, b) \\<and> y (a, b)) =\n                         (x (a, b) \\<and> y (a, b) \\<or>\n                          \\<not> ok a \\<and> tr a \\<le> tr b)", "apply (erule_tac x=\"b\" in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x (a, b) =\n                (x (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b);\n        y (a, b) =\n        (y (a, b) \\<or> \\<not> ok a \\<and> tr a \\<le> tr b)\\<rbrakk>\n       \\<Longrightarrow> (x (a, b) \\<and> y (a, b)) =\n                         (x (a, b) \\<and> y (a, b) \\<or>\n                          \\<not> ok a \\<and> tr a \\<le> tr b)", "by (auto)"], ["", "lemma CSP2_meet:\n  assumes A: \"x is CSP2 healthy\"\n  and B: \"y is CSP2 healthy\"\n  shows \"(x \\<squnion> y) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<and> y is CSP2 healthy", "using A B"], ["proof (prove)\nusing this:\n  x is CSP2 healthy\n  y is CSP2 healthy\n\ngoal (1 subgoal):\n 1. x \\<and> y is CSP2 healthy", "apply (simp add: Healthy_def CSP2_def fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b. x (a, b) = (x ;; J_csp) (a, b);\n     \\<forall>a b. y (a, b) = (y ;; J_csp) (a, b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (x \\<and> y) (a, b) = (x \\<and> y ;; J_csp) (a, b)", "apply (rule allI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b. x (a, b) = (x ;; J_csp) (a, b);\n        \\<forall>a b. y (a, b) = (y ;; J_csp) (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y) (a, b) = (x \\<and> y ;; J_csp) (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>a b. y (a, b) = (y ;; J_csp) (a, b);\n        \\<forall>b. x (a, b) = (x ;; J_csp) (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y) (a, b) = (x \\<and> y ;; J_csp) (a, b)", "apply (erule_tac x=\"a\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>b. x (a, b) = (x ;; J_csp) (a, b);\n        \\<forall>b. y (a, b) = (y ;; J_csp) (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y) (a, b) = (x \\<and> y ;; J_csp) (a, b)", "apply (erule_tac x=\"b\" in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x (a, b) = (x ;; J_csp) (a, b);\n        y (a, b) = (y ;; J_csp) (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y) (a, b) = (x \\<and> y ;; J_csp) (a, b)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba ab bb ca.\n       \\<lbrakk>x (ab, ba); J_csp (ba, ca); y (ab, bb); J_csp (bb, ca);\n        x (ab, ca); y (ab, ca)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y ;; J_csp) (ab, ca)", "apply (rule_tac b=\"ca\" in comp_intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ba ab bb ca.\n       \\<lbrakk>x (ab, ba); J_csp (ba, ca); y (ab, bb); J_csp (bb, ca);\n        x (ab, ca); y (ab, ca)\\<rbrakk>\n       \\<Longrightarrow> (x \\<and> y) (ab, ca)\n 2. \\<And>ba ab bb ca.\n       \\<lbrakk>x (ab, ba); J_csp (ba, ca); y (ab, bb); J_csp (bb, ca);\n        x (ab, ca); y (ab, ca)\\<rbrakk>\n       \\<Longrightarrow> J_csp (ca, ca)", "apply (auto simp: J_csp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP_join: \n  assumes A: \"is_CSP_process x\"\n  and B: \"is_CSP_process y\"\n  shows \"is_CSP_process (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (x \\<or> y)", "using A B"], ["proof (prove)\nusing this:\n  is_CSP_process x\n  is_CSP_process y\n\ngoal (1 subgoal):\n 1. is_CSP_process (x \\<or> y)", "by (simp add: is_CSP_process_def CSP1_join CSP2_join R_join)"], ["", "lemma CSP_meet:\n  assumes A: \"is_CSP_process x\"\n  and B: \"is_CSP_process y\"\n  shows \"is_CSP_process (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (x \\<and> y)", "using A B"], ["proof (prove)\nusing this:\n  is_CSP_process x\n  is_CSP_process y\n\ngoal (1 subgoal):\n 1. is_CSP_process (x \\<and> y)", "by (simp add: is_CSP_process_def CSP1_meet CSP2_meet R_meet)"], ["", "subsection \\<open>CSP processes and reactive designs\\<close>"], ["", "text \\<open>In this section, we prove the relation between CSP processes and reactive designs.\\<close>"], ["", "lemma rd_is_CSP1: \"(R (r \\<turnstile> p)) is CSP1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (r \\<turnstile> p) is CSP1 healthy", "by (auto simp: csp_defs design_defs rp_defs fun_eq_iff split: cond_splits elim: prefixE)"], ["", "lemma rd_is_CSP2:\n  assumes A: \"\\<forall> a b. r (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow> r (a, b\\<lparr>ok := False\\<rparr>)\"\n  shows \"(R (r \\<turnstile> p)) is CSP2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (r \\<turnstile> p) is CSP2 healthy", "apply (subst CSP2_is_H2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (r \\<turnstile> p) is H2 healthy", "apply (simp add: Healthy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (r \\<turnstile> p) = H2 (R (r \\<turnstile> p))", "apply (subst R_H2_commute2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (r \\<turnstile> p) = R (H2 (r \\<turnstile> p))", "apply (subst design_H2[simplified Healthy_def], auto simp: A)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rd_is_CSP:\n  assumes A: \"\\<forall> a b. r (a, b\\<lparr>ok := True\\<rparr>) \\<longrightarrow> r (a, b\\<lparr>ok := False\\<rparr>)\"\n  shows \"is_CSP_process (R (r \\<turnstile> p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_CSP_process (R (r \\<turnstile> p))", "apply (simp add: is_CSP_process_def Healthy_def fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) =\n        CSP1 (R (r \\<turnstile> p)) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) =\n        CSP2 (R (r \\<turnstile> p)) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) = R (R (r \\<turnstile> p)) (a, b))", "apply (subst R_idem2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) =\n        CSP1 (R (r \\<turnstile> p)) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) =\n        CSP2 (R (r \\<turnstile> p)) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) = R (r \\<turnstile> p) (a, b))", "apply (subst rd_is_CSP2[simplified Healthy_def, symmetric], rule A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) =\n        CSP1 (R (r \\<turnstile> p)) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) = R (r \\<turnstile> p) (a, b)) \\<and>\n    (\\<forall>a b.\n        R (r \\<turnstile> p) (a, b) = R (r \\<turnstile> p) (a, b))", "apply (subst rd_is_CSP1[simplified Healthy_def, symmetric], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CSP_is_rd:\n  assumes A: \"is_CSP_process P\"\n  shows \"P = (R (\\<not>(P \\<^sup>f\\<^sub>f) \\<turnstile> (P \\<^sup>t\\<^sub>f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R (\\<not> P\\<^sup>f\\<^sub>f \\<turnstile> P\\<^sup>t\\<^sub>f)", "apply (subst rd_ind_wait)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    R (\\<not> (\\<lambda>(A, A').\n                  P (A, A'\n                     \\<lparr>ok :=\n                               False\\<rparr>)) \\<turnstile> \\<lambda>(A,\n                         A'). P (A, A'\\<lparr>ok := True\\<rparr>))", "apply (subst rd_H1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    R (\\<not> H1 (\\<lambda>(A, A').\n                     P (A, A'\n                        \\<lparr>ok :=\n                                  False\\<rparr>)) \\<turnstile> H1\n                          (\\<lambda>(A, A').\n                              P (A, A'\\<lparr>ok := True\\<rparr>)))", "apply (subst rd_H1_H2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    R (\\<not> (H1 \\<circ> H2)\n               (\\<lambda>(A, A').\n                   P (A, A'\n                      \\<lparr>ok :=\n                                False\\<rparr>)) \\<turnstile> (H1 \\<circ> H2)\n                        (\\<lambda>(A, A').\n                            P (A, A'\\<lparr>ok := True\\<rparr>)))", "apply (subst rd_H1_H2_R_H1_H2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (R \\<circ> H1 \\<circ> H2) P", "apply (subst R_abs_R1[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (R \\<circ> R1 \\<circ> H1 \\<circ> H2) P", "apply (subst CSP1_is_R1_H1_b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (R \\<circ> CSP1 \\<circ> H2) P", "apply (subst CSP2_is_H2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (R \\<circ> CSP1 \\<circ> CSP2) P", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R (CSP1 (CSP2 P))", "apply (subst CSP_is_CSP2[OF A, simplified Healthy_def, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R (CSP1 P)", "apply (subst CSP_is_CSP1[OF A, simplified Healthy_def, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R P", "apply (subst CSP_is_R[OF A, simplified Healthy_def, symmetric], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}