{"file_name": "/home/qj213/afp-2021-10-22/thys/Circus/Reactive_Processes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Circus", "problem_names": ["lemma list_diff_empty [simp]: \"the (list_diff l []) = l\"", "lemma prefix_diff_empty [simp]: \"l  - [] = l\"", "lemma prefix_diff_eq [simp]: \"l - l = []\"", "lemma prefix_diff [simp]: \"(l @ t) - l = t\"", "lemma prefix_subst [simp]: \"l @ t = m \\<Longrightarrow> m - l = t\"", "lemma prefix_subst1 [simp]: \"m = l @ t \\<Longrightarrow> m - l = t\"", "lemma prefix_diff1 [simp]: \"((l @ m) @ t) - (l @ m) = t\"", "lemma prefix_diff2 [simp]: \"(l @ (m @ t)) - (l @ m) = t\"", "lemma prefix_diff3 [simp]: \"(l @ m) - (l @ t) = (m - t)\"", "lemma prefix_diff4 [simp]: \"(a # m) - (a # t) = (m - t)\"", "lemma in_imp_not_fcs:\n\"x\\<in>S \\<Longrightarrow> \\<not> filter_chan_set x S\"", "lemma tr_filter_conc: \"(tr_filter (a@b) cs) = ((tr_filter a cs) @ (tr_filter b cs))\"", "lemma filter_chan_set_hd_tr_filter:\n\"tr_filter l cs \\<noteq> [] --> filter_chan_set (hd (tr_filter l cs)) cs\"", "lemma tr_filter_conc_eq1: \n\"(a@b = (tr_filter (a@c) cs)) \\<longrightarrow> (b = (tr_filter c cs))\"", "lemma tr_filter_conc_eq2: \n\"(a@b = (tr_filter (a@c) cs)) \\<longrightarrow> (a = (tr_filter a cs))\"", "lemma tr_filter_conc_eq:\n\"(a@b = (tr_filter (a@c) cs)) = (b = (tr_filter c cs) & a = (tr_filter a cs))\"", "lemma tr_filter_conc_eq3:\n\"(b = (tr_filter (a@c) cs)) = (\\<exists> b1 b2. b=b1@b2 & b2 = (tr_filter c cs) & b1 = (tr_filter a cs))\"", "lemma tr_filter_un:\n\"tr_filter l (s1 \\<union> s2) = tr_filter (tr_filter l s1) s2\"", "lemma list_diff_empty_eq: \"l1 - l2 = [] \\<Longrightarrow> l2 \\<le> l1 \\<Longrightarrow> l1 = l2\"", "lemmas rp_defs = R1_def R2_def \\<Pi>rea_def R3_def R_def spec_def", "lemma tr_filter_empty [simp]: \"tr_filter l {} = l\"", "lemma trf_imp_filtercs: \"\\<lbrakk>xs = tr_filter ys cs; xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> filter_chan_set (hd xs) cs\"", "lemma filtercs_imp_trf: \n\"\\<lbrakk>filter_chan_set x cs; xs = tr_filter ys cs\\<rbrakk> \\<Longrightarrow> x#xs = tr_filter (x#ys) cs\"", "lemma alpha_d_more_eqI:\n  assumes \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\"\n  shows \"alpha_d.more r = alpha_d.more r'\"", "lemma alpha_d_more_eqE:\n  assumes \"alpha_d.more r = alpha_d.more r'\"\n  obtains \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\"", "lemma alpha_rp_eqE:\n  assumes \"r = r'\"\n  obtains \"ok r = ok r'\" \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\"", "lemma R_idem: \"R o R = R\"", "lemma R_idem2: \"R (R P) = R P\"", "lemma R1_idem: \"R1 o R1 = R1\"", "lemma R1_idem2: \"R1 (R1 x) = R1 x\"", "lemma R2_idem: \"R2 o R2 = R2\"", "lemma R2_idem2: \"R2 (R2 x) = R2 x\"", "lemma R3_idem: \"R3 o R3 = R3\"", "lemma R3_idem2: \"R3 (R3 x) = R3 x\"", "lemma R1_R2_commute: \"(R1 o R2) = (R2 o R1)\"", "lemma R1_R3_commute: \"(R1 o R3) = (R3 o R1)\"", "lemma R2_R3_commute: \"R2 o R3 = R3 o R2\"", "lemma R_abs_R1: \"R o R1 = R\"", "lemma R_abs_R2: \"R o R2 = R\"", "lemma R_abs_R3: \"R o R3 = R\"", "lemma R_is_R1:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R1 healthy\"", "lemma R_is_R2:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R2 healthy\"", "lemma R_is_R3:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R3 healthy\"", "lemma R_disj:\n  assumes A: \"P is R healthy\"\n  assumes B: \"Q is R healthy\"\n  shows  \"(P \\<or> Q) is R healthy\"", "lemma R_disj2:  \"R (P \\<or> Q) = (R P \\<or> R Q)\"", "lemma R1_comp:\n  assumes \"P is R1 healthy\"\n    and \"Q is R1 healthy\"\n  shows \"(P;;Q) is R1 healthy\"", "lemma R1_comp2:\n  assumes A: \"P is R1 healthy\"\n  assumes B: \"Q is R1 healthy\"\n  shows  \"R1 (P;;Q) = ((R1 P);;Q)\"", "lemma J_is_R1: \"J is R1 healthy\"", "lemma J_is_R2: \"J is R2 healthy\"", "lemma R1_H2_commute2: \"R1 (H2 P) = H2 (R1 P)\"", "lemma R1_H2_commute: \"R1 o H2 = H2 o R1\"", "lemma R2_H2_commute2: \"R2 (H2 P) = H2 (R2 P)\"", "lemma R2_H2_commute: \"R2 o H2 = H2 o R2\"", "lemma R3_H2_commute2: \"R3 (H2 P) = H2 (R3 P)\"", "lemma R3_H2_commute: \"R3 o H2 = H2 o R3\"", "lemma R_join: \n  assumes \"x is R healthy\"\n  and \"y is R healthy\"\n  shows \"(x \\<sqinter> y) is R healthy\"", "lemma R_meet:\n  assumes A: \"x is R healthy\"\n  and B:\"y is R healthy\"\n  shows \"(x \\<squnion> y) is R healthy\"", "lemma R_H2_commute: \"R o H2 = H2 o R\"", "lemma R_H2_commute2: \"R (H2 P) = H2 (R P)\""], "translations": [["", "lemma list_diff_empty [simp]: \"the (list_diff l []) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (list_diff l []) = l", "by (cases l) auto"], ["", "lemma prefix_diff_empty [simp]: \"l  - [] = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l - [] = l", "by (induct l) (auto simp: list_minus)"], ["", "lemma prefix_diff_eq [simp]: \"l - l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l - l = []", "by (induct l) (auto simp: list_minus)"], ["", "lemma prefix_diff [simp]: \"(l @ t) - l = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l @ t - l = t", "by (induct l) (auto simp: list_minus)"], ["", "lemma prefix_subst [simp]: \"l @ t = m \\<Longrightarrow> m - l = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l @ t = m \\<Longrightarrow> m - l = t", "by (auto)"], ["", "lemma prefix_subst1 [simp]: \"m = l @ t \\<Longrightarrow> m - l = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = l @ t \\<Longrightarrow> m - l = t", "by (auto)"], ["", "lemma prefix_diff1 [simp]: \"((l @ m) @ t) - (l @ m) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l @ m) @ t - (l @ m) = t", "by (rule prefix_diff)"], ["", "lemma prefix_diff2 [simp]: \"(l @ (m @ t)) - (l @ m) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l @ m @ t - (l @ m) = t", "apply (simp only: append_assoc [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l @ m) @ t - (l @ m) = t", "apply (rule prefix_diff1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prefix_diff3 [simp]: \"(l @ m) - (l @ t) = (m - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l @ m - (l @ t) = m - t", "by (induct l, auto simp: list_minus)"], ["", "lemma prefix_diff4 [simp]: \"(a # m) - (a # t) = (m - t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # m - (a # t) = m - t", "by (auto simp: list_minus)"], ["", "class ev_eq = \n  fixes ev_eq :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes refl: \"ev_eq a a\"\n  assumes comm: \"ev_eq a b = ev_eq b a\""], ["", "definition \"filter_chan_set a cs = (\\<not> (\\<exists> e\\<in>cs. ev_eq a e))\""], ["", "lemma in_imp_not_fcs:\n\"x\\<in>S \\<Longrightarrow> \\<not> filter_chan_set x S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> \\<not> filter_chan_set x S", "apply (auto simp: filter_chan_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> \\<exists>xa\\<in>S. ev_eq x xa", "apply (rule_tac bexI, auto simp: refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun tr_filter::\"'a::ev_eq list \\<Rightarrow> 'a set \\<Rightarrow> 'a list\" where\n    \"tr_filter [] cs = []\"\n  | \"tr_filter (x#xs) cs = (if (filter_chan_set x cs) then (x#(tr_filter xs cs))\n                                                                  else (tr_filter xs cs))\""], ["", "lemma tr_filter_conc: \"(tr_filter (a@b) cs) = ((tr_filter a cs) @ (tr_filter b cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_filter (a @ b) cs = tr_filter a cs @ tr_filter b cs", "by (induct a, auto)"], ["", "lemma filter_chan_set_hd_tr_filter:\n\"tr_filter l cs \\<noteq> [] --> filter_chan_set (hd (tr_filter l cs)) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_filter l cs \\<noteq> [] \\<longrightarrow>\n    filter_chan_set (hd (tr_filter l cs)) cs", "by (induct l, auto)"], ["", "lemma tr_filter_conc_eq1: \n\"(a@b = (tr_filter (a@c) cs)) \\<longrightarrow> (b = (tr_filter c cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ b = tr_filter (a @ c) cs \\<longrightarrow> b = tr_filter c cs", "apply (induct a, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs\\<rbrakk>\n       \\<Longrightarrow> b = tr_filter c cs", "apply (case_tac \"tr_filter (a2 @ c) cs = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs;\n        tr_filter (a2 @ c) cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> b = tr_filter c cs", "apply (drule filter_chan_set_hd_tr_filter[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs;\n        filter_chan_set (hd (tr_filter (a2 @ c) cs)) cs\\<rbrakk>\n       \\<Longrightarrow> b = tr_filter c cs", "apply (case_tac \"tr_filter (a2 @ c) cs\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tr_filter_conc_eq2: \n\"(a@b = (tr_filter (a@c) cs)) \\<longrightarrow> (a = (tr_filter a cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a @ b = tr_filter (a @ c) cs \\<longrightarrow> a = tr_filter a cs", "apply (induct a, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = tr_filter a2 cs\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"tr_filter (a2 @ c) cs = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs;\n        tr_filter (a2 @ c) cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = tr_filter a2 cs\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule filter_chan_set_hd_tr_filter[rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs;\n        a2 @ b \\<noteq> tr_filter (a2 @ c) cs;\n        filter_chan_set (hd (tr_filter (a2 @ c) cs)) cs\\<rbrakk>\n       \\<Longrightarrow> a1 # a2 = tr_filter a2 cs\n 2. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"tr_filter (a2 @ c) cs\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"tr_filter (a2 @ c) cs = []\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs;\n        tr_filter (a2 @ c) cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule filter_chan_set_hd_tr_filter[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>\\<not> filter_chan_set a1 cs;\n        a1 # a2 @ b = tr_filter (a2 @ c) cs; a2 = tr_filter a2 cs;\n        filter_chan_set (hd (tr_filter (a2 @ c) cs)) cs\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"tr_filter (a2 @ c) cs\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tr_filter_conc_eq:\n\"(a@b = (tr_filter (a@c) cs)) = (b = (tr_filter c cs) & a = (tr_filter a cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a @ b = tr_filter (a @ c) cs) =\n    (b = tr_filter c cs \\<and> a = tr_filter a cs)", "apply (rule, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. a @ b = tr_filter (a @ c) cs \\<Longrightarrow> b = tr_filter c cs\n 2. a @ b = tr_filter (a @ c) cs \\<Longrightarrow> a = tr_filter a cs\n 3. b = tr_filter c cs \\<and> a = tr_filter a cs \\<Longrightarrow>\n    a @ b = tr_filter (a @ c) cs", "apply (rule tr_filter_conc_eq1[rule_format, of a], clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a @ b = tr_filter (a @ c) cs \\<Longrightarrow> a = tr_filter a cs\n 2. b = tr_filter c cs \\<and> a = tr_filter a cs \\<Longrightarrow>\n    a @ b = tr_filter (a @ c) cs", "apply (rule tr_filter_conc_eq2[rule_format, of a b c], clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b = tr_filter c cs \\<and> a = tr_filter a cs \\<Longrightarrow>\n    a @ b = tr_filter (a @ c) cs", "apply (clarsimp simp: tr_filter_conc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tr_filter_conc_eq3:\n\"(b = (tr_filter (a@c) cs)) = (\\<exists> b1 b2. b=b1@b2 & b2 = (tr_filter c cs) & b1 = (tr_filter a cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b = tr_filter (a @ c) cs) =\n    (\\<exists>b1 b2.\n        b = b1 @ b2 \\<and> b2 = tr_filter c cs \\<and> b1 = tr_filter a cs)", "by (rule, auto simp: tr_filter_conc)"], ["", "lemma tr_filter_un:\n\"tr_filter l (s1 \\<union> s2) = tr_filter (tr_filter l s1) s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_filter l (s1 \\<union> s2) = tr_filter (tr_filter l s1) s2", "by (induct l, auto simp: filter_chan_set_def)"], ["", "instantiation list :: (ev_eq) ev_eq\nbegin"], ["", "fun ev_eq_list where\n    \"ev_eq_list [] [] = True\"\n  | \"ev_eq_list l [] = False\"\n  | \"ev_eq_list [] l = False\"\n  | \"ev_eq_list (x#xs) (y#ys) = (if (ev_eq x y) then (ev_eq_list xs ys) else False)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, ev_eq_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. ev_eq a a\n 2. \\<And>a b. ev_eq a b = ev_eq b a", "fix a::\"'a::ev_eq list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. ev_eq a a\n 2. \\<And>a b. ev_eq a b = ev_eq b a", "show \"ev_eq a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev_eq a a", "by (induct a, auto simp: ev_eq_class.refl)"], ["proof (state)\nthis:\n  ev_eq a a\n\ngoal (1 subgoal):\n 1. \\<And>a b. ev_eq a b = ev_eq b a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. ev_eq a b = ev_eq b a", "fix a b::\"'a::ev_eq list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. ev_eq a b = ev_eq b a", "show \"ev_eq a b = ev_eq b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev_eq a b = ev_eq b a", "apply (cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = [] \\<Longrightarrow> ev_eq a b = ev_eq b a\n 2. \\<And>aa list. a = aa # list \\<Longrightarrow> ev_eq a b = ev_eq b a", "apply (cases b, simp_all add: ev_eq_class.comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       a = aa # list \\<Longrightarrow>\n       ev_eq (aa # list) b = ev_eq b (aa # list)", "apply (hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list. ev_eq (a # list) b = ev_eq b (a # list)", "apply (induct b, simp_all add: ev_eq_class.comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       (\\<And>a list.\n           ev_eq (a # list) b = ev_eq b (a # list)) \\<Longrightarrow>\n       ev_eq a aa \\<longrightarrow> ev_eq list b = ev_eq b list", "apply (case_tac \"ev_eq aa a\", simp_all add: ev_eq_class.comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>\\<And>a list. ev_eq (a # list) b = ev_eq b (a # list);\n        ev_eq a aa\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (case_tac \"list = []\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa list.\n       \\<lbrakk>\\<And>a list. ev_eq (a # list) b = ev_eq b (a # list);\n        ev_eq a aa; list = []\\<rbrakk>\n       \\<Longrightarrow> ev_eq [] b = ev_eq b []\n 2. \\<And>a b aa list.\n       \\<lbrakk>\\<And>a list. ev_eq (a # list) b = ev_eq b (a # list);\n        ev_eq a aa; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (case_tac \"b\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>\\<And>a list. ev_eq (a # list) b = ev_eq b (a # list);\n        ev_eq a aa; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (atomize)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>\\<forall>a list. ev_eq (a # list) b = ev_eq b (a # list);\n        ev_eq a aa; list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (erule_tac x=\"hd list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>ev_eq a aa; list \\<noteq> [];\n        \\<forall>lista.\n           ev_eq (hd list # lista) b = ev_eq b (hd list # lista)\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (erule_tac x=\"tl list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>ev_eq a aa; list \\<noteq> [];\n        ev_eq (hd list # tl list) b = ev_eq b (hd list # tl list)\\<rbrakk>\n       \\<Longrightarrow> ev_eq list b = ev_eq b list", "apply (subst (asm) hd_Cons_tl, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ev_eq a b = ev_eq b a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Definitions\\<close>"], ["", "(* isabelle 2013 *)"], ["", "abbreviation subl::\"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" (\"_ \\<le> _\") \nwhere \"l1 \\<le> l2 == Sublist.prefix l1 l2\""], ["", "lemma list_diff_empty_eq: \"l1 - l2 = [] \\<Longrightarrow> l2 \\<le> l1 \\<Longrightarrow> l1 = l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l1 - l2 = []; l2 \\<le> l1\\<rbrakk> \\<Longrightarrow> l1 = l2", "by (auto simp: prefix_def)"], ["", "(* end isabelle 2013 *)"], ["", "text \\<open>The definitions of reactive process alphabets and healthiness conditions are given\nin the following. The healthiness conditions of reactive processes are defined by \n$R1$, $R2$, $R3$ and their composition $R$.\\<close>"], ["", "type_synonym '\\<theta> refusal = \"'\\<theta> set\""], ["", "record '\\<theta> alpha_rp  = alpha_d + \n                         wait:: bool\n                         tr  :: \"'\\<theta> trace\"\n                         ref :: \"'\\<theta> refusal\""], ["", "text\\<open>Note that we define here the class of UTP alphabets that contain\n$wait$, $tr$ and $ref$, or, in other words, we define here the class of reactive process\nalphabets.\\<close>"], ["", "type_synonym ('\\<theta>,'\\<sigma>) alphabet_rp  = \"('\\<theta>,'\\<sigma>) alpha_rp_scheme alphabet\""], ["", "type_synonym ('\\<theta>,'\\<sigma>) relation_rp  = \"('\\<theta>,'\\<sigma>) alphabet_rp relation\""], ["", "definition \"diff_tr s1 s2 = ((tr s1) - (tr s2))\""], ["", "definition spec :: \"[bool, bool, ('\\<theta>,'\\<sigma>) relation_rp] \\<Rightarrow> ('\\<theta>,'\\<sigma>) relation_rp\"\nwhere \"spec b b' P \\<equiv> \\<lambda> (A, A'). P (A\\<lparr>wait := b'\\<rparr>, A'\\<lparr>ok := b\\<rparr>)\""], ["", "abbreviation Speciftt (\"_\\<^sup>t\\<^sub>t\") where \"(P)\\<^sup>t\\<^sub>t \\<equiv> spec True True P\""], ["", "abbreviation Specifff (\"_\\<^sup>f\\<^sub>f\") where \"(P)\\<^sup>f\\<^sub>f \\<equiv> spec False False P\""], ["", "abbreviation Speciftf (\"_\\<^sup>t\\<^sub>f\") where \"(P)\\<^sup>t\\<^sub>f \\<equiv> spec True False P\""], ["", "abbreviation Specifft (\"_\\<^sup>f\\<^sub>t\") where \"(P)\\<^sup>f\\<^sub>t \\<equiv> spec False True P\""], ["", "definition R1::\"(('\\<theta>,'\\<sigma>) alphabet_rp) Healthiness_condition\"\nwhere \"R1 (P)  \\<equiv>  \\<lambda>(A, A'). (P (A, A')) \\<and> (tr A \\<le> tr A')\""], ["", "definition R2::\"(('\\<theta>,'\\<sigma>) alphabet_rp) Healthiness_condition\"\nwhere \"R2 (P)  \\<equiv> \\<lambda>(A, A'). (P (A\\<lparr>tr:=[]\\<rparr>,A'\\<lparr>tr:= tr A' - tr A\\<rparr>) \\<and> tr A \\<le> tr A')\""], ["", "definition \\<Pi>rea   \nwhere \"\\<Pi>rea  \\<equiv> \\<lambda>(A, A'). (\\<not>ok A \\<and> tr A \\<le> tr A') \\<or> (ok A' \\<and> tr A = tr A' \n                            \\<and> (wait A = wait A') \\<and> ref A = ref A' \\<and> more A = more A')\""], ["", "definition R3::\"(('\\<theta>,'\\<sigma>) alphabet_rp) Healthiness_condition\"\nwhere \"R3 (P)  \\<equiv> (\\<Pi>rea \\<triangleleft> wait o fst \\<triangleright> P)\""], ["", "definition R::\"(('\\<theta>,'\\<sigma>) alphabet_rp) Healthiness_condition\" \nwhere \"R  \\<equiv> R3 o R2 o R1\""], ["", "lemmas rp_defs = R1_def R2_def \\<Pi>rea_def R3_def R_def spec_def"], ["", "subsection \\<open>Proofs\\<close>"], ["", "lemma tr_filter_empty [simp]: \"tr_filter l {} = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tr_filter l {} = l", "by (induct l) (auto simp: filter_chan_set_def)"], ["", "lemma trf_imp_filtercs: \"\\<lbrakk>xs = tr_filter ys cs; xs \\<noteq> []\\<rbrakk> \\<Longrightarrow> filter_chan_set (hd xs) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = tr_filter ys cs; xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> filter_chan_set (hd xs) cs", "apply (induct xs, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>xs = tr_filter ys cs \\<Longrightarrow>\n                filter_chan_set (hd (tr_filter ys cs)) cs;\n        a # xs = tr_filter ys cs; tr_filter ys cs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> filter_chan_set (hd (tr_filter ys cs)) cs", "apply (induct ys, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys aa xs.\n       \\<lbrakk>\\<And>a xs.\n                   \\<lbrakk>xs = tr_filter ys cs \\<Longrightarrow>\n                            filter_chan_set (hd (tr_filter ys cs)) cs;\n                    a # xs = tr_filter ys cs\\<rbrakk>\n                   \\<Longrightarrow> filter_chan_set (hd (tr_filter ys cs))\ncs;\n        xs = tr_filter ys cs \\<Longrightarrow>\n        filter_chan_set (hd (tr_filter ys cs)) cs;\n        aa # xs = tr_filter ys cs; tr_filter ys cs \\<noteq> [];\n        \\<not> filter_chan_set a cs\\<rbrakk>\n       \\<Longrightarrow> filter_chan_set (hd (tr_filter ys cs)) cs", "apply (case_tac \"filter_chan_set a cs\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma filtercs_imp_trf: \n\"\\<lbrakk>filter_chan_set x cs; xs = tr_filter ys cs\\<rbrakk> \\<Longrightarrow> x#xs = tr_filter (x#ys) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>filter_chan_set x cs; xs = tr_filter ys cs\\<rbrakk>\n    \\<Longrightarrow> x # xs = tr_filter (x # ys) cs", "by (induct xs) auto"], ["", "lemma alpha_d_more_eqI:\n  assumes \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\"\n  shows \"alpha_d.more r = alpha_d.more r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alpha_d.more r = alpha_d.more r'", "using assms"], ["proof (prove)\nusing this:\n  tr r = tr r'\n  wait r = wait r'\n  ref r = ref r'\n  alpha_rp.more r = alpha_rp.more r'\n\ngoal (1 subgoal):\n 1. alpha_d.more r = alpha_d.more r'", "by (cases r, cases r') auto"], ["", "lemma alpha_d_more_eqE:\n  assumes \"alpha_d.more r = alpha_d.more r'\"\n  obtains \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>tr r = tr r'; wait r = wait r'; ref r = ref r';\n      alpha_rp.more r = alpha_rp.more r'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  alpha_d.more r = alpha_d.more r'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>tr r = tr r'; wait r = wait r'; ref r = ref r';\n      alpha_rp.more r = alpha_rp.more r'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r, cases r') auto"], ["", "lemma alpha_rp_eqE:\n  assumes \"r = r'\"\n  obtains \"ok r = ok r'\" \"tr r = tr r'\" \"wait r = wait r'\" \"ref r = ref r'\" \"more r = more r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>ok r = ok r'; tr r = tr r'; wait r = wait r'; ref r = ref r';\n      alpha_rp.more r = alpha_rp.more r'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  r = r'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>ok r = ok r'; tr r = tr r'; wait r = wait r'; ref r = ref r';\n      alpha_rp.more r = alpha_rp.more r'\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r, cases r') auto"], ["", "lemma R_idem: \"R o R = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ> R = R", "by (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["", "lemma R_idem2: \"R (R P) = R P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (R P) = R P", "by (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["", "lemma R1_idem: \"R1 o R1 = R1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 \\<circ> R1 = R1", "by (auto simp: rp_defs design_defs)"], ["", "lemma R1_idem2: \"R1 (R1 x) = R1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 (R1 x) = R1 x", "by (auto simp: rp_defs design_defs)"], ["", "lemma R2_idem: \"R2 o R2 = R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 \\<circ> R2 = R2", "by (auto simp: rp_defs design_defs fun_eq_iff prefix_def)"], ["", "lemma R2_idem2: \"R2 (R2 x) = R2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 (R2 x) = R2 x", "by (auto simp: rp_defs design_defs fun_eq_iff prefix_def)"], ["", "lemma R3_idem: \"R3 o R3 = R3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 \\<circ> R3 = R3", "by (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["", "lemma R3_idem2: \"R3 (R3 x) = R3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 (R3 x) = R3 x", "by (auto simp: R3_idem[simplified Fun.comp_def fun_eq_iff] fun_eq_iff)"], ["", "lemma R1_R2_commute: \"(R1 o R2) = (R2 o R1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 \\<circ> R2 = R2 \\<circ> R1", "by (auto simp: rp_defs design_defs fun_eq_iff prefix_def)"], ["", "lemma R1_R3_commute: \"(R1 o R3) = (R3 o R1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 \\<circ> R3 = R3 \\<circ> R1", "by (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["", "lemma R2_R3_commute: \"R2 o R3 = R3 o R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 \\<circ> R3 = R3 \\<circ> R2", "by (auto simp: rp_defs design_defs fun_eq_iff prefix_def split: cond_splits)"], ["", "lemma R_abs_R1: \"R o R1 = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ> R1 = R", "apply (auto simp: R_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 \\<circ> R2 \\<circ> R1 \\<circ> R1 = R3 \\<circ> R2 \\<circ> R1", "apply (subst (3) R1_idem[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 \\<circ> R2 \\<circ> R1 \\<circ> R1 =\n    R3 \\<circ> R2 \\<circ> (R1 \\<circ> R1)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R_abs_R2: \"R o R2 = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ> R2 = R", "by (auto simp: rp_defs design_defs fun_eq_iff)"], ["", "lemma R_abs_R3: \"R o R3 = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ> R3 = R", "by (auto simp: rp_defs design_defs fun_eq_iff split: cond_splits)"], ["", "lemma R_is_R1:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is R1 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P is R1 healthy", "have \"R P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P = P", "using assms"], ["proof (prove)\nusing this:\n  P is R healthy\n\ngoal (1 subgoal):\n 1. R P = P", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R1 healthy", "moreover"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R1 healthy", "have \"(R P) is R1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P is R1 healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R P is R1 healthy\n\ngoal (1 subgoal):\n 1. P is R1 healthy", "ultimately"], ["proof (chain)\npicking this:\n  R P = P\n  R P is R1 healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R P = P\n  R P is R1 healthy\n\ngoal (1 subgoal):\n 1. P is R1 healthy", "by simp"], ["proof (state)\nthis:\n  P is R1 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_is_R2:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is R2 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P is R2 healthy", "have \"R P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P = P", "using assms"], ["proof (prove)\nusing this:\n  P is R healthy\n\ngoal (1 subgoal):\n 1. R P = P", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R2 healthy", "moreover"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R2 healthy", "have \"(R P) is R2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P is R2 healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff prefix_def split: cond_splits)"], ["proof (state)\nthis:\n  R P is R2 healthy\n\ngoal (1 subgoal):\n 1. P is R2 healthy", "ultimately"], ["proof (chain)\npicking this:\n  R P = P\n  R P is R2 healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R P = P\n  R P is R2 healthy\n\ngoal (1 subgoal):\n 1. P is R2 healthy", "by simp"], ["proof (state)\nthis:\n  P is R2 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_is_R3:\n  assumes A: \"P is R healthy\"\n  shows  \"P is R3 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P is R3 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P is R3 healthy", "have \"R P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P = P", "using assms"], ["proof (prove)\nusing this:\n  P is R healthy\n\ngoal (1 subgoal):\n 1. R P = P", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R3 healthy", "moreover"], ["proof (state)\nthis:\n  R P = P\n\ngoal (1 subgoal):\n 1. P is R3 healthy", "have \"(R P) is R3 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P is R3 healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R P is R3 healthy\n\ngoal (1 subgoal):\n 1. P is R3 healthy", "ultimately"], ["proof (chain)\npicking this:\n  R P = P\n  R P is R3 healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R P = P\n  R P is R3 healthy\n\ngoal (1 subgoal):\n 1. P is R3 healthy", "by simp"], ["proof (state)\nthis:\n  P is R3 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_disj:\n  assumes A: \"P is R healthy\"\n  assumes B: \"Q is R healthy\"\n  shows  \"(P \\<or> Q) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "have \"R P = P\" and \"R Q = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P = P &&& R Q = Q", "using assms"], ["proof (prove)\nusing this:\n  P is R healthy\n  Q is R healthy\n\ngoal (1 subgoal):\n 1. R P = P &&& R Q = Q", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R P = P\n  R Q = Q\n\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "moreover"], ["proof (state)\nthis:\n  R P = P\n  R Q = Q\n\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "have \"((R P) \\<or> (R Q)) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R P \\<or> R Q is R healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R P \\<or> R Q is R healthy\n\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "ultimately"], ["proof (chain)\npicking this:\n  R P = P\n  R Q = Q\n  R P \\<or> R Q is R healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R P = P\n  R Q = Q\n  R P \\<or> R Q is R healthy\n\ngoal (1 subgoal):\n 1. P \\<or> Q is R healthy", "by simp"], ["proof (state)\nthis:\n  P \\<or> Q is R healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_disj2:  \"R (P \\<or> Q) = (R P \\<or> R Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (P \\<or> Q) = (R P \\<or> R Q)", "apply (subst R_disj[simplified Healthy_def, where P=\"R P\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. R P = R (R P)\n 2. R Q = R (R Q)\n 3. R (P \\<or> Q) = R (R P \\<or> R Q)", "apply (simp_all add: R_idem2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R (P \\<or> Q) = R (R P \\<or> R Q)", "apply (auto simp: fun_eq_iff rp_defs split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R1_comp:\n  assumes \"P is R1 healthy\"\n    and \"Q is R1 healthy\"\n  shows \"(P;;Q) is R1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "have \"R1 P = P\" and \"R1 Q = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 P = P &&& R1 Q = Q", "using assms"], ["proof (prove)\nusing this:\n  P is R1 healthy\n  Q is R1 healthy\n\ngoal (1 subgoal):\n 1. R1 P = P &&& R1 Q = Q", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R1 P = P\n  R1 Q = Q\n\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "moreover"], ["proof (state)\nthis:\n  R1 P = P\n  R1 Q = Q\n\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "have \"((R1 P) ;; (R1 Q)) is R1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 P ;; R1 Q is R1 healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R1 P ;; R1 Q is R1 healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "ultimately"], ["proof (chain)\npicking this:\n  R1 P = P\n  R1 Q = Q\n  R1 P ;; R1 Q is R1 healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R1 P = P\n  R1 Q = Q\n  R1 P ;; R1 Q is R1 healthy\n\ngoal (1 subgoal):\n 1. P ;; Q is R1 healthy", "by simp"], ["proof (state)\nthis:\n  P ;; Q is R1 healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R1_comp2:\n  assumes A: \"P is R1 healthy\"\n  assumes B: \"Q is R1 healthy\"\n  shows  \"R1 (P;;Q) = ((R1 P);;Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 (P ;; Q) = (R1 P ;; Q)", "using A B"], ["proof (prove)\nusing this:\n  P is R1 healthy\n  Q is R1 healthy\n\ngoal (1 subgoal):\n 1. R1 (P ;; Q) = (R1 P ;; Q)", "apply (subst R1_comp[simplified Healthy_def, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>P is R1 healthy; Q is R1 healthy\\<rbrakk>\n    \\<Longrightarrow> P = R1 P\n 2. \\<lbrakk>P is R1 healthy; Q is R1 healthy\\<rbrakk>\n    \\<Longrightarrow> Q = R1 Q\n 3. \\<lbrakk>P is R1 healthy; Q is R1 healthy\\<rbrakk>\n    \\<Longrightarrow> (P ;; Q) = (R1 P ;; Q)", "apply (auto simp: fun_eq_iff rp_defs design_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma J_is_R1: \"J is R1 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J is R1 healthy", "by (auto simp: rp_defs design_defs fun_eq_iff elim: alpha_d_more_eqE)"], ["", "lemma J_is_R2: \"J is R2 healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J is R2 healthy", "by (auto simp: rp_defs design_defs fun_eq_iff prefix_def\n    elim!: alpha_d_more_eqE intro!: alpha_d_more_eqI)"], ["", "lemma R1_H2_commute2: \"R1 (H2 P) = H2 (R1 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 (H2 P) = H2 (R1 P)", "by (auto simp add: H2_def R1_def J_def fun_eq_iff\n    elim!: alpha_d_more_eqE intro!: alpha_d_more_eqI)"], ["", "lemma R1_H2_commute: \"R1 o H2 = H2 o R1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 \\<circ> H2 = H2 \\<circ> R1", "by (auto simp: R1_H2_commute2)"], ["", "lemma R2_H2_commute2: \"R2 (H2 P) = H2 (R2 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 (H2 P) = H2 (R2 P)", "apply (auto simp add: fun_eq_iff rp_defs design_defs strict_prefix_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              tr A \\<le> tr A') ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 2. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              tr A \\<le> tr A') ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 3. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c;\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (P ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)\n 4. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c;\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> tr aa \\<le> tr c\n 5. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c; ok c\\<rbrakk>\n       \\<Longrightarrow> (P ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)\n 6. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c; ok c\\<rbrakk>\n       \\<Longrightarrow> tr aa \\<le> tr c", "apply (rule_tac b=\"ba\\<lparr>tr := tr a @ tr ba\\<rparr>\" in comp_intro)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> case (a, ba\\<lparr>tr := tr a @ tr ba\\<rparr>) of\n                         (A, A') \\<Rightarrow>\n                           P (A\\<lparr>tr := []\\<rparr>, A'\n                              \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                           tr A \\<le> tr A'\n 2. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> case (ba\\<lparr>tr := tr a @ tr ba\\<rparr>, b) of\n                         (A, A') \\<Rightarrow>\n                           (ok A \\<longrightarrow> ok A') \\<and>\n                           alpha_d.more A = alpha_d.more A'\n 3. \\<And>a b ba.\n       \\<lbrakk>tr a \\<le> tr b; P (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              tr A \\<le> tr A') ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 4. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c;\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (P ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)\n 5. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c;\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> tr aa \\<le> tr c\n 6. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c; ok c\\<rbrakk>\n       \\<Longrightarrow> (P ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)\n 7. \\<And>aa ba c.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\n                   \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba; alpha_d.more ba = alpha_d.more c; ok c\\<rbrakk>\n       \\<Longrightarrow> tr aa \\<le> tr c", "apply (auto simp: fun_eq_iff prefix_def\n  elim!: alpha_d_more_eqE alpha_rp_eqE intro!: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>P (a\\<lparr>tr := []\\<rparr>, ba); ok b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; tr b = tr a @ tr ba; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              (\\<exists>zs. tr A' = tr A @ zs)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 2. \\<And>a b ba.\n       \\<lbrakk>P (a\\<lparr>tr := []\\<rparr>, ba); ok b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; tr b = tr a @ tr ba;\n        \\<not> wait ba; \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              (\\<exists>zs. tr A' = tr A @ zs)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 3. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 4. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 5. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 6. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs", "apply (rule_tac b=\"ba\\<lparr>tr := tr a @ tr ba\\<rparr>\" in comp_intro,\n  auto simp: elim: alpha_d_more_eqE alpha_rp_eqE intro: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>P (a\\<lparr>tr := []\\<rparr>, ba); ok b; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; tr b = tr a @ tr ba;\n        \\<not> wait ba; \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>(A, A').\n                              P (A\\<lparr>tr := []\\<rparr>, A'\n                                 \\<lparr>tr := tr A' - tr A\\<rparr>) \\<and>\n                              (\\<exists>zs. tr A' = tr A @ zs)) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 2. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 3. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 4. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 5. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs", "apply (rule_tac b=\"ba\\<lparr>tr := tr a @ tr ba\\<rparr>\" in comp_intro,\n  auto simp: elim: alpha_d_more_eqE alpha_rp_eqE intro: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 2. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        \\<not> ok ba; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 3. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; wait ba;\n        wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs\n 4. \\<And>aa ba c zs.\n       \\<lbrakk>P (aa\\<lparr>tr := []\\<rparr>, ba\\<lparr>tr := zs\\<rparr>);\n        ok c; tr aa @ zs = tr c; ref ba = ref c;\n        alpha_rp.more ba = alpha_rp.more c; tr ba = tr c; \\<not> wait ba;\n        \\<not> wait c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>zs. tr c = tr aa @ zs", "apply (rule_tac x=zs in exI, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R2_H2_commute: \"R2 o H2 = H2 o R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 \\<circ> H2 = H2 \\<circ> R2", "by (auto simp: R2_H2_commute2)"], ["", "lemma R3_H2_commute2: \"R3 (H2 P) = H2 (R3 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 (H2 P) = H2 (R3 P)", "apply (auto simp: fun_eq_iff rp_defs design_defs strict_prefix_def \n            elim: alpha_d_more_eqE split: cond_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R3_H2_commute: \"R3 o H2 = H2 o R3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R3 \\<circ> H2 = H2 \\<circ> R3", "by (auto simp: R3_H2_commute2)"], ["", "lemma R_join: \n  assumes \"x is R healthy\"\n  and \"y is R healthy\"\n  shows \"(x \\<sqinter> y) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "have \"R x = x\" and \"R y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x = x &&& R y = y", "using assms"], ["proof (prove)\nusing this:\n  x is R healthy\n  y is R healthy\n\ngoal (1 subgoal):\n 1. R x = x &&& R y = y", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R x = x\n  R y = y\n\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "moreover"], ["proof (state)\nthis:\n  R x = x\n  R y = y\n\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "have \"((R x) \\<sqinter> (R y)) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x \\<or> R y is R healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R x \\<or> R y is R healthy\n\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "ultimately"], ["proof (chain)\npicking this:\n  R x = x\n  R y = y\n  R x \\<or> R y is R healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R x = x\n  R y = y\n  R x \\<or> R y is R healthy\n\ngoal (1 subgoal):\n 1. x \\<or> y is R healthy", "by simp"], ["proof (state)\nthis:\n  x \\<or> y is R healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_meet:\n  assumes A: \"x is R healthy\"\n  and B:\"y is R healthy\"\n  shows \"(x \\<squnion> y) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "have \"R x = x\" and \"R y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x = x &&& R y = y", "using assms"], ["proof (prove)\nusing this:\n  x is R healthy\n  y is R healthy\n\ngoal (1 subgoal):\n 1. R x = x &&& R y = y", "by (simp_all only: Healthy_def)"], ["proof (state)\nthis:\n  R x = x\n  R y = y\n\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "moreover"], ["proof (state)\nthis:\n  R x = x\n  R y = y\n\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "have \"((R x) \\<squnion> (R y)) is R healthy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R x \\<and> R y is R healthy", "by (auto simp add: design_defs rp_defs fun_eq_iff split: cond_splits)"], ["proof (state)\nthis:\n  R x \\<and> R y is R healthy\n\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "ultimately"], ["proof (chain)\npicking this:\n  R x = x\n  R y = y\n  R x \\<and> R y is R healthy", "show ?thesis"], ["proof (prove)\nusing this:\n  R x = x\n  R y = y\n  R x \\<and> R y is R healthy\n\ngoal (1 subgoal):\n 1. x \\<and> y is R healthy", "by simp"], ["proof (state)\nthis:\n  x \\<and> y is R healthy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R_H2_commute: \"R o H2 = H2 o R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<circ> H2 = H2 \\<circ> R", "apply (auto simp add: rp_defs design_defs fun_eq_iff split: cond_splits \n                     elim: alpha_d_more_eqE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        \\<not> ok ba\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 2. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba);\n        alpha_d.more ba = alpha_d.more (b\\<lparr>tr := tr b - tr a\\<rparr>);\n        ok b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 3. \\<And>x aa ba c.\n       \\<lbrakk>alpha_d.more ba = alpha_d.more c; \\<not> ok ba;\n        \\<not> wait aa;\n        x (aa\\<lparr>tr := []\\<rparr>, ba\n           \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba\\<rbrakk>\n       \\<Longrightarrow> (x ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)\n 4. \\<And>x aa ba c.\n       \\<lbrakk>alpha_d.more ba = alpha_d.more c; ok c; \\<not> wait aa;\n        x (aa\\<lparr>tr := []\\<rparr>, ba\n           \\<lparr>tr := tr ba - tr aa\\<rparr>);\n        tr aa \\<le> tr ba\\<rbrakk>\n       \\<Longrightarrow> (x ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (aa\\<lparr>tr := []\\<rparr>, c\n                           \\<lparr>tr := tr c - tr aa\\<rparr>)", "apply (rule_tac b=\"ba\\<lparr>tr := tr b\\<rparr>\" in comp_intro, auto split: cond_splits\n  elim!: alpha_d_more_eqE alpha_rp_eqE intro!: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); \\<not> ok ba;\n        tr ba = tr b - tr a; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; wait ba; wait b\\<rbrakk>\n       \\<Longrightarrow> x (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); \\<not> ok ba;\n        tr ba = tr b - tr a; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> x (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>tr := tr b - tr a\\<rparr>)\n 3. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 4. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac s=ba in subst, auto intro!: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); \\<not> ok ba;\n        tr ba = tr b - tr a; ref ba = ref b;\n        alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> x (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 3. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac s=ba in subst, auto intro!: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)\n 2. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac b=\"ba\\<lparr>tr := tr b\\<rparr>\" in comp_intro, auto split: cond_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> x (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>tr := tr b - tr a\\<rparr>)\n 2. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; wait ba;\n        wait b\\<rbrakk>\n       \\<Longrightarrow> alpha_d.more (ba\\<lparr>tr := tr b\\<rparr>) =\n                         alpha_d.more b\n 3. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac s=ba in subst,\n  auto elim: alpha_d_more_eqE alpha_rp_eqE intro: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> (((\\<lambda>(A, A').\n                               \\<not> ok A \\<and> tr A \\<le> tr A' \\<or>\n                               ok A' \\<and>\n                               tr A = tr A' \\<and>\n                               wait A = wait A' \\<and>\n                               ref A = ref A' \\<and>\n                               alpha_rp.more A =\n                               alpha_rp.more\n                                A') \\<triangleleft> wait \\<circ>\n              fst \\<triangleright> \n                              (\\<lambda>(A, A').\n                                  x (A\\<lparr>tr := []\\<rparr>, A'\n                                     \\<lparr>tr :=\n         tr A' - tr A\\<rparr>) \\<and>\n                                  tr A \\<le> tr A')) ;;\n                          (\\<lambda>(A, A').\n                              (ok A \\<longrightarrow> ok A') \\<and>\n                              alpha_d.more A = alpha_d.more A'))\n                          (a, b)", "apply (rule_tac b=\"ba\\<lparr>tr := tr b\\<rparr>\" in comp_intro,\n  auto elim: alpha_d_more_eqE alpha_rp_eqE intro: alpha_d_more_eqI alpha_rp.equality split: cond_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b ba.\n       \\<lbrakk>\\<not> wait a; tr a \\<le> tr b;\n        x (a\\<lparr>tr := []\\<rparr>, ba); ok b; tr ba = tr b - tr a;\n        ref ba = ref b; alpha_rp.more ba = alpha_rp.more b; \\<not> wait ba;\n        \\<not> wait b\\<rbrakk>\n       \\<Longrightarrow> x (a\\<lparr>tr := []\\<rparr>, ba\n                            \\<lparr>tr := tr b - tr a\\<rparr>)", "apply (rule_tac s=ba in subst,\n  auto elim: alpha_d_more_eqE alpha_rp_eqE intro: alpha_d_more_eqI alpha_rp.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma R_H2_commute2: \"R (H2 P) = H2 (R P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (H2 P) = H2 (R P)", "by (auto simp: fun_eq_iff R_H2_commute[simplified fun_eq_iff Fun.comp_def])"], ["", "end"]]}