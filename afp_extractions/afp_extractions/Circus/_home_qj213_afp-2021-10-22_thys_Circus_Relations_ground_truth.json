{"file_name": "/home/qj213/afp-2021-10-22/thys/Circus/Relations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Circus", "problem_names": ["lemmas utp_defs = true_def false_def conj_def disj_def not_def impl_def iff_def\n                  ex_def all_def cond_def comp_def Assign_def", "lemma true_intro: \"true x\"", "lemma false_elim: \"false x \\<Longrightarrow> C\"", "lemma true_elim: \"true x \\<Longrightarrow> C \\<Longrightarrow> C\"", "lemma not_intro: \"(P x \\<Longrightarrow> false x) \\<Longrightarrow> (\\<not> P) x\"", "lemma not_elim: \"(\\<not> P) x \\<Longrightarrow> P x \\<Longrightarrow> C\"", "lemma not_dest: \"(\\<not> P) x \\<Longrightarrow> \\<not> P x\"", "lemma conj_intro: \"P x \\<Longrightarrow> Q x \\<Longrightarrow> (P \\<and> Q) x\"", "lemma conj_elim: \"(P \\<and> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> Q x \\<Longrightarrow> C) \\<Longrightarrow> C\"", "lemma disj_introC: \"(\\<not> Q x \\<Longrightarrow> P x) \\<Longrightarrow> (P \\<or> Q) x\"", "lemma disj_elim: \"(P \\<or> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> C) \\<Longrightarrow> (Q x \\<Longrightarrow> C) \\<Longrightarrow> C\"", "lemma impl_intro: \"(P x \\<Longrightarrow> Q x) \\<Longrightarrow> (P \\<longrightarrow> Q) x\"", "lemma impl_elimC: \"(P \\<longrightarrow> Q) x \\<Longrightarrow> (\\<not> P x \\<Longrightarrow> R) \\<Longrightarrow> (Q x \\<Longrightarrow> R) \\<Longrightarrow> R \"", "lemma iff_intro: \"(P x \\<Longrightarrow> Q x) \\<Longrightarrow> (Q x \\<Longrightarrow> P x) \\<Longrightarrow> (P \\<longleftrightarrow> Q) x\"", "lemma iff_elimC: \n\"(P \\<longleftrightarrow> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> Q x \\<Longrightarrow> R) \\<Longrightarrow> (\\<not> P x \\<Longrightarrow> \\<not> Q x \\<Longrightarrow> R) \\<Longrightarrow> R\"", "lemma all_intro: \"(\\<And>a. P a x) \\<Longrightarrow> (\\<^bold>\\<forall>a. P a) x\"", "lemma all_elim: \"(\\<^bold>\\<forall>a. P a) x \\<Longrightarrow> (P a x \\<Longrightarrow> R) \\<Longrightarrow> R\"", "lemma ex_intro: \"P a x \\<Longrightarrow> (\\<^bold>\\<exists>a. P a) x\"", "lemma ex_elim: \"(\\<^bold>\\<exists>a. P a) x \\<Longrightarrow> (\\<And>a. P a x \\<Longrightarrow> Q) \\<Longrightarrow> Q\"", "lemma comp_intro: \"P (a, b) \\<Longrightarrow> Q (b, c) \\<Longrightarrow> (P ;; Q) (a, c)\"", "lemma comp_elim: \n\"(P ;; Q) ac \\<Longrightarrow> (\\<And>a b c. ac = (a, c) \\<Longrightarrow> P (a, b) \\<Longrightarrow> Q (b, c) \\<Longrightarrow> C) \\<Longrightarrow> C\"", "lemmas relation_rules = iff_intro not_intro impl_intro disj_introC conj_intro true_intro\n                        comp_intro not_dest iff_elimC false_elim impl_elimC all_elim\n                        disj_elim conj_elim comp_elim all_intro ex_intro ex_elim", "lemma split_cond: \n\"A ((P \\<triangleleft> b \\<triangleright> Q) x) = ((b x \\<longrightarrow> A (P x)) \\<and> (\\<not> b x \\<longrightarrow> A (Q x)))\"", "lemma split_cond_asm: \n\"A ((P \\<triangleleft> b \\<triangleright> Q) x) = (\\<not> ((b x \\<and> \\<not> A (P x)) \\<or> (\\<not> b x \\<and> \\<not> A (Q x))))\"", "lemmas cond_splits = split_cond split_cond_asm", "lemma cond_idem:\"(P \\<triangleleft> b \\<triangleright> P) = P\"", "lemma cond_symm:\"(P \\<triangleleft> b \\<triangleright> Q) = (Q \\<triangleleft> \\<not> b \\<triangleright> P)\"", "lemma cond_assoc: \"((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> R) = (P \\<triangleleft> b \\<and> c \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R))\"", "lemma cond_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> (P \\<triangleleft> b \\<triangleright> R))\"", "lemma cond_unit_T:\"(P \\<triangleleft> true \\<triangleright> Q) = P\"", "lemma cond_unit_F:\"(P \\<triangleleft> false \\<triangleright> Q) = Q\"", "lemma cond_L6: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> b \\<triangleright> R)) = (P \\<triangleleft> b \\<triangleright> R)\"", "lemma cond_L7: \"(P \\<triangleleft> b \\<triangleright> (P \\<triangleleft> c \\<triangleright> Q)) = (P \\<triangleleft> b \\<or> c \\<triangleright> Q)\"", "lemma cond_and_distr: \"((P \\<and> Q) \\<triangleleft> b \\<triangleright> (R \\<and> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<and> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_or_distr: \"((P \\<or> Q) \\<triangleleft> b \\<triangleright> (R \\<or> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<or> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_imp_distr: \n\"((P \\<longrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<longrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<longrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma cond_eq_distr: \n\"((P \\<longleftrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<longleftrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<longleftrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\"", "lemma comp_assoc: \"(P ;; (Q ;; R)) = ((P ;; Q) ;; R)\"", "lemma conj_comp: \n\"(\\<And> a b c. P (a, b) = P (a, c)) \\<Longrightarrow> (P \\<and> (Q ;; R)) = ((P \\<and> Q) ;; R)\"", "lemma comp_cond_left_distr:\n  assumes \"\\<And>x y z. b (x, y) = b (x, z)\"\n  shows \"((P \\<triangleleft> b \\<triangleright> Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright> (Q ;; R))\"", "lemma ndet_symm: \"(P::'a relation) \\<sqinter> Q = Q \\<sqinter> P\"", "lemma ndet_assoc: \"P \\<sqinter> (Q \\<sqinter> R) = (P \\<sqinter> Q) \\<sqinter> R\"", "lemma ndet_idemp: \"P \\<sqinter> P = P\"", "lemma ndet_distr: \"P \\<sqinter> (Q \\<sqinter> R) = (P \\<sqinter> Q) \\<sqinter> (P \\<sqinter> R)\"", "lemma cond_ndet_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<sqinter> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<sqinter> (P \\<triangleleft> b \\<triangleright> R))\"", "lemma ndet_cond_distr: \"(P \\<sqinter> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<sqinter> Q) \\<triangleleft> b \\<triangleright> (P \\<sqinter> R))\"", "lemma comp_ndet_l_distr: \"((P \\<sqinter> Q) ;; R) = ((P ;; R) \\<sqinter> (Q ;; R))\"", "lemma comp_ndet_r_distr: \"(P ;; (Q \\<sqinter> R)) = ((P ;; Q) \\<sqinter> (P ;; R))\"", "lemma l2_5_1_A: \"\\<forall>X \\<in> S. [X \\<longrightarrow> (\\<Sqinter> S)]\"", "lemma l2_5_1_B: \"(\\<forall> X \\<in> S. [X \\<longrightarrow> P]) \\<longrightarrow> [(\\<Sqinter> S) \\<longrightarrow> P]\"", "lemma l2_5_1: \"[(\\<Sqinter> S) \\<longrightarrow> P] \\<longleftrightarrow> (\\<forall> X \\<in> S. [X \\<longrightarrow> P])\"", "lemma empty_disj: \"\\<Sqinter> {} = Top\"", "lemma l2_5_1_2: \"[P \\<longrightarrow> (\\<Squnion> S)] \\<longleftrightarrow> (\\<forall> X \\<in> S. [P \\<longrightarrow> X])\"", "lemma empty_conj: \"\\<Squnion> {} = Bot\"", "lemma l2_5_2: \"((\\<Squnion> S) \\<sqinter> Q) = (\\<Squnion>{P \\<sqinter> Q | P. P\\<in>S})\"", "lemma l2_5_3: \"((\\<Sqinter> S) \\<squnion> Q) = (\\<Sqinter>{P \\<squnion> Q | P. P \\<in> S})\"", "lemma l2_5_4: \"((\\<Sqinter> S) ;; Q) = (\\<Sqinter>{P ;; Q | P. P \\<in> S})\"", "lemma l2_5_5: \"(Q ;; (\\<Sqinter> S)) = (\\<Sqinter>{Q ;; P | P. P \\<in> S})\"", "lemma all_idem :\"(\\<^bold>\\<forall>b. \\<^bold>\\<forall>a. P a) = (\\<^bold>\\<forall>a. P a)\"", "lemma comp_unit_R [simp]: \"(P ;; \\<Pi>r) = P\"", "lemma comp_unit_L [simp]: \"(\\<Pi>r ;; P) = P\"", "lemmas comp_unit_simps = comp_unit_R comp_unit_L", "lemma not_cond: \"(\\<not>(P \\<triangleleft> b \\<triangleright> Q)) = ((\\<not> P) \\<triangleleft> b \\<triangleright> (\\<not> Q))\"", "lemma cond_conj_not_distr: \n\"((P \\<triangleleft> b \\<triangleright> Q) \\<and> \\<not>(R \\<triangleleft> b \\<triangleright> S)) = ((P \\<and> \\<not>R) \\<triangleleft> b \\<triangleright> (Q \\<and> \\<not>S))\"", "lemma imp_cond_distr: \"(R \\<longrightarrow> (P \\<triangleleft> b \\<triangleright> Q)) = ((R \\<longrightarrow> P) \\<triangleleft> b \\<triangleright> (R \\<longrightarrow> Q))\"", "lemma cond_imp_dist: \"((P \\<triangleleft> b \\<triangleright> Q) \\<longrightarrow> R) = ((P \\<longrightarrow> R) \\<triangleleft> b \\<triangleright> (Q \\<longrightarrow> R))\"", "lemma cond_conj_distr: \"((P \\<triangleleft> b \\<triangleright> Q) \\<and> R) = ((P \\<and> R) \\<triangleleft> b \\<triangleright> (Q \\<and> R))\"", "lemma cond_disj_distr: \"((P \\<triangleleft> b \\<triangleright> Q) \\<or> R) = ((P \\<or> R) \\<triangleleft> b \\<triangleright> (Q \\<or> R))\"", "lemma cond_know_b: \"(b \\<and> (P \\<triangleleft> b \\<triangleright> Q)) = (b \\<and> P)\"", "lemma cond_know_nb: \"((\\<not> (b)) \\<and> (P \\<triangleleft> b \\<triangleright> Q)) = ((\\<not> (b)) \\<and> Q)\"", "lemma cond_ass_if: \"(P \\<triangleleft> b \\<triangleright> Q) = (((b) \\<and> P \\<triangleleft> b \\<triangleright> Q))\"", "lemma cond_ass_else: \"(P \\<triangleleft> b \\<triangleright> Q) = (P \\<triangleleft> b \\<triangleright> ((\\<not>b) \\<and> Q))\"", "lemma not_true_eq_false: \"(\\<not> true) = false\"", "lemma not_false_eq_true: \"(\\<not> false) = true\"", "lemma conj_idem: \"((P::'\\<alpha> predicate) \\<and> P) = P\"", "lemma disj_idem: \"((P::'\\<alpha> predicate) \\<or> P) = P\"", "lemma conj_comm: \"((P::'\\<alpha> predicate) \\<and> Q) = (Q \\<and> P)\"", "lemma disj_comm: \"((P::'\\<alpha> predicate) \\<or> Q) = (Q \\<or> P)\"", "lemma conj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> predicate) \\<and> Q) = (R \\<and> Q)\"", "lemma disj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> predicate) \\<or> Q) = (R \\<or> Q)\"", "lemma conj_assoc:\"(((P::'\\<alpha> predicate) \\<and> Q) \\<and> S) = (P \\<and> (Q \\<and> S))\"", "lemma disj_assoc:\"(((P::'\\<alpha> predicate) \\<or> Q) \\<or> S) = (P \\<or> (Q \\<or> S))\"", "lemma conj_disj_abs:\"((P::'\\<alpha> predicate) \\<and> (P \\<or> Q)) = P\"", "lemma disj_conj_abs:\"((P::'\\<alpha> predicate) \\<or> (P \\<and> Q)) = P\"", "lemma conj_disj_distr:\"((P::'\\<alpha> predicate) \\<and> (Q \\<or> R)) = ((P \\<and> Q) \\<or> (P \\<and> R))\"", "lemma disj_conj_dsitr:\"((P::'\\<alpha> predicate) \\<or> (Q \\<and> R)) = ((P \\<or> Q) \\<and> (P \\<or> R))\"", "lemma true_conj_id:\"(P \\<and> true) = P\"", "lemma true_dsij_zero:\"(P \\<or> true) = true\"", "lemma true_conj_zero:\"(P \\<and> false) = false\"", "lemma true_dsij_id:\"(P \\<or> false) = P\"", "lemma imp_vacuous: \"(false \\<longrightarrow> u) = true\"", "lemma p_and_not_p: \"(P \\<and> \\<not> P) = false\"", "lemma conj_disj_not_abs: \"((P::'\\<alpha> predicate) \\<and> ((\\<not>P) \\<or> Q)) = (P \\<and> Q)\"", "lemma p_or_not_p: \"(P \\<or> \\<not> P) = true\"", "lemma double_negation: \"(\\<not> \\<not> (P::'\\<alpha> predicate)) = P\"", "lemma not_conj_deMorgans: \"(\\<not> ((P::'\\<alpha> predicate) \\<and> Q)) = ((\\<not> P) \\<or> (\\<not> Q))\"", "lemma not_disj_deMorgans: \"(\\<not> ((P::'\\<alpha> predicate) \\<or> Q)) = ((\\<not> P) \\<and> (\\<not> Q))\"", "lemma p_imp_p: \"(P \\<longrightarrow> P) = true\"", "lemma imp_imp: \"((P::'\\<alpha> predicate) \\<longrightarrow> (Q \\<longrightarrow> R)) = ((P \\<and> Q) \\<longrightarrow> R)\"", "lemma imp_trans: \"((P \\<longrightarrow> Q) \\<and> (Q \\<longrightarrow> R) \\<longrightarrow> P \\<longrightarrow> R) = true\"", "lemma p_equiv_p: \"(P \\<longleftrightarrow> P) = true\"", "lemma equiv_eq: \"((((P::'\\<alpha> predicate) \\<and> Q) \\<or> (\\<not>P \\<and> \\<not>Q)) = true) \\<longleftrightarrow> (P = Q)\"", "lemma equiv_eq1: \"(((P::'\\<alpha> predicate) \\<longleftrightarrow> Q) = true) \\<longleftrightarrow> (P = Q)\"", "lemma cond_subst: \"b = c \\<Longrightarrow> (P \\<triangleleft> b \\<triangleright> Q) = (P \\<triangleleft> c \\<triangleright> Q)\"", "lemma ex_disj_distr: \"((\\<^bold>\\<exists>x. P x) \\<or> (\\<^bold>\\<exists>x. Q x)) = (\\<^bold>\\<exists>x. (P x \\<or> Q x))\"", "lemma all_disj_distr: \"((\\<^bold>\\<forall>x. P x) \\<or> (\\<^bold>\\<forall>x. Q)) = (\\<^bold>\\<forall>x. (P x \\<or> Q))\"", "lemma all_conj_distr: \"((\\<^bold>\\<forall>x. P x) \\<and> (\\<^bold>\\<forall>x. Q x)) = (\\<^bold>\\<forall>x. (P x \\<and> Q x))\"", "lemma all_triv: \"(\\<^bold>\\<forall>x. P) = P\"", "lemma closure_true: \"[true]\"", "lemma closure_p_eq_true: \"[P] \\<longleftrightarrow> (P = true)\"", "lemma closure_equiv_eq: \"[P \\<longleftrightarrow> Q] \\<longleftrightarrow> (P = Q)\"", "lemma closure_conj_distr: \"([P] \\<and> [Q]) = [P \\<and> Q]\"", "lemma closure_imp_distr: \"[P \\<longrightarrow> Q] \\<longrightarrow> [P] \\<longrightarrow> [Q]\"", "lemma true_iff[simp]: \"(P \\<longleftrightarrow> true) = P\"", "lemma true_imp[simp]: \"(true \\<longrightarrow> P) = P\""], "translations": [["", "lemmas utp_defs = true_def false_def conj_def disj_def not_def impl_def iff_def\n                  ex_def all_def cond_def comp_def Assign_def"], ["", "subsection \\<open>Proofs\\<close>"], ["", "text \\<open>All useful proved lemmas over predicates and relations are presented here.\nFirst, we introduce the most important lemmas that will be used by automatic tools to simplify\nproofs. In the second part, other lemmas are proved using these basic ones.\\<close>"], ["", "subsubsection \\<open>Setup of automated tools\\<close>"], ["", "lemma true_intro: \"true x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true x", "by (simp add: utp_defs)"], ["", "lemma false_elim: \"false x \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false x \\<Longrightarrow> C", "by (simp add: utp_defs)"], ["", "lemma true_elim: \"true x \\<Longrightarrow> C \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>true x; C\\<rbrakk> \\<Longrightarrow> C", "by (simp add: utp_defs)"], ["", "lemma not_intro: \"(P x \\<Longrightarrow> false x) \\<Longrightarrow> (\\<not> P) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<Longrightarrow> false x) \\<Longrightarrow> (\\<not> P) x", "by (auto simp add: utp_defs)"], ["", "lemma not_elim: \"(\\<not> P) x \\<Longrightarrow> P x \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<not> P) x; P x\\<rbrakk> \\<Longrightarrow> C", "by (auto simp add: utp_defs)"], ["", "lemma not_dest: \"(\\<not> P) x \\<Longrightarrow> \\<not> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> P) x \\<Longrightarrow> \\<not> P x", "by (auto simp add: utp_defs)"], ["", "lemma conj_intro: \"P x \\<Longrightarrow> Q x \\<Longrightarrow> (P \\<and> Q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x; Q x\\<rbrakk> \\<Longrightarrow> (P \\<and> Q) x", "by (auto simp add: utp_defs)"], ["", "lemma conj_elim: \"(P \\<and> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> Q x \\<Longrightarrow> C) \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<and> Q) x;\n     \\<lbrakk>P x; Q x\\<rbrakk> \\<Longrightarrow> C\\<rbrakk>\n    \\<Longrightarrow> C", "by (auto simp add: utp_defs)"], ["", "lemma disj_introC: \"(\\<not> Q x \\<Longrightarrow> P x) \\<Longrightarrow> (P \\<or> Q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Q x \\<Longrightarrow> P x) \\<Longrightarrow> (P \\<or> Q) x", "by (auto simp add: utp_defs)"], ["", "lemma disj_elim: \"(P \\<or> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> C) \\<Longrightarrow> (Q x \\<Longrightarrow> C) \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<or> Q) x; P x \\<Longrightarrow> C;\n     Q x \\<Longrightarrow> C\\<rbrakk>\n    \\<Longrightarrow> C", "by (auto simp add: utp_defs)"], ["", "lemma impl_intro: \"(P x \\<Longrightarrow> Q x) \\<Longrightarrow> (P \\<longrightarrow> Q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P x \\<Longrightarrow> Q x) \\<Longrightarrow> (P \\<longrightarrow> Q) x", "by (auto simp add: utp_defs)"], ["", "lemma impl_elimC: \"(P \\<longrightarrow> Q) x \\<Longrightarrow> (\\<not> P x \\<Longrightarrow> R) \\<Longrightarrow> (Q x \\<Longrightarrow> R) \\<Longrightarrow> R \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<longrightarrow> Q) x; \\<not> P x \\<Longrightarrow> R;\n     Q x \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by (auto simp add: utp_defs)"], ["", "lemma iff_intro: \"(P x \\<Longrightarrow> Q x) \\<Longrightarrow> (Q x \\<Longrightarrow> P x) \\<Longrightarrow> (P \\<longleftrightarrow> Q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P x \\<Longrightarrow> Q x; Q x \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> (P \\<longleftrightarrow> Q) x", "by (auto simp add: utp_defs)"], ["", "lemma iff_elimC: \n\"(P \\<longleftrightarrow> Q) x \\<Longrightarrow> (P x \\<Longrightarrow> Q x \\<Longrightarrow> R) \\<Longrightarrow> (\\<not> P x \\<Longrightarrow> \\<not> Q x \\<Longrightarrow> R) \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P \\<longleftrightarrow> Q) x;\n     \\<lbrakk>P x; Q x\\<rbrakk> \\<Longrightarrow> R;\n     \\<lbrakk>\\<not> P x; \\<not> Q x\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by (auto simp add: utp_defs)"], ["", "lemma all_intro: \"(\\<And>a. P a x) \\<Longrightarrow> (\\<^bold>\\<forall>a. P a) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. P a x) \\<Longrightarrow> (\\<^bold>\\<forall>a. P a) x", "by (auto simp add: utp_defs)"], ["", "lemma all_elim: \"(\\<^bold>\\<forall>a. P a) x \\<Longrightarrow> (P a x \\<Longrightarrow> R) \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<^bold>\\<forall>a. P a) x; P a x \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by (auto simp add: utp_defs)"], ["", "lemma ex_intro: \"P a x \\<Longrightarrow> (\\<^bold>\\<exists>a. P a) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a x \\<Longrightarrow> (\\<^bold>\\<exists>a. P a) x", "by (auto simp add: utp_defs)"], ["", "lemma ex_elim: \"(\\<^bold>\\<exists>a. P a) x \\<Longrightarrow> (\\<And>a. P a x \\<Longrightarrow> Q) \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<^bold>\\<exists>a. P a) x;\n     \\<And>a. P a x \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (auto simp add: utp_defs)"], ["", "lemma comp_intro: \"P (a, b) \\<Longrightarrow> Q (b, c) \\<Longrightarrow> (P ;; Q) (a, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (a, b); Q (b, c)\\<rbrakk> \\<Longrightarrow> (P ;; Q) (a, c)", "by (auto simp add: comp_def)"], ["", "lemma comp_elim: \n\"(P ;; Q) ac \\<Longrightarrow> (\\<And>a b c. ac = (a, c) \\<Longrightarrow> P (a, b) \\<Longrightarrow> Q (b, c) \\<Longrightarrow> C) \\<Longrightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(P ;; Q) ac;\n     \\<And>a b c.\n        \\<lbrakk>ac = (a, c); P (a, b); Q (b, c)\\<rbrakk>\n        \\<Longrightarrow> C\\<rbrakk>\n    \\<Longrightarrow> C", "by (auto simp add: comp_def)"], ["", "declare not_def [simp]"], ["", "declare iff_intro [intro!]\n  and not_intro [intro!]\n  and impl_intro [intro!]\n  and disj_introC [intro!]\n  and conj_intro [intro!]\n  and true_intro [intro!]\n  and comp_intro [intro]"], ["", "declare not_dest [dest!]\n  and iff_elimC [elim!]\n  and false_elim [elim!]\n  and impl_elimC [elim!]\n  and disj_elim [elim!]\n  and conj_elim [elim!]\n  and comp_elim [elim!]\n  and true_elim [elim!]"], ["", "declare all_intro [intro!] and ex_intro [intro]"], ["", "declare ex_elim [elim!] and all_elim [elim]"], ["", "lemmas relation_rules = iff_intro not_intro impl_intro disj_introC conj_intro true_intro\n                        comp_intro not_dest iff_elimC false_elim impl_elimC all_elim\n                        disj_elim conj_elim comp_elim all_intro ex_intro ex_elim"], ["", "lemma split_cond: \n\"A ((P \\<triangleleft> b \\<triangleright> Q) x) = ((b x \\<longrightarrow> A (P x)) \\<and> (\\<not> b x \\<longrightarrow> A (Q x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((P \\<triangleleft> b \\<triangleright>  Q) x) =\n    ((b x \\<longrightarrow> A (P x)) \\<and>\n     (\\<not> b x \\<longrightarrow> A (Q x)))", "by (cases \"b x\") (auto simp add: utp_defs)"], ["", "lemma split_cond_asm: \n\"A ((P \\<triangleleft> b \\<triangleright> Q) x) = (\\<not> ((b x \\<and> \\<not> A (P x)) \\<or> (\\<not> b x \\<and> \\<not> A (Q x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((P \\<triangleleft> b \\<triangleright>  Q) x) =\n    (\\<not> (b x \\<and> \\<not> A (P x) \\<or>\n             \\<not> b x \\<and> \\<not> A (Q x)))", "by (cases \"b x\") (auto simp add: utp_defs)"], ["", "lemmas cond_splits = split_cond split_cond_asm"], ["", "subsubsection \\<open>Misc lemmas\\<close>"], ["", "lemma cond_idem:\"(P \\<triangleleft> b \\<triangleright> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>  P) = P", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_symm:\"(P \\<triangleleft> b \\<triangleright> Q) = (Q \\<triangleleft> \\<not> b \\<triangleright> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>  Q) =\n    (Q \\<triangleleft> \\<not> b \\<triangleright>  P)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_assoc: \"((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> R) = (P \\<triangleleft> b \\<and> c \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright> \n        Q \\<triangleleft> c \\<triangleright> \n        R) =\n    (P \\<triangleleft> b \\<and> c \\<triangleright> \n        (Q \\<triangleleft> c \\<triangleright>  R))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> c \\<triangleright> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<triangleleft> c \\<triangleright> (P \\<triangleleft> b \\<triangleright> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright> \n        (Q \\<triangleleft> c \\<triangleright>  R)) =\n    (P \\<triangleleft> b \\<triangleright> \n        Q \\<triangleleft> c \\<triangleright> \n        (P \\<triangleleft> b \\<triangleright>  R))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_unit_T:\"(P \\<triangleleft> true \\<triangleright> Q) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> true \\<triangleright>  Q) = P", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_unit_F:\"(P \\<triangleleft> false \\<triangleright> Q) = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> false \\<triangleright>  Q) = Q", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_L6: \"(P \\<triangleleft> b \\<triangleright> (Q \\<triangleleft> b \\<triangleright> R)) = (P \\<triangleleft> b \\<triangleright> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright> \n        (Q \\<triangleleft> b \\<triangleright>  R)) =\n    (P \\<triangleleft> b \\<triangleright>  R)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_L7: \"(P \\<triangleleft> b \\<triangleright> (P \\<triangleleft> c \\<triangleright> Q)) = (P \\<triangleleft> b \\<or> c \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright> \n        (P \\<triangleleft> c \\<triangleright>  Q)) =\n    (P \\<triangleleft> b \\<or> c \\<triangleright>  Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_and_distr: \"((P \\<and> Q) \\<triangleleft> b \\<triangleright> (R \\<and> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<and> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q \\<triangleleft> b \\<triangleright>  R \\<and> S) =\n    ((P \\<triangleleft> b \\<triangleright>  R) \\<and>\n     (Q \\<triangleleft> b \\<triangleright>  S))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_or_distr: \"((P \\<or> Q) \\<triangleleft> b \\<triangleright> (R \\<or> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<or> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<triangleleft> b \\<triangleright>  R \\<or> S) =\n    ((P \\<triangleleft> b \\<triangleright>  R) \\<or>\n     (Q \\<triangleleft> b \\<triangleright>  S))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_imp_distr: \n\"((P \\<longrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<longrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<longrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longrightarrow> Q \\<triangleleft> b \\<triangleright> \n        R \\<longrightarrow> S) =\n    ((P \\<triangleleft> b \\<triangleright>  R) \\<longrightarrow>\n     (Q \\<triangleleft> b \\<triangleright>  S))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_eq_distr: \n\"((P \\<longleftrightarrow> Q) \\<triangleleft> b \\<triangleright> (R \\<longleftrightarrow> S)) = ((P \\<triangleleft> b \\<triangleright> R) \\<longleftrightarrow> (Q \\<triangleleft> b \\<triangleright> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longleftrightarrow> Q \\<triangleleft> b \\<triangleright> \n        R \\<longleftrightarrow> S) =\n    ((P \\<triangleleft> b \\<triangleright>  R) \\<longleftrightarrow>\n     (Q \\<triangleleft> b \\<triangleright>  S))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma comp_assoc: \"(P ;; (Q ;; R)) = ((P ;; Q) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; Q ;; R) = ((P ;; Q) ;; R)", "by (rule ext) blast"], ["", "lemma conj_comp: \n\"(\\<And> a b c. P (a, b) = P (a, c)) \\<Longrightarrow> (P \\<and> (Q ;; R)) = ((P \\<and> Q) ;; R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c. P (a, b) = P (a, c)) \\<Longrightarrow>\n    (P \\<and> (Q ;; R)) = (P \\<and> Q ;; R)", "by (rule ext) blast"], ["", "lemma comp_cond_left_distr:\n  assumes \"\\<And>x y z. b (x, y) = b (x, z)\"\n  shows \"((P \\<triangleleft> b \\<triangleright> Q) ;; R) = ((P ;; R) \\<triangleleft> b \\<triangleright> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) ;; R) =\n    (P ;; R \\<triangleleft> b \\<triangleright>  Q ;; R)", "using assms"], ["proof (prove)\nusing this:\n  b (?x, ?y) = b (?x, ?z)\n\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) ;; R) =\n    (P ;; R \\<triangleleft> b \\<triangleright>  Q ;; R)", "by (auto simp: fun_eq_iff utp_defs)"], ["", "lemma ndet_symm: \"(P::'a relation) \\<sqinter> Q = Q \\<sqinter> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = (Q \\<or> P)", "by (rule ext) blast"], ["", "lemma ndet_assoc: \"P \\<sqinter> (Q \\<sqinter> R) = (P \\<sqinter> Q) \\<sqinter> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<or> R) = ((P \\<or> Q) \\<or> R)", "by (rule ext) blast"], ["", "lemma ndet_idemp: \"P \\<sqinter> P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> P) = P", "by (rule ext) blast"], ["", "lemma ndet_distr: \"P \\<sqinter> (Q \\<sqinter> R) = (P \\<sqinter> Q) \\<sqinter> (P \\<sqinter> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<or> R) = ((P \\<or> Q) \\<or> P \\<or> R)", "by (rule ext) blast"], ["", "lemma cond_ndet_distr: \"(P \\<triangleleft> b \\<triangleright> (Q \\<sqinter> R)) = ((P \\<triangleleft> b \\<triangleright> Q) \\<sqinter> (P \\<triangleleft> b \\<triangleright> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>  Q \\<or> R) =\n    ((P \\<triangleleft> b \\<triangleright>  Q) \\<or>\n     (P \\<triangleleft> b \\<triangleright>  R))", "by (rule ext) (auto split: cond_splits)"], ["", "lemma ndet_cond_distr: \"(P \\<sqinter> (Q \\<triangleleft> b \\<triangleright> R)) = ((P \\<sqinter> Q) \\<triangleleft> b \\<triangleright> (P \\<sqinter> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> (Q \\<triangleleft> b \\<triangleright>  R)) =\n    (P \\<or> Q \\<triangleleft> b \\<triangleright>  P \\<or> R)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma comp_ndet_l_distr: \"((P \\<sqinter> Q) ;; R) = ((P ;; R) \\<sqinter> (Q ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q ;; R) = ((P ;; R) \\<or> (Q ;; R))", "by (auto simp: fun_eq_iff utp_defs)"], ["", "lemma comp_ndet_r_distr: \"(P ;; (Q \\<sqinter> R)) = ((P ;; Q) \\<sqinter> (P ;; R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; Q \\<or> R) = ((P ;; Q) \\<or> (P ;; R))", "by (auto simp: fun_eq_iff utp_defs)"], ["", "lemma l2_5_1_A: \"\\<forall>X \\<in> S. [X \\<longrightarrow> (\\<Sqinter> S)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>S.\n       \\<forall>A.\n          (X \\<longrightarrow>\n           (\\<lambda>A. A \\<in> \\<Union> {{p. P p} |P. P \\<in> S}))\n           A", "by blast"], ["", "lemma l2_5_1_B: \"(\\<forall> X \\<in> S. [X \\<longrightarrow> P]) \\<longrightarrow> [(\\<Sqinter> S) \\<longrightarrow> P]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>S.\n        \\<forall>A. (X \\<longrightarrow> P) A) \\<longrightarrow>\n    (\\<forall>A.\n        ((\\<lambda>A.\n             A \\<in> \\<Union> {{p. P p} |P. P \\<in> S}) \\<longrightarrow>\n         P)\n         A)", "by blast"], ["", "lemma l2_5_1: \"[(\\<Sqinter> S) \\<longrightarrow> P] \\<longleftrightarrow> (\\<forall> X \\<in> S. [X \\<longrightarrow> P])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A.\n        ((\\<lambda>A.\n             A \\<in> \\<Union> {{p. P p} |P. P \\<in> S}) \\<longrightarrow>\n         P)\n         A) =\n    (\\<forall>X\\<in>S. \\<forall>A. (X \\<longrightarrow> P) A)", "by blast"], ["", "lemma empty_disj: \"\\<Sqinter> {} = Top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<in> \\<Union> {{p. P p} |P. P \\<in> {}}) = false", "by (rule ext) blast"], ["", "lemma l2_5_1_2: \"[P \\<longrightarrow> (\\<Squnion> S)] \\<longleftrightarrow> (\\<forall> X \\<in> S. [P \\<longrightarrow> X])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A.\n        (P \\<longrightarrow>\n         (\\<lambda>A. A \\<in> \\<Inter> {{p. P p} |P. P \\<in> S}))\n         A) =\n    (\\<forall>X\\<in>S. \\<forall>A. (P \\<longrightarrow> X) A)", "by blast"], ["", "lemma empty_conj: \"\\<Squnion> {} = Bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. A \\<in> \\<Inter> {{p. P p} |P. P \\<in> {}}) = true", "by (rule ext) blast"], ["", "lemma l2_5_2: \"((\\<Squnion> S) \\<sqinter> Q) = (\\<Squnion>{P \\<sqinter> Q | P. P\\<in>S})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<in> \\<Inter> {{p. P p} |P. P \\<in> S}) \\<or> Q) =\n    (\\<lambda>A.\n        A \\<in> \\<Inter> {{p. P p} |P. P \\<in> {P \\<or> Q |P. P \\<in> S}})", "by (rule ext) blast"], ["", "lemma l2_5_3: \"((\\<Sqinter> S) \\<squnion> Q) = (\\<Sqinter>{P \\<squnion> Q | P. P \\<in> S})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<in> \\<Union> {{p. P p} |P. P \\<in> S}) \\<and> Q) =\n    (\\<lambda>A.\n        A \\<in> \\<Union> {{p. P p} |P. P \\<in> {P \\<and> Q |P. P \\<in> S}})", "by (rule ext) blast"], ["", "lemma l2_5_4: \"((\\<Sqinter> S) ;; Q) = (\\<Sqinter>{P ;; Q | P. P \\<in> S})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>A. A \\<in> \\<Union> {{p. P p} |P. P \\<in> S}) ;; Q) =\n    (\\<lambda>A.\n        A \\<in> \\<Union> {{p. P p} |P. P \\<in> {P ;; Q |P. P \\<in> S}})", "by (rule ext) blast"], ["", "lemma l2_5_5: \"(Q ;; (\\<Sqinter> S)) = (\\<Sqinter>{Q ;; P | P. P \\<in> S})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Q ;; (\\<lambda>A. A \\<in> \\<Union> {{p. P p} |P. P \\<in> S})) =\n    (\\<lambda>A.\n        A \\<in> \\<Union> {{p. P p} |P. P \\<in> {Q ;; P |P. P \\<in> S}})", "by (rule ext) blast"], ["", "lemma all_idem :\"(\\<^bold>\\<forall>b. \\<^bold>\\<forall>a. P a) = (\\<^bold>\\<forall>a. P a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<forall>b a. P a) = (\\<^bold>\\<forall>a. P a)", "by (simp add: all_def)"], ["", "lemma comp_unit_R [simp]: \"(P ;; \\<Pi>r) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ;; (\\<lambda>(A, A'). A = A')) = P", "by (auto simp: fun_eq_iff utp_defs)"], ["", "lemma comp_unit_L [simp]: \"(\\<Pi>r ;; P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>(A, A'). A = A') ;; P) = P", "by (auto simp: fun_eq_iff utp_defs)"], ["", "lemmas comp_unit_simps = comp_unit_R comp_unit_L"], ["", "lemma not_cond: \"(\\<not>(P \\<triangleleft> b \\<triangleright> Q)) = ((\\<not> P) \\<triangleleft> b \\<triangleright> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (P \\<triangleleft> b \\<triangleright>  Q)) =\n    (\\<not> P \\<triangleleft> b \\<triangleright>  \\<not> Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_conj_not_distr: \n\"((P \\<triangleleft> b \\<triangleright> Q) \\<and> \\<not>(R \\<triangleleft> b \\<triangleright> S)) = ((P \\<and> \\<not>R) \\<triangleleft> b \\<triangleright> (Q \\<and> \\<not>S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) \\<and>\n     \\<not> (R \\<triangleleft> b \\<triangleright>  S)) =\n    (P \\<and> \\<not> R \\<triangleleft> b \\<triangleright> \n        Q \\<and> \\<not> S)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma imp_cond_distr: \"(R \\<longrightarrow> (P \\<triangleleft> b \\<triangleright> Q)) = ((R \\<longrightarrow> P) \\<triangleleft> b \\<triangleright> (R \\<longrightarrow> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R \\<longrightarrow> (P \\<triangleleft> b \\<triangleright>  Q)) =\n    (R \\<longrightarrow> P \\<triangleleft> b \\<triangleright> \n        R \\<longrightarrow> Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_imp_dist: \"((P \\<triangleleft> b \\<triangleright> Q) \\<longrightarrow> R) = ((P \\<longrightarrow> R) \\<triangleleft> b \\<triangleright> (Q \\<longrightarrow> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) \\<longrightarrow> R) =\n    (P \\<longrightarrow> R \\<triangleleft> b \\<triangleright> \n        Q \\<longrightarrow> R)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_conj_distr: \"((P \\<triangleleft> b \\<triangleright> Q) \\<and> R) = ((P \\<and> R) \\<triangleleft> b \\<triangleright> (Q \\<and> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) \\<and> R) =\n    (P \\<and> R \\<triangleleft> b \\<triangleright>  Q \\<and> R)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_disj_distr: \"((P \\<triangleleft> b \\<triangleright> Q) \\<or> R) = ((P \\<or> R) \\<triangleleft> b \\<triangleright> (Q \\<or> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<triangleleft> b \\<triangleright>  Q) \\<or> R) =\n    (P \\<or> R \\<triangleleft> b \\<triangleright>  Q \\<or> R)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_know_b: \"(b \\<and> (P \\<triangleleft> b \\<triangleright> Q)) = (b \\<and> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<and> (P \\<triangleleft> b \\<triangleright>  Q)) = (b \\<and> P)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_know_nb: \"((\\<not> (b)) \\<and> (P \\<triangleleft> b \\<triangleright> Q)) = ((\\<not> (b)) \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> b \\<and> (P \\<triangleleft> b \\<triangleright>  Q)) =\n    (\\<not> b \\<and> Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_ass_if: \"(P \\<triangleleft> b \\<triangleright> Q) = (((b) \\<and> P \\<triangleleft> b \\<triangleright> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>  Q) =\n    (b \\<and> P \\<triangleleft> b \\<triangleright>  Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma cond_ass_else: \"(P \\<triangleleft> b \\<triangleright> Q) = (P \\<triangleleft> b \\<triangleright> ((\\<not>b) \\<and> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<triangleleft> b \\<triangleright>  Q) =\n    (P \\<triangleleft> b \\<triangleright>  \\<not> b \\<and> Q)", "by (rule ext) (auto split: cond_splits)"], ["", "lemma not_true_eq_false: \"(\\<not> true) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> true) = false", "by (rule ext) blast"], ["", "lemma not_false_eq_true: \"(\\<not> false) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> false) = true", "by (rule ext) blast"], ["", "lemma conj_idem: \"((P::'\\<alpha> predicate) \\<and> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> P) = P", "by (rule ext) blast"], ["", "lemma disj_idem: \"((P::'\\<alpha> predicate) \\<or> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> P) = P", "by (rule ext) blast"], ["", "lemma conj_comm: \"((P::'\\<alpha> predicate) \\<and> Q) = (Q \\<and> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q) = (Q \\<and> P)", "by (rule ext) blast"], ["", "lemma disj_comm: \"((P::'\\<alpha> predicate) \\<or> Q) = (Q \\<or> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q) = (Q \\<or> P)", "by (rule ext) blast"], ["", "lemma conj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> predicate) \\<and> Q) = (R \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R \\<Longrightarrow> (P \\<and> Q) = (R \\<and> Q)", "by (rule ext) blast"], ["", "lemma disj_subst: \"P = R \\<Longrightarrow> ((P::'\\<alpha> predicate) \\<or> Q) = (R \\<or> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = R \\<Longrightarrow> (P \\<or> Q) = (R \\<or> Q)", "by (rule ext) blast"], ["", "lemma conj_assoc:\"(((P::'\\<alpha> predicate) \\<and> Q) \\<and> S) = (P \\<and> (Q \\<and> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and> Q) \\<and> S) = (P \\<and> Q \\<and> S)", "by (rule ext) blast"], ["", "lemma disj_assoc:\"(((P::'\\<alpha> predicate) \\<or> Q) \\<or> S) = (P \\<or> (Q \\<or> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<or> Q) \\<or> S) = (P \\<or> Q \\<or> S)", "by (rule ext) blast"], ["", "lemma conj_disj_abs:\"((P::'\\<alpha> predicate) \\<and> (P \\<or> Q)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (P \\<or> Q)) = P", "by (rule ext) blast"], ["", "lemma disj_conj_abs:\"((P::'\\<alpha> predicate) \\<or> (P \\<and> Q)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> P \\<and> Q) = P", "by (rule ext) blast"], ["", "lemma conj_disj_distr:\"((P::'\\<alpha> predicate) \\<and> (Q \\<or> R)) = ((P \\<and> Q) \\<or> (P \\<and> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (Q \\<or> R)) = (P \\<and> Q \\<or> P \\<and> R)", "by (rule ext) blast"], ["", "lemma disj_conj_dsitr:\"((P::'\\<alpha> predicate) \\<or> (Q \\<and> R)) = ((P \\<or> Q) \\<and> (P \\<or> R))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> Q \\<and> R) = ((P \\<or> Q) \\<and> (P \\<or> R))", "by (rule ext) blast"], ["", "lemma true_conj_id:\"(P \\<and> true) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> true) = P", "by (rule ext) blast"], ["", "lemma true_dsij_zero:\"(P \\<or> true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> true) = true", "by (rule ext) blast"], ["", "lemma true_conj_zero:\"(P \\<and> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> false) = false", "by (rule ext) blast"], ["", "lemma true_dsij_id:\"(P \\<or> false) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> false) = P", "by (rule ext) blast"], ["", "lemma imp_vacuous: \"(false \\<longrightarrow> u) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<longrightarrow> u) = true", "by (rule ext) blast"], ["", "lemma p_and_not_p: \"(P \\<and> \\<not> P) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> \\<not> P) = false", "by (rule ext) blast"], ["", "lemma conj_disj_not_abs: \"((P::'\\<alpha> predicate) \\<and> ((\\<not>P) \\<or> Q)) = (P \\<and> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> (\\<not> P \\<or> Q)) = (P \\<and> Q)", "by (rule ext) blast"], ["", "lemma p_or_not_p: \"(P \\<or> \\<not> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<or> \\<not> P) = true", "by (rule ext) blast"], ["", "lemma double_negation: \"(\\<not> \\<not> (P::'\\<alpha> predicate)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> \\<not> P) = P", "by (rule ext) blast"], ["", "lemma not_conj_deMorgans: \"(\\<not> ((P::'\\<alpha> predicate) \\<and> Q)) = ((\\<not> P) \\<or> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (P \\<and> Q)) = (\\<not> P \\<or> \\<not> Q)", "by (rule ext) blast"], ["", "lemma not_disj_deMorgans: \"(\\<not> ((P::'\\<alpha> predicate) \\<or> Q)) = ((\\<not> P) \\<and> (\\<not> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (P \\<or> Q)) = (\\<not> P \\<and> \\<not> Q)", "by (rule ext) blast"], ["", "lemma p_imp_p: \"(P \\<longrightarrow> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longrightarrow> P) = true", "by (rule ext) blast"], ["", "lemma imp_imp: \"((P::'\\<alpha> predicate) \\<longrightarrow> (Q \\<longrightarrow> R)) = ((P \\<and> Q) \\<longrightarrow> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longrightarrow> Q \\<longrightarrow> R) =\n    (P \\<and> Q \\<longrightarrow> R)", "by (rule ext) blast"], ["", "lemma imp_trans: \"((P \\<longrightarrow> Q) \\<and> (Q \\<longrightarrow> R) \\<longrightarrow> P \\<longrightarrow> R) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<longrightarrow> Q) \\<and>\n     (Q \\<longrightarrow> R) \\<longrightarrow>\n     P \\<longrightarrow> R) =\n    true", "by (rule ext) blast"], ["", "lemma p_equiv_p: \"(P \\<longleftrightarrow> P) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longleftrightarrow> P) = true", "by (rule ext) blast"], ["", "lemma equiv_eq: \"((((P::'\\<alpha> predicate) \\<and> Q) \\<or> (\\<not>P \\<and> \\<not>Q)) = true) \\<longleftrightarrow> (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<and> Q \\<or> \\<not> P \\<and> \\<not> Q) = true) = (P = Q)", "by (auto simp add: fun_eq_iff utp_defs)"], ["", "lemma equiv_eq1: \"(((P::'\\<alpha> predicate) \\<longleftrightarrow> Q) = true) \\<longleftrightarrow> (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((P \\<longleftrightarrow> Q) = true) = (P = Q)", "by (auto simp add: fun_eq_iff utp_defs)"], ["", "lemma cond_subst: \"b = c \\<Longrightarrow> (P \\<triangleleft> b \\<triangleright> Q) = (P \\<triangleleft> c \\<triangleright> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = c \\<Longrightarrow>\n    (P \\<triangleleft> b \\<triangleright>  Q) =\n    (P \\<triangleleft> c \\<triangleright>  Q)", "by simp"], ["", "lemma ex_disj_distr: \"((\\<^bold>\\<exists>x. P x) \\<or> (\\<^bold>\\<exists>x. Q x)) = (\\<^bold>\\<exists>x. (P x \\<or> Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>\\<exists>x. P x) \\<or> (\\<^bold>\\<exists>x. Q x)) =\n    (\\<^bold>\\<exists>x. P x \\<or> Q x)", "by (rule ext) blast"], ["", "lemma all_disj_distr: \"((\\<^bold>\\<forall>x. P x) \\<or> (\\<^bold>\\<forall>x. Q)) = (\\<^bold>\\<forall>x. (P x \\<or> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>\\<forall>x. P x) \\<or> (\\<^bold>\\<forall>x. Q)) =\n    (\\<^bold>\\<forall>x. P x \\<or> Q)", "by (rule ext) blast"], ["", "lemma all_conj_distr: \"((\\<^bold>\\<forall>x. P x) \\<and> (\\<^bold>\\<forall>x. Q x)) = (\\<^bold>\\<forall>x. (P x \\<and> Q x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>\\<forall>x. P x) \\<and> (\\<^bold>\\<forall>x. Q x)) =\n    (\\<^bold>\\<forall>x. P x \\<and> Q x)", "by (rule ext) blast"], ["", "lemma all_triv: \"(\\<^bold>\\<forall>x. P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>\\<forall>x. P) = P", "by (rule ext) blast"], ["", "lemma closure_true: \"[true]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. true A", "by blast"], ["", "lemma closure_p_eq_true: \"[P] \\<longleftrightarrow> (P = true)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A. P A) = (P = true)", "by (simp add: fun_eq_iff utp_defs)"], ["", "lemma closure_equiv_eq: \"[P \\<longleftrightarrow> Q] \\<longleftrightarrow> (P = Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A. (P \\<longleftrightarrow> Q) A) = (P = Q)", "by (simp add: fun_eq_iff utp_defs)"], ["", "lemma closure_conj_distr: \"([P] \\<and> [Q]) = [P \\<and> Q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>A. P A) \\<and> (\\<forall>A. Q A)) =\n    (\\<forall>A. (P \\<and> Q) A)", "by blast"], ["", "lemma closure_imp_distr: \"[P \\<longrightarrow> Q] \\<longrightarrow> [P] \\<longrightarrow> [Q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A. (P \\<longrightarrow> Q) A) \\<longrightarrow>\n    (\\<forall>A. P A) \\<longrightarrow> (\\<forall>A. Q A)", "by blast"], ["", "lemma true_iff[simp]: \"(P \\<longleftrightarrow> true) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<longleftrightarrow> true) = P", "by blast"], ["", "lemma true_imp[simp]: \"(true \\<longrightarrow> P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<longrightarrow> P) = P", "by blast"], ["", "end"]]}