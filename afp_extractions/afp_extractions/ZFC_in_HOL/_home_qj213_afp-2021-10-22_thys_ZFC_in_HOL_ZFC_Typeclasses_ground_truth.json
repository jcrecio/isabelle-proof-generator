{"file_name": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL/ZFC_Typeclasses.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL", "problem_names": ["lemma embeddable_classI:\n  fixes f :: \"'a \\<Rightarrow> V\"\n  assumes \"\\<And>x y. f x = f y \\<Longrightarrow> x = y\"\n  shows \"OFCLASS('a, embeddable_class)\"", "lemma inj_V_of_list:\n  assumes \"inj V_of\"\n  shows \"inj (V_of_list V_of)\"", "lemma TC_small [iff]:\n  fixes A :: \"'a set\"\n  shows \"small A\"", "lemma lepoll_UNIV_imp_small: \"X \\<lesssim> (UNIV::'a::small set) \\<Longrightarrow> small X\"", "lemma lepoll_imp_small:\n  fixes A :: \"'a::small set\"\n  assumes \"X \\<lesssim> A\"\n  shows \"small X\""], "translations": [["", "lemma embeddable_classI:\n  fixes f :: \"'a \\<Rightarrow> V\"\n  assumes \"\\<And>x y. f x = f y \\<Longrightarrow> x = y\"\n  shows \"OFCLASS('a, embeddable_class)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, embeddable_class)", "proof (intro_classes, rule exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. inj ?V_of3", "show \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj f", "by (rule injI [OF assms]) assumption"], ["proof (state)\nthis:\n  inj f\n\ngoal:\nNo subgoals!", "qed"], ["", "instance V :: embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, embeddable_class)", "by (rule embeddable_classI [where f=id]) auto"], ["", "instance prod :: (embeddable,embeddable) embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, embeddable_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, embeddable_class)", "have \"inj (\\<lambda>(x,y). \\<langle>V_of1 x, V_of2 y\\<rangle>)\" if \"inj V_of1\" \"inj V_of2\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>)", "using that"], ["proof (prove)\nusing this:\n  inj V_of1\n  inj V_of2\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>)", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, embeddable_class)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)", "show \"OFCLASS('a \\<times> 'b, embeddable_class)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, embeddable_class)", "by intro_classes (meson embeddable_class.ex_inj)"], ["proof (state)\nthis:\n  OFCLASS('a \\<times> 'b, embeddable_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance sum :: (embeddable,embeddable) embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, embeddable_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, embeddable_class)", "have \"inj (case_sum (Inl \\<circ> V_of1) (Inr \\<circ> V_of2))\" if \"inj V_of1\" \"inj V_of2\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n          (ZFC_Cardinals.Inr \\<circ> V_of2))", "using that"], ["proof (prove)\nusing this:\n  inj V_of1\n  inj V_of2\n\ngoal (1 subgoal):\n 1. inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n          (ZFC_Cardinals.Inr \\<circ> V_of2))", "by (auto simp: inj_on_def split: sum.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, embeddable_class)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))", "show \"OFCLASS('a + 'b, embeddable_class)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, embeddable_class)", "by intro_classes (meson embeddable_class.ex_inj)"], ["proof (state)\nthis:\n  OFCLASS('a + 'b, embeddable_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance option :: (embeddable) embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, embeddable_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a option, embeddable_class)", "have \"inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set{V_of x}))\" if \"inj V_of\"\n    for V_of :: \"'a \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set {V_of x}))", "using that"], ["proof (prove)\nusing this:\n  inj V_of\n\ngoal (1 subgoal):\n 1. inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set {V_of x}))", "by (auto simp: inj_on_def split: option.split_asm)"], ["proof (state)\nthis:\n  inj ?V_of \\<Longrightarrow>\n  inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set {?V_of x}))\n\ngoal (1 subgoal):\n 1. OFCLASS('a option, embeddable_class)", "then"], ["proof (chain)\npicking this:\n  inj ?V_of \\<Longrightarrow>\n  inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set {?V_of x}))", "show \"OFCLASS('a option, embeddable_class)\""], ["proof (prove)\nusing this:\n  inj ?V_of \\<Longrightarrow>\n  inj (case_option 0 (\\<lambda>x. ZFC_in_HOL.set {?V_of x}))\n\ngoal (1 subgoal):\n 1. OFCLASS('a option, embeddable_class)", "by intro_classes (meson embeddable_class.ex_inj)"], ["proof (state)\nthis:\n  OFCLASS('a option, embeddable_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec V_of_list where\n  \"V_of_list V_of Nil = 0\"\n| \"V_of_list V_of (x#xs) = \\<langle>V_of x, V_of_list V_of xs\\<rangle>\""], ["", "lemma inj_V_of_list:\n  assumes \"inj V_of\"\n  shows \"inj (V_of_list V_of)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (V_of_list V_of)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (V_of_list V_of)", "note inj_eq [OF assms, simp]"], ["proof (state)\nthis:\n  (V_of ?x = V_of ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. inj (V_of_list V_of)", "have \"x = y\" if \"V_of_list V_of x = V_of_list V_of y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  V_of_list V_of x = V_of_list V_of y\n\ngoal (1 subgoal):\n 1. x = y", "proof (induction x arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. V_of_list V_of [] = V_of_list V_of y \\<Longrightarrow> [] = y\n 2. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   V_of_list V_of x = V_of_list V_of y \\<Longrightarrow>\n                   x = y;\n        V_of_list V_of (a # x) = V_of_list V_of y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "case Nil"], ["proof (state)\nthis:\n  V_of_list V_of [] = V_of_list V_of y\n\ngoal (2 subgoals):\n 1. \\<And>y. V_of_list V_of [] = V_of_list V_of y \\<Longrightarrow> [] = y\n 2. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   V_of_list V_of x = V_of_list V_of y \\<Longrightarrow>\n                   x = y;\n        V_of_list V_of (a # x) = V_of_list V_of y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "then"], ["proof (chain)\npicking this:\n  V_of_list V_of [] = V_of_list V_of y", "show ?case"], ["proof (prove)\nusing this:\n  V_of_list V_of [] = V_of_list V_of y\n\ngoal (1 subgoal):\n 1. [] = y", "by (cases y) auto"], ["proof (state)\nthis:\n  [] = y\n\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   V_of_list V_of x = V_of_list V_of y \\<Longrightarrow>\n                   x = y;\n        V_of_list V_of (a # x) = V_of_list V_of y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   V_of_list V_of x = V_of_list V_of y \\<Longrightarrow>\n                   x = y;\n        V_of_list V_of (a # x) = V_of_list V_of y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "case (Cons a x)"], ["proof (state)\nthis:\n  V_of_list V_of x = V_of_list V_of ?y \\<Longrightarrow> x = ?y\n  V_of_list V_of (a # x) = V_of_list V_of y\n\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   V_of_list V_of x = V_of_list V_of y \\<Longrightarrow>\n                   x = y;\n        V_of_list V_of (a # x) = V_of_list V_of y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "then"], ["proof (chain)\npicking this:\n  V_of_list V_of x = V_of_list V_of ?y \\<Longrightarrow> x = ?y\n  V_of_list V_of (a # x) = V_of_list V_of y", "show ?case"], ["proof (prove)\nusing this:\n  V_of_list V_of x = V_of_list V_of ?y \\<Longrightarrow> x = ?y\n  V_of_list V_of (a # x) = V_of_list V_of y\n\ngoal (1 subgoal):\n 1. a # x = y", "by (cases y) auto"], ["proof (state)\nthis:\n  a # x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V_of_list V_of ?x = V_of_list V_of ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. inj (V_of_list V_of)", "then"], ["proof (chain)\npicking this:\n  V_of_list V_of ?x = V_of_list V_of ?y \\<Longrightarrow> ?x = ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  V_of_list V_of ?x = V_of_list V_of ?y \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. inj (V_of_list V_of)", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj (V_of_list V_of)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance list :: (embeddable) embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, embeddable_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a list, embeddable_class)", "have \"inj (rec_list 0 (\\<lambda>x xs r. \\<langle>V_of x, r\\<rangle>))\" (is \"inj ?f\")\n    if V_of: \"inj V_of\" for V_of :: \"'a \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))", "note inj_eq [OF V_of, simp]"], ["proof (state)\nthis:\n  (V_of ?x = V_of ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))", "have \"x = y\" if \"?f x = ?f y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\n\ngoal (1 subgoal):\n 1. x = y", "proof (induction x arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       rec_list 0 (\\<lambda>x xs. vpair (V_of x)) [] =\n       rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y \\<Longrightarrow>\n       [] = y\n 2. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x))\n                    y \\<Longrightarrow>\n                   x = y;\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "case Nil"], ["proof (state)\nthis:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) [] =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       rec_list 0 (\\<lambda>x xs. vpair (V_of x)) [] =\n       rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y \\<Longrightarrow>\n       [] = y\n 2. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x))\n                    y \\<Longrightarrow>\n                   x = y;\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "then"], ["proof (chain)\npicking this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) [] =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y", "show ?case"], ["proof (prove)\nusing this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) [] =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\n\ngoal (1 subgoal):\n 1. [] = y", "by (cases y) auto"], ["proof (state)\nthis:\n  [] = y\n\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x))\n                    y \\<Longrightarrow>\n                   x = y;\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x))\n                    y \\<Longrightarrow>\n                   x = y;\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "case (Cons a x)"], ["proof (state)\nthis:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  x = ?y\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\n\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>\\<And>y.\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n                   rec_list 0 (\\<lambda>x xs. vpair (V_of x))\n                    y \\<Longrightarrow>\n                   x = y;\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n        rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\\<rbrakk>\n       \\<Longrightarrow> a # x = y", "then"], ["proof (chain)\npicking this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  x = ?y\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y", "show ?case"], ["proof (prove)\nusing this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  x = ?y\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) (a # x) =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) y\n\ngoal (1 subgoal):\n 1. a # x = y", "by (cases y) auto"], ["proof (state)\nthis:\n  a # x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))", "then"], ["proof (chain)\npicking this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  ?x = ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?x =\n  rec_list 0 (\\<lambda>x xs. vpair (V_of x)) ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj (rec_list 0 (\\<lambda>x xs. vpair (V_of x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj ?V_of \\<Longrightarrow>\n  inj (rec_list 0 (\\<lambda>x xs. vpair (?V_of x)))\n\ngoal (1 subgoal):\n 1. OFCLASS('a list, embeddable_class)", "then"], ["proof (chain)\npicking this:\n  inj ?V_of \\<Longrightarrow>\n  inj (rec_list 0 (\\<lambda>x xs. vpair (?V_of x)))", "show \"OFCLASS('a list, embeddable_class)\""], ["proof (prove)\nusing this:\n  inj ?V_of \\<Longrightarrow>\n  inj (rec_list 0 (\\<lambda>x xs. vpair (?V_of x)))\n\ngoal (1 subgoal):\n 1. OFCLASS('a list, embeddable_class)", "by intro_classes (meson embeddable_class.ex_inj)"], ["proof (state)\nthis:\n  OFCLASS('a list, embeddable_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The class of small types\\<close>"], ["", "class small =\n  assumes small: \"small (UNIV::'a set)\"\nbegin"], ["", "subclass embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.embeddable TYPE('a)", "by intro_classes (meson local.small small_def)"], ["", "lemma TC_small [iff]:\n  fixes A :: \"'a set\"\n  shows \"small A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A", "using small smaller_than_small"], ["proof (prove)\nusing this:\n  small UNIV\n  \\<lbrakk>small ?A; ?B \\<subseteq> ?A\\<rbrakk> \\<Longrightarrow> small ?B\n\ngoal (1 subgoal):\n 1. small A", "by blast"], ["", "end"], ["", "context countable\nbegin"], ["", "subclass small"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.small TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. class.small TYPE('a)", "have *: \"inj (ord_of_nat \\<circ> to_nat)\" if \"inj to_nat\"\n    for to_nat :: \"'a \\<Rightarrow> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (ord_of_nat \\<circ> to_nat)", "using that"], ["proof (prove)\nusing this:\n  inj to_nat\n\ngoal (1 subgoal):\n 1. inj (ord_of_nat \\<circ> to_nat)", "by (simp add: inj_compose inj_ord_of_nat)"], ["proof (state)\nthis:\n  inj ?to_nat \\<Longrightarrow> inj (ord_of_nat \\<circ> ?to_nat)\n\ngoal (1 subgoal):\n 1. class.small TYPE('a)", "then"], ["proof (chain)\npicking this:\n  inj ?to_nat \\<Longrightarrow> inj (ord_of_nat \\<circ> ?to_nat)", "show \"class.small TYPE('a)\""], ["proof (prove)\nusing this:\n  inj ?to_nat \\<Longrightarrow> inj (ord_of_nat \\<circ> ?to_nat)\n\ngoal (1 subgoal):\n 1. class.small TYPE('a)", "by intro_classes (metis small_image_nat local.ex_inj the_inv_into_onto)"], ["proof (state)\nthis:\n  class.small TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lepoll_UNIV_imp_small: \"X \\<lesssim> (UNIV::'a::small set) \\<Longrightarrow> small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<lesssim> UNIV \\<Longrightarrow> small X", "by (meson lepoll_iff replacement small smaller_than_small)"], ["", "lemma lepoll_imp_small:\n  fixes A :: \"'a::small set\"\n  assumes \"X \\<lesssim> A\"\n  shows \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "by (metis lepoll_UNIV_imp_small UNIV_I assms lepoll_def subsetI)"], ["", "instance unit :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, small_class)", ".."], ["", "instance bool :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, small_class)", ".."], ["", "instance nat :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, small_class)", ".."], ["", "instance int :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, small_class)", ".."], ["", "instance rat :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(rat, small_class)", ".."], ["", "instance char :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, small_class)", ".."], ["", "instance String.literal :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(String.literal, small_class)", ".."], ["", "instance typerep :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(typerep, small_class)", ".."], ["", "instance prod :: (small,small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, small_class)", "have \"inj (\\<lambda>(x,y). \\<langle>V_of1 x, V_of2 y\\<rangle>)\"\n       \"range (\\<lambda>(x,y). \\<langle>V_of1 x, V_of2 y\\<rangle>) \\<le> elts (VSigma A (\\<lambda>x. B))\"\n    if \"inj V_of1\" \"inj V_of2\" \"range V_of1 \\<le> elts A\" \"range V_of2 \\<le> elts B\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\" and A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>) &&&\n    range (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>)\n    \\<subseteq> elts (vtimes A B)", "using that"], ["proof (prove)\nusing this:\n  inj V_of1\n  inj V_of2\n  range V_of1 \\<subseteq> elts A\n  range V_of2 \\<subseteq> elts B\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>) &&&\n    range (\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>)\n    \\<subseteq> elts (vtimes A B)", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>(x, y).\n                         \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n                    \\<subseteq> elts (vtimes ?A ?B)\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, small_class)", "with small [where 'a='a] small [where 'a='b]"], ["proof (chain)\npicking this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>(x, y).\n                         \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n                    \\<subseteq> elts (vtimes ?A ?B)", "show \"OFCLASS('a \\<times> 'b, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>(x, y).\n                            \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>(x, y).\n                         \\<langle>?V_of1.0 x, ?V_of2.0 y\\<rangle>)\n                    \\<subseteq> elts (vtimes ?A ?B)\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small UNIV; small UNIV;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>(x, y).\n                                  \\<langle>V_of1 x, V_of2 y\\<rangle>);\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>(x, y).\n                               \\<langle>V_of1 x, V_of2 y\\<rangle>)\n                          \\<subseteq> elts (vtimes A B)\\<rbrakk>\n    \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>(x, y).\n                                  \\<langle>V_of1 x, V_of2 y\\<rangle>);\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>(x, y).\n                               \\<langle>V_of1 x, V_of2 y\\<rangle>)\n                          \\<subseteq> elts (vtimes A B)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V_of.\n                         inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of V_ofa x xa.\n       \\<lbrakk>\\<And>V_of1 V_of2 A B.\n                   \\<lbrakk>inj V_of1; inj V_of2;\n                    range V_of1 \\<subseteq> elts A;\n                    range V_of2 \\<subseteq> elts B\\<rbrakk>\n                   \\<Longrightarrow> inj\n(\\<lambda>(x, y). \\<langle>V_of1 x, V_of2 y\\<rangle>);\n        \\<And>V_of1 V_of2 A B.\n           \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n            range V_of2 \\<subseteq> elts B\\<rbrakk>\n           \\<Longrightarrow> range\n                              (\\<lambda>(x, y).\n                                  \\<langle>V_of1 x, V_of2 y\\<rangle>)\n                             \\<subseteq> elts (vtimes A B);\n        inj V_of; range V_of = elts x; x \\<in> UNIV; inj V_ofa;\n        range V_ofa = elts xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis down_raw dual_order.refl)"], ["proof (state)\nthis:\n  OFCLASS('a \\<times> 'b, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance sum :: (small,small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, small_class)", "have \"inj (case_sum (Inl \\<circ> V_of1) (Inr \\<circ> V_of2))\"\n       \"range (case_sum (Inl \\<circ> V_of1) (Inr \\<circ> V_of2)) \\<le> elts (A \\<Uplus> B)\"\n    if \"inj V_of1\" \"inj V_of2\" \"range V_of1 \\<le> elts A\" \"range V_of2 \\<le> elts B\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\" and A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n          (ZFC_Cardinals.Inr \\<circ> V_of2)) &&&\n    range\n     (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n       (ZFC_Cardinals.Inr \\<circ> V_of2))\n    \\<subseteq> elts (A \\<Uplus> B)", "using that"], ["proof (prove)\nusing this:\n  inj V_of1\n  inj V_of2\n  range V_of1 \\<subseteq> elts A\n  range V_of2 \\<subseteq> elts B\n\ngoal (1 subgoal):\n 1. inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n          (ZFC_Cardinals.Inr \\<circ> V_of2)) &&&\n    range\n     (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n       (ZFC_Cardinals.Inr \\<circ> V_of2))\n    \\<subseteq> elts (A \\<Uplus> B)", "by (force simp: inj_on_def split: sum.split)+"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                       (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n                    \\<subseteq> elts (?A \\<Uplus> ?B)\n\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, small_class)", "with small [where 'a='a] small [where 'a='b]"], ["proof (chain)\npicking this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                       (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n                    \\<subseteq> elts (?A \\<Uplus> ?B)", "show \"OFCLASS('a + 'b, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                          (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (case_sum (ZFC_Cardinals.Inl \\<circ> ?V_of1.0)\n                       (ZFC_Cardinals.Inr \\<circ> ?V_of2.0))\n                    \\<subseteq> elts (?A \\<Uplus> ?B)\n\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small UNIV; small UNIV;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n                                (ZFC_Cardinals.Inr \\<circ> V_of2));\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n                             (ZFC_Cardinals.Inr \\<circ> V_of2))\n                          \\<subseteq> elts (A \\<Uplus> B)\\<rbrakk>\n    \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n                                (ZFC_Cardinals.Inr \\<circ> V_of2));\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n                             (ZFC_Cardinals.Inr \\<circ> V_of2))\n                          \\<subseteq> elts (A \\<Uplus> B)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V_of.\n                         inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of V_ofa x xa.\n       \\<lbrakk>\\<And>V_of1 V_of2 A B.\n                   \\<lbrakk>inj V_of1; inj V_of2;\n                    range V_of1 \\<subseteq> elts A;\n                    range V_of2 \\<subseteq> elts B\\<rbrakk>\n                   \\<Longrightarrow> inj\n(case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n  (ZFC_Cardinals.Inr \\<circ> V_of2));\n        \\<And>V_of1 V_of2 A B.\n           \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n            range V_of2 \\<subseteq> elts B\\<rbrakk>\n           \\<Longrightarrow> range\n                              (case_sum (ZFC_Cardinals.Inl \\<circ> V_of1)\n                                (ZFC_Cardinals.Inr \\<circ> V_of2))\n                             \\<subseteq> elts (A \\<Uplus> B);\n        inj V_of; range V_of = elts x; x \\<in> UNIV; inj V_ofa;\n        range V_ofa = elts xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis down_raw dual_order.refl)"], ["proof (state)\nthis:\n  OFCLASS('a + 'b, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance option :: (small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a option, small_class)", "have \"inj (\\<lambda>x. case x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x})\"\n       \"range (\\<lambda>x. case x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x}) \\<le> insert 0 (elts (VPow A))\"\n    if \"inj V_of\" \"range V_of \\<le> elts A\"\n    for V_of :: \"'a \\<Rightarrow> V\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x.\n            case x of None \\<Rightarrow> 0\n            | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x}) &&&\n    range\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x})\n    \\<subseteq> insert 0 (elts (VPow A))", "using that"], ["proof (prove)\nusing this:\n  inj V_of\n  range V_of \\<subseteq> elts A\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>x.\n            case x of None \\<Rightarrow> 0\n            | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x}) &&&\n    range\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x})\n    \\<subseteq> insert 0 (elts (VPow A))", "by (auto simp: inj_on_def split: option.split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>x.\n                            case x of None \\<Rightarrow> 0\n                            | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>x.\n                         case x of None \\<Rightarrow> 0\n                         | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n                    \\<subseteq> insert 0 (elts (VPow ?A))\n\ngoal (1 subgoal):\n 1. OFCLASS('a option, small_class)", "with small [where 'a='a]"], ["proof (chain)\npicking this:\n  small UNIV\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>x.\n                            case x of None \\<Rightarrow> 0\n                            | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>x.\n                         case x of None \\<Rightarrow> 0\n                         | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n                    \\<subseteq> insert 0 (elts (VPow ?A))", "show \"OFCLASS('a option, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>x.\n                            case x of None \\<Rightarrow> 0\n                            | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>x.\n                         case x of None \\<Rightarrow> 0\n                         | Some x \\<Rightarrow> ZFC_in_HOL.set {?V_of x})\n                    \\<subseteq> insert 0 (elts (VPow ?A))\n\ngoal (1 subgoal):\n 1. OFCLASS('a option, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small UNIV;\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>x.\n                                  case x of None \\<Rightarrow> 0\n                                  | Some x \\<Rightarrow>\nZFC_in_HOL.set {V_of x});\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>x.\n                               case x of None \\<Rightarrow> 0\n                               | Some x \\<Rightarrow>\n                                   ZFC_in_HOL.set {V_of x})\n                          \\<subseteq> insert 0 (elts (VPow A))\\<rbrakk>\n    \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>x.\n                                  case x of None \\<Rightarrow> 0\n                                  | Some x \\<Rightarrow>\nZFC_in_HOL.set {V_of x});\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>x.\n                               case x of None \\<Rightarrow> 0\n                               | Some x \\<Rightarrow>\n                                   ZFC_in_HOL.set {V_of x})\n                          \\<subseteq> insert 0 (elts (VPow A))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V_of.\n                         inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of x.\n       \\<lbrakk>\\<And>V_of A.\n                   \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n                   \\<Longrightarrow> inj\n(\\<lambda>x.\n    case x of None \\<Rightarrow> 0\n    | Some x \\<Rightarrow> ZFC_in_HOL.set {V_of x});\n        \\<And>V_of A.\n           \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n           \\<Longrightarrow> range\n                              (\\<lambda>x.\n                                  case x of None \\<Rightarrow> 0\n                                  | Some x \\<Rightarrow>\nZFC_in_HOL.set {V_of x})\n                             \\<subseteq> insert 0 (elts (VPow A));\n        inj V_of; range V_of = elts x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis down_raw elts_vinsert subset_insertI)"], ["proof (state)\nthis:\n  OFCLASS('a option, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance list :: (small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a list, small_class)", "have \"small (range (V_of_list V_of))\"\n    if \"inj V_of\" \"range V_of \\<le> elts A\"\n    for V_of :: \"'a \\<Rightarrow> V\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "have \"range (V_of_list V_of) \\<approx> (UNIV :: 'a list set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (V_of_list V_of) \\<approx> UNIV", "using that"], ["proof (prove)\nusing this:\n  inj V_of\n  range V_of \\<subseteq> elts A\n\ngoal (1 subgoal):\n 1. range (V_of_list V_of) \\<approx> UNIV", "by (simp add: inj_V_of_list)"], ["proof (state)\nthis:\n  range (V_of_list V_of) \\<approx> UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "also"], ["proof (state)\nthis:\n  range (V_of_list V_of) \\<approx> UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "have \"\\<dots> \\<approx> lists (UNIV :: 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<approx> lists UNIV", "by simp"], ["proof (state)\nthis:\n  UNIV \\<approx> lists UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "also"], ["proof (state)\nthis:\n  UNIV \\<approx> lists UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "have \"\\<dots> \\<lesssim> (UNIV :: 'a set) \\<times> (UNIV :: nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV \\<times> UNIV", "proof (cases \"finite (range (V_of::'a \\<Rightarrow> V))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV\n 2. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "case True"], ["proof (state)\nthis:\n  finite (range V_of)\n\ngoal (2 subgoals):\n 1. finite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV\n 2. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "then"], ["proof (chain)\npicking this:\n  finite (range V_of)", "have \"lists (UNIV :: 'a set) \\<lesssim> (UNIV :: nat set)\""], ["proof (prove)\nusing this:\n  finite (range V_of)\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV", "using countable_iff_lepoll countable_image_inj_on that(1) uncountable_infinite"], ["proof (prove)\nusing this:\n  finite (range V_of)\n  countable ?A = (?A \\<lesssim> UNIV)\n  \\<lbrakk>countable (?f ` ?A); inj_on ?f ?A\\<rbrakk>\n  \\<Longrightarrow> countable ?A\n  inj V_of\n  uncountable ?A \\<Longrightarrow> infinite ?A\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV", "by blast"], ["proof (state)\nthis:\n  lists UNIV \\<lesssim> UNIV\n\ngoal (2 subgoals):\n 1. finite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV\n 2. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "then"], ["proof (chain)\npicking this:\n  lists UNIV \\<lesssim> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  lists UNIV \\<lesssim> UNIV\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV \\<times> UNIV", "by (blast intro: lepoll_trans [OF _ lepoll_times2])"], ["proof (state)\nthis:\n  lists UNIV \\<lesssim> UNIV \\<times> UNIV\n\ngoal (1 subgoal):\n 1. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "case False"], ["proof (state)\nthis:\n  infinite (range V_of)\n\ngoal (1 subgoal):\n 1. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "then"], ["proof (chain)\npicking this:\n  infinite (range V_of)", "have \"lists (UNIV :: 'a set) \\<lesssim> (UNIV :: 'a set)\""], ["proof (prove)\nusing this:\n  infinite (range V_of)\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV", "using \\<open>infinite (range V_of)\\<close> eqpoll_imp_lepoll infinite_eqpoll_lists"], ["proof (prove)\nusing this:\n  infinite (range V_of)\n  infinite (range V_of)\n  ?A \\<approx> ?B \\<Longrightarrow> ?A \\<lesssim> ?B\n  infinite ?A \\<Longrightarrow> lists ?A \\<approx> ?A\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV", "by blast"], ["proof (state)\nthis:\n  lists UNIV \\<lesssim> UNIV\n\ngoal (1 subgoal):\n 1. infinite (range V_of) \\<Longrightarrow>\n    lists UNIV \\<lesssim> UNIV \\<times> UNIV", "then"], ["proof (chain)\npicking this:\n  lists UNIV \\<lesssim> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  lists UNIV \\<lesssim> UNIV\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV \\<times> UNIV", "using lepoll_times1 lepoll_trans"], ["proof (prove)\nusing this:\n  lists UNIV \\<lesssim> UNIV\n  ?B \\<noteq> {} \\<Longrightarrow> ?A \\<lesssim> ?A \\<times> ?B\n  \\<lbrakk>?A \\<lesssim> ?B; ?B \\<lesssim> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<lesssim> ?C\n\ngoal (1 subgoal):\n 1. lists UNIV \\<lesssim> UNIV \\<times> UNIV", "by fastforce"], ["proof (state)\nthis:\n  lists UNIV \\<lesssim> UNIV \\<times> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lists UNIV \\<lesssim> UNIV \\<times> UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "finally"], ["proof (chain)\npicking this:\n  range (V_of_list V_of) \\<lesssim> UNIV \\<times> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  range (V_of_list V_of) \\<lesssim> UNIV \\<times> UNIV\n\ngoal (1 subgoal):\n 1. small (range (V_of_list V_of))", "by (simp add: lepoll_imp_small)"], ["proof (state)\nthis:\n  small (range (V_of_list V_of))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> small (range (V_of_list ?V_of))\n\ngoal (1 subgoal):\n 1. OFCLASS('a list, small_class)", "with small [where 'a='a]"], ["proof (chain)\npicking this:\n  small UNIV\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> small (range (V_of_list ?V_of))", "show \"OFCLASS('a list, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n  \\<lbrakk>inj ?V_of; range ?V_of \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> small (range (V_of_list ?V_of))\n\ngoal (1 subgoal):\n 1. OFCLASS('a list, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small UNIV;\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> small (range (V_of_list V_of))\\<rbrakk>\n    \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<And>V_of A.\n        \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n        \\<Longrightarrow> \\<exists>V_ofa.\n                             inj_on V_ofa (range (V_of_list V_of)) \\<and>\n                             V_ofa ` range (V_of_list V_of)\n                             \\<in> range elts\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V_of.\n                         inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of x.\n       \\<lbrakk>\\<And>V_of A.\n                   \\<lbrakk>inj V_of; range V_of \\<subseteq> elts A\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>V_ofa.\n  inj_on V_ofa (range (V_of_list V_of)) \\<and>\n  V_ofa ` range (V_of_list V_of) \\<in> range elts;\n        inj V_of; range V_of = elts x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis inj_V_of_list order_refl small_def small_iff_range)"], ["proof (state)\nthis:\n  OFCLASS('a list, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance \"fun\" :: (small,embeddable) embeddable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, embeddable_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, embeddable_class)", "have \"inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\"\n    if *: \"inj V_of1\" \"inj V_of2\" \"range V_of1 \\<le> elts A\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))", "have \"f u = f' u\"\n      if \"VLambda A (\\<lambda>u. V_of2 (f (inv V_of1 u))) = VLambda A (\\<lambda>x. V_of2 (f' (inv V_of1 x)))\"\n      for f f' :: \"'a \\<Rightarrow> 'b\" and u"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u = f' u", "by (metis inv_f_f rangeI subsetD VLambda_eq_D2 [OF that, of \"V_of1 u\"] *)"], ["proof (state)\nthis:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))", "then"], ["proof (chain)\npicking this:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u", "show ?thesis"], ["proof (prove)\nusing this:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0;\n   range ?V_of1.0 \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, embeddable_class)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0;\n   range ?V_of1.0 \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))", "show \"OFCLASS('a \\<Rightarrow> 'b, embeddable_class)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0;\n   range ?V_of1.0 \\<subseteq> elts ?A\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, embeddable_class)", "by intro_classes (metis embeddable_class.ex_inj small order_refl replacement small_iff)"], ["proof (state)\nthis:\n  OFCLASS('a \\<Rightarrow> 'b, embeddable_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance \"fun\" :: (small,small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, small_class)", "have \"inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\"   (is \"inj ?\\<phi>\")\n       \"range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x)))) \\<le> elts (VPi A (\\<lambda>x. B))\"\n    if *: \"inj V_of1\" \"inj V_of2\" \"range V_of1 \\<le> elts A\" and \"range V_of2 \\<le> elts B\"\n    for V_of1 :: \"'a \\<Rightarrow> V\" and V_of2 :: \"'b \\<Rightarrow> V\" and A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x)))) &&&\n    range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n 2. range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "have \"f u = f' u\"\n      if \"VLambda A (\\<lambda>u. V_of2 (f (inv V_of1 u))) = VLambda A (\\<lambda>x. V_of2 (f' (inv V_of1 x)))\"\n      for f f' :: \"'a \\<Rightarrow> 'b\" and u"], ["proof (prove)\ngoal (1 subgoal):\n 1. f u = f' u", "by (metis inv_f_f rangeI subsetD VLambda_eq_D2 [OF that, of \"V_of1 u\"] *)"], ["proof (state)\nthis:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u\n\ngoal (2 subgoals):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n 2. range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "then"], ["proof (chain)\npicking this:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u", "show \"inj ?\\<phi>\""], ["proof (prove)\nusing this:\n  VLambda A (\\<lambda>u. V_of2 (?f (inv V_of1 u))) =\n  VLambda A (\\<lambda>x. V_of2 (?f' (inv V_of1 x))) \\<Longrightarrow>\n  ?f ?u = ?f' ?u\n\ngoal (1 subgoal):\n 1. inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  inj (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n\ngoal (1 subgoal):\n 1. range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "show \"range ?\\<phi> \\<le> elts (VPi A (\\<lambda>x. B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "using that"], ["proof (prove)\nusing this:\n  inj V_of1\n  inj V_of2\n  range V_of1 \\<subseteq> elts A\n  range V_of2 \\<subseteq> elts B\n\ngoal (1 subgoal):\n 1. range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n    \\<subseteq> elts (VPi A (\\<lambda>x. B))", "by (simp add: VPi_I subset_eq)"], ["proof (state)\nthis:\n  range (\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n  \\<subseteq> elts (VPi A (\\<lambda>x. B))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>f.\n                         VLambda ?A\n                          (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n                    \\<subseteq> elts (VPi ?A (\\<lambda>x. ?B))\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, small_class)", "with small [where 'a='a] small [where 'a='b]"], ["proof (chain)\npicking this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>f.\n                         VLambda ?A\n                          (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n                    \\<subseteq> elts (VPi ?A (\\<lambda>x. ?B))", "show \"OFCLASS('a \\<Rightarrow> 'b, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n  small UNIV\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> inj (\\<lambda>f.\n                            VLambda ?A\n                             (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n  \\<lbrakk>inj ?V_of1.0; inj ?V_of2.0; range ?V_of1.0 \\<subseteq> elts ?A;\n   range ?V_of2.0 \\<subseteq> elts ?B\\<rbrakk>\n  \\<Longrightarrow> range\n                     (\\<lambda>f.\n                         VLambda ?A\n                          (\\<lambda>x. ?V_of2.0 (f (inv ?V_of1.0 x))))\n                    \\<subseteq> elts (VPi ?A (\\<lambda>x. ?B))\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small UNIV; small UNIV;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>f.\n                                  VLambda A\n                                   (\\<lambda>x. V_of2 (f (inv V_of1 x))));\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>f.\n                               VLambda A\n                                (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n                          \\<subseteq> elts (VPi A (\\<lambda>x. B))\\<rbrakk>\n    \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts;\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> inj (\\<lambda>f.\n                                  VLambda A\n                                   (\\<lambda>x. V_of2 (f (inv V_of1 x))));\n     \\<And>V_of1 V_of2 A B.\n        \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n         range V_of2 \\<subseteq> elts B\\<rbrakk>\n        \\<Longrightarrow> range\n                           (\\<lambda>f.\n                               VLambda A\n                                (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n                          \\<subseteq> elts (VPi A (\\<lambda>x. B))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V_of.\n                         inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of V_ofa x xa.\n       \\<lbrakk>\\<And>V_of1 V_of2 A B.\n                   \\<lbrakk>inj V_of1; inj V_of2;\n                    range V_of1 \\<subseteq> elts A;\n                    range V_of2 \\<subseteq> elts B\\<rbrakk>\n                   \\<Longrightarrow> inj\n(\\<lambda>f. VLambda A (\\<lambda>x. V_of2 (f (inv V_of1 x))));\n        \\<And>V_of1 V_of2 A B.\n           \\<lbrakk>inj V_of1; inj V_of2; range V_of1 \\<subseteq> elts A;\n            range V_of2 \\<subseteq> elts B\\<rbrakk>\n           \\<Longrightarrow> range\n                              (\\<lambda>f.\n                                  VLambda A\n                                   (\\<lambda>x. V_of2 (f (inv V_of1 x))))\n                             \\<subseteq> elts (VPi A (\\<lambda>x. B));\n        inj V_of; range V_of = elts x; x \\<in> UNIV; inj V_ofa;\n        range V_ofa = elts xa; xa \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis down_raw dual_order.refl)"], ["proof (state)\nthis:\n  OFCLASS('a \\<Rightarrow> 'b, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance set :: (small) small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS('a set, small_class)", "have 1: \"inj (\\<lambda>x. ZFC_in_HOL.set (V_of ` x))\"\n    if \"inj V_of\" for V_of :: \"'a \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. ZFC_in_HOL.set (V_of ` x))", "by (simp add: inj_on_def inj_image_eq_iff [OF that])"], ["proof (state)\nthis:\n  inj ?V_of \\<Longrightarrow> inj (\\<lambda>x. ZFC_in_HOL.set (?V_of ` x))\n\ngoal (1 subgoal):\n 1. OFCLASS('a set, small_class)", "have 2: \"range (\\<lambda>x. ZFC_in_HOL.set (V_of ` x)) \\<le> elts (VPow A)\"\n    if \"range V_of \\<le> elts A\" for V_of :: \"'a \\<Rightarrow> V\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>x. ZFC_in_HOL.set (V_of ` x)) \\<subseteq> elts (VPow A)", "using that"], ["proof (prove)\nusing this:\n  range V_of \\<subseteq> elts A\n\ngoal (1 subgoal):\n 1. range (\\<lambda>x. ZFC_in_HOL.set (V_of ` x)) \\<subseteq> elts (VPow A)", "by (auto simp: inj_on_def image_subset_iff)"], ["proof (state)\nthis:\n  range ?V_of \\<subseteq> elts ?A \\<Longrightarrow>\n  range (\\<lambda>x. ZFC_in_HOL.set (?V_of ` x)) \\<subseteq> elts (VPow ?A)\n\ngoal (1 subgoal):\n 1. OFCLASS('a set, small_class)", "from small [where 'a='a]"], ["proof (chain)\npicking this:\n  small UNIV", "show \"OFCLASS('a set, small_class)\""], ["proof (prove)\nusing this:\n  small UNIV\n\ngoal (1 subgoal):\n 1. OFCLASS('a set, small_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. small UNIV \\<Longrightarrow> small UNIV", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of.\n       inj V_of \\<and> range V_of \\<in> range elts \\<Longrightarrow>\n    \\<exists>V_of. inj V_of \\<and> range V_of \\<in> range elts", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>V_of x.\n       \\<lbrakk>inj V_of; range V_of = elts x; x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>V_of.\n                            inj V_of \\<and> range V_of \\<in> range elts", "by (metis 1 2 down_raw subsetI)"], ["proof (state)\nthis:\n  OFCLASS('a set, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance real :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS(real, small_class)", "have \"small (range (Rep_real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (range Rep_real)", "by simp"], ["proof (state)\nthis:\n  small (range Rep_real)\n\ngoal (1 subgoal):\n 1. OFCLASS(real, small_class)", "then"], ["proof (chain)\npicking this:\n  small (range Rep_real)", "show \"OFCLASS(real, small_class)\""], ["proof (prove)\nusing this:\n  small (range Rep_real)\n\ngoal (1 subgoal):\n 1. OFCLASS(real, small_class)", "by intro_classes (metis Rep_real_inverse image_inv_f_f inj_on_def replacement)"], ["proof (state)\nthis:\n  OFCLASS(real, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance complex :: small"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, small_class)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OFCLASS(complex, small_class)", "have \"\\<And>c. c \\<in> range (\\<lambda>(x,y). Complex x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. c \\<in> range (\\<lambda>(x, y). Complex x y)", "by (metis case_prod_conv complex.exhaust_sel rangeI)"], ["proof (state)\nthis:\n  ?c \\<in> range (\\<lambda>(x, y). Complex x y)\n\ngoal (1 subgoal):\n 1. OFCLASS(complex, small_class)", "then"], ["proof (chain)\npicking this:\n  ?c \\<in> range (\\<lambda>(x, y). Complex x y)", "show \"OFCLASS(complex, small_class)\""], ["proof (prove)\nusing this:\n  ?c \\<in> range (\\<lambda>(x, y). Complex x y)\n\ngoal (1 subgoal):\n 1. OFCLASS(complex, small_class)", "by intro_classes (meson TC_small replacement smaller_than_small subset_eq)"], ["proof (state)\nthis:\n  OFCLASS(complex, small_class)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}