{"file_name": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL/ZFC_in_HOL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL", "problem_names": ["lemma mem_not_refl [simp]: \"i \\<notin> elts i\"", "lemma mem_not_sym: \"\\<not> (x \\<in> elts y \\<and> y \\<in> elts x)\"", "lemma small_empty [iff]: \"small {}\"", "lemma small_iff_range: \"small X \\<longleftrightarrow> X \\<in> range elts\"", "lemma set_of_elts [simp]: \"set (elts x) = x\"", "lemma elts_of_set [simp]: \"elts (set X) = (if small X then X else {})\"", "lemma down: \"Y \\<subseteq> elts x \\<Longrightarrow> small Y\"", "lemma Union [intro]: \"small X \\<Longrightarrow> small (Union (elts ` X))\"", "lemma Pow: \"small X \\<Longrightarrow> small (set ` Pow X)\"", "lemma replacement [intro,simp]:\n  assumes \"small X\"\n  shows \"small (f ` X)\"", "lemma small_image_iff [simp]: \"inj_on f A \\<Longrightarrow> small (f ` A) \\<longleftrightarrow> small A\"", "lemma inf: \"small (range (g :: nat \\<Rightarrow> V))\"", "lemma small_image_nat_V [simp]: \"small (g ` N)\" for g :: \"nat \\<Rightarrow> V\"", "lemma Finite_V:\n  fixes X :: \"V set\"\n  assumes \"finite X\" shows \"small X\"", "lemma small_insert_V:\n  fixes X :: \"V set\"\n  assumes \"small X\"\n  shows \"small (insert a X)\"", "lemma small_UN_V [simp,intro]:\n  fixes B :: \"'a \\<Rightarrow> V set\"\n  assumes X: \"small X\" and B: \"\\<And>x. x \\<in> X \\<Longrightarrow> small (B x)\"\n  shows \"small (\\<Union>x\\<in>X. B x)\"", "lemma elts_vinsert [simp]: \"elts (vinsert x y) = insert x (elts y)\"", "lemma elts_succ [simp]: \"elts (succ x) = insert x (elts x)\"", "lemma finite_imp_small:\n  assumes \"finite X\" shows \"small X\"", "lemma small_insert:\n  assumes \"small X\"\n  shows \"small (insert a X)\"", "lemma smaller_than_small:\n  assumes \"small A\" \"B \\<subseteq> A\" shows \"small B\"", "lemma small_insert_iff [iff]: \"small (insert a X) \\<longleftrightarrow> small X\"", "lemma small_iff: \"small X \\<longleftrightarrow> (\\<exists>x. X = elts x)\"", "lemma small_elts [iff]: \"small (elts x)\"", "lemma small_diff [iff]: \"small (elts a - X)\"", "lemma small_set [simp]: \"small (list.set xs)\"", "lemma small_upair: \"small {x,y}\"", "lemma small_Un_elts: \"small (elts x \\<union> elts y)\"", "lemma small_eqcong: \"\\<lbrakk>small X; X \\<approx> Y\\<rbrakk> \\<Longrightarrow> small Y\"", "lemma big_UNIV [simp]: \"\\<not> small (UNIV::V set)\" (is  \"\\<not> small ?U\")", "lemma inj_on_set: \"inj_on set (Collect small)\"", "lemma set_injective [simp]: \"\\<lbrakk>small X; small Y\\<rbrakk> \\<Longrightarrow> set X = set Y \\<longleftrightarrow> X=Y\"", "lemma elts_0 [simp]: \"elts 0 = {}\"", "lemma set_empty [simp]: \"set {} = 0\"", "lemma elts_1 [simp]: \"elts 1 = {0}\"", "lemma insert_neq_0 [simp]: \"set (insert a X) = 0 \\<longleftrightarrow> \\<not> small X\"", "lemma elts_eq_empty_iff [simp]: \"elts x = {} \\<longleftrightarrow> x=0\"", "lemma V_equalityI [intro]: \"(\\<And>x. x \\<in> elts a \\<longleftrightarrow> x \\<in> elts b) \\<Longrightarrow> a = b\"", "lemma vsubsetI [intro!]: \"(\\<And>x. x \\<in> elts a \\<Longrightarrow> x \\<in> elts b) \\<Longrightarrow> a \\<le> b\"", "lemma vsubsetD [elim, intro?]: \"a \\<le> b \\<Longrightarrow> c \\<in> elts a \\<Longrightarrow> c \\<in> elts b\"", "lemma rev_vsubsetD: \"c \\<in> elts a \\<Longrightarrow> a \\<le> b \\<Longrightarrow> c \\<in> elts b\"\n  \\<comment> \\<open>The same, with reversed premises for use with @{method erule} -- cf. @{thm rev_mp}.\\<close>", "lemma vsubsetCE [elim,no_atp]: \"a \\<le> b \\<Longrightarrow> (c \\<notin> elts a \\<Longrightarrow> P) \\<Longrightarrow> (c \\<in> elts b \\<Longrightarrow> P) \\<Longrightarrow> P\"\n  \\<comment> \\<open>Classical elimination rule.\\<close>", "lemma set_image_le_iff: \"small A \\<Longrightarrow> set (f ` A) \\<le> B \\<longleftrightarrow> (\\<forall>x\\<in>A. f x \\<in> elts B)\"", "lemma eq0_iff: \"x = 0 \\<longleftrightarrow> (\\<forall>y. y \\<notin> elts x)\"", "lemma less_eq_V_0_iff [simp]: \"x \\<le> 0 \\<longleftrightarrow> x = 0\" for x::V", "lemma subset_iff_less_eq_V:\n  assumes \"small B\" shows \"A \\<subseteq> B \\<longleftrightarrow> set A \\<le> set B \\<and> small A\"", "lemma small_Collect [simp]: \"small A \\<Longrightarrow> small {x \\<in> A. P x}\"", "lemma small_Union_iff: \"small (\\<Union>(elts ` X)) \\<longleftrightarrow> small X\"", "lemma not_less_0 [iff]:\n  fixes x::V shows \"\\<not> x < 0\"", "lemma le_0 [iff]:\n  fixes x::V shows \"0 \\<le> x\"", "lemma min_0L [simp]: \"min 0 n = 0\" for n :: V", "lemma min_0R [simp]: \"min n 0 = 0\" for n :: V", "lemma neq0_conv: \"\\<And>n::V. n \\<noteq> 0 \\<longleftrightarrow> 0 < n\"", "lemma VPow_iff [iff]: \"y \\<in> elts (VPow x) \\<longleftrightarrow> y \\<le> x\"", "lemma VPow_le_VPow_iff [simp]: \"VPow a \\<le> VPow b \\<longleftrightarrow> a \\<le> b\"", "lemma elts_VPow: \"elts (VPow x) = set ` Pow (elts x)\"", "lemma small_sup_iff [simp]: \"small (X \\<union> Y) \\<longleftrightarrow> small X \\<and> small Y\" for X::\"V set\"", "lemma elts_sup_iff [simp]: \"elts (x \\<squnion> y) = elts x \\<union> elts y\"", "lemma trad_foundation:\n  assumes z: \"z \\<noteq> 0\" shows \"\\<exists>w. w \\<in> elts z \\<and> w \\<sqinter> z = 0\"", "lemma V_disjoint_iff: \"x \\<sqinter> y = 0 \\<longleftrightarrow> elts x \\<inter> elts y = {}\"", "lemma bdd_above_iff_small [simp]: \"bdd_above X = small X\" for X::\"V set\"", "lemma Sup_upper: \"\\<lbrakk>x \\<in> A; small A\\<rbrakk> \\<Longrightarrow> x \\<le> \\<Squnion>A\" for A::\"V set\"", "lemma Sup_least:\n  fixes z::V shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow> \\<Squnion>A \\<le> z\"", "lemma Sup_empty [simp]: \"\\<Squnion>{} = (0::V)\"", "lemma elts_Sup [simp]: \"small X \\<Longrightarrow> elts (\\<Squnion> X) = \\<Union>(elts ` X)\"", "lemma sup_V_0_left [simp]: \"0 \\<squnion> a = a\" and sup_V_0_right [simp]: \"a \\<squnion> 0 = a\" for a::V", "lemma Sup_V_insert:\n  fixes x::V assumes \"small A\" shows \"\\<Squnion>(insert x A) = x \\<squnion> \\<Squnion>A\"", "lemma Sup_Un_distrib: \"\\<lbrakk>small A; small B\\<rbrakk> \\<Longrightarrow> \\<Squnion>(A \\<union> B) = \\<Squnion>A \\<squnion> \\<Squnion>B\" for A::\"V set\"", "lemma SUP_sup_distrib:\n  fixes f :: \"V \\<Rightarrow> V\"\n  shows \"small A \\<Longrightarrow> (SUP x\\<in>A. f x \\<squnion> g x) = \\<Squnion> (f ` A) \\<squnion> \\<Squnion> (g ` A)\"", "lemma SUP_const [simp]: \"(SUP y \\<in> A. a) = (if A = {} then (0::V) else a)\"", "lemma cSUP_subset_mono:\n  fixes f :: \"'a \\<Rightarrow> V set\" and g :: \"'a \\<Rightarrow> V set\"\n  shows \"\\<lbrakk>A \\<subseteq> B; \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<le> g x\\<rbrakk> \\<Longrightarrow> \\<Squnion> (f ` A) \\<le> \\<Squnion> (g ` B)\"", "lemma mem_Sup_iff [iff]: \"x \\<in> elts (\\<Squnion>X) \\<longleftrightarrow> x \\<in> \\<Union> (elts ` X) \\<and> small X\"", "lemma cSUP_UNION:\n  fixes B :: \"V \\<Rightarrow> V set\" and f :: \"V \\<Rightarrow> V\"\n  assumes ne: \"small A\" and bdd_UN: \"small (\\<Union>x\\<in>A. f ` B x)\"\n  shows \"\\<Squnion>(f ` (\\<Union>x\\<in>A. B x)) = \\<Squnion>((\\<lambda>x. \\<Squnion>(f ` B x)) ` A)\"", "lemma Sup_subset_mono: \"small B \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> Sup A \\<le> Sup B\" for A::\"V set\"", "lemma Sup_le_iff: \"small A \\<Longrightarrow> Sup A \\<le> a \\<longleftrightarrow> (\\<forall>x\\<in>A. x \\<le> a)\" for A::\"V set\"", "lemma SUP_le_iff: \"small (f ` A) \\<Longrightarrow> \\<Squnion>(f ` A) \\<le> u \\<longleftrightarrow> (\\<forall>x\\<in>A. f x \\<le> u)\" for f :: \"V \\<Rightarrow> V\"", "lemma Sup_eq_0_iff [simp]: \"\\<Squnion>A = 0 \\<longleftrightarrow> A \\<subseteq> {0} \\<or> \\<not> small A\" for A :: \"V set\"", "lemma Sup_Union_commute:\n  fixes f :: \"V \\<Rightarrow> V set\"\n  assumes \"small A\" \"\\<And>x. x\\<in>A \\<Longrightarrow> small (f x)\"\n  shows \"\\<Squnion> (\\<Union>x\\<in>A. f x) = (SUP x\\<in>A. \\<Squnion> (f x))\"", "lemma Sup_eq_Sup:\n  fixes B :: \"V set\"\n  assumes \"B \\<subseteq> A\" \"small A\" and *: \"\\<And>x. x \\<in> A \\<Longrightarrow> \\<exists>y \\<in> B. x \\<le> y\"\n  shows \"Sup A = Sup B\"", "lemma vinsert_not_empty [simp]: \"vinsert a A \\<noteq> 0\"\n  and empty_not_vinsert [simp]: \"0 \\<noteq> vinsert a A\"", "lemma succ_not_0 [simp]: \"succ n \\<noteq> 0\" and zero_not_succ [simp]: \"0 \\<noteq> succ n\"", "lemma succ_ne_self [simp]: \"i \\<noteq> succ i\"", "lemma succ_notin_self: \"succ i \\<notin> elts i\"", "lemma le_succE: \"succ i \\<le> succ j \\<Longrightarrow> i \\<le> j\"", "lemma succ_inject_iff [iff]: \"succ i = succ j \\<longleftrightarrow> i = j\"", "lemma inj_succ: \"inj succ\"", "lemma succ_neq_zero: \"succ x \\<noteq> 0\"", "lemma pred_succ [simp]: \"pred (succ i) = i\"", "lemma Transset_0 [iff]: \"Transset 0\"", "lemma Transset_succ [intro]:\n  assumes \"Transset x\" shows \"Transset (succ x)\"", "lemma Transset_Sup:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Transset x\" shows \"Transset (\\<Squnion>X)\"", "lemma Transset_sup:\n  assumes \"Transset x\" \"Transset y\" shows \"Transset (x \\<squnion> y)\"", "lemma Transset_inf: \"\\<lbrakk>Transset i; Transset j\\<rbrakk> \\<Longrightarrow> Transset (i \\<sqinter> j)\"", "lemma Transset_VPow: \"Transset(i) \\<Longrightarrow> Transset(VPow(i))\"", "lemma Transset_Inf: \"(\\<And>i. i \\<in> A \\<Longrightarrow> Transset i) \\<Longrightarrow> Transset (\\<Sqinter> A)\"", "lemma Transset_SUP: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow> Transset (\\<Squnion> (B ` A))\"", "lemma Transset_INT: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow> Transset (\\<Sqinter> (B ` A))\"", "lemma Ord_0 [iff]: \"Ord 0\"", "lemma Ord_succ [intro]:\n  assumes \"Ord x\" shows \"Ord (succ x)\"", "lemma Ord_Sup:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Ord x\" shows \"Ord (\\<Squnion>X)\"", "lemma Ord_Union:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Ord x\" \"small X\" shows \"Ord (set (\\<Union> (elts ` X)))\"", "lemma Ord_sup:\n  assumes \"Ord x\" \"Ord y\" shows \"Ord (x \\<squnion> y)\"", "lemma big_ON [simp]: \"\\<not> small ON\"", "lemma Ord_1 [iff]: \"Ord 1\"", "lemma OrdmemD: \"Ord k \\<Longrightarrow> j \\<in> elts k \\<Longrightarrow> j < k\"", "lemma Ord_trans: \"\\<lbrakk> i \\<in> elts j;  j \\<in> elts k;  Ord k \\<rbrakk>  \\<Longrightarrow> i \\<in> elts k\"", "lemma mem_0_Ord:\n  assumes k: \"Ord k\" and knz: \"k \\<noteq> 0\" shows \"0 \\<in> elts k\"", "lemma Ord_in_Ord: \"\\<lbrakk> Ord k;  m \\<in> elts k \\<rbrakk>  \\<Longrightarrow> Ord m\"", "lemma OrdI: \"\\<lbrakk>Transset i; \\<And>x. x \\<in> elts i \\<Longrightarrow> Transset x\\<rbrakk> \\<Longrightarrow> Ord i\"", "lemma Ord_is_Transset: \"Ord i \\<Longrightarrow> Transset i\"", "lemma Ord_contains_Transset: \"\\<lbrakk>Ord i; j \\<in> elts i\\<rbrakk> \\<Longrightarrow> Transset j\"", "lemma ON_imp_Ord:\n  assumes \"H \\<subseteq> ON\" \"x \\<in> H\"\n  shows \"Ord x\"", "lemma elts_subset_ON: \"Ord \\<alpha> \\<Longrightarrow> elts \\<alpha> \\<subseteq> ON\"", "lemma Transset_pred [simp]: \"Transset x \\<Longrightarrow> \\<Squnion>(elts (succ x)) = x\"", "lemma Ord_pred [simp]: \"Ord \\<beta> \\<Longrightarrow> \\<Squnion> (insert \\<beta> (elts \\<beta>)) = \\<beta>\"", "lemma Ord_induct [consumes 1, case_names step]:\n  assumes k: \"Ord k\"\n      and step: \"\\<And>x.\\<lbrakk> Ord x; \\<And>y. y \\<in> elts x \\<Longrightarrow> P y \\<rbrakk>  \\<Longrightarrow> P x\"\n    shows \"P k\"", "lemma Ord_linear: \"Ord k \\<Longrightarrow> Ord l \\<Longrightarrow> k \\<in> elts l \\<or> k=l \\<or> l \\<in> elts k\"", "lemma Ord_linear_lt:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (lt) \"k < l\" | (eq) \"k=l\" | (gt) \"l < k\"", "lemma Ord_linear2:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (lt) \"k < l\" | (ge) \"l \\<le> k\"", "lemma Ord_linear_le:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (le) \"k \\<le> l\" | (ge) \"l \\<le> k\"", "lemma union_less_iff [simp]: \"\\<lbrakk>Ord i; Ord j\\<rbrakk> \\<Longrightarrow> i \\<squnion> j < k \\<longleftrightarrow> i<k \\<and> j<k\"", "lemma Ord_mem_iff_lt: \"Ord k \\<Longrightarrow> Ord l \\<Longrightarrow> k \\<in> elts l \\<longleftrightarrow> k < l\"", "lemma Ord_Collect_lt: \"Ord \\<alpha> \\<Longrightarrow> {\\<xi>. Ord \\<xi> \\<and> \\<xi> < \\<alpha>} = elts \\<alpha>\"", "lemma Ord_not_less: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> \\<not> x < y \\<longleftrightarrow> y \\<le> x\"", "lemma Ord_not_le: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> \\<not> x \\<le> y \\<longleftrightarrow> y < x\"", "lemma le_succ_iff: \"Ord i \\<Longrightarrow> Ord j \\<Longrightarrow> succ i \\<le> succ j \\<longleftrightarrow> i \\<le> j\"", "lemma succ_le_iff: \"Ord i \\<Longrightarrow> Ord j \\<Longrightarrow> succ i \\<le> j \\<longleftrightarrow> i < j\"", "lemma succ_in_Sup_Ord:\n  assumes eq: \"succ \\<beta> = \\<Squnion>A\" and \"small A\" \"A \\<subseteq> ON\" \"Ord \\<beta>\"\n  shows \"succ \\<beta> \\<in> A\"", "lemma zero_in_succ [simp,intro]: \"Ord i \\<Longrightarrow> 0 \\<in> elts (succ i)\"", "lemma Ord_finite_Sup: \"\\<lbrakk>finite A; A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<Squnion>A \\<in> A\"", "lemma ord_of_nat_eq_initial: \"ord_of_nat n = set (ord_of_nat ` {..<n})\"", "lemma mem_ord_of_nat_iff [simp]: \"x \\<in> elts (ord_of_nat n) \\<longleftrightarrow> (\\<exists>m<n. x = ord_of_nat m)\"", "lemma elts_ord_of_nat: \"elts (ord_of_nat k) = ord_of_nat ` {..<k}\"", "lemma Ord_equality: \"Ord i \\<Longrightarrow> i = \\<Squnion> (succ ` elts i)\"", "lemma Ord_ord_of_nat [simp]: \"Ord (ord_of_nat k)\"", "lemma ord_of_nat_equality: \"ord_of_nat n = \\<Squnion> ((succ \\<circ> ord_of_nat) ` {..<n})\"", "lemma elts_\\<omega>: \"elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\"", "lemma nat_into_Ord [simp]: \"n \\<in> elts \\<omega> \\<Longrightarrow> Ord n\"", "lemma Sup_\\<omega>: \"\\<Squnion>(elts \\<omega>) = \\<omega>\"", "lemma Ord_\\<omega> [iff]: \"Ord \\<omega>\"", "lemma zero_in_omega [iff]: \"0 \\<in> elts \\<omega>\"", "lemma succ_in_omega [simp]: \"n \\<in> elts \\<omega> \\<Longrightarrow> succ n \\<in> elts \\<omega>\"", "lemma ord_of_eq_0: \"ord_of_nat j = 0 \\<Longrightarrow> j = 0\"", "lemma ord_of_nat_le_omega: \"ord_of_nat n \\<le> \\<omega>\"", "lemma ord_of_eq_0_iff [simp]: \"ord_of_nat n = 0 \\<longleftrightarrow> n=0\"", "lemma ord_of_nat_inject [iff]: \"ord_of_nat i = ord_of_nat j \\<longleftrightarrow> i=j\"", "lemma small_image_nat [simp]:\n  fixes N :: \"nat set\" shows \"small (g ` N)\"", "lemma finite_Ord_omega: \"\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts \\<alpha>)\"", "lemma infinite_Ord_omega: \"Ord \\<alpha> \\<Longrightarrow> infinite (elts \\<alpha>) \\<Longrightarrow> \\<omega> \\<le> \\<alpha>\"", "lemma ord_of_minus_1: \"n > 0 \\<Longrightarrow> ord_of_nat n = succ (ord_of_nat (n - 1))\"", "lemma card_ord_of_nat [simp]: \"card (elts (ord_of_nat m)) = m\"", "lemma ord_of_nat_\\<omega> [iff]:\"ord_of_nat n \\<in> elts \\<omega>\"", "lemma succ_\\<omega>_iff [iff]: \"succ n \\<in> elts \\<omega> \\<longleftrightarrow> n \\<in> elts \\<omega>\"", "lemma \\<omega>_gt0 [simp]: \"\\<omega> > 0\"", "lemma \\<omega>_gt1 [simp]: \"\\<omega> > 1\"", "lemma zero_not_Limit [iff]: \"\\<not> Limit 0\"", "lemma not_succ_Limit [simp]: \"\\<not> Limit(succ i)\"", "lemma Limit_is_Ord: \"Limit \\<xi> \\<Longrightarrow> Ord \\<xi>\"", "lemma succ_in_Limit_iff: \"Limit \\<xi> \\<Longrightarrow> succ \\<alpha> \\<in> elts \\<xi> \\<longleftrightarrow> \\<alpha> \\<in> elts \\<xi>\"", "lemma Limit_eq_Sup_self [simp]: \"Limit i \\<Longrightarrow> Sup (elts i) = i\"", "lemma zero_less_Limit: \"Limit \\<beta> \\<Longrightarrow> 0 < \\<beta>\"", "lemma non_Limit_ord_of_nat [iff]: \"\\<not> Limit (ord_of_nat m)\"", "lemma Limit_omega [iff]: \"Limit \\<omega>\"", "lemma omega_nonzero [simp]: \"\\<omega> \\<noteq> 0\"", "lemma Ord_cases_lemma:\n  assumes \"Ord k\" shows \"k = 0 \\<or> (\\<exists>j. k = succ j) \\<or> Limit k\"", "lemma Ord_cases [cases type: V, case_names 0 succ limit]:\n  assumes \"Ord k\"\n  obtains \"k = 0\" | l where \"Ord l\" \"succ l = k\" | \"Limit k\"", "lemma non_succ_LimitI:\n  assumes \"i\\<noteq>0\" \"Ord(i)\" \"\\<And>y. succ(y) \\<noteq> i\"\n  shows \"Limit(i)\"", "lemma Ord_induct3 [consumes 1, case_names 0 succ Limit, induct type: V]:\n  assumes \\<alpha>: \"Ord \\<alpha>\"\n    and P: \"P 0\" \"\\<And>\\<alpha>. \\<lbrakk>Ord \\<alpha>; P \\<alpha>\\<rbrakk> \\<Longrightarrow> P (succ \\<alpha>)\"\n           \"\\<And>\\<alpha>. \\<lbrakk>Limit \\<alpha>; \\<And>\\<xi>. \\<xi> \\<in> elts \\<alpha> \\<Longrightarrow> P \\<xi>\\<rbrakk> \\<Longrightarrow> P (SUP \\<xi> \\<in> elts \\<alpha>. \\<xi>)\"\n  shows \"P \\<alpha>\"", "lemma\n  assumes \"Ord k\" \"P k\"\n  shows Ord_LeastI: \"P (LEAST i. Ord i \\<and> P i)\" and Ord_Least_le: \"(LEAST i. Ord i \\<and> P i) \\<le> k\"", "lemma Ord_Least:\n  assumes \"Ord k\" \"P k\"\n  shows \"Ord (LEAST i. Ord i \\<and> P i)\"", "lemma Ord_LeastI_ex: \"\\<exists>i. Ord i \\<and> P i \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i)\"", "lemma Ord_LeastI2:\n  \"\\<lbrakk>Ord a; P a; \\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x\\<rbrakk> \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)\"", "lemma Ord_LeastI2_ex:\n  \"\\<exists>a. Ord a \\<and> P a \\<Longrightarrow> (\\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x) \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)\"", "lemma Ord_LeastI2_wellorder:\n  assumes \"Ord a\" \"P a\"\n  and \"\\<And>a. \\<lbrakk> P a; \\<forall>b. Ord b \\<and> P b \\<longrightarrow> a \\<le> b \\<rbrakk> \\<Longrightarrow> Q a\"\n  shows \"Q (LEAST i. Ord i \\<and> P i)\"", "lemma Ord_LeastI2_wellorder_ex:\n  assumes \"\\<exists>x. Ord x \\<and> P x\"\n  and \"\\<And>a. \\<lbrakk> P a; \\<forall>b. Ord b \\<and> P b \\<longrightarrow> a \\<le> b \\<rbrakk> \\<Longrightarrow> Q a\"\n  shows \"Q (LEAST i. Ord i \\<and> P i)\"", "lemma not_less_Ord_Least: \"\\<lbrakk>k < (LEAST x. Ord x \\<and> P x); Ord k\\<rbrakk> \\<Longrightarrow> \\<not> P k\"", "lemma exists_Ord_Least_iff: \"(\\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>) \\<longleftrightarrow> (\\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<and> (\\<forall>\\<beta> < \\<alpha>. Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma Ord_mono_imp_increasing:\n  assumes fun_hD: \"h \\<in> D \\<rightarrow> D\"\n    and mono_h: \"strict_mono_on h D\" \n    and \"D \\<subseteq> ON\" and \\<nu>: \"\\<nu> \\<in> D\"\n  shows \"\\<nu> \\<le> h \\<nu>\"", "lemma le_Sup_iff:\n  assumes \"A \\<subseteq> ON\" \"Ord x\" \"small A\" shows \"x \\<le> \\<Squnion>A \\<longleftrightarrow> (\\<forall>y \\<in> ON. y<x \\<longrightarrow> (\\<exists>a\\<in>A. y < a))\"", "lemma le_SUP_iff: \"\\<lbrakk>f ` A \\<subseteq> ON; Ord x; small A\\<rbrakk> \\<Longrightarrow> x \\<le> \\<Squnion>(f ` A) \\<longleftrightarrow> (\\<forall>y \\<in> ON. y<x \\<longrightarrow> (\\<exists>i\\<in>A. y < f i))\"", "lemma transrec: \"transrec H a = H (\\<lambda>x \\<in> elts a. transrec H x) a\"", "lemma def_transrec:\n    \"\\<lbrakk>\\<And>x. f x \\<equiv> transrec H x\\<rbrakk> \\<Longrightarrow> f a = H(\\<lambda>x \\<in> elts a. f x) a\"", "lemma eps_induct [case_names step]:\n  assumes \"\\<And>x. (\\<And>y. y \\<in> elts x \\<Longrightarrow> P y) \\<Longrightarrow> P x\"\n  shows \"P a\"", "lemma Vfrom: \"Vfrom a i = a \\<squnion> \\<Squnion>((\\<lambda>j. VPow(Vfrom a j)) ` elts i)\"", "lemma Vfrom_0 [simp]: \"Vfrom a 0 = a\"", "lemma Vset: \"Vset i = \\<Squnion>((\\<lambda>j. VPow(Vset j)) ` elts i)\"", "lemma Vfrom_mono1:\n  assumes \"a \\<le> b\" shows \"Vfrom a i \\<le> Vfrom b i\"", "lemma Vfrom_mono2: \"Vfrom a i \\<le> Vfrom a (i \\<squnion> j)\"", "lemma Vfrom_mono: \"\\<lbrakk>Ord i; a\\<le>b; i\\<le>j\\<rbrakk> \\<Longrightarrow> Vfrom a i \\<le> Vfrom b j\"", "lemma Transset_Vfrom: \"Transset(A) \\<Longrightarrow> Transset(Vfrom A i)\"", "lemma Transset_Vset [simp]: \"Transset(Vset i)\"", "lemma Vfrom_sup: \"Vfrom a (i \\<squnion> j) = Vfrom a i \\<squnion> Vfrom a j\"", "lemma Vfrom_succ_Ord:\n  assumes \"Ord i\" shows \"Vfrom a (succ i) = a \\<squnion> VPow(Vfrom a i)\"", "lemma Vset_succ: \"Ord i \\<Longrightarrow> Vset(succ(i)) = VPow(Vset(i))\"", "lemma Vfrom_Sup:\n  assumes \"X \\<noteq> {}\" \"small X\"\n  shows \"Vfrom a (Sup X) = (SUP y\\<in>X. Vfrom a y)\"", "lemma Limit_Vfrom_eq:\n    \"Limit(i) \\<Longrightarrow> Vfrom a i = (SUP y \\<in> elts i. Vfrom a y)\""], "translations": [["", "lemma mem_not_refl [simp]: \"i \\<notin> elts i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> elts i", "using wf_not_refl [OF foundation]"], ["proof (prove)\nusing this:\n  (?a, ?a) \\<notin> {(x, y). x \\<in> elts y}\n\ngoal (1 subgoal):\n 1. i \\<notin> elts i", "by force"], ["", "lemma mem_not_sym: \"\\<not> (x \\<in> elts y \\<and> y \\<in> elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> elts y \\<and> y \\<in> elts x)", "using wf_not_sym [OF foundation]"], ["proof (prove)\nusing this:\n  (?a, ?x) \\<in> {(x, y). x \\<in> elts y} \\<Longrightarrow>\n  (?x, ?a) \\<notin> {(x, y). x \\<in> elts y}\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> elts y \\<and> y \\<in> elts x)", "by force"], ["", "text \\<open>A set is small if it can be injected into the extension of a V-set.\\<close>"], ["", "definition small :: \"'a set \\<Rightarrow> bool\" \n  where \"small X \\<equiv> \\<exists>V_of :: 'a \\<Rightarrow> V. inj_on V_of X \\<and> V_of ` X \\<in> range elts\""], ["", "lemma small_empty [iff]: \"small {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small {}", "by (simp add: small_def down_raw)"], ["", "lemma small_iff_range: \"small X \\<longleftrightarrow> X \\<in> range elts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X = (X \\<in> range elts)", "apply (simp add: small_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>V_of. inj_on V_of X \\<and> V_of ` X \\<in> range elts) =\n    (X \\<in> range elts)", "by (metis inj_on_id2 replacement_raw the_inv_into_onto)"], ["", "text\\<open>Small classes can be mapped to sets.\\<close>"], ["", "definition   \"set X \\<equiv> (if small X then inv elts X else inv elts {})\""], ["", "lemma set_of_elts [simp]: \"set (elts x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (elts x) = x", "by (force simp add: ext set_def f_inv_into_f small_def)"], ["", "lemma elts_of_set [simp]: \"elts (set X) = (if small X then X else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (set X) = (if small X then X else {})", "by (simp add: ZFC_in_HOL.set_def down_raw f_inv_into_f small_iff_range)"], ["", "lemma down: \"Y \\<subseteq> elts x \\<Longrightarrow> small Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> elts x \\<Longrightarrow> small Y", "by (simp add: down_raw small_iff_range)"], ["", "lemma Union [intro]: \"small X \\<Longrightarrow> small (Union (elts ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X \\<Longrightarrow> small (\\<Union> (elts ` X))", "by (simp add: Union_raw small_iff_range)"], ["", "lemma Pow: \"small X \\<Longrightarrow> small (set ` Pow X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X \\<Longrightarrow> small (set ` Pow X)", "unfolding small_iff_range"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> range elts \\<Longrightarrow> set ` Pow X \\<in> range elts", "using Pow_raw set_def down"], ["proof (prove)\nusing this:\n  ?X \\<in> range elts \\<Longrightarrow> inv elts ` Pow ?X \\<in> range elts\n  set ?X \\<equiv> if small ?X then inv elts ?X else inv elts {}\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n\ngoal (1 subgoal):\n 1. X \\<in> range elts \\<Longrightarrow> set ` Pow X \\<in> range elts", "by force"], ["", "declare replacement_raw [intro,simp]"], ["", "lemma replacement [intro,simp]:\n  assumes \"small X\"\n  shows \"small (f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (f ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (f ` X)", "let ?A = \"inv_into X f ` (f ` X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. small (f ` X)", "have AX: \"?A \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into X f ` f ` X \\<subseteq> X", "by (simp add: image_subsetI inv_into_into)"], ["proof (state)\nthis:\n  inv_into X f ` f ` X \\<subseteq> X\n\ngoal (1 subgoal):\n 1. small (f ` X)", "have inj: \"inj_on f ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (inv_into X f ` f ` X)", "by (simp add: f_inv_into_f inj_on_def)"], ["proof (state)\nthis:\n  inj_on f (inv_into X f ` f ` X)\n\ngoal (1 subgoal):\n 1. small (f ` X)", "have injo: \"inj_on (inv_into X f) (f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (inv_into X f) (f ` X)", "using inj_on_inv_into"], ["proof (prove)\nusing this:\n  ?B \\<subseteq> ?f ` ?A \\<Longrightarrow> inj_on (inv_into ?A ?f) ?B\n\ngoal (1 subgoal):\n 1. inj_on (inv_into X f) (f ` X)", "by blast"], ["proof (state)\nthis:\n  inj_on (inv_into X f) (f ` X)\n\ngoal (1 subgoal):\n 1. small (f ` X)", "have \"\\<exists>V_of. inj_on V_of (f ` X) \\<and> V_of ` f ` X \\<in> range elts\"\n    if \"inj_on V_of X\" and \"V_of ` X = elts x\"\n    for V_of :: \"'a \\<Rightarrow> V\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of. inj_on V_of (f ` X) \\<and> V_of ` f ` X \\<in> range elts", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ?V_of (f ` X)\n 2. ?V_of ` f ` X \\<in> range elts", "show \"inj_on (V_of \\<circ> inv_into X f) (f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (V_of \\<circ> inv_into X f) (f ` X)", "by (meson \\<open>inv_into X f ` f ` X \\<subseteq> X\\<close> comp_inj_on inj_on_subset injo that)"], ["proof (state)\nthis:\n  inj_on (V_of \\<circ> inv_into X f) (f ` X)\n\ngoal (1 subgoal):\n 1. (V_of \\<circ> inv_into X f) ` f ` X \\<in> range elts", "have \"(\\<lambda>x. V_of (inv_into X f (f x))) ` X = elts (set (V_of ` ?A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. V_of (inv_into X f (f x))) ` X =\n    elts (set (V_of ` inv_into X f ` f ` X))", "by (metis AX down elts_of_set image_image image_mono that(2))"], ["proof (state)\nthis:\n  (\\<lambda>x. V_of (inv_into X f (f x))) ` X =\n  elts (set (V_of ` inv_into X f ` f ` X))\n\ngoal (1 subgoal):\n 1. (V_of \\<circ> inv_into X f) ` f ` X \\<in> range elts", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. V_of (inv_into X f (f x))) ` X =\n  elts (set (V_of ` inv_into X f ` f ` X))", "show \"(V_of \\<circ> inv_into X f) ` f ` X \\<in> range elts\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. V_of (inv_into X f (f x))) ` X =\n  elts (set (V_of ` inv_into X f ` f ` X))\n\ngoal (1 subgoal):\n 1. (V_of \\<circ> inv_into X f) ` f ` X \\<in> range elts", "by (metis image_comp image_image rangeI)"], ["proof (state)\nthis:\n  (V_of \\<circ> inv_into X f) ` f ` X \\<in> range elts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on ?V_of X; ?V_of ` X = elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V_of.\n                       inj_on V_of (f ` X) \\<and>\n                       V_of ` f ` X \\<in> range elts\n\ngoal (1 subgoal):\n 1. small (f ` X)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj_on ?V_of X; ?V_of ` X = elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V_of.\n                       inj_on V_of (f ` X) \\<and>\n                       V_of ` f ` X \\<in> range elts", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?V_of X; ?V_of ` X = elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V_of.\n                       inj_on V_of (f ` X) \\<and>\n                       V_of ` f ` X \\<in> range elts\n\ngoal (1 subgoal):\n 1. small (f ` X)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?V_of X; ?V_of ` X = elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>V_of.\n                       inj_on V_of (f ` X) \\<and>\n                       V_of ` f ` X \\<in> range elts\n  small X\n\ngoal (1 subgoal):\n 1. small (f ` X)", "by (auto simp: small_def)"], ["proof (state)\nthis:\n  small (f ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_image_iff [simp]: \"inj_on f A \\<Longrightarrow> small (f ` A) \\<longleftrightarrow> small A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A \\<Longrightarrow> small (f ` A) = small A", "by (metis replacement the_inv_into_onto)"], ["", "text \\<open>A little bootstrapping is needed to characterise @{term small} for sets of arbitrary type.\\<close>"], ["", "lemma inf: \"small (range (g :: nat \\<Rightarrow> V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (range g)", "by (simp add: inf_raw small_iff_range)"], ["", "lemma small_image_nat_V [simp]: \"small (g ` N)\" for g :: \"nat \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (g ` N)", "by (metis (mono_tags, hide_lams) down elts_of_set image_iff inf rangeI subsetI)"], ["", "lemma Finite_V:\n  fixes X :: \"V set\"\n  assumes \"finite X\" shows \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "using ex_bij_betw_nat_finite [OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {0..<card X} X\n\ngoal (1 subgoal):\n 1. small X", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<exists>h. inj_on h {0..<card X} \\<and> h ` {0..<card X} = X\n\ngoal (1 subgoal):\n 1. small X", "by (metis small_image_nat_V)"], ["", "lemma small_insert_V:\n  fixes X :: \"V set\"\n  assumes \"small X\"\n  shows \"small (insert a X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X)", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> small (insert a X)\n 2. infinite X \\<Longrightarrow> small (insert a X)", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> small (insert a X)\n 2. infinite X \\<Longrightarrow> small (insert a X)", "then"], ["proof (chain)\npicking this:\n  finite X", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. small (insert a X)", "by (simp add: Finite_V)"], ["proof (state)\nthis:\n  small (insert a X)\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "case False"], ["proof (state)\nthis:\n  infinite X\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X)", "using infinite_imp_bij_betw2 [OF False]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h X (X \\<union> {?a})\n\ngoal (1 subgoal):\n 1. small (insert a X)", "by (metis replacement Un_insert_right assms bij_betw_imp_surj_on sup_bot.right_neutral)"], ["proof (state)\nthis:\n  small (insert a X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_UN_V [simp,intro]:\n  fixes B :: \"'a \\<Rightarrow> V set\"\n  assumes X: \"small X\" and B: \"\\<And>x. x \\<in> X \\<Longrightarrow> small (B x)\"\n  shows \"small (\\<Union>x\\<in>X. B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "have \"(\\<Union> (elts ` (\\<lambda>x. ZFC_in_HOL.set (B x)) ` X)) = (\\<Union> (B ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)", "using B"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> small (B ?x)\n\ngoal (1 subgoal):\n 1. \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)", "by force"], ["proof (state)\nthis:\n  \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "then"], ["proof (chain)\npicking this:\n  \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "using Union [OF replacement [OF X, of \"\\<lambda>x. ZFC_in_HOL.set (B x)\"]]"], ["proof (prove)\nusing this:\n  \\<Union> (elts ` (\\<lambda>x. set (B x)) ` X) = \\<Union> (B ` X)\n  small (\\<Union> (elts ` (\\<lambda>x. set (B x)) ` X))\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "by simp"], ["proof (state)\nthis:\n  small (\\<Union> (B ` X))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition vinsert where \"vinsert x y \\<equiv> set (insert x (elts y))\""], ["", "lemma elts_vinsert [simp]: \"elts (vinsert x y) = insert x (elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vinsert x y) = insert x (elts y)", "using down small_insert_V vinsert_def"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n  small ?X \\<Longrightarrow> small (insert ?a ?X)\n  vinsert ?x ?y \\<equiv> set (insert ?x (elts ?y))\n\ngoal (1 subgoal):\n 1. elts (vinsert x y) = insert x (elts y)", "by auto"], ["", "definition succ where \"succ x \\<equiv> vinsert x x\""], ["", "lemma elts_succ [simp]: \"elts (succ x) = insert x (elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ZFC_in_HOL.succ x) = insert x (elts x)", "by (simp add: succ_def)"], ["", "lemma finite_imp_small:\n  assumes \"finite X\" shows \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "using assms"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. small X", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. small {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. small {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. small {}", "by simp"], ["proof (state)\nthis:\n  small {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "case (insert a X)"], ["proof (state)\nthis:\n  finite X\n  a \\<notin> X\n  small X\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite X\n  a \\<notin> X\n  small X", "obtain V_of u where u: \"inj_on V_of X\" \"V_of ` X = elts u\""], ["proof (prove)\nusing this:\n  finite X\n  a \\<notin> X\n  small X\n\ngoal (1 subgoal):\n 1. (\\<And>V_of u.\n        \\<lbrakk>inj_on V_of X; V_of ` X = elts u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson small_def image_iff)"], ["proof (state)\nthis:\n  inj_on V_of X\n  V_of ` X = elts u\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F; small F\\<rbrakk>\n       \\<Longrightarrow> small (insert x F)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X)", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of.\n       inj_on V_of (insert a X) \\<and> V_of ` insert a X \\<in> range elts", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ?V_of (insert a X)\n 2. ?V_of ` insert a X \\<in> range elts", "show \"inj_on (V_of(a:=u)) (insert a X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (V_of(a := u)) (insert a X)", "using u"], ["proof (prove)\nusing this:\n  inj_on V_of X\n  V_of ` X = elts u\n\ngoal (1 subgoal):\n 1. inj_on (V_of(a := u)) (insert a X)", "apply (clarsimp simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>y\\<in>X. V_of x = V_of y \\<longrightarrow> x = y;\n     V_of ` X = elts u\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>y\\<in>X.\n                          y \\<noteq> a \\<longrightarrow>\n                          u \\<noteq> V_of y) \\<and>\n                      (\\<forall>x\\<in>X.\n                          (x = a \\<longrightarrow>\n                           (\\<forall>y\\<in>X.\n                               y \\<noteq> a \\<longrightarrow>\n                               u \\<noteq> V_of y)) \\<and>\n                          (x \\<noteq> a \\<longrightarrow>\n                           V_of x \\<noteq> u \\<and>\n                           (a \\<in> X \\<longrightarrow> V_of x \\<noteq> u)))", "by (metis image_eqI mem_not_refl)"], ["proof (state)\nthis:\n  inj_on (V_of(a := u)) (insert a X)\n\ngoal (1 subgoal):\n 1. V_of(a := u) ` insert a X \\<in> range elts", "have \"(V_of(a:=u)) ` insert a X = elts (vinsert u u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_of(a := u) ` insert a X = elts (vinsert u u)", "using insert.hyps(2) u(2)"], ["proof (prove)\nusing this:\n  a \\<notin> X\n  V_of ` X = elts u\n\ngoal (1 subgoal):\n 1. V_of(a := u) ` insert a X = elts (vinsert u u)", "by auto"], ["proof (state)\nthis:\n  V_of(a := u) ` insert a X = elts (vinsert u u)\n\ngoal (1 subgoal):\n 1. V_of(a := u) ` insert a X \\<in> range elts", "then"], ["proof (chain)\npicking this:\n  V_of(a := u) ` insert a X = elts (vinsert u u)", "show \"(V_of(a:=u)) ` insert a X \\<in> range elts\""], ["proof (prove)\nusing this:\n  V_of(a := u) ` insert a X = elts (vinsert u u)\n\ngoal (1 subgoal):\n 1. V_of(a := u) ` insert a X \\<in> range elts", "by (blast intro:  elim: )"], ["proof (state)\nthis:\n  V_of(a := u) ` insert a X \\<in> range elts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small (insert a X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_insert:\n  assumes \"small X\"\n  shows \"small (insert a X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X)", "proof (cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> small (insert a X)\n 2. infinite X \\<Longrightarrow> small (insert a X)", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> small (insert a X)\n 2. infinite X \\<Longrightarrow> small (insert a X)", "then"], ["proof (chain)\npicking this:\n  finite X", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. small (insert a X)", "by (simp add: finite_imp_small)"], ["proof (state)\nthis:\n  small (insert a X)\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "case False"], ["proof (state)\nthis:\n  infinite X\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> small (insert a X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X)", "using infinite_imp_bij_betw2 [OF False]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h X (X \\<union> {?a})\n\ngoal (1 subgoal):\n 1. small (insert a X)", "by (metis replacement Un_insert_right assms bij_betw_imp_surj_on sup_bot.right_neutral)"], ["proof (state)\nthis:\n  small (insert a X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smaller_than_small:\n  assumes \"small A\" \"B \\<subseteq> A\" shows \"small B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small B", "using assms"], ["proof (prove)\nusing this:\n  small A\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. small B", "by (metis down elts_of_set image_mono small_def small_iff_range subset_inj_on)"], ["", "lemma small_insert_iff [iff]: \"small (insert a X) \\<longleftrightarrow> small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (insert a X) = small X", "by (meson small_insert smaller_than_small subset_insertI)"], ["", "lemma small_iff: \"small X \\<longleftrightarrow> (\\<exists>x. X = elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X = (\\<exists>x. X = elts x)", "by (metis down elts_of_set subset_refl)"], ["", "lemma small_elts [iff]: \"small (elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (elts x)", "by (auto simp: small_iff)"], ["", "lemma small_diff [iff]: \"small (elts a - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (elts a - X)", "by (meson Diff_subset down)"], ["", "lemma small_set [simp]: \"small (list.set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (list.set xs)", "by (simp add: ZFC_in_HOL.finite_imp_small)"], ["", "lemma small_upair: \"small {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small {x, y}", "by simp"], ["", "lemma small_Un_elts: \"small (elts x \\<union> elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (elts x \\<union> elts y)", "using Union [OF small_upair]"], ["proof (prove)\nusing this:\n  small (\\<Union> (elts ` {?x1, ?y1}))\n\ngoal (1 subgoal):\n 1. small (elts x \\<union> elts y)", "by auto"], ["", "lemma small_eqcong: \"\\<lbrakk>small X; X \\<approx> Y\\<rbrakk> \\<Longrightarrow> small Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small X; X \\<approx> Y\\<rbrakk> \\<Longrightarrow> small Y", "by (metis bij_betw_imp_surj_on eqpoll_def replacement)"], ["", "lemma big_UNIV [simp]: \"\\<not> small (UNIV::V set)\" (is  \"\\<not> small ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> small UNIV", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. small UNIV \\<Longrightarrow> False", "assume \"small ?U\""], ["proof (state)\nthis:\n  small UNIV\n\ngoal (1 subgoal):\n 1. small UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  small UNIV", "have \"small A\" for A :: \"V set\""], ["proof (prove)\nusing this:\n  small UNIV\n\ngoal (1 subgoal):\n 1. small A", "by (metis (full_types) UNIV_I down small_iff subsetI)"], ["proof (state)\nthis:\n  small ?A\n\ngoal (1 subgoal):\n 1. small UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  small ?A", "have \"range elts = UNIV\""], ["proof (prove)\nusing this:\n  small ?A\n\ngoal (1 subgoal):\n 1. surj elts", "by (meson small_iff surj_def)"], ["proof (state)\nthis:\n  surj elts\n\ngoal (1 subgoal):\n 1. small UNIV \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  surj elts", "show False"], ["proof (prove)\nusing this:\n  surj elts\n\ngoal (1 subgoal):\n 1. False", "by (metis Cantors_paradox Pow_UNIV)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_set: \"inj_on set (Collect small)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on set (Collect small)", "by (metis elts_of_set inj_onI mem_Collect_eq)"], ["", "lemma set_injective [simp]: \"\\<lbrakk>small X; small Y\\<rbrakk> \\<Longrightarrow> set X = set Y \\<longleftrightarrow> X=Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small X; small Y\\<rbrakk>\n    \\<Longrightarrow> (set X = set Y) = (X = Y)", "by (metis elts_of_set)"], ["", "subsection\\<open>Type classes and other basic setup\\<close>"], ["", "instantiation V :: zero\nbegin"], ["", "definition zero_V where \"0 \\<equiv> set {}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, zero_class)", ".."], ["", "end"], ["", "lemma elts_0 [simp]: \"elts 0 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts 0 = {}", "by (simp add: zero_V_def)"], ["", "lemma set_empty [simp]: \"set {} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set {} = 0", "by (simp add: zero_V_def)"], ["", "instantiation V :: one\nbegin"], ["", "definition one_V where \"1 \\<equiv> succ 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, one_class)", ".."], ["", "end"], ["", "lemma elts_1 [simp]: \"elts 1 = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts 1 = {0}", "by (simp add: one_V_def)"], ["", "lemma insert_neq_0 [simp]: \"set (insert a X) = 0 \\<longleftrightarrow> \\<not> small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (insert a X) = 0) = (\\<not> small X)", "unfolding zero_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (insert a X) = set {}) = (\\<not> small X)", "by (metis elts_of_set empty_not_insert set_of_elts small_insert_iff)"], ["", "lemma elts_eq_empty_iff [simp]: \"elts x = {} \\<longleftrightarrow> x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (elts x = {}) = (x = 0)", "by (auto simp: ZFC_in_HOL.ext)"], ["", "instantiation V :: distrib_lattice\nbegin"], ["", "definition inf_V where \"inf_V x y \\<equiv> set (elts x \\<inter> elts y)\""], ["", "definition sup_V where \"sup_V x y \\<equiv> set (elts x \\<union> elts y)\""], ["", "definition less_eq_V where \"less_eq_V x y \\<equiv> elts x \\<subseteq> elts y\""], ["", "definition less_V where \"less_V x y \\<equiv> less_eq x y \\<and> x \\<noteq> (y::V)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, distrib_lattice_class)", "proof"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 11 subgoals...", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\" for x :: V and y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "using ext less_V_def less_eq_V_def"], ["proof (prove)\nusing this:\n  elts ?x = elts ?y \\<Longrightarrow> ?x = ?y\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by auto"], ["proof (state)\nthis:\n  (?x < ?y) = (?x \\<le> ?y \\<and> \\<not> ?y \\<le> ?x)\n\ngoal (10 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x \\<le> x\" for x :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: less_eq_V_def)"], ["proof (state)\nthis:\n  ?x \\<le> ?x\n\ngoal (9 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x \\<le> z\" if \"x \\<le> y\" \"y \\<le> z\" for x y z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (auto simp: less_eq_V_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (8 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x = y\" if \"x \\<le> y\" \"y \\<le> x\" for x y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: ext less_eq_V_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (7 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"inf x y \\<le> x\" for x y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> x", "by (metis down elts_of_set inf_V_def inf_sup_ord(1) less_eq_V_def)"], ["proof (state)\nthis:\n  ?x \\<sqinter> ?y \\<le> ?x\n\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"inf x y \\<le> y\" for x y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> y", "by (metis Int_lower2 down elts_of_set inf_V_def less_eq_V_def)"], ["proof (state)\nthis:\n  ?x \\<sqinter> ?y \\<le> ?y\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x \\<le> inf y z\" if \"x \\<le> y\" \"x \\<le> z\" for x y z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "have \"small (elts y \\<inter> elts z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (elts y \\<inter> elts z)", "by (meson down inf.cobounded1)"], ["proof (state)\nthis:\n  small (elts y \\<inter> elts z)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "then"], ["proof (chain)\npicking this:\n  small (elts y \\<inter> elts z)", "show ?thesis"], ["proof (prove)\nusing this:\n  small (elts y \\<inter> elts z)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "using elts_of_set inf_V_def less_eq_V_def that"], ["proof (prove)\nusing this:\n  small (elts y \\<inter> elts z)\n  elts (set ?X) = (if small ?X then ?X else {})\n  ?x \\<sqinter> ?y \\<equiv> set (elts ?x \\<inter> elts ?y)\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n  x \\<le> y\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "by auto"], ["proof (state)\nthis:\n  x \\<le> y \\<sqinter> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y \\<sqinter> ?z\n\ngoal (4 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"x \\<le> x \\<squnion> y\" \"y \\<le> x \\<squnion> y\" for x y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x \\<squnion> y &&& y \\<le> x \\<squnion> y", "by (simp_all add: less_eq_V_def small_Un_elts sup_V_def)"], ["proof (state)\nthis:\n  ?x \\<le> ?x \\<squnion> ?y\n  ?y \\<le> ?x \\<squnion> ?y\n\ngoal (2 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"sup y z \\<le> x\" if \"y \\<le> x\" \"z \\<le> x\" for x y z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<squnion> z \\<le> x", "using less_eq_V_def sup_V_def that"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n  ?x \\<squnion> ?y \\<equiv> set (elts ?x \\<union> elts ?y)\n  y \\<le> x\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. y \\<squnion> z \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<le> ?x; ?z \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> ?y \\<squnion> ?z \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "show \"sup x (inf y z) = inf (x \\<squnion> y) (sup x z)\" for x y z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "have \"small (elts y \\<inter> elts z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (elts y \\<inter> elts z)", "by (meson down inf.cobounded2)"], ["proof (state)\nthis:\n  small (elts y \\<inter> elts z)\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "then"], ["proof (chain)\npicking this:\n  small (elts y \\<inter> elts z)", "show ?thesis"], ["proof (prove)\nusing this:\n  small (elts y \\<inter> elts z)\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqinter> z =\n    (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)", "by (simp add: Un_Int_distrib inf_V_def small_Un_elts sup_V_def)"], ["proof (state)\nthis:\n  x \\<squnion> y \\<sqinter> z = (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<squnion> ?y \\<sqinter> ?z =\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma V_equalityI [intro]: \"(\\<And>x. x \\<in> elts a \\<longleftrightarrow> x \\<in> elts b) \\<Longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (x \\<in> elts a) = (x \\<in> elts b)) \\<Longrightarrow> a = b", "by (meson dual_order.antisym less_eq_V_def subsetI)"], ["", "lemma vsubsetI [intro!]: \"(\\<And>x. x \\<in> elts a \\<Longrightarrow> x \\<in> elts b) \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> elts a \\<Longrightarrow> x \\<in> elts b) \\<Longrightarrow>\n    a \\<le> b", "by (simp add: less_eq_V_def subsetI)"], ["", "lemma vsubsetD [elim, intro?]: \"a \\<le> b \\<Longrightarrow> c \\<in> elts a \\<Longrightarrow> c \\<in> elts b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<in> elts a\\<rbrakk>\n    \\<Longrightarrow> c \\<in> elts b", "using less_eq_V_def"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<in> elts a\\<rbrakk>\n    \\<Longrightarrow> c \\<in> elts b", "by auto"], ["", "lemma rev_vsubsetD: \"c \\<in> elts a \\<Longrightarrow> a \\<le> b \\<Longrightarrow> c \\<in> elts b\"\n  \\<comment> \\<open>The same, with reversed premises for use with @{method erule} -- cf. @{thm rev_mp}.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> elts a; a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> c \\<in> elts b", "by (rule vsubsetD)"], ["", "lemma vsubsetCE [elim,no_atp]: \"a \\<le> b \\<Longrightarrow> (c \\<notin> elts a \\<Longrightarrow> P) \\<Longrightarrow> (c \\<in> elts b \\<Longrightarrow> P) \\<Longrightarrow> P\"\n  \\<comment> \\<open>Classical elimination rule.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<notin> elts a \\<Longrightarrow> P;\n     c \\<in> elts b \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "using vsubsetD"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?c \\<in> elts ?a\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> elts ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<notin> elts a \\<Longrightarrow> P;\n     c \\<in> elts b \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "lemma set_image_le_iff: \"small A \\<Longrightarrow> set (f ` A) \\<le> B \\<longleftrightarrow> (\\<forall>x\\<in>A. f x \\<in> elts B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A \\<Longrightarrow>\n    (set (f ` A) \\<le> B) = (\\<forall>x\\<in>A. f x \\<in> elts B)", "by auto"], ["", "lemma eq0_iff: \"x = 0 \\<longleftrightarrow> (\\<forall>y. y \\<notin> elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (\\<forall>y. y \\<notin> elts x)", "by auto"], ["", "lemma less_eq_V_0_iff [simp]: \"x \\<le> 0 \\<longleftrightarrow> x = 0\" for x::V"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> 0) = (x = 0)", "by auto"], ["", "lemma subset_iff_less_eq_V:\n  assumes \"small B\" shows \"A \\<subseteq> B \\<longleftrightarrow> set A \\<le> set B \\<and> small A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<subseteq> B) = (set A \\<le> set B \\<and> small A)", "using assms down small_iff"], ["proof (prove)\nusing this:\n  small B\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n  small ?X = (\\<exists>x. ?X = elts x)\n\ngoal (1 subgoal):\n 1. (A \\<subseteq> B) = (set A \\<le> set B \\<and> small A)", "by auto"], ["", "lemma small_Collect [simp]: \"small A \\<Longrightarrow> small {x \\<in> A. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A \\<Longrightarrow> small {x \\<in> A. P x}", "by (simp add: smaller_than_small)"], ["", "lemma small_Union_iff: \"small (\\<Union>(elts ` X)) \\<longleftrightarrow> small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> (elts ` X)) = small X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. small (\\<Union> (elts ` X)) \\<Longrightarrow> small X\n 2. small X \\<Longrightarrow> small (\\<Union> (elts ` X))", "show \"small X\"\n    if \"small (\\<Union> (elts ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small X", "have \"X \\<subseteq> set ` Pow (\\<Union> (elts ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> set ` Pow (\\<Union> (elts ` X))", "by fastforce"], ["proof (state)\nthis:\n  X \\<subseteq> set ` Pow (\\<Union> (elts ` X))\n\ngoal (1 subgoal):\n 1. small X", "then"], ["proof (chain)\npicking this:\n  X \\<subseteq> set ` Pow (\\<Union> (elts ` X))", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<subseteq> set ` Pow (\\<Union> (elts ` X))\n\ngoal (1 subgoal):\n 1. small X", "using Pow subset_iff_less_eq_V that"], ["proof (prove)\nusing this:\n  X \\<subseteq> set ` Pow (\\<Union> (elts ` X))\n  small ?X \\<Longrightarrow> small (set ` Pow ?X)\n  small ?B \\<Longrightarrow>\n  (?A \\<subseteq> ?B) = (set ?A \\<le> set ?B \\<and> small ?A)\n  small (\\<Union> (elts ` X))\n\ngoal (1 subgoal):\n 1. small X", "by auto"], ["proof (state)\nthis:\n  small X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small (\\<Union> (elts ` X)) \\<Longrightarrow> small X\n\ngoal (1 subgoal):\n 1. small X \\<Longrightarrow> small (\\<Union> (elts ` X))", "qed auto"], ["", "lemma not_less_0 [iff]:\n  fixes x::V shows \"\\<not> x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < 0", "by (simp add: less_eq_V_def less_le_not_le)"], ["", "lemma le_0 [iff]:\n  fixes x::V shows \"0 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by auto"], ["", "lemma min_0L [simp]: \"min 0 n = 0\" for n :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. min 0 n = 0", "by (simp add: min_absorb1)"], ["", "lemma min_0R [simp]: \"min n 0 = 0\" for n :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. min n 0 = 0", "by (simp add: min_absorb2)"], ["", "lemma neq0_conv: \"\\<And>n::V. n \\<noteq> 0 \\<longleftrightarrow> 0 < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. (n \\<noteq> 0) = (0 < n)", "by (simp add: less_V_def)"], ["", "definition VPow :: \"V \\<Rightarrow> V\"\n  where \"VPow x \\<equiv> set (set ` Pow (elts x))\""], ["", "lemma VPow_iff [iff]: \"y \\<in> elts (VPow x) \\<longleftrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> elts (VPow x)) = (y \\<le> x)", "using down Pow"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n  small ?X \\<Longrightarrow> small (set ` Pow ?X)\n\ngoal (1 subgoal):\n 1. (y \\<in> elts (VPow x)) = (y \\<le> x)", "apply (auto simp: VPow_def less_eq_V_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Y x. Y \\<subseteq> elts x \\<Longrightarrow> small Y;\n     \\<And>X. small X \\<Longrightarrow> small (set ` Pow X);\n     elts y \\<subseteq> elts x\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set ` Pow (elts x)", "using less_eq_V_def"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Y x. Y \\<subseteq> elts x \\<Longrightarrow> small Y;\n     \\<And>X. small X \\<Longrightarrow> small (set ` Pow X);\n     elts y \\<subseteq> elts x\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set ` Pow (elts x)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma VPow_le_VPow_iff [simp]: \"VPow a \\<le> VPow b \\<longleftrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (VPow a \\<le> VPow b) = (a \\<le> b)", "by auto"], ["", "lemma elts_VPow: \"elts (VPow x) = set ` Pow (elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (VPow x) = set ` Pow (elts x)", "by (auto simp: VPow_def Pow)"], ["", "lemma small_sup_iff [simp]: \"small (X \\<union> Y) \\<longleftrightarrow> small X \\<and> small Y\" for X::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X \\<union> Y) = (small X \\<and> small Y)", "by (metis down elts_of_set small_Un_elts sup_ge1 sup_ge2)"], ["", "lemma elts_sup_iff [simp]: \"elts (x \\<squnion> y) = elts x \\<union> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (x \\<squnion> y) = elts x \\<union> elts y", "by (simp add: sup_V_def)"], ["", "lemma trad_foundation:\n  assumes z: \"z \\<noteq> 0\" shows \"\\<exists>w. w \\<in> elts z \\<and> w \\<sqinter> z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. w \\<in> elts z \\<and> w \\<sqinter> z = 0", "using foundation assms"], ["proof (prove)\nusing this:\n  wf {(x, y). x \\<in> elts y}\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>w. w \\<in> elts z \\<and> w \\<sqinter> z = 0", "by (simp add: wf_eq_minimal) (metis Int_emptyI equals0I inf_V_def set_of_elts zero_V_def)"], ["", "instantiation \"V\" :: Sup\nbegin"], ["", "definition Sup_V where \"Sup_V X \\<equiv> if small X then set (Union (elts ` X)) else 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, Sup_class)", ".."], ["", "end"], ["", "instantiation \"V\" :: Inf\nbegin"], ["", "definition Inf_V where \"Inf_V X \\<equiv> if X = {} then 0 else set (Inter (elts ` X))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, Inf_class)", ".."], ["", "end"], ["", "lemma V_disjoint_iff: \"x \\<sqinter> y = 0 \\<longleftrightarrow> elts x \\<inter> elts y = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = 0) = (elts x \\<inter> elts y = {})", "by (metis down elts_of_set inf_V_def inf_le1 zero_V_def)"], ["", "text\\<open>I've no idea why @{term bdd_above} is treated differently from @{term bdd_below}, but anyway\\<close>"], ["", "lemma bdd_above_iff_small [simp]: \"bdd_above X = small X\" for X::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above X = small X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bdd_above X \\<Longrightarrow> small X\n 2. small X \\<Longrightarrow> bdd_above X", "show \"small X\" if \"bdd_above X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small X", "obtain a where \"\\<forall>x\\<in>X. x \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<forall>x\\<in>X. x \\<le> a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using that \\<open>bdd_above X\\<close> bdd_above_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. x \\<le> ?a \\<Longrightarrow> thesis\n  bdd_above X\n  bdd_above ?A = (\\<exists>M. \\<forall>x\\<in>?A. x \\<le> M)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<forall>x\\<in>X. x \\<le> a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. x \\<le> a\n\ngoal (1 subgoal):\n 1. small X", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X. x \\<le> a", "show \"small X\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. x \\<le> a\n\ngoal (1 subgoal):\n 1. small X", "by (meson VPow_iff \\<open>\\<forall>x\\<in>X. x \\<le> a\\<close> down subsetI)"], ["proof (state)\nthis:\n  small X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_above X \\<Longrightarrow> small X\n\ngoal (1 subgoal):\n 1. small X \\<Longrightarrow> bdd_above X", "show \"bdd_above X\"\n    if \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_above X", "have \"\\<forall>x\\<in>X. x \\<le> \\<Squnion> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<le> \\<Squnion> X", "by (simp add: SUP_upper Sup_V_def Union less_eq_V_def that)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. x \\<le> \\<Squnion> X\n\ngoal (1 subgoal):\n 1. bdd_above X", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X. x \\<le> \\<Squnion> X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. x \\<le> \\<Squnion> X\n\ngoal (1 subgoal):\n 1. bdd_above X", "by (meson bdd_above_def)"], ["proof (state)\nthis:\n  bdd_above X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small X \\<Longrightarrow> bdd_above X\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation \"V\" :: conditionally_complete_lattice\nbegin"], ["", "definition bdd_below_V where \"bdd_below_V X \\<equiv> X \\<noteq> {}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, conditionally_complete_lattice_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; bdd_below X\\<rbrakk>\n       \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 2. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> \\<Sqinter> X\n 3. \\<And>x X.\n       \\<lbrakk>x \\<in> X; bdd_above X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> X\n 4. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> X \\<le> z", "show \"\\<Sqinter> X \\<le> x\" if \"x \\<in> X\" \"bdd_below X\"\n    for x :: V and X :: \"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> X \\<le> x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> X\n  bdd_below X\n\ngoal (1 subgoal):\n 1. \\<Sqinter> X \\<le> x", "by (auto simp: bdd_below_V_def Inf_V_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> ?X; bdd_below ?X\\<rbrakk>\n  \\<Longrightarrow> \\<Sqinter> ?X \\<le> ?x\n\ngoal (3 subgoals):\n 1. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> z \\<le> \\<Sqinter> X\n 2. \\<And>x X.\n       \\<lbrakk>x \\<in> X; bdd_above X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> X\n 3. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> X \\<le> z", "show \"z \\<le> \\<Sqinter> X\"\n    if \"X \\<noteq> {}\" \"\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x\"\n    for X :: \"V set\" and z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> \\<Sqinter> X", "using that"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> z \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> \\<Sqinter> X", "apply (clarsimp simp add: bdd_below_V_def Inf_V_def less_eq_V_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<And>x. x \\<in> X \\<Longrightarrow> elts z \\<subseteq> elts x\\<rbrakk>\n    \\<Longrightarrow> (small (\\<Inter> (elts ` X)) \\<longrightarrow>\n                       elts z \\<subseteq> \\<Inter> (elts ` X)) \\<and>\n                      (\\<not> small (\\<Inter> (elts ` X)) \\<longrightarrow>\n                       z = 0)", "by (meson INT_subset_iff down eq_refl equals0I)"], ["proof (state)\nthis:\n  \\<lbrakk>?X \\<noteq> {};\n   \\<And>x. x \\<in> ?X \\<Longrightarrow> ?z \\<le> x\\<rbrakk>\n  \\<Longrightarrow> ?z \\<le> \\<Sqinter> ?X\n\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>x \\<in> X; bdd_above X\\<rbrakk>\n       \\<Longrightarrow> x \\<le> \\<Squnion> X\n 2. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> X \\<le> z", "show \"x \\<le> \\<Squnion> X\" if \"x \\<in> X\" and \"bdd_above X\" for x :: V and X :: \"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> X", "using that Sup_V_def"], ["proof (prove)\nusing this:\n  x \\<in> X\n  bdd_above X\n  \\<Squnion> ?X \\<equiv> if small ?X then set (\\<Union> (elts ` ?X)) else 0\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> X", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> ?X; bdd_above ?X\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?X\n\ngoal (1 subgoal):\n 1. \\<And>X z.\n       \\<lbrakk>X \\<noteq> {};\n        \\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> X \\<le> z", "show \"\\<Squnion> X \\<le> (z::V)\" if \"X \\<noteq> {}\" \"\\<And>x. x \\<in> X \\<Longrightarrow> x \\<le> z\" for X :: \"V set\" and z :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> X \\<le> z", "using that"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  ?x \\<in> X \\<Longrightarrow> ?x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<Squnion> X \\<le> z", "by (simp add: SUP_least Sup_V_def less_eq_V_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?X \\<noteq> {};\n   \\<And>x. x \\<in> ?X \\<Longrightarrow> x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> ?X \\<le> ?z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma Sup_upper: \"\\<lbrakk>x \\<in> A; small A\\<rbrakk> \\<Longrightarrow> x \\<le> \\<Squnion>A\" for A::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; small A\\<rbrakk>\n    \\<Longrightarrow> x \\<le> \\<Squnion> A", "by (auto simp: Sup_V_def SUP_upper Union less_eq_V_def)"], ["", "lemma Sup_least:\n  fixes z::V shows \"(\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow> \\<Squnion>A \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n    \\<Squnion> A \\<le> z", "by (auto simp: Sup_V_def SUP_least less_eq_V_def)"], ["", "lemma Sup_empty [simp]: \"\\<Squnion>{} = (0::V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = 0", "using Sup_V_def"], ["proof (prove)\nusing this:\n  \\<Squnion> ?X \\<equiv> if small ?X then set (\\<Union> (elts ` ?X)) else 0\n\ngoal (1 subgoal):\n 1. \\<Squnion> {} = 0", "by auto"], ["", "lemma elts_Sup [simp]: \"small X \\<Longrightarrow> elts (\\<Squnion> X) = \\<Union>(elts ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X \\<Longrightarrow> elts (\\<Squnion> X) = \\<Union> (elts ` X)", "by (auto simp: Sup_V_def)"], ["", "lemma sup_V_0_left [simp]: \"0 \\<squnion> a = a\" and sup_V_0_right [simp]: \"a \\<squnion> 0 = a\" for a::V"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<squnion> a = a &&& a \\<squnion> 0 = a", "by auto"], ["", "lemma Sup_V_insert:\n  fixes x::V assumes \"small A\" shows \"\\<Squnion>(insert x A) = x \\<squnion> \\<Squnion>A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (insert x A) = x \\<squnion> \\<Squnion> A", "by (simp add: assms cSup_insert_If)"], ["", "lemma Sup_Un_distrib: \"\\<lbrakk>small A; small B\\<rbrakk> \\<Longrightarrow> \\<Squnion>(A \\<union> B) = \\<Squnion>A \\<squnion> \\<Squnion>B\" for A::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small A; small B\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> (A \\<union> B) =\n                      \\<Squnion> A \\<squnion> \\<Squnion> B", "by auto"], ["", "lemma SUP_sup_distrib:\n  fixes f :: \"V \\<Rightarrow> V\"\n  shows \"small A \\<Longrightarrow> (SUP x\\<in>A. f x \\<squnion> g x) = \\<Squnion> (f ` A) \\<squnion> \\<Squnion> (g ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A \\<Longrightarrow>\n    (SUP x\\<in>A. f x \\<squnion> g x) =\n    \\<Squnion> (f ` A) \\<squnion> \\<Squnion> (g ` A)", "by (force simp:)"], ["", "lemma SUP_const [simp]: \"(SUP y \\<in> A. a) = (if A = {} then (0::V) else a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP y\\<in>A. a) = (if A = {} then 0 else a)", "by simp"], ["", "lemma cSUP_subset_mono:\n  fixes f :: \"'a \\<Rightarrow> V set\" and g :: \"'a \\<Rightarrow> V set\"\n  shows \"\\<lbrakk>A \\<subseteq> B; \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<le> g x\\<rbrakk> \\<Longrightarrow> \\<Squnion> (f ` A) \\<le> \\<Squnion> (g ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B;\n     \\<And>x. x \\<in> A \\<Longrightarrow> f x \\<subseteq> g x\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (f ` A) \\<subseteq> \\<Union> (g ` B)", "by (simp add: SUP_subset_mono)"], ["", "lemma mem_Sup_iff [iff]: \"x \\<in> elts (\\<Squnion>X) \\<longleftrightarrow> x \\<in> \\<Union> (elts ` X) \\<and> small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> elts (\\<Squnion> X)) =\n    (x \\<in> \\<Union> (elts ` X) \\<and> small X)", "using Sup_V_def"], ["proof (prove)\nusing this:\n  \\<Squnion> ?X \\<equiv> if small ?X then set (\\<Union> (elts ` ?X)) else 0\n\ngoal (1 subgoal):\n 1. (x \\<in> elts (\\<Squnion> X)) =\n    (x \\<in> \\<Union> (elts ` X) \\<and> small X)", "by auto"], ["", "lemma cSUP_UNION:\n  fixes B :: \"V \\<Rightarrow> V set\" and f :: \"V \\<Rightarrow> V\"\n  assumes ne: \"small A\" and bdd_UN: \"small (\\<Union>x\\<in>A. f ` B x)\"\n  shows \"\\<Squnion>(f ` (\\<Union>x\\<in>A. B x)) = \\<Squnion>((\\<lambda>x. \\<Squnion>(f ` B x)) ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "have bdd: \"\\<And>x. x \\<in> A \\<Longrightarrow> small (f ` B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> small (f ` B x)", "using bdd_UN subset_iff_less_eq_V"], ["proof (prove)\nusing this:\n  small (\\<Union>x\\<in>A. f ` B x)\n  small ?B \\<Longrightarrow>\n  (?A \\<subseteq> ?B) = (set ?A \\<le> set ?B \\<and> small ?A)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> small (f ` B x)", "by (meson SUP_upper smaller_than_small)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> small (f ` B ?x)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow> small (f ` B ?x)", "have bdd2: \"small ((\\<lambda>x. \\<Squnion>(f ` B x)) ` A)\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> small (f ` B ?x)\n\ngoal (1 subgoal):\n 1. small ((\\<lambda>x. \\<Squnion> (f ` B x)) ` A)", "using ne(1)"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> small (f ` B ?x)\n  small A\n\ngoal (1 subgoal):\n 1. small ((\\<lambda>x. \\<Squnion> (f ` B x)) ` A)", "by blast"], ["proof (state)\nthis:\n  small ((\\<lambda>x. \\<Squnion> (f ` B x)) ` A)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "have \"\\<Squnion>(f ` (\\<Union>x\\<in>A. B x)) \\<le> \\<Squnion>((\\<lambda>x. \\<Squnion>(f ` B x)) ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A))\n    \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))", "using assms"], ["proof (prove)\nusing this:\n  small A\n  small (\\<Union>x\\<in>A. f ` B x)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A))\n    \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))", "by (fastforce simp add: intro!: cSUP_least intro: cSUP_upper2 simp: bdd2 bdd)"], ["proof (state)\nthis:\n  \\<Squnion> (f ` \\<Union> (B ` A))\n  \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> (f ` \\<Union> (B ` A))\n  \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "have \"\\<Squnion>((\\<lambda>x. \\<Squnion>(f ` B x)) ` A) \\<le> \\<Squnion>(f ` (\\<Union>x\\<in>A. B x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. \\<Squnion> (f ` B x))\n    \\<le> \\<Squnion> (f ` \\<Union> (B ` A))", "using assms"], ["proof (prove)\nusing this:\n  small A\n  small (\\<Union>x\\<in>A. f ` B x)\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. \\<Squnion> (f ` B x))\n    \\<le> \\<Squnion> (f ` \\<Union> (B ` A))", "by (fastforce simp add: intro!: cSUP_least intro: cSUP_upper simp: image_UN bdd_UN)"], ["proof (state)\nthis:\n  (SUP x\\<in>A. \\<Squnion> (f ` B x))\n  \\<le> \\<Squnion> (f ` \\<Union> (B ` A))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> (f ` \\<Union> (B ` A))\n  \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))\n  (SUP x\\<in>A. \\<Squnion> (f ` B x))\n  \\<le> \\<Squnion> (f ` \\<Union> (B ` A))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> (f ` \\<Union> (B ` A))\n  \\<le> (SUP x\\<in>A. \\<Squnion> (f ` B x))\n  (SUP x\\<in>A. \\<Squnion> (f ` B x))\n  \\<le> \\<Squnion> (f ` \\<Union> (B ` A))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))", "by (rule order_antisym)"], ["proof (state)\nthis:\n  \\<Squnion> (f ` \\<Union> (B ` A)) = (SUP x\\<in>A. \\<Squnion> (f ` B x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_subset_mono: \"small B \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> Sup A \\<le> Sup B\" for A::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small B; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> A \\<le> \\<Squnion> B", "by auto"], ["", "lemma Sup_le_iff: \"small A \\<Longrightarrow> Sup A \\<le> a \\<longleftrightarrow> (\\<forall>x\\<in>A. x \\<le> a)\" for A::\"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A \\<Longrightarrow>\n    (\\<Squnion> A \\<le> a) = (\\<forall>x\\<in>A. x \\<le> a)", "by auto"], ["", "lemma SUP_le_iff: \"small (f ` A) \\<Longrightarrow> \\<Squnion>(f ` A) \\<le> u \\<longleftrightarrow> (\\<forall>x\\<in>A. f x \\<le> u)\" for f :: \"V \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (f ` A) \\<Longrightarrow>\n    (\\<Squnion> (f ` A) \\<le> u) = (\\<forall>x\\<in>A. f x \\<le> u)", "by blast"], ["", "lemma Sup_eq_0_iff [simp]: \"\\<Squnion>A = 0 \\<longleftrightarrow> A \\<subseteq> {0} \\<or> \\<not> small A\" for A :: \"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> A = 0) = (A \\<subseteq> {0} \\<or> \\<not> small A)", "using Sup_upper"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?A; small ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n\ngoal (1 subgoal):\n 1. (\\<Squnion> A = 0) = (A \\<subseteq> {0} \\<or> \\<not> small A)", "by fastforce"], ["", "lemma Sup_Union_commute:\n  fixes f :: \"V \\<Rightarrow> V set\"\n  assumes \"small A\" \"\\<And>x. x\\<in>A \\<Longrightarrow> small (f x)\"\n  shows \"\\<Squnion> (\\<Union>x\\<in>A. f x) = (SUP x\\<in>A. \\<Squnion> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (\\<Union> (f ` A)) = (SUP x\\<in>A. \\<Squnion> (f x))", "using assms"], ["proof (prove)\nusing this:\n  small A\n  ?x \\<in> A \\<Longrightarrow> small (f ?x)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (\\<Union> (f ` A)) = (SUP x\\<in>A. \\<Squnion> (f x))", "by (force simp: subset_iff_less_eq_V intro!: antisym)"], ["", "lemma Sup_eq_Sup:\n  fixes B :: \"V set\"\n  assumes \"B \\<subseteq> A\" \"small A\" and *: \"\\<And>x. x \\<in> A \\<Longrightarrow> \\<exists>y \\<in> B. x \\<le> y\"\n  shows \"Sup A = Sup B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "have \"small B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small B", "using assms subset_iff_less_eq_V"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  small A\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>B. ?x \\<le> y\n  small ?B \\<Longrightarrow>\n  (?A \\<subseteq> ?B) = (set ?A \\<le> set ?B \\<and> small ?A)\n\ngoal (1 subgoal):\n 1. small B", "by auto"], ["proof (state)\nthis:\n  small B\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "moreover"], ["proof (state)\nthis:\n  small B\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "have \"\\<exists>y\\<in>B. u \\<in> elts y\"\n    if \"x \\<in> A\" \"u \\<in> elts x\" for u x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>B. u \\<in> elts y", "using that \"*\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  u \\<in> elts x\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>B. ?x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>B. u \\<in> elts y", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?u \\<in> elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>B. ?u \\<in> elts y\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?u \\<in> elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>B. ?u \\<in> elts y\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "have \"\\<exists>x\\<in>A. v \\<in> elts x\"\n    if \"y \\<in> B\" \"v \\<in> elts y\" for v y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A. v \\<in> elts x", "using that \\<open>B \\<subseteq> A\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> B\n  v \\<in> elts y\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A. v \\<in> elts x", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> B; ?v \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>A. ?v \\<in> elts x\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "ultimately"], ["proof (chain)\npicking this:\n  small B\n  \\<lbrakk>?x \\<in> A; ?u \\<in> elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>B. ?u \\<in> elts y\n  \\<lbrakk>?y \\<in> B; ?v \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>A. ?v \\<in> elts x", "show ?thesis"], ["proof (prove)\nusing this:\n  small B\n  \\<lbrakk>?x \\<in> A; ?u \\<in> elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>B. ?u \\<in> elts y\n  \\<lbrakk>?y \\<in> B; ?v \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>A. ?v \\<in> elts x\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "using assms"], ["proof (prove)\nusing this:\n  small B\n  \\<lbrakk>?x \\<in> A; ?u \\<in> elts ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>B. ?u \\<in> elts y\n  \\<lbrakk>?y \\<in> B; ?v \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>A. ?v \\<in> elts x\n  B \\<subseteq> A\n  small A\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>B. ?x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "by auto"], ["proof (state)\nthis:\n  \\<Squnion> A = \\<Squnion> B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Successor function\\<close>"], ["", "lemma vinsert_not_empty [simp]: \"vinsert a A \\<noteq> 0\"\n  and empty_not_vinsert [simp]: \"0 \\<noteq> vinsert a A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vinsert a A \\<noteq> 0 &&& 0 \\<noteq> vinsert a A", "by (auto simp: vinsert_def)"], ["", "lemma succ_not_0 [simp]: \"succ n \\<noteq> 0\" and zero_not_succ [simp]: \"0 \\<noteq> succ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ n \\<noteq> 0 &&& 0 \\<noteq> ZFC_in_HOL.succ n", "by (auto simp: succ_def)"], ["", "instantiation V :: zero_neq_one\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, zero_neq_one_class)", "by intro_classes (metis elts_0 elts_succ empty_iff insert_iff one_V_def set_of_elts)"], ["", "end"], ["", "instantiation V :: zero_less_one\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, zero_less_one_class)", "by intro_classes (simp add: less_V_def)"], ["", "end"], ["", "lemma succ_ne_self [simp]: \"i \\<noteq> succ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> ZFC_in_HOL.succ i", "by (metis elts_succ insertI1 mem_not_refl)"], ["", "lemma succ_notin_self: \"succ i \\<notin> elts i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ i \\<notin> elts i", "using elts_succ mem_not_refl"], ["proof (prove)\nusing this:\n  elts (ZFC_in_HOL.succ ?x) = insert ?x (elts ?x)\n  ?i \\<notin> elts ?i\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ i \\<notin> elts i", "by blast"], ["", "lemma le_succE: \"succ i \\<le> succ j \\<Longrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ i \\<le> ZFC_in_HOL.succ j \\<Longrightarrow> i \\<le> j", "using less_eq_V_def mem_not_sym"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n  \\<not> (?x \\<in> elts ?y \\<and> ?y \\<in> elts ?x)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ i \\<le> ZFC_in_HOL.succ j \\<Longrightarrow> i \\<le> j", "by auto"], ["", "lemma succ_inject_iff [iff]: \"succ i = succ j \\<longleftrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_in_HOL.succ i = ZFC_in_HOL.succ j) = (i = j)", "by (simp add: dual_order.antisym le_succE)"], ["", "lemma inj_succ: \"inj succ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ZFC_in_HOL.succ", "by (simp add: inj_def)"], ["", "lemma succ_neq_zero: \"succ x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ x \\<noteq> 0", "by (metis elts_0 elts_succ insert_not_empty)"], ["", "definition pred where \"pred i \\<equiv> THE j. i = succ j\""], ["", "lemma pred_succ [simp]: \"pred (succ i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.pred (ZFC_in_HOL.succ i) = i", "by (simp add: pred_def)"], ["", "subsection \\<open>Ordinals\\<close>"], ["", "definition Transset where \"Transset x \\<equiv> \\<forall>y \\<in> elts x. y \\<le> x\""], ["", "definition Ord where \"Ord x \\<equiv> Transset x \\<and> (\\<forall>y \\<in> elts x. Transset y)\""], ["", "abbreviation ON where \"ON \\<equiv> Collect Ord\""], ["", "subsubsection \\<open>Transitive sets\\<close>"], ["", "lemma Transset_0 [iff]: \"Transset 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset 0", "by (auto simp: Transset_def)"], ["", "lemma Transset_succ [intro]:\n  assumes \"Transset x\" shows \"Transset (succ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (ZFC_in_HOL.succ x)", "using assms"], ["proof (prove)\nusing this:\n  Transset x\n\ngoal (1 subgoal):\n 1. Transset (ZFC_in_HOL.succ x)", "by (auto simp: Transset_def succ_def less_eq_V_def)"], ["", "lemma Transset_Sup:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Transset x\" shows \"Transset (\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (\\<Squnion> X)", "proof (cases \"small X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. small X \\<Longrightarrow> Transset (\\<Squnion> X)\n 2. \\<not> small X \\<Longrightarrow> Transset (\\<Squnion> X)", "case True"], ["proof (state)\nthis:\n  small X\n\ngoal (2 subgoals):\n 1. small X \\<Longrightarrow> Transset (\\<Squnion> X)\n 2. \\<not> small X \\<Longrightarrow> Transset (\\<Squnion> X)", "with assms"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> Transset ?x\n  small X", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> Transset ?x\n  small X\n\ngoal (1 subgoal):\n 1. Transset (\\<Squnion> X)", "by (simp add: Transset_def) (meson Sup_upper assms dual_order.trans)"], ["proof (state)\nthis:\n  Transset (\\<Squnion> X)\n\ngoal (1 subgoal):\n 1. \\<not> small X \\<Longrightarrow> Transset (\\<Squnion> X)", "qed (simp add: Sup_V_def)"], ["", "lemma Transset_sup:\n  assumes \"Transset x\" \"Transset y\" shows \"Transset (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (x \\<squnion> y)", "using Transset_def assms"], ["proof (prove)\nusing this:\n  Transset ?x \\<equiv> \\<forall>y\\<in>elts ?x. y \\<le> ?x\n  Transset x\n  Transset y\n\ngoal (1 subgoal):\n 1. Transset (x \\<squnion> y)", "by fastforce"], ["", "lemma Transset_inf: \"\\<lbrakk>Transset i; Transset j\\<rbrakk> \\<Longrightarrow> Transset (i \\<sqinter> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transset i; Transset j\\<rbrakk>\n    \\<Longrightarrow> Transset (i \\<sqinter> j)", "by (simp add: Transset_def rev_vsubsetD)"], ["", "lemma Transset_VPow: \"Transset(i) \\<Longrightarrow> Transset(VPow(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset i \\<Longrightarrow> Transset (VPow i)", "by (auto simp: Transset_def)"], ["", "lemma Transset_Inf: \"(\\<And>i. i \\<in> A \\<Longrightarrow> Transset i) \\<Longrightarrow> Transset (\\<Sqinter> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> A \\<Longrightarrow> Transset i) \\<Longrightarrow>\n    Transset (\\<Sqinter> A)", "by (force simp: Transset_def Inf_V_def)"], ["", "lemma Transset_SUP: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow> Transset (\\<Squnion> (B ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow>\n    Transset (\\<Squnion> (B ` A))", "by (metis Transset_Sup imageE)"], ["", "lemma Transset_INT: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow> Transset (\\<Sqinter> (B ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> Transset (B x)) \\<Longrightarrow>\n    Transset (\\<Sqinter> (B ` A))", "by (metis Transset_Inf imageE)"], ["", "subsubsection \\<open>Zero, successor, sups\\<close>"], ["", "lemma Ord_0 [iff]: \"Ord 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord 0", "by (auto simp: Ord_def)"], ["", "lemma Ord_succ [intro]:\n  assumes \"Ord x\" shows \"Ord (succ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ZFC_in_HOL.succ x)", "using assms"], ["proof (prove)\nusing this:\n  Ord x\n\ngoal (1 subgoal):\n 1. Ord (ZFC_in_HOL.succ x)", "by (auto simp: Ord_def)"], ["", "lemma Ord_Sup:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Ord x\" shows \"Ord (\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<Squnion> X)", "proof (cases \"small X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. small X \\<Longrightarrow> Ord (\\<Squnion> X)\n 2. \\<not> small X \\<Longrightarrow> Ord (\\<Squnion> X)", "case True"], ["proof (state)\nthis:\n  small X\n\ngoal (2 subgoals):\n 1. small X \\<Longrightarrow> Ord (\\<Squnion> X)\n 2. \\<not> small X \\<Longrightarrow> Ord (\\<Squnion> X)", "with assms"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> Ord ?x\n  small X", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> Ord ?x\n  small X\n\ngoal (1 subgoal):\n 1. Ord (\\<Squnion> X)", "by (auto simp: Ord_def Transset_Sup)"], ["proof (state)\nthis:\n  Ord (\\<Squnion> X)\n\ngoal (1 subgoal):\n 1. \\<not> small X \\<Longrightarrow> Ord (\\<Squnion> X)", "qed (simp add: Sup_V_def)"], ["", "lemma Ord_Union:\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> Ord x\" \"small X\" shows \"Ord (set (\\<Union> (elts ` X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (set (\\<Union> (elts ` X)))", "by (metis Ord_Sup Sup_V_def assms)"], ["", "lemma Ord_sup:\n  assumes \"Ord x\" \"Ord y\" shows \"Ord (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (x \\<squnion> y)", "using assms"], ["proof (prove)\nusing this:\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. Ord (x \\<squnion> y)", "proof (clarsimp simp: Ord_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transset x; \\<forall>y\\<in>elts x. Transset y; Transset y;\n     \\<forall>y\\<in>elts y. Transset y\\<rbrakk>\n    \\<Longrightarrow> Transset (x \\<squnion> y) \\<and>\n                      (\\<forall>y\\<in>elts x \\<union> elts y. Transset y)", "show \"Transset (x \\<squnion> y) \\<and> (\\<forall>y\\<in>elts x \\<union> elts y. Transset y)\"\n    if \"Transset x\" \"Transset y\" \"\\<forall>y\\<in>elts x. Transset y\" \"\\<forall>y\\<in>elts y. Transset y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (x \\<squnion> y) \\<and>\n    (\\<forall>y\\<in>elts x \\<union> elts y. Transset y)", "using Ord_def Transset_sup assms"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  \\<lbrakk>Transset ?x; Transset ?y\\<rbrakk>\n  \\<Longrightarrow> Transset (?x \\<squnion> ?y)\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. Transset (x \\<squnion> y) \\<and>\n    (\\<forall>y\\<in>elts x \\<union> elts y. Transset y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Transset x; Transset y; \\<forall>y\\<in>elts x. Transset y;\n   \\<forall>y\\<in>elts y. Transset y\\<rbrakk>\n  \\<Longrightarrow> Transset (x \\<squnion> y) \\<and>\n                    (\\<forall>y\\<in>elts x \\<union> elts y. Transset y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma big_ON [simp]: \"\\<not> small ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> small ON", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. small ON \\<Longrightarrow> False", "assume \"small ON\""], ["proof (state)\nthis:\n  small ON\n\ngoal (1 subgoal):\n 1. small ON \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  small ON", "have \"set ON \\<in> ON\""], ["proof (prove)\nusing this:\n  small ON\n\ngoal (1 subgoal):\n 1. set ON \\<in> ON", "by (metis Ord_Union Ord_succ Sup_upper elts_Sup elts_succ insertI1 mem_Collect_eq mem_not_refl set_of_elts vsubsetD)"], ["proof (state)\nthis:\n  set ON \\<in> ON\n\ngoal (1 subgoal):\n 1. small ON \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  set ON \\<in> ON", "show False"], ["proof (prove)\nusing this:\n  set ON \\<in> ON\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>small ON\\<close> elts_of_set mem_not_refl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_1 [iff]: \"Ord 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord 1", "using Ord_succ one_V_def succ_def vinsert_def"], ["proof (prove)\nusing this:\n  Ord ?x \\<Longrightarrow> Ord (ZFC_in_HOL.succ ?x)\n  1 \\<equiv> ZFC_in_HOL.succ 0\n  ZFC_in_HOL.succ ?x \\<equiv> vinsert ?x ?x\n  vinsert ?x ?y \\<equiv> set (insert ?x (elts ?y))\n\ngoal (1 subgoal):\n 1. Ord 1", "by fastforce"], ["", "lemma OrdmemD: \"Ord k \\<Longrightarrow> j \\<in> elts k \\<Longrightarrow> j < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; j \\<in> elts k\\<rbrakk> \\<Longrightarrow> j < k", "using Ord_def Transset_def less_V_def"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  Transset ?x \\<equiv> \\<forall>y\\<in>elts ?x. y \\<le> ?x\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; j \\<in> elts k\\<rbrakk> \\<Longrightarrow> j < k", "by auto"], ["", "lemma Ord_trans: \"\\<lbrakk> i \\<in> elts j;  j \\<in> elts k;  Ord k \\<rbrakk>  \\<Longrightarrow> i \\<in> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> elts j; j \\<in> elts k; Ord k\\<rbrakk>\n    \\<Longrightarrow> i \\<in> elts k", "using Ord_def Transset_def"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  Transset ?x \\<equiv> \\<forall>y\\<in>elts ?x. y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> elts j; j \\<in> elts k; Ord k\\<rbrakk>\n    \\<Longrightarrow> i \\<in> elts k", "by blast"], ["", "lemma mem_0_Ord:\n  assumes k: \"Ord k\" and knz: \"k \\<noteq> 0\" shows \"0 \\<in> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> elts k", "by (metis Ord_def Transset_def inf.orderE k knz trad_foundation)"], ["", "lemma Ord_in_Ord: \"\\<lbrakk> Ord k;  m \\<in> elts k \\<rbrakk>  \\<Longrightarrow> Ord m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; m \\<in> elts k\\<rbrakk> \\<Longrightarrow> Ord m", "using Ord_def Ord_trans"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; m \\<in> elts k\\<rbrakk> \\<Longrightarrow> Ord m", "by blast"], ["", "lemma OrdI: \"\\<lbrakk>Transset i; \\<And>x. x \\<in> elts i \\<Longrightarrow> Transset x\\<rbrakk> \\<Longrightarrow> Ord i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transset i;\n     \\<And>x. x \\<in> elts i \\<Longrightarrow> Transset x\\<rbrakk>\n    \\<Longrightarrow> Ord i", "by (simp add: Ord_def)"], ["", "lemma Ord_is_Transset: \"Ord i \\<Longrightarrow> Transset i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> Transset i", "by (simp add: Ord_def)"], ["", "lemma Ord_contains_Transset: \"\\<lbrakk>Ord i; j \\<in> elts i\\<rbrakk> \\<Longrightarrow> Transset j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; j \\<in> elts i\\<rbrakk> \\<Longrightarrow> Transset j", "using Ord_def"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; j \\<in> elts i\\<rbrakk> \\<Longrightarrow> Transset j", "by blast"], ["", "lemma ON_imp_Ord:\n  assumes \"H \\<subseteq> ON\" \"x \\<in> H\"\n  shows \"Ord x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord x", "using assms"], ["proof (prove)\nusing this:\n  H \\<subseteq> ON\n  x \\<in> H\n\ngoal (1 subgoal):\n 1. Ord x", "by blast"], ["", "lemma elts_subset_ON: \"Ord \\<alpha> \\<Longrightarrow> elts \\<alpha> \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<Longrightarrow> elts \\<alpha> \\<subseteq> ON", "using Ord_in_Ord"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<Longrightarrow> elts \\<alpha> \\<subseteq> ON", "by blast"], ["", "lemma Transset_pred [simp]: \"Transset x \\<Longrightarrow> \\<Squnion>(elts (succ x)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset x \\<Longrightarrow> \\<Squnion> (elts (ZFC_in_HOL.succ x)) = x", "by (fastforce simp: Transset_def)"], ["", "lemma Ord_pred [simp]: \"Ord \\<beta> \\<Longrightarrow> \\<Squnion> (insert \\<beta> (elts \\<beta>)) = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<beta> \\<Longrightarrow>\n    \\<Squnion> (insert \\<beta> (elts \\<beta>)) = \\<beta>", "using Ord_def Transset_pred"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  Transset ?x \\<Longrightarrow> \\<Squnion> (elts (ZFC_in_HOL.succ ?x)) = ?x\n\ngoal (1 subgoal):\n 1. Ord \\<beta> \\<Longrightarrow>\n    \\<Squnion> (insert \\<beta> (elts \\<beta>)) = \\<beta>", "by auto"], ["", "subsubsection \\<open>Induction, Linearity, etc.\\<close>"], ["", "lemma Ord_induct [consumes 1, case_names step]:\n  assumes k: \"Ord k\"\n      and step: \"\\<And>x.\\<lbrakk> Ord x; \\<And>y. y \\<in> elts x \\<Longrightarrow> P y \\<rbrakk>  \\<Longrightarrow> P x\"\n    shows \"P k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P k", "using foundation k"], ["proof (prove)\nusing this:\n  wf {(x, y). x \\<in> elts y}\n  Ord k\n\ngoal (1 subgoal):\n 1. P k", "proof (induction k rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> {(x, y). x \\<in> elts y};\n                    Ord y\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> P x", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, x) \\<in> {(x, y). x \\<in> elts y}; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  Ord x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> {(x, y). x \\<in> elts y};\n                    Ord y\\<rbrakk>\n                   \\<Longrightarrow> P y;\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?y, x) \\<in> {(x, y). x \\<in> elts y}; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  Ord x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> {(x, y). x \\<in> elts y}; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  Ord x\n\ngoal (1 subgoal):\n 1. P x", "using Ord_in_Ord local.step"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> {(x, y). x \\<in> elts y}; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> P ?y\n  Ord x\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>Ord ?x; \\<And>y. y \\<in> elts ?x \\<Longrightarrow> P y\\<rbrakk>\n  \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. P x", "by auto"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Comparability of ordinals\\<close>"], ["", "lemma Ord_linear: \"Ord k \\<Longrightarrow> Ord l \\<Longrightarrow> k \\<in> elts l \\<or> k=l \\<or> l \\<in> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; Ord l\\<rbrakk>\n    \\<Longrightarrow> k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k", "proof (induct k arbitrary: l rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>Ord x;\n        \\<And>y l.\n           \\<lbrakk>y \\<in> elts x; Ord l\\<rbrakk>\n           \\<Longrightarrow> y \\<in> elts l \\<or>\n                             y = l \\<or> l \\<in> elts y;\n        Ord l\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts l \\<or> x = l \\<or> l \\<in> elts x", "case (step k)"], ["proof (state)\nthis:\n  Ord k\n  \\<lbrakk>?y \\<in> elts k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> elts ?l \\<or> ?y = ?l \\<or> ?l \\<in> elts ?y\n  Ord l\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>Ord x;\n        \\<And>y l.\n           \\<lbrakk>y \\<in> elts x; Ord l\\<rbrakk>\n           \\<Longrightarrow> y \\<in> elts l \\<or>\n                             y = l \\<or> l \\<in> elts y;\n        Ord l\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts l \\<or> x = l \\<or> l \\<in> elts x", "note step_k = step"], ["proof (state)\nthis:\n  Ord k\n  \\<lbrakk>?y \\<in> elts k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> elts ?l \\<or> ?y = ?l \\<or> ?l \\<in> elts ?y\n  Ord l\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>Ord x;\n        \\<And>y l.\n           \\<lbrakk>y \\<in> elts x; Ord l\\<rbrakk>\n           \\<Longrightarrow> y \\<in> elts l \\<or>\n                             y = l \\<or> l \\<in> elts y;\n        Ord l\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts l \\<or> x = l \\<or> l \\<in> elts x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k", "using \\<open>Ord l\\<close>"], ["proof (prove)\nusing this:\n  Ord l\n\ngoal (1 subgoal):\n 1. k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k", "proof (induct l rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           k \\<in> elts y \\<or> k = y \\<or> y \\<in> elts k\\<rbrakk>\n       \\<Longrightarrow> k \\<in> elts x \\<or> k = x \\<or> x \\<in> elts k", "case (step l)"], ["proof (state)\nthis:\n  Ord l\n  ?y \\<in> elts l \\<Longrightarrow>\n  k \\<in> elts ?y \\<or> k = ?y \\<or> ?y \\<in> elts k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           k \\<in> elts y \\<or> k = y \\<or> y \\<in> elts k\\<rbrakk>\n       \\<Longrightarrow> k \\<in> elts x \\<or> k = x \\<or> x \\<in> elts k", "thus ?case"], ["proof (prove)\nusing this:\n  Ord l\n  ?y \\<in> elts l \\<Longrightarrow>\n  k \\<in> elts ?y \\<or> k = ?y \\<or> ?y \\<in> elts k\n\ngoal (1 subgoal):\n 1. k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k", "using step_k"], ["proof (prove)\nusing this:\n  Ord l\n  ?y \\<in> elts l \\<Longrightarrow>\n  k \\<in> elts ?y \\<or> k = ?y \\<or> ?y \\<in> elts k\n  Ord k\n  \\<lbrakk>?y \\<in> elts k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> elts ?l \\<or> ?y = ?l \\<or> ?l \\<in> elts ?y\n  Ord la__\n\ngoal (1 subgoal):\n 1. k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k", "by (metis Ord_trans V_equalityI)"], ["proof (state)\nthis:\n  k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<in> elts l \\<or> k = l \\<or> l \\<in> elts k\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The trichotomy law for ordinals\\<close>"], ["", "lemma Ord_linear_lt:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (lt) \"k < l\" | (eq) \"k=l\" | (gt) \"l < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < l \\<Longrightarrow> thesis; k = l \\<Longrightarrow> thesis;\n     l < k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Ord_linear OrdmemD assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> ?k \\<in> elts ?l \\<or> ?k = ?l \\<or> ?l \\<in> elts ?k\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  Ord k\n  Ord l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < l \\<Longrightarrow> thesis; k = l \\<Longrightarrow> thesis;\n     l < k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma Ord_linear2:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (lt) \"k < l\" | (ge) \"l \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < l \\<Longrightarrow> thesis;\n     l \\<le> k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis Ord_linear_lt eq_refl assms order.strict_implies_order)"], ["", "lemma Ord_linear_le:\n  assumes \"Ord k\" \"Ord l\"\n  obtains (le) \"k \\<le> l\" | (ge) \"l \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> l \\<Longrightarrow> thesis;\n     l \\<le> k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (meson Ord_linear2 le_less assms)"], ["", "lemma union_less_iff [simp]: \"\\<lbrakk>Ord i; Ord j\\<rbrakk> \\<Longrightarrow> i \\<squnion> j < k \\<longleftrightarrow> i<k \\<and> j<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; Ord j\\<rbrakk>\n    \\<Longrightarrow> (i \\<squnion> j < k) = (i < k \\<and> j < k)", "by (metis Ord_linear_le le_iff_sup sup.order_iff sup.strict_boundedE)"], ["", "lemma Ord_mem_iff_lt: \"Ord k \\<Longrightarrow> Ord l \\<Longrightarrow> k \\<in> elts l \\<longleftrightarrow> k < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord k; Ord l\\<rbrakk>\n    \\<Longrightarrow> (k \\<in> elts l) = (k < l)", "by (metis Ord_linear OrdmemD less_le_not_le)"], ["", "lemma Ord_Collect_lt: \"Ord \\<alpha> \\<Longrightarrow> {\\<xi>. Ord \\<xi> \\<and> \\<xi> < \\<alpha>} = elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<Longrightarrow>\n    {\\<xi>. Ord \\<xi> \\<and> \\<xi> < \\<alpha>} = elts \\<alpha>", "by (auto simp flip: Ord_mem_iff_lt elim: Ord_in_Ord OrdmemD)"], ["", "lemma Ord_not_less: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> \\<not> x < y \\<longleftrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord x; Ord y\\<rbrakk>\n    \\<Longrightarrow> (\\<not> x < y) = (y \\<le> x)", "by (metis (no_types) Ord_linear2 leD)"], ["", "lemma Ord_not_le: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> \\<not> x \\<le> y \\<longleftrightarrow> y < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord x; Ord y\\<rbrakk>\n    \\<Longrightarrow> (\\<not> x \\<le> y) = (y < x)", "by (metis (no_types) Ord_linear2 leD)"], ["", "lemma le_succ_iff: \"Ord i \\<Longrightarrow> Ord j \\<Longrightarrow> succ i \\<le> succ j \\<longleftrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; Ord j\\<rbrakk>\n    \\<Longrightarrow> (ZFC_in_HOL.succ i \\<le> ZFC_in_HOL.succ j) =\n                      (i \\<le> j)", "by (metis Ord_linear_le Ord_succ le_succE order_antisym)"], ["", "lemma succ_le_iff: \"Ord i \\<Longrightarrow> Ord j \\<Longrightarrow> succ i \\<le> j \\<longleftrightarrow> i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; Ord j\\<rbrakk>\n    \\<Longrightarrow> (ZFC_in_HOL.succ i \\<le> j) = (i < j)", "using Ord_mem_iff_lt dual_order.strict_implies_order less_eq_V_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  ?b < ?a \\<Longrightarrow> ?b \\<le> ?a\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; Ord j\\<rbrakk>\n    \\<Longrightarrow> (ZFC_in_HOL.succ i \\<le> j) = (i < j)", "by fastforce"], ["", "lemma succ_in_Sup_Ord:\n  assumes eq: \"succ \\<beta> = \\<Squnion>A\" and \"small A\" \"A \\<subseteq> ON\" \"Ord \\<beta>\"\n  shows \"succ \\<beta> \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta> \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta> \\<in> A", "have \"\\<not> \\<Squnion>A \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<Squnion> A \\<le> \\<beta>", "using eq \\<open>Ord \\<beta>\\<close> succ_le_iff"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ \\<beta> = \\<Squnion> A\n  Ord \\<beta>\n  \\<lbrakk>Ord ?i; Ord ?j\\<rbrakk>\n  \\<Longrightarrow> (ZFC_in_HOL.succ ?i \\<le> ?j) = (?i < ?j)\n\ngoal (1 subgoal):\n 1. \\<not> \\<Squnion> A \\<le> \\<beta>", "by fastforce"], ["proof (state)\nthis:\n  \\<not> \\<Squnion> A \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta> \\<in> A", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<Squnion> A \\<le> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<Squnion> A \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta> \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  \\<not> \\<Squnion> A \\<le> \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<Squnion> A\n  small A\n  A \\<subseteq> ON\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta> \\<in> A", "by (metis Ord_linear2 Sup_least Sup_upper eq_iff mem_Collect_eq subsetD succ_le_iff)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<beta> \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_in_succ [simp,intro]: \"Ord i \\<Longrightarrow> 0 \\<in> elts (succ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> 0 \\<in> elts (ZFC_in_HOL.succ i)", "using mem_0_Ord"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?k \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 0 \\<in> elts ?k\n\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> 0 \\<in> elts (ZFC_in_HOL.succ i)", "by auto"], ["", "lemma Ord_finite_Sup: \"\\<lbrakk>finite A; A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk> \\<Longrightarrow> \\<Squnion>A \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> A \\<in> A", "proof (induction A rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> ON; {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> {} \\<in> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> ON; F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> \\<Squnion> F \\<in> F;\n        insert x F \\<subseteq> ON; insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (insert x F) \\<in> insert x F", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> A \\<in> A\n  insert x A \\<subseteq> ON\n  insert x A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> ON; {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> {} \\<in> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> ON; F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> \\<Squnion> F \\<in> F;\n        insert x F \\<subseteq> ON; insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (insert x F) \\<in> insert x F", "then"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> A \\<in> A\n  insert x A \\<subseteq> ON\n  insert x A \\<noteq> {}", "have *: \"small A\" \"A \\<subseteq> ON\" \"Ord x\""], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> A \\<in> A\n  insert x A \\<subseteq> ON\n  insert x A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. small A &&& A \\<subseteq> ON &&& Ord x", "by (auto simp add: ZFC_in_HOL.finite_imp_small insert.hyps)"], ["proof (state)\nthis:\n  small A\n  A \\<subseteq> ON\n  Ord x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> ON; {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> {} \\<in> {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> ON; F \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> \\<Squnion> F \\<in> F;\n        insert x F \\<subseteq> ON; insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (insert x F) \\<in> insert x F", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (insert x A) \\<in> insert x A", "proof (cases \"A = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A\n 2. A \\<noteq> {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A", "case False"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A\n 2. A \\<noteq> {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A", "then"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "have \"\\<Squnion>A \\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<in> A", "using insert"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  finite A\n  x \\<notin> A\n  \\<lbrakk>A \\<subseteq> ON; A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> A \\<in> A\n  insert x A \\<subseteq> ON\n  insert x A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<in> A", "by blast"], ["proof (state)\nthis:\n  \\<Squnion> A \\<in> A\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A\n 2. A \\<noteq> {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> A \\<in> A", "have \"\\<Squnion>A \\<le> x\" if \"x \\<squnion> \\<Squnion>A \\<notin> A\""], ["proof (prove)\nusing this:\n  \\<Squnion> A \\<in> A\n\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<le> x", "using *"], ["proof (prove)\nusing this:\n  \\<Squnion> A \\<in> A\n  small A\n  A \\<subseteq> ON\n  Ord x\n\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<le> x", "by (metis ON_imp_Ord Ord_linear_le sup.absorb2 that)"], ["proof (state)\nthis:\n  x \\<squnion> \\<Squnion> A \\<notin> A \\<Longrightarrow>\n  \\<Squnion> A \\<le> x\n\ngoal (2 subgoals):\n 1. A = {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A\n 2. A \\<noteq> {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A", "then"], ["proof (chain)\npicking this:\n  x \\<squnion> \\<Squnion> A \\<notin> A \\<Longrightarrow>\n  \\<Squnion> A \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<squnion> \\<Squnion> A \\<notin> A \\<Longrightarrow>\n  \\<Squnion> A \\<le> x\n\ngoal (1 subgoal):\n 1. \\<Squnion> (insert x A) \\<in> insert x A", "by (fastforce simp: \\<open>small A\\<close> Sup_V_insert)"], ["proof (state)\nthis:\n  \\<Squnion> (insert x A) \\<in> insert x A\n\ngoal (1 subgoal):\n 1. A = {} \\<Longrightarrow> \\<Squnion> (insert x A) \\<in> insert x A", "qed auto"], ["proof (state)\nthis:\n  \\<Squnion> (insert x A) \\<in> insert x A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<subseteq> ON; {} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> {} \\<in> {}", "qed auto"], ["", "subsubsection \\<open>The natural numbers\\<close>"], ["", "primrec ord_of_nat :: \"nat \\<Rightarrow> V\" where\n  \"ord_of_nat 0 = 0\"\n| \"ord_of_nat (Suc n) = succ (ord_of_nat n)\""], ["", "lemma ord_of_nat_eq_initial: \"ord_of_nat n = set (ord_of_nat ` {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n = set (ord_of_nat ` {..<n})", "by (induction n) (auto simp: lessThan_Suc succ_def)"], ["", "lemma mem_ord_of_nat_iff [simp]: \"x \\<in> elts (ord_of_nat n) \\<longleftrightarrow> (\\<exists>m<n. x = ord_of_nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> elts (ord_of_nat n)) = (\\<exists>m<n. x = ord_of_nat m)", "by (subst ord_of_nat_eq_initial) auto"], ["", "lemma elts_ord_of_nat: \"elts (ord_of_nat k) = ord_of_nat ` {..<k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ord_of_nat k) = ord_of_nat ` {..<k}", "by auto"], ["", "lemma Ord_equality: \"Ord i \\<Longrightarrow> i = \\<Squnion> (succ ` elts i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> i = \\<Squnion> (ZFC_in_HOL.succ ` elts i)", "by (force intro: Ord_trans)"], ["", "lemma Ord_ord_of_nat [simp]: \"Ord (ord_of_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ord_of_nat k)", "by (induct k, auto)"], ["", "lemma ord_of_nat_equality: \"ord_of_nat n = \\<Squnion> ((succ \\<circ> ord_of_nat) ` {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n =\n    \\<Squnion> ((ZFC_in_HOL.succ \\<circ> ord_of_nat) ` {..<n})", "by (metis Ord_equality Ord_ord_of_nat elts_of_set image_comp small_image_nat_V ord_of_nat_eq_initial)"], ["", "definition \\<omega> :: V where \"\\<omega> \\<equiv> set (range ord_of_nat)\""], ["", "lemma elts_\\<omega>: \"elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}", "by (auto simp: \\<omega>_def image_iff)"], ["", "lemma nat_into_Ord [simp]: \"n \\<in> elts \\<omega> \\<Longrightarrow> Ord n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> elts \\<omega> \\<Longrightarrow> Ord n", "by (metis Ord_ord_of_nat \\<omega>_def elts_of_set image_iff inf)"], ["", "lemma Sup_\\<omega>: \"\\<Squnion>(elts \\<omega>) = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (elts \\<omega>) = \\<omega>", "unfolding \\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (elts (set (range ord_of_nat))) = set (range ord_of_nat)", "by force"], ["", "lemma Ord_\\<omega> [iff]: \"Ord \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<omega>", "by (metis Ord_Sup Sup_\\<omega> nat_into_Ord)"], ["", "lemma zero_in_omega [iff]: \"0 \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> elts \\<omega>", "by (metis \\<omega>_def elts_of_set inf ord_of_nat.simps(1) rangeI)"], ["", "lemma succ_in_omega [simp]: \"n \\<in> elts \\<omega> \\<Longrightarrow> succ n \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> elts \\<omega> \\<Longrightarrow>\n    ZFC_in_HOL.succ n \\<in> elts \\<omega>", "by (metis \\<omega>_def elts_of_set image_iff small_image_nat_V ord_of_nat.simps(2) rangeI)"], ["", "lemma ord_of_eq_0: \"ord_of_nat j = 0 \\<Longrightarrow> j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat j = 0 \\<Longrightarrow> j = 0", "by (induct j) (auto simp: succ_neq_zero)"], ["", "lemma ord_of_nat_le_omega: \"ord_of_nat n \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n \\<le> \\<omega>", "by (metis Sup_\\<omega> ZFC_in_HOL.Sup_upper \\<omega>_def elts_of_set inf rangeI)"], ["", "lemma ord_of_eq_0_iff [simp]: \"ord_of_nat n = 0 \\<longleftrightarrow> n=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat n = 0) = (n = 0)", "by (auto simp: ord_of_eq_0)"], ["", "lemma ord_of_nat_inject [iff]: \"ord_of_nat i = ord_of_nat j \\<longleftrightarrow> i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat i = ord_of_nat j) = (i = j)", "proof (induct i arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. (ord_of_nat 0 = ord_of_nat j) = (0 = j)\n 2. \\<And>i j.\n       (\\<And>j. (ord_of_nat i = ord_of_nat j) = (i = j)) \\<Longrightarrow>\n       (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>j. (ord_of_nat 0 = ord_of_nat j) = (0 = j)\n 2. \\<And>i j.\n       (\\<And>j. (ord_of_nat i = ord_of_nat j) = (i = j)) \\<Longrightarrow>\n       (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat 0 = ord_of_nat j) = (0 = j)", "using ord_of_eq_0"], ["proof (prove)\nusing this:\n  ord_of_nat ?j = 0 \\<Longrightarrow> ?j = 0\n\ngoal (1 subgoal):\n 1. (ord_of_nat 0 = ord_of_nat j) = (0 = j)", "by auto"], ["proof (state)\nthis:\n  (ord_of_nat 0 = ord_of_nat j) = (0 = j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. (ord_of_nat i = ord_of_nat j) = (i = j)) \\<Longrightarrow>\n       (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. (ord_of_nat i = ord_of_nat j) = (i = j)) \\<Longrightarrow>\n       (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "case (Suc i)"], ["proof (state)\nthis:\n  (ord_of_nat i = ord_of_nat ?j) = (i = ?j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       (\\<And>j. (ord_of_nat i = ord_of_nat j) = (i = j)) \\<Longrightarrow>\n       (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "then"], ["proof (chain)\npicking this:\n  (ord_of_nat i = ord_of_nat ?j) = (i = ?j)", "show ?case"], ["proof (prove)\nusing this:\n  (ord_of_nat i = ord_of_nat ?j) = (i = ?j)\n\ngoal (1 subgoal):\n 1. (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)", "by auto (metis elts_0 elts_succ insert_not_empty not0_implies_Suc ord_of_nat.simps succ_inject_iff)"], ["proof (state)\nthis:\n  (ord_of_nat (Suc i) = ord_of_nat j) = (Suc i = j)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary inj_ord_of_nat: \"inj ord_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ord_of_nat", "by (simp add: linorder_injI)"], ["", "corollary countable:\n  assumes \"countable X\" shows \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small X", "have \"X \\<subseteq> range (from_nat_into X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> range (from_nat_into X)", "by (simp add: assms subset_range_from_nat_into)"], ["proof (state)\nthis:\n  X \\<subseteq> range (from_nat_into X)\n\ngoal (1 subgoal):\n 1. small X", "then"], ["proof (chain)\npicking this:\n  X \\<subseteq> range (from_nat_into X)", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<subseteq> range (from_nat_into X)\n\ngoal (1 subgoal):\n 1. small X", "by (meson inf_raw inj_ord_of_nat replacement small_def smaller_than_small)"], ["proof (state)\nthis:\n  small X\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary infinite_\\<omega>: \"infinite (elts \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (elts \\<omega>)", "using range_inj_infinite [of ord_of_nat]"], ["proof (prove)\nusing this:\n  inj ord_of_nat \\<Longrightarrow> infinite (range ord_of_nat)\n\ngoal (1 subgoal):\n 1. infinite (elts \\<omega>)", "by (simp add: \\<omega>_def inj_ord_of_nat)"], ["", "corollary ord_of_nat_mono_iff [iff]: \"ord_of_nat i \\<le> ord_of_nat j \\<longleftrightarrow> i \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat i \\<le> ord_of_nat j) = (i \\<le> j)", "by (metis Ord_def Ord_ord_of_nat Transset_def eq_iff mem_ord_of_nat_iff not_less ord_of_nat_inject)"], ["", "corollary ord_of_nat_strict_mono_iff [iff]: \"ord_of_nat i < ord_of_nat j \\<longleftrightarrow> i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat i < ord_of_nat j) = (i < j)", "by (simp add: less_le_not_le)"], ["", "lemma small_image_nat [simp]:\n  fixes N :: \"nat set\" shows \"small (g ` N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (g ` N)", "by (simp add: countable)"], ["", "lemma finite_Ord_omega: \"\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts \\<alpha>)", "proof (clarsimp simp add: \\<omega>_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<alpha> = ord_of_nat x \\<Longrightarrow>\n       finite (elts (ord_of_nat x))", "show \"finite (elts (ord_of_nat n))\" if \"\\<alpha> = ord_of_nat n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (elts (ord_of_nat n))", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. finite (elts (ord_of_nat n))", "by (simp add: ord_of_nat_eq_initial [of n])"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat ?n \\<Longrightarrow> finite (elts (ord_of_nat ?n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_Ord_omega: \"Ord \\<alpha> \\<Longrightarrow> infinite (elts \\<alpha>) \\<Longrightarrow> \\<omega> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; infinite (elts \\<alpha>)\\<rbrakk>\n    \\<Longrightarrow> \\<omega> \\<le> \\<alpha>", "by (meson Ord_\\<omega> Ord_linear2 Ord_mem_iff_lt finite_Ord_omega)"], ["", "lemma ord_of_minus_1: \"n > 0 \\<Longrightarrow> ord_of_nat n = succ (ord_of_nat (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    ord_of_nat n = ZFC_in_HOL.succ (ord_of_nat (n - 1))", "by (metis Suc_diff_1 ord_of_nat.simps(2))"], ["", "lemma card_ord_of_nat [simp]: \"card (elts (ord_of_nat m)) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (elts (ord_of_nat m)) = m", "by (induction m) (auto simp: \\<omega>_def finite_Ord_omega)"], ["", "lemma ord_of_nat_\\<omega> [iff]:\"ord_of_nat n \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n \\<in> elts \\<omega>", "by (simp add: \\<omega>_def)"], ["", "lemma succ_\\<omega>_iff [iff]: \"succ n \\<in> elts \\<omega> \\<longleftrightarrow> n \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_in_HOL.succ n \\<in> elts \\<omega>) = (n \\<in> elts \\<omega>)", "by (metis Ord_\\<omega> OrdmemD elts_vinsert insert_iff less_V_def succ_def succ_in_omega vsubsetD)"], ["", "lemma \\<omega>_gt0 [simp]: \"\\<omega> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<omega>", "by (simp add: OrdmemD)"], ["", "lemma \\<omega>_gt1 [simp]: \"\\<omega> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<omega>", "by (simp add: OrdmemD one_V_def)"], ["", "subsubsection\\<open>Limit ordinals\\<close>"], ["", "definition Limit :: \"V\\<Rightarrow>bool\"\n  where \"Limit i \\<equiv> Ord i \\<and> 0 \\<in> elts i \\<and> (\\<forall>y. y \\<in> elts i \\<longrightarrow> succ y \\<in> elts i)\""], ["", "lemma zero_not_Limit [iff]: \"\\<not> Limit 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Limit 0", "by (simp add: Limit_def)"], ["", "lemma not_succ_Limit [simp]: \"\\<not> Limit(succ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Limit (ZFC_in_HOL.succ i)", "by (metis Limit_def Ord_mem_iff_lt elts_succ insertI1 less_irrefl)"], ["", "lemma Limit_is_Ord: \"Limit \\<xi> \\<Longrightarrow> Ord \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<xi> \\<Longrightarrow> Ord \\<xi>", "by (simp add: Limit_def)"], ["", "lemma succ_in_Limit_iff: \"Limit \\<xi> \\<Longrightarrow> succ \\<alpha> \\<in> elts \\<xi> \\<longleftrightarrow> \\<alpha> \\<in> elts \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<xi> \\<Longrightarrow>\n    (ZFC_in_HOL.succ \\<alpha> \\<in> elts \\<xi>) =\n    (\\<alpha> \\<in> elts \\<xi>)", "by (metis Limit_def OrdmemD elts_succ insertI1 less_V_def vsubsetD)"], ["", "lemma Limit_eq_Sup_self [simp]: \"Limit i \\<Longrightarrow> Sup (elts i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i \\<Longrightarrow> \\<Squnion> (elts i) = i", "apply (rule order_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Limit i \\<Longrightarrow> \\<Squnion> (elts i) \\<le> i\n 2. Limit i \\<Longrightarrow> i \\<le> \\<Squnion> (elts i)", "apply (simp add: Limit_def Ord_def Transset_def Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i \\<Longrightarrow> i \\<le> \\<Squnion> (elts i)", "by (metis Limit_def Ord_equality Sup_V_def SUP_le_iff Sup_upper small_elts)"], ["", "lemma zero_less_Limit: \"Limit \\<beta> \\<Longrightarrow> 0 < \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<beta> \\<Longrightarrow> 0 < \\<beta>", "by (simp add: Limit_def OrdmemD)"], ["", "lemma non_Limit_ord_of_nat [iff]: \"\\<not> Limit (ord_of_nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Limit (ord_of_nat m)", "by (metis Limit_def mem_ord_of_nat_iff not_succ_Limit ord_of_eq_0_iff ord_of_minus_1)"], ["", "lemma Limit_omega [iff]: \"Limit \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<omega>", "by (simp add: Limit_def)"], ["", "lemma omega_nonzero [simp]: \"\\<omega> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<noteq> 0", "using Limit_omega"], ["proof (prove)\nusing this:\n  Limit \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<noteq> 0", "by fastforce"], ["", "lemma Ord_cases_lemma:\n  assumes \"Ord k\" shows \"k = 0 \\<or> (\\<exists>j. k = succ j) \\<or> Limit k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "proof (cases \"Limit k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k\n 2. \\<not> Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "case False"], ["proof (state)\nthis:\n  \\<not> Limit k\n\ngoal (2 subgoals):\n 1. Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k\n 2. \\<not> Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "have \"succ j \\<in> elts k\" if  \"\\<forall>j. k \\<noteq> succ j\" \"j \\<in> elts k\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ j \\<in> elts k", "by (metis Ord_in_Ord Ord_linear Ord_succ assms elts_succ insertE mem_not_sym that)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j. k \\<noteq> ZFC_in_HOL.succ j;\n   ?j \\<in> elts k\\<rbrakk>\n  \\<Longrightarrow> ZFC_in_HOL.succ ?j \\<in> elts k\n\ngoal (2 subgoals):\n 1. Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k\n 2. \\<not> Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "with assms"], ["proof (chain)\npicking this:\n  Ord k\n  \\<lbrakk>\\<forall>j. k \\<noteq> ZFC_in_HOL.succ j;\n   ?j \\<in> elts k\\<rbrakk>\n  \\<Longrightarrow> ZFC_in_HOL.succ ?j \\<in> elts k", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord k\n  \\<lbrakk>\\<forall>j. k \\<noteq> ZFC_in_HOL.succ j;\n   ?j \\<in> elts k\\<rbrakk>\n  \\<Longrightarrow> ZFC_in_HOL.succ ?j \\<in> elts k\n\ngoal (1 subgoal):\n 1. k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "by (auto simp: Limit_def mem_0_Ord)"], ["proof (state)\nthis:\n  k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k\n\ngoal (1 subgoal):\n 1. Limit k \\<Longrightarrow>\n    k = 0 \\<or> (\\<exists>j. k = ZFC_in_HOL.succ j) \\<or> Limit k", "qed auto"], ["", "lemma Ord_cases [cases type: V, case_names 0 succ limit]:\n  assumes \"Ord k\"\n  obtains \"k = 0\" | l where \"Ord l\" \"succ l = k\" | \"Limit k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k = 0 \\<Longrightarrow> thesis;\n     \\<And>l.\n        \\<lbrakk>Ord l; ZFC_in_HOL.succ l = k\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     Limit k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis assms Ord_cases_lemma Ord_in_Ord elts_succ insertI1)"], ["", "lemma non_succ_LimitI:\n  assumes \"i\\<noteq>0\" \"Ord(i)\" \"\\<And>y. succ(y) \\<noteq> i\"\n  shows \"Limit(i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i", "using Ord_cases_lemma assms"], ["proof (prove)\nusing this:\n  Ord ?k \\<Longrightarrow>\n  ?k = 0 \\<or> (\\<exists>j. ?k = ZFC_in_HOL.succ j) \\<or> Limit ?k\n  i \\<noteq> 0\n  Ord i\n  ZFC_in_HOL.succ ?y \\<noteq> i\n\ngoal (1 subgoal):\n 1. Limit i", "by blast"], ["", "lemma Ord_induct3 [consumes 1, case_names 0 succ Limit, induct type: V]:\n  assumes \\<alpha>: \"Ord \\<alpha>\"\n    and P: \"P 0\" \"\\<And>\\<alpha>. \\<lbrakk>Ord \\<alpha>; P \\<alpha>\\<rbrakk> \\<Longrightarrow> P (succ \\<alpha>)\"\n           \"\\<And>\\<alpha>. \\<lbrakk>Limit \\<alpha>; \\<And>\\<xi>. \\<xi> \\<in> elts \\<alpha> \\<Longrightarrow> P \\<xi>\\<rbrakk> \\<Longrightarrow> P (SUP \\<xi> \\<in> elts \\<alpha>. \\<xi>)\"\n  shows \"P \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<alpha>", "using \\<alpha>"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. P \\<alpha>", "proof (induction \\<alpha> rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y. y \\<in> elts x \\<Longrightarrow> P y\\<rbrakk>\n       \\<Longrightarrow> P x", "case (step \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  ?y \\<in> elts \\<alpha> \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y. y \\<in> elts x \\<Longrightarrow> P y\\<rbrakk>\n       \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  ?y \\<in> elts \\<alpha> \\<Longrightarrow> P ?y", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  ?y \\<in> elts \\<alpha> \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. P \\<alpha>", "by (metis Limit_eq_Sup_self Ord_cases P elts_succ image_ident insertI1)"], ["proof (state)\nthis:\n  P \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Properties of LEAST for ordinals\\<close>"], ["", "lemma\n  assumes \"Ord k\" \"P k\"\n  shows Ord_LeastI: \"P (LEAST i. Ord i \\<and> P i)\" and Ord_Least_le: \"(LEAST i. Ord i \\<and> P i) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) &&& (LEAST i. Ord i \\<and> P i) \\<le> k", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. P (LEAST i. Ord i \\<and> P i)\n 2. (LEAST i. Ord i \\<and> P i) \\<le> k", "have \"P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k", "using assms"], ["proof (prove)\nusing this:\n  Ord k\n  P k\n\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k", "proof (induct k rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; P y\\<rbrakk>\n           \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                             (LEAST i. Ord i \\<and> P i) \\<le> y;\n        P x\\<rbrakk>\n       \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                         (LEAST i. Ord i \\<and> P i) \\<le> x", "case (step x)"], ["proof (state)\nthis:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; P ?y\\<rbrakk>\n  \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                    (LEAST i. Ord i \\<and> P i) \\<le> ?y\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; P y\\<rbrakk>\n           \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                             (LEAST i. Ord i \\<and> P i) \\<le> y;\n        P x\\<rbrakk>\n       \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                         (LEAST i. Ord i \\<and> P i) \\<le> x", "then"], ["proof (chain)\npicking this:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; P ?y\\<rbrakk>\n  \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                    (LEAST i. Ord i \\<and> P i) \\<le> ?y\n  P x", "have \"P x\""], ["proof (prove)\nusing this:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; P ?y\\<rbrakk>\n  \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                    (LEAST i. Ord i \\<and> P i) \\<le> ?y\n  P x\n\ngoal (1 subgoal):\n 1. P x", "by simp"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; P y\\<rbrakk>\n           \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                             (LEAST i. Ord i \\<and> P i) \\<le> y;\n        P x\\<rbrakk>\n       \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                         (LEAST i. Ord i \\<and> P i) \\<le> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "proof (rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (P (LEAST i. Ord i \\<and> P i) \\<and>\n            (LEAST i. Ord i \\<and> P i) \\<le> x) \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "assume assm: \"\\<not> (P (LEAST a. Ord a \\<and> P a) \\<and> (LEAST a. Ord a \\<and> P a) \\<le> x)\""], ["proof (state)\nthis:\n  \\<not> (P (LEAST a. Ord a \\<and> P a) \\<and>\n          (LEAST a. Ord a \\<and> P a) \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<not> (P (LEAST i. Ord i \\<and> P i) \\<and>\n            (LEAST i. Ord i \\<and> P i) \\<le> x) \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "have \"\\<And>y. Ord y \\<and> P y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. Ord y \\<and> P y \\<Longrightarrow> x \\<le> y", "proof (rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Ord y \\<and> P y; \\<not> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Ord y \\<and> P y; \\<not> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "assume y: \"Ord y \\<and> P y\" \"\\<not> x \\<le> y\""], ["proof (state)\nthis:\n  Ord y \\<and> P y\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Ord y \\<and> P y; \\<not> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "with step"], ["proof (chain)\npicking this:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; P ?y\\<rbrakk>\n  \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                    (LEAST i. Ord i \\<and> P i) \\<le> ?y\n  P x\n  Ord y \\<and> P y\n  \\<not> x \\<le> y", "obtain \"P (LEAST a. Ord a \\<and> P a)\" and le: \"(LEAST a. Ord a \\<and> P a) \\<le> y\""], ["proof (prove)\nusing this:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; P ?y\\<rbrakk>\n  \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i) \\<and>\n                    (LEAST i. Ord i \\<and> P i) \\<le> ?y\n  P x\n  Ord y \\<and> P y\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>P (LEAST a. Ord a \\<and> P a);\n      (LEAST a. Ord a \\<and> P a) \\<le> y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson Ord_linear2 Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  P (LEAST a. Ord a \\<and> P a)\n  (LEAST a. Ord a \\<and> P a) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Ord y \\<and> P y; \\<not> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "with assm"], ["proof (chain)\npicking this:\n  \\<not> (P (LEAST a. Ord a \\<and> P a) \\<and>\n          (LEAST a. Ord a \\<and> P a) \\<le> x)\n  P (LEAST a. Ord a \\<and> P a)\n  (LEAST a. Ord a \\<and> P a) \\<le> y", "have \"x < (LEAST a. Ord a \\<and> P a)\""], ["proof (prove)\nusing this:\n  \\<not> (P (LEAST a. Ord a \\<and> P a) \\<and>\n          (LEAST a. Ord a \\<and> P a) \\<le> x)\n  P (LEAST a. Ord a \\<and> P a)\n  (LEAST a. Ord a \\<and> P a) \\<le> y\n\ngoal (1 subgoal):\n 1. x < (LEAST a. Ord a \\<and> P a)", "by (meson Ord_linear_le y order.trans \\<open>Ord x\\<close>)"], ["proof (state)\nthis:\n  x < (LEAST a. Ord a \\<and> P a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Ord y \\<and> P y; \\<not> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  x < (LEAST a. Ord a \\<and> P a)", "show \"x \\<le> y\""], ["proof (prove)\nusing this:\n  x < (LEAST a. Ord a \\<and> P a)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "using le"], ["proof (prove)\nusing this:\n  x < (LEAST a. Ord a \\<and> P a)\n  (LEAST a. Ord a \\<and> P a) \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ord ?y \\<and> P ?y \\<Longrightarrow> x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<not> (P (LEAST i. Ord i \\<and> P i) \\<and>\n            (LEAST i. Ord i \\<and> P i) \\<le> x) \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "then"], ["proof (chain)\npicking this:\n  Ord ?y \\<and> P ?y \\<Longrightarrow> x \\<le> ?y", "have Least: \"(LEAST a. Ord a \\<and> P a) = x\""], ["proof (prove)\nusing this:\n  Ord ?y \\<and> P ?y \\<Longrightarrow> x \\<le> ?y\n\ngoal (1 subgoal):\n 1. (LEAST a. Ord a \\<and> P a) = x", "by (simp add: Least_equality \\<open>Ord x\\<close> step.prems)"], ["proof (state)\nthis:\n  (LEAST a. Ord a \\<and> P a) = x\n\ngoal (1 subgoal):\n 1. \\<not> (P (LEAST i. Ord i \\<and> P i) \\<and>\n            (LEAST i. Ord i \\<and> P i) \\<le> x) \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "with \\<open>P x\\<close>"], ["proof (chain)\npicking this:\n  P x\n  (LEAST a. Ord a \\<and> P a) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  P x\n  (LEAST a. Ord a \\<and> P a) = x\n\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x", "by simp"], ["proof (state)\nthis:\n  P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k\n\ngoal (2 subgoals):\n 1. P (LEAST i. Ord i \\<and> P i)\n 2. (LEAST i. Ord i \\<and> P i) \\<le> k", "then"], ["proof (chain)\npicking this:\n  P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k", "show \"P (LEAST i. Ord i \\<and> P i)\" and \"(LEAST i. Ord i \\<and> P i) \\<le> k\""], ["proof (prove)\nusing this:\n  P (LEAST i. Ord i \\<and> P i) \\<and> (LEAST i. Ord i \\<and> P i) \\<le> k\n\ngoal (1 subgoal):\n 1. P (LEAST i. Ord i \\<and> P i) &&& (LEAST i. Ord i \\<and> P i) \\<le> k", "by auto"], ["proof (state)\nthis:\n  P (LEAST i. Ord i \\<and> P i)\n  (LEAST i. Ord i \\<and> P i) \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_Least:\n  assumes \"Ord k\" \"P k\"\n  shows \"Ord (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i)", "have \"Ord (LEAST i. Ord i \\<and> (Ord i \\<and> P i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i)", "using Ord_LeastI [where P = \"\\<lambda>i. Ord i \\<and> P i\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?k \\<and> P ?k\\<rbrakk>\n  \\<Longrightarrow> Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i) \\<and>\n                    P (LEAST i. Ord i \\<and> Ord i \\<and> P i)\n  Ord k\n  P k\n\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i)", "by blast"], ["proof (state)\nthis:\n  Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i)\n\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i)", "then"], ["proof (chain)\npicking this:\n  Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i)", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord (LEAST i. Ord i \\<and> Ord i \\<and> P i)\n\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i)", "by simp"], ["proof (state)\nthis:\n  Ord (LEAST i. Ord i \\<and> P i)\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>The following 3 lemmas are due to Brian Huffman\\<close>"], ["", "lemma Ord_LeastI_ex: \"\\<exists>i. Ord i \\<and> P i \\<Longrightarrow> P (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. Ord i \\<and> P i \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i)", "using Ord_LeastI"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?P ?k\\<rbrakk>\n  \\<Longrightarrow> ?P (LEAST i. Ord i \\<and> ?P i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. Ord i \\<and> P i \\<Longrightarrow>\n    P (LEAST i. Ord i \\<and> P i)", "by blast"], ["", "lemma Ord_LeastI2:\n  \"\\<lbrakk>Ord a; P a; \\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x\\<rbrakk> \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord a; P a;\n     \\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)", "by (blast intro: Ord_LeastI Ord_Least)"], ["", "lemma Ord_LeastI2_ex:\n  \"\\<exists>a. Ord a \\<and> P a \\<Longrightarrow> (\\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x) \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>a. Ord a \\<and> P a;\n     \\<And>x. \\<lbrakk>Ord x; P x\\<rbrakk> \\<Longrightarrow> Q x\\<rbrakk>\n    \\<Longrightarrow> Q (LEAST i. Ord i \\<and> P i)", "by (blast intro: Ord_LeastI_ex Ord_Least)"], ["", "lemma Ord_LeastI2_wellorder:\n  assumes \"Ord a\" \"P a\"\n  and \"\\<And>a. \\<lbrakk> P a; \\<forall>b. Ord b \\<and> P b \\<longrightarrow> a \\<le> b \\<rbrakk> \\<Longrightarrow> Q a\"\n  shows \"Q (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (LEAST i. Ord i \\<and> P i)", "proof (rule LeastI2_order)"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord ?x \\<and> P ?x\n 2. \\<And>y. Ord y \\<and> P y \\<Longrightarrow> ?x \\<le> y\n 3. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "show \"Ord (LEAST i. Ord i \\<and> P i) \\<and> P (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i) \\<and> P (LEAST i. Ord i \\<and> P i)", "using Ord_Least Ord_LeastI assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?P ?k\\<rbrakk>\n  \\<Longrightarrow> Ord (LEAST i. Ord i \\<and> ?P i)\n  \\<lbrakk>Ord ?k; ?P ?k\\<rbrakk>\n  \\<Longrightarrow> ?P (LEAST i. Ord i \\<and> ?P i)\n  Ord a\n  P a\n  \\<lbrakk>P ?a;\n   \\<forall>b. Ord b \\<and> P b \\<longrightarrow> ?a \\<le> b\\<rbrakk>\n  \\<Longrightarrow> Q ?a\n\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> P i) \\<and> P (LEAST i. Ord i \\<and> P i)", "by auto"], ["proof (state)\nthis:\n  Ord (LEAST i. Ord i \\<and> P i) \\<and> P (LEAST i. Ord i \\<and> P i)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       Ord y \\<and> P y \\<Longrightarrow>\n       (LEAST i. Ord i \\<and> P i) \\<le> y\n 2. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       Ord y \\<and> P y \\<Longrightarrow>\n       (LEAST i. Ord i \\<and> P i) \\<le> y\n 2. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       Ord y \\<and> P y \\<Longrightarrow>\n       (LEAST i. Ord i \\<and> P i) \\<le> y\n 2. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "assume \"Ord y \\<and> P y\""], ["proof (state)\nthis:\n  Ord y \\<and> P y\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       Ord y \\<and> P y \\<Longrightarrow>\n       (LEAST i. Ord i \\<and> P i) \\<le> y\n 2. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "thus \"(LEAST i. Ord i \\<and> P i) \\<le> y\""], ["proof (prove)\nusing this:\n  Ord y \\<and> P y\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> P i) \\<le> y", "by (simp add: Ord_Least_le)"], ["proof (state)\nthis:\n  (LEAST i. Ord i \\<and> P i) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "assume \"Ord x \\<and> P x\" \"\\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\""], ["proof (state)\nthis:\n  Ord x \\<and> P x\n  \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x \\<and> P x;\n        \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> Q x", "thus \"Q x\""], ["proof (prove)\nusing this:\n  Ord x \\<and> P x\n  \\<forall>y. Ord y \\<and> P y \\<longrightarrow> x \\<le> y\n\ngoal (1 subgoal):\n 1. Q x", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  Q x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_LeastI2_wellorder_ex:\n  assumes \"\\<exists>x. Ord x \\<and> P x\"\n  and \"\\<And>a. \\<lbrakk> P a; \\<forall>b. Ord b \\<and> P b \\<longrightarrow> a \\<le> b \\<rbrakk> \\<Longrightarrow> Q a\"\n  shows \"Q (LEAST i. Ord i \\<and> P i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (LEAST i. Ord i \\<and> P i)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x. Ord x \\<and> P x\n  \\<lbrakk>P ?a;\n   \\<forall>b. Ord b \\<and> P b \\<longrightarrow> ?a \\<le> b\\<rbrakk>\n  \\<Longrightarrow> Q ?a\n\ngoal (1 subgoal):\n 1. Q (LEAST i. Ord i \\<and> P i)", "by clarify (blast intro!: Ord_LeastI2_wellorder)"], ["", "lemma not_less_Ord_Least: \"\\<lbrakk>k < (LEAST x. Ord x \\<and> P x); Ord k\\<rbrakk> \\<Longrightarrow> \\<not> P k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < (LEAST x. Ord x \\<and> P x); Ord k\\<rbrakk>\n    \\<Longrightarrow> \\<not> P k", "using Ord_Least_le less_le_not_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?P ?k\\<rbrakk>\n  \\<Longrightarrow> (LEAST i. Ord i \\<and> ?P i) \\<le> ?k\n  (?x < ?y) = (?x \\<le> ?y \\<and> \\<not> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < (LEAST x. Ord x \\<and> P x); Ord k\\<rbrakk>\n    \\<Longrightarrow> \\<not> P k", "by auto"], ["", "lemma exists_Ord_Least_iff: \"(\\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>) \\<longleftrightarrow> (\\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<and> (\\<forall>\\<beta> < \\<alpha>. Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>) =\n    (\\<exists>\\<alpha>.\n        Ord \\<alpha> \\<and>\n        P \\<alpha> \\<and>\n        (\\<forall>\\<beta><\\<alpha>.\n            Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)\n 2. \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>) \\<Longrightarrow>\n    \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>.\n     Ord \\<alpha> \\<and>\n     P \\<alpha> \\<and>\n     (\\<forall>\\<beta><\\<alpha>.\n         Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)\n\ngoal (2 subgoals):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)\n 2. \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>) \\<Longrightarrow>\n    \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>", "thus ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>.\n     Ord \\<alpha> \\<and>\n     P \\<alpha> \\<and>\n     (\\<forall>\\<beta><\\<alpha>.\n         Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "assume H: ?lhs"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>", "obtain \\<alpha> where \\<alpha>: \"Ord \\<alpha>\" \"P \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<lbrakk>Ord \\<alpha>; P \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  P \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "let ?x = \"LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "have \"Ord ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)", "by (metis Ord_Least \\<alpha>)"], ["proof (state)\nthis:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "moreover"], ["proof (state)\nthis:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "{"], ["proof (state)\nthis:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "fix \\<beta>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "assume m: \"\\<beta> < ?x\" \"Ord \\<beta>\""], ["proof (state)\nthis:\n  \\<beta> < (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "from not_less_Ord_Least[OF m]"], ["proof (chain)\npicking this:\n  \\<not> P \\<beta>", "have \"\\<not> P \\<beta>\""], ["proof (prove)\nusing this:\n  \\<not> P \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> P \\<beta>", "."], ["proof (state)\nthis:\n  \\<not> P \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<beta>2 < (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>);\n   Ord ?\\<beta>2\\<rbrakk>\n  \\<Longrightarrow> \\<not> P ?\\<beta>2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. Ord \\<alpha> \\<and> P \\<alpha> \\<Longrightarrow>\n    \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "ultimately"], ["proof (chain)\npicking this:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n  \\<lbrakk>?\\<beta>2 < (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>);\n   Ord ?\\<beta>2\\<rbrakk>\n  \\<Longrightarrow> \\<not> P ?\\<beta>2", "show ?rhs"], ["proof (prove)\nusing this:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n  \\<lbrakk>?\\<beta>2 < (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>);\n   Ord ?\\<beta>2\\<rbrakk>\n  \\<Longrightarrow> \\<not> P ?\\<beta>2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "using Ord_LeastI_ex[OF H]"], ["proof (prove)\nusing this:\n  Ord (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>)\n  \\<lbrakk>?\\<beta>2 < (LEAST \\<alpha>. Ord \\<alpha> \\<and> P \\<alpha>);\n   Ord ?\\<beta>2\\<rbrakk>\n  \\<Longrightarrow> \\<not> P ?\\<beta>2\n  P (LEAST i. Ord i \\<and> P i)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>.\n       Ord \\<alpha> \\<and>\n       P \\<alpha> \\<and>\n       (\\<forall>\\<beta><\\<alpha>.\n           Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>.\n     Ord \\<alpha> \\<and>\n     P \\<alpha> \\<and>\n     (\\<forall>\\<beta><\\<alpha>.\n         Ord \\<beta> \\<longrightarrow> \\<not> P \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_mono_imp_increasing:\n  assumes fun_hD: \"h \\<in> D \\<rightarrow> D\"\n    and mono_h: \"strict_mono_on h D\" \n    and \"D \\<subseteq> ON\" and \\<nu>: \"\\<nu> \\<in> D\"\n  shows \"\\<nu> \\<le> h \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nu> \\<le> h \\<nu>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "assume non: \"\\<not> \\<nu> \\<le> h \\<nu>\""], ["proof (state)\nthis:\n  \\<not> \\<nu> \\<le> h \\<nu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "define \\<mu> where \"\\<mu> \\<equiv> LEAST \\<mu>. Ord \\<mu> \\<and> \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\""], ["proof (state)\nthis:\n  \\<mu> \\<equiv>\n  LEAST \\<mu>.\n     Ord \\<mu> \\<and> \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "have \"Ord \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<nu>", "using \\<nu> \\<open>D \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  \\<nu> \\<in> D\n  D \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<nu>", "by blast"], ["proof (state)\nthis:\n  Ord \\<nu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ord \\<nu>", "have \\<mu>: \"\\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\""], ["proof (prove)\nusing this:\n  Ord \\<nu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  Ord \\<nu>\n\ngoal (1 subgoal):\n 1. \\<not> (LEAST \\<mu>.\n               Ord \\<mu> \\<and>\n               \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D)\n           \\<le> h (LEAST \\<mu>.\n                       Ord \\<mu> \\<and>\n                       \\<not> \\<mu> \\<le> h \\<mu> \\<and>\n                       \\<mu> \\<in> D) \\<and>\n    (LEAST \\<mu>.\n        Ord \\<mu> \\<and> \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D)\n    \\<in> D", "by (rule Ord_LeastI) (simp add: \\<nu> non)"], ["proof (state)\nthis:\n  \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "have \"Ord (h \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (h \\<nu>)", "using assms"], ["proof (prove)\nusing this:\n  h \\<in> D \\<rightarrow> D\n  strict_mono_on h D\n  D \\<subseteq> ON\n  \\<nu> \\<in> D\n\ngoal (1 subgoal):\n 1. Ord (h \\<nu>)", "by auto"], ["proof (state)\nthis:\n  Ord (h \\<nu>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ord (h \\<nu>)", "have \"Ord (h (h \\<nu>))\""], ["proof (prove)\nusing this:\n  Ord (h \\<nu>)\n\ngoal (1 subgoal):\n 1. Ord (h (h \\<nu>))", "by (meson ON_imp_Ord \\<nu> assms funcset_mem)"], ["proof (state)\nthis:\n  Ord (h (h \\<nu>))\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "have \"Ord \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<mu>", "using \\<mu> \\<open>D \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n  D \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<mu>", "by blast"], ["proof (state)\nthis:\n  Ord \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ord \\<mu>", "have \"h \\<mu> < \\<mu>\""], ["proof (prove)\nusing this:\n  Ord \\<mu>\n\ngoal (1 subgoal):\n 1. h \\<mu> < \\<mu>", "by (metis ON_imp_Ord Ord_linear2 PiE \\<mu> \\<open>D \\<subseteq> ON\\<close> fun_hD)"], ["proof (state)\nthis:\n  h \\<mu> < \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  h \\<mu> < \\<mu>", "have \"\\<not> h \\<mu> \\<le> h (h \\<mu>)\""], ["proof (prove)\nusing this:\n  h \\<mu> < \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> h \\<mu> \\<le> h (h \\<mu>)", "using \\<mu> fun_hD mono_h"], ["proof (prove)\nusing this:\n  h \\<mu> < \\<mu>\n  \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n  h \\<in> D \\<rightarrow> D\n  strict_mono_on h D\n\ngoal (1 subgoal):\n 1. \\<not> h \\<mu> \\<le> h (h \\<mu>)", "by (force simp: strict_mono_on_def)"], ["proof (state)\nthis:\n  \\<not> h \\<mu> \\<le> h (h \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> h \\<mu> \\<le> h (h \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "have *: \"h \\<mu> \\<in> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<mu> \\<in> D", "using \\<mu> fun_hD"], ["proof (prove)\nusing this:\n  \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n  h \\<in> D \\<rightarrow> D\n\ngoal (1 subgoal):\n 1. h \\<mu> \\<in> D", "by auto"], ["proof (state)\nthis:\n  h \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  h \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "have \"Ord (h \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (h \\<mu>)", "using \\<open>D \\<subseteq> ON\\<close> *"], ["proof (prove)\nusing this:\n  D \\<subseteq> ON\n  h \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. Ord (h \\<mu>)", "by blast"], ["proof (state)\nthis:\n  Ord (h \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> h \\<mu> \\<le> h (h \\<mu>)\n  h \\<mu> \\<in> D\n  Ord (h \\<mu>)", "have \"\\<mu> \\<le> h \\<mu>\""], ["proof (prove)\nusing this:\n  \\<not> h \\<mu> \\<le> h (h \\<mu>)\n  h \\<mu> \\<in> D\n  Ord (h \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<mu> \\<le> h \\<mu>", "by (simp add: \\<mu>_def Ord_Least_le)"], ["proof (state)\nthis:\n  \\<mu> \\<le> h \\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> \\<nu> \\<le> h \\<nu> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<mu> \\<le> h \\<mu>", "show False"], ["proof (prove)\nusing this:\n  \\<mu> \\<le> h \\<mu>\n\ngoal (1 subgoal):\n 1. False", "using \\<mu>"], ["proof (prove)\nusing this:\n  \\<mu> \\<le> h \\<mu>\n  \\<not> \\<mu> \\<le> h \\<mu> \\<and> \\<mu> \\<in> D\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_Sup_iff:\n  assumes \"A \\<subseteq> ON\" \"Ord x\" \"small A\" shows \"x \\<le> \\<Squnion>A \\<longleftrightarrow> (\\<forall>y \\<in> ON. y<x \\<longrightarrow> (\\<exists>a\\<in>A. y < a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> \\<Squnion> A) =\n    (\\<forall>y\\<in>ON. y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a))", "proof (intro iffI ballI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>x \\<le> \\<Squnion> A; y \\<in> ON; y < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>A. y < a\n 2. \\<forall>y\\<in>ON.\n       y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a) \\<Longrightarrow>\n    x \\<le> \\<Squnion> A", "show \"\\<exists>a\\<in>A. y < a\"\n    if \"x \\<le> \\<Squnion> A\" \"y \\<in> ON\" \"y < x\"\n    for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. y < a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. y < a", "have \"\\<not> \\<Squnion> A \\<le> y\" \"Ord y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<Squnion> A \\<le> y &&& Ord y", "using that"], ["proof (prove)\nusing this:\n  x \\<le> \\<Squnion> A\n  y \\<in> ON\n  y < x\n\ngoal (1 subgoal):\n 1. \\<not> \\<Squnion> A \\<le> y &&& Ord y", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<Squnion> A \\<le> y\n  Ord y\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. y < a", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<Squnion> A \\<le> y\n  Ord y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<Squnion> A \\<le> y\n  Ord y\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>A. y < a", "by (metis Ord_linear2 Sup_least \\<open>A \\<subseteq> ON\\<close> mem_Collect_eq subset_eq)"], ["proof (state)\nthis:\n  \\<exists>a\\<in>A. y < a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> \\<Squnion> A; ?y \\<in> ON; ?y < x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a\\<in>A. ?y < a\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>ON.\n       y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a) \\<Longrightarrow>\n    x \\<le> \\<Squnion> A", "show \"x \\<le> \\<Squnion> A\"\n    if \"\\<forall>y\\<in>ON. y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> A", "using that assms"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>ON. y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a)\n  A \\<subseteq> ON\n  Ord x\n  small A\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> A", "by (metis Ord_Sup Ord_linear_le Sup_upper less_le_not_le mem_Collect_eq subsetD)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>ON.\n     y < x \\<longrightarrow> (\\<exists>a\\<in>A. y < a) \\<Longrightarrow>\n  x \\<le> \\<Squnion> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_SUP_iff: \"\\<lbrakk>f ` A \\<subseteq> ON; Ord x; small A\\<rbrakk> \\<Longrightarrow> x \\<le> \\<Squnion>(f ` A) \\<longleftrightarrow> (\\<forall>y \\<in> ON. y<x \\<longrightarrow> (\\<exists>i\\<in>A. y < f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f ` A \\<subseteq> ON; Ord x; small A\\<rbrakk>\n    \\<Longrightarrow> (x \\<le> \\<Squnion> (f ` A)) =\n                      (\\<forall>y\\<in>ON.\n                          y < x \\<longrightarrow>\n                          (\\<exists>i\\<in>A. y < f i))", "by (simp add: le_Sup_iff)"], ["", "subsection\\<open>Transfinite Recursion and the V-levels\\<close>"], ["", "definition transrec :: \"[[V\\<Rightarrow>V,V]\\<Rightarrow>V, V] \\<Rightarrow> V\"\n  where \"transrec H a \\<equiv> wfrec {(x,y). x \\<in> elts y} H a\""], ["", "lemma transrec: \"transrec H a = H (\\<lambda>x \\<in> elts a. transrec H x) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec H a = H (restrict (transrec H) (elts a)) a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. transrec H a = H (restrict (transrec H) (elts a)) a", "have \"(cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a)\n      = (\\<lambda>x\\<in>elts a. wfrec {(x, y). x \\<in> elts y} H x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a =\n    restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)", "by (force simp: cut_def)"], ["proof (state)\nthis:\n  cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a =\n  restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)\n\ngoal (1 subgoal):\n 1. transrec H a = H (restrict (transrec H) (elts a)) a", "then"], ["proof (chain)\npicking this:\n  cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a =\n  restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)", "show ?thesis"], ["proof (prove)\nusing this:\n  cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a =\n  restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)\n\ngoal (1 subgoal):\n 1. transrec H a = H (restrict (transrec H) (elts a)) a", "unfolding transrec_def"], ["proof (prove)\nusing this:\n  cut (wfrec {(x, y). x \\<in> elts y} H) {(x, y). x \\<in> elts y} a =\n  restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)\n\ngoal (1 subgoal):\n 1. wfrec {(x, y). x \\<in> elts y} H a =\n    H (restrict (wfrec {(x, y). x \\<in> elts y} H) (elts a)) a", "by (simp add: foundation wfrec)"], ["proof (state)\nthis:\n  transrec H a = H (restrict (transrec H) (elts a)) a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Avoids explosions in proofs; resolve it with a meta-level definition\\<close>"], ["", "lemma def_transrec:\n    \"\\<lbrakk>\\<And>x. f x \\<equiv> transrec H x\\<rbrakk> \\<Longrightarrow> f a = H(\\<lambda>x \\<in> elts a. f x) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<equiv> transrec H x) \\<Longrightarrow>\n    f a = H (restrict f (elts a)) a", "by (metis restrict_ext transrec)"], ["", "lemma eps_induct [case_names step]:\n  assumes \"\\<And>x. (\\<And>y. y \\<in> elts x \\<Longrightarrow> P y) \\<Longrightarrow> P x\"\n  shows \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a", "using wf_induct [OF foundation] assms"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<forall>y.\n         (y, x) \\<in> {(x, y). x \\<in> elts y} \\<longrightarrow>\n         ?P y \\<Longrightarrow>\n      ?P x) \\<Longrightarrow>\n  ?P ?a\n  (\\<And>y. y \\<in> elts ?x \\<Longrightarrow> P y) \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. P a", "by auto"], ["", "definition Vfrom :: \"[V,V] \\<Rightarrow> V\"\n  where \"Vfrom a \\<equiv> transrec (\\<lambda>f x. a \\<squnion> \\<Squnion>((\\<lambda>y. VPow(f y)) ` elts x))\""], ["", "abbreviation Vset :: \"V \\<Rightarrow> V\" where \"Vset \\<equiv> Vfrom 0\""], ["", "lemma Vfrom: \"Vfrom a i = a \\<squnion> \\<Squnion>((\\<lambda>j. VPow(Vfrom a j)) ` elts i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a i = a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))", "apply (subst Vfrom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec (\\<lambda>f x. a \\<squnion> (SUP y\\<in>elts x. VPow (f y))) i =\n    a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))", "apply (subst transrec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion>\n    (SUP y\\<in>elts i.\n        VPow\n         (restrict\n           (transrec\n             (\\<lambda>f x. a \\<squnion> (SUP y\\<in>elts x. VPow (f y))))\n           (elts i) y)) =\n    a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))", "using Vfrom_def"], ["proof (prove)\nusing this:\n  Vfrom ?a \\<equiv>\n  transrec (\\<lambda>f x. ?a \\<squnion> (SUP y\\<in>elts x. VPow (f y)))\n\ngoal (1 subgoal):\n 1. a \\<squnion>\n    (SUP y\\<in>elts i.\n        VPow\n         (restrict\n           (transrec\n             (\\<lambda>f x. a \\<squnion> (SUP y\\<in>elts x. VPow (f y))))\n           (elts i) y)) =\n    a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))", "by auto"], ["", "lemma Vfrom_0 [simp]: \"Vfrom a 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a 0 = a", "by (subst Vfrom) auto"], ["", "lemma Vset: \"Vset i = \\<Squnion>((\\<lambda>j. VPow(Vset j)) ` elts i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vset i = (SUP j\\<in>elts i. VPow (Vset j))", "by (subst Vfrom) auto"], ["", "lemma Vfrom_mono1:\n  assumes \"a \\<le> b\" shows \"Vfrom a i \\<le> Vfrom b i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a i \\<le> Vfrom b i", "proof (induction i rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom b y) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom b x", "case (step i)"], ["proof (state)\nthis:\n  ?y \\<in> elts i \\<Longrightarrow> Vfrom a ?y \\<le> Vfrom b ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom b y) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom b x", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts i \\<Longrightarrow> Vfrom a ?y \\<le> Vfrom b ?y", "have \"a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j)) \\<le> b \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom b j))\""], ["proof (prove)\nusing this:\n  ?y \\<in> elts i \\<Longrightarrow> Vfrom a ?y \\<le> Vfrom b ?y\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n    \\<le> b \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom b j))", "by (intro sup_mono cSUP_subset_mono \\<open>a \\<le> b\\<close>) auto"], ["proof (state)\nthis:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> b \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom b j))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom b y) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom b x", "then"], ["proof (chain)\npicking this:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> b \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom b j))", "show ?case"], ["proof (prove)\nusing this:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> b \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom b j))\n\ngoal (1 subgoal):\n 1. Vfrom a i \\<le> Vfrom b i", "by (metis Vfrom)"], ["proof (state)\nthis:\n  Vfrom a i \\<le> Vfrom b i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Vfrom_mono2: \"Vfrom a i \\<le> Vfrom a (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a i \\<le> Vfrom a (i \\<squnion> j)", "proof (induction arbitrary: j rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x j.\n       (\\<And>y j.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom a (y \\<squnion> j)) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom a (x \\<squnion> j)", "case (step i)"], ["proof (state)\nthis:\n  ?y \\<in> elts i \\<Longrightarrow>\n  Vfrom a ?y \\<le> Vfrom a (?y \\<squnion> ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       (\\<And>y j.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom a (y \\<squnion> j)) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom a (x \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts i \\<Longrightarrow>\n  Vfrom a ?y \\<le> Vfrom a (?y \\<squnion> ?j)", "have \"a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n           \\<le> a \\<squnion> (SUP j\\<in>elts (i \\<squnion> j). VPow (Vfrom a j))\""], ["proof (prove)\nusing this:\n  ?y \\<in> elts i \\<Longrightarrow>\n  Vfrom a ?y \\<le> Vfrom a (?y \\<squnion> ?j)\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n    \\<le> a \\<squnion> (SUP j\\<in>elts (i \\<squnion> j). VPow (Vfrom a j))", "by (intro sup_mono cSUP_subset_mono order_refl) auto"], ["proof (state)\nthis:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (i \\<squnion> j). VPow (Vfrom a j))\n\ngoal (1 subgoal):\n 1. \\<And>x j.\n       (\\<And>y j.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom a y \\<le> Vfrom a (y \\<squnion> j)) \\<Longrightarrow>\n       Vfrom a x \\<le> Vfrom a (x \\<squnion> j)", "then"], ["proof (chain)\npicking this:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (i \\<squnion> j). VPow (Vfrom a j))", "show ?case"], ["proof (prove)\nusing this:\n  a \\<squnion> (SUP j\\<in>elts i. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (i \\<squnion> j). VPow (Vfrom a j))\n\ngoal (1 subgoal):\n 1. Vfrom a i \\<le> Vfrom a (i \\<squnion> j)", "by (metis Vfrom)"], ["proof (state)\nthis:\n  Vfrom a i \\<le> Vfrom a (i \\<squnion> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Vfrom_mono: \"\\<lbrakk>Ord i; a\\<le>b; i\\<le>j\\<rbrakk> \\<Longrightarrow> Vfrom a i \\<le> Vfrom b j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; a \\<le> b; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> Vfrom a i \\<le> Vfrom b j", "by (metis (no_types) Vfrom_mono1 Vfrom_mono2 dual_order.trans sup.absorb_iff2)"], ["", "lemma Transset_Vfrom: \"Transset(A) \\<Longrightarrow> Transset(Vfrom A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset A \\<Longrightarrow> Transset (Vfrom A i)", "proof (induction i rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts x; Transset A\\<rbrakk>\n                   \\<Longrightarrow> Transset (Vfrom A y);\n        Transset A\\<rbrakk>\n       \\<Longrightarrow> Transset (Vfrom A x)", "case (step i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts i; Transset A\\<rbrakk>\n  \\<Longrightarrow> Transset (Vfrom A ?y)\n  Transset A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts x; Transset A\\<rbrakk>\n                   \\<Longrightarrow> Transset (Vfrom A y);\n        Transset A\\<rbrakk>\n       \\<Longrightarrow> Transset (Vfrom A x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> elts i; Transset A\\<rbrakk>\n  \\<Longrightarrow> Transset (Vfrom A ?y)\n  Transset A", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts i; Transset A\\<rbrakk>\n  \\<Longrightarrow> Transset (Vfrom A ?y)\n  Transset A\n\ngoal (1 subgoal):\n 1. Transset (Vfrom A i)", "by (metis Transset_SUP Transset_VPow Transset_sup Vfrom)"], ["proof (state)\nthis:\n  Transset (Vfrom A i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Transset_Vset [simp]: \"Transset(Vset i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (Vset i)", "by (simp add: Transset_Vfrom)"], ["", "lemma Vfrom_sup: \"Vfrom a (i \\<squnion> j) = Vfrom a i \\<squnion> Vfrom a j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (i \\<squnion> j) = Vfrom a i \\<squnion> Vfrom a j", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. Vfrom a (i \\<squnion> j) \\<le> Vfrom a i \\<squnion> Vfrom a j\n 2. Vfrom a i \\<squnion> Vfrom a j \\<le> Vfrom a (i \\<squnion> j)", "show \"Vfrom a (i \\<squnion> j) \\<le> Vfrom a i \\<squnion> Vfrom a j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (i \\<squnion> j) \\<le> Vfrom a i \\<squnion> Vfrom a j", "by (simp add: Vfrom [of a \"i \\<squnion> j\"] Vfrom [of a i] Vfrom [of a j] Sup_Un_distrib image_Un sup.assoc sup.left_commute)"], ["proof (state)\nthis:\n  Vfrom a (i \\<squnion> j) \\<le> Vfrom a i \\<squnion> Vfrom a j\n\ngoal (1 subgoal):\n 1. Vfrom a i \\<squnion> Vfrom a j \\<le> Vfrom a (i \\<squnion> j)", "show \"Vfrom a i \\<squnion> Vfrom a j \\<le> Vfrom a (i \\<squnion> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a i \\<squnion> Vfrom a j \\<le> Vfrom a (i \\<squnion> j)", "by (metis Vfrom_mono2 le_supI sup_commute)"], ["proof (state)\nthis:\n  Vfrom a i \\<squnion> Vfrom a j \\<le> Vfrom a (i \\<squnion> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Vfrom_succ_Ord:\n  assumes \"Ord i\" shows \"Vfrom a (succ i) = a \\<squnion> VPow(Vfrom a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "by (simp add: Vfrom [of _ \"succ 0\"])"], ["proof (state)\nthis:\n  Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "have *: \"(SUP x\\<in>elts i. VPow (Vfrom a x)) \\<le> VPow (Vfrom a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts i. VPow (Vfrom a x)) \\<le> VPow (Vfrom a i)", "proof (rule cSup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<noteq> {}\n 2. \\<And>x.\n       x \\<in> (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<Longrightarrow>\n       x \\<le> VPow (Vfrom a i)", "show \"(\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<Longrightarrow>\n       x \\<le> VPow (Vfrom a i)", "show \"x \\<le> VPow (Vfrom a i)\" if \"x \\<in> (\\<lambda>x. VPow (Vfrom a x)) ` elts i\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> VPow (Vfrom a i)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. VPow (Vfrom a x)) ` elts i\n\ngoal (1 subgoal):\n 1. x \\<le> VPow (Vfrom a i)", "by clarsimp (meson Ord_in_Ord Ord_linear_le Vfrom_mono assms mem_not_refl order_refl vsubsetD)"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>x. VPow (Vfrom a x)) ` elts i \\<Longrightarrow>\n  ?x \\<le> VPow (Vfrom a i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP x\\<in>elts i. VPow (Vfrom a x)) \\<le> VPow (Vfrom a i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)", "proof (rule Vfrom [THEN trans])"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (ZFC_in_HOL.succ i). VPow (Vfrom a j)) =\n    a \\<squnion> VPow (Vfrom a i)", "show \"a \\<squnion> (SUP j\\<in>elts (succ i). VPow (Vfrom a j)) = a \\<squnion> VPow (Vfrom a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (ZFC_in_HOL.succ i). VPow (Vfrom a j)) =\n    a \\<squnion> VPow (Vfrom a i)", "using assms"], ["proof (prove)\nusing this:\n  Ord i\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (ZFC_in_HOL.succ i). VPow (Vfrom a j)) =\n    a \\<squnion> VPow (Vfrom a i)", "by (intro sup_mono order_antisym) (auto simp: Sup_V_insert *)"], ["proof (state)\nthis:\n  a \\<squnion> (SUP j\\<in>elts (ZFC_in_HOL.succ i). VPow (Vfrom a j)) =\n  a \\<squnion> VPow (Vfrom a i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Vfrom a (ZFC_in_HOL.succ i) = a \\<squnion> VPow (Vfrom a i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Vset_succ: \"Ord i \\<Longrightarrow> Vset(succ(i)) = VPow(Vset(i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> Vset (ZFC_in_HOL.succ i) = VPow (Vset i)", "by (simp add: Vfrom_succ_Ord)"], ["", "lemma Vfrom_Sup:\n  assumes \"X \\<noteq> {}\" \"small X\"\n  shows \"Vfrom a (Sup X) = (SUP y\\<in>X. Vfrom a y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (\\<Squnion> X) = \\<Squnion> (Vfrom a ` X)", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n 2. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "have \"Vfrom a (\\<Squnion> X) = a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a (\\<Squnion> X) =\n    a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))", "by (metis Vfrom)"], ["proof (state)\nthis:\n  Vfrom a (\\<Squnion> X) =\n  a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n\ngoal (2 subgoals):\n 1. Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n 2. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "also"], ["proof (state)\nthis:\n  Vfrom a (\\<Squnion> X) =\n  a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n\ngoal (2 subgoals):\n 1. Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n 2. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "have \"\\<dots> \\<le> \\<Squnion> (Vfrom a ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "have \"a \\<le> \\<Squnion> (Vfrom a ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> \\<Squnion> (Vfrom a ` X)", "by (metis Vfrom all_not_in_conv assms bdd_above_iff_small cSUP_upper2 replacement sup_ge1)"], ["proof (state)\nthis:\n  a \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "moreover"], ["proof (state)\nthis:\n  a \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "have \"(SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j)) \\<le> \\<Squnion> (Vfrom a ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "have \"VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)\"\n        if \"y \\<in> X\" \"x \\<in> elts y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "have \"VPow (Vfrom a x) \\<le> Vfrom a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> Vfrom a y", "by (metis Vfrom bdd_above_iff_small cSUP_upper2 le_supI2 order_refl replacement small_elts that(2))"], ["proof (state)\nthis:\n  VPow (Vfrom a x) \\<le> Vfrom a y\n\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "also"], ["proof (state)\nthis:\n  VPow (Vfrom a x) \\<le> Vfrom a y\n\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "have \"\\<dots> \\<le> \\<Squnion> (Vfrom a ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom a y \\<le> \\<Squnion> (Vfrom a ` X)", "using assms that"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n  small X\n  y \\<in> X\n  x \\<in> elts y\n\ngoal (1 subgoal):\n 1. Vfrom a y \\<le> \\<Squnion> (Vfrom a ` X)", "by (force intro: cSUP_upper)"], ["proof (state)\nthis:\n  Vfrom a y \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "finally"], ["proof (chain)\npicking this:\n  VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)", "."], ["proof (state)\nthis:\n  VPow (Vfrom a x) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> X; ?x \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> VPow (Vfrom a ?x) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> X; ?x \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> VPow (Vfrom a ?x) \\<le> \\<Squnion> (Vfrom a ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> X; ?x \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> VPow (Vfrom a ?x) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "by (simp add: SUP_le_iff \\<open>small X\\<close>)"], ["proof (state)\nthis:\n  (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> \\<Squnion> (Vfrom a ` X)\n  (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> \\<Squnion> (Vfrom a ` X)\n  (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n    \\<le> \\<Squnion> (Vfrom a ` X)", "by auto"], ["proof (state)\nthis:\n  a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n  \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (2 subgoals):\n 1. Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n 2. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "finally"], ["proof (chain)\npicking this:\n  Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)", "show \"Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\""], ["proof (prove)\nusing this:\n  Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)", "."], ["proof (state)\nthis:\n  Vfrom a (\\<Squnion> X) \\<le> \\<Squnion> (Vfrom a ` X)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "have \"\\<And>x. x \\<in> X \\<Longrightarrow>\n         a \\<squnion> (SUP j\\<in>elts x. VPow (Vfrom a j))\n         \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       a \\<squnion> (SUP j\\<in>elts x. VPow (Vfrom a j))\n       \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))", "using cSUP_subset_mono \\<open>small X\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> ?B;\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> ?f x \\<subseteq> ?g x\\<rbrakk>\n  \\<Longrightarrow> \\<Union> (?f ` ?A) \\<subseteq> \\<Union> (?g ` ?B)\n  small X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       a \\<squnion> (SUP j\\<in>elts x. VPow (Vfrom a j))\n       \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  a \\<squnion> (SUP j\\<in>elts ?x. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow>\n  a \\<squnion> (SUP j\\<in>elts ?x. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))", "show \"\\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow>\n  a \\<squnion> (SUP j\\<in>elts ?x. VPow (Vfrom a j))\n  \\<le> a \\<squnion> (SUP j\\<in>elts (\\<Squnion> X). VPow (Vfrom a j))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)", "by (metis Vfrom assms(1) cSUP_least)"], ["proof (state)\nthis:\n  \\<Squnion> (Vfrom a ` X) \\<le> Vfrom a (\\<Squnion> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Limit_Vfrom_eq:\n    \"Limit(i) \\<Longrightarrow> Vfrom a i = (SUP y \\<in> elts i. Vfrom a y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i \\<Longrightarrow> Vfrom a i = \\<Squnion> (Vfrom a ` elts i)", "by (metis Limit_def Limit_eq_Sup_self Vfrom_Sup ex_in_conv small_elts)"], ["", "end"]]}