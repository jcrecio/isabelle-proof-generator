{"file_name": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL/Kirby.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL", "problem_names": ["lemma plus: \"x + y = x \\<squnion> set ((+)x ` elts y)\"", "lemma plus_eq_lift: \"x + y = x \\<squnion> lift x y\"", "lemma lift_sup_distrib: \"lift x (a \\<squnion> b) = lift x a \\<squnion> lift x b\"", "lemma lift_Sup_distrib: \"small Y \\<Longrightarrow> lift x (\\<Squnion> Y) = \\<Squnion> (lift x ` Y)\"", "lemma add_Sup_distrib:\n  fixes x::V shows \"y \\<noteq> 0 \\<Longrightarrow> x + (SUP z\\<in>elts y. f z) = (SUP z\\<in>elts y. x + f z)\"", "lemma Limit_add_Sup_distrib:\n  fixes x::V shows \"Limit \\<alpha> \\<Longrightarrow> x + (SUP z\\<in>elts \\<alpha>. f z) = (SUP z\\<in>elts \\<alpha>. x + f z)\"", "lemma lift_0 [simp]: \"lift 0 x = x\"", "lemma lift_by0 [simp]: \"lift x 0 = 0\"", "lemma lift_by1 [simp]: \"lift x 1 = set{x}\"", "lemma add_eq_0_iff [simp]:\n  fixes x y::V\n  shows \"x+y = 0 \\<longleftrightarrow> x=0 \\<and> y=0\"", "lemma plus_vinsert: \"x + vinsert z y = vinsert (x+z) (x + y)\"", "lemma plus_V_succ_right: \"x + succ y = succ (x + y)\"", "lemma succ_eq_add1: \"succ x = x + 1\"", "lemma ord_of_nat_add: \"ord_of_nat (m+n) = ord_of_nat m + ord_of_nat n\"", "lemma succ_0_plus_eq [simp]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \n  shows \"succ 0 + \\<alpha> = succ \\<alpha>\"", "lemma omega_closed_add [intro]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"\\<beta> \\<in> elts \\<omega>\" shows \"\\<alpha>+\\<beta> \\<in> elts \\<omega>\"", "lemma mem_plus_V_E:\n  assumes l: \"l \\<in> elts (x + y)\"\n  obtains \"l \\<in> elts x\" | z where \"z \\<in> elts y\" \"l = x + z\"", "lemma not_add_less_right: assumes \"Ord y\" shows \"\\<not> (x + y < x)\"", "lemma not_add_mem_right: \"\\<not> (x + y \\<in> elts x)\"", "lemma add_not_less_TC_self: \"\\<not> x + y \\<sqsubset> x\"", "lemma TC_sup_lift: \"TC x \\<sqinter> lift x y = 0\"", "lemma lift_lift: \"lift x (lift y z) = lift (x+y) z\"", "lemma lift_self_disjoint: \"x \\<sqinter> lift x u = 0\"", "lemma sup_lift_eq_lift:\n  assumes \"x \\<squnion> lift x u = x \\<squnion> lift x v\"\n  shows \"lift x u = lift x v\"", "lemma succ_less_\\<omega>_imp: \"succ x < \\<omega> \\<Longrightarrow> x < \\<omega>\"", "lemma card_lift: \"vcard (lift x y) = vcard y\"", "lemma eqpoll_lift: \"elts (lift x y) \\<approx> elts y\"", "lemma vcard_add: \"vcard (x + y) = vcard x \\<oplus> vcard y\"", "lemma countable_add:\n  assumes \"countable (elts A)\" \"countable (elts B)\"\n  shows \"countable (elts (A+B))\"", "lemma Ord_add [simp]: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> Ord (x+y)\"", "lemma add_Sup_distrib_id: \"A \\<noteq> 0 \\<Longrightarrow> x + \\<Squnion>(elts A) = (SUP z\\<in>elts A. x + z)\"", "lemma add_Limit: \"Limit \\<alpha> \\<Longrightarrow> x + \\<alpha> = (SUP z\\<in>elts \\<alpha>. x + z)\"", "lemma add_le_left:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"\\<beta> \\<le> \\<alpha>+\\<beta>\"", "lemma plus_\\<omega>_equals_\\<omega>:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\"  shows \"\\<alpha> + \\<omega> = \\<omega>\"", "lemma one_plus_\\<omega>_equals_\\<omega> [simp]: \"1 + \\<omega> = \\<omega>\"", "lemma vle_refl [iff]: \"x \\<unlhd> x\"", "lemma vle_antisym: \"\\<lbrakk>x \\<unlhd> y; y \\<unlhd> x\\<rbrakk> \\<Longrightarrow> x = y\"", "lemma vle_trans [trans]: \"\\<lbrakk>x \\<unlhd> y; y \\<unlhd> z\\<rbrakk> \\<Longrightarrow> x \\<unlhd> z\"", "lemma comparable:\n  assumes \"a+b = c+d\"\n  shows \"vle_comparable a c\"", "lemma vle1: \"x \\<unlhd> y \\<Longrightarrow> x \\<le> y\"", "lemma vle2: \"x \\<unlhd> y \\<Longrightarrow> x \\<sqsubseteq> y\"", "lemma vle_iff_le_Ord:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  shows \"\\<alpha> \\<unlhd> \\<beta> \\<longleftrightarrow> \\<alpha> \\<le> \\<beta>\"", "lemma add_le_cancel_left0 [iff]:\n  fixes x::V shows \"x \\<le> x+z\"", "lemma add_less_cancel_left0 [iff]:\n  fixes x::V shows \"x < x+z \\<longleftrightarrow> 0<z\"", "lemma le_Ord_diff:\n  assumes \"\\<alpha> \\<le> \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  obtains \\<gamma> where \"\\<alpha>+\\<gamma> = \\<beta>\" \"\\<gamma> \\<le> \\<beta>\" \"Ord \\<gamma>\"", "lemma plus_Ord_le:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"Ord \\<beta>\" shows \"\\<alpha>+\\<beta> \\<le> \\<beta>+\\<alpha>\"", "lemma add_right_mono: \"\\<lbrakk>\\<alpha> \\<le> \\<beta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> \\<le> \\<beta>+\\<gamma>\"", "lemma add_strict_mono: \"\\<lbrakk>\\<alpha> < \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> < \\<beta>+\\<delta>\"", "lemma add_right_strict_mono: \"\\<lbrakk>\\<alpha> \\<le> \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> < \\<beta>+\\<delta>\"", "lemma Limit_add_Limit [simp]:\n  assumes \"Limit \\<mu>\" \"Ord \\<beta>\" shows \"Limit (\\<beta> + \\<mu>)\"", "lemma vle_imp_odiff_eq: \"x \\<unlhd> y \\<Longrightarrow> x + (odiff y x) = y\"", "lemma not_vle_imp_odiff_0: \"\\<not> x \\<unlhd> y \\<Longrightarrow> (odiff y x) = 0\"", "lemma Ord_odiff_eq:\n  assumes \"\\<alpha> \\<le> \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  shows \"\\<alpha> + odiff \\<beta> \\<alpha> = \\<beta>\"", "lemma Ord_odiff:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"Ord (odiff \\<beta> \\<alpha>)\"", "lemma Ord_odiff_le:\n  assumes  \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"odiff \\<beta> \\<alpha> \\<le> \\<beta>\"", "lemma odiff_0_right [simp]: \"odiff x 0 = x\"", "lemma odiff_succ: \"y \\<unlhd> x \\<Longrightarrow> odiff (succ x) y = succ (odiff x y)\"", "lemma odiff_eq_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z = y \\<longleftrightarrow> x = z + y\"", "lemma odiff_le_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> y \\<longleftrightarrow> x \\<le> z + y\"", "lemma odiff_less_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z < y \\<longleftrightarrow> x < z + y\"", "lemma odiff_ge_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z \\<ge> y \\<longleftrightarrow> x \\<ge> z + y\"", "lemma Ord_odiff_le_iff: \"\\<lbrakk>\\<alpha> \\<le> x; Ord x; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> \\<le> y \\<longleftrightarrow> x \\<le> \\<alpha> + y\"", "lemma odiff_le_odiff:\n  assumes \"x \\<unlhd> y\" shows \"odiff x z \\<le> odiff y z\"", "lemma Ord_odiff_le_odiff: \"\\<lbrakk>x \\<le> y; Ord x; Ord y\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> \\<le> odiff y \\<alpha>\"", "lemma Ord_odiff_less_odiff: \"\\<lbrakk>\\<alpha> \\<le> x; x < y; Ord x; Ord y; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> < odiff y \\<alpha>\"", "lemma Ord_odiff_less_imp_less: \"\\<lbrakk>odiff x \\<alpha> < odiff y \\<alpha>; Ord x; Ord y\\<rbrakk> \\<Longrightarrow> x < y\"", "lemma odiff_add_cancel [simp]: \"odiff (x + y) x = y\"", "lemma odiff_add_cancel_0 [simp]: \"odiff x x = 0\"", "lemma odiff_add_cancel_both [simp]: \"odiff (x + y) (x + z) = odiff y z\"", "lemma mult: \"x * y = (SUP u\\<in>elts y. lift (x * u) x)\"", "lemma elts_multE:\n  assumes \"z \\<in> elts (x * y)\" \n  obtains u v where \"u \\<in> elts x\" \"v \\<in> elts y\" \"z = x*v + u\"", "lemma mult_zero_right [simp]:\n  fixes x::V shows \"x * 0 = 0\"", "lemma mult_insert: \"x * (vinsert y z) = x*z \\<squnion> lift (x*y) x\"", "lemma mult_succ: \"x * succ y = x*y + x\"", "lemma ord_of_nat_mult: \"ord_of_nat (m*n) = ord_of_nat m * ord_of_nat n\"", "lemma omega_closed_mult [intro]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"\\<beta> \\<in> elts \\<omega>\" shows \"\\<alpha>*\\<beta> \\<in> elts \\<omega>\"", "lemma zero_imp_le_mult: \"0 \\<in> elts y \\<Longrightarrow> x \\<le> x*y\"", "lemma mult_zero_left [simp]:\n  fixes x::V shows \"0 * x = 0\"", "lemma mult_sup_distrib:\n  fixes x::V shows \"x * (y \\<squnion> z) = x*y \\<squnion> x*z\"", "lemma mult_Sup_distrib: \"small Y \\<Longrightarrow> x * (\\<Squnion>Y) = \\<Squnion> ((*) x ` Y)\" for Y:: \"V set\"", "lemma mult_lift_imp_distrib: \"x * (lift y z) = lift (x*y) (x*z) \\<Longrightarrow> x * (y+z) = x*y + x*z\"", "lemma mult_lift: \"x * (lift y z) = lift (x*y) (x*z)\"", "lemma mult_Limit: \"Limit \\<gamma> \\<Longrightarrow> x * \\<gamma> = \\<Squnion> ((*) x ` elts \\<gamma>)\"", "lemma add_mult_distrib: \"x * (y+z) = x*y + x*z\" for x::V", "lemma le_mult:\n  assumes \"Ord \\<beta>\" \"\\<beta> \\<noteq> 0\" shows \"\\<alpha> \\<le> \\<alpha> * \\<beta>\"", "lemma mult_sing_1 [simp]:\n  fixes x::V shows \"x * set{1} = lift x x\"", "lemma mult_2_right [simp]:\n  fixes x::V shows \"x * set{0,1} = x+x\"", "lemma Ord_mult [simp]: \"\\<lbrakk>Ord y; Ord x\\<rbrakk> \\<Longrightarrow> Ord (x*y)\"", "lemma mult_le1:\n  fixes y::V assumes \"y \\<noteq> 0\" shows \"x \\<sqsubseteq> x * y\"", "lemma mult_eq_0_iff [simp]:\n  fixes y::V shows \"x * y = 0 \\<longleftrightarrow> x=0 \\<or> y=0\"", "lemma lift_lemma:\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"  shows \"\\<not> lift (x * y) x \\<le> x\"", "lemma mult_le2:\n  fixes y::V assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"y \\<noteq> 1\" shows \"x \\<sqsubset> x * y\"", "lemma elts_mult_\\<omega>E:\n  assumes \"x \\<in> elts (y * \\<omega>)\"\n  obtains n where \"n \\<noteq> 0\" \"x \\<in> elts (y * ord_of_nat n)\" \"\\<And>m. m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)\"", "theorem mult_eq_imp_0:\n  assumes \"a*x = a*y + b\" \"b \\<sqsubset> a\"\n  shows \"b=0\"", "lemma mult_cancellation_half:\n  assumes \"a*x + r \\<le> a*y + s\" \"r \\<sqsubset> a\" \"s \\<sqsubset> a\"\n  shows \"x \\<le> y\"", "theorem mult_cancellation_lemma:\n  assumes \"a*x + r = a*y + s\" \"r \\<sqsubset> a\" \"s \\<sqsubset> a\"\n  shows \"x=y \\<and> r=s\"", "lemma mult_add_mem:\n  assumes \"a*x + r \\<in> elts (a*y)\" \"r \\<sqsubset> a\"\n  shows \"x \\<in> elts y\" \"r \\<in> elts a\"", "lemma mult_add_mem_0 [simp]: \"a*x \\<in> elts (a*y) \\<longleftrightarrow> x \\<in> elts y \\<and> 0 \\<in> elts a\"", "lemma zero_mem_mult_iff: \"0 \\<in> elts (x*y) \\<longleftrightarrow> 0 \\<in> elts x \\<and> 0 \\<in> elts y\"", "lemma zero_less_mult_iff [simp]: \"0 < x*y \\<longleftrightarrow> 0 < x \\<and> 0 < y\" if \"Ord x\"", "lemma mult_cancel_less_iff [simp]:\n  \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>*\\<beta> < \\<alpha>*\\<gamma> \\<longleftrightarrow> \\<beta> < \\<gamma> \\<and> 0 < \\<alpha>\"", "lemma mult_cancel_le_iff [simp]:\n  \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>*\\<beta> \\<le> \\<alpha>*\\<gamma> \\<longleftrightarrow> \\<beta> \\<le> \\<gamma> \\<or> \\<alpha>=0\"", "lemma mult_Suc_add_less: \"\\<lbrakk>\\<alpha> < \\<gamma>; \\<beta> < \\<gamma>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>  \\<Longrightarrow> \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat (Suc m) + \\<beta>\"", "lemma mult_nat_less_add_less:\n  assumes \"m < n\" \"\\<alpha> < \\<gamma>\" \"\\<beta> < \\<gamma>\" and ord: \"Ord \\<alpha>\" \"Ord \\<beta>\" \"Ord \\<gamma>\"\n    shows \"\\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>\"", "lemma add_mult_less_add_mult:\n  assumes \"x < y\" \"x \\<in> elts \\<beta>\" \"y \\<in> elts \\<beta>\" \"\\<mu> \\<in> elts \\<alpha>\" \"\\<nu> \\<in> elts \\<alpha>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n    shows \"\\<alpha>*x + \\<mu> < \\<alpha>*y + \\<nu>\"", "lemma add_mult_less:\n  assumes \"\\<gamma> \\<in> elts \\<alpha>\" \"\\<nu> \\<in> elts \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n    shows \"\\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)\"", "lemma Ord_add_mult_iff:\n  assumes \"\\<beta> \\<in> elts \\<gamma>\" \"\\<beta>' \\<in> elts \\<gamma>\" \"Ord \\<alpha>\" \"Ord \\<alpha>'\" \"Ord \\<gamma>\"\n  shows \"\\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>') \\<longleftrightarrow> \\<alpha> \\<in> elts \\<alpha>' \\<or> \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma vcard_mult: \"vcard (x * y) = vcard x \\<otimes> vcard y\"", "lemma countable_mult:\n  assumes \"countable (elts A)\" \"countable (elts B)\"\n  shows \"countable (elts (A*B))\"", "lemma ordertype_image_plus:\n  assumes \"Ord \\<alpha>\"\n  shows \"ordertype ((+) u ` elts \\<alpha>) VWF = \\<alpha>\"", "lemma ordertype_diff:\n  assumes \"\\<beta> + \\<delta> = \\<alpha>\" and \\<alpha>: \"\\<delta> \\<in> elts \\<alpha>\" \"Ord \\<alpha>\"\n  shows \"ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\"", "lemma ordertype_interval_eq:\n  assumes \\<alpha>: \"Ord \\<alpha>\" and \\<beta>: \"Ord \\<beta>\"\n  shows \"ordertype ({\\<alpha> ..< \\<alpha>+\\<beta>} \\<inter> ON) VWF = \\<beta>\"", "lemma ordertype_Times:\n  assumes \"small A\" \"small B\" and r: \"wf r\" \"trans r\" \"total_on A r\" and s: \"wf s\" \"trans s\" \"total_on B s\"\n  shows \"ordertype (A\\<times>B) (r <*lex*> s) = ordertype B s * ordertype A r\" (is \"_ = ?\\<beta> * ?\\<alpha>\")"], "translations": [["", "lemma plus: \"x + y = x \\<squnion> set ((+)x ` elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<squnion> set ((+) x ` elts y)", "unfolding plus_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec (\\<lambda>f z. x \\<squnion> set (f ` elts z)) y =\n    x \\<squnion>\n    set (transrec (\\<lambda>f z. x \\<squnion> set (f ` elts z)) ` elts y)", "by (subst transrec) auto"], ["", "lemma plus_eq_lift: \"x + y = x \\<squnion> lift x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<squnion> lift x y", "unfolding lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y = x \\<squnion> set ((+) x ` elts y)", "using plus"], ["proof (prove)\nusing this:\n  ?x + ?y = ?x \\<squnion> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. x + y = x \\<squnion> set ((+) x ` elts y)", "by blast"], ["", "text\\<open>Lemma 3.2\\<close>"], ["", "lemma lift_sup_distrib: \"lift x (a \\<squnion> b) = lift x a \\<squnion> lift x b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x (a \\<squnion> b) = lift x a \\<squnion> lift x b", "by (simp add: image_Un lift_def sup_V_def)"], ["", "lemma lift_Sup_distrib: \"small Y \\<Longrightarrow> lift x (\\<Squnion> Y) = \\<Squnion> (lift x ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small Y \\<Longrightarrow>\n    lift x (\\<Squnion> Y) = \\<Squnion> (lift x ` Y)", "by (auto simp: lift_def Sup_V_def image_Union)"], ["", "lemma add_Sup_distrib:\n  fixes x::V shows \"y \\<noteq> 0 \\<Longrightarrow> x + (SUP z\\<in>elts y. f z) = (SUP z\\<in>elts y. x + f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    x + \\<Squnion> (f ` elts y) = (SUP z\\<in>elts y. x + f z)", "by (auto simp: plus_eq_lift SUP_sup_distrib lift_Sup_distrib image_image)"], ["", "lemma Limit_add_Sup_distrib:\n  fixes x::V shows \"Limit \\<alpha> \\<Longrightarrow> x + (SUP z\\<in>elts \\<alpha>. f z) = (SUP z\\<in>elts \\<alpha>. x + f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<alpha> \\<Longrightarrow>\n    x + \\<Squnion> (f ` elts \\<alpha>) = (SUP z\\<in>elts \\<alpha>. x + f z)", "using add_Sup_distrib"], ["proof (prove)\nusing this:\n  ?y \\<noteq> 0 \\<Longrightarrow>\n  ?x + \\<Squnion> (?f ` elts ?y) = (SUP z\\<in>elts ?y. ?x + ?f z)\n\ngoal (1 subgoal):\n 1. Limit \\<alpha> \\<Longrightarrow>\n    x + \\<Squnion> (f ` elts \\<alpha>) = (SUP z\\<in>elts \\<alpha>. x + f z)", "by force"], ["", "text\\<open>Proposition 3.3(ii)\\<close>"], ["", "instantiation V :: monoid_add\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a. 0 + a = a\n 3. \\<And>a. a + 0 = a", "show \"a + b + c = a + (b + c)\" for a b c :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "proof (induction c rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "case (step c)"], ["proof (state)\nthis:\n  ?y \\<in> elts c \\<Longrightarrow> a + b + ?y = a + (b + ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "have \"(a+b) + c = a + b \\<squnion> set ((+) (a + b) ` elts c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + b \\<squnion> set ((+) (a + b) ` elts c)", "by (metis plus)"], ["proof (state)\nthis:\n  a + b + c = a + b \\<squnion> set ((+) (a + b) ` elts c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "also"], ["proof (state)\nthis:\n  a + b + c = a + b \\<squnion> set ((+) (a + b) ` elts c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "have \"\\<dots> = a \\<squnion> lift a b \\<squnion> set ((\\<lambda>u. a + (b+u)) ` elts c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b \\<squnion> set ((+) (a + b) ` elts c) =\n    a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c)", "using plus_eq_lift step.IH"], ["proof (prove)\nusing this:\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n  ?y \\<in> elts c \\<Longrightarrow> a + b + ?y = a + (b + ?y)\n\ngoal (1 subgoal):\n 1. a + b \\<squnion> set ((+) (a + b) ` elts c) =\n    a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c)", "by auto"], ["proof (state)\nthis:\n  a + b \\<squnion> set ((+) (a + b) ` elts c) =\n  a \\<squnion> lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "also"], ["proof (state)\nthis:\n  a + b \\<squnion> set ((+) (a + b) ` elts c) =\n  a \\<squnion> lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "have \"\\<dots> = a \\<squnion> lift a (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    a \\<squnion> lift a (b + c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    a \\<squnion> lift a (b + c)", "have \"lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c) = lift a (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    lift a (b + c)", "unfolding lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((+) a ` elts b) \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    set ((+) a ` elts (b + c))", "by (metis elts_of_set image_image lift_def lift_sup_distrib plus_eq_lift replacement small_elts)"], ["proof (state)\nthis:\n  lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  lift a (b + c)\n\ngoal (1 subgoal):\n 1. a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    a \\<squnion> lift a (b + c)", "then"], ["proof (chain)\npicking this:\n  lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  lift a (b + c)", "show ?thesis"], ["proof (prove)\nusing this:\n  lift a b \\<squnion> set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  lift a (b + c)\n\ngoal (1 subgoal):\n 1. a \\<squnion> lift a b \\<squnion>\n    set ((\\<lambda>u. a + (b + u)) ` elts c) =\n    a \\<squnion> lift a (b + c)", "by (simp add: sup_assoc)"], ["proof (state)\nthis:\n  a \\<squnion> lift a b \\<squnion>\n  set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  a \\<squnion> lift a (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<squnion> lift a b \\<squnion>\n  set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  a \\<squnion> lift a (b + c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "also"], ["proof (state)\nthis:\n  a \\<squnion> lift a b \\<squnion>\n  set ((\\<lambda>u. a + (b + u)) ` elts c) =\n  a \\<squnion> lift a (b + c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "have \"\\<dots> = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> lift a (b + c) = a + (b + c)", "using plus_eq_lift"], ["proof (prove)\nusing this:\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. a \\<squnion> lift a (b + c) = a + (b + c)", "by auto"], ["proof (state)\nthis:\n  a \\<squnion> lift a (b + c) = a + (b + c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           a + b + y = a + (b + y)) \\<Longrightarrow>\n       a + b + x = a + (b + x)", "finally"], ["proof (chain)\npicking this:\n  a + b + c = a + (b + c)", "show ?case"], ["proof (prove)\nusing this:\n  a + b + c = a + (b + c)\n\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "."], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (2 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. a + 0 = a", "show \"0 + x = x\" for x :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x", "proof (induction rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 0 + y = y) \\<Longrightarrow>\n       0 + x = x", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> 0 + ?y = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 0 + y = y) \\<Longrightarrow>\n       0 + x = x", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts x \\<Longrightarrow> 0 + ?y = ?y", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> 0 + ?y = ?y\n\ngoal (1 subgoal):\n 1. 0 + x = x", "by (subst plus) auto"], ["proof (state)\nthis:\n  0 + x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 + ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a. a + 0 = a", "show \"x + 0 = x\" for x :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + 0 = x", "by (subst plus) auto"], ["proof (state)\nthis:\n  ?x + 0 = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma lift_0 [simp]: \"lift 0 x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 x = x", "by (simp add: lift_def)"], ["", "lemma lift_by0 [simp]: \"lift x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x 0 = 0", "by (simp add: lift_def)"], ["", "lemma lift_by1 [simp]: \"lift x 1 = set{x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x 1 = set {x}", "by (simp add: lift_def)"], ["", "lemma add_eq_0_iff [simp]:\n  fixes x y::V\n  shows \"x+y = 0 \\<longleftrightarrow> x=0 \\<and> y=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = 0) = (x = 0 \\<and> y = 0)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. x + y = 0 \\<Longrightarrow> x = 0\n 2. x + y = 0 \\<Longrightarrow> y = 0\n 3. \\<lbrakk>y = 0; x = 0\\<rbrakk> \\<Longrightarrow> 0 + 0 = 0", "show \"x = 0\" if \"x + y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "by (metis that le_imp_less_or_eq not_less_0 plus sup_ge1)"], ["proof (state)\nthis:\n  x + y = 0 \\<Longrightarrow> x = 0\n\ngoal (2 subgoals):\n 1. x + y = 0 \\<Longrightarrow> y = 0\n 2. \\<lbrakk>y = 0; x = 0\\<rbrakk> \\<Longrightarrow> 0 + 0 = 0", "then"], ["proof (chain)\npicking this:\n  x + y = 0 \\<Longrightarrow> x = 0", "show \"y = 0\" if \"x + y = 0\""], ["proof (prove)\nusing this:\n  x + y = 0 \\<Longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. y = 0", "using that"], ["proof (prove)\nusing this:\n  x + y = 0 \\<Longrightarrow> x = 0\n  x + y = 0\n\ngoal (1 subgoal):\n 1. y = 0", "by auto"], ["proof (state)\nthis:\n  x + y = 0 \\<Longrightarrow> y = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x = 0\\<rbrakk> \\<Longrightarrow> 0 + 0 = 0", "qed auto"], ["", "lemma plus_vinsert: \"x + vinsert z y = vinsert (x+z) (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "have f1: \"elts (x + y) = elts x \\<union> (+) x ` elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (x + y) = elts x \\<union> (+) x ` elts y", "by (metis elts_of_set lift_def plus_eq_lift replacement small_Un small_elts sup_V_def)"], ["proof (state)\nthis:\n  elts (x + y) = elts x \\<union> (+) x ` elts y\n\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "moreover"], ["proof (state)\nthis:\n  elts (x + y) = elts x \\<union> (+) x ` elts y\n\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "have \"lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))", "using vinsert_def lift_def"], ["proof (prove)\nusing this:\n  vinsert ?x ?y \\<equiv> set (insert ?x (elts ?y))\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))", "by presburger"], ["proof (state)\nthis:\n  lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))\n\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "ultimately"], ["proof (chain)\npicking this:\n  elts (x + y) = elts x \\<union> (+) x ` elts y\n  lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (x + y) = elts x \\<union> (+) x ` elts y\n  lift x (vinsert z y) = set ((+) x ` elts (set (insert z (elts y))))\n\ngoal (1 subgoal):\n 1. x + vinsert z y = vinsert (x + z) (x + y)", "by (simp add: vinsert_def plus_eq_lift sup_V_def)"], ["proof (state)\nthis:\n  x + vinsert z y = vinsert (x + z) (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_V_succ_right: \"x + succ y = succ (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + ZFC_in_HOL.succ y = ZFC_in_HOL.succ (x + y)", "by (metis plus_vinsert succ_def)"], ["", "lemma succ_eq_add1: \"succ x = x + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ x = x + 1", "by (simp add: plus_V_succ_right one_V_def)"], ["", "lemma ord_of_nat_add: \"ord_of_nat (m+n) = ord_of_nat m + ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat (m + n) = ord_of_nat m + ord_of_nat n", "by (induction n) (auto simp: plus_V_succ_right)"], ["", "lemma succ_0_plus_eq [simp]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \n  shows \"succ 0 + \\<alpha> = succ \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ 0 + \\<alpha> = ZFC_in_HOL.succ \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ 0 + \\<alpha> = ZFC_in_HOL.succ \\<alpha>", "obtain n where \"\\<alpha> = ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<alpha> = ord_of_nat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms elts_\\<omega>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n  elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<alpha> = ord_of_nat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ 0 + \\<alpha> = ZFC_in_HOL.succ \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = ord_of_nat n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ 0 + \\<alpha> = ZFC_in_HOL.succ \\<alpha>", "by (metis One_nat_def ord_of_nat.simps ord_of_nat_add plus_1_eq_Suc)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ 0 + \\<alpha> = ZFC_in_HOL.succ \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma omega_closed_add [intro]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"\\<beta> \\<in> elts \\<omega>\" shows \"\\<alpha>+\\<beta> \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<in> elts \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<in> elts \\<omega>", "obtain m n where \"\\<alpha> = ord_of_nat m\" \"\\<beta> = ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<alpha> = ord_of_nat m; \\<beta> = ord_of_nat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms elts_\\<omega>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n  \\<beta> \\<in> elts \\<omega>\n  elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<alpha> = ord_of_nat m; \\<beta> = ord_of_nat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n", "have \"\\<alpha>+\\<beta> = ord_of_nat (m+n)\""], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = ord_of_nat (m + n)", "using ord_of_nat_add"], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n\n  ord_of_nat (?m + ?n) = ord_of_nat ?m + ord_of_nat ?n\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = ord_of_nat (m + n)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = ord_of_nat (m + n)\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> + \\<beta> = ord_of_nat (m + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> + \\<beta> = ord_of_nat (m + n)\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<in> elts \\<omega>", "by (simp add: \\<omega>_def)"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> \\<in> elts \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_plus_V_E:\n  assumes l: \"l \\<in> elts (x + y)\"\n  obtains \"l \\<in> elts x\" | z where \"z \\<in> elts y\" \"l = x + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> elts x \\<Longrightarrow> thesis;\n     \\<And>z.\n        \\<lbrakk>z \\<in> elts y; l = x + z\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using l"], ["proof (prove)\nusing this:\n  l \\<in> elts (x + y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<in> elts x \\<Longrightarrow> thesis;\n     \\<And>z.\n        \\<lbrakk>z \\<in> elts y; l = x + z\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: plus [of x y] split: if_split_asm)"], ["", "lemma not_add_less_right: assumes \"Ord y\" shows \"\\<not> (x + y < x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x + y < x", "using assms"], ["proof (prove)\nusing this:\n  Ord y\n\ngoal (1 subgoal):\n 1. \\<not> x + y < x", "proof (induction rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Ord xa;\n        \\<And>y. y \\<in> elts xa \\<Longrightarrow> \\<not> x + y < x\\<rbrakk>\n       \\<Longrightarrow> \\<not> x + xa < x", "case (step i)"], ["proof (state)\nthis:\n  Ord i\n  ?y \\<in> elts i \\<Longrightarrow> \\<not> x + ?y < x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Ord xa;\n        \\<And>y. y \\<in> elts xa \\<Longrightarrow> \\<not> x + y < x\\<rbrakk>\n       \\<Longrightarrow> \\<not> x + xa < x", "then"], ["proof (chain)\npicking this:\n  Ord i\n  ?y \\<in> elts i \\<Longrightarrow> \\<not> x + ?y < x", "show ?case"], ["proof (prove)\nusing this:\n  Ord i\n  ?y \\<in> elts i \\<Longrightarrow> \\<not> x + ?y < x\n\ngoal (1 subgoal):\n 1. \\<not> x + i < x", "by (metis less_le_not_le plus sup_ge1)"], ["proof (state)\nthis:\n  \\<not> x + i < x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_add_mem_right: \"\\<not> (x + y \\<in> elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<notin> elts x", "by (metis sup_ge1 mem_not_refl plus vsubsetD)"], ["", "text\\<open>Proposition 3.3(iii)\\<close>"], ["", "lemma add_not_less_TC_self: \"\\<not> x + y \\<sqsubset> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x + y \\<sqsubset> x", "proof (induction y arbitrary: x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<And>y xa.\n           y \\<in> elts x \\<Longrightarrow>\n           \\<not> xa + y \\<sqsubset> xa) \\<Longrightarrow>\n       \\<not> xa + x \\<sqsubset> xa", "case (step y)"], ["proof (state)\nthis:\n  ?y \\<in> elts y \\<Longrightarrow> \\<not> ?x + ?y \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<And>y xa.\n           y \\<in> elts x \\<Longrightarrow>\n           \\<not> xa + y \\<sqsubset> xa) \\<Longrightarrow>\n       \\<not> xa + x \\<sqsubset> xa", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts y \\<Longrightarrow> \\<not> ?x + ?y \\<sqsubset> ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in> elts y \\<Longrightarrow> \\<not> ?x + ?y \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. \\<not> x + y \\<sqsubset> x", "using less_TC_imp_not_le plus_eq_lift"], ["proof (prove)\nusing this:\n  ?y \\<in> elts y \\<Longrightarrow> \\<not> ?x + ?y \\<sqsubset> ?x\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. \\<not> x + y \\<sqsubset> x", "by fastforce"], ["proof (state)\nthis:\n  \\<not> x + y \\<sqsubset> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TC_sup_lift: \"TC x \\<sqinter> lift x y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "have \"elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}", "using add_not_less_TC_self"], ["proof (prove)\nusing this:\n  \\<not> ?x + ?y \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}", "by (auto simp: less_TC_def)"], ["proof (state)\nthis:\n  elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}\n\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "then"], ["proof (chain)\npicking this:\n  elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}", "have \"TC x \\<sqinter> set ((+) x ` elts y) = set {}\""], ["proof (prove)\nusing this:\n  elts (TC x) \\<inter> elts (set ((+) x ` elts y)) = {}\n\ngoal (1 subgoal):\n 1. TC x \\<sqinter> set ((+) x ` elts y) = set {}", "by (metis inf_V_def)"], ["proof (state)\nthis:\n  TC x \\<sqinter> set ((+) x ` elts y) = set {}\n\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "then"], ["proof (chain)\npicking this:\n  TC x \\<sqinter> set ((+) x ` elts y) = set {}", "show ?thesis"], ["proof (prove)\nusing this:\n  TC x \\<sqinter> set ((+) x ` elts y) = set {}\n\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "using lift_def"], ["proof (prove)\nusing this:\n  TC x \\<sqinter> set ((+) x ` elts y) = set {}\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. TC x \\<sqinter> lift x y = 0", "by auto"], ["proof (state)\nthis:\n  TC x \\<sqinter> lift x y = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_lift: \"lift x (lift y z) = lift (x+y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x (lift y z) = lift (x + y) z", "using add.assoc"], ["proof (prove)\nusing this:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. lift x (lift y z) = lift (x + y) z", "by (auto simp: lift_def)"], ["", "lemma lift_self_disjoint: \"x \\<sqinter> lift x u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> lift x u = 0", "by (metis TC_sup_lift arg_subset_TC inf.absorb_iff2 inf_assoc inf_sup_aci(3) lift_0)"], ["", "lemma sup_lift_eq_lift:\n  assumes \"x \\<squnion> lift x u = x \\<squnion> lift x v\"\n  shows \"lift x u = lift x v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x u = lift x v", "by (metis (no_types) assms inf_sup_absorb inf_sup_distrib2 lift_self_disjoint sup_commute sup_inf_absorb)"], ["", "subsubsection \\<open>Deeper properties of addition\\<close>"], ["", "text\\<open>Proposition 3.4(i)\\<close>"], ["", "proposition lift_eq_lift: \"lift x y = lift x z \\<Longrightarrow> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x y = lift x z \\<Longrightarrow> y = z", "proof (induction y arbitrary: z rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa z.\n       \\<lbrakk>\\<And>y z.\n                   \\<lbrakk>y \\<in> elts xa; lift x y = lift x z\\<rbrakk>\n                   \\<Longrightarrow> y = z;\n        lift x xa = lift x z\\<rbrakk>\n       \\<Longrightarrow> xa = z", "case (step y)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts y; lift x ?y = lift x ?z\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n  lift x y = lift x z\n\ngoal (1 subgoal):\n 1. \\<And>xa z.\n       \\<lbrakk>\\<And>y z.\n                   \\<lbrakk>y \\<in> elts xa; lift x y = lift x z\\<rbrakk>\n                   \\<Longrightarrow> y = z;\n        lift x xa = lift x z\\<rbrakk>\n       \\<Longrightarrow> xa = z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = z", "proof (intro vsubsetI order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> elts y \\<Longrightarrow> x \\<in> elts z\n 2. \\<And>x. x \\<in> elts z \\<Longrightarrow> x \\<in> elts y", "show \"u \\<in> elts z\" if \"u \\<in> elts y\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> elts z", "have \"x+u \\<in> elts (lift x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + u \\<in> elts (lift x z)", "using lift_def step.prems that"], ["proof (prove)\nusing this:\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n  lift x y = lift x z\n  u \\<in> elts y\n\ngoal (1 subgoal):\n 1. x + u \\<in> elts (lift x z)", "by fastforce"], ["proof (state)\nthis:\n  x + u \\<in> elts (lift x z)\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "then"], ["proof (chain)\npicking this:\n  x + u \\<in> elts (lift x z)", "obtain v where \"v \\<in> elts z\" \"x+u = x+v\""], ["proof (prove)\nusing this:\n  x + u \\<in> elts (lift x z)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts z; x + u = x + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  x + u \\<in> elts (lift x z)\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts z; x + u = x + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> elts z\n  x + u = x + v\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts z\n  x + u = x + v", "have \"lift x u = lift x v\""], ["proof (prove)\nusing this:\n  v \\<in> elts z\n  x + u = x + v\n\ngoal (1 subgoal):\n 1. lift x u = lift x v", "using sup_lift_eq_lift"], ["proof (prove)\nusing this:\n  v \\<in> elts z\n  x + u = x + v\n  ?x \\<squnion> lift ?x ?u = ?x \\<squnion> lift ?x ?v \\<Longrightarrow>\n  lift ?x ?u = lift ?x ?v\n\ngoal (1 subgoal):\n 1. lift x u = lift x v", "by (simp add: plus_eq_lift)"], ["proof (state)\nthis:\n  lift x u = lift x v\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "then"], ["proof (chain)\npicking this:\n  lift x u = lift x v", "have \"u=v\""], ["proof (prove)\nusing this:\n  lift x u = lift x v\n\ngoal (1 subgoal):\n 1. u = v", "using step.IH that"], ["proof (prove)\nusing this:\n  lift x u = lift x v\n  \\<lbrakk>?y \\<in> elts y; lift x ?y = lift x ?z\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n  u \\<in> elts y\n\ngoal (1 subgoal):\n 1. u = v", "by blast"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "then"], ["proof (chain)\npicking this:\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "using \\<open>v \\<in> elts z\\<close>"], ["proof (prove)\nusing this:\n  u = v\n  v \\<in> elts z\n\ngoal (1 subgoal):\n 1. u \\<in> elts z", "by blast"], ["proof (state)\nthis:\n  u \\<in> elts z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> elts y \\<Longrightarrow> ?u \\<in> elts z\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts z \\<Longrightarrow> x \\<in> elts y", "show \"u \\<in> elts y\" if \"u \\<in> elts z\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> elts y", "have \"x+u \\<in> elts (lift x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + u \\<in> elts (lift x y)", "using lift_def step.prems that"], ["proof (prove)\nusing this:\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n  lift x y = lift x z\n  u \\<in> elts z\n\ngoal (1 subgoal):\n 1. x + u \\<in> elts (lift x y)", "by fastforce"], ["proof (state)\nthis:\n  x + u \\<in> elts (lift x y)\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  x + u \\<in> elts (lift x y)", "obtain v where \"v \\<in> elts y\" \"x+u = x+v\""], ["proof (prove)\nusing this:\n  x + u \\<in> elts (lift x y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts y; x + u = x + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  x + u \\<in> elts (lift x y)\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts y; x + u = x + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> elts y\n  x + u = x + v\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts y\n  x + u = x + v", "have \"lift x u = lift x v\""], ["proof (prove)\nusing this:\n  v \\<in> elts y\n  x + u = x + v\n\ngoal (1 subgoal):\n 1. lift x u = lift x v", "using sup_lift_eq_lift"], ["proof (prove)\nusing this:\n  v \\<in> elts y\n  x + u = x + v\n  ?x \\<squnion> lift ?x ?u = ?x \\<squnion> lift ?x ?v \\<Longrightarrow>\n  lift ?x ?u = lift ?x ?v\n\ngoal (1 subgoal):\n 1. lift x u = lift x v", "by (simp add: plus_eq_lift)"], ["proof (state)\nthis:\n  lift x u = lift x v\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  lift x u = lift x v", "have \"u=v\""], ["proof (prove)\nusing this:\n  lift x u = lift x v\n\ngoal (1 subgoal):\n 1. u = v", "using step.IH"], ["proof (prove)\nusing this:\n  lift x u = lift x v\n  \\<lbrakk>?y \\<in> elts y; lift x ?y = lift x ?z\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. u = v", "by (metis \\<open>v \\<in> elts y\\<close>)"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "using \\<open>v \\<in> elts y\\<close>"], ["proof (prove)\nusing this:\n  u = v\n  v \\<in> elts y\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "by auto"], ["proof (state)\nthis:\n  u \\<in> elts y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> elts z \\<Longrightarrow> ?u \\<in> elts y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary inj_lift: \"inj_on (lift x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (lift x) A", "by (auto simp: inj_on_def dest: lift_eq_lift)"], ["", "corollary add_right_cancel [iff]:\n  fixes x y z::V shows \"x+y = x+z \\<longleftrightarrow> y=z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y = x + z) = (y = z)", "by (metis lift_eq_lift plus_eq_lift sup_lift_eq_lift)"], ["", "corollary add_mem_right_cancel [iff]:\n  fixes x y z::V shows \"x+y \\<in> elts (x+z) \\<longleftrightarrow> y \\<in> elts z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y \\<in> elts (x + z)) = (y \\<in> elts z)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. x + y \\<in> elts (x + z) \\<Longrightarrow> y \\<in> elts z\n 2. y \\<in> elts z \\<Longrightarrow> x + y \\<in> elts (x + z)", "apply (metis mem_plus_V_E not_add_mem_right add_right_cancel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> elts z \\<Longrightarrow> x + y \\<in> elts (x + z)", "by (metis ZFC_in_HOL.ext dual_order.antisym elts_vinsert insert_subset order_refl plus_vinsert)"], ["", "corollary add_le_cancel_left [iff]:\n  fixes x y z::V shows \"x+y \\<le> x+z \\<longleftrightarrow> y\\<le>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y \\<le> x + z) = (y \\<le> z)", "by auto (metis add_mem_right_cancel mem_plus_V_E plus sup_ge1 vsubsetD)"], ["", "corollary add_less_cancel_left [iff]:\n  fixes x y z::V shows \"x+y < x+z \\<longleftrightarrow> y<z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y < x + z) = (y < z)", "by (simp add: less_le_not_le)"], ["", "corollary lift_le_self [simp]: \"lift x y \\<le> x \\<longleftrightarrow> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift x y \\<le> x) = (y = 0)", "by (auto simp: inf.absorb_iff2 lift_eq_lift lift_self_disjoint)"], ["", "lemma succ_less_\\<omega>_imp: \"succ x < \\<omega> \\<Longrightarrow> x < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ x < \\<omega> \\<Longrightarrow> x < \\<omega>", "by (metis add_le_cancel_left add.right_neutral le_0 le_less_trans succ_eq_add1)"], ["", "text\\<open>Proposition 3.5\\<close>"], ["", "lemma card_lift: \"vcard (lift x y) = vcard y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (lift x y) = vcard y", "proof (rule cardinal_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (lift x y) \\<approx> elts y", "have \"bij_betw ((+)x) (elts y) (elts (lift x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((+) x) (elts y) (elts (lift x y))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((+) x) (elts y) \\<and> (+) x ` elts y = elts (lift x y)", "by (simp add: inj_on_def lift_def)"], ["proof (state)\nthis:\n  bij_betw ((+) x) (elts y) (elts (lift x y))\n\ngoal (1 subgoal):\n 1. elts (lift x y) \\<approx> elts y", "then"], ["proof (chain)\npicking this:\n  bij_betw ((+) x) (elts y) (elts (lift x y))", "show \"elts (lift x y) \\<approx> elts y\""], ["proof (prove)\nusing this:\n  bij_betw ((+) x) (elts y) (elts (lift x y))\n\ngoal (1 subgoal):\n 1. elts (lift x y) \\<approx> elts y", "using eqpoll_def eqpoll_sym"], ["proof (prove)\nusing this:\n  bij_betw ((+) x) (elts y) (elts (lift x y))\n  ?A \\<approx> ?B \\<equiv> \\<exists>f. bij_betw f ?A ?B\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n\ngoal (1 subgoal):\n 1. elts (lift x y) \\<approx> elts y", "by blast"], ["proof (state)\nthis:\n  elts (lift x y) \\<approx> elts y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eqpoll_lift: \"elts (lift x y) \\<approx> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (lift x y) \\<approx> elts y", "by (metis card_lift cardinal_eqpoll eqpoll_sym eqpoll_trans)"], ["", "lemma vcard_add: \"vcard (x + y) = vcard x \\<oplus> vcard y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (x + y) = vcard x \\<oplus> vcard y", "using card_lift [of x y] lift_self_disjoint [of x]"], ["proof (prove)\nusing this:\n  vcard (lift x y) = vcard y\n  x \\<sqinter> lift x ?u = 0\n\ngoal (1 subgoal):\n 1. vcard (x + y) = vcard x \\<oplus> vcard y", "by (simp add: plus_eq_lift vcard_disjoint_sup)"], ["", "lemma countable_add:\n  assumes \"countable (elts A)\" \"countable (elts B)\"\n  shows \"countable (elts (A+B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts (A + B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (elts (A + B))", "have \"vcard A \\<le> \\<aleph>0\" \"vcard B \\<le> \\<aleph>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0 &&& vcard B \\<le> \\<aleph>0", "using assms countable_iff_le_Aleph0"], ["proof (prove)\nusing this:\n  countable (elts A)\n  countable (elts B)\n  countable (elts ?A) = (vcard ?A \\<le> \\<aleph>0)\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0 &&& vcard B \\<le> \\<aleph>0", "by blast+"], ["proof (state)\nthis:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A + B))", "then"], ["proof (chain)\npicking this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0", "have \"vcard (A+B) \\<le> \\<aleph>0\""], ["proof (prove)\nusing this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. vcard (A + B) \\<le> \\<aleph>0", "unfolding vcard_add"], ["proof (prove)\nusing this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. vcard A \\<oplus> vcard B \\<le> \\<aleph>0", "by (metis Aleph_0 Card_\\<omega> InfCard_cdouble_eq InfCard_def cadd_le_mono order_refl)"], ["proof (state)\nthis:\n  vcard (A + B) \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A + B))", "then"], ["proof (chain)\npicking this:\n  vcard (A + B) \\<le> \\<aleph>0", "show ?thesis"], ["proof (prove)\nusing this:\n  vcard (A + B) \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A + B))", "by (simp add: countable_iff_le_Aleph0)"], ["proof (state)\nthis:\n  countable (elts (A + B))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Proposition 3.6\\<close>"], ["", "proposition TC_add: \"TC (x + y) = TC x \\<squnion> lift x (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x + y) = TC x \\<squnion> lift x (TC y)", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "case (step y)"], ["proof (state)\nthis:\n  ?y \\<in> elts y \\<Longrightarrow>\n  TC (x + ?y) = TC x \\<squnion> lift x (TC ?y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have *: \"\\<Squnion> (TC ` (+) x ` elts y) = TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))\"\n    if \"elts y \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "obtain w where \"w \\<in> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> elts y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>elts y \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  elts y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w. w \\<in> elts y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> elts y\n\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "then"], ["proof (chain)\npicking this:\n  w \\<in> elts y", "have \"TC x \\<le> TC (x + w)\""], ["proof (prove)\nusing this:\n  w \\<in> elts y\n\ngoal (1 subgoal):\n 1. TC x \\<le> TC (x + w)", "by (simp add: step.IH)"], ["proof (state)\nthis:\n  TC x \\<le> TC (x + w)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "then"], ["proof (chain)\npicking this:\n  TC x \\<le> TC (x + w)", "have \\<dagger>: \"TC x \\<le> (SUP w\\<in>elts y. TC (x + w))\""], ["proof (prove)\nusing this:\n  TC x \\<le> TC (x + w)\n\ngoal (1 subgoal):\n 1. TC x \\<le> (SUP w\\<in>elts y. TC (x + w))", "using \\<open>w \\<in> elts y\\<close>"], ["proof (prove)\nusing this:\n  TC x \\<le> TC (x + w)\n  w \\<in> elts y\n\ngoal (1 subgoal):\n 1. TC x \\<le> (SUP w\\<in>elts y. TC (x + w))", "by blast"], ["proof (state)\nthis:\n  TC x \\<le> (SUP w\\<in>elts y. TC (x + w))\n\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "using that"], ["proof (prove)\nusing this:\n  elts y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` (+) x ` elts y) =\n    TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))", "apply (intro conjI ballI impI order_antisym; clarsimp simp add: image_comp \\<dagger>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>y \\<noteq> 0; xa \\<in> elts (TC (x + xb)); xb \\<in> elts y;\n        \\<forall>xb\\<in>elts y.\n           xa \\<notin> elts (TC (set ((+) x ` elts xb)))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts (TC x)\n 2. \\<And>xa xb.\n       \\<lbrakk>y \\<noteq> 0; xa \\<in> elts (TC (set ((+) x ` elts xb)));\n        xb \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>elts y. xa \\<in> elts (TC (x + xb))", "apply(metis TC_sup_distrib Un_iff elts_sup_iff plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>y \\<noteq> 0; xa \\<in> elts (TC (set ((+) x ` elts xb)));\n        xb \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<in>elts y. xa \\<in> elts (TC (x + xb))", "by (metis TC_least Transset_TC arg_subset_TC le_sup_iff plus vsubsetD)"], ["proof (state)\nthis:\n  \\<Squnion> (TC ` (+) x ` elts y) =\n  TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts y \\<noteq> {} \\<Longrightarrow>\n  \\<Squnion> (TC ` (+) x ` elts y) =\n  TC x \\<squnion> (SUP u\\<in>elts y. TC (set ((+) x ` elts u)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"TC (x + y) = (x + y) \\<squnion> \\<Squnion> (TC ` elts (x + y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x + y) = x + y \\<squnion> \\<Squnion> (TC ` elts (x + y))", "using TC"], ["proof (prove)\nusing this:\n  TC ?a = ?a \\<squnion> \\<Squnion> (TC ` elts ?a)\n\ngoal (1 subgoal):\n 1. TC (x + y) = x + y \\<squnion> \\<Squnion> (TC ` elts (x + y))", "by blast"], ["proof (state)\nthis:\n  TC (x + y) = x + y \\<squnion> \\<Squnion> (TC ` elts (x + y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "also"], ["proof (state)\nthis:\n  TC (x + y) = x + y \\<squnion> \\<Squnion> (TC ` elts (x + y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"\\<dots> = x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> \\<Squnion> ((\\<lambda>u. TC (x+u)) ` elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<squnion> \\<Squnion> (TC ` elts (x + y)) =\n    x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n    (SUP u\\<in>elts y. TC (x + u))", "apply (simp add: plus_eq_lift image_Un Sup_Un_distrib sup.left_commute sup_assoc TC_sup_distrib SUP_sup_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<longrightarrow>\n    x \\<squnion>\n    (lift x y \\<squnion>\n     (\\<Squnion> (TC ` elts x) \\<squnion>\n      \\<Squnion> (TC ` elts (lift x y)))) =\n    x \\<squnion>\n    (TC x \\<squnion>\n     (lift x y \\<squnion>\n      (\\<Squnion> (TC ` elts x) \\<squnion>\n       (SUP xa\\<in>elts y. TC (lift x xa)))))", "apply (simp add: lift_def sup.commute sup_aci *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x + y \\<squnion> \\<Squnion> (TC ` elts (x + y)) =\n  x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n  (SUP u\\<in>elts y. TC (x + u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "also"], ["proof (state)\nthis:\n  x + y \\<squnion> \\<Squnion> (TC ` elts (x + y)) =\n  x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n  (SUP u\\<in>elts y. TC (x + u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"\\<dots> = x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion> \\<Squnion> ((\\<lambda>u. TC x \\<squnion> lift x (TC u)) ` elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n    (SUP u\\<in>elts y. TC (x + u)) =\n    x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n    (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))", "by (simp add: sup_aci step.IH)"], ["proof (state)\nthis:\n  x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n  (SUP u\\<in>elts y. TC (x + u)) =\n  x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n  (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "also"], ["proof (state)\nthis:\n  x \\<squnion> lift x y \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion>\n  (SUP u\\<in>elts y. TC (x + u)) =\n  x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n  (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"\\<dots> = TC x \\<squnion> lift x y \\<squnion> \\<Squnion> ((\\<lambda>u. lift x (TC u)) ` elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n    (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n    TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u))", "by (simp add: sup_aci SUP_sup_distrib flip: TC [of x])"], ["proof (state)\nthis:\n  x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n  (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n  TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "also"], ["proof (state)\nthis:\n  x \\<squnion> \\<Squnion> (TC ` elts x) \\<squnion> lift x y \\<squnion>\n  (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n  TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"\\<dots> = TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u)) =\n    TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y))", "by (metis (no_types) elts_of_set lift_Sup_distrib image_image lift_sup_distrib replacement small_elts sup_assoc)"], ["proof (state)\nthis:\n  TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u)) =\n  TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "also"], ["proof (state)\nthis:\n  TC x \\<squnion> lift x y \\<squnion> (SUP u\\<in>elts y. lift x (TC u)) =\n  TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "have \"\\<dots> = TC x \\<squnion> lift x (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y)) =\n    TC x \\<squnion> lift x (TC y)", "by (simp add: TC [of y])"], ["proof (state)\nthis:\n  TC x \\<squnion> lift x (y \\<squnion> \\<Squnion> (TC ` elts y)) =\n  TC x \\<squnion> lift x (TC y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x + y) = TC x \\<squnion> lift x (TC y)) \\<Longrightarrow>\n       TC (x + xa) = TC x \\<squnion> lift x (TC xa)", "finally"], ["proof (chain)\npicking this:\n  TC (x + y) = TC x \\<squnion> lift x (TC y)", "show ?case"], ["proof (prove)\nusing this:\n  TC (x + y) = TC x \\<squnion> lift x (TC y)\n\ngoal (1 subgoal):\n 1. TC (x + y) = TC x \\<squnion> lift x (TC y)", "."], ["proof (state)\nthis:\n  TC (x + y) = TC x \\<squnion> lift x (TC y)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary TC_add': \"z \\<sqsubset> x + y \\<longleftrightarrow> z \\<sqsubset> x \\<or> (\\<exists>v. v \\<sqsubset> y \\<and> z = x + v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqsubset> x + y) =\n    (z \\<sqsubset> x \\<or> (\\<exists>v. v \\<sqsubset> y \\<and> z = x + v))", "using TC_add"], ["proof (prove)\nusing this:\n  TC (?x + ?y) = TC ?x \\<squnion> lift ?x (TC ?y)\n\ngoal (1 subgoal):\n 1. (z \\<sqsubset> x + y) =\n    (z \\<sqsubset> x \\<or> (\\<exists>v. v \\<sqsubset> y \\<and> z = x + v))", "by (force simp: less_TC_def lift_def)"], ["", "text\\<open>Corollary 3.7\\<close>"], ["", "corollary vcard_TC_add: \"vcard (TC (x+y)) = vcard (TC x) \\<oplus> vcard (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (TC (x + y)) = vcard (TC x) \\<oplus> vcard (TC y)", "by (simp add: TC_add TC_sup_lift card_lift vcard_disjoint_sup)"], ["", "text\\<open>Corollary 3.8\\<close>"], ["", "corollary TC_lift:\n  assumes \"y \\<noteq> 0\"\n  shows \"TC (lift x y) = TC x \\<squnion> lift x (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "have \"TC (lift x y) = lift x y \\<squnion> \\<Squnion> ((\\<lambda>u. TC(x+u)) ` elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (lift x y) = lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u))", "unfolding TC [of \"lift x y\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x y \\<squnion> \\<Squnion> (TC ` elts (lift x y)) =\n    lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u))", "by (simp add: lift_def image_image)"], ["proof (state)\nthis:\n  TC (lift x y) = lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "also"], ["proof (state)\nthis:\n  TC (lift x y) = lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "have \"\\<dots> = lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u)) =\n    lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))", "by (simp add: TC_add)"], ["proof (state)\nthis:\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u)) =\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "also"], ["proof (state)\nthis:\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC (x + u)) =\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "have \"\\<dots> = lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n    lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u))", "using assms"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n    lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u))", "by (auto simp: SUP_sup_distrib)"], ["proof (state)\nthis:\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n  lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "also"], ["proof (state)\nthis:\n  lift x y \\<squnion> (SUP u\\<in>elts y. TC x \\<squnion> lift x (TC u)) =\n  lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u))\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "have \"\\<dots> = TC x \\<squnion> lift x (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u)) =\n    TC x \\<squnion> lift x (TC y)", "by (simp add: TC [of y] sup_aci image_image lift_sup_distrib lift_Sup_distrib)"], ["proof (state)\nthis:\n  lift x y \\<squnion> TC x \\<squnion> (SUP u\\<in>elts y. lift x (TC u)) =\n  TC x \\<squnion> lift x (TC y)\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "finally"], ["proof (chain)\npicking this:\n  TC (lift x y) = TC x \\<squnion> lift x (TC y)", "show ?thesis"], ["proof (prove)\nusing this:\n  TC (lift x y) = TC x \\<squnion> lift x (TC y)\n\ngoal (1 subgoal):\n 1. TC (lift x y) = TC x \\<squnion> lift x (TC y)", "."], ["proof (state)\nthis:\n  TC (lift x y) = TC x \\<squnion> lift x (TC y)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition rank_add_distrib: \"rank (x+y) = rank x + rank y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (x + y) = rank x + rank y", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x + y) = rank x + rank y) \\<Longrightarrow>\n       rank (x + xa) = rank x + rank xa", "case (step y)"], ["proof (state)\nthis:\n  ?y \\<in> elts y \\<Longrightarrow> rank (x + ?y) = rank x + rank ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x + y) = rank x + rank y) \\<Longrightarrow>\n       rank (x + xa) = rank x + rank xa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (x + y) = rank x + rank y", "proof (cases \"y=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "obtain e where e: \"e \\<in> elts y\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>e. e \\<in> elts y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  e \\<in> elts y\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "have \"rank (x+y) = (SUP u\\<in>elts (x \\<squnion> ZFC_in_HOL.set ((+) x ` elts y)). succ (rank u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (x + y) =\n    (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n        ZFC_in_HOL.succ (rank u))", "by (metis plus rank_Sup)"], ["proof (state)\nthis:\n  rank (x + y) =\n  (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n      ZFC_in_HOL.succ (rank u))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "also"], ["proof (state)\nthis:\n  rank (x + y) =\n  (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n      ZFC_in_HOL.succ (rank u))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "have \"\\<dots> = (SUP x\\<in>elts x. succ (rank x)) \\<squnion> (SUP z\\<in>elts y. succ (rank x + rank z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n        ZFC_in_HOL.succ (rank u)) =\n    (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))", "apply (simp add: Sup_Un_distrib image_Un image_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP xa\\<in>elts y. ZFC_in_HOL.succ (rank (x + xa))) =\n    (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))", "apply (simp add: step cong: SUP_cong_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n      ZFC_in_HOL.succ (rank u)) =\n  (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n  (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts (x \\<squnion> set ((+) x ` elts y)).\n      ZFC_in_HOL.succ (rank u)) =\n  (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n  (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "have \"\\<dots> = (SUP z \\<in> elts y. rank x + succ (rank z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n    (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n    (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))", "have \"rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))", "using \\<open>y \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))", "by (auto simp: plus_eq_lift intro: order_trans [OF _ cSUP_upper [OF e]])"], ["proof (state)\nthis:\n  rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n    (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))", "then"], ["proof (chain)\npicking this:\n  rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))", "show ?thesis"], ["proof (prove)\nusing this:\n  rank x \\<le> (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z))\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n    (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n    (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))", "by (force simp: plus_V_succ_right simp flip: rank_Sup [of x] intro!: order_antisym)"], ["proof (state)\nthis:\n  (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n  (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n  (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n  (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n  (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "also"], ["proof (state)\nthis:\n  (SUP x\\<in>elts x. ZFC_in_HOL.succ (rank x)) \\<squnion>\n  (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank x + rank z)) =\n  (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "have \"\\<dots> = rank x + (SUP z \\<in> elts y. succ (rank z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z)) =\n    rank x + (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank z))", "by (simp add: add_Sup_distrib False)"], ["proof (state)\nthis:\n  (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z)) =\n  rank x + (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "also"], ["proof (state)\nthis:\n  (SUP z\\<in>elts y. rank x + ZFC_in_HOL.succ (rank z)) =\n  rank x + (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank z))\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "have \"\\<dots> = rank x + rank y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x + (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank z)) = rank x + rank y", "by (simp add: rank_Sup [of y])"], ["proof (state)\nthis:\n  rank x + (SUP z\\<in>elts y. ZFC_in_HOL.succ (rank z)) = rank x + rank y\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y\n 2. y \\<noteq> 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "finally"], ["proof (chain)\npicking this:\n  rank (x + y) = rank x + rank y", "show ?thesis"], ["proof (prove)\nusing this:\n  rank (x + y) = rank x + rank y\n\ngoal (1 subgoal):\n 1. rank (x + y) = rank x + rank y", "."], ["proof (state)\nthis:\n  rank (x + y) = rank x + rank y\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow> rank (x + y) = rank x + rank y", "qed auto"], ["proof (state)\nthis:\n  rank (x + y) = rank x + rank y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_add [simp]: \"\\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> Ord (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord x; Ord y\\<rbrakk> \\<Longrightarrow> Ord (x + y)", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; Ord x; Ord y\\<rbrakk>\n                   \\<Longrightarrow> Ord (x + y);\n        Ord x; Ord xa\\<rbrakk>\n       \\<Longrightarrow> Ord (x + xa)", "case (step y)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts y; Ord x; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> Ord (x + ?y)\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; Ord x; Ord y\\<rbrakk>\n                   \\<Longrightarrow> Ord (x + y);\n        Ord x; Ord xa\\<rbrakk>\n       \\<Longrightarrow> Ord (x + xa)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> elts y; Ord x; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> Ord (x + ?y)\n  Ord x\n  Ord y", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts y; Ord x; Ord ?y\\<rbrakk>\n  \\<Longrightarrow> Ord (x + ?y)\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. Ord (x + y)", "by (metis Ord_rank rank_add_distrib rank_of_Ord)"], ["proof (state)\nthis:\n  Ord (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_Sup_distrib_id: \"A \\<noteq> 0 \\<Longrightarrow> x + \\<Squnion>(elts A) = (SUP z\\<in>elts A. x + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> 0 \\<Longrightarrow>\n    x + \\<Squnion> (elts A) = \\<Squnion> ((+) x ` elts A)", "by (metis add_Sup_distrib image_ident image_image)"], ["", "lemma add_Limit: \"Limit \\<alpha> \\<Longrightarrow> x + \\<alpha> = (SUP z\\<in>elts \\<alpha>. x + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<alpha> \\<Longrightarrow>\n    x + \\<alpha> = \\<Squnion> ((+) x ` elts \\<alpha>)", "by (metis Limit_add_Sup_distrib Limit_eq_Sup_self image_ident image_image)"], ["", "lemma add_le_left:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"\\<beta> \\<le> \\<alpha>+\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<le> \\<alpha> + \\<beta>", "using \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<le> \\<alpha> + \\<beta>", "proof (induction rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> \\<alpha> + 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>'; \\<alpha>' \\<le> \\<alpha> + \\<alpha>'\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<alpha>'\n                         \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>'\n 3. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. 0 \\<le> \\<alpha> + 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>'; \\<alpha>' \\<le> \\<alpha> + \\<alpha>'\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<alpha>'\n                         \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>'\n 3. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<alpha> + 0", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<alpha> + 0\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>'; \\<alpha>' \\<le> \\<alpha> + \\<alpha>'\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<alpha>'\n                         \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>'\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>'; \\<alpha>' \\<le> \\<alpha> + \\<alpha>'\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<alpha>'\n                         \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>'\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "case (succ \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<alpha> \\<le> \\<alpha> + \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>'; \\<alpha>' \\<le> \\<alpha> + \\<alpha>'\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<alpha>'\n                         \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>'\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  \\<alpha> \\<le> \\<alpha> + \\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  \\<alpha> \\<le> \\<alpha> + \\<alpha>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<alpha> \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>", "by (auto simp: plus_V_succ_right Ord_mem_iff_lt assms(1))"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<alpha> \\<le> \\<alpha> + ZFC_in_HOL.succ \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "case (Limit \\<mu>)"], ["proof (state)\nthis:\n  Limit \\<mu>\n  ?\\<xi> \\<in> elts \\<mu> \\<Longrightarrow> ?\\<xi> \\<le> \\<alpha> + ?\\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  Limit \\<mu>\n  ?\\<xi> \\<in> elts \\<mu> \\<Longrightarrow> ?\\<xi> \\<le> \\<alpha> + ?\\<xi>", "have k: \"\\<mu> = (SUP \\<beta> \\<in> elts \\<mu>. \\<beta>)\""], ["proof (prove)\nusing this:\n  Limit \\<mu>\n  ?\\<xi> \\<in> elts \\<mu> \\<Longrightarrow> ?\\<xi> \\<le> \\<alpha> + ?\\<xi>\n\ngoal (1 subgoal):\n 1. \\<mu> = (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)", "by (simp add: Limit_eq_Sup_self)"], ["proof (state)\nthis:\n  \\<mu> = (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "also"], ["proof (state)\nthis:\n  \\<mu> = (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "have \"\\<dots>  \\<le> (SUP \\<beta> \\<in> elts \\<mu>. \\<alpha> + \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n    \\<le> \\<Squnion> ((+) \\<alpha> ` elts \\<mu>)", "using Limit.IH"], ["proof (prove)\nusing this:\n  ?\\<xi> \\<in> elts \\<mu> \\<Longrightarrow> ?\\<xi> \\<le> \\<alpha> + ?\\<xi>\n\ngoal (1 subgoal):\n 1. (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n    \\<le> \\<Squnion> ((+) \\<alpha> ` elts \\<mu>)", "by auto"], ["proof (state)\nthis:\n  (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n  \\<le> \\<Squnion> ((+) \\<alpha> ` elts \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "also"], ["proof (state)\nthis:\n  (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n  \\<le> \\<Squnion> ((+) \\<alpha> ` elts \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "have \"\\<dots> = \\<alpha> + (SUP \\<beta> \\<in> elts \\<mu>. \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> ((+) \\<alpha> ` elts \\<mu>) =\n    \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)", "using Limit.hyps Limit_add_Sup_distrib"], ["proof (prove)\nusing this:\n  Limit \\<mu>\n  Limit ?\\<alpha> \\<Longrightarrow>\n  ?x + \\<Squnion> (?f ` elts ?\\<alpha>) =\n  (SUP z\\<in>elts ?\\<alpha>. ?x + ?f z)\n\ngoal (1 subgoal):\n 1. \\<Squnion> ((+) \\<alpha> ` elts \\<mu>) =\n    \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)", "by presburger"], ["proof (state)\nthis:\n  \\<Squnion> ((+) \\<alpha> ` elts \\<mu>) =\n  \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<xi> \\<in> elts \\<alpha>' \\<Longrightarrow>\n           \\<xi> \\<le> \\<alpha> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)\n                         \\<le> \\<alpha> +\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "finally"], ["proof (chain)\npicking this:\n  \\<mu> \\<le> \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<mu> \\<le> \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n\ngoal (1 subgoal):\n 1. (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)\n    \\<le> \\<alpha> + (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)", "using k"], ["proof (prove)\nusing this:\n  \\<mu> \\<le> \\<alpha> + (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n  \\<mu> = (SUP \\<beta>\\<in>elts \\<mu>. \\<beta>)\n\ngoal (1 subgoal):\n 1. (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)\n    \\<le> \\<alpha> + (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)", "by simp"], ["proof (state)\nthis:\n  (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)\n  \\<le> \\<alpha> + (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_\\<omega>_equals_\\<omega>:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\"  shows \"\\<alpha> + \\<omega> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<omega> = \\<omega>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> + \\<omega> \\<le> \\<omega>\n 2. \\<omega> \\<le> \\<alpha> + \\<omega>", "show \"\\<alpha> + \\<omega> \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<omega> \\<le> \\<omega>", "using Ord_trans assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n  \\<alpha> \\<in> elts \\<omega>\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<omega> \\<le> \\<omega>", "by (auto simp: elim!: mem_plus_V_E)"], ["proof (state)\nthis:\n  \\<alpha> + \\<omega> \\<le> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> \\<alpha> + \\<omega>", "show \"\\<omega> \\<le> \\<alpha> + \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<le> \\<alpha> + \\<omega>", "by (simp add: add_le_left assms)"], ["proof (state)\nthis:\n  \\<omega> \\<le> \\<alpha> + \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_plus_\\<omega>_equals_\\<omega> [simp]: \"1 + \\<omega> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + \\<omega> = \\<omega>", "by (simp add: one_V_def plus_\\<omega>_equals_\\<omega>)"], ["", "subsubsection \\<open>Cancellation / set subtraction\\<close>"], ["", "definition vle :: \"V \\<Rightarrow> V \\<Rightarrow> bool\" (infix \"\\<unlhd>\" 50)\n  where \"x \\<unlhd> y \\<equiv> \\<exists>z::V. x+z = y\""], ["", "lemma vle_refl [iff]: \"x \\<unlhd> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<unlhd> x", "by (metis (no_types) add.right_neutral vle_def)"], ["", "lemma vle_antisym: \"\\<lbrakk>x \\<unlhd> y; y \\<unlhd> x\\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<unlhd> y; y \\<unlhd> x\\<rbrakk> \\<Longrightarrow> x = y", "by (metis V_equalityI plus_eq_lift sup_ge1 vle_def vsubsetD)"], ["", "lemma vle_trans [trans]: \"\\<lbrakk>x \\<unlhd> y; y \\<unlhd> z\\<rbrakk> \\<Longrightarrow> x \\<unlhd> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<unlhd> y; y \\<unlhd> z\\<rbrakk>\n    \\<Longrightarrow> x \\<unlhd> z", "by (metis add.assoc vle_def)"], ["", "definition vle_comparable :: \"V \\<Rightarrow> V \\<Rightarrow> bool\"\n  where \"vle_comparable x y \\<equiv> x \\<unlhd> y \\<or> y \\<unlhd> x\""], ["", "text\\<open>Lemma 3.13\\<close>"], ["", "lemma comparable:\n  assumes \"a+b = c+d\"\n  shows \"vle_comparable a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vle_comparable a c", "unfolding vle_comparable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<unlhd> c \\<or> c \\<unlhd> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a) \\<Longrightarrow> False", "assume non: \"\\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\""], ["proof (state)\nthis:\n  \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a) \\<Longrightarrow> False", "let ?\\<phi> = \"\\<lambda>x. \\<forall>z. a+x \\<noteq> c+z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a) \\<Longrightarrow> False", "have \"?\\<phi> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. a + x \\<noteq> c + z", "proof (induction x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           \\<forall>z. a + y \\<noteq> c + z) \\<Longrightarrow>\n       \\<forall>z. a + x \\<noteq> c + z", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> \\<forall>z. a + ?y \\<noteq> c + z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           \\<forall>z. a + y \\<noteq> c + z) \\<Longrightarrow>\n       \\<forall>z. a + x \\<noteq> c + z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. a + x \\<noteq> c + z", "proof (cases \"x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "with non nonzero_less_TC"], ["proof (chain)\npicking this:\n  \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>z. a + x \\<noteq> c + z", "using vle_def"], ["proof (prove)\nusing this:\n  \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n  x = 0\n  ?x \\<unlhd> ?y \\<equiv> \\<exists>z. ?x + z = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>z. a + x \\<noteq> c + z", "by auto"], ["proof (state)\nthis:\n  \\<forall>z. a + x \\<noteq> c + z\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "obtain v where \"v \\<in> elts x\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> elts x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trad_foundation"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  ?z \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>w. w \\<in> elts ?z \\<and> w \\<sqinter> ?z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> elts x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> elts x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<forall>z. a + x \\<noteq> c + z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. a + x \\<noteq> c + z", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "assume eq: \"a + x = c + z\""], ["proof (state)\nthis:\n  a + x = c + z\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a + x = c + z", "have \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a + x = c + z\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "using vle_def non"], ["proof (prove)\nusing this:\n  a + x = c + z\n  ?x \\<unlhd> ?y \\<equiv> \\<exists>z. ?x + z = ?y\n  \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a)\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "have av: \"a+v \\<in> elts (a+x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + v \\<in> elts (a + x)", "by (simp add: \\<open>v \\<in> elts x\\<close>)"], ["proof (state)\nthis:\n  a + v \\<in> elts (a + x)\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a + v \\<in> elts (a + x)\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "have \"a+x = c \\<squnion> lift c z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + x = c \\<squnion> lift c z", "using eq plus_eq_lift"], ["proof (prove)\nusing this:\n  a + x = c + z\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. a + x = c \\<squnion> lift c z", "by fastforce"], ["proof (state)\nthis:\n  a + x = c \\<squnion> lift c z\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a + v \\<in> elts (a + x)\n  a + x = c \\<squnion> lift c z", "have \"a+v \\<in> elts (c \\<squnion> lift c z)\""], ["proof (prove)\nusing this:\n  a + v \\<in> elts (a + x)\n  a + x = c \\<squnion> lift c z\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts (c \\<squnion> lift c z)", "by simp"], ["proof (state)\nthis:\n  a + v \\<in> elts (c \\<squnion> lift c z)\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a + v \\<in> elts (c \\<squnion> lift c z)\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "define u where \"u \\<equiv> set (elts x - {v})\""], ["proof (state)\nthis:\n  u \\<equiv> set (elts x - {v})\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "have u: \"v \\<notin> elts u\" and xeq: \"x = vinsert v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> elts u &&& x = vinsert v u", "using \\<open>v \\<in> elts x\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> elts x\n\ngoal (1 subgoal):\n 1. v \\<notin> elts u &&& x = vinsert v u", "by (auto simp: u_def intro: order_antisym)"], ["proof (state)\nthis:\n  v \\<notin> elts u\n  x = vinsert v u\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "have case1: \"a+v \\<notin> elts c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + v \\<notin> elts c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "assume avc: \"a + v \\<in> elts c\""], ["proof (state)\nthis:\n  a + v \\<in> elts c\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a + v \\<in> elts c", "have \"a \\<le> c\""], ["proof (prove)\nusing this:\n  a + v \\<in> elts c\n\ngoal (1 subgoal):\n 1. a \\<le> c", "by clarify (metis Un_iff elts_sup_iff eq mem_not_sym mem_plus_V_E plus_eq_lift)"], ["proof (state)\nthis:\n  a \\<le> c\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a \\<le> c\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "have \"a \\<squnion> lift a x = c \\<squnion> lift c z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> lift a x = c \\<squnion> lift c z", "using eq"], ["proof (prove)\nusing this:\n  a + x = c + z\n\ngoal (1 subgoal):\n 1. a \\<squnion> lift a x = c \\<squnion> lift c z", "by (simp add: plus_eq_lift)"], ["proof (state)\nthis:\n  a \\<squnion> lift a x = c \\<squnion> lift c z\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> c\n  a \\<squnion> lift a x = c \\<squnion> lift c z", "have \"lift c z \\<le> lift a x\""], ["proof (prove)\nusing this:\n  a \\<le> c\n  a \\<squnion> lift a x = c \\<squnion> lift c z\n\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a x", "by (metis inf.absorb_iff2 inf_commute inf_sup_absorb inf_sup_distrib2 lift_self_disjoint sup.commute)"], ["proof (state)\nthis:\n  lift c z \\<le> lift a x\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift c z \\<le> lift a x\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "have \"\\<dots> = vinsert (a+v) (lift a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift a x = vinsert (a + v) (lift a u)", "by (simp add: lift_def vinsert_def xeq)"], ["proof (state)\nthis:\n  lift a x = vinsert (a + v) (lift a u)\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lift c z \\<le> vinsert (a + v) (lift a u)", "have *: \"lift c z \\<le> vinsert (a + v) (lift a u)\""], ["proof (prove)\nusing this:\n  lift c z \\<le> vinsert (a + v) (lift a u)\n\ngoal (1 subgoal):\n 1. lift c z \\<le> vinsert (a + v) (lift a u)", "."], ["proof (state)\nthis:\n  lift c z \\<le> vinsert (a + v) (lift a u)\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "have \"lift c z \\<le> lift a u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a u", "have \"a + v \\<notin> elts (lift c z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + v \\<notin> elts (lift c z)", "using lift_self_disjoint [of c z] avc V_disjoint_iff"], ["proof (prove)\nusing this:\n  c \\<sqinter> lift c z = 0\n  a + v \\<in> elts c\n  (?x \\<sqinter> ?y = 0) = (elts ?x \\<inter> elts ?y = {})\n\ngoal (1 subgoal):\n 1. a + v \\<notin> elts (lift c z)", "by auto"], ["proof (state)\nthis:\n  a + v \\<notin> elts (lift c z)\n\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a u", "then"], ["proof (chain)\npicking this:\n  a + v \\<notin> elts (lift c z)", "show ?thesis"], ["proof (prove)\nusing this:\n  a + v \\<notin> elts (lift c z)\n\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a u", "using * less_eq_V_def"], ["proof (prove)\nusing this:\n  a + v \\<notin> elts (lift c z)\n  lift c z \\<le> vinsert (a + v) (lift a u)\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. lift c z \\<le> lift a u", "by auto"], ["proof (state)\nthis:\n  lift c z \\<le> lift a u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lift c z \\<le> lift a u\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  lift c z \\<le> lift a u\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "assume \"e \\<in> elts z\""], ["proof (state)\nthis:\n  e \\<in> elts z\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e \\<in> elts z", "have \"c+e \\<in> elts (lift c z)\""], ["proof (prove)\nusing this:\n  e \\<in> elts z\n\ngoal (1 subgoal):\n 1. c + e \\<in> elts (lift c z)", "by (simp add: lift_def)"], ["proof (state)\nthis:\n  c + e \\<in> elts (lift c z)\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c + e \\<in> elts (lift c z)", "have \"c+e \\<in> elts (lift a u)\""], ["proof (prove)\nusing this:\n  c + e \\<in> elts (lift c z)\n\ngoal (1 subgoal):\n 1. c + e \\<in> elts (lift a u)", "using \\<open>lift c z \\<le> lift a u\\<close>"], ["proof (prove)\nusing this:\n  c + e \\<in> elts (lift c z)\n  lift c z \\<le> lift a u\n\ngoal (1 subgoal):\n 1. c + e \\<in> elts (lift a u)", "by blast"], ["proof (state)\nthis:\n  c + e \\<in> elts (lift a u)\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c + e \\<in> elts (lift a u)", "obtain y where \"y \\<in> elts u\" \"c+e = a+y\""], ["proof (prove)\nusing this:\n  c + e \\<in> elts (lift a u)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> elts u; c + e = a + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  c + e \\<in> elts (lift a u)\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> elts u; c + e = a + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> elts u\n  c + e = a + y\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<in> elts u\n  c + e = a + y", "have False"], ["proof (prove)\nusing this:\n  y \\<in> elts u\n  c + e = a + y\n\ngoal (1 subgoal):\n 1. False", "by (metis elts_vinsert insert_iff step.IH xeq)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?e2 \\<in> elts z \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a + v \\<in> elts c \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?e2 \\<in> elts z \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  ?e2 \\<in> elts z \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  ?e2 \\<in> elts z \\<Longrightarrow> False\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + v \\<notin> elts c\n\ngoal (1 subgoal):\n 1. \\<And>z. a + x = c + z \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a + v \\<in> elts (c \\<squnion> lift c z)\n  a + v \\<notin> elts c", "show False"], ["proof (prove)\nusing this:\n  a + v \\<in> elts (c \\<squnion> lift c z)\n  a + v \\<notin> elts c\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types) \\<open>v \\<in> elts x\\<close> av case1 eq mem_plus_V_E step.IH)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z. a + x \\<noteq> c + z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z. a + x \\<noteq> c + z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z. a + ?x \\<noteq> c + z\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<unlhd> c \\<or> c \\<unlhd> a) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>z. a + ?x \\<noteq> c + z", "show False"], ["proof (prove)\nusing this:\n  \\<forall>z. a + ?x \\<noteq> c + z\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>z. a + ?x \\<noteq> c + z\n  a + b = c + d\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vle1: \"x \\<unlhd> y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<unlhd> y \\<Longrightarrow> x \\<le> y", "using vle_def plus_eq_lift"], ["proof (prove)\nusing this:\n  ?x \\<unlhd> ?y \\<equiv> \\<exists>z. ?x + z = ?y\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. x \\<unlhd> y \\<Longrightarrow> x \\<le> y", "by auto"], ["", "lemma vle2: \"x \\<unlhd> y \\<Longrightarrow> x \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<unlhd> y \\<Longrightarrow> x \\<sqsubseteq> y", "by (metis (full_types) TC_add' add.right_neutral le_TC_def vle_def nonzero_less_TC)"], ["", "lemma vle_iff_le_Ord:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  shows \"\\<alpha> \\<unlhd> \\<beta> \\<longleftrightarrow> \\<alpha> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> \\<unlhd> \\<beta>) = (\\<alpha> \\<le> \\<beta>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow> \\<alpha> \\<le> \\<beta>\n 2. \\<alpha> \\<le> \\<beta> \\<Longrightarrow> \\<alpha> \\<unlhd> \\<beta>", "show \"\\<alpha> \\<le> \\<beta>\" if \"\\<alpha> \\<unlhd> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "by (simp add: vle1)"], ["proof (state)\nthis:\n  \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow> \\<alpha> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta> \\<Longrightarrow> \\<alpha> \\<unlhd> \\<beta>", "show \"\\<alpha> \\<unlhd> \\<beta>\" if \"\\<alpha> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<unlhd> \\<beta>", "using \\<open>Ord \\<alpha>\\<close> \\<open>Ord \\<beta>\\<close> that"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<alpha> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<unlhd> \\<beta>", "proof (induction \\<alpha> arbitrary: \\<beta> rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<beta>.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<beta>.\n           \\<lbrakk>y \\<in> elts x; Ord \\<beta>; y \\<le> \\<beta>\\<rbrakk>\n           \\<Longrightarrow> y \\<unlhd> \\<beta>;\n        Ord \\<beta>; x \\<le> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> x \\<unlhd> \\<beta>", "case (step \\<gamma>)"], ["proof (state)\nthis:\n  Ord \\<gamma>\n  \\<lbrakk>?y \\<in> elts \\<gamma>; Ord ?\\<beta>; ?y \\<le> ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?y \\<unlhd> ?\\<beta>\n  Ord \\<beta>\n  \\<gamma> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<beta>.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<beta>.\n           \\<lbrakk>y \\<in> elts x; Ord \\<beta>; y \\<le> \\<beta>\\<rbrakk>\n           \\<Longrightarrow> y \\<unlhd> \\<beta>;\n        Ord \\<beta>; x \\<le> \\<beta>\\<rbrakk>\n       \\<Longrightarrow> x \\<unlhd> \\<beta>", "then"], ["proof (chain)\npicking this:\n  Ord \\<gamma>\n  \\<lbrakk>?y \\<in> elts \\<gamma>; Ord ?\\<beta>; ?y \\<le> ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?y \\<unlhd> ?\\<beta>\n  Ord \\<beta>\n  \\<gamma> \\<le> \\<beta>", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<gamma>\n  \\<lbrakk>?y \\<in> elts \\<gamma>; Ord ?\\<beta>; ?y \\<le> ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?y \\<unlhd> ?\\<beta>\n  Ord \\<beta>\n  \\<gamma> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> \\<unlhd> \\<beta>", "unfolding vle_def"], ["proof (prove)\nusing this:\n  Ord \\<gamma>\n  \\<lbrakk>?y \\<in> elts \\<gamma>; Ord ?\\<beta>; ?y \\<le> ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. ?y + z = ?\\<beta>\n  Ord \\<beta>\n  \\<gamma> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>z. \\<gamma> + z = \\<beta>", "by (metis Ord_add Ord_linear add_le_left mem_not_refl mem_plus_V_E vsubsetD)"], ["proof (state)\nthis:\n  \\<gamma> \\<unlhd> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<beta> \\<Longrightarrow> \\<alpha> \\<unlhd> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_le_cancel_left0 [iff]:\n  fixes x::V shows \"x \\<le> x+z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x + z", "by (simp add: vle1 vle_def)"], ["", "lemma add_less_cancel_left0 [iff]:\n  fixes x::V shows \"x < x+z \\<longleftrightarrow> 0<z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < x + z) = (0 < z)", "by (metis add_less_cancel_left add.right_neutral)"], ["", "lemma le_Ord_diff:\n  assumes \"\\<alpha> \\<le> \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  obtains \\<gamma> where \"\\<alpha>+\\<gamma> = \\<beta>\" \"\\<gamma> \\<le> \\<beta>\" \"Ord \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<alpha> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<alpha> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain \\<gamma> where \\<gamma>: \"\\<alpha>+\\<gamma> = \\<beta>\" \"\\<gamma> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<alpha> + \\<gamma> = \\<beta>;\n         \\<gamma> \\<le> \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_le_cancel_left add_le_left assms vle_def vle_iff_le_Ord)"], ["proof (state)\nthis:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<alpha> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>", "have \"Ord \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. Ord \\<gamma>", "using Ord_def Transset_def \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  Transset ?x \\<equiv> \\<forall>y\\<in>elts ?x. y \\<le> ?x\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. Ord \\<gamma>", "by force"], ["proof (state)\nthis:\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<alpha> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with \\<gamma> that"], ["proof (chain)\npicking this:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  \\<lbrakk>\\<alpha> + ?\\<gamma> = \\<beta>; ?\\<gamma> \\<le> \\<beta>;\n   Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Ord \\<gamma>", "show thesis"], ["proof (prove)\nusing this:\n  \\<alpha> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  \\<lbrakk>\\<alpha> + ?\\<gamma> = \\<beta>; ?\\<gamma> \\<le> \\<beta>;\n   Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_Ord_le:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"Ord \\<beta>\" shows \"\\<alpha>+\\<beta> \\<le> \\<beta>+\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "proof (cases \"\\<beta> \\<in> elts \\<omega>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta> \\<in> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>\n 2. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "case True"], ["proof (state)\nthis:\n  \\<beta> \\<in> elts \\<omega>\n\ngoal (2 subgoals):\n 1. \\<beta> \\<in> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>\n 2. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "with assms"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts \\<omega>\n  Ord \\<beta>\n  \\<beta> \\<in> elts \\<omega>", "have \"\\<alpha>+\\<beta> = \\<beta>+\\<alpha>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n  Ord \\<beta>\n  \\<beta> \\<in> elts \\<omega>\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = \\<beta> + \\<alpha>", "by (auto simp: elts_\\<omega> add.commute ord_of_nat_add [symmetric])"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = \\<beta> + \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<beta> \\<in> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>\n 2. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> + \\<beta> = \\<beta> + \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> + \\<beta> = \\<beta> + \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "by simp"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "case False"], ["proof (state)\nthis:\n  \\<beta> \\<notin> elts \\<omega>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<notin> elts \\<omega>", "have \"\\<omega> \\<le> \\<beta>\""], ["proof (prove)\nusing this:\n  \\<beta> \\<notin> elts \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> \\<beta>", "using Ord_linear2 Ord_mem_iff_lt \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  \\<beta> \\<notin> elts \\<omega>\n  \\<lbrakk>Ord ?k; Ord ?l; ?k < ?l \\<Longrightarrow> ?thesis;\n   ?l \\<le> ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<le> \\<beta>", "obtain \\<gamma> where \"\\<omega>+\\<gamma> = \\<beta>\" \"\\<gamma> \\<le> \\<beta>\" \"Ord \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<omega> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<omega> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Ord \\<beta>\\<close> le_Ord_diff"], ["proof (prove)\nusing this:\n  \\<omega> \\<le> \\<beta>\n  Ord \\<beta>\n  \\<lbrakk>?\\<alpha> \\<le> ?\\<beta>; Ord ?\\<alpha>; Ord ?\\<beta>;\n   \\<And>\\<gamma>.\n      \\<lbrakk>?\\<alpha> + \\<gamma> = ?\\<beta>; \\<gamma> \\<le> ?\\<beta>;\n       Ord \\<gamma>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>\\<omega> + \\<gamma> = \\<beta>; \\<gamma> \\<le> \\<beta>;\n         Ord \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<omega> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<omega> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  Ord \\<gamma>", "have \"\\<alpha>+\\<beta> = \\<beta>\""], ["proof (prove)\nusing this:\n  \\<omega> + \\<gamma> = \\<beta>\n  \\<gamma> \\<le> \\<beta>\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = \\<beta>", "by (metis add.assoc assms(1) plus_\\<omega>_equals_\\<omega>)"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<notin> elts \\<omega> \\<Longrightarrow>\n    \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> + \\<beta> = \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> + \\<beta> = \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>", "by simp"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> \\<le> \\<beta> + \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_right_mono: \"\\<lbrakk>\\<alpha> \\<le> \\<beta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> \\<le> \\<beta>+\\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> \\<le> \\<beta>; Ord \\<alpha>; Ord \\<beta>;\n     Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> + \\<gamma> \\<le> \\<beta> + \\<gamma>", "by (metis add_le_cancel_left add.assoc add_le_left le_Ord_diff)"], ["", "lemma add_strict_mono: \"\\<lbrakk>\\<alpha> < \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> < \\<beta>+\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> < \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>;\n     Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> + \\<gamma> < \\<beta> + \\<delta>", "by (metis order.strict_implies_order add_less_cancel_left add_right_mono le_less_trans)"], ["", "lemma add_right_strict_mono: \"\\<lbrakk>\\<alpha> \\<le> \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk> \\<Longrightarrow> \\<alpha>+\\<gamma> < \\<beta>+\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> \\<le> \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>;\n     Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> + \\<gamma> < \\<beta> + \\<delta>", "using add_strict_mono le_imp_less_or_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<alpha> < ?\\<beta>; ?\\<gamma> < ?\\<delta>; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>; Ord ?\\<delta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> + ?\\<gamma> < ?\\<beta> + ?\\<delta>\n  ?x \\<le> ?y \\<Longrightarrow> ?x < ?y \\<or> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> \\<le> \\<beta>; \\<gamma> < \\<delta>; Ord \\<alpha>;\n     Ord \\<beta>; Ord \\<gamma>; Ord \\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> + \\<gamma> < \\<beta> + \\<delta>", "by blast"], ["", "lemma Limit_add_Limit [simp]:\n  assumes \"Limit \\<mu>\" \"Ord \\<beta>\" shows \"Limit (\\<beta> + \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit (\\<beta> + \\<mu>)", "unfolding Limit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<beta> + \\<mu>) \\<and>\n    0 \\<in> elts (\\<beta> + \\<mu>) \\<and>\n    (\\<forall>y.\n        y \\<in> elts (\\<beta> + \\<mu>) \\<longrightarrow>\n        ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>))", "proof (intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord (\\<beta> + \\<mu>)\n 2. 0 \\<in> elts (\\<beta> + \\<mu>)\n 3. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "show \"Ord (\\<beta> + \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<beta> + \\<mu>)", "using Limit_def assms"], ["proof (prove)\nusing this:\n  Limit ?i \\<equiv>\n  Ord ?i \\<and>\n  0 \\<in> elts ?i \\<and>\n  (\\<forall>y.\n      y \\<in> elts ?i \\<longrightarrow> ZFC_in_HOL.succ y \\<in> elts ?i)\n  Limit \\<mu>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. Ord (\\<beta> + \\<mu>)", "by auto"], ["proof (state)\nthis:\n  Ord (\\<beta> + \\<mu>)\n\ngoal (2 subgoals):\n 1. 0 \\<in> elts (\\<beta> + \\<mu>)\n 2. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "show \"0 \\<in> elts (\\<beta> + \\<mu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> elts (\\<beta> + \\<mu>)", "using Limit_def add_le_left assms"], ["proof (prove)\nusing this:\n  Limit ?i \\<equiv>\n  Ord ?i \\<and>\n  0 \\<in> elts ?i \\<and>\n  (\\<forall>y.\n      y \\<in> elts ?i \\<longrightarrow> ZFC_in_HOL.succ y \\<in> elts ?i)\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<le> ?\\<alpha> + ?\\<beta>\n  Limit \\<mu>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. 0 \\<in> elts (\\<beta> + \\<mu>)", "by auto"], ["proof (state)\nthis:\n  0 \\<in> elts (\\<beta> + \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "fix \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "assume \"\\<gamma> \\<in> elts (\\<beta> + \\<mu>)\""], ["proof (state)\nthis:\n  \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<gamma> \\<in> elts (\\<beta> + \\<mu>)", "consider \"\\<gamma> \\<in> elts \\<beta>\" | \\<xi> where \"\\<xi> \\<in> elts \\<mu>\" \"\\<gamma> = \\<beta> + \\<xi>\""], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<gamma> \\<in> elts \\<beta> \\<Longrightarrow> thesis;\n     \\<And>\\<xi>.\n        \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using mem_plus_V_E"], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n  \\<lbrakk>?l \\<in> elts (?x + ?y);\n   ?l \\<in> elts ?x \\<Longrightarrow> ?thesis;\n   \\<And>z.\n      \\<lbrakk>z \\<in> elts ?y; ?l = ?x + z\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<gamma> \\<in> elts \\<beta> \\<Longrightarrow> thesis;\n     \\<And>\\<xi>.\n        \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<gamma> \\<in> elts \\<beta> \\<Longrightarrow> ?thesis;\n   \\<And>\\<xi>.\n      \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts (\\<beta> + \\<mu>) \\<Longrightarrow>\n       ZFC_in_HOL.succ y \\<in> elts (\\<beta> + \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<gamma> \\<in> elts \\<beta> \\<Longrightarrow> ?thesis;\n   \\<And>\\<xi>.\n      \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<gamma> \\<in> elts \\<beta> \\<Longrightarrow> ?thesis;\n   \\<And>\\<xi>.\n      \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<gamma> \\<in> elts \\<beta> \\<Longrightarrow>\n    ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n 2. \\<And>\\<xi>.\n       \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<gamma>\n                         \\<in> elts (\\<beta> + \\<mu>)", "case 1"], ["proof (state)\nthis:\n  \\<gamma> \\<in> elts \\<beta>\n\ngoal (2 subgoals):\n 1. \\<gamma> \\<in> elts \\<beta> \\<Longrightarrow>\n    ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n 2. \\<And>\\<xi>.\n       \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<gamma>\n                         \\<in> elts (\\<beta> + \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<gamma> \\<in> elts \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts \\<beta>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)", "by (metis Kirby.add_strict_mono Limit_def Ord_add Ord_in_Ord Ord_mem_iff_lt assms one_V_def succ_eq_add1)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>.\n       \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<gamma>\n                         \\<in> elts (\\<beta> + \\<mu>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>.\n       \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<gamma>\n                         \\<in> elts (\\<beta> + \\<mu>)", "case 2"], ["proof (state)\nthis:\n  \\<xi> \\<in> elts \\<mu>\n  \\<gamma> = \\<beta> + \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<xi>.\n       \\<lbrakk>\\<xi> \\<in> elts \\<mu>; \\<gamma> = \\<beta> + \\<xi>\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ \\<gamma>\n                         \\<in> elts (\\<beta> + \\<mu>)", "then"], ["proof (chain)\npicking this:\n  \\<xi> \\<in> elts \\<mu>\n  \\<gamma> = \\<beta> + \\<xi>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<xi> \\<in> elts \\<mu>\n  \\<gamma> = \\<beta> + \\<xi>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)", "by (metis Limit_def add_mem_right_cancel assms(1) plus_V_succ_right)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<gamma> \\<in> elts (\\<beta> + \\<mu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Generalised Difference\\<close>"], ["", "definition odiff where \"odiff y x \\<equiv> THE z::V. (x+z = y) \\<or> (z=0 \\<and> \\<not> x \\<unlhd> y)\""], ["", "lemma vle_imp_odiff_eq: \"x \\<unlhd> y \\<Longrightarrow> x + (odiff y x) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<unlhd> y \\<Longrightarrow> x + odiff y x = y", "by (auto simp: vle_def odiff_def)"], ["", "lemma not_vle_imp_odiff_0: \"\\<not> x \\<unlhd> y \\<Longrightarrow> (odiff y x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x \\<unlhd> y \\<Longrightarrow> odiff y x = 0", "by (auto simp: vle_def odiff_def)"], ["", "lemma Ord_odiff_eq:\n  assumes \"\\<alpha> \\<le> \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n  shows \"\\<alpha> + odiff \\<beta> \\<alpha> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + odiff \\<beta> \\<alpha> = \\<beta>", "by (simp add: assms vle_iff_le_Ord vle_imp_odiff_eq)"], ["", "lemma Ord_odiff:\n  assumes \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"Ord (odiff \\<beta> \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (odiff \\<beta> \\<alpha>)", "proof (cases \"\\<alpha> \\<unlhd> \\<beta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow> Ord (odiff \\<beta> \\<alpha>)\n 2. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    Ord (odiff \\<beta> \\<alpha>)", "case True"], ["proof (state)\nthis:\n  \\<alpha> \\<unlhd> \\<beta>\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow> Ord (odiff \\<beta> \\<alpha>)\n 2. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    Ord (odiff \\<beta> \\<alpha>)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<unlhd> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. Ord (odiff \\<beta> \\<alpha>)", "by (metis add_right_cancel assms le_Ord_diff vle1 vle_imp_odiff_eq)"], ["proof (state)\nthis:\n  Ord (odiff \\<beta> \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    Ord (odiff \\<beta> \\<alpha>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    Ord (odiff \\<beta> \\<alpha>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    Ord (odiff \\<beta> \\<alpha>)", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. Ord (odiff \\<beta> \\<alpha>)", "by (simp add: odiff_def vle_def)"], ["proof (state)\nthis:\n  Ord (odiff \\<beta> \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_odiff_le:\n  assumes  \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"odiff \\<beta> \\<alpha> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff \\<beta> \\<alpha> \\<le> \\<beta>", "proof (cases \"\\<alpha> \\<unlhd> \\<beta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>\n 2. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>", "case True"], ["proof (state)\nthis:\n  \\<alpha> \\<unlhd> \\<beta>\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>\n 2. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<unlhd> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. odiff \\<beta> \\<alpha> \\<le> \\<beta>", "by (metis add_right_cancel assms le_Ord_diff vle1 vle_imp_odiff_eq)"], ["proof (state)\nthis:\n  odiff \\<beta> \\<alpha> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>", "case False"], ["proof (state)\nthis:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> \\<unlhd> \\<beta> \\<Longrightarrow>\n    odiff \\<beta> \\<alpha> \\<le> \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<alpha> \\<unlhd> \\<beta>\n\ngoal (1 subgoal):\n 1. odiff \\<beta> \\<alpha> \\<le> \\<beta>", "by (simp add: odiff_def vle_def)"], ["proof (state)\nthis:\n  odiff \\<beta> \\<alpha> \\<le> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odiff_0_right [simp]: \"odiff x 0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff x 0 = x", "by (metis add.left_neutral vle_def vle_imp_odiff_eq)"], ["", "lemma odiff_succ: \"y \\<unlhd> x \\<Longrightarrow> odiff (succ x) y = succ (odiff x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<unlhd> x \\<Longrightarrow>\n    odiff (ZFC_in_HOL.succ x) y = ZFC_in_HOL.succ (odiff x y)", "unfolding odiff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<unlhd> x \\<Longrightarrow>\n    (THE z.\n        y + z = ZFC_in_HOL.succ x \\<or>\n        z = 0 \\<and> \\<not> y \\<unlhd> ZFC_in_HOL.succ x) =\n    ZFC_in_HOL.succ\n     (THE z. y + z = x \\<or> z = 0 \\<and> \\<not> y \\<unlhd> x)", "by (metis add_right_cancel odiff_def plus_V_succ_right vle_def vle_imp_odiff_eq)"], ["", "lemma odiff_eq_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z = y \\<longleftrightarrow> x = z + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<unlhd> x \\<Longrightarrow> (odiff x z = y) = (x = z + y)", "by (auto simp: odiff_def vle_def)"], ["", "lemma odiff_le_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> y \\<longleftrightarrow> x \\<le> z + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<unlhd> x \\<Longrightarrow> (odiff x z \\<le> y) = (x \\<le> z + y)", "by (auto simp: odiff_def vle_def)"], ["", "lemma odiff_less_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z < y \\<longleftrightarrow> x < z + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<unlhd> x \\<Longrightarrow> (odiff x z < y) = (x < z + y)", "by (auto simp: odiff_def vle_def)"], ["", "lemma odiff_ge_iff: \"z \\<unlhd> x \\<Longrightarrow> odiff x z \\<ge> y \\<longleftrightarrow> x \\<ge> z + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<unlhd> x \\<Longrightarrow> (y \\<le> odiff x z) = (z + y \\<le> x)", "by (auto simp: odiff_def vle_def)"], ["", "lemma Ord_odiff_le_iff: \"\\<lbrakk>\\<alpha> \\<le> x; Ord x; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> \\<le> y \\<longleftrightarrow> x \\<le> \\<alpha> + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> \\<le> x; Ord x; Ord \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> (odiff x \\<alpha> \\<le> y) = (x \\<le> \\<alpha> + y)", "by (simp add: odiff_le_iff vle_iff_le_Ord)"], ["", "lemma odiff_le_odiff:\n  assumes \"x \\<unlhd> y\" shows \"odiff x z \\<le> odiff y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff x z \\<le> odiff y z", "proof (cases \"z \\<unlhd> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z\n 2. \\<not> z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z", "case True"], ["proof (state)\nthis:\n  z \\<unlhd> x\n\ngoal (2 subgoals):\n 1. z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z\n 2. \\<not> z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z", "then"], ["proof (chain)\npicking this:\n  z \\<unlhd> x", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<unlhd> x\n\ngoal (1 subgoal):\n 1. odiff x z \\<le> odiff y z", "using assms odiff_le_iff vle1 vle_imp_odiff_eq vle_trans"], ["proof (prove)\nusing this:\n  z \\<unlhd> x\n  x \\<unlhd> y\n  ?z \\<unlhd> ?x \\<Longrightarrow>\n  (odiff ?x ?z \\<le> ?y) = (?x \\<le> ?z + ?y)\n  ?x \\<unlhd> ?y \\<Longrightarrow> ?x \\<le> ?y\n  ?x \\<unlhd> ?y \\<Longrightarrow> ?x + odiff ?y ?x = ?y\n  \\<lbrakk>?x \\<unlhd> ?y; ?y \\<unlhd> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<unlhd> ?z\n\ngoal (1 subgoal):\n 1. odiff x z \\<le> odiff y z", "by presburger"], ["proof (state)\nthis:\n  odiff x z \\<le> odiff y z\n\ngoal (1 subgoal):\n 1. \\<not> z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z", "case False"], ["proof (state)\nthis:\n  \\<not> z \\<unlhd> x\n\ngoal (1 subgoal):\n 1. \\<not> z \\<unlhd> x \\<Longrightarrow> odiff x z \\<le> odiff y z", "then"], ["proof (chain)\npicking this:\n  \\<not> z \\<unlhd> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> z \\<unlhd> x\n\ngoal (1 subgoal):\n 1. odiff x z \\<le> odiff y z", "by (simp add: not_vle_imp_odiff_0)"], ["proof (state)\nthis:\n  odiff x z \\<le> odiff y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_odiff_le_odiff: \"\\<lbrakk>x \\<le> y; Ord x; Ord y\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> \\<le> odiff y \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; Ord x; Ord y\\<rbrakk>\n    \\<Longrightarrow> odiff x \\<alpha> \\<le> odiff y \\<alpha>", "by (simp add: odiff_le_odiff vle_iff_le_Ord)"], ["", "lemma Ord_odiff_less_odiff: \"\\<lbrakk>\\<alpha> \\<le> x; x < y; Ord x; Ord y; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> odiff x \\<alpha> < odiff y \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> \\<le> x; x < y; Ord x; Ord y; Ord \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> odiff x \\<alpha> < odiff y \\<alpha>", "by (metis Ord_odiff_eq Ord_odiff_le_odiff dual_order.strict_trans less_V_def)"], ["", "lemma Ord_odiff_less_imp_less: \"\\<lbrakk>odiff x \\<alpha> < odiff y \\<alpha>; Ord x; Ord y\\<rbrakk> \\<Longrightarrow> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>odiff x \\<alpha> < odiff y \\<alpha>; Ord x; Ord y\\<rbrakk>\n    \\<Longrightarrow> x < y", "by (meson Ord_linear2 leD odiff_le_odiff vle_iff_le_Ord)"], ["", "lemma odiff_add_cancel [simp]: \"odiff (x + y) x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff (x + y) x = y", "by (simp add: odiff_eq_iff vle_def)"], ["", "lemma odiff_add_cancel_0 [simp]: \"odiff x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff x x = 0", "by (simp add: odiff_eq_iff)"], ["", "lemma odiff_add_cancel_both [simp]: \"odiff (x + y) (x + z) = odiff y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odiff (x + y) (x + z) = odiff y z", "by (simp add: add.assoc odiff_def vle_def)"], ["", "subsection \\<open>Generalised Multiplication\\<close>"], ["", "text \\<open>Credited to Dana Scott\\<close>"], ["", "instantiation V :: times\nbegin"], ["", "text\\<open>This definition is credited to Tarski\\<close>"], ["", "definition times_V :: \"V \\<Rightarrow> V \\<Rightarrow> V\"\n  where \"times_V x \\<equiv> transrec (\\<lambda>f y. \\<Squnion> ((\\<lambda>u. lift (f u) x) ` elts y))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, times_class)", ".."], ["", "end"], ["", "lemma mult: \"x * y = (SUP u\\<in>elts y. lift (x * u) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = (SUP u\\<in>elts y. lift (x * u) x)", "unfolding times_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec (\\<lambda>f y. SUP u\\<in>elts y. lift (f u) x) y =\n    (SUP u\\<in>elts y.\n        lift (transrec (\\<lambda>f y. SUP u\\<in>elts y. lift (f u) x) u) x)", "by (subst transrec) (force simp:)"], ["", "lemma elts_multE:\n  assumes \"z \\<in> elts (x * y)\" \n  obtains u v where \"u \\<in> elts x\" \"v \\<in> elts y\" \"z = x*v + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> elts x; v \\<in> elts y; z = x * v + u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mult [of x y] lift_def assms"], ["proof (prove)\nusing this:\n  x * y = (SUP u\\<in>elts y. lift (x * u) x)\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n  z \\<in> elts (x * y)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> elts x; v \\<in> elts y; z = x * v + u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "text \\<open>Lemma 4.2\\<close>"], ["", "lemma mult_zero_right [simp]:\n  fixes x::V shows \"x * 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 0 = 0", "by (metis ZFC_in_HOL.Sup_empty elts_0 image_empty mult)"], ["", "lemma mult_insert: \"x * (vinsert y z) = x*z \\<squnion> lift (x*y) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * vinsert y z = x * z \\<squnion> lift (x * y) x", "by (metis (no_types, lifting) elts_vinsert image_insert replacement small_elts sup_commute mult Sup_V_insert)"], ["", "lemma mult_succ: \"x * succ y = x*y + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * ZFC_in_HOL.succ y = x * y + x", "by (simp add: mult_insert plus_eq_lift succ_def)"], ["", "lemma ord_of_nat_mult: \"ord_of_nat (m*n) = ord_of_nat m * ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. ord_of_nat (m * 0) = ord_of_nat m * ord_of_nat 0\n 2. \\<And>n.\n       ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n \\<Longrightarrow>\n       ord_of_nat (m * Suc n) = ord_of_nat m * ord_of_nat (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n\n\ngoal (2 subgoals):\n 1. ord_of_nat (m * 0) = ord_of_nat m * ord_of_nat 0\n 2. \\<And>n.\n       ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n \\<Longrightarrow>\n       ord_of_nat (m * Suc n) = ord_of_nat m * ord_of_nat (Suc n)", "then"], ["proof (chain)\npicking this:\n  ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n", "show ?case"], ["proof (prove)\nusing this:\n  ord_of_nat (m * n) = ord_of_nat m * ord_of_nat n\n\ngoal (1 subgoal):\n 1. ord_of_nat (m * Suc n) = ord_of_nat m * ord_of_nat (Suc n)", "by (simp add: add.commute [of m]) (simp add: ord_of_nat_add mult_succ)"], ["proof (state)\nthis:\n  ord_of_nat (m * Suc n) = ord_of_nat m * ord_of_nat (Suc n)\n\ngoal (1 subgoal):\n 1. ord_of_nat (m * 0) = ord_of_nat m * ord_of_nat 0", "qed auto"], ["", "lemma omega_closed_mult [intro]:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" \"\\<beta> \\<in> elts \\<omega>\" shows \"\\<alpha>*\\<beta> \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> \\<in> elts \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> \\<in> elts \\<omega>", "obtain m n where \"\\<alpha> = ord_of_nat m\" \"\\<beta> = ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<alpha> = ord_of_nat m; \\<beta> = ord_of_nat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms elts_\\<omega>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n  \\<beta> \\<in> elts \\<omega>\n  elts \\<omega> = {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n}\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<alpha> = ord_of_nat m; \\<beta> = ord_of_nat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n", "have \"\\<alpha>*\\<beta> = ord_of_nat (m*n)\""], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat m\n  \\<beta> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> = ord_of_nat (m * n)", "by (simp add: ord_of_nat_mult)"], ["proof (state)\nthis:\n  \\<alpha> * \\<beta> = ord_of_nat (m * n)\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> * \\<beta> = ord_of_nat (m * n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> * \\<beta> = ord_of_nat (m * n)\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<beta> \\<in> elts \\<omega>", "by (simp add: \\<omega>_def)"], ["proof (state)\nthis:\n  \\<alpha> * \\<beta> \\<in> elts \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_imp_le_mult: \"0 \\<in> elts y \\<Longrightarrow> x \\<le> x*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> elts y \\<Longrightarrow> x \\<le> x * y", "by (auto simp: mult [of x y])"], ["", "subsubsection\\<open>Proposition 4.3\\<close>"], ["", "lemma mult_zero_left [simp]:\n  fixes x::V shows \"0 * x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * x = 0", "proof (induction x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 0 * y = 0) \\<Longrightarrow>\n       0 * x = 0", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> 0 * ?y = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 0 * y = 0) \\<Longrightarrow>\n       0 * x = 0", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts x \\<Longrightarrow> 0 * ?y = 0", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> 0 * ?y = 0\n\ngoal (1 subgoal):\n 1. 0 * x = 0", "by (subst mult) auto"], ["proof (state)\nthis:\n  0 * x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_sup_distrib:\n  fixes x::V shows \"x * (y \\<squnion> z) = x*y \\<squnion> x*z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<squnion> z) = x * y \\<squnion> x * z", "unfolding mult [of x \"y \\<squnion> z\"] mult [of x y] mult [of x z]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts (y \\<squnion> z). lift (x * u) x) =\n    (SUP u\\<in>elts y. lift (x * u) x) \\<squnion>\n    (SUP u\\<in>elts z. lift (x * u) x)", "by (simp add: Sup_Un_distrib image_Un)"], ["", "lemma mult_Sup_distrib: \"small Y \\<Longrightarrow> x * (\\<Squnion>Y) = \\<Squnion> ((*) x ` Y)\" for Y:: \"V set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small Y \\<Longrightarrow> x * \\<Squnion> Y = \\<Squnion> ((*) x ` Y)", "unfolding mult [of x \"\\<Squnion>Y\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. small Y \\<Longrightarrow>\n    (SUP u\\<in>elts (\\<Squnion> Y). lift (x * u) x) = \\<Squnion> ((*) x ` Y)", "by (simp add: cSUP_UNION) (metis mult)"], ["", "lemma mult_lift_imp_distrib: \"x * (lift y z) = lift (x*y) (x*z) \\<Longrightarrow> x * (y+z) = x*y + x*z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * lift y z = lift (x * y) (x * z) \\<Longrightarrow>\n    x * (y + z) = x * y + x * z", "by (simp add: mult_sup_distrib plus_eq_lift)"], ["", "lemma mult_lift: \"x * (lift y z) = lift (x*y) (x*z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * lift y z = lift (x * y) (x * z)", "proof (induction z rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "case (step z)"], ["proof (state)\nthis:\n  ?y \\<in> elts z \\<Longrightarrow> x * lift y ?y = lift (x * y) (x * ?y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"x * lift y z = (SUP u\\<in>elts (lift y z). lift (x * u) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * lift y z = (SUP u\\<in>elts (lift y z). lift (x * u) x)", "using mult"], ["proof (prove)\nusing this:\n  ?x * ?y = (SUP u\\<in>elts ?y. lift (?x * u) ?x)\n\ngoal (1 subgoal):\n 1. x * lift y z = (SUP u\\<in>elts (lift y z). lift (x * u) x)", "by blast"], ["proof (state)\nthis:\n  x * lift y z = (SUP u\\<in>elts (lift y z). lift (x * u) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "also"], ["proof (state)\nthis:\n  x * lift y z = (SUP u\\<in>elts (lift y z). lift (x * u) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"\\<dots> = (SUP v\\<in>elts z. lift (x * (y + v)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts (lift y z). lift (x * u) x) =\n    (SUP v\\<in>elts z. lift (x * (y + v)) x)", "using lift_def"], ["proof (prove)\nusing this:\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts (lift y z). lift (x * u) x) =\n    (SUP v\\<in>elts z. lift (x * (y + v)) x)", "by auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts (lift y z). lift (x * u) x) =\n  (SUP v\\<in>elts z. lift (x * (y + v)) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts (lift y z). lift (x * u) x) =\n  (SUP v\\<in>elts z. lift (x * (y + v)) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"\\<dots> = (SUP v\\<in>elts z. lift (x * y + x * v) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP v\\<in>elts z. lift (x * (y + v)) x) =\n    (SUP v\\<in>elts z. lift (x * y + x * v) x)", "using mult_lift_imp_distrib step.IH"], ["proof (prove)\nusing this:\n  ?x * lift ?y ?z = lift (?x * ?y) (?x * ?z) \\<Longrightarrow>\n  ?x * (?y + ?z) = ?x * ?y + ?x * ?z\n  ?y \\<in> elts z \\<Longrightarrow> x * lift y ?y = lift (x * y) (x * ?y)\n\ngoal (1 subgoal):\n 1. (SUP v\\<in>elts z. lift (x * (y + v)) x) =\n    (SUP v\\<in>elts z. lift (x * y + x * v) x)", "by auto"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * (y + v)) x) =\n  (SUP v\\<in>elts z. lift (x * y + x * v) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "also"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * (y + v)) x) =\n  (SUP v\\<in>elts z. lift (x * y + x * v) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"\\<dots> = (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP v\\<in>elts z. lift (x * y + x * v) x) =\n    (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x))", "by (simp add: lift_lift)"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * y + x * v) x) =\n  (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "also"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * y + x * v) x) =\n  (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"\\<dots> = lift (x * y) (SUP v\\<in>elts z. lift (x * v) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x)) =\n    lift (x * y) (SUP v\\<in>elts z. lift (x * v) x)", "by (simp add: image_image lift_Sup_distrib)"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x)) =\n  lift (x * y) (SUP v\\<in>elts z. lift (x * v) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "also"], ["proof (state)\nthis:\n  (SUP v\\<in>elts z. lift (x * y) (lift (x * v) x)) =\n  lift (x * y) (SUP v\\<in>elts z. lift (x * v) x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "have \"\\<dots> = lift (x*y) (x*z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (x * y) (SUP v\\<in>elts z. lift (x * v) x) = lift (x * y) (x * z)", "by (metis mult)"], ["proof (state)\nthis:\n  lift (x * y) (SUP v\\<in>elts z. lift (x * v) x) = lift (x * y) (x * z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * lift y ya = lift (x * y) (x * ya)) \\<Longrightarrow>\n       x * lift y xa = lift (x * y) (x * xa)", "finally"], ["proof (chain)\npicking this:\n  x * lift y z = lift (x * y) (x * z)", "show ?case"], ["proof (prove)\nusing this:\n  x * lift y z = lift (x * y) (x * z)\n\ngoal (1 subgoal):\n 1. x * lift y z = lift (x * y) (x * z)", "."], ["proof (state)\nthis:\n  x * lift y z = lift (x * y) (x * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_Limit: \"Limit \\<gamma> \\<Longrightarrow> x * \\<gamma> = \\<Squnion> ((*) x ` elts \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<gamma> \\<Longrightarrow>\n    x * \\<gamma> = \\<Squnion> ((*) x ` elts \\<gamma>)", "by (metis Limit_eq_Sup_self mult_Sup_distrib small_elts)"], ["", "lemma add_mult_distrib: \"x * (y+z) = x*y + x*z\" for x::V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (simp add: mult_lift mult_lift_imp_distrib)"], ["", "instantiation V :: monoid_mult\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(V, monoid_mult_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a. a * 1 = a", "show \"1 * x = x\" for x :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * x = x", "proof (induction x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 1 * y = y) \\<Longrightarrow>\n       1 * x = x", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> 1 * ?y = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> 1 * y = y) \\<Longrightarrow>\n       1 * x = x", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts x \\<Longrightarrow> 1 * ?y = ?y", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> 1 * ?y = ?y\n\ngoal (1 subgoal):\n 1. 1 * x = x", "by (subst mult) auto"], ["proof (state)\nthis:\n  1 * x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 * ?x = ?x\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a. a * 1 = a", "show \"x * 1 = x\" for x :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * 1 = x", "by (subst mult) auto"], ["proof (state)\nthis:\n  ?x * 1 = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a * b * c = a * (b * c)", "show \"(x * y) * z = x * (y * z)\" for x y z::V"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "proof (induction z rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "case (step z)"], ["proof (state)\nthis:\n  ?y \\<in> elts z \\<Longrightarrow> x * y * ?y = x * (y * ?y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "have \"(x * y) * z = (SUP u\\<in>elts z. lift (x * y * u) (x * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = (SUP u\\<in>elts z. lift (x * y * u) (x * y))", "using mult"], ["proof (prove)\nusing this:\n  ?x * ?y = (SUP u\\<in>elts ?y. lift (?x * u) ?x)\n\ngoal (1 subgoal):\n 1. x * y * z = (SUP u\\<in>elts z. lift (x * y * u) (x * y))", "by blast"], ["proof (state)\nthis:\n  x * y * z = (SUP u\\<in>elts z. lift (x * y * u) (x * y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "also"], ["proof (state)\nthis:\n  x * y * z = (SUP u\\<in>elts z. lift (x * y * u) (x * y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "have \"\\<dots> = (SUP u\\<in>elts z. lift (x * (y * u)) (x * y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts z. lift (x * y * u) (x * y)) =\n    (SUP u\\<in>elts z. lift (x * (y * u)) (x * y))", "using step.IH"], ["proof (prove)\nusing this:\n  ?y \\<in> elts z \\<Longrightarrow> x * y * ?y = x * (y * ?y)\n\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts z. lift (x * y * u) (x * y)) =\n    (SUP u\\<in>elts z. lift (x * (y * u)) (x * y))", "by auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. lift (x * y * u) (x * y)) =\n  (SUP u\\<in>elts z. lift (x * (y * u)) (x * y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. lift (x * y * u) (x * y)) =\n  (SUP u\\<in>elts z. lift (x * (y * u)) (x * y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "have \"\\<dots> = (SUP u\\<in>elts z. x * lift (y * u) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts z. lift (x * (y * u)) (x * y)) =\n    (SUP u\\<in>elts z. x * lift (y * u) y)", "using mult_lift"], ["proof (prove)\nusing this:\n  ?x * lift ?y ?z = lift (?x * ?y) (?x * ?z)\n\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts z. lift (x * (y * u)) (x * y)) =\n    (SUP u\\<in>elts z. x * lift (y * u) y)", "by auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. lift (x * (y * u)) (x * y)) =\n  (SUP u\\<in>elts z. x * lift (y * u) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. lift (x * (y * u)) (x * y)) =\n  (SUP u\\<in>elts z. x * lift (y * u) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "have \"\\<dots> = x * (SUP u\\<in>elts z. lift (y * u) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts z. x * lift (y * u) y) =\n    x * (SUP u\\<in>elts z. lift (y * u) y)", "by (simp add: image_image mult_Sup_distrib)"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. x * lift (y * u) y) =\n  x * (SUP u\\<in>elts z. lift (y * u) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts z. x * lift (y * u) y) =\n  x * (SUP u\\<in>elts z. lift (y * u) y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "have \"\\<dots> = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (SUP u\\<in>elts z. lift (y * u) y) = x * (y * z)", "by (metis mult)"], ["proof (state)\nthis:\n  x * (SUP u\\<in>elts z. lift (y * u) y) = x * (y * z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>ya.\n           ya \\<in> elts xa \\<Longrightarrow>\n           x * y * ya = x * (y * ya)) \\<Longrightarrow>\n       x * y * xa = x * (y * xa)", "finally"], ["proof (chain)\npicking this:\n  x * y * z = x * (y * z)", "show ?case"], ["proof (prove)\nusing this:\n  x * y * z = x * (y * z)\n\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "."], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x * ?y * ?z = ?x * (?y * ?z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma le_mult:\n  assumes \"Ord \\<beta>\" \"\\<beta> \\<noteq> 0\" shows \"\\<alpha> \\<le> \\<alpha> * \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<alpha> * \\<beta>", "using assms"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<alpha> * \\<beta>", "proof (induction rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>';\n        \\<alpha>' \\<noteq> 0 \\<Longrightarrow>\n        \\<alpha> \\<le> \\<alpha> * \\<alpha>';\n        ZFC_in_HOL.succ \\<alpha>' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * ZFC_in_HOL.succ \\<alpha>'\n 3. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "case (succ \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<alpha>\n  ZFC_in_HOL.succ \\<alpha> \\<noteq> 0\n\ngoal (3 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Ord \\<alpha>';\n        \\<alpha>' \\<noteq> 0 \\<Longrightarrow>\n        \\<alpha> \\<le> \\<alpha> * \\<alpha>';\n        ZFC_in_HOL.succ \\<alpha>' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * ZFC_in_HOL.succ \\<alpha>'\n 3. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<alpha>\n  ZFC_in_HOL.succ \\<alpha> \\<noteq> 0", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<alpha>\n  ZFC_in_HOL.succ \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<alpha> * ZFC_in_HOL.succ \\<alpha>", "using mult_insert succ_def"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<alpha>\n  ZFC_in_HOL.succ \\<alpha> \\<noteq> 0\n  ?x * vinsert ?y ?z = ?x * ?z \\<squnion> lift (?x * ?y) ?x\n  ZFC_in_HOL.succ ?x \\<equiv> vinsert ?x ?x\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<alpha> * ZFC_in_HOL.succ \\<alpha>", "by fastforce"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<alpha> * ZFC_in_HOL.succ \\<alpha>\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "case (Limit \\<mu>)"], ["proof (state)\nthis:\n  Limit \\<mu>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<mu>; ?\\<xi> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * ?\\<xi>\n  (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "have \"\\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>", "using Limit.hyps Limit_def one_V_def"], ["proof (prove)\nusing this:\n  Limit \\<mu>\n  Limit ?i \\<equiv>\n  Ord ?i \\<and>\n  0 \\<in> elts ?i \\<and>\n  (\\<forall>y.\n      y \\<in> elts ?i \\<longrightarrow> ZFC_in_HOL.succ y \\<in> elts ?i)\n  1 \\<equiv> ZFC_in_HOL.succ 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>", "by (metis imageI mult.right_neutral)"], ["proof (state)\nthis:\n  \\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>", "have \"\\<alpha> \\<le> \\<Squnion> ((*) \\<alpha> ` elts \\<mu>)\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> (*) \\<alpha> ` elts \\<mu>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<Squnion> ((*) \\<alpha> ` elts \\<mu>)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<Squnion> ((*) \\<alpha> ` elts \\<mu>)\n\ngoal (2 subgoals):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0\n 2. \\<And>\\<alpha>'.\n       \\<lbrakk>Limit \\<alpha>';\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>'; \\<xi> \\<noteq> 0\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * \\<xi>;\n        (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                         \\<le> \\<alpha> *\n                               (SUP \\<xi>\\<in>elts \\<alpha>'. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> \\<Squnion> ((*) \\<alpha> ` elts \\<mu>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> \\<Squnion> ((*) \\<alpha> ` elts \\<mu>)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<alpha> * (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)", "by (simp add: Limit.hyps mult_Limit)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<alpha> * (SUP \\<xi>\\<in>elts \\<mu>. \\<xi>)\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> 0 \\<Longrightarrow> \\<alpha> \\<le> \\<alpha> * 0", "qed auto"], ["", "lemma mult_sing_1 [simp]:\n  fixes x::V shows \"x * set{1} = lift x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * set {1} = lift x x", "by (subst mult) auto"], ["", "lemma mult_2_right [simp]:\n  fixes x::V shows \"x * set{0,1} = x+x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * set {0, 1} = x + x", "by (subst mult) (auto simp: Sup_V_insert plus_eq_lift)"], ["", "lemma Ord_mult [simp]: \"\\<lbrakk>Ord y; Ord x\\<rbrakk> \\<Longrightarrow> Ord (x*y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord y; Ord x\\<rbrakk> \\<Longrightarrow> Ord (x * y)", "proof (induction y rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord x \\<Longrightarrow> Ord (x * 0)\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Ord \\<alpha>; Ord x \\<Longrightarrow> Ord (x * \\<alpha>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * ZFC_in_HOL.succ \\<alpha>)\n 3. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "case 0"], ["proof (state)\nthis:\n  Ord x\n\ngoal (3 subgoals):\n 1. Ord x \\<Longrightarrow> Ord (x * 0)\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Ord \\<alpha>; Ord x \\<Longrightarrow> Ord (x * \\<alpha>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * ZFC_in_HOL.succ \\<alpha>)\n 3. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "then"], ["proof (chain)\npicking this:\n  Ord x", "show ?case"], ["proof (prove)\nusing this:\n  Ord x\n\ngoal (1 subgoal):\n 1. Ord (x * 0)", "by auto"], ["proof (state)\nthis:\n  Ord (x * 0)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Ord \\<alpha>; Ord x \\<Longrightarrow> Ord (x * \\<alpha>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Ord \\<alpha>; Ord x \\<Longrightarrow> Ord (x * \\<alpha>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "case (succ k)"], ["proof (state)\nthis:\n  Ord k\n  Ord x \\<Longrightarrow> Ord (x * k)\n  Ord x\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Ord \\<alpha>; Ord x \\<Longrightarrow> Ord (x * \\<alpha>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "then"], ["proof (chain)\npicking this:\n  Ord k\n  Ord x \\<Longrightarrow> Ord (x * k)\n  Ord x", "show ?case"], ["proof (prove)\nusing this:\n  Ord k\n  Ord x \\<Longrightarrow> Ord (x * k)\n  Ord x\n\ngoal (1 subgoal):\n 1. Ord (x * ZFC_in_HOL.succ k)", "by (simp add: mult_succ)"], ["proof (state)\nthis:\n  Ord (x * ZFC_in_HOL.succ k)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "case (Limit k)"], ["proof (state)\nthis:\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; Ord x\\<rbrakk>\n  \\<Longrightarrow> Ord (x * ?\\<xi>)\n  Ord x\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "then"], ["proof (chain)\npicking this:\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; Ord x\\<rbrakk>\n  \\<Longrightarrow> Ord (x * ?\\<xi>)\n  Ord x", "have \"Ord (x * \\<Squnion> (elts k))\""], ["proof (prove)\nusing this:\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; Ord x\\<rbrakk>\n  \\<Longrightarrow> Ord (x * ?\\<xi>)\n  Ord x\n\ngoal (1 subgoal):\n 1. Ord (x * \\<Squnion> (elts k))", "by (metis Ord_Sup imageE mult_Sup_distrib small_elts)"], ["proof (state)\nthis:\n  Ord (x * \\<Squnion> (elts k))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi>.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x\\<rbrakk>\n           \\<Longrightarrow> Ord (x * \\<xi>);\n        Ord x\\<rbrakk>\n       \\<Longrightarrow> Ord (x * (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>))", "then"], ["proof (chain)\npicking this:\n  Ord (x * \\<Squnion> (elts k))", "show ?case"], ["proof (prove)\nusing this:\n  Ord (x * \\<Squnion> (elts k))\n\ngoal (1 subgoal):\n 1. Ord (x * (SUP \\<xi>\\<in>elts k. \\<xi>))", "using Limit.hyps Limit_eq_Sup_self"], ["proof (prove)\nusing this:\n  Ord (x * \\<Squnion> (elts k))\n  Limit k\n  Limit ?i \\<Longrightarrow> \\<Squnion> (elts ?i) = ?i\n\ngoal (1 subgoal):\n 1. Ord (x * (SUP \\<xi>\\<in>elts k. \\<xi>))", "by auto"], ["proof (state)\nthis:\n  Ord (x * (SUP \\<xi>\\<in>elts k. \\<xi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Proposition 4.4-5\\<close>"], ["", "proposition rank_mult_distrib: \"rank (x*y) = rank x * rank y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (x * y) = rank x * rank y", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "case (step y)"], ["proof (state)\nthis:\n  ?y \\<in> elts y \\<Longrightarrow> rank (x * ?y) = rank x * rank ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"rank (x*y) = (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x). succ (rank y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (x * y) =\n    (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n        ZFC_in_HOL.succ (rank y))", "by (metis rank_Sup mult)"], ["proof (state)\nthis:\n  rank (x * y) =\n  (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n      ZFC_in_HOL.succ (rank y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "also"], ["proof (state)\nthis:\n  rank (x * y) =\n  (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n      ZFC_in_HOL.succ (rank y))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"\\<dots> = (SUP u\\<in>elts y. SUP r\\<in>elts x. succ (rank (x * u + r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n        ZFC_in_HOL.succ (rank y)) =\n    (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r)))", "apply (simp add: lift_def image_image image_UN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (\\<Union>xa\\<in>elts y.\n         (\\<lambda>xb. ZFC_in_HOL.succ (rank (x * xa + xb))) ` elts x) =\n    (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r)))", "apply (simp add: Sup_V_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n      ZFC_in_HOL.succ (rank y)) =\n  (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "also"], ["proof (state)\nthis:\n  (SUP y\\<in>elts (SUP u\\<in>elts y. lift (x * u) x).\n      ZFC_in_HOL.succ (rank y)) =\n  (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"\\<dots> = (SUP u\\<in>elts y. SUP r\\<in>elts x. succ (rank (x * u) + rank r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r))) =\n    (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r))", "using rank_add_distrib"], ["proof (prove)\nusing this:\n  rank (?x + ?y) = rank ?x + rank ?y\n\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r))) =\n    (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r))", "by auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r))) =\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u + r))) =\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"\\<dots> = (SUP u\\<in>elts y. SUP r\\<in>elts x. succ (rank x * rank u + rank r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r)) =\n    (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "using step arg_cong [where f = Sup]"], ["proof (prove)\nusing this:\n  ?y \\<in> elts y \\<Longrightarrow> rank (x * ?y) = rank x * rank ?y\n  ?x = ?y \\<Longrightarrow> \\<Squnion> ?x = \\<Squnion> ?y\n\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r)) =\n    (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "by auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r)) =\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank (x * u) + rank r)) =\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"\\<dots> = (SUP u\\<in>elts y. rank x * rank u + rank x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    (SUP u\\<in>elts y. rank x * rank u + rank x)", "proof (rule SUP_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. elts y = elts y\n 2. \\<And>xa.\n       xa \\<in> elts y \\<Longrightarrow>\n       (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank xa + rank r)) =\n       rank x * rank xa + rank x", "show \"(SUP r\\<in>elts x. succ (rank x * rank u + rank r)) = rank x * rank u + rank x\"\n      if \"u \\<in> elts y\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "proof (cases \"x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "have \"(SUP r\\<in>elts x. succ (rank x * rank u + rank r)) = rank x * rank u + (SUP y\\<in>elts x. succ (rank y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n    \\<le> rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n 2. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "show \"(SUP r\\<in>elts x. succ (rank x * rank u + rank r)) \\<le> rank x * rank u + (SUP y\\<in>elts x. succ (rank y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n    \\<le> rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))", "by (auto simp: Sup_le_iff simp flip: plus_V_succ_right)"], ["proof (state)\nthis:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n  \\<le> rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "have \"rank x * rank u + (SUP y\\<in>elts x. succ (rank y)) = (SUP y\\<in>elts x. rank x * rank u + succ (rank y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y)) =\n    (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))", "by (simp add: add_Sup_distrib False)"], ["proof (state)\nthis:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y)) =\n  (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))\n\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "also"], ["proof (state)\nthis:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y)) =\n  (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))\n\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "have \"\\<dots> \\<le> (SUP r\\<in>elts x. succ (rank x * rank u + rank r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "using plus_V_succ_right"], ["proof (prove)\nusing this:\n  ?x + ZFC_in_HOL.succ ?y = ZFC_in_HOL.succ (?x + ?y)\n\ngoal (1 subgoal):\n 1. (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "by auto"], ["proof (state)\nthis:\n  (SUP y\\<in>elts x. rank x * rank u + ZFC_in_HOL.succ (rank y))\n  \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "finally"], ["proof (chain)\npicking this:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n  \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "show \"rank x * rank u + (SUP y\\<in>elts x. succ (rank y)) \\<le> (SUP r\\<in>elts x. succ (rank x * rank u + rank r))\""], ["proof (prove)\nusing this:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n  \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n    \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))", "."], ["proof (state)\nthis:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n  \\<le> (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "also"], ["proof (state)\nthis:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "have \"\\<dots> = rank x * rank u + rank x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y)) =\n    rank x * rank u + rank x", "by (metis rank_Sup)"], ["proof (state)\nthis:\n  rank x * rank u + (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y)) =\n  rank x * rank u + rank x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "finally"], ["proof (chain)\npicking this:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  rank x * rank u + rank x", "show ?thesis"], ["proof (prove)\nusing this:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  rank x * rank u + rank x\n\ngoal (1 subgoal):\n 1. (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "."], ["proof (state)\nthis:\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  rank x * rank u + rank x\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow>\n    (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n    rank x * rank u + rank x", "qed auto"], ["proof (state)\nthis:\n  ?u \\<in> elts y \\<Longrightarrow>\n  (SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank ?u + rank r)) =\n  rank x * rank ?u + rank x\n\ngoal (1 subgoal):\n 1. elts y = elts y", "qed auto"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  (SUP u\\<in>elts y. rank x * rank u + rank x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y.\n      SUP r\\<in>elts x. ZFC_in_HOL.succ (rank x * rank u + rank r)) =\n  (SUP u\\<in>elts y. rank x * rank u + rank x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "have \"\\<dots> = rank x * rank y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y. rank x * rank u + rank x) = rank x * rank y", "by (simp add: rank_Sup [of y] mult_Sup_distrib mult_succ image_image)"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. rank x * rank u + rank x) = rank x * rank y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           rank (x * y) = rank x * rank y) \\<Longrightarrow>\n       rank (x * xa) = rank x * rank xa", "finally"], ["proof (chain)\npicking this:\n  rank (x * y) = rank x * rank y", "show ?case"], ["proof (prove)\nusing this:\n  rank (x * y) = rank x * rank y\n\ngoal (1 subgoal):\n 1. rank (x * y) = rank x * rank y", "."], ["proof (state)\nthis:\n  rank (x * y) = rank x * rank y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_le1:\n  fixes y::V assumes \"y \\<noteq> 0\" shows \"x \\<sqsubseteq> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x * y", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<sqsubseteq> x * y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<sqsubseteq> x * y", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "obtain r where r: \"r \\<in> elts x\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r. r \\<in> elts x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  r \\<in> elts x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. x \\<noteq> 0 \\<Longrightarrow> x \\<sqsubseteq> x * y", "from \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x * y", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> x \\<sqsubseteq> x * y;\n        xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> x * xa", "case (step y)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts y; ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> x \\<sqsubseteq> x * ?y\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> x \\<sqsubseteq> x * y;\n        xa \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> x * xa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x * y", "proof (cases \"y = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 1\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "with \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  y \\<noteq> 1", "obtain p where p: \"p \\<in> elts y\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  y \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> elts y; p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis V_equalityI elts_1 insertI1 singletonD trad_foundation)"], ["proof (state)\nthis:\n  p \\<in> elts y\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "then"], ["proof (chain)\npicking this:\n  p \\<in> elts y\n  p \\<noteq> 0", "have \"x*p + r \\<in> elts (lift (x*p) x)\""], ["proof (prove)\nusing this:\n  p \\<in> elts y\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * p + r \\<in> elts (lift (x * p) x)", "by (simp add: lift_def r)"], ["proof (state)\nthis:\n  x * p + r \\<in> elts (lift (x * p) x)\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "moreover"], ["proof (state)\nthis:\n  x * p + r \\<in> elts (lift (x * p) x)\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "have \"lift (x*p) x \\<le> x*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (x * p) x \\<le> x * y", "by (metis bdd_above_iff_small cSUP_upper2 order_refl \\<open>p \\<in> elts y\\<close> replacement small_elts mult)"], ["proof (state)\nthis:\n  lift (x * p) x \\<le> x * y\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "ultimately"], ["proof (chain)\npicking this:\n  x * p + r \\<in> elts (lift (x * p) x)\n  lift (x * p) x \\<le> x * y", "have \"x*p + r \\<in> elts (x*y)\""], ["proof (prove)\nusing this:\n  x * p + r \\<in> elts (lift (x * p) x)\n  lift (x * p) x \\<le> x * y\n\ngoal (1 subgoal):\n 1. x * p + r \\<in> elts (x * y)", "by blast"], ["proof (state)\nthis:\n  x * p + r \\<in> elts (x * y)\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "moreover"], ["proof (state)\nthis:\n  x * p + r \\<in> elts (x * y)\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "have \"x*p \\<sqsubseteq> x*p + r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * p \\<sqsubseteq> x * p + r", "by (metis TC_add' V_equalityI add.right_neutral eps_induct le_TC_refl less_TC_iff less_imp_le_TC)"], ["proof (state)\nthis:\n  x * p \\<sqsubseteq> x * p + r\n\ngoal (2 subgoals):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y\n 2. y \\<noteq> 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "ultimately"], ["proof (chain)\npicking this:\n  x * p + r \\<in> elts (x * y)\n  x * p \\<sqsubseteq> x * p + r", "show ?thesis"], ["proof (prove)\nusing this:\n  x * p + r \\<in> elts (x * y)\n  x * p \\<sqsubseteq> x * p + r\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x * y", "using step.IH [OF p] le_TC_trans less_TC_iff"], ["proof (prove)\nusing this:\n  x * p + r \\<in> elts (x * y)\n  x * p \\<sqsubseteq> x * p + r\n  x \\<sqsubseteq> x * p\n  \\<lbrakk>?x \\<sqsubseteq> ?y; ?y \\<sqsubseteq> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubseteq> ?z\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x * y", "by blast"], ["proof (state)\nthis:\n  x \\<sqsubseteq> x * y\n\ngoal (1 subgoal):\n 1. y = 1 \\<Longrightarrow> x \\<sqsubseteq> x * y", "qed auto"], ["proof (state)\nthis:\n  x \\<sqsubseteq> x * y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<sqsubseteq> x * y\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> x \\<sqsubseteq> x * y", "qed auto"], ["", "lemma mult_eq_0_iff [simp]:\n  fixes y::V shows \"x * y = 0 \\<longleftrightarrow> x=0 \\<or> y=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y = 0) = (x = 0 \\<or> y = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x * y = 0 \\<Longrightarrow> x = 0 \\<or> y = 0\n 2. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "show \"x = 0 \\<or> y = 0\" if \"x * y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0 \\<or> y = 0", "by (metis le_0 le_TC_def less_TC_imp_not_le mult_le1 that)"], ["proof (state)\nthis:\n  x * y = 0 \\<Longrightarrow> x = 0 \\<or> y = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<or> y = 0 \\<Longrightarrow> x * y = 0", "qed auto"], ["", "lemma lift_lemma:\n  assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\"  shows \"\\<not> lift (x * y) x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lift (x * y) x \\<le> x", "using assms mult_le1 [of concl: x y]"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  y \\<noteq> 0\n  y \\<noteq> 0 \\<Longrightarrow> x \\<sqsubseteq> x * y\n\ngoal (1 subgoal):\n 1. \\<not> lift (x * y) x \\<le> x", "by (auto simp: le_TC_def TC_lift less_TC_def less_TC_imp_not_le)"], ["", "lemma mult_le2:\n  fixes y::V assumes \"x \\<noteq> 0\" \"y \\<noteq> 0\" \"y \\<noteq> 1\" shows \"x \\<sqsubset> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "obtain v where v: \"v \\<in> elts y\" \"v \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts y; v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  y \\<noteq> 0\n  y \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> elts y; v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v \\<in> elts y\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "have \"x \\<noteq> x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> x * y", "using lift_lemma [of x v]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> 0; v \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> lift (x * v) x \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> x * y", "by (metis \\<open>x \\<noteq> 0\\<close> bdd_above_iff_small cSUP_upper2 order_refl replacement small_elts mult v)"], ["proof (state)\nthis:\n  x \\<noteq> x * y\n\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> x * y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> x * y\n\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "using assms mult_le1 [of y x]"], ["proof (prove)\nusing this:\n  x \\<noteq> x * y\n  x \\<noteq> 0\n  y \\<noteq> 0\n  y \\<noteq> 1\n  y \\<noteq> 0 \\<Longrightarrow> x \\<sqsubseteq> x * y\n\ngoal (1 subgoal):\n 1. x \\<sqsubset> x * y", "by (auto simp: le_TC_def)"], ["proof (state)\nthis:\n  x \\<sqsubset> x * y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elts_mult_\\<omega>E:\n  assumes \"x \\<in> elts (y * \\<omega>)\"\n  obtains n where \"n \\<noteq> 0\" \"x \\<in> elts (y * ord_of_nat n)\" \"\\<And>m. m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> 0; x \\<in> elts (y * ord_of_nat n);\n         \\<And>m.\n            m < n \\<Longrightarrow>\n            x \\<notin> elts (y * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> 0; x \\<in> elts (y * ord_of_nat n);\n         \\<And>m.\n            m < n \\<Longrightarrow>\n            x \\<notin> elts (y * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain k where k:  \"k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<noteq> 0 \\<and>\n        x \\<in> elts (y * ord_of_nat k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> elts (y * \\<omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<noteq> 0 \\<and>\n        x \\<in> elts (y * ord_of_nat k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: mult_Limit elts_\\<omega>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                0 < k \\<and>\n                x \\<in> elts (y * ord_of_nat k) \\<Longrightarrow>\n                thesis;\n     (\\<exists>xa.\n         (\\<exists>n. xa = ord_of_nat n) \\<and>\n         x \\<in> elts (y * xa)) \\<and>\n     small\n      ((*) y ` {\\<alpha>. \\<exists>n. \\<alpha> = ord_of_nat n})\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis mult_eq_0_iff elts_0 ex_in_conv ord_of_eq_0_iff that)"], ["proof (state)\nthis:\n  k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> 0; x \\<in> elts (y * ord_of_nat n);\n         \\<And>m.\n            m < n \\<Longrightarrow>\n            x \\<notin> elts (y * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define n where \"n \\<equiv> (LEAST k. k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k))\""], ["proof (state)\nthis:\n  n \\<equiv> LEAST k. k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<noteq> 0; x \\<in> elts (y * ord_of_nat n);\n         \\<And>m.\n            m < n \\<Longrightarrow>\n            x \\<notin> elts (y * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. ?n \\<noteq> 0\n 2. x \\<in> elts (y * ord_of_nat ?n)\n 3. \\<And>m. m < ?n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)", "show \"n \\<noteq> 0\" \"x \\<in> elts (y * ord_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 &&& x \\<in> elts (y * ord_of_nat n)", "unfolding n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST k. k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k)) \\<noteq>\n    0 &&&\n    x \\<in> elts\n             (y *\n              ord_of_nat\n               (LEAST k.\n                   k \\<noteq> 0 \\<and> x \\<in> elts (y * ord_of_nat k)))", "by (metis (mono_tags, lifting) LeastI_ex k)+"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  x \\<in> elts (y * ord_of_nat n)\n\ngoal (1 subgoal):\n 1. \\<And>m. m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)", "show \"\\<And>m. m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat m)", "by (metis (mono_tags, lifting) mult_eq_0_iff elts_0 empty_iff n_def not_less_Least ord_of_eq_0_iff)"], ["proof (state)\nthis:\n  ?m < n \\<Longrightarrow> x \\<notin> elts (y * ord_of_nat ?m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Theorem 4.6\\<close>"], ["", "theorem mult_eq_imp_0:\n  assumes \"a*x = a*y + b\" \"b \\<sqsubset> a\"\n  shows \"b=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 0", "proof (cases \"a=0 \\<or> x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<or> x = 0 \\<Longrightarrow> b = 0\n 2. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "case True"], ["proof (state)\nthis:\n  a = 0 \\<or> x = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<or> x = 0 \\<Longrightarrow> b = 0\n 2. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "with assms"], ["proof (chain)\npicking this:\n  a * x = a * y + b\n  b \\<sqsubset> a\n  a = 0 \\<or> x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a * x = a * y + b\n  b \\<sqsubset> a\n  a = 0 \\<or> x = 0\n\ngoal (1 subgoal):\n 1. b = 0", "by (metis add_le_cancel_left mult_eq_0_iff eq_iff le_0)"], ["proof (state)\nthis:\n  b = 0\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "case False"], ["proof (state)\nthis:\n  \\<not> (a = 0 \\<or> x = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "then"], ["proof (chain)\npicking this:\n  \\<not> (a = 0 \\<or> x = 0)", "have \"a\\<noteq>0\" \"x\\<noteq>0\""], ["proof (prove)\nusing this:\n  \\<not> (a = 0 \\<or> x = 0)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> x = 0) \\<Longrightarrow> b = 0", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0\n  x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b = 0", "proof (cases \"y=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y = 0\\<rbrakk>\n    \\<Longrightarrow> b = 0\n 2. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "case True"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y = 0\\<rbrakk>\n    \\<Longrightarrow> b = 0\n 2. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "then"], ["proof (chain)\npicking this:\n  y = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. b = 0", "using assms less_asym_TC mult_le2"], ["proof (prove)\nusing this:\n  y = 0\n  a * x = a * y + b\n  b \\<sqsubset> a\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubset> ?x\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>?x \\<noteq> 0; ?y \\<noteq> 0; ?y \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?x * ?y\n\ngoal (1 subgoal):\n 1. b = 0", "by force"], ["proof (state)\nthis:\n  b = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "have \"b=0\" if \"Ord \\<alpha>\" \"x \\<in> elts (Vset \\<alpha>)\" \"y \\<in> elts (Vset \\<alpha>)\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 0", "using that assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  x \\<in> elts (Vset \\<alpha>)\n  y \\<in> elts (Vset \\<alpha>)\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. b = 0", "proof (induction \\<alpha> arbitrary: x y b rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y b.\n       \\<lbrakk>x \\<in> elts (Vset 0); y \\<in> elts (Vset 0);\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "case 0"], ["proof (state)\nthis:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (3 subgoals):\n 1. \\<And>x y b.\n       \\<lbrakk>x \\<in> elts (Vset 0); y \\<in> elts (Vset 0);\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 3. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x = a * y + b\n  b \\<sqsubset> a", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. b = 0", "by auto"], ["proof (state)\nthis:\n  b = 0\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "case (succ k)"], ["proof (state)\nthis:\n  Ord k\n  \\<lbrakk>?x \\<in> elts (Vset k); ?y \\<in> elts (Vset k);\n   a * ?x = a * ?y + ?b; ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "define \\<Phi> where \"\\<Phi> \\<equiv> \\<lambda>x y. \\<exists>r. 0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a*x = a*y + r\""], ["proof (state)\nthis:\n  \\<Phi> \\<equiv>\n  \\<lambda>x y.\n     \\<exists>r.\n        0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * x = a * y + r\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y b.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>)); a * x = a * y + b;\n        b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "assume \"b \\<noteq> 0\""], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0", "have \"0 \\<sqsubset> b\""], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<sqsubset> b", "by (metis nonzero_less_TC)"], ["proof (state)\nthis:\n  0 \\<sqsubset> b\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<sqsubset> b", "have \"\\<Phi> x y\""], ["proof (prove)\nusing this:\n  0 \\<sqsubset> b\n\ngoal (1 subgoal):\n 1. \\<Phi> x y", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  0 \\<sqsubset> b\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * x = a * y + r", "using succ.prems"], ["proof (prove)\nusing this:\n  0 \\<sqsubset> b\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * x = a * y + r", "by blast"], ["proof (state)\nthis:\n  \\<Phi> x y\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Phi> x y", "obtain x' where \"\\<Phi> x' y\" \"x' \\<sqsubseteq> x\" and min: \"\\<And>x''. x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> x'' y\""], ["proof (prove)\nusing this:\n  \\<Phi> x y\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>\\<Phi> x' y; x' \\<sqsubseteq> x;\n         \\<And>x''.\n            x'' \\<sqsubset> x' \\<Longrightarrow>\n            \\<not> \\<Phi> x'' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_TC_minimal [of \"\\<lambda>x. \\<Phi> x y\" x]"], ["proof (prove)\nusing this:\n  \\<Phi> x y\n  \\<lbrakk>\\<Phi> x y;\n   \\<And>x.\n      \\<lbrakk>\\<Phi> x y; x \\<sqsubseteq> x;\n       \\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> \\<Phi> y y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>\\<Phi> x' y; x' \\<sqsubseteq> x;\n         \\<And>x''.\n            x'' \\<sqsubset> x' \\<Longrightarrow>\n            \\<not> \\<Phi> x'' y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Phi> x' y\n  x' \\<sqsubseteq> x\n  ?x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> ?x'' y\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Phi> x' y\n  x' \\<sqsubseteq> x\n  ?x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> ?x'' y", "obtain b' where \"0 \\<sqsubset> b'\" \"b' \\<sqsubset> a\" and eq: \"a*x' = a*y + b'\""], ["proof (prove)\nusing this:\n  \\<Phi> x' y\n  x' \\<sqsubseteq> x\n  ?x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> ?x'' y\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>0 \\<sqsubset> b'; b' \\<sqsubset> a;\n         a * x' = a * y + b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  \\<Phi> x' y\n  x' \\<sqsubseteq> x\n  ?x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> ?x'' y\n  \\<Phi> \\<equiv>\n  \\<lambda>x y.\n     \\<exists>r.\n        0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * x = a * y + r\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>0 \\<sqsubset> b'; b' \\<sqsubset> a;\n         a * x' = a * y + b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<sqsubset> b'\n  b' \\<sqsubset> a\n  a * x' = a * y + b'\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "have \"a*y \\<sqsubset> a*x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * y \\<sqsubset> a * x'", "using TC_add' \\<open>0 \\<sqsubset> b'\\<close> eq"], ["proof (prove)\nusing this:\n  (?z \\<sqsubset> ?x + ?y) =\n  (?z \\<sqsubset> ?x \\<or>\n   (\\<exists>v. v \\<sqsubset> ?y \\<and> ?z = ?x + v))\n  0 \\<sqsubset> b'\n  a * x' = a * y + b'\n\ngoal (1 subgoal):\n 1. a * y \\<sqsubset> a * x'", "by auto"], ["proof (state)\nthis:\n  a * y \\<sqsubset> a * x'\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y \\<sqsubset> a * x'", "obtain p where \"p \\<in> elts (a * x')\" \"a * y \\<sqsubseteq> p\""], ["proof (prove)\nusing this:\n  a * y \\<sqsubset> a * x'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> elts (a * x'); a * y \\<sqsubseteq> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_TC_iff"], ["proof (prove)\nusing this:\n  a * y \\<sqsubset> a * x'\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> elts (a * x'); a * y \\<sqsubseteq> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> elts (a * x')\n  a * y \\<sqsubseteq> p\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> elts (a * x')\n  a * y \\<sqsubseteq> p", "have \"p \\<notin> elts (a * y)\""], ["proof (prove)\nusing this:\n  p \\<in> elts (a * x')\n  a * y \\<sqsubseteq> p\n\ngoal (1 subgoal):\n 1. p \\<notin> elts (a * y)", "using less_TC_iff less_irrefl_TC"], ["proof (prove)\nusing this:\n  p \\<in> elts (a * x')\n  a * y \\<sqsubseteq> p\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  \\<not> ?x \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. p \\<notin> elts (a * y)", "by blast"], ["proof (state)\nthis:\n  p \\<notin> elts (a * y)\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<notin> elts (a * y)", "have \"p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')\""], ["proof (prove)\nusing this:\n  p \\<notin> elts (a * y)\n\ngoal (1 subgoal):\n 1. p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')", "by (metis \\<open>p \\<in> elts (a * x')\\<close> elts_Sup replacement small_elts mult)"], ["proof (state)\nthis:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')", "obtain u c where \"u \\<in> elts x'\" \"c \\<in> elts a\" \"p = a*u + c\""], ["proof (prove)\nusing this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')\n\ngoal (1 subgoal):\n 1. (\\<And>u c.\n        \\<lbrakk>u \\<in> elts x'; c \\<in> elts a; p = a * u + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts x')\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>u c.\n        \\<lbrakk>u \\<in> elts x'; c \\<in> elts a; p = a * u + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> elts x'\n  c \\<in> elts a\n  p = a * u + c\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  u \\<in> elts x'\n  c \\<in> elts a\n  p = a * u + c", "have \"p \\<in> elts (lift (a*y) b')\""], ["proof (prove)\nusing this:\n  u \\<in> elts x'\n  c \\<in> elts a\n  p = a * u + c\n\ngoal (1 subgoal):\n 1. p \\<in> elts (lift (a * y) b')", "using \\<open>p \\<in> elts (a * x')\\<close> \\<open>p \\<notin> elts (a * y)\\<close> eq plus_eq_lift"], ["proof (prove)\nusing this:\n  u \\<in> elts x'\n  c \\<in> elts a\n  p = a * u + c\n  p \\<in> elts (a * x')\n  p \\<notin> elts (a * y)\n  a * x' = a * y + b'\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. p \\<in> elts (lift (a * y) b')", "by auto"], ["proof (state)\nthis:\n  p \\<in> elts (lift (a * y) b')\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> elts (lift (a * y) b')", "obtain d where d: \"d \\<in> elts b'\" \"p = a*y + d\" \"p = a*u + c\""], ["proof (prove)\nusing this:\n  p \\<in> elts (lift (a * y) b')\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> elts b'; p = a * y + d; p = a * u + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p = a * u + c\\<close> \\<open>p \\<in> elts (a * x')\\<close> \\<open>p \\<notin> elts (a * y)\\<close> eq mem_plus_V_E)"], ["proof (state)\nthis:\n  d \\<in> elts b'\n  p = a * y + d\n  p = a * u + c\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "have noteq: \"a*y \\<noteq> a*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * y \\<noteq> a * u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "assume \"a*y = a*u\""], ["proof (state)\nthis:\n  a * y = a * u\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y = a * u", "have \"lift (a*y) a = lift (a*u) a\""], ["proof (prove)\nusing this:\n  a * y = a * u\n\ngoal (1 subgoal):\n 1. lift (a * y) a = lift (a * u) a", "by metis"], ["proof (state)\nthis:\n  lift (a * y) a = lift (a * u) a\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift (a * y) a = lift (a * u) a\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "have \"\\<dots> \\<le> a*x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> a * x'", "unfolding mult [of _ x']"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> (SUP u\\<in>elts x'. lift (a * u) a)", "using \\<open>u \\<in> elts x'\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> elts x'\n\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> (SUP u\\<in>elts x'. lift (a * u) a)", "by (auto intro: cSUP_upper)"], ["proof (state)\nthis:\n  lift (a * u) a \\<le> a * x'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift (a * u) a \\<le> a * x'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "have \"\\<dots> = a*y \\<squnion> lift (a*y) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x' = a * y \\<squnion> lift (a * y) b'", "by (simp add: eq plus_eq_lift)"], ["proof (state)\nthis:\n  a * x' = a * y \\<squnion> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'", "have \"lift (a*y) a \\<le> a*y \\<squnion> lift (a*y) b'\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'", "."], ["proof (state)\nthis:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'", "have \"lift (a*y) a \\<le> lift (a*y) b'\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> lift (a * y) b'", "using add_le_cancel_left less_TC_imp_not_le plus_eq_lift \\<open>b' \\<sqsubset> a\\<close>"], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) b'\n  (?x + ?y \\<le> ?x + ?z) = (?y \\<le> ?z)\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n  b' \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> lift (a * y) b'", "by auto"], ["proof (state)\nthis:\n  lift (a * y) a \\<le> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> lift (a * y) b'", "have \"a \\<le> b'\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> lift (a * y) b'\n\ngoal (1 subgoal):\n 1. a \\<le> b'", "by (simp add: le_iff_sup lift_eq_lift lift_sup_distrib)"], ["proof (state)\nthis:\n  a \\<le> b'\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<le> b'", "show False"], ["proof (prove)\nusing this:\n  a \\<le> b'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>b' \\<sqsubset> a\\<close> less_TC_imp_not_le"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b' \\<sqsubset> a\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * y \\<noteq> a * u\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "consider \"a*y \\<unlhd> a*u\" | \"a*u \\<unlhd> a*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * y \\<unlhd> a * u \\<Longrightarrow> thesis;\n     a * u \\<unlhd> a * y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using d comparable vle_comparable_def"], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  p = a * y + d\n  p = a * u + c\n  ?a + ?b = ?c + ?d \\<Longrightarrow> vle_comparable ?a ?c\n  vle_comparable ?x ?y \\<equiv> ?x \\<unlhd> ?y \\<or> ?y \\<unlhd> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * y \\<unlhd> a * u \\<Longrightarrow> thesis;\n     a * u \\<unlhd> a * y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis;\n   a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis;\n   a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis;\n   a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  a * y \\<unlhd> a * u\n\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y \\<unlhd> a * u", "obtain e where e: \"a*u = a*y + e\" \"e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a * y \\<unlhd> a * u\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>a * u = a * y + e; e \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.right_neutral noteq vle_def)"], ["proof (state)\nthis:\n  a * u = a * y + e\n  e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a * u = a * y + e\n  e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have \"e + c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + c = d", "by (metis e add_right_cancel \\<open>p = a * u + c\\<close> \\<open>p = a * y + d\\<close> add.assoc)"], ["proof (state)\nthis:\n  e + c = d\n\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "with \\<open>d \\<in> elts b'\\<close> \\<open>b' \\<sqsubset> a\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + c = d", "have \"e \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + c = d\n\ngoal (1 subgoal):\n 1. e \\<sqsubset> a", "by (meson less_TC_iff less_TC_trans vle2 vle_def)"], ["proof (state)\nthis:\n  e \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False\n 2. a * u \\<unlhd> a * y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a * u = a * y + e\n  e \\<noteq> 0\n  e \\<sqsubset> a", "show False\n            \\<comment>\\<open>contradicts minimality of @{term x'}\\<close>"], ["proof (prove)\nusing this:\n  a * u = a * y + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. False", "using min"], ["proof (prove)\nusing this:\n  a * u = a * y + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n  ?x'' \\<sqsubset> x' \\<Longrightarrow> \\<not> \\<Phi> ?x'' y\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  a * u = a * y + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n  ?x'' \\<sqsubset> x' \\<Longrightarrow>\n  \\<nexists>r.\n     0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * ?x'' = a * y + r\n\ngoal (1 subgoal):\n 1. False", "by (meson \\<open>u \\<in> elts x'\\<close> le_TC_def less_TC_iff nonzero_less_TC)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  a * u \\<unlhd> a * y\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u \\<unlhd> a * y", "obtain e where e: \"a*y = a*u + e\" \"e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a * u \\<unlhd> a * y\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>a * y = a * u + e; e \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.right_neutral noteq vle_def)"], ["proof (state)\nthis:\n  a * y = a * u + e\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a * y = a * u + e\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have \"e + d = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + d = c", "by (metis e add_right_cancel \\<open>p = a * u + c\\<close> \\<open>p = a * y + d\\<close> add.assoc)"], ["proof (state)\nthis:\n  e + d = c\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "with \\<open>d \\<in> elts b'\\<close> \\<open>b' \\<sqsubset> a\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + d = c", "have \"e \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + d = c\n\ngoal (1 subgoal):\n 1. e \\<sqsubset> a", "by (metis \\<open>c \\<in> elts a\\<close> less_TC_iff vle2 vle_def)"], ["proof (state)\nthis:\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a * y = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a", "have \"\\<Phi> y u\""], ["proof (prove)\nusing this:\n  a * y = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<Phi> y u", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  a * y = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * y = a * u + r", "using nonzero_less_TC"], ["proof (prove)\nusing this:\n  a * y = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * y = a * u + r", "by blast"], ["proof (state)\nthis:\n  \\<Phi> y u\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Phi> y u", "obtain y' where \"\\<Phi> y' u\" \"y' \\<sqsubseteq> y\" and min: \"\\<And>x''. x'' \\<sqsubset> y' \\<Longrightarrow> \\<not> \\<Phi> x'' u\""], ["proof (prove)\nusing this:\n  \\<Phi> y u\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>\\<Phi> y' u; y' \\<sqsubseteq> y;\n         \\<And>x''.\n            x'' \\<sqsubset> y' \\<Longrightarrow>\n            \\<not> \\<Phi> x'' u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_TC_minimal [of \"\\<lambda>x. \\<Phi> x u\" y]"], ["proof (prove)\nusing this:\n  \\<Phi> y u\n  \\<lbrakk>\\<Phi> y u;\n   \\<And>x.\n      \\<lbrakk>\\<Phi> x u; x \\<sqsubseteq> y;\n       \\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> \\<Phi> y u\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>\\<Phi> y' u; y' \\<sqsubseteq> y;\n         \\<And>x''.\n            x'' \\<sqsubset> y' \\<Longrightarrow>\n            \\<not> \\<Phi> x'' u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Phi> y' u\n  y' \\<sqsubseteq> y\n  ?x'' \\<sqsubset> y' \\<Longrightarrow> \\<not> \\<Phi> ?x'' u\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Phi> y' u\n  y' \\<sqsubseteq> y\n  ?x'' \\<sqsubset> y' \\<Longrightarrow> \\<not> \\<Phi> ?x'' u", "obtain b' where \"0 \\<sqsubset> b'\" \"b' \\<sqsubset> a\" and eq: \"a*y' = a*u + b'\""], ["proof (prove)\nusing this:\n  \\<Phi> y' u\n  y' \\<sqsubseteq> y\n  ?x'' \\<sqsubset> y' \\<Longrightarrow> \\<not> \\<Phi> ?x'' u\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>0 \\<sqsubset> b'; b' \\<sqsubset> a;\n         a * y' = a * u + b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  \\<Phi> y' u\n  y' \\<sqsubseteq> y\n  ?x'' \\<sqsubset> y' \\<Longrightarrow> \\<not> \\<Phi> ?x'' u\n  \\<Phi> \\<equiv>\n  \\<lambda>x y.\n     \\<exists>r.\n        0 \\<sqsubset> r \\<and> r \\<sqsubset> a \\<and> a * x = a * y + r\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>0 \\<sqsubset> b'; b' \\<sqsubset> a;\n         a * y' = a * u + b'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<sqsubset> b'\n  b' \\<sqsubset> a\n  a * y' = a * u + b'\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have u_k: \"u \\<in> elts (Vset k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "using \\<open>u \\<in> elts x'\\<close> \\<open>x' \\<sqsubseteq> x\\<close> succ Vset_succ_TC less_TC_iff less_le_TC_trans"], ["proof (prove)\nusing this:\n  u \\<in> elts x'\n  x' \\<sqsubseteq> x\n  Ord k\n  \\<lbrakk>?x \\<in> elts (Vset k); ?y \\<in> elts (Vset k);\n   a * ?x = a * ?y + ?b; ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  a * x = a * y + b\n  b \\<sqsubset> a\n  \\<lbrakk>?x \\<in> elts (Vset (ZFC_in_HOL.succ ?k));\n   ?u \\<sqsubset> ?x\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> elts (Vset ?k)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubseteq> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?z\n\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "by blast"], ["proof (state)\nthis:\n  u \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have \"a*u \\<sqsubset> a*y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * u \\<sqsubset> a * y'", "using TC_add' \\<open>0 \\<sqsubset> b'\\<close> eq"], ["proof (prove)\nusing this:\n  (?z \\<sqsubset> ?x + ?y) =\n  (?z \\<sqsubset> ?x \\<or>\n   (\\<exists>v. v \\<sqsubset> ?y \\<and> ?z = ?x + v))\n  0 \\<sqsubset> b'\n  a * y' = a * u + b'\n\ngoal (1 subgoal):\n 1. a * u \\<sqsubset> a * y'", "by auto"], ["proof (state)\nthis:\n  a * u \\<sqsubset> a * y'\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u \\<sqsubset> a * y'", "obtain p where \"p \\<in> elts (a * y')\" \"a * u \\<sqsubseteq> p\""], ["proof (prove)\nusing this:\n  a * u \\<sqsubset> a * y'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> elts (a * y'); a * u \\<sqsubseteq> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_TC_iff"], ["proof (prove)\nusing this:\n  a * u \\<sqsubset> a * y'\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> elts (a * y'); a * u \\<sqsubseteq> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> elts (a * y')\n  a * u \\<sqsubseteq> p\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> elts (a * y')\n  a * u \\<sqsubseteq> p", "have \"p \\<notin> elts (a * u)\""], ["proof (prove)\nusing this:\n  p \\<in> elts (a * y')\n  a * u \\<sqsubseteq> p\n\ngoal (1 subgoal):\n 1. p \\<notin> elts (a * u)", "using less_TC_iff less_irrefl_TC"], ["proof (prove)\nusing this:\n  p \\<in> elts (a * y')\n  a * u \\<sqsubseteq> p\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  \\<not> ?x \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. p \\<notin> elts (a * u)", "by blast"], ["proof (state)\nthis:\n  p \\<notin> elts (a * u)\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<notin> elts (a * u)", "have \"p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')\""], ["proof (prove)\nusing this:\n  p \\<notin> elts (a * u)\n\ngoal (1 subgoal):\n 1. p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')", "by (metis \\<open>p \\<in> elts (a * y')\\<close> elts_Sup replacement small_elts mult)"], ["proof (state)\nthis:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')", "obtain v c where \"v \\<in> elts y'\" \"c \\<in> elts a\" \"p = a*v + c\""], ["proof (prove)\nusing this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')\n\ngoal (1 subgoal):\n 1. (\\<And>v c.\n        \\<lbrakk>v \\<in> elts y'; c \\<in> elts a; p = a * v + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  p \\<in> \\<Union> (elts ` (\\<lambda>v. lift (a * v) a) ` elts y')\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>v c.\n        \\<lbrakk>v \\<in> elts y'; c \\<in> elts a; p = a * v + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> elts y'\n  c \\<in> elts a\n  p = a * v + c\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts y'\n  c \\<in> elts a\n  p = a * v + c", "have \"p \\<in> elts (lift (a*u) b')\""], ["proof (prove)\nusing this:\n  v \\<in> elts y'\n  c \\<in> elts a\n  p = a * v + c\n\ngoal (1 subgoal):\n 1. p \\<in> elts (lift (a * u) b')", "using \\<open>p \\<in> elts (a * y')\\<close> \\<open>p \\<notin> elts (a * u)\\<close> eq plus_eq_lift"], ["proof (prove)\nusing this:\n  v \\<in> elts y'\n  c \\<in> elts a\n  p = a * v + c\n  p \\<in> elts (a * y')\n  p \\<notin> elts (a * u)\n  a * y' = a * u + b'\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. p \\<in> elts (lift (a * u) b')", "by auto"], ["proof (state)\nthis:\n  p \\<in> elts (lift (a * u) b')\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p \\<in> elts (lift (a * u) b')", "obtain d where d: \"d \\<in> elts b'\" \"p = a*u + d\" \"p = a*v + c\""], ["proof (prove)\nusing this:\n  p \\<in> elts (lift (a * u) b')\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> elts b'; p = a * u + d; p = a * v + c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>p = a * v + c\\<close> \\<open>p \\<in> elts (a * y')\\<close> \\<open>p \\<notin> elts (a * u)\\<close> eq mem_plus_V_E)"], ["proof (state)\nthis:\n  d \\<in> elts b'\n  p = a * u + d\n  p = a * v + c\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have v_k: \"v \\<in> elts (Vset k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> elts (Vset k)", "using Vset_succ_TC \\<open>v \\<in> elts y'\\<close> \\<open>y' \\<sqsubseteq> y\\<close> less_TC_iff less_le_TC_trans succ.hyps succ.prems(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts (Vset (ZFC_in_HOL.succ ?k));\n   ?u \\<sqsubset> ?x\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> elts (Vset ?k)\n  v \\<in> elts y'\n  y' \\<sqsubseteq> y\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubseteq> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?z\n  Ord k\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n\ngoal (1 subgoal):\n 1. v \\<in> elts (Vset k)", "by blast"], ["proof (state)\nthis:\n  v \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "have noteq: \"a*u \\<noteq> a*v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * u \\<noteq> a * v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "assume \"a*u = a*v\""], ["proof (state)\nthis:\n  a * u = a * v\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u = a * v", "have \"lift (a*v) a \\<le> a*y'\""], ["proof (prove)\nusing this:\n  a * u = a * v\n\ngoal (1 subgoal):\n 1. lift (a * v) a \\<le> a * y'", "unfolding mult [of _ y']"], ["proof (prove)\nusing this:\n  a * u = a * v\n\ngoal (1 subgoal):\n 1. lift (a * v) a \\<le> (SUP u\\<in>elts y'. lift (a * u) a)", "using \\<open>v \\<in> elts y'\\<close>"], ["proof (prove)\nusing this:\n  a * u = a * v\n  v \\<in> elts y'\n\ngoal (1 subgoal):\n 1. lift (a * v) a \\<le> (SUP u\\<in>elts y'. lift (a * u) a)", "by (auto intro: cSUP_upper)"], ["proof (state)\nthis:\n  lift (a * v) a \\<le> a * y'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift (a * v) a \\<le> a * y'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "have \"\\<dots> = a*u \\<squnion> lift (a*u) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * y' = a * u \\<squnion> lift (a * u) b'", "by (simp add: eq plus_eq_lift)"], ["proof (state)\nthis:\n  a * y' = a * u \\<squnion> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'", "have \"lift (a*v) a \\<le> a*u \\<squnion> lift (a*u) b'\""], ["proof (prove)\nusing this:\n  lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'", "."], ["proof (state)\nthis:\n  lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'", "have \"lift (a*u) a \\<le> lift (a*u) b'\""], ["proof (prove)\nusing this:\n  lift (a * v) a \\<le> a * u \\<squnion> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> lift (a * u) b'", "by (metis \\<open>a * u = a * v\\<close> le_iff_sup lift_sup_distrib sup_left_commute sup_lift_eq_lift)"], ["proof (state)\nthis:\n  lift (a * u) a \\<le> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * u) a \\<le> lift (a * u) b'", "have \"a \\<le> b'\""], ["proof (prove)\nusing this:\n  lift (a * u) a \\<le> lift (a * u) b'\n\ngoal (1 subgoal):\n 1. a \\<le> b'", "by (simp add: le_iff_sup lift_eq_lift lift_sup_distrib)"], ["proof (state)\nthis:\n  a \\<le> b'\n\ngoal (1 subgoal):\n 1. a * u = a * v \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<le> b'", "show False"], ["proof (prove)\nusing this:\n  a \\<le> b'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>b' \\<sqsubset> a\\<close> less_TC_imp_not_le"], ["proof (prove)\nusing this:\n  a \\<le> b'\n  b' \\<sqsubset> a\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * u \\<noteq> a * v\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "consider \"a*u \\<unlhd> a*v\" | \"a*v \\<unlhd> a*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * u \\<unlhd> a * v \\<Longrightarrow> thesis;\n     a * v \\<unlhd> a * u \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using d comparable vle_comparable_def"], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  p = a * u + d\n  p = a * v + c\n  ?a + ?b = ?c + ?d \\<Longrightarrow> vle_comparable ?a ?c\n  vle_comparable ?x ?y \\<equiv> ?x \\<unlhd> ?y \\<or> ?y \\<unlhd> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * u \\<unlhd> a * v \\<Longrightarrow> thesis;\n     a * v \\<unlhd> a * u \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a * u \\<unlhd> a * v \\<Longrightarrow> ?thesis;\n   a * v \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a * u \\<unlhd> a * v \\<Longrightarrow> ?thesis;\n   a * v \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>a * u \\<unlhd> a * v \\<Longrightarrow> ?thesis;\n   a * v \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  a * u \\<unlhd> a * v\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u \\<unlhd> a * v", "obtain e where e: \"a*v = a*u + e\" \"e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a * u \\<unlhd> a * v\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>a * v = a * u + e; e \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.right_neutral noteq vle_def)"], ["proof (state)\nthis:\n  a * v = a * u + e\n  e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a * v = a * u + e\n  e \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "have \"e + c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + c = d", "by (metis add_right_cancel \\<open>p = a * u + d\\<close> \\<open>p = a * v + c\\<close> add.assoc e)"], ["proof (state)\nthis:\n  e + c = d\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "with \\<open>d \\<in> elts b'\\<close> \\<open>b' \\<sqsubset> a\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + c = d", "have \"e \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + c = d\n\ngoal (1 subgoal):\n 1. e \\<sqsubset> a", "by (meson less_TC_iff less_TC_trans vle2 vle_def)"], ["proof (state)\nthis:\n  e \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * v \\<Longrightarrow> False\n 2. a * v \\<unlhd> a * u \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a * v = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a", "show False"], ["proof (prove)\nusing this:\n  a * v = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. False", "using succ.IH u_k v_k"], ["proof (prove)\nusing this:\n  a * v = a * u + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n  \\<lbrakk>?x \\<in> elts (Vset k); ?y \\<in> elts (Vset k);\n   a * ?x = a * ?y + ?b; ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  u \\<in> elts (Vset k)\n  v \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  a * v \\<unlhd> a * u\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * v \\<unlhd> a * u", "obtain e where e: \"a*u = a*v + e\" \"e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a * v \\<unlhd> a * u\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>a * u = a * v + e; e \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.right_neutral noteq vle_def)"], ["proof (state)\nthis:\n  a * u = a * v + e\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  a * u = a * v + e\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "have \"e + d = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + d = c", "by (metis add_right_cancel add.assoc d e)"], ["proof (state)\nthis:\n  e + d = c\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "with \\<open>d \\<in> elts b'\\<close> \\<open>b' \\<sqsubset> a\\<close>"], ["proof (chain)\npicking this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + d = c", "have \"e \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  d \\<in> elts b'\n  b' \\<sqsubset> a\n  e + d = c\n\ngoal (1 subgoal):\n 1. e \\<sqsubset> a", "by (metis \\<open>c \\<in> elts a\\<close> less_TC_iff vle2 vle_def)"], ["proof (state)\nthis:\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. a * v \\<unlhd> a * u \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  a * u = a * v + e\n  e \\<noteq> 0\n  e \\<sqsubset> a", "show False"], ["proof (prove)\nusing this:\n  a * u = a * v + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. False", "using succ.IH u_k v_k"], ["proof (prove)\nusing this:\n  a * u = a * v + e\n  e \\<noteq> 0\n  e \\<sqsubset> a\n  \\<lbrakk>?x \\<in> elts (Vset k); ?y \\<in> elts (Vset k);\n   a * ?x = a * ?y + ?b; ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  u \\<in> elts (Vset k)\n  v \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "case (Limit k)"], ["proof (state)\nthis:\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; ?x \\<in> elts (Vset ?\\<xi>);\n   ?y \\<in> elts (Vset ?\\<xi>); a * ?x = a * ?y + ?b;\n   ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  x \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  y \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "obtain i j where k: \"i \\<in> elts k\" \"j \\<in> elts k\"\n        and x: \"x \\<in> elts (Vset i)\"\n        and y: \"y \\<in> elts (Vset j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> elts k; j \\<in> elts k; x \\<in> elts (Vset i);\n         y \\<in> elts (Vset j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using that Limit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> elts k; ?j \\<in> elts k; x \\<in> elts (Vset ?i);\n   y \\<in> elts (Vset ?j)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; ?x \\<in> elts (Vset ?\\<xi>);\n   ?y \\<in> elts (Vset ?\\<xi>); a * ?x = a * ?y + ?b;\n   ?b \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n  x \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  y \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  a * x = a * y + b\n  b \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> elts k; j \\<in> elts k; x \\<in> elts (Vset i);\n         y \\<in> elts (Vset j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Limit_Vfrom_eq)"], ["proof (state)\nthis:\n  i \\<in> elts k\n  j \\<in> elts k\n  x \\<in> elts (Vset i)\n  y \\<in> elts (Vset j)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y b.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y b.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x = a * y + b;\n            b \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> b = 0;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x = a * y + b; b \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> b = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b = 0", "proof (rule Limit.IH [of \"i \\<squnion> j\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. i \\<squnion> j \\<in> elts k\n 2. ?x \\<in> elts (Vset (i \\<squnion> j))\n 3. ?y \\<in> elts (Vset (i \\<squnion> j))\n 4. a * ?x = a * ?y + b\n 5. b \\<sqsubset> a", "show \"i \\<squnion> j \\<in> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<squnion> j \\<in> elts k", "by (meson k x y Limit.hyps Limit_def Ord_in_Ord Ord_mem_iff_lt Ord_sup union_less_iff)"], ["proof (state)\nthis:\n  i \\<squnion> j \\<in> elts k\n\ngoal (4 subgoals):\n 1. ?x \\<in> elts (Vset (i \\<squnion> j))\n 2. ?y \\<in> elts (Vset (i \\<squnion> j))\n 3. a * ?x = a * ?y + b\n 4. b \\<sqsubset> a", "show \"x \\<in> elts (Vset (i \\<squnion> j))\" \"y \\<in> elts (Vset (i \\<squnion> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts (Vset (i \\<squnion> j)) &&&\n    y \\<in> elts (Vset (i \\<squnion> j))", "using x y"], ["proof (prove)\nusing this:\n  x \\<in> elts (Vset i)\n  y \\<in> elts (Vset j)\n\ngoal (1 subgoal):\n 1. x \\<in> elts (Vset (i \\<squnion> j)) &&&\n    y \\<in> elts (Vset (i \\<squnion> j))", "by (auto simp: Vfrom_sup)"], ["proof (state)\nthis:\n  x \\<in> elts (Vset (i \\<squnion> j))\n  y \\<in> elts (Vset (i \\<squnion> j))\n\ngoal (2 subgoals):\n 1. a * x = a * y + b\n 2. b \\<sqsubset> a", "qed (use Limit.prems in auto)"], ["proof (state)\nthis:\n  b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> b = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> 0; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> b = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> b = 0\n\ngoal (1 subgoal):\n 1. b = 0", "by (metis two_in_Vset Ord_rank Ord_VsetI rank_lt)"], ["proof (state)\nthis:\n  b = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Theorem 4.7\\<close>"], ["", "lemma mult_cancellation_half:\n  assumes \"a*x + r \\<le> a*y + s\" \"r \\<sqsubset> a\" \"s \\<sqsubset> a\"\n  shows \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y", "have \"x \\<le> y\" if \"Ord \\<alpha>\" \"x \\<in> elts (Vset \\<alpha>)\" \"y \\<in> elts (Vset \\<alpha>)\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "using that assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  x \\<in> elts (Vset \\<alpha>)\n  y \\<in> elts (Vset \\<alpha>)\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. x \\<le> y", "proof (induction \\<alpha> arbitrary: x y r s rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y r s.\n       \\<lbrakk>x \\<in> elts (Vset 0); y \\<in> elts (Vset 0);\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y r s.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 3. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "case 0"], ["proof (state)\nthis:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (3 subgoals):\n 1. \\<And>x y r s.\n       \\<lbrakk>x \\<in> elts (Vset 0); y \\<in> elts (Vset 0);\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y r s.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 3. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> elts (Vset 0)\n  y \\<in> elts (Vset 0)\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y r s.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y r s.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "case (succ k)"], ["proof (state)\nthis:\n  Ord k\n  \\<lbrakk>?x \\<in> elts (Vset k); ?y \\<in> elts (Vset k);\n   a * ?x + ?r \\<le> a * ?y + ?s; ?r \\<sqsubset> a;\n   ?s \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x y r s.\n           \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n            y \\<in> elts (Vset \\<alpha>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        y \\<in> elts (Vset (ZFC_in_HOL.succ \\<alpha>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "assume u: \"u \\<in> elts x\""], ["proof (state)\nthis:\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "have u_k: \"u \\<in> elts (Vset k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "using Vset_succ succ.hyps succ.prems(1) u"], ["proof (prove)\nusing this:\n  Ord ?i \\<Longrightarrow> Vset (ZFC_in_HOL.succ ?i) = VPow (Vset ?i)\n  Ord k\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "by auto"], ["proof (state)\nthis:\n  u \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "obtain r' where \"r' \\<in> elts a\" \"r \\<sqsubseteq> r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>r' \\<in> elts a; r \\<sqsubseteq> r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_TC_iff succ.prems(4)"], ["proof (prove)\nusing this:\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  r \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>r' \\<in> elts a; r \\<sqsubseteq> r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r' \\<in> elts a\n  r \\<sqsubseteq> r'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "have \"a*u + r' \\<in> elts (lift (a*u) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * u) a)", "by (simp add: \\<open>r' \\<in> elts a\\<close> lift_def)"], ["proof (state)\nthis:\n  a * u + r' \\<in> elts (lift (a * u) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "also"], ["proof (state)\nthis:\n  a * u + r' \\<in> elts (lift (a * u) a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "have \"\\<dots> \\<le> elts (a*x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (lift (a * u) a) \\<subseteq> elts (a * x)", "using u"], ["proof (prove)\nusing this:\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. elts (lift (a * u) a) \\<subseteq> elts (a * x)", "by (force simp: mult [of _ x])"], ["proof (state)\nthis:\n  elts (lift (a * u) a) \\<subseteq> elts (a * x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "also"], ["proof (state)\nthis:\n  elts (lift (a * u) a) \\<subseteq> elts (a * x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "have \"\\<dots> \\<le> elts (a*y + s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (a * x) \\<subseteq> elts (a * y + s)", "using plus_eq_lift succ.prems(3)"], ["proof (prove)\nusing this:\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n  a * x + r \\<le> a * y + s\n\ngoal (1 subgoal):\n 1. elts (a * x) \\<subseteq> elts (a * y + s)", "by auto"], ["proof (state)\nthis:\n  elts (a * x) \\<subseteq> elts (a * y + s)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "also"], ["proof (state)\nthis:\n  elts (a * x) \\<subseteq> elts (a * y + s)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "have \"\\<dots> = elts (a*y) \\<union> elts (lift (a*y) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (a * y + s) = elts (a * y) \\<union> elts (lift (a * y) s)", "by (simp add: plus_eq_lift)"], ["proof (state)\nthis:\n  elts (a * y + s) = elts (a * y) \\<union> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "finally"], ["proof (chain)\npicking this:\n  a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)", "have \"a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)\""], ["proof (prove)\nusing this:\n  a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)", "."], ["proof (state)\nthis:\n  a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> elts x \\<Longrightarrow> x \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)", "show \"u \\<in> elts y\""], ["proof (prove)\nusing this:\n  a * u + r' \\<in> elts (a * y) \\<union> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a * u + r' \\<in> elts (a * y) \\<Longrightarrow> u \\<in> elts y\n 2. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "assume *: \"a * u + r' \\<in> elts (a * y)\""], ["proof (state)\nthis:\n  a * u + r' \\<in> elts (a * y)\n\ngoal (2 subgoals):\n 1. a * u + r' \\<in> elts (a * y) \\<Longrightarrow> u \\<in> elts y\n 2. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "show \"u \\<in> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> elts y", "obtain v e where v: \"v \\<in> elts y\" \"e \\<in> elts a\" \"a * u + r' = a * v + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v e.\n        \\<lbrakk>v \\<in> elts y; e \\<in> elts a;\n         a * u + r' = a * v + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  a * u + r' \\<in> elts (a * y)\n\ngoal (1 subgoal):\n 1. (\\<And>v e.\n        \\<lbrakk>v \\<in> elts y; e \\<in> elts a;\n         a * u + r' = a * v + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mult [of _ y] lift_def)"], ["proof (state)\nthis:\n  v \\<in> elts y\n  e \\<in> elts a\n  a * u + r' = a * v + e\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts y\n  e \\<in> elts a\n  a * u + r' = a * v + e", "have v_k: \"v \\<in> elts (Vset k)\""], ["proof (prove)\nusing this:\n  v \\<in> elts y\n  e \\<in> elts a\n  a * u + r' = a * v + e\n\ngoal (1 subgoal):\n 1. v \\<in> elts (Vset k)", "using Vset_succ_TC less_TC_iff succ.prems(2)"], ["proof (prove)\nusing this:\n  v \\<in> elts y\n  e \\<in> elts a\n  a * u + r' = a * v + e\n  \\<lbrakk>?x \\<in> elts (Vset (ZFC_in_HOL.succ ?k));\n   ?u \\<sqsubset> ?x\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> elts (Vset ?k)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  y \\<in> elts (Vset (ZFC_in_HOL.succ k))\n\ngoal (1 subgoal):\n 1. v \\<in> elts (Vset k)", "by blast"], ["proof (state)\nthis:\n  v \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts (Vset k)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> elts (Vset k)\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", "by (metis \\<open>r' \\<in> elts a\\<close> antisym le_TC_refl less_TC_iff order_refl succ.IH u_k v)"], ["proof (state)\nthis:\n  u \\<in> elts y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> elts y\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "assume \"a * u + r' \\<in> elts (lift (a * y) s)\""], ["proof (state)\nthis:\n  a * u + r' \\<in> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  a * u + r' \\<in> elts (lift (a * y) s)", "obtain t where \"t \\<in> elts s\" and t: \"a * u + r' = a * y + t\""], ["proof (prove)\nusing this:\n  a * u + r' \\<in> elts (lift (a * y) s)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> elts s; a * u + r' = a * y + t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lift_def"], ["proof (prove)\nusing this:\n  a * u + r' \\<in> elts (lift (a * y) s)\n  lift ?x ?y \\<equiv> set ((+) ?x ` elts ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> elts s; a * u + r' = a * y + t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> elts s\n  a * u + r' = a * y + t\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "have noteq: \"a*y \\<noteq> a*u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * y \\<noteq> a * u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "assume \"a*y = a*u\""], ["proof (state)\nthis:\n  a * y = a * u\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y = a * u", "have \"lift (a*y) a = lift (a*u) a\""], ["proof (prove)\nusing this:\n  a * y = a * u\n\ngoal (1 subgoal):\n 1. lift (a * y) a = lift (a * u) a", "by metis"], ["proof (state)\nthis:\n  lift (a * y) a = lift (a * u) a\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift (a * y) a = lift (a * u) a\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "have \"\\<dots> \\<le> a*x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> a * x", "unfolding mult [of _ x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> (SUP u\\<in>elts x. lift (a * u) a)", "using \\<open>u \\<in> elts x\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. lift (a * u) a \\<le> (SUP u\\<in>elts x. lift (a * u) a)", "by (auto intro: cSUP_upper)"], ["proof (state)\nthis:\n  lift (a * u) a \\<le> a * x\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  lift (a * u) a \\<le> a * x\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "have \"\\<dots> \\<le> a*y \\<squnion> lift (a*y) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x \\<le> a * y \\<squnion> lift (a * y) s", "using \\<open>elts (a * x) \\<subseteq> elts (a * y + s)\\<close> plus_eq_lift"], ["proof (prove)\nusing this:\n  elts (a * x) \\<subseteq> elts (a * y + s)\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n\ngoal (1 subgoal):\n 1. a * x \\<le> a * y \\<squnion> lift (a * y) s", "by auto"], ["proof (state)\nthis:\n  a * x \\<le> a * y \\<squnion> lift (a * y) s\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s", "have \"lift (a*y) a \\<le> a*y \\<squnion> lift (a*y) s\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s", "."], ["proof (state)\nthis:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s", "have \"lift (a*y) a \\<le> lift (a*y) s\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> lift (a * y) s", "using add_le_cancel_left less_TC_imp_not_le plus_eq_lift \\<open>s \\<sqsubset> a\\<close>"], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> a * y \\<squnion> lift (a * y) s\n  (?x + ?y \\<le> ?x + ?z) = (?y \\<le> ?z)\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n  ?x + ?y = ?x \\<squnion> lift ?x ?y\n  s \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. lift (a * y) a \\<le> lift (a * y) s", "by auto"], ["proof (state)\nthis:\n  lift (a * y) a \\<le> lift (a * y) s\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift (a * y) a \\<le> lift (a * y) s", "have \"a \\<le> s\""], ["proof (prove)\nusing this:\n  lift (a * y) a \\<le> lift (a * y) s\n\ngoal (1 subgoal):\n 1. a \\<le> s", "by (simp add: le_iff_sup lift_eq_lift lift_sup_distrib)"], ["proof (state)\nthis:\n  a \\<le> s\n\ngoal (1 subgoal):\n 1. a * y = a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a \\<le> s", "show False"], ["proof (prove)\nusing this:\n  a \\<le> s\n\ngoal (1 subgoal):\n 1. False", "using \\<open>s \\<sqsubset> a\\<close> less_TC_imp_not_le"], ["proof (prove)\nusing this:\n  a \\<le> s\n  s \\<sqsubset> a\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a * y \\<noteq> a * u\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "consider \"a * u \\<unlhd> a * y\" | \"a * y \\<unlhd> a * u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a * u \\<unlhd> a * y \\<Longrightarrow> thesis;\n     a * y \\<unlhd> a * u \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using t comparable vle_comparable_def"], ["proof (prove)\nusing this:\n  a * u + r' = a * y + t\n  ?a + ?b = ?c + ?d \\<Longrightarrow> vle_comparable ?a ?c\n  vle_comparable ?x ?y \\<equiv> ?x \\<unlhd> ?y \\<or> ?y \\<unlhd> ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a * u \\<unlhd> a * y \\<Longrightarrow> thesis;\n     a * y \\<unlhd> a * u \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis;\n   a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis;\n   a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a * u \\<unlhd> a * y \\<Longrightarrow> ?thesis;\n   a * y \\<unlhd> a * u \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  a * u \\<unlhd> a * y\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u \\<unlhd> a * y", "obtain c where \"a*y = a*u + c\""], ["proof (prove)\nusing this:\n  a * u \\<unlhd> a * y\n\ngoal (1 subgoal):\n 1. (\\<And>c. a * y = a * u + c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis vle_def)"], ["proof (state)\nthis:\n  a * y = a * u + c\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y = a * u + c", "have \"c+t = r'\""], ["proof (prove)\nusing this:\n  a * y = a * u + c\n\ngoal (1 subgoal):\n 1. c + t = r'", "by (metis add_right_cancel add.assoc t)"], ["proof (state)\nthis:\n  c + t = r'\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c + t = r'", "have \"c \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  c + t = r'\n\ngoal (1 subgoal):\n 1. c \\<sqsubset> a", "using \\<open>r' \\<in> elts a\\<close> less_TC_iff vle2 vle_def"], ["proof (prove)\nusing this:\n  c + t = r'\n  r' \\<in> elts a\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  ?x \\<unlhd> ?y \\<Longrightarrow> ?x \\<sqsubseteq> ?y\n  ?x \\<unlhd> ?y \\<equiv> \\<exists>z. ?x + z = ?y\n\ngoal (1 subgoal):\n 1. c \\<sqsubset> a", "by force"], ["proof (state)\nthis:\n  c \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<sqsubset> a\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "have \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using \\<open>a * y = a * u + c\\<close> noteq"], ["proof (prove)\nusing this:\n  a * y = a * u + c\n  a * y \\<noteq> a * u\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a * u \\<unlhd> a * y \\<Longrightarrow> False\n 2. a * y \\<unlhd> a * u \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  c \\<sqsubset> a\n  c \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sqsubset> a\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>a * y = a * u + c\\<close> mult_eq_imp_0"], ["proof (prove)\nusing this:\n  c \\<sqsubset> a\n  c \\<noteq> 0\n  a * y = a * u + c\n  \\<lbrakk>?a * ?x = ?a * ?y + ?b; ?b \\<sqsubset> ?a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "case 2"], ["proof (state)\nthis:\n  a * y \\<unlhd> a * u\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * y \\<unlhd> a * u", "obtain c where \"a*u = a*y + c\""], ["proof (prove)\nusing this:\n  a * y \\<unlhd> a * u\n\ngoal (1 subgoal):\n 1. (\\<And>c. a * u = a * y + c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis vle_def)"], ["proof (state)\nthis:\n  a * u = a * y + c\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  a * u = a * y + c", "have \"c+r' = t\""], ["proof (prove)\nusing this:\n  a * u = a * y + c\n\ngoal (1 subgoal):\n 1. c + r' = t", "by (metis add_right_cancel add.assoc t)"], ["proof (state)\nthis:\n  c + r' = t\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  c + r' = t", "have \"c \\<sqsubset> a\""], ["proof (prove)\nusing this:\n  c + r' = t\n\ngoal (1 subgoal):\n 1. c \\<sqsubset> a", "by (metis \\<open>t \\<in> elts s\\<close> less_TC_iff less_TC_trans \\<open>s \\<sqsubset> a\\<close> vle2 vle_def)"], ["proof (state)\nthis:\n  c \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  c \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "have \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using \\<open>a * u = a * y + c\\<close> noteq"], ["proof (prove)\nusing this:\n  a * u = a * y + c\n  a * y \\<noteq> a * u\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a * y \\<unlhd> a * u \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  c \\<sqsubset> a\n  c \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<sqsubset> a\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>a * u = a * y + c\\<close> mult_eq_imp_0"], ["proof (prove)\nusing this:\n  c \\<sqsubset> a\n  c \\<noteq> 0\n  a * u = a * y + c\n  \\<lbrakk>?a * ?x = ?a * ?y + ?b; ?b \\<sqsubset> ?a\\<rbrakk>\n  \\<Longrightarrow> ?b = 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a * u + r' \\<in> elts (lift (a * y) s) \\<Longrightarrow> u \\<in> elts y", "then"], ["proof (chain)\npicking this:\n  False", "show \"u \\<in> elts y\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. u \\<in> elts y", ".."], ["proof (state)\nthis:\n  u \\<in> elts y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> elts y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "case (Limit k)"], ["proof (state)\nthis:\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; ?x \\<in> elts (Vset ?\\<xi>);\n   ?y \\<in> elts (Vset ?\\<xi>); a * ?x + ?r \\<le> a * ?y + ?s;\n   ?r \\<sqsubset> a; ?s \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  x \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  y \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "obtain i j where k: \"i \\<in> elts k\" \"j \\<in> elts k\"\n      and x: \"x \\<in> elts (Vset i)\" and y: \"y \\<in> elts (Vset j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> elts k; j \\<in> elts k; x \\<in> elts (Vset i);\n         y \\<in> elts (Vset j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using that Limit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> elts k; ?j \\<in> elts k; x \\<in> elts (Vset ?i);\n   y \\<in> elts (Vset ?j)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  Limit k\n  \\<lbrakk>?\\<xi> \\<in> elts k; ?x \\<in> elts (Vset ?\\<xi>);\n   ?y \\<in> elts (Vset ?\\<xi>); a * ?x + ?r \\<le> a * ?y + ?s;\n   ?r \\<sqsubset> a; ?s \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n  x \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  y \\<in> elts (Vset (SUP \\<xi>\\<in>elts k. \\<xi>))\n  a * x + r \\<le> a * y + s\n  r \\<sqsubset> a\n  s \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> elts k; j \\<in> elts k; x \\<in> elts (Vset i);\n         y \\<in> elts (Vset j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Limit_Vfrom_eq)"], ["proof (state)\nthis:\n  i \\<in> elts k\n  j \\<in> elts k\n  x \\<in> elts (Vset i)\n  y \\<in> elts (Vset j)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x y r s.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x y r s.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; x \\<in> elts (Vset \\<xi>);\n            y \\<in> elts (Vset \\<xi>); a * x + r \\<le> a * y + s;\n            r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n           \\<Longrightarrow> x \\<le> y;\n        x \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        y \\<in> elts (Vset (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>));\n        a * x + r \\<le> a * y + s; r \\<sqsubset> a; s \\<sqsubset> a\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof (rule Limit.IH [of \"i \\<squnion> j\"])"], ["proof (state)\ngoal (6 subgoals):\n 1. i \\<squnion> j \\<in> elts k\n 2. x \\<in> elts (Vset (i \\<squnion> j))\n 3. y \\<in> elts (Vset (i \\<squnion> j))\n 4. a * x + ?r \\<le> a * y + ?s\n 5. ?r \\<sqsubset> a\n 6. ?s \\<sqsubset> a", "show \"i \\<squnion> j \\<in> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<squnion> j \\<in> elts k", "by (meson k x y Limit.hyps Limit_def Ord_in_Ord Ord_mem_iff_lt Ord_sup union_less_iff)"], ["proof (state)\nthis:\n  i \\<squnion> j \\<in> elts k\n\ngoal (5 subgoals):\n 1. x \\<in> elts (Vset (i \\<squnion> j))\n 2. y \\<in> elts (Vset (i \\<squnion> j))\n 3. a * x + ?r \\<le> a * y + ?s\n 4. ?r \\<sqsubset> a\n 5. ?s \\<sqsubset> a", "show \"x \\<in> elts (Vset (i \\<squnion> j))\" \"y \\<in> elts (Vset (i \\<squnion> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts (Vset (i \\<squnion> j)) &&&\n    y \\<in> elts (Vset (i \\<squnion> j))", "using x y"], ["proof (prove)\nusing this:\n  x \\<in> elts (Vset i)\n  y \\<in> elts (Vset j)\n\ngoal (1 subgoal):\n 1. x \\<in> elts (Vset (i \\<squnion> j)) &&&\n    y \\<in> elts (Vset (i \\<squnion> j))", "by (auto simp: Vfrom_sup)"], ["proof (state)\nthis:\n  x \\<in> elts (Vset (i \\<squnion> j))\n  y \\<in> elts (Vset (i \\<squnion> j))\n\ngoal (3 subgoals):\n 1. a * x + ?r \\<le> a * y + ?s\n 2. ?r \\<sqsubset> a\n 3. ?s \\<sqsubset> a", "show \"a * x + r \\<le> a * y + s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x + r \\<le> a * y + s", "by (simp add: Limit.prems)"], ["proof (state)\nthis:\n  a * x + r \\<le> a * y + s\n\ngoal (2 subgoals):\n 1. r \\<sqsubset> a\n 2. s \\<sqsubset> a", "qed (auto simp: Limit.prems)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> x \\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; x \\<in> elts (Vset ?\\<alpha>);\n   y \\<in> elts (Vset ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (metis two_in_Vset Ord_rank Ord_VsetI rank_lt)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem mult_cancellation_lemma:\n  assumes \"a*x + r = a*y + s\" \"r \\<sqsubset> a\" \"s \\<sqsubset> a\"\n  shows \"x=y \\<and> r=s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<and> r = s", "by (metis assms leD less_V_def mult_cancellation_half odiff_add_cancel order_refl)"], ["", "corollary mult_cancellation [simp]:\n  fixes a::V\n  assumes \"a \\<noteq> 0\"\n  shows \"a*x = a*y \\<longleftrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * x = a * y) = (x = y)", "by (metis assms nonzero_less_TC mult_cancellation_lemma)"], ["", "corollary mult_cancellation_less:\n  assumes lt: \"a*x + r < a*y + s\" and \"r \\<sqsubset> a\" \"s \\<sqsubset> a\"\n  obtains \"x < y\" | \"x = y\" \"r < s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "by (meson assms dual_order.strict_implies_order mult_cancellation_half)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x \\<le> y", "consider \"x < y\" | \"x = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     x = y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using less_V_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     x = y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>x < y \\<Longrightarrow> ?thesis;\n   x = y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < y \\<Longrightarrow> thesis;\n     \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "with lt that"], ["proof (chain)\npicking this:\n  a * x + r < a * y + s\n  x < y \\<Longrightarrow> thesis\n  \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>x < y \\<Longrightarrow> ?thesis;\n   x = y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  a * x + r < a * y + s\n  x < y \\<Longrightarrow> thesis\n  \\<lbrakk>x = y; r < s\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>x < y \\<Longrightarrow> ?thesis;\n   x = y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lift_mult_TC_disjoint:\n  fixes x::V\n  assumes \"x \\<noteq> y\"\n  shows \"lift (a*x) (TC a) \\<sqinter> lift (a*y) (TC a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a) = 0", "apply (rule V_equalityI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> elts\n                  (lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a))) =\n       (xa \\<in> elts 0)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<in> elts\n                  (lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a))) =\n       (xa \\<in> elts 0)", "by (auto simp: less_TC_def inf_V_def lift_def image_iff dest: mult_cancellation_lemma)"], ["", "corollary lift_mult_disjoint:\n  fixes x::V\n  assumes \"x \\<noteq> y\"\n  shows \"lift (a*x) a \\<sqinter> lift (a*y) a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a = 0", "have \"lift (a*x) a \\<sqinter> lift (a*y) a \\<le> lift (a*x) (TC a) \\<sqinter> lift (a*y) (TC a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a\n    \\<le> lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a)", "by (metis TC' inf_mono lift_sup_distrib sup_ge1)"], ["proof (state)\nthis:\n  lift (a * x) a \\<sqinter> lift (a * y) a\n  \\<le> lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a)\n\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a = 0", "then"], ["proof (chain)\npicking this:\n  lift (a * x) a \\<sqinter> lift (a * y) a\n  \\<le> lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a)", "show ?thesis"], ["proof (prove)\nusing this:\n  lift (a * x) a \\<sqinter> lift (a * y) a\n  \\<le> lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a)\n\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a = 0", "using assms lift_mult_TC_disjoint"], ["proof (prove)\nusing this:\n  lift (a * x) a \\<sqinter> lift (a * y) a\n  \\<le> lift (a * x) (TC a) \\<sqinter> lift (a * y) (TC a)\n  x \\<noteq> y\n  ?x \\<noteq> ?y \\<Longrightarrow>\n  lift (?a * ?x) (TC ?a) \\<sqinter> lift (?a * ?y) (TC ?a) = 0\n\ngoal (1 subgoal):\n 1. lift (a * x) a \\<sqinter> lift (a * y) a = 0", "by auto"], ["proof (state)\nthis:\n  lift (a * x) a \\<sqinter> lift (a * y) a = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_add_mem:\n  assumes \"a*x + r \\<in> elts (a*y)\" \"r \\<sqsubset> a\"\n  shows \"x \\<in> elts y\" \"r \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts y &&& r \\<in> elts a", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> elts y\n 2. r \\<in> elts a", "obtain v s where v: \"a * x + r = a * v + s\" \"v \\<in> elts y\" \"s \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>a * x + r = a * v + s; v \\<in> elts y;\n         s \\<in> elts a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  a * x + r \\<in> elts (a * y)\n  r \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>a * x + r = a * v + s; v \\<in> elts y;\n         s \\<in> elts a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mult [of a y] lift_def"], ["proof (prove)\nusing this:\n  a * x + r \\<in> elts (SUP u\\<in>elts y. set ((+) (a * u) ` elts a))\n  r \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. (\\<And>v s.\n        \\<lbrakk>a * x + r = a * v + s; v \\<in> elts y;\n         s \\<in> elts a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a * x + r = a * v + s\n  v \\<in> elts y\n  s \\<in> elts a\n\ngoal (2 subgoals):\n 1. x \\<in> elts y\n 2. r \\<in> elts a", "then"], ["proof (chain)\npicking this:\n  a * x + r = a * v + s\n  v \\<in> elts y\n  s \\<in> elts a", "show \"x \\<in> elts y\""], ["proof (prove)\nusing this:\n  a * x + r = a * v + s\n  v \\<in> elts y\n  s \\<in> elts a\n\ngoal (1 subgoal):\n 1. x \\<in> elts y", "by (metis arg_subset_TC assms(2) less_TC_def mult_cancellation_lemma vsubsetD)"], ["proof (state)\nthis:\n  x \\<in> elts y\n\ngoal (1 subgoal):\n 1. r \\<in> elts a", "show \"r \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> elts a", "by (metis arg_subset_TC assms(2) less_TC_def mult_cancellation_lemma v(1) v(3) vsubsetD)"], ["proof (state)\nthis:\n  r \\<in> elts a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_add_mem_0 [simp]: \"a*x \\<in> elts (a*y) \\<longleftrightarrow> x \\<in> elts y \\<and> 0 \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "have \"x \\<in> elts y\"\n    if \"a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts y", "using that"], ["proof (prove)\nusing this:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a\n\ngoal (1 subgoal):\n 1. x \\<in> elts y", "using mult_add_mem [of a x 0]"], ["proof (prove)\nusing this:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a\n  \\<lbrakk>a * x + 0 \\<in> elts (a * ?y); 0 \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elts ?y\n  \\<lbrakk>a * x + 0 \\<in> elts (a * ?y); 0 \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> 0 \\<in> elts a\n\ngoal (1 subgoal):\n 1. x \\<in> elts y", "using nonzero_less_TC"], ["proof (prove)\nusing this:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a\n  \\<lbrakk>a * x + 0 \\<in> elts (a * ?y); 0 \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> x \\<in> elts ?y\n  \\<lbrakk>a * x + 0 \\<in> elts (a * ?y); 0 \\<sqsubset> a\\<rbrakk>\n  \\<Longrightarrow> 0 \\<in> elts a\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. x \\<in> elts y", "by force"], ["proof (state)\nthis:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a \\<Longrightarrow>\n  x \\<in> elts y\n\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "moreover"], ["proof (state)\nthis:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a \\<Longrightarrow>\n  x \\<in> elts y\n\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "have \"a * x \\<in> elts (a * y)\"\n    if \"x \\<in> elts y\" \"0 \\<in> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * x \\<in> elts (a * y)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> elts y\n  0 \\<in> elts a\n\ngoal (1 subgoal):\n 1. a * x \\<in> elts (a * y)", "by (force simp: image_iff mult [of a y] lift_def)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> elts y; 0 \\<in> elts a\\<rbrakk>\n  \\<Longrightarrow> a * x \\<in> elts (a * y)\n\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "ultimately"], ["proof (chain)\npicking this:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a \\<Longrightarrow>\n  x \\<in> elts y\n  \\<lbrakk>x \\<in> elts y; 0 \\<in> elts a\\<rbrakk>\n  \\<Longrightarrow> a * x \\<in> elts (a * y)", "show ?thesis"], ["proof (prove)\nusing this:\n  a * x \\<in> elts (a * y) \\<and> 0 \\<in> elts a \\<Longrightarrow>\n  x \\<in> elts y\n  \\<lbrakk>x \\<in> elts y; 0 \\<in> elts a\\<rbrakk>\n  \\<Longrightarrow> a * x \\<in> elts (a * y)\n\ngoal (1 subgoal):\n 1. (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)", "by (metis mult_eq_0_iff add.right_neutral mult_add_mem(2) nonzero_less_TC)"], ["proof (state)\nthis:\n  (a * x \\<in> elts (a * y)) = (x \\<in> elts y \\<and> 0 \\<in> elts a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_mem_mult_iff: \"0 \\<in> elts (x*y) \\<longleftrightarrow> 0 \\<in> elts x \\<and> 0 \\<in> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<in> elts (x * y)) = (0 \\<in> elts x \\<and> 0 \\<in> elts y)", "by (metis Kirby.mult_zero_right mult_add_mem_0)"], ["", "lemma zero_less_mult_iff [simp]: \"0 < x*y \\<longleftrightarrow> 0 < x \\<and> 0 < y\" if \"Ord x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < x * y) = (0 < x \\<and> 0 < y)", "using Kirby.mult_eq_0_iff ZFC_in_HOL.neq0_conv"], ["proof (prove)\nusing this:\n  (?x * ?y = 0) = (?x = 0 \\<or> ?y = 0)\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. (0 < x * y) = (0 < x \\<and> 0 < y)", "by blast"], ["", "lemma mult_cancel_less_iff [simp]:\n  \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>*\\<beta> < \\<alpha>*\\<gamma> \\<longleftrightarrow> \\<beta> < \\<gamma> \\<and> 0 < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<alpha> * \\<beta> < \\<alpha> * \\<gamma>) =\n                      (\\<beta> < \\<gamma> \\<and> 0 < \\<alpha>)", "using mult_add_mem_0 [of \\<alpha> \\<beta> \\<gamma>]"], ["proof (prove)\nusing this:\n  (\\<alpha> * \\<beta> \\<in> elts (\\<alpha> * \\<gamma>)) =\n  (\\<beta> \\<in> elts \\<gamma> \\<and> 0 \\<in> elts \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<alpha> * \\<beta> < \\<alpha> * \\<gamma>) =\n                      (\\<beta> < \\<gamma> \\<and> 0 < \\<alpha>)", "by (meson Ord_0 Ord_mem_iff_lt Ord_mult)"], ["", "lemma mult_cancel_le_iff [simp]:\n  \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<alpha>*\\<beta> \\<le> \\<alpha>*\\<gamma> \\<longleftrightarrow> \\<beta> \\<le> \\<gamma> \\<or> \\<alpha>=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> (\\<alpha> * \\<beta> \\<le> \\<alpha> * \\<gamma>) =\n                      (\\<beta> \\<le> \\<gamma> \\<or> \\<alpha> = 0)", "by (metis Ord_linear2 Ord_mult eq_iff leD mult_cancel_less_iff mult_cancellation)"], ["", "lemma mult_Suc_add_less: \"\\<lbrakk>\\<alpha> < \\<gamma>; \\<beta> < \\<gamma>; Ord \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>  \\<Longrightarrow> \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat (Suc m) + \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> < \\<gamma>; \\<beta> < \\<gamma>; Ord \\<alpha>;\n     Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<gamma> * ord_of_nat m + \\<alpha>\n                      < \\<gamma> * ord_of_nat (Suc m) + \\<beta>", "apply (simp add: mult_succ add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> < \\<gamma>; \\<beta> < \\<gamma>; Ord \\<alpha>;\n     Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> < \\<gamma> + \\<beta>", "by (meson Ord_add Ord_linear2 le_less_trans not_add_less_right)"], ["", "lemma mult_nat_less_add_less:\n  assumes \"m < n\" \"\\<alpha> < \\<gamma>\" \"\\<beta> < \\<gamma>\" and ord: \"Ord \\<alpha>\" \"Ord \\<beta>\" \"Ord \\<gamma>\"\n    shows \"\\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "have \"Suc m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc m \\<le> n", "using \\<open>m < n\\<close>"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. Suc m \\<le> n", "by auto"], ["proof (state)\nthis:\n  Suc m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "have \"\\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat (Suc m) + \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha>\n    < \\<gamma> * ord_of_nat (Suc m) + \\<beta>", "using assms mult_Suc_add_less"], ["proof (prove)\nusing this:\n  m < n\n  \\<alpha> < \\<gamma>\n  \\<beta> < \\<gamma>\n  Ord \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<lbrakk>?\\<alpha> < ?\\<gamma>; ?\\<beta> < ?\\<gamma>; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<gamma> * ord_of_nat ?m + ?\\<alpha>\n                    < ?\\<gamma> * ord_of_nat (Suc ?m) + ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha>\n    < \\<gamma> * ord_of_nat (Suc m) + \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<gamma> * ord_of_nat m + \\<alpha>\n  < \\<gamma> * ord_of_nat (Suc m) + \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "also"], ["proof (state)\nthis:\n  \\<gamma> * ord_of_nat m + \\<alpha>\n  < \\<gamma> * ord_of_nat (Suc m) + \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "have \"\\<dots> \\<le> \\<gamma> * ord_of_nat n + \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat (Suc m) + \\<beta>\n    \\<le> \\<gamma> * ord_of_nat n + \\<beta>", "using Ord_mult Ord_ord_of_nat add_right_mono \\<open>Suc m \\<le> n\\<close> ord mult_cancel_le_iff ord_of_nat_mono_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?y; Ord ?x\\<rbrakk> \\<Longrightarrow> Ord (?x * ?y)\n  Ord (ord_of_nat ?k)\n  \\<lbrakk>?\\<alpha> \\<le> ?\\<beta>; Ord ?\\<alpha>; Ord ?\\<beta>;\n   Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> + ?\\<gamma> \\<le> ?\\<beta> + ?\\<gamma>\n  Suc m \\<le> n\n  Ord \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> (?\\<alpha> * ?\\<beta> \\<le> ?\\<alpha> * ?\\<gamma>) =\n                    (?\\<beta> \\<le> ?\\<gamma> \\<or> ?\\<alpha> = 0)\n  (ord_of_nat ?i \\<le> ord_of_nat ?j) = (?i \\<le> ?j)\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat (Suc m) + \\<beta>\n    \\<le> \\<gamma> * ord_of_nat n + \\<beta>", "by presburger"], ["proof (state)\nthis:\n  \\<gamma> * ord_of_nat (Suc m) + \\<beta>\n  \\<le> \\<gamma> * ord_of_nat n + \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "finally"], ["proof (chain)\npicking this:\n  \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>\n\ngoal (1 subgoal):\n 1. \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>", "."], ["proof (state)\nthis:\n  \\<gamma> * ord_of_nat m + \\<alpha> < \\<gamma> * ord_of_nat n + \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_mult_less_add_mult:\n  assumes \"x < y\" \"x \\<in> elts \\<beta>\" \"y \\<in> elts \\<beta>\" \"\\<mu> \\<in> elts \\<alpha>\" \"\\<nu> \\<in> elts \\<alpha>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n    shows \"\\<alpha>*x + \\<mu> < \\<alpha>*y + \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>", "obtain \"Ord x\" \"Ord y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord x; Ord y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_in_Ord assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  x < y\n  x \\<in> elts \\<beta>\n  y \\<in> elts \\<beta>\n  \\<mu> \\<in> elts \\<alpha>\n  \\<nu> \\<in> elts \\<alpha>\n  Ord \\<alpha>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord x; Ord y\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>", "then"], ["proof (chain)\npicking this:\n  Ord x\n  Ord y", "obtain \\<delta> where \"0 \\<in> elts \\<delta>\" \"y = x + \\<delta>\""], ["proof (prove)\nusing this:\n  Ord x\n  Ord y\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<lbrakk>0 \\<in> elts \\<delta>; y = x + \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.right_neutral \\<open>x < y\\<close> le_Ord_diff less_V_def mem_0_Ord)"], ["proof (state)\nthis:\n  0 \\<in> elts \\<delta>\n  y = x + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>", "then"], ["proof (chain)\npicking this:\n  0 \\<in> elts \\<delta>\n  y = x + \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> elts \\<delta>\n  y = x + \\<delta>\n\ngoal (1 subgoal):\n 1. \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>", "apply (simp add: add_mult_distrib add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> elts \\<delta>; y = x + \\<delta>\\<rbrakk>\n    \\<Longrightarrow> \\<mu> < \\<alpha> * \\<delta> + \\<nu>", "by (meson OrdmemD add_le_cancel_left0 \\<open>\\<mu> \\<in> elts \\<alpha>\\<close> \\<open>Ord \\<alpha>\\<close> less_le_trans zero_imp_le_mult)"], ["proof (state)\nthis:\n  \\<alpha> * x + \\<mu> < \\<alpha> * y + \\<nu>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_mult_less:\n  assumes \"\\<gamma> \\<in> elts \\<alpha>\" \"\\<nu> \\<in> elts \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\"\n    shows \"\\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)", "have \"Ord \\<nu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<nu>", "using Ord_in_Ord assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<gamma> \\<in> elts \\<alpha>\n  \\<nu> \\<in> elts \\<beta>\n  Ord \\<alpha>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. Ord \\<nu>", "by blast"], ["proof (state)\nthis:\n  Ord \\<nu>\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)", "with assms"], ["proof (chain)\npicking this:\n  \\<gamma> \\<in> elts \\<alpha>\n  \\<nu> \\<in> elts \\<beta>\n  Ord \\<alpha>\n  Ord \\<beta>\n  Ord \\<nu>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<gamma> \\<in> elts \\<alpha>\n  \\<nu> \\<in> elts \\<beta>\n  Ord \\<alpha>\n  Ord \\<beta>\n  Ord \\<nu>\n\ngoal (1 subgoal):\n 1. \\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)", "by (metis Ord_mem_iff_lt Ord_succ add_mem_right_cancel mult_cancel_le_iff mult_succ succ_le_iff vsubsetD)"], ["proof (state)\nthis:\n  \\<alpha> * \\<nu> + \\<gamma> \\<in> elts (\\<alpha> * \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_add_mult_iff:\n  assumes \"\\<beta> \\<in> elts \\<gamma>\" \"\\<beta>' \\<in> elts \\<gamma>\" \"Ord \\<alpha>\" \"Ord \\<alpha>'\" \"Ord \\<gamma>\"\n  shows \"\\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>') \\<longleftrightarrow> \\<alpha> \\<in> elts \\<alpha>' \\<or> \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<gamma> * \\<alpha> + \\<beta>\n     \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')) =\n    (\\<alpha> \\<in> elts \\<alpha>' \\<or>\n     \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>') \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n 2. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "assume L: ?lhs"], ["proof (state)\nthis:\n  \\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n\ngoal (2 subgoals):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>') \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n 2. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "proof (cases \"\\<alpha> \\<in> elts \\<alpha>'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n 2. \\<alpha> \\<notin> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<notin> elts \\<alpha>'\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n 2. \\<alpha> \\<notin> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "with assms"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> elts \\<gamma>\n  \\<beta>' \\<in> elts \\<gamma>\n  Ord \\<alpha>\n  Ord \\<alpha>'\n  Ord \\<gamma>\n  \\<alpha> \\<notin> elts \\<alpha>'", "have \"\\<alpha> = \\<alpha>'\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts \\<gamma>\n  \\<beta>' \\<in> elts \\<gamma>\n  Ord \\<alpha>\n  Ord \\<alpha>'\n  Ord \\<gamma>\n  \\<alpha> \\<notin> elts \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>'", "by (meson L Ord_linear Ord_mult Ord_trans add_mult_less not_add_mem_right)"], ["proof (state)\nthis:\n  \\<alpha> = \\<alpha>'\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n 2. \\<alpha> \\<notin> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = \\<alpha>'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "using L less_V_def"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<alpha>'\n  \\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts \\<alpha>' \\<or>\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "qed auto"], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts \\<alpha>' \\<or>\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "assume R: ?rhs"], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts \\<alpha>' \\<or>\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<or>\n    \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts \\<alpha>' \\<or>\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<alpha>' \\<or>\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n 2. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "assume \"\\<alpha> \\<in> elts \\<alpha>'\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts \\<alpha>'\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n 2. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts \\<alpha>'", "obtain \\<delta> where \"\\<alpha>' = \\<alpha>+\\<delta>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<alpha>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<alpha>' = \\<alpha> + \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis OrdmemD assms(3) assms(4) le_Ord_diff less_V_def)"], ["proof (state)\nthis:\n  \\<alpha>' = \\<alpha> + \\<delta>\n\ngoal (2 subgoals):\n 1. \\<alpha> \\<in> elts \\<alpha>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n 2. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "using assms"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts \\<gamma>\n  \\<beta>' \\<in> elts \\<gamma>\n  Ord \\<alpha>\n  Ord \\<alpha>'\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "by (meson \\<open>\\<alpha> \\<in> elts \\<alpha>'\\<close> add_le_cancel_left0 add_mult_less vsubsetD)"], ["proof (state)\nthis:\n  \\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "assume \"\\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\""], ["proof (state)\nthis:\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>' \\<and>\n    \\<beta> \\<in> elts \\<beta>' \\<Longrightarrow>\n    \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n\ngoal (1 subgoal):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "using less_V_def"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<alpha>' \\<and> \\<beta> \\<in> elts \\<beta>'\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. \\<gamma> * \\<alpha> + \\<beta>\n    \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')", "by auto"], ["proof (state)\nthis:\n  \\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<gamma> * \\<alpha> + \\<beta> \\<in> elts (\\<gamma> * \\<alpha>' + \\<beta>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vcard_mult: \"vcard (x * y) = vcard x \\<otimes> vcard y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have 1: \"elts (lift (x * u) x) \\<approx> elts x\" if \"u \\<in> elts y\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (lift (x * u) x) \\<approx> elts x", "by (metis cardinal_eqpoll eqpoll_sym eqpoll_trans card_lift)"], ["proof (state)\nthis:\n  ?u \\<in> elts y \\<Longrightarrow> elts (lift (x * ?u) x) \\<approx> elts x\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have 2: \"pairwise (\\<lambda>u u'. disjnt (elts (lift (x * u) x)) (elts (lift (x * u') x)))  (elts y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise\n     (\\<lambda>u u'.\n         disjnt (elts (lift (x * u) x)) (elts (lift (x * u') x)))\n     (elts y)", "by (simp add: pairwise_def disjnt_def) (metis V_disjoint_iff lift_mult_disjoint)"], ["proof (state)\nthis:\n  pairwise\n   (\\<lambda>u u'. disjnt (elts (lift (x * u) x)) (elts (lift (x * u') x)))\n   (elts y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have \"x * y = (SUP u\\<in>elts y. lift (x * u) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = (SUP u\\<in>elts y. lift (x * u) x)", "using mult"], ["proof (prove)\nusing this:\n  ?x * ?y = (SUP u\\<in>elts ?y. lift (?x * u) ?x)\n\ngoal (1 subgoal):\n 1. x * y = (SUP u\\<in>elts y. lift (x * u) x)", "by blast"], ["proof (state)\nthis:\n  x * y = (SUP u\\<in>elts y. lift (x * u) x)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "then"], ["proof (chain)\npicking this:\n  x * y = (SUP u\\<in>elts y. lift (x * u) x)", "have \"elts (x * y) \\<approx> (\\<Union>u\\<in>elts y. elts (lift (x * u) x))\""], ["proof (prove)\nusing this:\n  x * y = (SUP u\\<in>elts y. lift (x * u) x)\n\ngoal (1 subgoal):\n 1. elts (x * y) \\<approx> (\\<Union>u\\<in>elts y. elts (lift (x * u) x))", "by simp"], ["proof (state)\nthis:\n  elts (x * y) \\<approx> (\\<Union>u\\<in>elts y. elts (lift (x * u) x))\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "also"], ["proof (state)\nthis:\n  elts (x * y) \\<approx> (\\<Union>u\\<in>elts y. elts (lift (x * u) x))\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have \"\\<dots> \\<approx> elts y \\<times> elts x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts y. elts (lift (x * u) x)) \\<approx>\n    elts y \\<times> elts x", "using Union_eqpoll_Times [OF 1 2]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> elts y \\<Longrightarrow> x \\<in> elts y) \\<Longrightarrow>\n  (\\<Union>xa\\<in>elts y. elts (lift (x * xa) x)) \\<approx>\n  elts y \\<times> elts x\n\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts y. elts (lift (x * u) x)) \\<approx>\n    elts y \\<times> elts x", "."], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts y. elts (lift (x * u) x)) \\<approx>\n  elts y \\<times> elts x\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "also"], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts y. elts (lift (x * u) x)) \\<approx>\n  elts y \\<times> elts x\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have \"\\<dots> \\<approx> elts x \\<times> elts y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts y \\<times> elts x \\<approx> elts x \\<times> elts y", "by (simp add: times_commute_eqpoll)"], ["proof (state)\nthis:\n  elts y \\<times> elts x \\<approx> elts x \\<times> elts y\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "also"], ["proof (state)\nthis:\n  elts y \\<times> elts x \\<approx> elts x \\<times> elts y\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have \"\\<dots> \\<approx> elts (vcard x) \\<times> elts (vcard y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts x \\<times> elts y \\<approx> elts (vcard x) \\<times> elts (vcard y)", "using cardinal_eqpoll eqpoll_sym times_eqpoll_cong"], ["proof (prove)\nusing this:\n  elts (vcard ?a) \\<approx> elts ?a\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  \\<lbrakk>?A \\<approx> ?C; ?B \\<approx> ?D\\<rbrakk>\n  \\<Longrightarrow> ?A \\<times> ?B \\<approx> ?C \\<times> ?D\n\ngoal (1 subgoal):\n 1. elts x \\<times> elts y \\<approx> elts (vcard x) \\<times> elts (vcard y)", "by blast"], ["proof (state)\nthis:\n  elts x \\<times> elts y \\<approx> elts (vcard x) \\<times> elts (vcard y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "also"], ["proof (state)\nthis:\n  elts x \\<times> elts y \\<approx> elts (vcard x) \\<times> elts (vcard y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "have \"\\<dots> \\<approx> elts (vcard x \\<otimes> vcard y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard x) \\<times> elts (vcard y) \\<approx>\n    elts (vcard x \\<otimes> vcard y)", "by (simp add: cmult_def elts_vcard_VSigma_eqpoll eqpoll_sym)"], ["proof (state)\nthis:\n  elts (vcard x) \\<times> elts (vcard y) \\<approx>\n  elts (vcard x \\<otimes> vcard y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "finally"], ["proof (chain)\npicking this:\n  elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)", "have \"elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)\""], ["proof (prove)\nusing this:\n  elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)\n\ngoal (1 subgoal):\n 1. elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)", "."], ["proof (state)\nthis:\n  elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "then"], ["proof (chain)\npicking this:\n  elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (x * y) \\<approx> elts (vcard x \\<otimes> vcard y)\n\ngoal (1 subgoal):\n 1. vcard (x * y) = vcard x \\<otimes> vcard y", "by (metis cadd_cmult_distrib cadd_def cardinal_cong cardinal_idem vsum_0_eqpoll)"], ["proof (state)\nthis:\n  vcard (x * y) = vcard x \\<otimes> vcard y\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition TC_mult: \"TC(x * y) = (SUP r \\<in> elts (TC x). SUP u \\<in> elts (TC y). set{x * u + r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "have *: \"TC(x * y) = (SUP u \\<in> elts (TC y). lift (x * u) (TC x))\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x * y) = (SUP u\\<in>elts (TC y). lift (x * u) (TC x))", "proof (induction y rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "case (step y)"], ["proof (state)\nthis:\n  ?y \\<in> elts y \\<Longrightarrow>\n  TC (x * ?y) = (SUP u\\<in>elts (TC ?y). lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "have \"TC(x * y) = (SUP u \\<in> elts y. TC (lift (x * u) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x * y) = (SUP u\\<in>elts y. TC (lift (x * u) x))", "by (simp add: mult [of x y] TC_Sup_distrib image_image)"], ["proof (state)\nthis:\n  TC (x * y) = (SUP u\\<in>elts y. TC (lift (x * u) x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "also"], ["proof (state)\nthis:\n  TC (x * y) = (SUP u\\<in>elts y. TC (lift (x * u) x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "have \"\\<dots> = (SUP u \\<in> elts y. TC(x * u) \\<squnion> lift (x * u) (TC x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y. TC (lift (x * u) x)) =\n    (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x))", "by (simp add: TC_lift False)"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. TC (lift (x * u) x)) =\n  (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. TC (lift (x * u) x)) =\n  (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "have \"\\<dots> = (SUP u \\<in> elts y. (SUP z \\<in> elts (TC u). lift (x * z) (TC x)) \\<squnion> lift (x * u) (TC x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x)) =\n    (SUP u\\<in>elts y.\n        (SUP z\\<in>elts (TC u). lift (x * z) (TC x)) \\<squnion>\n        lift (x * u) (TC x))", "by (simp add: step)"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x)) =\n  (SUP u\\<in>elts y.\n      (SUP z\\<in>elts (TC u). lift (x * z) (TC x)) \\<squnion>\n      lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "also"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y. TC (x * u) \\<squnion> lift (x * u) (TC x)) =\n  (SUP u\\<in>elts y.\n      (SUP z\\<in>elts (TC u). lift (x * z) (TC x)) \\<squnion>\n      lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "have \"\\<dots> = (SUP u \\<in> elts (TC y). lift (x * u) (TC x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP u\\<in>elts y.\n        (SUP z\\<in>elts (TC u). lift (x * z) (TC x)) \\<squnion>\n        lift (x * u) (TC x)) =\n    (SUP u\\<in>elts (TC y). lift (x * u) (TC x))", "by (auto simp: TC' [of y] image_Un Sup_Un_distrib TC_Sup_distrib cSUP_UNION SUP_sup_distrib)"], ["proof (state)\nthis:\n  (SUP u\\<in>elts y.\n      (SUP z\\<in>elts (TC u). lift (x * z) (TC x)) \\<squnion>\n      lift (x * u) (TC x)) =\n  (SUP u\\<in>elts (TC y). lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (\\<And>y.\n           y \\<in> elts xa \\<Longrightarrow>\n           TC (x * y) =\n           (SUP u\\<in>elts (TC y). lift (x * u) (TC x))) \\<Longrightarrow>\n       TC (x * xa) = (SUP u\\<in>elts (TC xa). lift (x * u) (TC x))", "finally"], ["proof (chain)\npicking this:\n  TC (x * y) = (SUP u\\<in>elts (TC y). lift (x * u) (TC x))", "show ?case"], ["proof (prove)\nusing this:\n  TC (x * y) = (SUP u\\<in>elts (TC y). lift (x * u) (TC x))\n\ngoal (1 subgoal):\n 1. TC (x * y) = (SUP u\\<in>elts (TC y). lift (x * u) (TC x))", "."], ["proof (state)\nthis:\n  TC (x * y) = (SUP u\\<in>elts (TC y). lift (x * u) (TC x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  TC (x * ?y) = (SUP u\\<in>elts (TC ?y). lift (x * u) (TC x))\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "by (force simp: * lift_def)"], ["proof (state)\nthis:\n  TC (x * y) =\n  (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow>\n    TC (x * y) =\n    (SUP r\\<in>elts (TC x). SUP u\\<in>elts (TC y). set {x * u + r})", "qed auto"], ["", "corollary vcard_TC_mult: \"vcard (TC(x * y)) = vcard (TC x) \\<otimes> vcard (TC y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "have \"(\\<Union>u\\<in>elts (TC x). \\<Union>v\\<in>elts (TC y). {x * v + u}) = (\\<Union>u\\<in>elts (TC x). (\\<lambda>v. x * v + u) ` elts (TC y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts (TC x). \\<Union>v\\<in>elts (TC y). {x * v + u}) =\n    (\\<Union>u\\<in>elts (TC x). (\\<lambda>v. x * v + u) ` elts (TC y))", "by (simp add: UNION_singleton_eq_range)"], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts (TC x). \\<Union>v\\<in>elts (TC y). {x * v + u}) =\n  (\\<Union>u\\<in>elts (TC x). (\\<lambda>v. x * v + u) ` elts (TC y))\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "also"], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts (TC x). \\<Union>v\\<in>elts (TC y). {x * v + u}) =\n  (\\<Union>u\\<in>elts (TC x). (\\<lambda>v. x * v + u) ` elts (TC y))\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "have \"\\<dots> \\<approx> (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts (TC x).\n        (\\<lambda>v. x * v + u) ` elts (TC y)) \\<approx>\n    (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y)))", "proof (rule UN_eqpoll_UN)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u \\<in> elts (TC x) \\<Longrightarrow>\n       (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n       elts (lift (TC y * u) (TC y))\n 2. pairwise\n     (\\<lambda>u ya.\n         disjnt ((\\<lambda>v. x * v + u) ` elts (TC y))\n          ((\\<lambda>v. x * v + ya) ` elts (TC y)))\n     (elts (TC x))\n 3. pairwise\n     (\\<lambda>u ya.\n         disjnt (elts (lift (TC y * u) (TC y)))\n          (elts (lift (TC y * ya) (TC y))))\n     (elts (TC x))", "show \"(\\<lambda>v. x * v + u) ` elts (TC y) \\<approx> elts (lift (TC y * u) (TC y))\"\n      if \"u \\<in> elts (TC x)\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "have \"inj_on (\\<lambda>v. x * v + u) (elts (TC y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>v. x * v + u) (elts (TC y))", "by (meson inj_onI less_TC_def mult_cancellation_lemma that)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>v. x * v + u) (elts (TC y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "then"], ["proof (chain)\npicking this:\n  inj_on (\\<lambda>v. x * v + u) (elts (TC y))", "have \"(\\<lambda>v. x * v + u) ` elts (TC y) \\<approx> elts (TC y)\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>v. x * v + u) (elts (TC y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx> elts (TC y)", "by (rule inj_on_image_eqpoll_self)"], ["proof (state)\nthis:\n  (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx> elts (TC y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "also"], ["proof (state)\nthis:\n  (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx> elts (TC y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "have \"\\<dots> \\<approx> elts (lift (TC y * u) (TC y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (TC y) \\<approx> elts (lift (TC y * u) (TC y))", "by (simp add: eqpoll_lift eqpoll_sym)"], ["proof (state)\nthis:\n  elts (TC y) \\<approx> elts (lift (TC y * u) (TC y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n  elts (lift (TC y * u) (TC y))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n  elts (lift (TC y * u) (TC y))\n\ngoal (1 subgoal):\n 1. (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n    elts (lift (TC y * u) (TC y))", "."], ["proof (state)\nthis:\n  (\\<lambda>v. x * v + u) ` elts (TC y) \\<approx>\n  elts (lift (TC y * u) (TC y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> elts (TC x) \\<Longrightarrow>\n  (\\<lambda>v. x * v + ?u) ` elts (TC y) \\<approx>\n  elts (lift (TC y * ?u) (TC y))\n\ngoal (2 subgoals):\n 1. pairwise\n     (\\<lambda>u ya.\n         disjnt ((\\<lambda>v. x * v + u) ` elts (TC y))\n          ((\\<lambda>v. x * v + ya) ` elts (TC y)))\n     (elts (TC x))\n 2. pairwise\n     (\\<lambda>u ya.\n         disjnt (elts (lift (TC y * u) (TC y)))\n          (elts (lift (TC y * ya) (TC y))))\n     (elts (TC x))", "show \"pairwise (\\<lambda>u ya. disjnt ((\\<lambda>v. x * v + u) ` elts (TC y)) ((\\<lambda>v. x * v + ya) ` elts (TC y))) (elts (TC x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise\n     (\\<lambda>u ya.\n         disjnt ((\\<lambda>v. x * v + u) ` elts (TC y))\n          ((\\<lambda>v. x * v + ya) ` elts (TC y)))\n     (elts (TC x))", "apply (auto simp: pairwise_def disjnt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya v va.\n       \\<lbrakk>xa \\<in> elts (TC x); ya \\<in> elts (TC x); xa \\<noteq> ya;\n        v \\<in> elts (TC y); x * v + xa = x * va + ya;\n        va \\<in> elts (TC y)\\<rbrakk>\n       \\<Longrightarrow> False", "using less_TC_def mult_cancellation_lemma"], ["proof (prove)\nusing this:\n  ?x \\<sqsubset> ?y \\<equiv> ?x \\<in> elts (TC ?y)\n  \\<lbrakk>?a * ?x + ?r = ?a * ?y + ?s; ?r \\<sqsubset> ?a;\n   ?s \\<sqsubset> ?a\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y \\<and> ?r = ?s\n\ngoal (1 subgoal):\n 1. \\<And>xa ya v va.\n       \\<lbrakk>xa \\<in> elts (TC x); ya \\<in> elts (TC x); xa \\<noteq> ya;\n        v \\<in> elts (TC y); x * v + xa = x * va + ya;\n        va \\<in> elts (TC y)\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  pairwise\n   (\\<lambda>u ya.\n       disjnt ((\\<lambda>v. x * v + u) ` elts (TC y))\n        ((\\<lambda>v. x * v + ya) ` elts (TC y)))\n   (elts (TC x))\n\ngoal (1 subgoal):\n 1. pairwise\n     (\\<lambda>u ya.\n         disjnt (elts (lift (TC y * u) (TC y)))\n          (elts (lift (TC y * ya) (TC y))))\n     (elts (TC x))", "show \"pairwise (\\<lambda>u ya. disjnt (elts (lift (TC y * u) (TC y))) (elts (lift (TC y * ya) (TC y)))) (elts (TC x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise\n     (\\<lambda>u ya.\n         disjnt (elts (lift (TC y * u) (TC y)))\n          (elts (lift (TC y * ya) (TC y))))\n     (elts (TC x))", "apply (auto simp: pairwise_def disjnt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya xaa.\n       \\<lbrakk>xa \\<in> elts (TC x); ya \\<in> elts (TC x); xa \\<noteq> ya;\n        xaa \\<in> elts (lift (TC y * xa) (TC y));\n        xaa \\<in> elts (lift (TC y * ya) (TC y))\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Int_iff V_disjoint_iff empty_iff lift_mult_disjoint)"], ["proof (state)\nthis:\n  pairwise\n   (\\<lambda>u ya.\n       disjnt (elts (lift (TC y * u) (TC y)))\n        (elts (lift (TC y * ya) (TC y))))\n   (elts (TC x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts (TC x).\n      (\\<lambda>v. x * v + u) ` elts (TC y)) \\<approx>\n  (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y)))\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "also"], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts (TC x).\n      (\\<lambda>v. x * v + u) ` elts (TC y)) \\<approx>\n  (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y)))\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "have \"\\<dots> = elts (TC y * TC x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y))) =\n    elts (TC y * TC x)", "by (metis elts_Sup image_image mult replacement small_elts)"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>elts (TC x). elts (lift (TC y * x) (TC y))) =\n  elts (TC y * TC x)\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "finally"], ["proof (chain)\npicking this:\n  (\\<Union>u\\<in>elts (TC x).\n      \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n  elts (TC y * TC x)", "have \"(\\<Union>u\\<in>elts (TC x). \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx> elts (TC y * TC x)\""], ["proof (prove)\nusing this:\n  (\\<Union>u\\<in>elts (TC x).\n      \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n  elts (TC y * TC x)\n\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts (TC x).\n        \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n    elts (TC y * TC x)", "."], ["proof (state)\nthis:\n  (\\<Union>u\\<in>elts (TC x).\n      \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n  elts (TC y * TC x)\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "then"], ["proof (chain)\npicking this:\n  (\\<Union>u\\<in>elts (TC x).\n      \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n  elts (TC y * TC x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>u\\<in>elts (TC x).\n      \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n  elts (TC y * TC x)\n\ngoal (1 subgoal):\n 1. vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)", "apply (subst cmult_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>u\\<in>elts (TC x).\n        \\<Union>v\\<in>elts (TC y). {x * v + u}) \\<approx>\n    elts (TC y * TC x) \\<Longrightarrow>\n    vcard (TC (x * y)) = vcard (TC y) \\<otimes> vcard (TC x)", "by (simp add: TC_mult cardinal_cong flip: vcard_mult)"], ["proof (state)\nthis:\n  vcard (TC (x * y)) = vcard (TC x) \\<otimes> vcard (TC y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma countable_mult:\n  assumes \"countable (elts A)\" \"countable (elts B)\"\n  shows \"countable (elts (A*B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts (A * B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (elts (A * B))", "have \"vcard A \\<le> \\<aleph>0\" \"vcard B \\<le> \\<aleph>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0 &&& vcard B \\<le> \\<aleph>0", "using assms countable_iff_le_Aleph0"], ["proof (prove)\nusing this:\n  countable (elts A)\n  countable (elts B)\n  countable (elts ?A) = (vcard ?A \\<le> \\<aleph>0)\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0 &&& vcard B \\<le> \\<aleph>0", "by blast+"], ["proof (state)\nthis:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A * B))", "then"], ["proof (chain)\npicking this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0", "have \"vcard (A*B) \\<le> \\<aleph>0\""], ["proof (prove)\nusing this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. vcard (A * B) \\<le> \\<aleph>0", "unfolding vcard_mult"], ["proof (prove)\nusing this:\n  vcard A \\<le> \\<aleph>0\n  vcard B \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. vcard A \\<otimes> vcard B \\<le> \\<aleph>0", "by (metis InfCard_csquare_eq cmult_le_mono Aleph_0 Card_\\<omega> InfCard_def order_refl)"], ["proof (state)\nthis:\n  vcard (A * B) \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A * B))", "then"], ["proof (chain)\npicking this:\n  vcard (A * B) \\<le> \\<aleph>0", "show ?thesis"], ["proof (prove)\nusing this:\n  vcard (A * B) \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. countable (elts (A * B))", "by (simp add: countable_iff_le_Aleph0)"], ["proof (state)\nthis:\n  countable (elts (A * B))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Ordertype properties\\<close>"], ["", "lemma ordertype_image_plus:\n  assumes \"Ord \\<alpha>\"\n  shows \"ordertype ((+) u ` elts \\<alpha>) VWF = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ((+) u ` elts \\<alpha>) VWF = \\<alpha>", "proof (subst ordertype_VWF_eq_iff)"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord \\<alpha>\n 2. small ((+) u ` elts \\<alpha>)\n 3. \\<exists>f.\n       bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "have 1: \"(u + x, u + y) \\<in> VWF\" if \"x \\<in> elts \\<alpha>\" \"y \\<in> elts \\<alpha>\" \"x < y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u + x, u + y) \\<in> VWF", "using that"], ["proof (prove)\nusing this:\n  x \\<in> elts \\<alpha>\n  y \\<in> elts \\<alpha>\n  x < y\n\ngoal (1 subgoal):\n 1. (u + x, u + y) \\<in> VWF", "by (meson Ord_in_Ord Ord_mem_iff_lt add_mem_right_cancel assms mem_imp_VWF)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF\n\ngoal (3 subgoals):\n 1. Ord \\<alpha>\n 2. small ((+) u ` elts \\<alpha>)\n 3. \\<exists>f.\n       bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF", "have 2: \"x < y\"\n    if \"x \\<in> elts \\<alpha>\" \"y \\<in> elts \\<alpha>\" \"(u + x, u + y) \\<in> VWF\" for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. x < y", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF\n  x \\<in> elts \\<alpha>\n  y \\<in> elts \\<alpha>\n  (u + x, u + y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. x < y", "by (metis Ord_in_Ord Ord_linear_lt VWF_asym assms)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>;\n   (u + ?x, u + ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (3 subgoals):\n 1. Ord \\<alpha>\n 2. small ((+) u ` elts \\<alpha>)\n 3. \\<exists>f.\n       bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "show \"\\<exists>f. bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and> (\\<forall>x\\<in>(+) u ` elts \\<alpha>. \\<forall>y\\<in>(+) u ` elts \\<alpha>. (f x < f y) = ((x, y) \\<in> VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "using 1 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>;\n   (u + ?x, u + ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> (u + ?x, u + ?y) \\<in> VWF\n  \\<lbrakk>?x \\<in> elts \\<alpha>; ?y \\<in> elts \\<alpha>;\n   (u + ?x, u + ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       ((\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n            \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n               f x = f y \\<longrightarrow> x = y) \\<and>\n        f ` (+) u ` elts \\<alpha> = elts \\<alpha>) \\<and>\n       (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n           \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "by (rule_tac x=\"\\<lambda>x. odiff x u\" in exI) (auto simp: image_iff)"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f ((+) u ` elts \\<alpha>) (elts \\<alpha>) \\<and>\n     (\\<forall>x\\<in>(+) u ` elts \\<alpha>.\n         \\<forall>y\\<in>(+) u ` elts \\<alpha>.\n            (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. small ((+) u ` elts \\<alpha>)", "qed (use assms in auto)"], ["", "lemma ordertype_diff:\n  assumes \"\\<beta> + \\<delta> = \\<alpha>\" and \\<alpha>: \"\\<delta> \\<in> elts \\<alpha>\" \"Ord \\<alpha>\"\n  shows \"ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "have *: \"elts \\<alpha> - elts \\<beta> = ((+)\\<beta>) ` elts \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<alpha> - elts \\<beta> = (+) \\<beta> ` elts \\<delta>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. elts \\<alpha> - elts \\<beta> \\<subseteq> (+) \\<beta> ` elts \\<delta>\n 2. (+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>", "show \"elts \\<alpha> - elts \\<beta> \\<subseteq> (+) \\<beta> ` elts \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<alpha> - elts \\<beta> \\<subseteq> (+) \\<beta> ` elts \\<delta>", "by clarsimp (metis assms(1) image_iff mem_plus_V_E)"], ["proof (state)\nthis:\n  elts \\<alpha> - elts \\<beta> \\<subseteq> (+) \\<beta> ` elts \\<delta>\n\ngoal (1 subgoal):\n 1. (+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>", "show \"(+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>", "using assms(1) not_add_mem_right"], ["proof (prove)\nusing this:\n  \\<beta> + \\<delta> = \\<alpha>\n  ?x + ?y \\<notin> elts ?x\n\ngoal (1 subgoal):\n 1. (+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>", "by force"], ["proof (state)\nthis:\n  (+) \\<beta> ` elts \\<delta> \\<subseteq> elts \\<alpha> - elts \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts \\<alpha> - elts \\<beta> = (+) \\<beta> ` elts \\<delta>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "have \"ordertype ((+) \\<beta> ` elts \\<delta>) VWF = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ((+) \\<beta> ` elts \\<delta>) VWF = \\<delta>", "proof (subst ordertype_VWF_inc_eq)"], ["proof (state)\ngoal (5 subgoals):\n 1. elts \\<delta> \\<subseteq> ON\n 2. (+) \\<beta> ` elts \\<delta> \\<subseteq> ON\n 3. small (elts \\<delta>)\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> elts \\<delta>; y \\<in> elts \\<delta>; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + x < \\<beta> + y\n 5. ordertype (elts \\<delta>) VWF = \\<delta>", "show \"elts \\<delta> \\<subseteq> ON\" \"ordertype (elts \\<delta>) VWF = \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<delta> \\<subseteq> ON &&&\n    ordertype (elts \\<delta>) VWF = \\<delta>", "using \\<alpha> elts_subset_ON ordertype_eq_Ord"], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts \\<alpha>\n  Ord \\<alpha>\n  Ord ?\\<alpha> \\<Longrightarrow> elts ?\\<alpha> \\<subseteq> ON\n  Ord ?\\<alpha> \\<Longrightarrow> ordertype (elts ?\\<alpha>) VWF = ?\\<alpha>\n\ngoal (1 subgoal):\n 1. elts \\<delta> \\<subseteq> ON &&&\n    ordertype (elts \\<delta>) VWF = \\<delta>", "by blast+"], ["proof (state)\nthis:\n  elts \\<delta> \\<subseteq> ON\n  ordertype (elts \\<delta>) VWF = \\<delta>\n\ngoal (3 subgoals):\n 1. (+) \\<beta> ` elts \\<delta> \\<subseteq> ON\n 2. small (elts \\<delta>)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> elts \\<delta>; y \\<in> elts \\<delta>; x < y\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + x < \\<beta> + y", "qed (use \"*\" assms elts_subset_ON in auto)"], ["proof (state)\nthis:\n  ordertype ((+) \\<beta> ` elts \\<delta>) VWF = \\<delta>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "then"], ["proof (chain)\npicking this:\n  ordertype ((+) \\<beta> ` elts \\<delta>) VWF = \\<delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype ((+) \\<beta> ` elts \\<delta>) VWF = \\<delta>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "by (simp add: *)"], ["proof (state)\nthis:\n  ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_interval_eq:\n  assumes \\<alpha>: \"Ord \\<alpha>\" and \\<beta>: \"Ord \\<beta>\"\n  shows \"ordertype ({\\<alpha> ..< \\<alpha>+\\<beta>} \\<inter> ON) VWF = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "have ON: \"(+) \\<alpha> ` elts \\<beta> \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) \\<alpha> ` elts \\<beta> \\<subseteq> ON", "using assms Ord_add Ord_in_Ord"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; Ord ?y\\<rbrakk> \\<Longrightarrow> Ord (?x + ?y)\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n\ngoal (1 subgoal):\n 1. (+) \\<alpha> ` elts \\<beta> \\<subseteq> ON", "by blast"], ["proof (state)\nthis:\n  (+) \\<alpha> ` elts \\<beta> \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "have \"({\\<alpha> ..< \\<alpha>+\\<beta>} \\<inter> ON) = (+) \\<alpha> ` elts \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON =\n    (+) \\<alpha> ` elts \\<beta>", "using assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON =\n    (+) \\<alpha> ` elts \\<beta>", "apply (simp add: image_def set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (\\<alpha> \\<le> x \\<and>\n                          x < \\<alpha> + \\<beta> \\<and> Ord x) =\n                         (\\<exists>xa\\<in>elts \\<beta>. x = \\<alpha> + xa)", "by (metis add_less_cancel_left Ord_add Ord_in_Ord Ord_linear2 Ord_mem_iff_lt le_Ord_diff not_add_less_right)"], ["proof (state)\nthis:\n  {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON = (+) \\<alpha> ` elts \\<beta>\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "moreover"], ["proof (state)\nthis:\n  {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON = (+) \\<alpha> ` elts \\<beta>\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "have \"ordertype (elts \\<beta>) VWF = ordertype ((+) \\<alpha> ` elts \\<beta>) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (elts \\<beta>) VWF =\n    ordertype ((+) \\<alpha> ` elts \\<beta>) VWF", "using ON \\<beta> elts_subset_ON ordertype_VWF_inc_eq"], ["proof (prove)\nusing this:\n  (+) \\<alpha> ` elts \\<beta> \\<subseteq> ON\n  Ord \\<beta>\n  Ord ?\\<alpha> \\<Longrightarrow> elts ?\\<alpha> \\<subseteq> ON\n  \\<lbrakk>?A \\<subseteq> ON; ?\\<pi> ` ?A \\<subseteq> ON; small ?A;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?A; x < y\\<rbrakk>\n      \\<Longrightarrow> ?\\<pi> x < ?\\<pi> y\\<rbrakk>\n  \\<Longrightarrow> ordertype (?\\<pi> ` ?A) VWF = ordertype ?A VWF\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<beta>) VWF =\n    ordertype ((+) \\<alpha> ` elts \\<beta>) VWF", "by auto"], ["proof (state)\nthis:\n  ordertype (elts \\<beta>) VWF = ordertype ((+) \\<alpha> ` elts \\<beta>) VWF\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "ultimately"], ["proof (chain)\npicking this:\n  {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON = (+) \\<alpha> ` elts \\<beta>\n  ordertype (elts \\<beta>) VWF = ordertype ((+) \\<alpha> ` elts \\<beta>) VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON = (+) \\<alpha> ` elts \\<beta>\n  ordertype (elts \\<beta>) VWF = ordertype ((+) \\<alpha> ` elts \\<beta>) VWF\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "using \\<beta>"], ["proof (prove)\nusing this:\n  {\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON = (+) \\<alpha> ` elts \\<beta>\n  ordertype (elts \\<beta>) VWF = ordertype ((+) \\<alpha> ` elts \\<beta>) VWF\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>", "by auto"], ["proof (state)\nthis:\n  ordertype ({\\<alpha>..<\\<alpha> + \\<beta>} \\<inter> ON) VWF = \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_Times:\n  assumes \"small A\" \"small B\" and r: \"wf r\" \"trans r\" \"total_on A r\" and s: \"wf s\" \"trans s\" \"total_on B s\"\n  shows \"ordertype (A\\<times>B) (r <*lex*> s) = ordertype B s * ordertype A r\" (is \"_ = ?\\<beta> * ?\\<alpha>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (A \\<times> B) (r <*lex*> s) = ordertype B s * ordertype A r", "proof (subst ordertype_eq_iff)"], ["proof (state)\ngoal (6 subgoals):\n 1. Ord (ordertype B s * ordertype A r)\n 2. wf (r <*lex*> s)\n 3. small (A \\<times> B)\n 4. total_on (A \\<times> B) (r <*lex*> s)\n 5. trans (r <*lex*> s)\n 6. \\<exists>f.\n       bij_betw f (A \\<times> B)\n        (elts (ordertype B s * ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A \\<times> B.\n           \\<forall>y\\<in>A \\<times> B.\n              (f x < f y) = ((x, y) \\<in> r <*lex*> s))", "show \"Ord (?\\<beta> * ?\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordertype B s * ordertype A r)", "by (intro wf_Ord_ordertype Ord_mult r s; simp)"], ["proof (state)\nthis:\n  Ord (ordertype B s * ordertype A r)\n\ngoal (5 subgoals):\n 1. wf (r <*lex*> s)\n 2. small (A \\<times> B)\n 3. total_on (A \\<times> B) (r <*lex*> s)\n 4. trans (r <*lex*> s)\n 5. \\<exists>f.\n       bij_betw f (A \\<times> B)\n        (elts (ordertype B s * ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A \\<times> B.\n           \\<forall>y\\<in>A \\<times> B.\n              (f x < f y) = ((x, y) \\<in> r <*lex*> s))", "define f where \"f \\<equiv> \\<lambda>(x,y). ?\\<beta> * ordermap A r x + (ordermap B s y)\""], ["proof (state)\nthis:\n  f \\<equiv>\n  \\<lambda>(x, y). ordertype B s * ordermap A r x + ordermap B s y\n\ngoal (5 subgoals):\n 1. wf (r <*lex*> s)\n 2. small (A \\<times> B)\n 3. total_on (A \\<times> B) (r <*lex*> s)\n 4. trans (r <*lex*> s)\n 5. \\<exists>f.\n       bij_betw f (A \\<times> B)\n        (elts (ordertype B s * ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A \\<times> B.\n           \\<forall>y\\<in>A \\<times> B.\n              (f x < f y) = ((x, y) \\<in> r <*lex*> s))", "show \"\\<exists>f. bij_betw f (A \\<times> B) (elts (?\\<beta> * ?\\<alpha>)) \\<and> (\\<forall>x\\<in>A \\<times> B. \\<forall>y\\<in>A \\<times> B. (f x < f y) = ((x, y) \\<in> (r <*lex*> s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (A \\<times> B)\n        (elts (ordertype B s * ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A \\<times> B.\n           \\<forall>y\\<in>A \\<times> B.\n              (f x < f y) = ((x, y) \\<in> r <*lex*> s))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       (inj_on f (A \\<times> B) \\<and>\n        f ` (A \\<times> B) = elts (ordertype B s * ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A \\<times> B.\n           \\<forall>y\\<in>A \\<times> B.\n              (f x < f y) = ((x, y) \\<in> r <*lex*> s))", "proof (intro exI conjI strip)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?f (A \\<times> B)\n 2. ?f ` (A \\<times> B) = elts (ordertype B s * ordertype A r)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (?f x < ?f y) = ((x, y) \\<in> r <*lex*> s)", "show \"inj_on f (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (A \\<times> B)", "proof (clarsimp simp: f_def inj_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x \\<in> A; y \\<in> B; xa \\<in> A; ya \\<in> B;\n        ordertype B s * ordermap A r x + ordermap B s y =\n        ordertype B s * ordermap A r xa + ordermap B s ya\\<rbrakk>\n       \\<Longrightarrow> x = xa \\<and> y = ya", "fix x y x' y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x \\<in> A; y \\<in> B; xa \\<in> A; ya \\<in> B;\n        ordertype B s * ordermap A r x + ordermap B s y =\n        ordertype B s * ordermap A r xa + ordermap B s ya\\<rbrakk>\n       \\<Longrightarrow> x = xa \\<and> y = ya", "assume \"x \\<in> A\" \"y \\<in> B\" \"x' \\<in> A\" \"y' \\<in> B\"\n        and eq: \"?\\<beta> * ordermap A r x + ordermap B s y = ?\\<beta> * ordermap A r x' + ordermap B s y'\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> B\n  x' \\<in> A\n  y' \\<in> B\n  ordertype B s * ordermap A r x + ordermap B s y =\n  ordertype B s * ordermap A r x' + ordermap B s y'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x \\<in> A; y \\<in> B; xa \\<in> A; ya \\<in> B;\n        ordertype B s * ordermap A r x + ordermap B s y =\n        ordertype B s * ordermap A r xa + ordermap B s ya\\<rbrakk>\n       \\<Longrightarrow> x = xa \\<and> y = ya", "have \"ordermap A r x = ordermap A r x' \\<and>\n            ordermap B s y = ordermap B s y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r x = ordermap A r x' \\<and> ordermap B s y = ordermap B s y'", "proof (rule mult_cancellation_lemma [OF eq])"], ["proof (state)\ngoal (2 subgoals):\n 1. ordermap B s y \\<sqsubset> ordertype B s\n 2. ordermap B s y' \\<sqsubset> ordertype B s", "show \"ordermap B s y \\<sqsubset> ?\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap B s y \\<sqsubset> ordertype B s", "using ordermap_in_ordertype [OF \\<open>y \\<in> B\\<close>, of s] less_TC_iff \\<open>small B\\<close>"], ["proof (prove)\nusing this:\n  small B \\<Longrightarrow> ordermap B s y \\<in> elts (ordertype B s)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  small B\n\ngoal (1 subgoal):\n 1. ordermap B s y \\<sqsubset> ordertype B s", "by blast"], ["proof (state)\nthis:\n  ordermap B s y \\<sqsubset> ordertype B s\n\ngoal (1 subgoal):\n 1. ordermap B s y' \\<sqsubset> ordertype B s", "show \"ordermap B s y' \\<sqsubset> ?\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap B s y' \\<sqsubset> ordertype B s", "using ordermap_in_ordertype [OF \\<open>y' \\<in> B\\<close>, of s] less_TC_iff \\<open>small B\\<close>"], ["proof (prove)\nusing this:\n  small B \\<Longrightarrow> ordermap B s y' \\<in> elts (ordertype B s)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n  small B\n\ngoal (1 subgoal):\n 1. ordermap B s y' \\<sqsubset> ordertype B s", "by blast"], ["proof (state)\nthis:\n  ordermap B s y' \\<sqsubset> ordertype B s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordermap A r x = ordermap A r x' \\<and> ordermap B s y = ordermap B s y'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x \\<in> A; y \\<in> B; xa \\<in> A; ya \\<in> B;\n        ordertype B s * ordermap A r x + ordermap B s y =\n        ordertype B s * ordermap A r xa + ordermap B s ya\\<rbrakk>\n       \\<Longrightarrow> x = xa \\<and> y = ya", "then"], ["proof (chain)\npicking this:\n  ordermap A r x = ordermap A r x' \\<and> ordermap B s y = ordermap B s y'", "show \"x = x' \\<and> y = y'\""], ["proof (prove)\nusing this:\n  ordermap A r x = ordermap A r x' \\<and> ordermap B s y = ordermap B s y'\n\ngoal (1 subgoal):\n 1. x = x' \\<and> y = y'", "using \\<open>x \\<in> A\\<close> \\<open>x' \\<in> A\\<close> \\<open>y \\<in> B\\<close> \\<open>y' \\<in> B\\<close> r s \\<open>small A\\<close> \\<open>small B\\<close>"], ["proof (prove)\nusing this:\n  ordermap A r x = ordermap A r x' \\<and> ordermap B s y = ordermap B s y'\n  x \\<in> A\n  x' \\<in> A\n  y \\<in> B\n  y' \\<in> B\n  wf r\n  trans r\n  total_on A r\n  wf s\n  trans s\n  total_on B s\n  small A\n  small B\n\ngoal (1 subgoal):\n 1. x = x' \\<and> y = y'", "by auto"], ["proof (state)\nthis:\n  x = x' \\<and> y = y'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f (A \\<times> B)\n\ngoal (2 subgoals):\n 1. f ` (A \\<times> B) = elts (ordertype B s * ordertype A r)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "show \"f ` (A \\<times> B) = elts (?\\<beta> * ?\\<alpha>)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (A \\<times> B) = elts (ordertype B s * ordertype A r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` (A \\<times> B) \\<subseteq> elts (ordertype B s * ordertype A r)\n 2. elts (ordertype B s * ordertype A r) \\<subseteq> f ` (A \\<times> B)", "show \"f ` (A \\<times> B) \\<subseteq> elts (?\\<beta> * ?\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (A \\<times> B) \\<subseteq> elts (ordertype B s * ordertype A r)", "apply (auto simp: f_def add_mult_less ordermap_in_ordertype wf_Ord_ordertype r s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> A; b \\<in> B\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r a + ordermap B s b\n                         \\<in> elts (ordertype B s * ordertype A r)", "by (simp add: add_mult_less assms ordermap_in_ordertype wf_Ord_ordertype)"], ["proof (state)\nthis:\n  f ` (A \\<times> B) \\<subseteq> elts (ordertype B s * ordertype A r)\n\ngoal (1 subgoal):\n 1. elts (ordertype B s * ordertype A r) \\<subseteq> f ` (A \\<times> B)", "show \"elts (?\\<beta> * ?\\<alpha>) \\<subseteq> f ` (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ordertype B s * ordertype A r) \\<subseteq> f ` (A \\<times> B)", "proof (clarsimp simp: f_def image_iff elim !: elts_multE split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "assume u: \"u \\<in> elts (?\\<beta>)\" and v: \"v \\<in> elts ?\\<alpha>\""], ["proof (state)\nthis:\n  u \\<in> elts (ordertype B s)\n  v \\<in> elts (ordertype A r)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "have \"inv_into B (ordermap B s) u \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into B (ordermap B s) u \\<in> B", "by (simp add: inv_into_ordermap u)"], ["proof (state)\nthis:\n  inv_into B (ordermap B s) u \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "moreover"], ["proof (state)\nthis:\n  inv_into B (ordermap B s) u \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "have \"inv_into A (ordermap A r) v \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into A (ordermap A r) v \\<in> A", "by (simp add: inv_into_ordermap v)"], ["proof (state)\nthis:\n  inv_into A (ordermap A r) v \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> elts (ordertype B s);\n        v \\<in> elts (ordertype A r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A.\n                            \\<exists>y\\<in>B.\n                               ordertype B s * v + u =\n                               ordertype B s * ordermap A r x +\n                               ordermap B s y", "ultimately"], ["proof (chain)\npicking this:\n  inv_into B (ordermap B s) u \\<in> B\n  inv_into A (ordermap A r) v \\<in> A", "show \"\\<exists>x\\<in>A. \\<exists>y\\<in>B. ?\\<beta> * v + u = ?\\<beta> * ordermap A r x + ordermap B s y\""], ["proof (prove)\nusing this:\n  inv_into B (ordermap B s) u \\<in> B\n  inv_into A (ordermap A r) v \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>A.\n       \\<exists>y\\<in>B.\n          ordertype B s * v + u =\n          ordertype B s * ordermap A r x + ordermap B s y", "by (metis \\<open>small A\\<close> \\<open>small B\\<close> bij_betw_inv_into_right ordermap_bij r(1) r(3) s(1) s(3) u v)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>A.\n     \\<exists>y\\<in>B.\n        ordertype B s * v + u =\n        ordertype B s * ordermap A r x + ordermap B s y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts (ordertype B s * ordertype A r) \\<subseteq> f ` (A \\<times> B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` (A \\<times> B) = elts (ordertype B s * ordertype A r)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "assume \"p \\<in> A \\<times> B\" and \"q \\<in> A \\<times> B\""], ["proof (state)\nthis:\n  p \\<in> A \\<times> B\n  q \\<in> A \\<times> B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "then"], ["proof (chain)\npicking this:\n  p \\<in> A \\<times> B\n  q \\<in> A \\<times> B", "obtain u v x y where \\<section>: \"p = (u,v)\" \"u \\<in> A\" \"v \\<in> B\" \"q = (x,y)\" \"x \\<in> A\" \"y \\<in> B\""], ["proof (prove)\nusing this:\n  p \\<in> A \\<times> B\n  q \\<in> A \\<times> B\n\ngoal (1 subgoal):\n 1. (\\<And>u v x y.\n        \\<lbrakk>p = (u, v); u \\<in> A; v \\<in> B; q = (x, y); x \\<in> A;\n         y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = (u, v)\n  u \\<in> A\n  v \\<in> B\n  q = (x, y)\n  x \\<in> A\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A \\<times> B; y \\<in> A \\<times> B\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> r <*lex*> s)", "show \"((f p) < f q) = ((p, q) \\<in> (r <*lex*> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f p < f q) = ((p, q) \\<in> r <*lex*> s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> r <*lex*> s\n 2. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "assume \"f p < f q\""], ["proof (state)\nthis:\n  f p < f q\n\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> r <*lex*> s\n 2. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "with \\<section> assms"], ["proof (chain)\npicking this:\n  p = (u, v)\n  u \\<in> A\n  v \\<in> B\n  q = (x, y)\n  x \\<in> A\n  y \\<in> B\n  small A\n  small B\n  wf r\n  trans r\n  total_on A r\n  wf s\n  trans s\n  total_on B s\n  f p < f q", "have \"(u, x) \\<in> r \\<or> u=x \\<and> (v, y) \\<in> s\""], ["proof (prove)\nusing this:\n  p = (u, v)\n  u \\<in> A\n  v \\<in> B\n  q = (x, y)\n  x \\<in> A\n  y \\<in> B\n  small A\n  small B\n  wf r\n  trans r\n  total_on A r\n  wf s\n  trans s\n  total_on B s\n  f p < f q\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s", "apply (simp add: f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = (u, v); u \\<in> A; v \\<in> B; q = (x, y); x \\<in> A;\n     y \\<in> B; small A; small B; wf r; trans r; total_on A r; wf s;\n     trans s; total_on B s;\n     ordertype B s * ordermap A r u + ordermap B s v\n     < ordertype B s * ordermap A r x + ordermap B s y\\<rbrakk>\n    \\<Longrightarrow> (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s", "by (metis Ord_add Ord_add_mult_iff Ord_mem_iff_lt Ord_mult Ord_ordermap converse_ordermap_mono \n            ordermap_eq_iff ordermap_in_ordertype wf_Ord_ordertype)"], ["proof (state)\nthis:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s\n\ngoal (2 subgoals):\n 1. f p < f q \\<Longrightarrow> (p, q) \\<in> r <*lex*> s\n 2. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s", "show \"(p,q) \\<in> (r <*lex*> s)\""], ["proof (prove)\nusing this:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> r <*lex*> s", "by (simp add: \\<section>)"], ["proof (state)\nthis:\n  (p, q) \\<in> r <*lex*> s\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "assume \"(p,q) \\<in> (r <*lex*> s)\""], ["proof (state)\nthis:\n  (p, q) \\<in> r <*lex*> s\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (p, q) \\<in> r <*lex*> s", "have \"(u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s\""], ["proof (prove)\nusing this:\n  (p, q) \\<in> r <*lex*> s\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s", "by (simp add: \\<section>)"], ["proof (state)\nthis:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s\n\ngoal (1 subgoal):\n 1. (p, q) \\<in> r <*lex*> s \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s", "show \"f p < f q\""], ["proof (prove)\nusing this:\n  (u, x) \\<in> r \\<or> u = x \\<and> (v, y) \\<in> s\n\ngoal (1 subgoal):\n 1. f p < f q", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, x) \\<in> r \\<Longrightarrow> f p < f q\n 2. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "assume ux: \"(u, x) \\<in> r\""], ["proof (state)\nthis:\n  (u, x) \\<in> r\n\ngoal (2 subgoals):\n 1. (u, x) \\<in> r \\<Longrightarrow> f p < f q\n 2. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "have oo: \"\\<And>x. Ord (ordermap A r x)\" \"\\<And>y. Ord (ordermap B s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. Ord (ordermap A r x)) &&& (\\<And>y. Ord (ordermap B s y))", "by (simp_all add: r s)"], ["proof (state)\nthis:\n  Ord (ordermap A r ?x)\n  Ord (ordermap B s ?y)\n\ngoal (2 subgoals):\n 1. (u, x) \\<in> r \\<Longrightarrow> f p < f q\n 2. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "show \"f p < f q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f p < f q", "proof (clarsimp simp: f_def split: prod.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "fix a b a' b'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "assume \"p = (a, b)\" and \"q = (a', b')\""], ["proof (state)\nthis:\n  p = (a, b)\n  q = (a', b')\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "then"], ["proof (chain)\npicking this:\n  p = (a, b)\n  q = (a', b')", "have \"?\\<beta> * ordermap A r a + ordermap B s b < ?\\<beta> * ordermap A r a'\""], ["proof (prove)\nusing this:\n  p = (a, b)\n  q = (a', b')\n\ngoal (1 subgoal):\n 1. ordertype B s * ordermap A r a + ordermap B s b\n    < ordertype B s * ordermap A r a'", "using ux assms \\<section>"], ["proof (prove)\nusing this:\n  p = (a, b)\n  q = (a', b')\n  (u, x) \\<in> r\n  small A\n  small B\n  wf r\n  trans r\n  total_on A r\n  wf s\n  trans s\n  total_on B s\n  p = (u, v)\n  u \\<in> A\n  v \\<in> B\n  q = (x, y)\n  x \\<in> A\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. ordertype B s * ordermap A r a + ordermap B s b\n    < ordertype B s * ordermap A r a'", "by (metis Ord_mult Ord_ordermap OrdmemD Pair_inject add_mult_less ordermap_in_ordertype ordermap_mono wf_Ord_ordertype)"], ["proof (state)\nthis:\n  ordertype B s * ordermap A r a + ordermap B s b\n  < ordertype B s * ordermap A r a'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "also"], ["proof (state)\nthis:\n  ordertype B s * ordermap A r a + ordermap B s b\n  < ordertype B s * ordermap A r a'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "have \"\\<dots> \\<le> ?\\<beta> * ordermap A r a' + ordermap B s b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype B s * ordermap A r a'\n    \\<le> ordertype B s * ordermap A r a' + ordermap B s b'", "by simp"], ["proof (state)\nthis:\n  ordertype B s * ordermap A r a'\n  \\<le> ordertype B s * ordermap A r a' + ordermap B s b'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>p = (x1, x2); q = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ordertype B s * ordermap A r x1 + ordermap B s x2\n                         < ordertype B s * ordermap A r x1a +\n                           ordermap B s x2a", "finally"], ["proof (chain)\npicking this:\n  ordertype B s * ordermap A r a + ordermap B s b\n  < ordertype B s * ordermap A r a' + ordermap B s b'", "show \"?\\<beta> * ordermap A r a + ordermap B s b < ?\\<beta> * ordermap A r a' + ordermap B s b'\""], ["proof (prove)\nusing this:\n  ordertype B s * ordermap A r a + ordermap B s b\n  < ordertype B s * ordermap A r a' + ordermap B s b'\n\ngoal (1 subgoal):\n 1. ordertype B s * ordermap A r a + ordermap B s b\n    < ordertype B s * ordermap A r a' + ordermap B s b'", "."], ["proof (state)\nthis:\n  ordertype B s * ordermap A r a + ordermap B s b\n  < ordertype B s * ordermap A r a' + ordermap B s b'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f p < f q\n\ngoal (1 subgoal):\n 1. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "assume \"u = x \\<and> (v, y) \\<in> s\""], ["proof (state)\nthis:\n  u = x \\<and> (v, y) \\<in> s\n\ngoal (1 subgoal):\n 1. u = x \\<and> (v, y) \\<in> s \\<Longrightarrow> f p < f q", "then"], ["proof (chain)\npicking this:\n  u = x \\<and> (v, y) \\<in> s", "show \"f p < f q\""], ["proof (prove)\nusing this:\n  u = x \\<and> (v, y) \\<in> s\n\ngoal (1 subgoal):\n 1. f p < f q", "using \\<section> assms"], ["proof (prove)\nusing this:\n  u = x \\<and> (v, y) \\<in> s\n  p = (u, v)\n  u \\<in> A\n  v \\<in> B\n  q = (x, y)\n  x \\<in> A\n  y \\<in> B\n  small A\n  small B\n  wf r\n  trans r\n  total_on A r\n  wf s\n  trans s\n  total_on B s\n\ngoal (1 subgoal):\n 1. f p < f q", "by (fastforce simp: f_def split: prod.split intro: ordermap_mono_less)"], ["proof (state)\nthis:\n  f p < f q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f p < f q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f p < f q) = ((p, q) \\<in> r <*lex*> s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (A \\<times> B) (elts (ordertype B s * ordertype A r)) \\<and>\n     (\\<forall>x\\<in>A \\<times> B.\n         \\<forall>y\\<in>A \\<times> B.\n            (f x < f y) = ((x, y) \\<in> r <*lex*> s))\n\ngoal (4 subgoals):\n 1. wf (r <*lex*> s)\n 2. small (A \\<times> B)\n 3. total_on (A \\<times> B) (r <*lex*> s)\n 4. trans (r <*lex*> s)", "qed (use assms small_Times in auto)"], ["", "end"]]}