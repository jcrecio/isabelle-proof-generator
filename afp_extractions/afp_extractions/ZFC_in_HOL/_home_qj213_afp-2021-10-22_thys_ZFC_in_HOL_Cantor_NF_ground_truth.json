{"file_name": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL/Cantor_NF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL", "problem_names": ["lemma cnf_1:\n  assumes \\<alpha>: \"\\<alpha> \\<in> elts \\<beta>\" \"Ord \\<beta>\" and \"m > 0\"\n  shows \"\\<omega>\\<up>\\<alpha> * ord_of_nat n < \\<omega>\\<up>\\<beta> * ord_of_nat m\"", "lemma Ord_Cantor_sum:\n  assumes \"List.set \\<alpha>s \\<subseteq> ON\"\n  shows \"Ord (Cantor_sum \\<alpha>s ms)\"", "lemma Cantor_dec_Cons_iff [simp]: \"Cantor_dec (\\<alpha>#\\<beta>#\\<beta>s) \\<longleftrightarrow> \\<beta> < \\<alpha> \\<and> Cantor_dec (\\<beta>#\\<beta>s)\"", "lemma cnf_2:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length \\<alpha>s = length ms\"\n    and \"Cantor_dec (\\<alpha>#\\<alpha>s)\"\n  shows \"\\<omega>\\<up>\\<alpha> > Cantor_sum \\<alpha>s ms\"", "lemma Cantor_sum_0E:\n  assumes \"Cantor_sum \\<alpha>s ms = 0\" \"List.set \\<alpha>s \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length \\<alpha>s = length ms\"\n  shows \"\\<alpha>s = []\"", "lemma Cantor_nf_unique_aux:\n  assumes \"Ord \\<alpha>\"\n    and \\<alpha>sON: \"List.set \\<alpha>s \\<subseteq> ON\"\n    and \\<beta>sON: \"List.set \\<beta>s \\<subseteq> ON\"\n    and ms: \"list.set ms \\<subseteq> {0<..}\"\n    and ns: \"list.set ns \\<subseteq> {0<..}\"\n    and mseq: \"length \\<alpha>s = length ms\"\n    and nseq: \"length \\<beta>s = length ns\"\n    and \\<alpha>sdec: \"Cantor_dec \\<alpha>s\"\n    and \\<beta>sdec: \"Cantor_dec \\<beta>s\"\n    and \\<alpha>seq: \"\\<alpha> = Cantor_sum \\<alpha>s ms\"\n    and \\<beta>seq: \"\\<alpha> = Cantor_sum \\<beta>s ns\"\n  shows \"\\<alpha>s = \\<beta>s \\<and> ms = ns\"", "lemma less_\\<omega>_power:\n  assumes \"Ord \\<alpha>1\" \"Ord \\<beta>\"\n    and \\<alpha>2: \"\\<alpha>2 \\<in> elts \\<alpha>1\" and \\<beta>: \"\\<beta> < \\<omega>\\<up>\\<alpha>2\"\n    and \"m1 > 0\" \"m2 > 0\"\n  shows \"\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + \\<beta> < \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + (\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + \\<beta>)\"\n        (is \"?lhs < ?rhs\")", "lemma Cantor_sum_ge:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length ms > 0\"\n  shows \"\\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha>#\\<alpha>s) ms\"", "lemma Ord_\\<omega>_sum [simp]: \"List.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow> Ord (\\<omega>_sum \\<alpha>s)\"", "lemma \\<omega>_dec_Cons_iff [simp]: \"\\<omega>_dec (\\<alpha>#\\<beta>#\\<beta>s) \\<longleftrightarrow> \\<beta> \\<le> \\<alpha> \\<and> \\<omega>_dec (\\<beta>#\\<beta>s)\"", "lemma \\<omega>_sum_0E:\n  assumes \"\\<omega>_sum \\<alpha>s = 0\" \"List.set \\<alpha>s \\<subseteq> ON\"\n  shows \"\\<alpha>s = []\"", "lemma \\<omega>_sum_append [simp]: \"\\<omega>_sum (xs @ ys) = \\<omega>_sum xs + \\<omega>_sum ys\"", "lemma \\<omega>_sum_replicate [simp]: \"\\<omega>_sum (replicate m a) = \\<omega> \\<up> a * ord_of_nat m\"", "lemma \\<omega>_sum_of_Cantor [simp]: \"\\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ms) = Cantor_sum \\<alpha>s ms\"", "lemma \\<omega>_of_Cantor_subset: \"List.set (\\<omega>_of_Cantor \\<alpha>s ms) \\<subseteq> List.set \\<alpha>s\"", "lemma \\<omega>_dec_replicate: \"\\<omega>_dec (replicate m \\<alpha> @ \\<alpha>s) = (if m=0 then \\<omega>_dec \\<alpha>s else \\<omega>_dec (\\<alpha>#\\<alpha>s))\"", "lemma \\<omega>_dec_of_Cantor_aux:\n  assumes \"Cantor_dec (\\<alpha>#\\<alpha>s)\" \"length \\<alpha>s = length ms\"\n  shows \"\\<omega>_dec (\\<omega>_of_Cantor (\\<alpha>#\\<alpha>s) (m#ms))\"", "lemma \\<omega>_dec_of_Cantor:\n  assumes \"Cantor_dec \\<alpha>s\" \"length \\<alpha>s = length ms\"\n  shows \"\\<omega>_dec (\\<omega>_of_Cantor \\<alpha>s ms)\"", "lemma \\<omega>_sum_take_drop: \"\\<omega>_sum \\<alpha>s = \\<omega>_sum (take k \\<alpha>s) + \\<omega>_sum (drop k \\<alpha>s)\"", "lemma in_elts_\\<omega>_sum:\n  assumes \"\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s)\"\n  shows \"\\<exists>k<length \\<alpha>s. \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> (\\<alpha>s!k)). \\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\"", "lemma \\<omega>_le_\\<omega>_sum: \"\\<lbrakk>k < length \\<alpha>s; List.set \\<alpha>s \\<subseteq> ON\\<rbrakk> \\<Longrightarrow> \\<omega> \\<up> (\\<alpha>s!k) \\<le> \\<omega>_sum \\<alpha>s\"", "lemma \\<omega>_sum_less_self:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" and \"\\<omega>_dec (\\<alpha>#\\<alpha>s)\"\n  shows \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> + \\<omega>_sum \\<alpha>s\"", "lemma \\<omega>_sum_less_\\<omega>_power:\n  assumes \"\\<omega>_dec (\\<alpha>#\\<alpha>s)\" \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\"\n  shows \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> * \\<omega>\"", "lemma \\<omega>_sum_nf_unique_aux:\n  assumes \"Ord \\<alpha>\"\n    and \\<alpha>sON: \"List.set \\<alpha>s \\<subseteq> ON\"\n    and \\<beta>sON: \"List.set \\<beta>s \\<subseteq> ON\"\n    and \\<alpha>sdec: \"\\<omega>_dec \\<alpha>s\"\n    and \\<beta>sdec: \"\\<omega>_dec \\<beta>s\"\n    and \\<alpha>seq: \"\\<alpha> = \\<omega>_sum \\<alpha>s\"\n    and \\<beta>seq: \"\\<alpha> = \\<omega>_sum \\<beta>s\"\n  shows \"\\<alpha>s = \\<beta>s\"", "lemma indecomposableD:\n  \"\\<lbrakk>indecomposable \\<alpha>; \\<beta> < \\<alpha>; \\<gamma> < \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<beta>+\\<gamma> < \\<alpha>\"", "lemma indecomposable_imp_Ord:\n  \"indecomposable \\<alpha> \\<Longrightarrow> Ord \\<alpha>\"", "lemma indecomposable_1: \"indecomposable 1\"", "lemma indecomposable_0: \"indecomposable 0\"", "lemma indecomposable_succ [simp]: \"indecomposable (succ \\<alpha>) \\<longleftrightarrow> \\<alpha> = 0\"", "lemma indecomposable_alt:\n  assumes ord: \"Ord \\<alpha>\" \"Ord \\<beta>\" and \\<beta>: \"\\<beta> < \\<alpha>\" and minor: \"\\<And>\\<beta> \\<gamma>. \\<lbrakk>\\<beta> < \\<alpha>; \\<gamma> < \\<alpha>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<beta>+\\<gamma> < \\<alpha>\"\n  shows \"\\<beta>+\\<alpha> = \\<alpha>\"", "lemma indecomposable_imp_eq:\n  assumes \"indecomposable \\<alpha>\" \"Ord \\<beta>\" \"\\<beta> < \\<alpha>\"\n  shows \"\\<beta>+\\<alpha> = \\<alpha>\"", "lemma indecomposable2:\n  assumes y: \"y < x\" and z: \"z < x\" and minor: \"\\<And>y::V. y < x \\<Longrightarrow> y+x = x\"\n  shows \"y+z < x\"", "lemma indecomposable_imp_Limit:\n  assumes indec: \"indecomposable \\<alpha>\" and \"\\<alpha> > 1\"\n  shows \"Limit \\<alpha>\"", "lemma eq_imp_indecomposable:\n  assumes \"Ord \\<alpha>\" \"\\<And>\\<beta>::V. \\<beta> \\<in> elts \\<alpha> \\<Longrightarrow> \\<beta>+\\<alpha> = \\<alpha>\"\n  shows \"indecomposable \\<alpha>\"", "lemma indecomposable_\\<omega>_power:\n  assumes \"Ord \\<delta>\"\n  shows \"indecomposable (\\<omega>\\<up>\\<delta>)\"", "lemma \\<omega>_power_imp_eq:\n  assumes \"\\<beta> < \\<omega>\\<up>\\<delta>\" \"Ord \\<beta>\" \"Ord \\<delta>\" \"\\<delta> \\<noteq> 0\"\n  shows \"\\<beta> + \\<omega>\\<up>\\<delta> = \\<omega>\\<up>\\<delta>\"", "lemma type_imp_indecomposable:\n  assumes \\<alpha>: \"Ord \\<alpha>\"\n    and minor: \"\\<And>X. X \\<subseteq> elts \\<alpha> \\<Longrightarrow> ordertype X VWF = \\<alpha> \\<or> ordertype (elts \\<alpha> - X) VWF = \\<alpha>\"\n  shows \"indecomposable \\<alpha>\"", "theorem indecomposable_imp_type:\n  fixes X :: \"bool \\<Rightarrow> V set\"\n  assumes \\<gamma>: \"indecomposable \\<gamma>\"\n    and \"\\<And>b. ordertype (X b) VWF \\<le> \\<gamma>\" \"\\<And>b. small (X b)\" \"\\<And>b. X b \\<subseteq> ON\"\n    and \"elts \\<gamma> \\<subseteq> (UN b. X b)\"\n  shows \"\\<exists>b. ordertype (X b) VWF = \\<gamma>\"", "lemma indecomposable_ordertype_eq:\n  assumes indec: \"indecomposable \\<alpha>\" and \\<alpha>: \"ordertype A VWF = \\<alpha>\" and A: \"B \\<subseteq> A\" \"small A\"\n  shows \"ordertype B VWF = \\<alpha> \\<or> ordertype (A-B) VWF = \\<alpha>\"", "lemma indecomposable_ordertype_ge:\n  assumes indec: \"indecomposable \\<alpha>\" and \\<alpha>: \"ordertype A VWF \\<ge> \\<alpha>\" and small: \"small A\" \"small B\"\n  shows \"ordertype B VWF \\<ge> \\<alpha> \\<or> ordertype (A-B) VWF \\<ge> \\<alpha>\"", "lemma indecomposable_ordertype_finite_eq:\n  assumes \"indecomposable \\<alpha>\"\n    and \\<A>: \"finite \\<A>\" \"pairwise disjnt \\<A>\" \"\\<Union>\\<A> = A\" \"\\<A> \\<noteq> {}\" \"ordertype A VWF = \\<alpha>\" \"small A\"\n  shows \"\\<exists>X \\<in> \\<A>. ordertype X VWF = \\<alpha>\"", "lemma indecomposable_ordertype_finite_ge:\n  assumes indec: \"indecomposable \\<alpha>\"\n    and \\<A>: \"finite \\<A>\" \"A \\<subseteq> \\<Union>\\<A>\" \"\\<A> \\<noteq> {}\" \"ordertype A VWF \\<ge> \\<alpha>\" \"small (\\<Union>\\<A>)\"\n  shows \"\\<exists>X \\<in> \\<A>. ordertype X VWF \\<ge> \\<alpha>\""], "translations": [["", "lemma cnf_1:\n  assumes \\<alpha>: \"\\<alpha> \\<in> elts \\<beta>\" \"Ord \\<beta>\" and \"m > 0\"\n  shows \"\\<omega>\\<up>\\<alpha> * ord_of_nat n < \\<omega>\\<up>\\<beta> * ord_of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "have \\<dagger>: \"\\<omega>\\<up>succ \\<alpha> \\<le> \\<omega>\\<up>\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>", "using Ord_mem_iff_less_TC assms oexp_mono succ_le_TC_iff"], ["proof (prove)\nusing this:\n  Ord ?l \\<Longrightarrow> (?k \\<in> elts ?l) = (?k \\<sqsubset> ?l)\n  \\<alpha> \\<in> elts \\<beta>\n  Ord \\<beta>\n  0 < m\n  \\<lbrakk>Ord ?\\<alpha>; ?\\<alpha> \\<noteq> 0; Ord ?\\<beta>;\n   ?\\<gamma> \\<sqsubseteq> ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<up> ?\\<gamma> \\<le> ?\\<alpha> \\<up> ?\\<beta>\n  Ord ?j \\<Longrightarrow>\n  (ZFC_in_HOL.succ ?i \\<sqsubseteq> ?j) = (?i \\<sqsubset> ?j)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "have \"\\<omega>\\<up>\\<alpha> * ord_of_nat n < \\<omega>\\<up>\\<alpha> * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<alpha> * \\<omega>", "using Ord_in_Ord OrdmemD assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  \\<alpha> \\<in> elts \\<beta>\n  Ord \\<beta>\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<alpha> * \\<omega>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> * ord_of_nat n\n  < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> * ord_of_nat n\n  < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "have \"\\<dots> = \\<omega>\\<up>succ \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * \\<omega> =\n    \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>", "using Ord_in_Ord \\<alpha>"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<alpha> \\<in> elts \\<beta>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * \\<omega> =\n    \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> * \\<omega> =\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> * \\<omega> =\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>", "using \"\\<dagger>\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha> \\<le> \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<beta> * ord_of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat m", "using \\<open>m > 0\\<close> le_mult"], ["proof (prove)\nusing this:\n  0 < m\n  \\<lbrakk>Ord ?\\<beta>; ?\\<beta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<le> ?\\<alpha> * ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat m", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "finally"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha> * ord_of_nat n\n  < \\<omega> \\<up> \\<beta> * ord_of_nat m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha> * ord_of_nat n\n  < \\<omega> \\<up> \\<beta> * ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> * ord_of_nat n\n    < \\<omega> \\<up> \\<beta> * ord_of_nat m", "."], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> * ord_of_nat n\n  < \\<omega> \\<up> \\<beta> * ord_of_nat m\n\ngoal:\nNo subgoals!", "qed"], ["", "fun Cantor_sum  where\n  Cantor_sum_Nil: \"Cantor_sum [] ms = 0\"\n| Cantor_sum_Nil2: \"Cantor_sum (\\<alpha>#\\<alpha>s) [] = 0\"\n| Cantor_sum_Cons: \"Cantor_sum (\\<alpha>#\\<alpha>s) (m#ms) = (\\<omega>\\<up>\\<alpha>) * ord_of_nat m + Cantor_sum \\<alpha>s ms\""], ["", "abbreviation Cantor_dec :: \"V list \\<Rightarrow> bool\" where\n  \"Cantor_dec \\<equiv> sorted_wrt (>)\""], ["", "lemma Ord_Cantor_sum:\n  assumes \"List.set \\<alpha>s \\<subseteq> ON\"\n  shows \"Ord (Cantor_sum \\<alpha>s ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<alpha>s ms)", "using assms"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<alpha>s ms)", "proof (induction \\<alpha>s arbitrary: ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       list.set [] \\<subseteq> ON \\<Longrightarrow> Ord (Cantor_sum [] ms)\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n                   Ord (Cantor_sum \\<alpha>s ms);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> Ord (Cantor_sum (a # \\<alpha>s) ms)", "case (Cons a \\<alpha>s ms)"], ["proof (state)\nthis:\n  list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n  Ord (Cantor_sum \\<alpha>s ?ms)\n  list.set (a # \\<alpha>s) \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       list.set [] \\<subseteq> ON \\<Longrightarrow> Ord (Cantor_sum [] ms)\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n                   Ord (Cantor_sum \\<alpha>s ms);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> Ord (Cantor_sum (a # \\<alpha>s) ms)", "then"], ["proof (chain)\npicking this:\n  list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n  Ord (Cantor_sum \\<alpha>s ?ms)\n  list.set (a # \\<alpha>s) \\<subseteq> ON", "show ?case"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n  Ord (Cantor_sum \\<alpha>s ?ms)\n  list.set (a # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord (Cantor_sum (a # \\<alpha>s) ms)", "by (cases ms) auto"], ["proof (state)\nthis:\n  Ord (Cantor_sum (a # \\<alpha>s) ms)\n\ngoal (1 subgoal):\n 1. \\<And>ms.\n       list.set [] \\<subseteq> ON \\<Longrightarrow> Ord (Cantor_sum [] ms)", "qed auto"], ["", "lemma Cantor_dec_Cons_iff [simp]: \"Cantor_dec (\\<alpha>#\\<beta>#\\<beta>s) \\<longleftrightarrow> \\<beta> < \\<alpha> \\<and> Cantor_dec (\\<beta>#\\<beta>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<beta> # \\<beta>s) =\n    (\\<beta> < \\<alpha> \\<and>\n     sorted_wrt (\\<lambda>x y. y < x) (\\<beta> # \\<beta>s))", "by auto"], ["", "text \\<open>Lemma 5.2. The second and third premises aren't really necessary, but their\n      removal requires quite a lot of work.\\<close>"], ["", "lemma cnf_2:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length \\<alpha>s = length ms\"\n    and \"Cantor_dec (\\<alpha>#\\<alpha>s)\"\n  shows \"\\<omega>\\<up>\\<alpha> > Cantor_sum \\<alpha>s ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<alpha>", "proof (induction ms arbitrary: \\<alpha> \\<alpha>s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> \\<alpha>s.\n       \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set [] \\<subseteq> {0<..}; length \\<alpha>s = length [];\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "case Nil"], ["proof (state)\nthis:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set [] \\<subseteq> {0<..}\n  length \\<alpha>s = length []\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> \\<alpha>s.\n       \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set [] \\<subseteq> {0<..}; length \\<alpha>s = length [];\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set [] \\<subseteq> {0<..}\n  length \\<alpha>s = length []\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)", "obtain \\<alpha>0 where \\<alpha>0: \"(\\<alpha>#\\<alpha>s) = [\\<alpha>0]\""], ["proof (prove)\nusing this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set [] \\<subseteq> {0<..}\n  length \\<alpha>s = length []\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>0.\n        \\<alpha> # \\<alpha>s = [\\<alpha>0] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis length_0_conv)"], ["proof (state)\nthis:\n  \\<alpha> # \\<alpha>s = [\\<alpha>0]\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> \\<alpha>s.\n       \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set [] \\<subseteq> {0<..}; length \\<alpha>s = length [];\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> # \\<alpha>s = [\\<alpha>0]", "have \"Ord \\<alpha>0\""], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = [\\<alpha>0]\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>0", "using Nil.prems(1)"], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = [\\<alpha>0]\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>0", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>0\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> \\<alpha>s.\n       \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set [] \\<subseteq> {0<..}; length \\<alpha>s = length [];\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>0", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<alpha>0\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>", "using \\<alpha>0 zero_less_Limit"], ["proof (prove)\nusing this:\n  Ord \\<alpha>0\n  \\<alpha> # \\<alpha>s = [\\<alpha>0]\n  Limit ?\\<beta> \\<Longrightarrow> 0 < ?\\<beta>\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s [] < \\<omega> \\<up> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "case (Cons m1 ms)"], ["proof (state)\nthis:\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ms < \\<omega> \\<up> ?\\<alpha>\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ms < \\<omega> \\<up> ?\\<alpha>\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)", "obtain \\<alpha>0 \\<alpha>1 \\<alpha>s' where \\<alpha>01: \"(\\<alpha>#\\<alpha>s) = \\<alpha>0#\\<alpha>1#\\<alpha>s'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ms < \\<omega> \\<up> ?\\<alpha>\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>0 \\<alpha>1 \\<alpha>s'.\n        \\<alpha> # \\<alpha>s =\n        \\<alpha>0 # \\<alpha>1 # \\<alpha>s' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) Cons.prems(3) Suc_length_conv)"], ["proof (state)\nthis:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'", "have \"Ord \\<alpha>0\" \"Ord \\<alpha>1\""], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>0 &&& Ord \\<alpha>1", "using Cons.prems(1) \\<alpha>01"], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>0 &&& Ord \\<alpha>1", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>0\n  Ord \\<alpha>1\n\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "have *: \"\\<omega>\\<up>\\<alpha>0 * ord_of_nat 1 > \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n    < \\<omega> \\<up> \\<alpha>0 * ord_of_nat 1", "proof (rule cnf_1)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<alpha>1 \\<in> elts \\<alpha>0\n 2. Ord \\<alpha>0\n 3. 0 < 1", "show \"\\<alpha>1 \\<in> elts \\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 \\<in> elts \\<alpha>0", "using Cons.prems \\<alpha>01"], ["proof (prove)\nusing this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. \\<alpha>1 \\<in> elts \\<alpha>0", "by (simp add: Ord_mem_iff_lt \\<open>Ord \\<alpha>0\\<close> \\<open>Ord \\<alpha>1\\<close>)"], ["proof (state)\nthis:\n  \\<alpha>1 \\<in> elts \\<alpha>0\n\ngoal (2 subgoals):\n 1. Ord \\<alpha>0\n 2. 0 < 1", "qed (use \\<open>Ord \\<alpha>0\\<close> in auto)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0 * ord_of_nat 1\n\ngoal (1 subgoal):\n 1. \\<And>a ms \\<alpha> \\<alpha>s.\n       \\<lbrakk>\\<And>\\<alpha> \\<alpha>s.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms;\n                    sorted_wrt (\\<lambda>x y. y < x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> Cantor_sum \\<alpha>s ms\n                                     < \\<omega> \\<up> \\<alpha>;\n        list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n        list.set (a # ms) \\<subseteq> {0<..};\n        length \\<alpha>s = length (a # ms);\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> Cantor_sum \\<alpha>s (a # ms)\n                         < \\<omega> \\<up> \\<alpha>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "proof (cases ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. ms = [] \\<Longrightarrow>\n    Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "case Nil"], ["proof (state)\nthis:\n  ms = []\n\ngoal (2 subgoals):\n 1. ms = [] \\<Longrightarrow>\n    Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>\n 2. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  ms = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ms = []\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "using * one_V_def Cons.prems(3) \\<alpha>01"], ["proof (prove)\nusing this:\n  ms = []\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0 * ord_of_nat 1\n  1 \\<equiv> ZFC_in_HOL.succ 0\n  length \\<alpha>s = length (m1 # ms)\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "case (Cons m2 ms')"], ["proof (state)\nthis:\n  ms = m2 # ms'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  ms = m2 # ms'", "obtain \\<alpha>2 \\<alpha>s'' where \\<alpha>02: \"(\\<alpha>#\\<alpha>s) = \\<alpha>0#\\<alpha>1#\\<alpha>2#\\<alpha>s''\""], ["proof (prove)\nusing this:\n  ms = m2 # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>2 \\<alpha>s''.\n        \\<alpha> # \\<alpha>s =\n        \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Cons.prems(3) Suc_length_conv \\<alpha>01 length_tl list.sel(3))"], ["proof (state)\nthis:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''", "have \"Ord \\<alpha>2\""], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>2", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>2", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "have \"m1 > 0\" \"m2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m1 &&& 0 < m2", "using Cons.prems Cons"], ["proof (prove)\nusing this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n  ms = m2 # ms'\n\ngoal (1 subgoal):\n 1. 0 < m1 &&& 0 < m2", "by auto"], ["proof (state)\nthis:\n  0 < m1\n  0 < m2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "have \"\\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 = (\\<omega>\\<up>\\<alpha>1 * ord_of_nat m1) * ord_of_nat 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 =\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2", "by (simp add: mult_succ eval_nat_numeral)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "have \"\\<dots> < \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2\n    < \\<omega> \\<up> \\<alpha>0", "using cnf_1 [of concl: \"\\<alpha>1\" \"m1 * 2\" \"\\<alpha>0\" 1] Cons.prems \\<alpha>01 one_V_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha>1 \\<in> elts \\<alpha>0; Ord \\<alpha>0; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>1 * ord_of_nat (m1 * 2)\n                    < \\<omega> \\<up> \\<alpha>0 * ord_of_nat 1\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  list.set (m1 # ms) \\<subseteq> {0<..}\n  length \\<alpha>s = length (m1 # ms)\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n  1 \\<equiv> ZFC_in_HOL.succ 0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2\n    < \\<omega> \\<up> \\<alpha>0", "by (simp add: mult.assoc ord_of_nat_mult Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 * ord_of_nat 2\n  < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0", "have II: \"\\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 < \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n    < \\<omega> \\<up> \\<alpha>0", "by simp"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "have \"Cantor_sum (tl \\<alpha>s) ms < \\<omega>\\<up>hd \\<alpha>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum (tl \\<alpha>s) ms < \\<omega> \\<up> hd \\<alpha>s", "proof (rule Cons.IH)"], ["proof (state)\ngoal (4 subgoals):\n 1. list.set (hd \\<alpha>s # tl \\<alpha>s) \\<subseteq> ON\n 2. list.set ms \\<subseteq> {0<..}\n 3. length (tl \\<alpha>s) = length ms\n 4. sorted_wrt (\\<lambda>x y. y < x) (hd \\<alpha>s # tl \\<alpha>s)", "show \"Cantor_dec (hd \\<alpha>s # tl \\<alpha>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) (hd \\<alpha>s # tl \\<alpha>s)", "using \\<open>Cantor_dec (\\<alpha>#\\<alpha>s)\\<close> \\<alpha>01"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) (hd \\<alpha>s # tl \\<alpha>s)", "by auto"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y < x) (hd \\<alpha>s # tl \\<alpha>s)\n\ngoal (3 subgoals):\n 1. list.set (hd \\<alpha>s # tl \\<alpha>s) \\<subseteq> ON\n 2. list.set ms \\<subseteq> {0<..}\n 3. length (tl \\<alpha>s) = length ms", "qed (use Cons.prems \\<alpha>01 in auto)"], ["proof (state)\nthis:\n  Cantor_sum (tl \\<alpha>s) ms < \\<omega> \\<up> hd \\<alpha>s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "then"], ["proof (chain)\npicking this:\n  Cantor_sum (tl \\<alpha>s) ms < \\<omega> \\<up> hd \\<alpha>s", "have \"Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms < \\<omega>\\<up>\\<alpha>1\""], ["proof (prove)\nusing this:\n  Cantor_sum (tl \\<alpha>s) ms < \\<omega> \\<up> hd \\<alpha>s\n\ngoal (1 subgoal):\n 1. Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms < \\<omega> \\<up> \\<alpha>1", "using \\<alpha>02"], ["proof (prove)\nusing this:\n  Cantor_sum (tl \\<alpha>s) ms < \\<omega> \\<up> hd \\<alpha>s\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''\n\ngoal (1 subgoal):\n 1. Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms < \\<omega> \\<up> \\<alpha>1", "by auto"], ["proof (state)\nthis:\n  Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms < \\<omega> \\<up> \\<alpha>1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "also"], ["proof (state)\nthis:\n  Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms < \\<omega> \\<up> \\<alpha>1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 \\<le> \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1", "by (simp add: \\<open>0 < m1\\<close> le_mult)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 \\<le> \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ms = a # list \\<Longrightarrow>\n       Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1", "show ?thesis"], ["proof (prove)\nusing this:\n  Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "using II \\<alpha>02 dual_order.strict_trans"], ["proof (prove)\nusing this:\n  Cantor_sum (\\<alpha>2 # \\<alpha>s'') ms\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1\n  < \\<omega> \\<up> \\<alpha>0\n  \\<alpha> # \\<alpha>s = \\<alpha>0 # \\<alpha>1 # \\<alpha>2 # \\<alpha>s''\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>", "by fastforce"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s (m1 # ms) < \\<omega> \\<up> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition Cantor_nf_exists:\n  assumes \"Ord \\<alpha>\"\n  obtains \\<alpha>s ms where \"List.set \\<alpha>s \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length \\<alpha>s = length ms\"\n    and \"Cantor_dec \\<alpha>s\"\n    and \"\\<alpha> = Cantor_sum \\<alpha>s ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction \\<alpha> arbitrary: thesis rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x thesis.\n       \\<lbrakk>Ord x;\n        \\<And>y thesis.\n           \\<lbrakk>y \\<in> elts x;\n            \\<And>\\<alpha>s ms.\n               \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n                list.set ms \\<subseteq> {0<..};\n                length \\<alpha>s = length ms;\n                sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n                y = Cantor_sum \\<alpha>s ms\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>\\<alpha>s ms.\n           \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n            list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n            sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n            x = Cantor_sum \\<alpha>s ms\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (step \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>;\n   \\<And>\\<alpha>s ms.\n      \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n       list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n       sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n       ?y = Cantor_sum \\<alpha>s ms\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   \\<alpha> = Cantor_sum ?\\<alpha>s ?ms\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>x thesis.\n       \\<lbrakk>Ord x;\n        \\<And>y thesis.\n           \\<lbrakk>y \\<in> elts x;\n            \\<And>\\<alpha>s ms.\n               \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n                list.set ms \\<subseteq> {0<..};\n                length \\<alpha>s = length ms;\n                sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n                y = Cantor_sum \\<alpha>s ms\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>\\<alpha>s ms.\n           \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n            list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n            sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n            x = Cantor_sum \\<alpha>s ms\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"\\<alpha> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> thesis\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<alpha> = 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> thesis\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have \"Cantor_sum [] [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum [] [] = 0", "by simp"], ["proof (state)\nthis:\n  Cantor_sum [] [] = 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> thesis\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "with True"], ["proof (chain)\npicking this:\n  \\<alpha> = 0\n  Cantor_sum [] [] = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n  Cantor_sum [] [] = 0\n\ngoal (1 subgoal):\n 1. thesis", "using length_pos_if_in_set step.prems subset_eq"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n  Cantor_sum [] [] = 0\n  ?x \\<in> list.set ?xs \\<Longrightarrow> 0 < length ?xs\n  \\<lbrakk>list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   \\<alpha> = Cantor_sum ?\\<alpha>s ?ms\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis length_0_conv not_gr_zero sorted_wrt.simps(1))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "define \\<alpha>hat where \"\\<alpha>hat \\<equiv> Sup {\\<gamma> \\<in> ON. \\<omega>\\<up>\\<gamma> \\<le> \\<alpha>}\""], ["proof (state)\nthis:\n  \\<alpha>hat \\<equiv>\n  \\<Squnion> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<alpha>hat \\<equiv>\n  \\<Squnion> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}", "have \"Ord \\<alpha>hat\""], ["proof (prove)\nusing this:\n  \\<alpha>hat \\<equiv>\n  \\<Squnion> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>hat", "using Ord_Sup assms"], ["proof (prove)\nusing this:\n  \\<alpha>hat \\<equiv>\n  \\<Squnion> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  (\\<And>x. x \\<in> ?X \\<Longrightarrow> Ord x) \\<Longrightarrow>\n  Ord (\\<Squnion> ?X)\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>hat", "by fastforce"], ["proof (state)\nthis:\n  Ord \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have \"\\<And>\\<xi>. \\<lbrakk>Ord \\<xi>; \\<omega>\\<up>\\<xi> \\<le> \\<alpha>\\<rbrakk> \\<Longrightarrow> \\<xi> \\<le> \\<omega>\\<up>\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<xi>.\n       \\<lbrakk>Ord \\<xi>; \\<omega> \\<up> \\<xi> \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<xi> \\<le> \\<omega> \\<up> \\<alpha>", "by (metis Ord_\\<omega> OrdmemD le_oexp' order_trans step.hyps one_V_def succ_in_omega zero_in_omega)"], ["proof (state)\nthis:\n  \\<lbrakk>Ord ?\\<xi>; \\<omega> \\<up> ?\\<xi> \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<xi> \\<le> \\<omega> \\<up> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Ord ?\\<xi>; \\<omega> \\<up> ?\\<xi> \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<xi> \\<le> \\<omega> \\<up> \\<alpha>", "have \"{\\<gamma> \\<in> ON. \\<omega>\\<up>\\<gamma> \\<le> \\<alpha>} \\<subseteq> elts (succ (\\<omega>\\<up>\\<alpha>))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<xi>; \\<omega> \\<up> ?\\<xi> \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<xi> \\<le> \\<omega> \\<up> \\<alpha>\n\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n    \\<subseteq> elts (ZFC_in_HOL.succ (\\<omega> \\<up> \\<alpha>))", "using Ord_mem_iff_lt step.hyps"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<xi>; \\<omega> \\<up> ?\\<xi> \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ?\\<xi> \\<le> \\<omega> \\<up> \\<alpha>\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n    \\<subseteq> elts (ZFC_in_HOL.succ (\\<omega> \\<up> \\<alpha>))", "by force"], ["proof (state)\nthis:\n  {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  \\<subseteq> elts (ZFC_in_HOL.succ (\\<omega> \\<up> \\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  \\<subseteq> elts (ZFC_in_HOL.succ (\\<omega> \\<up> \\<alpha>))", "have sma: \"small {\\<gamma> \\<in> ON. \\<omega>\\<up>\\<gamma> \\<le> \\<alpha>}\""], ["proof (prove)\nusing this:\n  {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  \\<subseteq> elts (ZFC_in_HOL.succ (\\<omega> \\<up> \\<alpha>))\n\ngoal (1 subgoal):\n 1. small {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}", "by (meson down)"], ["proof (state)\nthis:\n  small {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have le: \"\\<omega>\\<up>\\<alpha>hat \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha> \\<Longrightarrow> False", "assume \"\\<not> \\<omega>\\<up>\\<alpha>hat \\<le> \\<alpha>\""], ["proof (state)\nthis:\n  \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>", "have \\<dagger>: \"\\<alpha> \\<in> elts (\\<omega>\\<up>\\<alpha>hat)\""], ["proof (prove)\nusing this:\n  \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)", "by (meson Ord_\\<omega> Ord_linear2 Ord_mem_iff_lt Ord_oexp \\<open>Ord \\<alpha>hat\\<close> step.hyps)"], ["proof (state)\nthis:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha> \\<Longrightarrow> False", "obtain \\<gamma> where \"Ord \\<gamma>\" \"\\<omega>\\<up>\\<gamma> \\<le> \\<alpha>\" \"\\<alpha> < \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>Ord \\<gamma>; \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n         \\<alpha> < \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Ord \\<alpha>hat\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<alpha>hat\n\ngoal (1 subgoal):\n 1. (\\<And>\\<gamma>.\n        \\<lbrakk>Ord \\<gamma>; \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n         \\<alpha> < \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \\<alpha>hat rule: Ord_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<alpha>hat = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  \\<alpha>hat = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<alpha>hat = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<dagger>"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  \\<alpha>hat = 0", "show thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  \\<alpha>hat = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: False)"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "case (succ \\<beta>)"], ["proof (state)\nthis:\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>hat\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"succ \\<beta> \\<in> {\\<gamma> \\<in> ON. \\<omega>\\<up>\\<gamma> \\<le> \\<alpha>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ \\<beta>\n    \\<in> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}", "by (rule succ_in_Sup_Ord) (use succ \\<alpha>hat_def sma in auto)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ \\<beta>\n  \\<in> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  ZFC_in_HOL.succ \\<beta>\n  \\<in> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}", "have \"\\<omega>\\<up>succ \\<beta> \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ \\<beta>\n  \\<in> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<beta> \\<le> \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<beta> \\<le> \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>\\<gamma>.\n                   \\<lbrakk>Ord \\<gamma>;\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                    \\<alpha> < \\<gamma>\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Ord l; ZFC_in_HOL.succ l = \\<alpha>hat\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<dagger>"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<beta> \\<le> \\<alpha>", "show thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<beta> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>\\<not> \\<omega>\\<up>\\<alpha>hat \\<le> \\<alpha>\\<close> succ"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<beta> \\<le> \\<alpha>\n  \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>hat\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "case limit"], ["proof (state)\nthis:\n  Limit \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>\\<gamma>.\n                \\<lbrakk>Ord \\<gamma>;\n                 \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>;\n                 \\<alpha> < \\<gamma>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     Limit \\<alpha>hat\\<rbrakk>\n    \\<Longrightarrow> thesis", "with \\<dagger>"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  Limit \\<alpha>hat", "show thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts (\\<omega> \\<up> \\<alpha>hat)\n  Limit \\<alpha>hat\n\ngoal (1 subgoal):\n 1. thesis", "apply (clarsimp simp: oexp_Limit \\<alpha>hat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>Limit\n                 (\\<Squnion>\n                   {\\<gamma>.\n                    Ord \\<gamma> \\<and>\n                    \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>});\n        \\<alpha> \\<in> elts (\\<omega> \\<up> x);\n        small\n         {\\<gamma>.\n          Ord \\<gamma> \\<and> \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>};\n        x \\<in> elts xa; Ord xa; \\<omega> \\<up> xa \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (meson Ord_\\<omega> Ord_in_Ord Ord_linear_le mem_not_refl oexp_mono_le omega_nonzero vsubsetD)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ord \\<gamma>\n  \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>\n  \\<alpha> < \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ord \\<gamma>\n  \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>\n  \\<alpha> < \\<gamma>", "show False"], ["proof (prove)\nusing this:\n  Ord \\<gamma>\n  \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>\n  \\<alpha> < \\<gamma>\n\ngoal (1 subgoal):\n 1. False", "by (metis Ord_\\<omega> OrdmemD leD le_less_trans le_oexp' one_V_def succ_in_omega zero_in_omega)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have False if \"\\<nexists>M. \\<alpha> < \\<omega>\\<up>\\<alpha>hat * ord_of_nat M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \\<dagger>: \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat M \\<le> \\<alpha>\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * ord_of_nat M \\<le> \\<alpha>", "by (meson that Ord_\\<omega> Ord_linear2 Ord_mult Ord_oexp Ord_ord_of_nat \\<open>Ord \\<alpha>hat\\<close> step.hyps)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat ?M \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "have \"\\<not> \\<omega>\\<up>succ \\<alpha>hat \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat \\<le> \\<alpha>", "using Ord_mem_iff_lt \\<alpha>hat_def \\<open>Ord \\<alpha>hat\\<close> sma elts_succ"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  \\<alpha>hat \\<equiv>\n  \\<Squnion> {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  Ord \\<alpha>hat\n  small {\\<gamma> \\<in> ON. \\<omega> \\<up> \\<gamma> \\<le> \\<alpha>}\n  elts (ZFC_in_HOL.succ ?x) = insert ?x (elts ?x)\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat \\<le> \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<not> \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat \\<le> \\<alpha>", "have \"\\<alpha> < \\<omega>\\<up>succ \\<alpha>hat\""], ["proof (prove)\nusing this:\n  \\<not> \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat", "by (meson Ord_\\<omega> Ord_linear2 Ord_oexp Ord_succ \\<open>Ord \\<alpha>hat\\<close> step.hyps)"], ["proof (state)\nthis:\n  \\<alpha> < \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<alpha> < \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = \\<omega>\\<up>\\<alpha>hat * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat =\n    \\<omega> \\<up> \\<alpha>hat * \\<omega>", "using \\<open>Ord \\<alpha>hat\\<close> oexp_succ"], ["proof (prove)\nusing this:\n  Ord \\<alpha>hat\n  Ord ?\\<beta> \\<Longrightarrow>\n  ?\\<alpha> \\<up> ZFC_in_HOL.succ ?\\<beta> =\n  ?\\<alpha> \\<up> ?\\<beta> * ?\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat =\n    \\<omega> \\<up> \\<alpha>hat * \\<omega>", "by blast"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat =\n  \\<omega> \\<up> \\<alpha>hat * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> ZFC_in_HOL.succ \\<alpha>hat =\n  \\<omega> \\<up> \\<alpha>hat * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = Sup (range (\\<lambda>m. \\<omega>\\<up>\\<alpha>hat * ord_of_nat m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * \\<omega> =\n    (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m)", "by (simp add: mult_Limit) (auto simp: \\<omega>_def image_image)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * \\<omega> =\n  (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m)\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * \\<omega> =\n  (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m) \\<le> \\<alpha>", "using \\<dagger>"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat ?M \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m) \\<le> \\<alpha>", "by blast"], ["proof (state)\nthis:\n  (SUP m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<alpha>", "show False"], ["proof (prove)\nusing this:\n  \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>M.\n     \\<alpha> < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<nexists>M.\n     \\<alpha> < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M \\<Longrightarrow>\n  False", "obtain M where M: \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat M > \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<nexists>M.\n     \\<alpha> < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<alpha>\n        < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha> < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have bound: \"i \\<le> M\" if \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat i \\<le> \\<alpha>\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> M", "have \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat i < \\<omega>\\<up>\\<alpha>hat * ord_of_nat M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n    < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M", "using M dual_order.strict_trans2 that"], ["proof (prove)\nusing this:\n  \\<alpha> < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M\n  \\<lbrakk>?b < ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat i \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n    < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M", "by blast"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n  < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M\n\ngoal (1 subgoal):\n 1. i \\<le> M", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n  < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n  < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M\n\ngoal (1 subgoal):\n 1. i \\<le> M", "using \\<open>Ord \\<alpha>hat\\<close> less_V_def"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat i\n  < \\<omega> \\<up> \\<alpha>hat * ord_of_nat M\n  Ord \\<alpha>hat\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. i \\<le> M", "by auto"], ["proof (state)\nthis:\n  i \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat ?i\n  \\<le> \\<alpha> \\<Longrightarrow>\n  ?i \\<le> M\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "define mhat where \"mhat \\<equiv> Greatest (\\<lambda>m. \\<omega>\\<up>\\<alpha>hat * ord_of_nat m \\<le> \\<alpha>)\""], ["proof (state)\nthis:\n  mhat \\<equiv>\n  GREATEST m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have mhat_ge: \"m \\<le> mhat\" if \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat m \\<le> \\<alpha>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> mhat", "unfolding mhat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> (GREATEST m.\n                \\<omega> \\<up> \\<alpha>hat * ord_of_nat m \\<le> \\<alpha>)", "by (metis (mono_tags, lifting) Greatest_le_nat bound that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat ?m\n  \\<le> \\<alpha> \\<Longrightarrow>\n  ?m \\<le> mhat\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have mhat: \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat mhat \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat \\<le> \\<alpha>", "unfolding mhat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat *\n    ord_of_nat\n     (GREATEST m. \\<omega> \\<up> \\<alpha>hat * ord_of_nat m \\<le> \\<alpha>)\n    \\<le> \\<alpha>", "by (rule GreatestI_nat [where k=0 and b=M]) (use bound in auto)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat \\<le> \\<alpha>", "obtain \\<xi> where \"Ord \\<xi>\" \"\\<xi> \\<le> \\<alpha>\" and \\<xi>: \"\\<alpha> = \\<omega>\\<up>\\<alpha>hat * ord_of_nat mhat + \\<xi>\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<xi>.\n        \\<lbrakk>Ord \\<xi>; \\<xi> \\<le> \\<alpha>;\n         \\<alpha> =\n         \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat + \\<xi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_\\<omega> Ord_mult Ord_oexp Ord_ord_of_nat \\<open>Ord \\<alpha>hat\\<close> step.hyps le_Ord_diff)"], ["proof (state)\nthis:\n  Ord \\<xi>\n  \\<xi> \\<le> \\<alpha>\n  \\<alpha> = \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat + \\<xi>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "have False if \"\\<xi> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<xi> \\<ge> \\<omega>\\<up>\\<alpha>hat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat \\<le> \\<xi>", "by (simp add: le that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat \\<le> \\<xi>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>hat \\<le> \\<xi>", "obtain \\<zeta> where \"Ord \\<zeta>\" \"\\<zeta> \\<le> \\<xi>\" and \\<zeta>: \"\\<xi> = \\<omega>\\<up>\\<alpha>hat + \\<zeta>\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat \\<le> \\<xi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<zeta>.\n        \\<lbrakk>Ord \\<zeta>; \\<zeta> \\<le> \\<xi>;\n         \\<xi> = \\<omega> \\<up> \\<alpha>hat + \\<zeta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_\\<omega> Ord_oexp \\<open>Ord \\<alpha>hat\\<close> \\<open>Ord \\<xi>\\<close> le_Ord_diff)"], ["proof (state)\nthis:\n  Ord \\<zeta>\n  \\<zeta> \\<le> \\<xi>\n  \\<xi> = \\<omega> \\<up> \\<alpha>hat + \\<zeta>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Ord \\<zeta>\n  \\<zeta> \\<le> \\<xi>\n  \\<xi> = \\<omega> \\<up> \\<alpha>hat + \\<zeta>", "have \"\\<alpha> = \\<omega>\\<up>\\<alpha>hat * ord_of_nat mhat + \\<omega>\\<up>\\<alpha>hat + \\<zeta>\""], ["proof (prove)\nusing this:\n  Ord \\<zeta>\n  \\<zeta> \\<le> \\<xi>\n  \\<xi> = \\<omega> \\<up> \\<alpha>hat + \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<alpha> =\n    \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat +\n    \\<omega> \\<up> \\<alpha>hat +\n    \\<zeta>", "by (simp add: \\<xi> add.assoc)"], ["proof (state)\nthis:\n  \\<alpha> =\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat +\n  \\<omega> \\<up> \\<alpha>hat +\n  \\<zeta>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<alpha> =\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat +\n  \\<omega> \\<up> \\<alpha>hat +\n  \\<zeta>", "have \"\\<omega>\\<up>\\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<alpha> =\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat +\n  \\<omega> \\<up> \\<alpha>hat +\n  \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>", "by (metis add_le_cancel_left add.right_neutral le_0 mult_succ ord_of_nat.simps(2))"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>", "show False"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "using Suc_n_not_le_n mhat_ge"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat (Suc mhat) \\<le> \\<alpha>\n  \\<not> Suc ?n \\<le> ?n\n  \\<omega> \\<up> \\<alpha>hat * ord_of_nat ?m\n  \\<le> \\<alpha> \\<Longrightarrow>\n  ?m \\<le> mhat\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<xi> = \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<xi> = \\<alpha> \\<Longrightarrow> False", "have \\<xi>in\\<alpha>: \"\\<xi> \\<in> elts \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<xi> = \\<alpha> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<xi> \\<in> elts \\<alpha>", "using Ord_mem_iff_lt \\<open>Ord \\<xi>\\<close> \\<open>\\<xi> \\<le> \\<alpha>\\<close> less_V_def step.hyps"], ["proof (prove)\nusing this:\n  \\<xi> = \\<alpha> \\<Longrightarrow> False\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  Ord \\<xi>\n  \\<xi> \\<le> \\<alpha>\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<xi> \\<in> elts \\<alpha>", "by auto"], ["proof (state)\nthis:\n  \\<xi> \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"\\<xi> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<xi> = 0 \\<Longrightarrow> thesis\n 2. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<xi> = 0\n\ngoal (2 subgoals):\n 1. \\<xi> = 0 \\<Longrightarrow> thesis\n 2. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. list.set ?\\<alpha>s \\<subseteq> ON\n 2. list.set ?ms \\<subseteq> {0<..}\n 3. length ?\\<alpha>s = length ?ms\n 4. sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s\n 5. \\<alpha> = Cantor_sum ?\\<alpha>s ?ms", "show \"\\<alpha> = Cantor_sum [\\<alpha>hat] [mhat]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum [\\<alpha>hat] [mhat]", "by (simp add: True \\<xi>)"], ["proof (state)\nthis:\n  \\<alpha> = Cantor_sum [\\<alpha>hat] [mhat]\n\ngoal (4 subgoals):\n 1. list.set [\\<alpha>hat] \\<subseteq> ON\n 2. list.set [mhat] \\<subseteq> {0<..}\n 3. length [\\<alpha>hat] = length [mhat]\n 4. sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>hat]", "qed (use \\<xi> True \\<open>\\<alpha> \\<noteq> 0\\<close> \\<open>Ord \\<alpha>hat\\<close> in auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<xi> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "obtain \\<beta>s ns where sub: \"List.set \\<beta>s \\<subseteq> ON\" \"list.set ns \\<subseteq> {0<..}\"\n        and len_eq: \"length \\<beta>s = length ns\"\n        and dec: \"Cantor_dec \\<beta>s\"\n        and \\<xi>eq: \"\\<xi> = Cantor_sum \\<beta>s ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>s ns.\n        \\<lbrakk>list.set \\<beta>s \\<subseteq> ON;\n         list.set ns \\<subseteq> {0<..}; length \\<beta>s = length ns;\n         sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n         \\<xi> = Cantor_sum \\<beta>s ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step.IH [OF \\<xi>in\\<alpha>]"], ["proof (prove)\nusing this:\n  (\\<And>\\<alpha>s ms.\n      \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n       list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n       sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n       \\<xi> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>s ns.\n        \\<lbrakk>list.set \\<beta>s \\<subseteq> ON;\n         list.set ns \\<subseteq> {0<..}; length \\<beta>s = length ns;\n         sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n         \\<xi> = Cantor_sum \\<beta>s ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<xi> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<xi> = Cantor_sum \\<beta>s ns", "have \"length \\<beta>s > 0\" \"length ns > 0\""], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<xi> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. 0 < length \\<beta>s &&& 0 < length ns", "using False Cantor_sum.simps(1) \\<open>\\<xi> = Cantor_sum \\<beta>s ns\\<close>"], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<xi> = Cantor_sum \\<beta>s ns\n  \\<xi> \\<noteq> 0\n  Cantor_sum [] ?ms = 0\n  \\<xi> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. 0 < length \\<beta>s &&& 0 < length ns", "by auto"], ["proof (state)\nthis:\n  0 < length \\<beta>s\n  0 < length ns\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  0 < length \\<beta>s\n  0 < length ns", "obtain \\<beta>0 n0 \\<beta>s' ns' where \\<beta>0: \"\\<beta>s = \\<beta>0 # \\<beta>s'\" and \"Ord \\<beta>0\"\n        and n0: \"ns = n0 # ns'\" and \"n0 > 0\""], ["proof (prove)\nusing this:\n  0 < length \\<beta>s\n  0 < length ns\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>0 \\<beta>s' n0 ns'.\n        \\<lbrakk>\\<beta>s = \\<beta>0 # \\<beta>s'; Ord \\<beta>0;\n         ns = n0 # ns'; 0 < n0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sub"], ["proof (prove)\nusing this:\n  0 < length \\<beta>s\n  0 < length ns\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>0 \\<beta>s' n0 ns'.\n        \\<lbrakk>\\<beta>s = \\<beta>0 # \\<beta>s'; Ord \\<beta>0;\n         ns = n0 # ns'; 0 < n0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  Ord \\<beta>0\n  ns = n0 # ns'\n  0 < n0\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  Ord \\<beta>0\n  ns = n0 # ns'\n  0 < n0\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "have False if \"\\<beta>0 > \\<alpha>hat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>\\<up>\\<beta>0 \\<le> \\<omega>\\<up>\\<beta>0 * ord_of_nat n0 + u\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0\n    \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + u", "using \\<open>n0 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0\n    \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + u", "by (metis add_le_cancel_left Ord_ord_of_nat add.right_neutral dual_order.trans gr_implies_not_zero le_0 le_mult ord_of_eq_0_iff)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + ?u\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + ?u\n\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>\\<up>\\<beta>0 > \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < \\<omega> \\<up> \\<beta>0", "using that \\<open>Ord \\<beta>0\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>hat < \\<beta>0\n  Ord \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<omega> \\<up> \\<beta>0", "by (metis (no_types, lifting) Ord_\\<omega> Ord_linear2 Ord_oexp Sup_upper \\<alpha>hat_def leD mem_Collect_eq sma step.hyps)"], ["proof (state)\nthis:\n  \\<alpha> < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + ?u\n  \\<alpha> < \\<omega> \\<up> \\<beta>0", "have \"\\<xi> \\<ge> \\<omega>\\<up>\\<beta>0\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + ?u\n  \\<alpha> < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 \\<le> \\<xi>", "by (simp add: \\<xi>eq \\<beta>0 n0)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<xi>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<xi>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<xi>\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<alpha> < \\<omega>\\<up>\\<beta>0\\<close> \\<open>\\<xi> \\<le> \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<beta>0 \\<le> \\<xi>\n  \\<alpha> < \\<omega> \\<up> \\<beta>0\n  \\<xi> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>hat < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  Ord \\<beta>0\n  ns = n0 # ns'\n  0 < n0\n  \\<alpha>hat < \\<beta>0 \\<Longrightarrow> False", "have \"\\<beta>0 \\<le> \\<alpha>hat\""], ["proof (prove)\nusing this:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  Ord \\<beta>0\n  ns = n0 # ns'\n  0 < n0\n  \\<alpha>hat < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<beta>0 \\<le> \\<alpha>hat", "using Ord_linear2 \\<open>Ord \\<alpha>hat\\<close>"], ["proof (prove)\nusing this:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  Ord \\<beta>0\n  ns = n0 # ns'\n  0 < n0\n  \\<alpha>hat < \\<beta>0 \\<Longrightarrow> False\n  \\<lbrakk>Ord ?k; Ord ?l; ?k < ?l \\<Longrightarrow> ?thesis;\n   ?l \\<le> ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Ord \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<beta>0 \\<le> \\<alpha>hat", "by auto"], ["proof (state)\nthis:\n  \\<beta>0 \\<le> \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<beta>0 \\<le> \\<alpha>hat", "consider \"\\<beta>0 < \\<alpha>hat\" | \"\\<beta>0 = \\<alpha>hat\""], ["proof (prove)\nusing this:\n  \\<beta>0 \\<le> \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta>0 < \\<alpha>hat \\<Longrightarrow> thesis;\n     \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using dual_order.order_iff_strict"], ["proof (prove)\nusing this:\n  \\<beta>0 \\<le> \\<alpha>hat\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta>0 < \\<alpha>hat \\<Longrightarrow> thesis;\n     \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<beta>0 < \\<alpha>hat \\<Longrightarrow> ?thesis;\n   \\<beta>0 = \\<alpha>hat \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<xi> \\<noteq> 0 \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<beta>0 < \\<alpha>hat \\<Longrightarrow> ?thesis;\n   \\<beta>0 = \\<alpha>hat \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<beta>0 < \\<alpha>hat \\<Longrightarrow> ?thesis;\n   \\<beta>0 = \\<alpha>hat \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta>0 < \\<alpha>hat \\<Longrightarrow> thesis\n 2. \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \\<beta>0 < \\<alpha>hat\n\ngoal (2 subgoals):\n 1. \\<beta>0 < \\<alpha>hat \\<Longrightarrow> thesis\n 2. \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. list.set ?\\<alpha>s \\<subseteq> ON\n 2. list.set ?ms \\<subseteq> {0<..}\n 3. length ?\\<alpha>s = length ?ms\n 4. sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s\n 5. \\<alpha> = Cantor_sum ?\\<alpha>s ?ms", "show \"list.set (\\<alpha>hat#\\<beta>s) \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (\\<alpha>hat # \\<beta>s) \\<subseteq> ON", "using sub"], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. list.set (\\<alpha>hat # \\<beta>s) \\<subseteq> ON", "by (auto simp: \\<open>Ord \\<alpha>hat\\<close>)"], ["proof (state)\nthis:\n  list.set (\\<alpha>hat # \\<beta>s) \\<subseteq> ON\n\ngoal (4 subgoals):\n 1. list.set ?ms \\<subseteq> {0<..}\n 2. length (\\<alpha>hat # \\<beta>s) = length ?ms\n 3. sorted_wrt (\\<lambda>x y. y < x) (\\<alpha>hat # \\<beta>s)\n 4. \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) ?ms", "show \"list.set (mhat#ns) \\<subseteq> {0::nat<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (mhat # ns) \\<subseteq> {0<..}", "using sub"], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. list.set (mhat # ns) \\<subseteq> {0<..}", "using \\<open>\\<xi> = \\<alpha> \\<Longrightarrow> False\\<close> \\<xi>"], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ns \\<subseteq> {0<..}\n  \\<xi> = \\<alpha> \\<Longrightarrow> False\n  \\<alpha> = \\<omega> \\<up> \\<alpha>hat * ord_of_nat mhat + \\<xi>\n\ngoal (1 subgoal):\n 1. list.set (mhat # ns) \\<subseteq> {0<..}", "by fastforce"], ["proof (state)\nthis:\n  list.set (mhat # ns) \\<subseteq> {0<..}\n\ngoal (3 subgoals):\n 1. length (\\<alpha>hat # \\<beta>s) = length (mhat # ns)\n 2. sorted_wrt (\\<lambda>x y. y < x) (\\<alpha>hat # \\<beta>s)\n 3. \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) (mhat # ns)", "show \"Cantor_dec (\\<alpha>hat#\\<beta>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) (\\<alpha>hat # \\<beta>s)", "using that \\<open>\\<beta>0 < \\<alpha>hat\\<close> \\<open>Ord \\<alpha>hat\\<close> \\<open>Ord \\<beta>0\\<close> Ord_mem_iff_lt \\<beta>0 dec less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  \\<lbrakk>list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   \\<alpha> = Cantor_sum ?\\<alpha>s ?ms\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<beta>0 < \\<alpha>hat\n  Ord \\<alpha>hat\n  Ord \\<beta>0\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) (\\<alpha>hat # \\<beta>s)", "by (force simp: \\<beta>0 n0)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha>hat # \\<beta>s)\n\ngoal (2 subgoals):\n 1. length (\\<alpha>hat # \\<beta>s) = length (mhat # ns)\n 2. \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) (mhat # ns)", "show \"length (\\<alpha>hat#\\<beta>s) = length (mhat#ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (\\<alpha>hat # \\<beta>s) = length (mhat # ns)", "by (auto simp: len_eq)"], ["proof (state)\nthis:\n  length (\\<alpha>hat # \\<beta>s) = length (mhat # ns)\n\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) (mhat # ns)", "show \"\\<alpha> = Cantor_sum (\\<alpha>hat#\\<beta>s) (mhat#ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) (mhat # ns)", "by (simp add: \\<xi> \\<xi>eq \\<beta>0 n0)"], ["proof (state)\nthis:\n  \\<alpha> = Cantor_sum (\\<alpha>hat # \\<beta>s) (mhat # ns)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  \\<beta>0 = \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<beta>0 = \\<alpha>hat \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule step.prems)"], ["proof (state)\ngoal (5 subgoals):\n 1. list.set ?\\<alpha>s \\<subseteq> ON\n 2. list.set ?ms \\<subseteq> {0<..}\n 3. length ?\\<alpha>s = length ?ms\n 4. sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s\n 5. \\<alpha> = Cantor_sum ?\\<alpha>s ?ms", "show \"list.set \\<beta>s \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set \\<beta>s \\<subseteq> ON", "by (simp add: sub(1))"], ["proof (state)\nthis:\n  list.set \\<beta>s \\<subseteq> ON\n\ngoal (4 subgoals):\n 1. list.set ?ms \\<subseteq> {0<..}\n 2. length \\<beta>s = length ?ms\n 3. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n 4. \\<alpha> = Cantor_sum \\<beta>s ?ms", "show \"list.set ((n0+mhat)#ns') \\<subseteq> {0::nat<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set ((n0 + mhat) # ns') \\<subseteq> {0<..}", "using n0 sub(2)"], ["proof (prove)\nusing this:\n  ns = n0 # ns'\n  list.set ns \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. list.set ((n0 + mhat) # ns') \\<subseteq> {0<..}", "by auto"], ["proof (state)\nthis:\n  list.set ((n0 + mhat) # ns') \\<subseteq> {0<..}\n\ngoal (3 subgoals):\n 1. length \\<beta>s = length ((n0 + mhat) # ns')\n 2. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n 3. \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')", "show \"length (\\<beta>s::V list) = length ((n0+mhat)#ns')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<beta>s = length ((n0 + mhat) # ns')", "by (simp add: len_eq n0)"], ["proof (state)\nthis:\n  length \\<beta>s = length ((n0 + mhat) # ns')\n\ngoal (2 subgoals):\n 1. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n 2. \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')", "show \"Cantor_dec \\<beta>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s", "using that \\<beta>0 dec"], ["proof (prove)\nusing this:\n  \\<lbrakk>list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   \\<alpha> = Cantor_sum ?\\<alpha>s ?ms\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s", "by auto"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')", "show \"\\<alpha> = Cantor_sum \\<beta>s ((n0+mhat)#ns')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')", "using 2"], ["proof (prove)\nusing this:\n  \\<beta>0 = \\<alpha>hat\n\ngoal (1 subgoal):\n 1. \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')", "by (simp add: add_mult_distrib \\<beta>0 \\<xi> \\<xi>eq add.assoc add.commute n0 ord_of_nat_add)"], ["proof (state)\nthis:\n  \\<alpha> = Cantor_sum \\<beta>s ((n0 + mhat) # ns')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cantor_sum_0E:\n  assumes \"Cantor_sum \\<alpha>s ms = 0\" \"List.set \\<alpha>s \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length \\<alpha>s = length ms\"\n  shows \"\\<alpha>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = []", "using assms"], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s ms = 0\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n\ngoal (1 subgoal):\n 1. \\<alpha>s = []", "proof (induction \\<alpha>s arbitrary: ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>Cantor_sum [] ms = 0; list.set [] \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..}; length [] = length ms\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "case Nil"], ["proof (state)\nthis:\n  Cantor_sum [] ms = 0\n  list.set [] \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length [] = length ms\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>Cantor_sum [] ms = 0; list.set [] \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..}; length [] = length ms\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "then"], ["proof (chain)\npicking this:\n  Cantor_sum [] ms = 0\n  list.set [] \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length [] = length ms", "show ?case"], ["proof (prove)\nusing this:\n  Cantor_sum [] ms = 0\n  list.set [] \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length [] = length ms\n\ngoal (1 subgoal):\n 1. [] = []", "by auto"], ["proof (state)\nthis:\n  [] = []\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<lbrakk>Cantor_sum list ?ms = 0; list.set list \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length list = length ?ms\\<rbrakk>\n  \\<Longrightarrow> list = []\n  Cantor_sum (a # list) ms = 0\n  list.set (a # list) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length (a # list) = length ms\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Cantor_sum list ?ms = 0; list.set list \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length list = length ?ms\\<rbrakk>\n  \\<Longrightarrow> list = []\n  Cantor_sum (a # list) ms = 0\n  list.set (a # list) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length (a # list) = length ms", "obtain m ms' where \"ms = m#ms'\" \"m \\<noteq> 0\" \"list.set ms' \\<subseteq> {0<..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Cantor_sum list ?ms = 0; list.set list \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length list = length ?ms\\<rbrakk>\n  \\<Longrightarrow> list = []\n  Cantor_sum (a # list) ms = 0\n  list.set (a # list) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length (a # list) = length ms\n\ngoal (1 subgoal):\n 1. (\\<And>m ms'.\n        \\<lbrakk>ms = m # ms'; m \\<noteq> 0;\n         list.set ms' \\<subseteq> {0<..}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (metis Suc_length_conv greaterThan_iff insert_subset list.set(2))"], ["proof (state)\nthis:\n  ms = m # ms'\n  m \\<noteq> 0\n  list.set ms' \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>Cantor_sum \\<alpha>s ms = 0;\n                    list.set \\<alpha>s \\<subseteq> ON;\n                    list.set ms \\<subseteq> {0<..};\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> \\<alpha>s = [];\n        Cantor_sum (a # \\<alpha>s) ms = 0;\n        list.set (a # \\<alpha>s) \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..};\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> a # \\<alpha>s = []", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>Cantor_sum list ?ms = 0; list.set list \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length list = length ?ms\\<rbrakk>\n  \\<Longrightarrow> list = []\n  Cantor_sum (a # list) ms = 0\n  list.set (a # list) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length (a # list) = length ms\n  ms = m # ms'\n  m \\<noteq> 0\n  list.set ms' \\<subseteq> {0<..}", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Cantor_sum list ?ms = 0; list.set list \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length list = length ?ms\\<rbrakk>\n  \\<Longrightarrow> list = []\n  Cantor_sum (a # list) ms = 0\n  list.set (a # list) \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length (a # list) = length ms\n  ms = m # ms'\n  m \\<noteq> 0\n  list.set ms' \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. a # list = []", "by auto"], ["proof (state)\nthis:\n  a # list = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cantor_nf_unique_aux:\n  assumes \"Ord \\<alpha>\"\n    and \\<alpha>sON: \"List.set \\<alpha>s \\<subseteq> ON\"\n    and \\<beta>sON: \"List.set \\<beta>s \\<subseteq> ON\"\n    and ms: \"list.set ms \\<subseteq> {0<..}\"\n    and ns: \"list.set ns \\<subseteq> {0<..}\"\n    and mseq: \"length \\<alpha>s = length ms\"\n    and nseq: \"length \\<beta>s = length ns\"\n    and \\<alpha>sdec: \"Cantor_dec \\<alpha>s\"\n    and \\<beta>sdec: \"Cantor_dec \\<beta>s\"\n    and \\<alpha>seq: \"\\<alpha> = Cantor_sum \\<alpha>s ms\"\n    and \\<beta>seq: \"\\<alpha> = Cantor_sum \\<beta>s ns\"\n  shows \"\\<alpha>s = \\<beta>s \\<and> ms = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "using assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "proof (induction \\<alpha> arbitrary: \\<alpha>s ms \\<beta>s ns rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<alpha>s ms \\<beta>s ns.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<alpha>s ms \\<beta>s ns.\n           \\<lbrakk>y \\<in> elts x; list.set \\<alpha>s \\<subseteq> ON;\n            list.set \\<beta>s \\<subseteq> ON;\n            list.set ms \\<subseteq> {0<..}; list.set ns \\<subseteq> {0<..};\n            length \\<alpha>s = length ms; length \\<beta>s = length ns;\n            sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n            sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n            y = Cantor_sum \\<alpha>s ms; y = Cantor_sum \\<beta>s ns\\<rbrakk>\n           \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns;\n        list.set \\<alpha>s \\<subseteq> ON; list.set \\<beta>s \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..}; list.set ns \\<subseteq> {0<..};\n        length \\<alpha>s = length ms; length \\<beta>s = length ns;\n        sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n        sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n        x = Cantor_sum \\<alpha>s ms; x = Cantor_sum \\<beta>s ns\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns", "case (step \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>; list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?\\<beta>s \\<subseteq> ON; list.set ?ms \\<subseteq> {0<..};\n   list.set ?ns \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   length ?\\<beta>s = length ?ns;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<beta>s;\n   ?y = Cantor_sum ?\\<alpha>s ?ms; ?y = Cantor_sum ?\\<beta>s ?ns\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha>s = ?\\<beta>s \\<and> ?ms = ?ns\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. \\<And>x \\<alpha>s ms \\<beta>s ns.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<alpha>s ms \\<beta>s ns.\n           \\<lbrakk>y \\<in> elts x; list.set \\<alpha>s \\<subseteq> ON;\n            list.set \\<beta>s \\<subseteq> ON;\n            list.set ms \\<subseteq> {0<..}; list.set ns \\<subseteq> {0<..};\n            length \\<alpha>s = length ms; length \\<beta>s = length ns;\n            sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n            sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n            y = Cantor_sum \\<alpha>s ms; y = Cantor_sum \\<beta>s ns\\<rbrakk>\n           \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns;\n        list.set \\<alpha>s \\<subseteq> ON; list.set \\<beta>s \\<subseteq> ON;\n        list.set ms \\<subseteq> {0<..}; list.set ns \\<subseteq> {0<..};\n        length \\<alpha>s = length ms; length \\<beta>s = length ns;\n        sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n        sorted_wrt (\\<lambda>x y. y < x) \\<beta>s;\n        x = Cantor_sum \\<alpha>s ms; x = Cantor_sum \\<beta>s ns\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "proof (cases \"\\<alpha> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "case True"], ["proof (state)\nthis:\n  \\<alpha> = 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s \\<and> ms = ns\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "using step.prems"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "by (metis Cantor_sum_0E length_0_conv)"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s \\<and> ms = ns\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<noteq> 0", "obtain \\<alpha>0 \\<alpha>s' \\<beta>0 \\<beta>s' where \\<alpha>s: \"\\<alpha>s = \\<alpha>0 # \\<alpha>s'\" and \\<beta>s: \"\\<beta>s = \\<beta>0 # \\<beta>s'\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>0 \\<alpha>s' \\<beta>0 \\<beta>s'.\n        \\<lbrakk>\\<alpha>s = \\<alpha>0 # \\<alpha>s';\n         \\<beta>s = \\<beta>0 # \\<beta>s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Cantor_sum.simps(1) min_list.cases step.prems(9,10))"], ["proof (state)\nthis:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'", "have ON: \"Ord \\<alpha>0\" \"list.set \\<alpha>s' \\<subseteq> ON\" \"Ord \\<beta>0\" \"list.set \\<beta>s' \\<subseteq> ON\""], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n\ngoal (1 subgoal):\n 1. (Ord \\<alpha>0 &&& list.set \\<alpha>s' \\<subseteq> ON) &&&\n    Ord \\<beta>0 &&& list.set \\<beta>s' \\<subseteq> ON", "using \\<alpha>s \\<beta>s step.prems(1,2)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. (Ord \\<alpha>0 &&& list.set \\<alpha>s' \\<subseteq> ON) &&&\n    Ord \\<beta>0 &&& list.set \\<beta>s' \\<subseteq> ON", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON", "obtain m0 ms' n0 ns' where ms: \"ms = m0 # ms'\" and ns: \"ns = n0 # ns'\""], ["proof (prove)\nusing this:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. (\\<And>m0 ms' n0 ns'.\n        \\<lbrakk>ms = m0 # ms'; ns = n0 # ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<alpha>s \\<beta>s length_0_conv list.distinct(1) list.exhaust step.prems(5,6))"], ["proof (state)\nthis:\n  ms = m0 # ms'\n  ns = n0 # ns'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  ms = m0 # ms'\n  ns = n0 # ns'", "have nz: \"m0 \\<noteq> 0\" \"list.set ms' \\<subseteq> {0<..}\" \"n0 \\<noteq> 0\" \"list.set ns' \\<subseteq> {0<..}\""], ["proof (prove)\nusing this:\n  ms = m0 # ms'\n  ns = n0 # ns'\n\ngoal (1 subgoal):\n 1. (m0 \\<noteq> 0 &&& list.set ms' \\<subseteq> {0<..}) &&&\n    n0 \\<noteq> 0 &&& list.set ns' \\<subseteq> {0<..}", "using ms ns step.prems(3,4)"], ["proof (prove)\nusing this:\n  ms = m0 # ms'\n  ns = n0 # ns'\n  ms = m0 # ms'\n  ns = n0 # ns'\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. (m0 \\<noteq> 0 &&& list.set ms' \\<subseteq> {0<..}) &&&\n    n0 \\<noteq> 0 &&& list.set ns' \\<subseteq> {0<..}", "by auto"], ["proof (state)\nthis:\n  m0 \\<noteq> 0\n  list.set ms' \\<subseteq> {0<..}\n  n0 \\<noteq> 0\n  list.set ns' \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "have False if \"\\<beta>0 < \\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have Ordc: \"Ord (Cantor_sum \\<beta>s ns)\" \"Ord (\\<omega>\\<up>\\<alpha>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<beta>s ns) &&& Ord (\\<omega> \\<up> \\<alpha>0)", "using Ord_oexp \\<open>Ord \\<alpha>0\\<close>  step.hyps step.prems(10)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  Ord \\<alpha>0\n  Ord \\<alpha>\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<beta>s ns) &&& Ord (\\<omega> \\<up> \\<alpha>0)", "by blast+"], ["proof (state)\nthis:\n  Ord (Cantor_sum \\<beta>s ns)\n  Ord (\\<omega> \\<up> \\<alpha>0)\n\ngoal (1 subgoal):\n 1. False", "have *: \"Cantor_sum \\<beta>s ns < \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<beta>s ns < \\<omega> \\<up> \\<alpha>0", "using step.prems(2-6) \\<open>Ord \\<alpha>0\\<close> \\<open>Cantor_dec \\<beta>s\\<close> that \\<beta>s cnf_2"], ["proof (prove)\nusing this:\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  Ord \\<alpha>0\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<beta>0 < \\<alpha>0\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<beta>s ns < \\<omega> \\<up> \\<alpha>0", "by (metis Cantor_dec_Cons_iff insert_subset list.set(2) mem_Collect_eq)"], ["proof (state)\nthis:\n  Cantor_sum \\<beta>s ns < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Cantor_sum \\<beta>s ns < \\<omega> \\<up> \\<alpha>0", "show False"], ["proof (prove)\nusing this:\n  Cantor_sum \\<beta>s ns < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "by (metis Cantor_sum_Cons Ord_mem_iff_lt Ord_ord_of_nat Ordc \\<alpha>s \\<open>m0 \\<noteq> 0\\<close> * le_mult ms not_add_mem_right ord_of_eq_0 step.prems(9,10) vsubsetD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "moreover"], ["proof (state)\nthis:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "have False if \"\\<alpha>0 < \\<beta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have Ordc: \"Ord (Cantor_sum \\<alpha>s ms)\" \"Ord (\\<omega>\\<up>\\<beta>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<alpha>s ms) &&& Ord (\\<omega> \\<up> \\<beta>0)", "using Ord_oexp \\<open>Ord \\<beta>0\\<close>  step.hyps step.prems(9)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  Ord \\<beta>0\n  Ord \\<alpha>\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<alpha>s ms) &&& Ord (\\<omega> \\<up> \\<beta>0)", "by blast+"], ["proof (state)\nthis:\n  Ord (Cantor_sum \\<alpha>s ms)\n  Ord (\\<omega> \\<up> \\<beta>0)\n\ngoal (1 subgoal):\n 1. False", "have *: \"Cantor_sum \\<alpha>s ms < \\<omega>\\<up>\\<beta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<beta>0", "using step.prems(1-5) \\<open>Ord \\<beta>0\\<close> \\<open>Cantor_dec \\<alpha>s\\<close> that \\<alpha>s cnf_2"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  Ord \\<beta>0\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<alpha>0 < \\<beta>0\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<beta>0", "by (metis Cantor_dec_Cons_iff \\<beta>s insert_subset list.set(2))"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<beta>0", "show False"], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s ms < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "by (metis Cantor_sum_Cons Ord_mem_iff_lt Ord_ord_of_nat Ordc \\<beta>s \\<open>n0 \\<noteq> 0\\<close> * le_mult not_add_mem_right ns ord_of_eq_0 step.prems(9,10) vsubsetD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "ultimately"], ["proof (chain)\npicking this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False", "have 1: \"\\<alpha>0 = \\<beta>0\""], ["proof (prove)\nusing this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha>0 = \\<beta>0", "using Ord_linear_lt \\<open>Ord \\<alpha>0\\<close> \\<open>Ord \\<beta>0\\<close>"], ["proof (prove)\nusing this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n  \\<lbrakk>Ord ?k; Ord ?l; ?k < ?l \\<Longrightarrow> ?thesis;\n   ?k = ?l \\<Longrightarrow> ?thesis;\n   ?l < ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Ord \\<alpha>0\n  Ord \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha>0 = \\<beta>0", "by blast"], ["proof (state)\nthis:\n  \\<alpha>0 = \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "have False if \"m0 < n0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>\\<up>\\<alpha>0 > Cantor_sum \\<alpha>s' ms'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0", "using \\<alpha>s \\<open>list.set ms' \\<subseteq> {0<..}\\<close> cnf_2 ms step.prems(1,5,7)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  list.set ms' \\<subseteq> {0<..}\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n  ms = m0 # ms'\n  list.set \\<alpha>s \\<subseteq> ON\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0", "have \"\\<alpha> < \\<omega>\\<up>\\<alpha>0 * ord_of_nat m0 + \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0", "by (simp add: \\<alpha>s ms step.prems(9))"], ["proof (state)\nthis:\n  \\<alpha>\n  < \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<alpha>\n  < \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = \\<omega>\\<up>\\<alpha>0 * ord_of_nat (Suc m0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0 =\n    \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)", "by (simp add: mult_succ)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0 =\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 + \\<omega> \\<up> \\<alpha>0 =\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<alpha>0 * ord_of_nat n0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)\n    \\<le> \\<omega> \\<up> \\<alpha>0 * ord_of_nat n0", "by (meson Ord_\\<omega> Ord_oexp Ord_ord_of_nat Suc_leI \\<open>Ord \\<alpha>0\\<close> mult_cancel_le_iff ord_of_nat_mono_iff that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)\n  \\<le> \\<omega> \\<up> \\<alpha>0 * ord_of_nat n0\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat (Suc m0)\n  \\<le> \\<omega> \\<up> \\<alpha>0 * ord_of_nat n0\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 * ord_of_nat n0 \\<le> \\<alpha>", "by (metis Cantor_sum_Cons add_le_cancel_left \\<beta>s \\<open>\\<alpha>0 = \\<beta>0\\<close> add.right_neutral le_0 ns step.prems(10))"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * ord_of_nat n0 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<alpha>", "show False"], ["proof (prove)\nusing this:\n  \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m0 < n0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "moreover"], ["proof (state)\nthis:\n  m0 < n0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "have False if \"n0 < m0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>\\<up>\\<beta>0 > Cantor_sum \\<beta>s' ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<beta>s' ns' < \\<omega> \\<up> \\<beta>0", "using \\<beta>s \\<open>list.set ns' \\<subseteq> {0<..}\\<close> cnf_2 ns step.prems(2,6,8)"], ["proof (prove)\nusing this:\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  list.set ns' \\<subseteq> {0<..}\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n  ns = n0 # ns'\n  list.set \\<beta>s \\<subseteq> ON\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<beta>s' ns' < \\<omega> \\<up> \\<beta>0", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<beta>s' ns' < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Cantor_sum \\<beta>s' ns' < \\<omega> \\<up> \\<beta>0", "have \"\\<alpha> < \\<omega>\\<up>\\<beta>0 * ord_of_nat n0 + \\<omega>\\<up>\\<beta>0\""], ["proof (prove)\nusing this:\n  Cantor_sum \\<beta>s' ns' < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha>\n    < \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0", "by (simp add: \\<beta>s ns step.prems(10))"], ["proof (state)\nthis:\n  \\<alpha>\n  < \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<alpha>\n  < \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = \\<omega>\\<up>\\<beta>0 * ord_of_nat (Suc n0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0 =\n    \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)", "by (simp add: mult_succ)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0 =\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat n0 + \\<omega> \\<up> \\<beta>0 =\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<beta>0 * ord_of_nat m0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)\n    \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat m0", "by (meson Ord_\\<omega> Ord_oexp Ord_ord_of_nat Suc_leI \\<open>Ord \\<beta>0\\<close> mult_cancel_le_iff ord_of_nat_mono_iff that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)\n  \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat m0\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat (Suc n0)\n  \\<le> \\<omega> \\<up> \\<beta>0 * ord_of_nat m0\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 * ord_of_nat m0 \\<le> \\<alpha>", "by (metis Cantor_sum_Cons add_le_cancel_left \\<alpha>s \\<open>\\<alpha>0 = \\<beta>0\\<close> add.right_neutral le_0 ms step.prems(9))"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * ord_of_nat m0 \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<alpha>", "show False"], ["proof (prove)\nusing this:\n  \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n0 < m0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "ultimately"], ["proof (chain)\npicking this:\n  m0 < n0 \\<Longrightarrow> False\n  n0 < m0 \\<Longrightarrow> False", "have 2: \"m0 = n0\""], ["proof (prove)\nusing this:\n  m0 < n0 \\<Longrightarrow> False\n  n0 < m0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. m0 = n0", "using nat_neq_iff"], ["proof (prove)\nusing this:\n  m0 < n0 \\<Longrightarrow> False\n  n0 < m0 \\<Longrightarrow> False\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. m0 = n0", "by blast"], ["proof (state)\nthis:\n  m0 = n0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "have \"\\<alpha>s' = \\<beta>s' \\<and> ms' = ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s' = \\<beta>s' \\<and> ms' = ns'", "proof (rule step.IH)"], ["proof (state)\ngoal (11 subgoals):\n 1. ?y \\<in> elts \\<alpha>\n 2. list.set \\<alpha>s' \\<subseteq> ON\n 3. list.set \\<beta>s' \\<subseteq> ON\n 4. list.set ms' \\<subseteq> {0<..}\n 5. list.set ns' \\<subseteq> {0<..}\n 6. length \\<alpha>s' = length ms'\n 7. length \\<beta>s' = length ns'\n 8. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 9. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 10. ?y = Cantor_sum \\<alpha>s' ms'\nA total of 11 subgoals...", "have \"Cantor_sum \\<alpha>s' ms' < \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0", "using \\<alpha>s cnf_2 ms nz(2) step.prems(1) step.prems(5) step.prems(7)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n  ms = m0 # ms'\n  list.set ms' \\<subseteq> {0<..}\n  list.set \\<alpha>s \\<subseteq> ON\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0\n\ngoal (11 subgoals):\n 1. ?y \\<in> elts \\<alpha>\n 2. list.set \\<alpha>s' \\<subseteq> ON\n 3. list.set \\<beta>s' \\<subseteq> ON\n 4. list.set ms' \\<subseteq> {0<..}\n 5. list.set ns' \\<subseteq> {0<..}\n 6. length \\<alpha>s' = length ms'\n 7. length \\<beta>s' = length ns'\n 8. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 9. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 10. ?y = Cantor_sum \\<alpha>s' ms'\nA total of 11 subgoals...", "also"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>0\n\ngoal (11 subgoals):\n 1. ?y \\<in> elts \\<alpha>\n 2. list.set \\<alpha>s' \\<subseteq> ON\n 3. list.set \\<beta>s' \\<subseteq> ON\n 4. list.set ms' \\<subseteq> {0<..}\n 5. list.set ns' \\<subseteq> {0<..}\n 6. length \\<alpha>s' = length ms'\n 7. length \\<beta>s' = length ns'\n 8. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 9. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 10. ?y = Cantor_sum \\<alpha>s' ms'\nA total of 11 subgoals...", "have \"\\<dots> \\<le> Cantor_sum \\<alpha>s ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 \\<le> Cantor_sum \\<alpha>s ms", "apply (simp add: \\<alpha>s \\<beta>s ms ns)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0\n    \\<le> \\<omega> \\<up> \\<alpha>0 * ord_of_nat m0 +\n          Cantor_sum \\<alpha>s' ms'", "by (metis Cantor_sum_Cons add_less_cancel_left ON(1) Ord_\\<omega> Ord_linear2 Ord_oexp Ord_ord_of_nat \\<alpha>s add.right_neutral dual_order.strict_trans1 le_mult ms not_less_0 nz(1) ord_of_eq_0 step.hyps step.prems(9))"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 \\<le> Cantor_sum \\<alpha>s ms\n\ngoal (11 subgoals):\n 1. ?y \\<in> elts \\<alpha>\n 2. list.set \\<alpha>s' \\<subseteq> ON\n 3. list.set \\<beta>s' \\<subseteq> ON\n 4. list.set ms' \\<subseteq> {0<..}\n 5. list.set ns' \\<subseteq> {0<..}\n 6. length \\<alpha>s' = length ms'\n 7. length \\<beta>s' = length ns'\n 8. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 9. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 10. ?y = Cantor_sum \\<alpha>s' ms'\nA total of 11 subgoals...", "finally"], ["proof (chain)\npicking this:\n  Cantor_sum \\<alpha>s' ms' < Cantor_sum \\<alpha>s ms", "show \"Cantor_sum \\<alpha>s' ms' \\<in> elts \\<alpha>\""], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s' ms' < Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' \\<in> elts \\<alpha>", "using ON(2) Ord_Cantor_sum Ord_mem_iff_lt step.hyps step.prems(9)"], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s' ms' < Cantor_sum \\<alpha>s ms\n  list.set \\<alpha>s' \\<subseteq> ON\n  list.set ?\\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n  Ord (Cantor_sum ?\\<alpha>s ?ms)\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  Ord \\<alpha>\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' \\<in> elts \\<alpha>", "by blast"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' \\<in> elts \\<alpha>\n\ngoal (10 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. list.set ms' \\<subseteq> {0<..}\n 4. list.set ns' \\<subseteq> {0<..}\n 5. length \\<alpha>s' = length ms'\n 6. length \\<beta>s' = length ns'\n 7. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 8. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 9. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<alpha>s' ms'\n 10. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "show \"length \\<alpha>s' = length ms'\" \"length \\<beta>s' = length ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length \\<alpha>s' = length ms' &&& length \\<beta>s' = length ns'", "using \\<alpha>s ms \\<beta>s ns step.prems"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  ms = m0 # ms'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  ns = n0 # ns'\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. length \\<alpha>s' = length ms' &&& length \\<beta>s' = length ns'", "by auto"], ["proof (state)\nthis:\n  length \\<alpha>s' = length ms'\n  length \\<beta>s' = length ns'\n\ngoal (8 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. list.set ms' \\<subseteq> {0<..}\n 4. list.set ns' \\<subseteq> {0<..}\n 5. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n 6. sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n 7. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<alpha>s' ms'\n 8. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "show \"Cantor_dec \\<alpha>s'\" \"Cantor_dec \\<beta>s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s' &&&\n    sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'", "using \\<alpha>s \\<beta>s step.prems(7,8)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s' &&&\n    sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'", "by auto"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s'\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s'\n\ngoal (6 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. list.set ms' \\<subseteq> {0<..}\n 4. list.set ns' \\<subseteq> {0<..}\n 5. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<alpha>s' ms'\n 6. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "have \"Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns", "using step.prems(9,10)"], ["proof (prove)\nusing this:\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n  \\<alpha> = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\n\ngoal (6 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. list.set ms' \\<subseteq> {0<..}\n 4. list.set ns' \\<subseteq> {0<..}\n 5. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<alpha>s' ms'\n 6. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "then"], ["proof (chain)\npicking this:\n  Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns", "show \"Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'\""], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "using 1 2"], ["proof (prove)\nusing this:\n  Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\n  \\<alpha>0 = \\<beta>0\n  m0 = n0\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'", "by (simp add: \\<alpha>s \\<beta>s ms ns)"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<beta>s' ns'\n\ngoal (5 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. list.set ms' \\<subseteq> {0<..}\n 4. list.set ns' \\<subseteq> {0<..}\n 5. Cantor_sum \\<alpha>s' ms' = Cantor_sum \\<alpha>s' ms'", "qed (use ON nz in auto)"], ["proof (state)\nthis:\n  \\<alpha>s' = \\<beta>s' \\<and> ms' = ns'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    \\<alpha>s = \\<beta>s \\<and> ms = ns", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s' = \\<beta>s' \\<and> ms' = ns'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>s' = \\<beta>s' \\<and> ms' = ns'\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "using 1 2"], ["proof (prove)\nusing this:\n  \\<alpha>s' = \\<beta>s' \\<and> ms' = ns'\n  \\<alpha>0 = \\<beta>0\n  m0 = n0\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "by (simp add: \\<alpha>s \\<beta>s ms ns)"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s \\<and> ms = ns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s \\<and> ms = ns\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition Cantor_nf_unique:\n  assumes \"Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\"\n    and \\<alpha>sON: \"List.set \\<alpha>s \\<subseteq> ON\"\n    and \\<beta>sON: \"List.set \\<beta>s \\<subseteq> ON\"\n    and ms: \"list.set ms \\<subseteq> {0<..}\"\n    and ns: \"list.set ns \\<subseteq> {0<..}\"\n    and mseq: \"length \\<alpha>s = length ms\"\n    and nseq: \"length \\<beta>s = length ns\"\n    and \\<alpha>sdec: \"Cantor_dec \\<alpha>s\"\n    and \\<beta>sdec: \"Cantor_dec \\<beta>s\"\n  shows \"\\<alpha>s = \\<beta>s \\<and> ms = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "using Cantor_nf_unique_aux Ord_Cantor_sum assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?\\<beta>s \\<subseteq> ON; list.set ?ms \\<subseteq> {0<..};\n   list.set ?ns \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   length ?\\<beta>s = length ?ns;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<alpha>s;\n   sorted_wrt (\\<lambda>x y. y < x) ?\\<beta>s;\n   ?\\<alpha> = Cantor_sum ?\\<alpha>s ?ms;\n   ?\\<alpha> = Cantor_sum ?\\<beta>s ?ns\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha>s = ?\\<beta>s \\<and> ?ms = ?ns\n  list.set ?\\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n  Ord (Cantor_sum ?\\<alpha>s ?ms)\n  Cantor_sum \\<alpha>s ms = Cantor_sum \\<beta>s ns\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  list.set ns \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  length \\<beta>s = length ns\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y < x) \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s \\<and> ms = ns", "by auto"], ["", "lemma less_\\<omega>_power:\n  assumes \"Ord \\<alpha>1\" \"Ord \\<beta>\"\n    and \\<alpha>2: \"\\<alpha>2 \\<in> elts \\<alpha>1\" and \\<beta>: \"\\<beta> < \\<omega>\\<up>\\<alpha>2\"\n    and \"m1 > 0\" \"m2 > 0\"\n  shows \"\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + \\<beta> < \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + (\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + \\<beta>)\"\n        (is \"?lhs < ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "obtain oo: \"Ord (\\<omega>\\<up>\\<alpha>1)\" \"Ord (\\<omega>\\<up>\\<alpha>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord (\\<omega> \\<up> \\<alpha>1);\n      Ord (\\<omega> \\<up> \\<alpha>2)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_in_Ord Ord_oexp assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  Ord \\<alpha>1\n  Ord \\<beta>\n  \\<alpha>2 \\<in> elts \\<alpha>1\n  \\<beta> < \\<omega> \\<up> \\<alpha>2\n  0 < m1\n  0 < m2\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord (\\<omega> \\<up> \\<alpha>1);\n      Ord (\\<omega> \\<up> \\<alpha>2)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "moreover"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "obtain \"ord_of_nat m2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ord_of_nat m2 \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ord_of_eq_0"], ["proof (prove)\nusing this:\n  Ord \\<alpha>1\n  Ord \\<beta>\n  \\<alpha>2 \\<in> elts \\<alpha>1\n  \\<beta> < \\<omega> \\<up> \\<alpha>2\n  0 < m1\n  0 < m2\n  ord_of_nat ?j = 0 \\<Longrightarrow> ?j = 0\n\ngoal (1 subgoal):\n 1. (ord_of_nat m2 \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ord_of_nat m2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "ultimately"], ["proof (chain)\npicking this:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n  ord_of_nat m2 \\<noteq> 0", "have \"\\<beta> < \\<omega>\\<up>\\<alpha>2 * ord_of_nat m2\""], ["proof (prove)\nusing this:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n  ord_of_nat m2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2", "by (meson Ord_ord_of_nat \\<beta> dual_order.strict_trans1 le_mult)"], ["proof (state)\nthis:\n  \\<beta> < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "with oo assms"], ["proof (chain)\npicking this:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n  Ord \\<alpha>1\n  Ord \\<beta>\n  \\<alpha>2 \\<in> elts \\<alpha>1\n  \\<beta> < \\<omega> \\<up> \\<alpha>2\n  0 < m1\n  0 < m2\n  \\<beta> < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2", "have \"?lhs \\<noteq> ?rhs\""], ["proof (prove)\nusing this:\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n  Ord \\<alpha>1\n  Ord \\<beta>\n  \\<alpha>2 \\<in> elts \\<alpha>1\n  \\<beta> < \\<omega> \\<up> \\<alpha>2\n  0 < m1\n  0 < m2\n  \\<beta> < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta> \\<noteq>\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "by (metis Ord_mult Ord_ord_of_nat add_strict_mono add.assoc cnf_1 not_add_less_right oo)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta> \\<noteq>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta> \\<noteq>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta> \\<noteq>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)", "by (simp add: add_le_left \\<open>Ord \\<beta>\\<close> less_V_def oo)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cantor_sum_ge:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" \"length ms > 0\"\n  shows \"\\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha>#\\<alpha>s) ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "obtain m ns where ms: \"ms = Cons m ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m ns. ms = m # ns \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) strict_sorted.cases"], ["proof (prove)\nusing this:\n  0 < length ms\n  \\<lbrakk>?x = [] \\<Longrightarrow> ?P;\n   \\<And>x ys. ?x = x # ys \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>m ns. ms = m # ns \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ms = m # ns\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "then"], ["proof (chain)\npicking this:\n  ms = m # ns", "have \"\\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m\""], ["proof (prove)\nusing this:\n  ms = m # ns\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m", "using assms(2) le_mult"], ["proof (prove)\nusing this:\n  ms = m # ns\n  list.set ms \\<subseteq> {0<..}\n  \\<lbrakk>Ord ?\\<beta>; ?\\<beta> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<le> ?\\<alpha> * ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "using dual_order.trans ms"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha> \\<le> \\<omega> \\<up> \\<alpha> * ord_of_nat m\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ms = m # ns\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> \\<le> Cantor_sum (\\<alpha> # \\<alpha>s) ms\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Simplified Cantor normal form\\<close>"], ["", "text \\<open>No coefficients, and the exponents decreasing non-strictly\\<close>"], ["", "fun \\<omega>_sum  where\n  \\<omega>_sum_Nil: \"\\<omega>_sum [] = 0\"\n| \\<omega>_sum_Cons: \"\\<omega>_sum (\\<alpha>#\\<alpha>s) = (\\<omega>\\<up>\\<alpha>) + \\<omega>_sum \\<alpha>s\""], ["", "abbreviation \\<omega>_dec :: \"V list \\<Rightarrow> bool\" where\n  \"\\<omega>_dec \\<equiv> sorted_wrt (\\<ge>)\""], ["", "lemma Ord_\\<omega>_sum [simp]: \"List.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow> Ord (\\<omega>_sum \\<alpha>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set \\<alpha>s \\<subseteq> ON \\<Longrightarrow>\n    Ord (\\<omega>_sum \\<alpha>s)", "by (induction \\<alpha>s) auto"], ["", "lemma \\<omega>_dec_Cons_iff [simp]: \"\\<omega>_dec (\\<alpha>#\\<beta>#\\<beta>s) \\<longleftrightarrow> \\<beta> \\<le> \\<alpha> \\<and> \\<omega>_dec (\\<beta>#\\<beta>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<beta>s) =\n    (\\<beta> \\<le> \\<alpha> \\<and>\n     sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<beta> # \\<beta>s))", "by auto"], ["", "lemma \\<omega>_sum_0E:\n  assumes \"\\<omega>_sum \\<alpha>s = 0\" \"List.set \\<alpha>s \\<subseteq> ON\"\n  shows \"\\<alpha>s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = []", "using assms"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s = 0\n  list.set \\<alpha>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<alpha>s = []", "by (induction \\<alpha>s) auto"], ["", "fun \\<omega>_of_Cantor where\n  \\<omega>_of_Cantor_Nil: \"\\<omega>_of_Cantor [] ms = []\"\n| \\<omega>_of_Cantor_Nil2: \"\\<omega>_of_Cantor (\\<alpha>#\\<alpha>s) [] = []\"\n| \\<omega>_of_Cantor_Cons: \"\\<omega>_of_Cantor (\\<alpha>#\\<alpha>s) (m#ms) = replicate m \\<alpha> @ \\<omega>_of_Cantor \\<alpha>s ms\""], ["", "lemma \\<omega>_sum_append [simp]: \"\\<omega>_sum (xs @ ys) = \\<omega>_sum xs + \\<omega>_sum ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum (xs @ ys) = \\<omega>_sum xs + \\<omega>_sum ys", "by (induction xs) (auto simp: add.assoc)"], ["", "lemma \\<omega>_sum_replicate [simp]: \"\\<omega>_sum (replicate m a) = \\<omega> \\<up> a * ord_of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum (replicate m a) = \\<omega> \\<up> a * ord_of_nat m", "by (induction m) (auto simp: mult_succ simp flip: replicate_append_same)"], ["", "lemma \\<omega>_sum_of_Cantor [simp]: \"\\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ms) = Cantor_sum \\<alpha>s ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ms) = Cantor_sum \\<alpha>s ms", "proof (induction \\<alpha>s arbitrary: ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms. \\<omega>_sum (\\<omega>_of_Cantor [] ms) = Cantor_sum [] ms\n 2. \\<And>a \\<alpha>s ms.\n       (\\<And>ms.\n           \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ms) =\n           Cantor_sum \\<alpha>s ms) \\<Longrightarrow>\n       \\<omega>_sum (\\<omega>_of_Cantor (a # \\<alpha>s) ms) =\n       Cantor_sum (a # \\<alpha>s) ms", "case (Cons a \\<alpha>s ms)"], ["proof (state)\nthis:\n  \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ?ms) = Cantor_sum \\<alpha>s ?ms\n\ngoal (2 subgoals):\n 1. \\<And>ms. \\<omega>_sum (\\<omega>_of_Cantor [] ms) = Cantor_sum [] ms\n 2. \\<And>a \\<alpha>s ms.\n       (\\<And>ms.\n           \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ms) =\n           Cantor_sum \\<alpha>s ms) \\<Longrightarrow>\n       \\<omega>_sum (\\<omega>_of_Cantor (a # \\<alpha>s) ms) =\n       Cantor_sum (a # \\<alpha>s) ms", "then"], ["proof (chain)\npicking this:\n  \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ?ms) = Cantor_sum \\<alpha>s ?ms", "show ?case"], ["proof (prove)\nusing this:\n  \\<omega>_sum (\\<omega>_of_Cantor \\<alpha>s ?ms) = Cantor_sum \\<alpha>s ?ms\n\ngoal (1 subgoal):\n 1. \\<omega>_sum (\\<omega>_of_Cantor (a # \\<alpha>s) ms) =\n    Cantor_sum (a # \\<alpha>s) ms", "by (cases ms) auto"], ["proof (state)\nthis:\n  \\<omega>_sum (\\<omega>_of_Cantor (a # \\<alpha>s) ms) =\n  Cantor_sum (a # \\<alpha>s) ms\n\ngoal (1 subgoal):\n 1. \\<And>ms. \\<omega>_sum (\\<omega>_of_Cantor [] ms) = Cantor_sum [] ms", "qed auto"], ["", "lemma \\<omega>_of_Cantor_subset: \"List.set (\\<omega>_of_Cantor \\<alpha>s ms) \\<subseteq> List.set \\<alpha>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list.set (\\<omega>_of_Cantor \\<alpha>s ms)\n    \\<subseteq> list.set \\<alpha>s", "proof (induction \\<alpha>s arbitrary: ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms. list.set (\\<omega>_of_Cantor [] ms) \\<subseteq> list.set []\n 2. \\<And>a \\<alpha>s ms.\n       (\\<And>ms.\n           list.set (\\<omega>_of_Cantor \\<alpha>s ms)\n           \\<subseteq> list.set \\<alpha>s) \\<Longrightarrow>\n       list.set (\\<omega>_of_Cantor (a # \\<alpha>s) ms)\n       \\<subseteq> list.set (a # \\<alpha>s)", "case (Cons a \\<alpha>s ms)"], ["proof (state)\nthis:\n  list.set (\\<omega>_of_Cantor \\<alpha>s ?ms) \\<subseteq> list.set \\<alpha>s\n\ngoal (2 subgoals):\n 1. \\<And>ms. list.set (\\<omega>_of_Cantor [] ms) \\<subseteq> list.set []\n 2. \\<And>a \\<alpha>s ms.\n       (\\<And>ms.\n           list.set (\\<omega>_of_Cantor \\<alpha>s ms)\n           \\<subseteq> list.set \\<alpha>s) \\<Longrightarrow>\n       list.set (\\<omega>_of_Cantor (a # \\<alpha>s) ms)\n       \\<subseteq> list.set (a # \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  list.set (\\<omega>_of_Cantor \\<alpha>s ?ms) \\<subseteq> list.set \\<alpha>s", "show ?case"], ["proof (prove)\nusing this:\n  list.set (\\<omega>_of_Cantor \\<alpha>s ?ms) \\<subseteq> list.set \\<alpha>s\n\ngoal (1 subgoal):\n 1. list.set (\\<omega>_of_Cantor (a # \\<alpha>s) ms)\n    \\<subseteq> list.set (a # \\<alpha>s)", "by (cases ms) auto"], ["proof (state)\nthis:\n  list.set (\\<omega>_of_Cantor (a # \\<alpha>s) ms)\n  \\<subseteq> list.set (a # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>ms. list.set (\\<omega>_of_Cantor [] ms) \\<subseteq> list.set []", "qed auto"], ["", "lemma \\<omega>_dec_replicate: \"\\<omega>_dec (replicate m \\<alpha> @ \\<alpha>s) = (if m=0 then \\<omega>_dec \\<alpha>s else \\<omega>_dec (\\<alpha>#\\<alpha>s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (replicate m \\<alpha> @ \\<alpha>s) =\n    (if m = 0 then sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n     else sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s))", "by (induction m arbitrary: \\<alpha>s) (simp_all flip: replicate_append_same)"], ["", "lemma \\<omega>_dec_of_Cantor_aux:\n  assumes \"Cantor_dec (\\<alpha>#\\<alpha>s)\" \"length \\<alpha>s = length ms\"\n  shows \"\\<omega>_dec (\\<omega>_of_Cantor (\\<alpha>#\\<alpha>s) (m#ms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms))", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s)\n  length \\<alpha>s = length ms\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms))", "proof (induction \\<alpha>s arbitrary: ms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>];\n        length [] = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor [\\<alpha>] (m # ms))\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>]\n  length [] = length ms\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>];\n        length [] = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor [\\<alpha>] (m # ms))\n 2. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>]\n  length [] = length ms", "show ?case"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>]\n  length [] = length ms\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor [\\<alpha>] (m # ms))", "using sorted_wrt_iff_nth_less"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y < x) [\\<alpha>]\n  length [] = length ms\n  sorted_wrt ?P ?xs =\n  (\\<forall>i j.\n      i < j \\<longrightarrow>\n      j < length ?xs \\<longrightarrow> ?P (?xs ! i) (?xs ! j))\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor [\\<alpha>] (m # ms))", "by fastforce"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x)\n   (\\<omega>_of_Cantor [\\<alpha>] (m # ms))\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "case (Cons a \\<alpha>s ms)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s);\n   length \\<alpha>s = length ?ms\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ?ms))\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  length (a # \\<alpha>s) = length ms\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s);\n   length \\<alpha>s = length ?ms\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ?ms))\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  length (a # \\<alpha>s) = length ms", "obtain n ns where ns: \"ms = n#ns\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s);\n   length \\<alpha>s = length ?ms\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ?ms))\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  length (a # \\<alpha>s) = length ms\n\ngoal (1 subgoal):\n 1. (\\<And>n ns. ms = n # ns \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  ms = n # ns\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "then"], ["proof (chain)\npicking this:\n  ms = n # ns", "have \"a \\<le> \\<alpha>\""], ["proof (prove)\nusing this:\n  ms = n # ns\n\ngoal (1 subgoal):\n 1. a \\<le> \\<alpha>", "using Cons.prems(1) order.strict_implies_order"], ["proof (prove)\nusing this:\n  ms = n # ns\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  ?a < ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. a \\<le> \\<alpha>", "by auto"], ["proof (state)\nthis:\n  a \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "moreover"], ["proof (state)\nthis:\n  a \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "have \"\\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a", "using Cons ns \\<open>a \\<le> \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s);\n   length \\<alpha>s = length ?ms\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ?ms))\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  length (a # \\<alpha>s) = length ms\n  ms = n # ns\n  a \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a", "apply (simp add: \\<omega>_dec_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms.\n                length ns = length ms \\<Longrightarrow>\n                if m = 0\n                then sorted_wrt (\\<lambda>x y. y \\<le> x)\n                      (\\<omega>_of_Cantor \\<alpha>s ms)\n                else sorted_wrt (\\<lambda>x y. y \\<le> x)\n                      (\\<alpha> # \\<omega>_of_Cantor \\<alpha>s ms);\n     a < \\<alpha> \\<and>\n     (\\<forall>x\\<in>list.set \\<alpha>s. x < \\<alpha>) \\<and>\n     (\\<forall>x\\<in>list.set \\<alpha>s. x < a) \\<and>\n     sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n     length \\<alpha>s = length ns; ms = n # ns; a \\<le> \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>list.set\n(\\<omega>_of_Cantor \\<alpha>s ns).\n                         x \\<le> a", "by (meson \\<omega>_of_Cantor_subset order.strict_implies_order subsetD)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s ms.\n       \\<lbrakk>\\<And>ms.\n                   \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x)\n                             (\\<alpha> # \\<alpha>s);\n                    length \\<alpha>s = length ms\\<rbrakk>\n                   \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n(\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ms));\n        sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s);\n        length (a # \\<alpha>s) = length ms\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s)\n                            (m # ms))", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> \\<alpha>\n  \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a", "show ?case"], ["proof (prove)\nusing this:\n  a \\<le> \\<alpha>\n  \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s) (m # ms))", "using Cons ns"], ["proof (prove)\nusing this:\n  a \\<le> \\<alpha>\n  \\<forall>x\\<in>list.set (\\<omega>_of_Cantor \\<alpha>s ns). x \\<le> a\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # \\<alpha>s);\n   length \\<alpha>s = length ?ms\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<omega>_of_Cantor (\\<alpha> # \\<alpha>s) (m # ?ms))\n  sorted_wrt (\\<lambda>x y. y < x) (\\<alpha> # a # \\<alpha>s)\n  length (a # \\<alpha>s) = length ms\n  ms = n # ns\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x)\n     (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s) (m # ms))", "by (force simp: \\<omega>_dec_replicate)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x)\n   (\\<omega>_of_Cantor (\\<alpha> # a # \\<alpha>s) (m # ms))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<omega>_dec_of_Cantor:\n  assumes \"Cantor_dec \\<alpha>s\" \"length \\<alpha>s = length ms\"\n  shows \"\\<omega>_dec (\\<omega>_of_Cantor \\<alpha>s ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)", "proof (cases \\<alpha>s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha>s = [] \\<Longrightarrow>\n    sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)\n 2. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "case Nil"], ["proof (state)\nthis:\n  \\<alpha>s = []\n\ngoal (2 subgoals):\n 1. \\<alpha>s = [] \\<Longrightarrow>\n    sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)\n 2. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = []", "have \"ms = []\""], ["proof (prove)\nusing this:\n  \\<alpha>s = []\n\ngoal (1 subgoal):\n 1. ms = []", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha>s = []\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  length \\<alpha>s = length ms\n\ngoal (1 subgoal):\n 1. ms = []", "by auto"], ["proof (state)\nthis:\n  ms = []\n\ngoal (2 subgoals):\n 1. \\<alpha>s = [] \\<Longrightarrow>\n    sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)\n 2. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "with Nil"], ["proof (chain)\npicking this:\n  \\<alpha>s = []\n  ms = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>s = []\n  ms = []\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<alpha>s = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<alpha>s = a # list \\<Longrightarrow>\n       sorted_wrt (\\<lambda>x y. y \\<le> x)\n        (\\<omega>_of_Cantor \\<alpha>s ms)", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>s = a # list\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)", "by (metis \\<omega>_dec_of_Cantor_aux assms length_Suc_conv)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<omega>_of_Cantor \\<alpha>s ms)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition \\<omega>_nf_exists:\n  assumes \"Ord \\<alpha>\"\n  obtains \\<alpha>s where \"List.set \\<alpha>s \\<subseteq> ON\" and \"\\<omega>_dec \\<alpha>s\" and \"\\<alpha> = \\<omega>_sum \\<alpha>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n         \\<alpha> = \\<omega>_sum \\<alpha>s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n         \\<alpha> = \\<omega>_sum \\<alpha>s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain \\<alpha>s ms where \"List.set \\<alpha>s \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\" and length: \"length \\<alpha>s = length ms\"\n    and \"Cantor_dec \\<alpha>s\"\n    and \\<alpha>: \"\\<alpha> = Cantor_sum \\<alpha>s ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cantor_nf_exists assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>;\n   \\<And>\\<alpha>s ms.\n      \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n       list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n       sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n       ?\\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n         \\<alpha> = \\<omega>_sum \\<alpha>s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms", "show thesis"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<alpha> = Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. thesis", "by (metis \\<omega>_dec_of_Cantor \\<omega>_of_Cantor_subset \\<omega>_sum_of_Cantor order_trans that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<omega>_sum_take_drop: \"\\<omega>_sum \\<alpha>s = \\<omega>_sum (take k \\<alpha>s) + \\<omega>_sum (drop k \\<alpha>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s =\n    \\<omega>_sum (take k \\<alpha>s) + \\<omega>_sum (drop k \\<alpha>s)", "proof (induction k arbitrary: \\<alpha>s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>s.\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take 0 \\<alpha>s) + \\<omega>_sum (drop 0 \\<alpha>s)\n 2. \\<And>k \\<alpha>s.\n       (\\<And>\\<alpha>s.\n           \\<omega>_sum \\<alpha>s =\n           \\<omega>_sum (take k \\<alpha>s) +\n           \\<omega>_sum (drop k \\<alpha>s)) \\<Longrightarrow>\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take (Suc k) \\<alpha>s) +\n       \\<omega>_sum (drop (Suc k) \\<alpha>s)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>s.\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take 0 \\<alpha>s) + \\<omega>_sum (drop 0 \\<alpha>s)\n 2. \\<And>k \\<alpha>s.\n       (\\<And>\\<alpha>s.\n           \\<omega>_sum \\<alpha>s =\n           \\<omega>_sum (take k \\<alpha>s) +\n           \\<omega>_sum (drop k \\<alpha>s)) \\<Longrightarrow>\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take (Suc k) \\<alpha>s) +\n       \\<omega>_sum (drop (Suc k) \\<alpha>s)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s =\n    \\<omega>_sum (take 0 \\<alpha>s) + \\<omega>_sum (drop 0 \\<alpha>s)", "by simp"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s =\n  \\<omega>_sum (take 0 \\<alpha>s) + \\<omega>_sum (drop 0 \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<alpha>s.\n       (\\<And>\\<alpha>s.\n           \\<omega>_sum \\<alpha>s =\n           \\<omega>_sum (take k \\<alpha>s) +\n           \\<omega>_sum (drop k \\<alpha>s)) \\<Longrightarrow>\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take (Suc k) \\<alpha>s) +\n       \\<omega>_sum (drop (Suc k) \\<alpha>s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k \\<alpha>s.\n       (\\<And>\\<alpha>s.\n           \\<omega>_sum \\<alpha>s =\n           \\<omega>_sum (take k \\<alpha>s) +\n           \\<omega>_sum (drop k \\<alpha>s)) \\<Longrightarrow>\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take (Suc k) \\<alpha>s) +\n       \\<omega>_sum (drop (Suc k) \\<alpha>s)", "case (Suc k)"], ["proof (state)\nthis:\n  \\<omega>_sum ?\\<alpha>s =\n  \\<omega>_sum (take k ?\\<alpha>s) + \\<omega>_sum (drop k ?\\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>k \\<alpha>s.\n       (\\<And>\\<alpha>s.\n           \\<omega>_sum \\<alpha>s =\n           \\<omega>_sum (take k \\<alpha>s) +\n           \\<omega>_sum (drop k \\<alpha>s)) \\<Longrightarrow>\n       \\<omega>_sum \\<alpha>s =\n       \\<omega>_sum (take (Suc k) \\<alpha>s) +\n       \\<omega>_sum (drop (Suc k) \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  \\<omega>_sum ?\\<alpha>s =\n  \\<omega>_sum (take k ?\\<alpha>s) + \\<omega>_sum (drop k ?\\<alpha>s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<omega>_sum ?\\<alpha>s =\n  \\<omega>_sum (take k ?\\<alpha>s) + \\<omega>_sum (drop k ?\\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s =\n    \\<omega>_sum (take (Suc k) \\<alpha>s) +\n    \\<omega>_sum (drop (Suc k) \\<alpha>s)", "proof (cases \"\\<alpha>s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<alpha>s.\n                \\<omega>_sum \\<alpha>s =\n                \\<omega>_sum (take k \\<alpha>s) +\n                \\<omega>_sum (drop k \\<alpha>s);\n     \\<alpha>s = []\\<rbrakk>\n    \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                      \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                      \\<omega>_sum (drop (Suc k) \\<alpha>s)\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>\\<alpha>s.\n                   \\<omega>_sum \\<alpha>s =\n                   \\<omega>_sum (take k \\<alpha>s) +\n                   \\<omega>_sum (drop k \\<alpha>s);\n        \\<alpha>s = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                         \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                         \\<omega>_sum (drop (Suc k) \\<alpha>s)", "case Nil"], ["proof (state)\nthis:\n  \\<alpha>s = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>\\<alpha>s.\n                \\<omega>_sum \\<alpha>s =\n                \\<omega>_sum (take k \\<alpha>s) +\n                \\<omega>_sum (drop k \\<alpha>s);\n     \\<alpha>s = []\\<rbrakk>\n    \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                      \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                      \\<omega>_sum (drop (Suc k) \\<alpha>s)\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>\\<alpha>s.\n                   \\<omega>_sum \\<alpha>s =\n                   \\<omega>_sum (take k \\<alpha>s) +\n                   \\<omega>_sum (drop k \\<alpha>s);\n        \\<alpha>s = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                         \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                         \\<omega>_sum (drop (Suc k) \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>s = []\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s =\n    \\<omega>_sum (take (Suc k) \\<alpha>s) +\n    \\<omega>_sum (drop (Suc k) \\<alpha>s)", "by simp"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s =\n  \\<omega>_sum (take (Suc k) \\<alpha>s) +\n  \\<omega>_sum (drop (Suc k) \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>\\<alpha>s.\n                   \\<omega>_sum \\<alpha>s =\n                   \\<omega>_sum (take k \\<alpha>s) +\n                   \\<omega>_sum (drop k \\<alpha>s);\n        \\<alpha>s = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                         \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                         \\<omega>_sum (drop (Suc k) \\<alpha>s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>\\<alpha>s.\n                   \\<omega>_sum \\<alpha>s =\n                   \\<omega>_sum (take k \\<alpha>s) +\n                   \\<omega>_sum (drop k \\<alpha>s);\n        \\<alpha>s = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                         \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                         \\<omega>_sum (drop (Suc k) \\<alpha>s)", "case (Cons a list)"], ["proof (state)\nthis:\n  \\<alpha>s = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>\\<alpha>s.\n                   \\<omega>_sum \\<alpha>s =\n                   \\<omega>_sum (take k \\<alpha>s) +\n                   \\<omega>_sum (drop k \\<alpha>s);\n        \\<alpha>s = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum \\<alpha>s =\n                         \\<omega>_sum (take (Suc k) \\<alpha>s) +\n                         \\<omega>_sum (drop (Suc k) \\<alpha>s)", "with Suc.prems"], ["proof (chain)\npicking this:\n  \\<alpha>s = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>s = a # list\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s =\n    \\<omega>_sum (take (Suc k) \\<alpha>s) +\n    \\<omega>_sum (drop (Suc k) \\<alpha>s)", "by (simp add: add.assoc flip: Suc.IH)"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s =\n  \\<omega>_sum (take (Suc k) \\<alpha>s) +\n  \\<omega>_sum (drop (Suc k) \\<alpha>s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s =\n  \\<omega>_sum (take (Suc k) \\<alpha>s) +\n  \\<omega>_sum (drop (Suc k) \\<alpha>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_elts_\\<omega>_sum:\n  assumes \"\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s)\"\n  shows \"\\<exists>k<length \\<alpha>s. \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> (\\<alpha>s!k)). \\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length \\<alpha>s.\n       \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n          \\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>", "using assms"], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length \\<alpha>s.\n       \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n          \\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>", "proof (induction \\<alpha>s arbitrary: \\<delta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<delta>.\n       \\<delta> \\<in> elts (\\<omega>_sum []) \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> [] ! k).\n             \\<delta> = \\<omega>_sum (take k []) + \\<gamma>\n 2. \\<And>a \\<alpha>s \\<delta>.\n       \\<lbrakk>\\<And>\\<delta>.\n                   \\<delta>\n                   \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n                   \\<exists>k<length \\<alpha>s.\n                      \\<exists>\\<gamma>\n                               \\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n                         \\<delta> =\n                         \\<omega>_sum (take k \\<alpha>s) + \\<gamma>;\n        \\<delta> \\<in> elts (\\<omega>_sum (a # \\<alpha>s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (a # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (a # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum (take k (a # \\<alpha>s)) +\n                               \\<gamma>", "case (Cons \\<alpha> \\<alpha>s)"], ["proof (state)\nthis:\n  ?\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n  \\<exists>k<length \\<alpha>s.\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n        ?\\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n  \\<delta> \\<in> elts (\\<omega>_sum (\\<alpha> # \\<alpha>s))\n\ngoal (2 subgoals):\n 1. \\<And>\\<delta>.\n       \\<delta> \\<in> elts (\\<omega>_sum []) \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> [] ! k).\n             \\<delta> = \\<omega>_sum (take k []) + \\<gamma>\n 2. \\<And>a \\<alpha>s \\<delta>.\n       \\<lbrakk>\\<And>\\<delta>.\n                   \\<delta>\n                   \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n                   \\<exists>k<length \\<alpha>s.\n                      \\<exists>\\<gamma>\n                               \\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n                         \\<delta> =\n                         \\<omega>_sum (take k \\<alpha>s) + \\<gamma>;\n        \\<delta> \\<in> elts (\\<omega>_sum (a # \\<alpha>s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (a # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (a # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum (take k (a # \\<alpha>s)) +\n                               \\<gamma>", "then"], ["proof (chain)\npicking this:\n  ?\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n  \\<exists>k<length \\<alpha>s.\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n        ?\\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n  \\<delta> \\<in> elts (\\<omega>_sum (\\<alpha> # \\<alpha>s))", "have \"\\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s)\""], ["proof (prove)\nusing this:\n  ?\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n  \\<exists>k<length \\<alpha>s.\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n        ?\\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n  \\<delta> \\<in> elts (\\<omega>_sum (\\<alpha> # \\<alpha>s))\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s)", "by simp"], ["proof (state)\nthis:\n  \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s)\n\ngoal (2 subgoals):\n 1. \\<And>\\<delta>.\n       \\<delta> \\<in> elts (\\<omega>_sum []) \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> [] ! k).\n             \\<delta> = \\<omega>_sum (take k []) + \\<gamma>\n 2. \\<And>a \\<alpha>s \\<delta>.\n       \\<lbrakk>\\<And>\\<delta>.\n                   \\<delta>\n                   \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n                   \\<exists>k<length \\<alpha>s.\n                      \\<exists>\\<gamma>\n                               \\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n                         \\<delta> =\n                         \\<omega>_sum (take k \\<alpha>s) + \\<gamma>;\n        \\<delta> \\<in> elts (\\<omega>_sum (a # \\<alpha>s))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (a # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (a # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum (take k (a # \\<alpha>s)) +\n                               \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>", "proof (rule mem_plus_V_E)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha>) \\<Longrightarrow>\n    \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> elts (\\<omega>_sum \\<alpha>s);\n        \\<delta> = \\<omega> \\<up> \\<alpha> + z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (\\<alpha> # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum\n                                (take k (\\<alpha> # \\<alpha>s)) +\n                               \\<gamma>", "fix \\<eta>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha>) \\<Longrightarrow>\n    \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> elts (\\<omega>_sum \\<alpha>s);\n        \\<delta> = \\<omega> \\<up> \\<alpha> + z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (\\<alpha> # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum\n                                (take k (\\<alpha> # \\<alpha>s)) +\n                               \\<gamma>", "assume \\<eta>: \"\\<eta> \\<in> elts (\\<omega>_sum \\<alpha>s)\" and \\<delta>: \"\\<delta> = \\<omega> \\<up> \\<alpha> + \\<eta>\""], ["proof (state)\nthis:\n  \\<eta> \\<in> elts (\\<omega>_sum \\<alpha>s)\n  \\<delta> = \\<omega> \\<up> \\<alpha> + \\<eta>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha>) \\<Longrightarrow>\n    \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> elts (\\<omega>_sum \\<alpha>s);\n        \\<delta> = \\<omega> \\<up> \\<alpha> + z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (\\<alpha> # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum\n                                (take k (\\<alpha> # \\<alpha>s)) +\n                               \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<eta> \\<in> elts (\\<omega>_sum \\<alpha>s)\n  \\<delta> = \\<omega> \\<up> \\<alpha> + \\<eta>", "obtain k \\<gamma> where \"k<length \\<alpha>s\" \"\\<gamma> \\<in> elts (\\<omega> \\<up> (\\<alpha>s!k))\" \"\\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<eta> \\<in> elts (\\<omega>_sum \\<alpha>s)\n  \\<delta> = \\<omega> \\<up> \\<alpha> + \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>k < length \\<alpha>s;\n         \\<gamma> \\<in> elts (\\<omega> \\<up> \\<alpha>s ! k);\n         \\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.IH"], ["proof (prove)\nusing this:\n  \\<eta> \\<in> elts (\\<omega>_sum \\<alpha>s)\n  \\<delta> = \\<omega> \\<up> \\<alpha> + \\<eta>\n  ?\\<delta> \\<in> elts (\\<omega>_sum \\<alpha>s) \\<Longrightarrow>\n  \\<exists>k<length \\<alpha>s.\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<alpha>s ! k).\n        ?\\<delta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>k \\<gamma>.\n        \\<lbrakk>k < length \\<alpha>s;\n         \\<gamma> \\<in> elts (\\<omega> \\<up> \\<alpha>s ! k);\n         \\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k < length \\<alpha>s\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<alpha>s ! k)\n  \\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n\ngoal (2 subgoals):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha>) \\<Longrightarrow>\n    \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n 2. \\<And>z.\n       \\<lbrakk>z \\<in> elts (\\<omega>_sum \\<alpha>s);\n        \\<delta> = \\<omega> \\<up> \\<alpha> + z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (\\<alpha> # \\<alpha>s).\n                            \\<exists>\\<gamma>\n                                     \\<in>elts\n     (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n                               \\<delta> =\n                               \\<omega>_sum\n                                (take k (\\<alpha> # \\<alpha>s)) +\n                               \\<gamma>", "then"], ["proof (chain)\npicking this:\n  k < length \\<alpha>s\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<alpha>s ! k)\n  \\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>", "show ?case"], ["proof (prove)\nusing this:\n  k < length \\<alpha>s\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<alpha>s ! k)\n  \\<eta> = \\<omega>_sum (take k \\<alpha>s) + \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>", "by (rule_tac x=\"Suc k\" in exI) (simp add: \\<delta> add.assoc)"], ["proof (state)\nthis:\n  \\<exists>k<length (\\<alpha> # \\<alpha>s).\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n        \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts (\\<omega> \\<up> \\<alpha>) \\<Longrightarrow>\n    \\<exists>k<length (\\<alpha> # \\<alpha>s).\n       \\<exists>\\<gamma>\n                \\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n          \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>", "qed auto"], ["proof (state)\nthis:\n  \\<exists>k<length (\\<alpha> # \\<alpha>s).\n     \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> (\\<alpha> # \\<alpha>s) ! k).\n        \\<delta> = \\<omega>_sum (take k (\\<alpha> # \\<alpha>s)) + \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<delta>.\n       \\<delta> \\<in> elts (\\<omega>_sum []) \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>\\<gamma>\\<in>elts (\\<omega> \\<up> [] ! k).\n             \\<delta> = \\<omega>_sum (take k []) + \\<gamma>", "qed auto"], ["", "lemma \\<omega>_le_\\<omega>_sum: \"\\<lbrakk>k < length \\<alpha>s; List.set \\<alpha>s \\<subseteq> ON\\<rbrakk> \\<Longrightarrow> \\<omega> \\<up> (\\<alpha>s!k) \\<le> \\<omega>_sum \\<alpha>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length \\<alpha>s;\n     list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n    \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k\n                      \\<le> \\<omega>_sum \\<alpha>s", "proof (induction \\<alpha>s arbitrary: k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < length []; list.set [] \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> [] ! k \\<le> \\<omega>_sum []\n 2. \\<And>a \\<alpha>s k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>k < length \\<alpha>s;\n                    list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n                   \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k\n                                     \\<le> \\<omega>_sum \\<alpha>s;\n        k < length (a # \\<alpha>s);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> (a # \\<alpha>s) ! k\n                         \\<le> \\<omega>_sum (a # \\<alpha>s)", "case (Cons a \\<alpha>s)"], ["proof (state)\nthis:\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  k < length (a # \\<alpha>s)\n  list.set (a # \\<alpha>s) \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < length []; list.set [] \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> [] ! k \\<le> \\<omega>_sum []\n 2. \\<And>a \\<alpha>s k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>k < length \\<alpha>s;\n                    list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n                   \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k\n                                     \\<le> \\<omega>_sum \\<alpha>s;\n        k < length (a # \\<alpha>s);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> (a # \\<alpha>s) ! k\n                         \\<le> \\<omega>_sum (a # \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  k < length (a # \\<alpha>s)\n  list.set (a # \\<alpha>s) \\<subseteq> ON", "obtain \"Ord a\" \"list.set \\<alpha>s \\<subseteq> ON\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  k < length (a # \\<alpha>s)\n  list.set (a # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord a; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Ord a\n  list.set \\<alpha>s \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < length []; list.set [] \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> [] ! k \\<le> \\<omega>_sum []\n 2. \\<And>a \\<alpha>s k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>k < length \\<alpha>s;\n                    list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n                   \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k\n                                     \\<le> \\<omega>_sum \\<alpha>s;\n        k < length (a # \\<alpha>s);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> (a # \\<alpha>s) ! k\n                         \\<le> \\<omega>_sum (a # \\<alpha>s)", "with Cons.IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  Ord a\n  list.set \\<alpha>s \\<subseteq> ON", "have \"\\<And>k x. k < length \\<alpha>s \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  Ord a\n  list.set \\<alpha>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       k < length \\<alpha>s \\<Longrightarrow>\n       \\<omega> \\<up> \\<alpha>s ! k\n       \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s", "by (meson Ord_\\<omega> Ord_\\<omega>_sum Ord_oexp add_le_left order_trans)"], ["proof (state)\nthis:\n  ?k < length \\<alpha>s \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>s ! ?k\n  \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>k < length []; list.set [] \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> [] ! k \\<le> \\<omega>_sum []\n 2. \\<And>a \\<alpha>s k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>k < length \\<alpha>s;\n                    list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n                   \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! k\n                                     \\<le> \\<omega>_sum \\<alpha>s;\n        k < length (a # \\<alpha>s);\n        list.set (a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> (a # \\<alpha>s) ! k\n                         \\<le> \\<omega>_sum (a # \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  ?k < length \\<alpha>s \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>s ! ?k\n  \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s", "show ?case"], ["proof (prove)\nusing this:\n  ?k < length \\<alpha>s \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>s ! ?k\n  \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> (a # \\<alpha>s) ! k \\<le> \\<omega>_sum (a # \\<alpha>s)", "using Cons"], ["proof (prove)\nusing this:\n  ?k < length \\<alpha>s \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>s ! ?k\n  \\<le> \\<omega> \\<up> a + \\<omega>_sum \\<alpha>s\n  \\<lbrakk>?k < length \\<alpha>s; list.set \\<alpha>s \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>s ! ?k\n                    \\<le> \\<omega>_sum \\<alpha>s\n  k < length (a # \\<alpha>s)\n  list.set (a # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> (a # \\<alpha>s) ! k \\<le> \\<omega>_sum (a # \\<alpha>s)", "by (simp add: nth_Cons split: nat.split)"], ["proof (state)\nthis:\n  \\<omega> \\<up> (a # \\<alpha>s) ! k \\<le> \\<omega>_sum (a # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k < length []; list.set [] \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega> \\<up> [] ! k \\<le> \\<omega>_sum []", "qed auto"], ["", "lemma \\<omega>_sum_less_self:\n  assumes \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\" and \"\\<omega>_dec (\\<alpha>#\\<alpha>s)\"\n  shows \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> + \\<omega>_sum \\<alpha>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s\n    < \\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s", "using assms"], ["proof (prove)\nusing this:\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s\n    < \\<omega> \\<up> \\<alpha> + \\<omega>_sum \\<alpha>s", "proof (induction \\<alpha>s arbitrary: \\<alpha>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>list.set [\\<alpha>] \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum []\n                         < \\<omega> \\<up> \\<alpha> + \\<omega>_sum []\n 2. \\<And>a \\<alpha>s \\<alpha>.\n       \\<lbrakk>\\<And>\\<alpha>.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                     < \\<omega> \\<up> \\<alpha> +\n \\<omega>_sum \\<alpha>s;\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x)\n         (\\<alpha> # a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> +\n                           \\<omega>_sum (a # \\<alpha>s)", "case Nil"], ["proof (state)\nthis:\n  list.set [\\<alpha>] \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha>.\n       \\<lbrakk>list.set [\\<alpha>] \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum []\n                         < \\<omega> \\<up> \\<alpha> + \\<omega>_sum []\n 2. \\<And>a \\<alpha>s \\<alpha>.\n       \\<lbrakk>\\<And>\\<alpha>.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                     < \\<omega> \\<up> \\<alpha> +\n \\<omega>_sum \\<alpha>s;\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x)\n         (\\<alpha> # a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> +\n                           \\<omega>_sum (a # \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  list.set [\\<alpha>] \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]", "show ?case"], ["proof (prove)\nusing this:\n  list.set [\\<alpha>] \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n\ngoal (1 subgoal):\n 1. \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> + \\<omega>_sum []", "using ZFC_in_HOL.neq0_conv"], ["proof (prove)\nusing this:\n  list.set [\\<alpha>] \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> + \\<omega>_sum []", "by fastforce"], ["proof (state)\nthis:\n  \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> + \\<omega>_sum []\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s \\<alpha>.\n       \\<lbrakk>\\<And>\\<alpha>.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                     < \\<omega> \\<up> \\<alpha> +\n \\<omega>_sum \\<alpha>s;\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x)\n         (\\<alpha> # a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> +\n                           \\<omega>_sum (a # \\<alpha>s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s \\<alpha>.\n       \\<lbrakk>\\<And>\\<alpha>.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                     < \\<omega> \\<up> \\<alpha> +\n \\<omega>_sum \\<alpha>s;\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x)\n         (\\<alpha> # a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> +\n                           \\<omega>_sum (a # \\<alpha>s)", "case (Cons \\<alpha>1 \\<alpha>s)"], ["proof (state)\nthis:\n  \\<lbrakk>list.set (?\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n   sorted_wrt (\\<lambda>x y. y \\<le> x) (?\\<alpha> # \\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> ?\\<alpha> + \\<omega>_sum \\<alpha>s\n  list.set (\\<alpha> # \\<alpha>1 # \\<alpha>s) \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>1 # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s \\<alpha>.\n       \\<lbrakk>\\<And>\\<alpha>.\n                   \\<lbrakk>list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n                    sorted_wrt (\\<lambda>x y. y \\<le> x)\n                     (\\<alpha> # \\<alpha>s)\\<rbrakk>\n                   \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                     < \\<omega> \\<up> \\<alpha> +\n \\<omega>_sum \\<alpha>s;\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x)\n         (\\<alpha> # a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> +\n                           \\<omega>_sum (a # \\<alpha>s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>list.set (?\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n   sorted_wrt (\\<lambda>x y. y \\<le> x) (?\\<alpha> # \\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> ?\\<alpha> + \\<omega>_sum \\<alpha>s\n  list.set (\\<alpha> # \\<alpha>1 # \\<alpha>s) \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>1 # \\<alpha>s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>list.set (?\\<alpha> # \\<alpha>s) \\<subseteq> ON;\n   sorted_wrt (\\<lambda>x y. y \\<le> x) (?\\<alpha> # \\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> ?\\<alpha> + \\<omega>_sum \\<alpha>s\n  list.set (\\<alpha> # \\<alpha>1 # \\<alpha>s) \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>1 # \\<alpha>s)\n\ngoal (1 subgoal):\n 1. \\<omega>_sum (\\<alpha>1 # \\<alpha>s)\n    < \\<omega> \\<up> \\<alpha> + \\<omega>_sum (\\<alpha>1 # \\<alpha>s)", "by (simp add: add_right_strict_mono oexp_mono_le)"], ["proof (state)\nthis:\n  \\<omega>_sum (\\<alpha>1 # \\<alpha>s)\n  < \\<omega> \\<up> \\<alpha> + \\<omega>_sum (\\<alpha>1 # \\<alpha>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Something like Lemma 5.2 for @{term \\<omega>_sum}\\<close>"], ["", "lemma \\<omega>_sum_less_\\<omega>_power:\n  assumes \"\\<omega>_dec (\\<alpha>#\\<alpha>s)\" \"List.set (\\<alpha>#\\<alpha>s) \\<subseteq> ON\"\n  shows \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s)\n  list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>", "proof (induction \\<alpha>s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>];\n     list.set [\\<alpha>] \\<subseteq> ON\\<rbrakk>\n    \\<Longrightarrow> \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> * \\<omega>\n 2. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n  list.set [\\<alpha>] \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>];\n     list.set [\\<alpha>] \\<subseteq> ON\\<rbrakk>\n    \\<Longrightarrow> \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> * \\<omega>\n 2. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "then"], ["proof (chain)\npicking this:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n  list.set [\\<alpha>] \\<subseteq> ON", "show ?case"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) [\\<alpha>]\n  list.set [\\<alpha>] \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> * \\<omega>", "by (simp add: \\<omega>_gt0)"], ["proof (state)\nthis:\n  \\<omega>_sum [] < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "case (Cons \\<beta> \\<alpha>s)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s);\n   list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> \\<alpha> * \\<omega>\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<alpha>s)\n  list.set (\\<alpha> # \\<beta> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s);\n   list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> \\<alpha> * \\<omega>\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<alpha>s)\n  list.set (\\<alpha> # \\<beta> # \\<alpha>s) \\<subseteq> ON", "have \"Ord \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s);\n   list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> \\<alpha> * \\<omega>\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<alpha>s)\n  list.set (\\<alpha> # \\<beta> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "have \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<alpha>s);\n   list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n  \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                    < \\<omega> \\<up> \\<alpha> * \\<omega>\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<alpha>s)\n  list.set (\\<alpha> # \\<beta> # \\<alpha>s) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>", "by force"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>", "have \"\\<omega>\\<up>\\<beta> + \\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha> + \\<omega>\\<up>\\<alpha> * \\<omega>\""], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n    < \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega>", "using Cons.prems add_right_strict_mono oexp_mono_le"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha> * \\<omega>\n  sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # \\<beta> # \\<alpha>s)\n  list.set (\\<alpha> # \\<beta> # \\<alpha>s) \\<subseteq> ON\n  \\<lbrakk>?\\<alpha> \\<le> ?\\<beta>; ?\\<gamma> < ?\\<delta>; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>; Ord ?\\<delta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> + ?\\<gamma> < ?\\<beta> + ?\\<delta>\n  \\<lbrakk>?\\<gamma> \\<le> ?\\<beta>; ?\\<alpha> \\<noteq> 0; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<up> ?\\<gamma> \\<le> ?\\<alpha> \\<up> ?\\<beta>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n    < \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n  < \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n  < \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "have \"\\<dots> = \\<omega>\\<up>\\<alpha> * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega> =\n    \\<omega> \\<up> \\<alpha> * \\<omega>", "by (metis Kirby.add_mult_distrib mult.right_neutral one_plus_\\<omega>_equals_\\<omega>)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * \\<omega> =\n  \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>sorted_wrt (\\<lambda>x y. y \\<le> x)\n                          (\\<alpha> # \\<alpha>s);\n                 list.set (\\<alpha> # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n                \\<Longrightarrow> \\<omega>_sum \\<alpha>s\n                                  < \\<omega> \\<up> \\<alpha> * \\<omega>;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) (\\<alpha> # a # \\<alpha>s);\n        list.set (\\<alpha> # a # \\<alpha>s) \\<subseteq> ON\\<rbrakk>\n       \\<Longrightarrow> \\<omega>_sum (a # \\<alpha>s)\n                         < \\<omega> \\<up> \\<alpha> * \\<omega>", "finally"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n  < \\<omega> \\<up> \\<alpha> * \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<beta> + \\<omega>_sum \\<alpha>s\n  < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega>_sum (\\<beta> # \\<alpha>s) < \\<omega> \\<up> \\<alpha> * \\<omega>", "by simp"], ["proof (state)\nthis:\n  \\<omega>_sum (\\<beta> # \\<alpha>s) < \\<omega> \\<up> \\<alpha> * \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<omega>_sum_nf_unique_aux:\n  assumes \"Ord \\<alpha>\"\n    and \\<alpha>sON: \"List.set \\<alpha>s \\<subseteq> ON\"\n    and \\<beta>sON: \"List.set \\<beta>s \\<subseteq> ON\"\n    and \\<alpha>sdec: \"\\<omega>_dec \\<alpha>s\"\n    and \\<beta>sdec: \"\\<omega>_dec \\<beta>s\"\n    and \\<alpha>seq: \"\\<alpha> = \\<omega>_sum \\<alpha>s\"\n    and \\<beta>seq: \"\\<alpha> = \\<omega>_sum \\<beta>s\"\n  shows \"\\<alpha>s = \\<beta>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "using assms"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "proof (induction \\<alpha> arbitrary: \\<alpha>s \\<beta>s rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<alpha>s \\<beta>s.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<alpha>s \\<beta>s.\n           \\<lbrakk>y \\<in> elts x; list.set \\<alpha>s \\<subseteq> ON;\n            list.set \\<beta>s \\<subseteq> ON;\n            sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n            sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s;\n            y = \\<omega>_sum \\<alpha>s; y = \\<omega>_sum \\<beta>s\\<rbrakk>\n           \\<Longrightarrow> \\<alpha>s = \\<beta>s;\n        list.set \\<alpha>s \\<subseteq> ON; list.set \\<beta>s \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s;\n        x = \\<omega>_sum \\<alpha>s; x = \\<omega>_sum \\<beta>s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>s = \\<beta>s", "case (step \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>; list.set ?\\<alpha>s \\<subseteq> ON;\n   list.set ?\\<beta>s \\<subseteq> ON;\n   sorted_wrt (\\<lambda>x y. y \\<le> x) ?\\<alpha>s;\n   sorted_wrt (\\<lambda>x y. y \\<le> x) ?\\<beta>s;\n   ?y = \\<omega>_sum ?\\<alpha>s; ?y = \\<omega>_sum ?\\<beta>s\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha>s = ?\\<beta>s\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<And>x \\<alpha>s \\<beta>s.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<alpha>s \\<beta>s.\n           \\<lbrakk>y \\<in> elts x; list.set \\<alpha>s \\<subseteq> ON;\n            list.set \\<beta>s \\<subseteq> ON;\n            sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n            sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s;\n            y = \\<omega>_sum \\<alpha>s; y = \\<omega>_sum \\<beta>s\\<rbrakk>\n           \\<Longrightarrow> \\<alpha>s = \\<beta>s;\n        list.set \\<alpha>s \\<subseteq> ON; list.set \\<beta>s \\<subseteq> ON;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s;\n        sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s;\n        x = \\<omega>_sum \\<alpha>s; x = \\<omega>_sum \\<beta>s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>s = \\<beta>s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "proof (cases \"\\<alpha> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "case True"], ["proof (state)\nthis:\n  \\<alpha> = 0\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s\n 2. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "then"], ["proof (chain)\npicking this:\n  \\<alpha> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "using step.prems"], ["proof (prove)\nusing this:\n  \\<alpha> = 0\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "by (metis \\<omega>_sum_0E)"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "case False"], ["proof (state)\nthis:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<noteq> 0", "obtain \\<alpha>0 \\<alpha>s' \\<beta>0 \\<beta>s' where \\<alpha>s: \"\\<alpha>s = \\<alpha>0 # \\<alpha>s'\" and \\<beta>s: \"\\<beta>s = \\<beta>0 # \\<beta>s'\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>0 \\<alpha>s' \\<beta>0 \\<beta>s'.\n        \\<lbrakk>\\<alpha>s = \\<alpha>0 # \\<alpha>s';\n         \\<beta>s = \\<beta>0 # \\<beta>s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<omega>_sum.elims step.prems(5,6))"], ["proof (state)\nthis:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'", "have ON: \"Ord \\<alpha>0\" \"list.set \\<alpha>s' \\<subseteq> ON\" \"Ord \\<beta>0\" \"list.set \\<beta>s' \\<subseteq> ON\""], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n\ngoal (1 subgoal):\n 1. (Ord \\<alpha>0 &&& list.set \\<alpha>s' \\<subseteq> ON) &&&\n    Ord \\<beta>0 &&& list.set \\<beta>s' \\<subseteq> ON", "using \\<alpha>s \\<beta>s step.prems(1,2)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. (Ord \\<alpha>0 &&& list.set \\<alpha>s' \\<subseteq> ON) &&&\n    Ord \\<beta>0 &&& list.set \\<beta>s' \\<subseteq> ON", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "have False if \"\\<beta>0 < \\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have Ordc: \"Ord (\\<omega>_sum \\<beta>s)\" \"Ord (\\<omega>\\<up>\\<alpha>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega>_sum \\<beta>s) &&& Ord (\\<omega> \\<up> \\<alpha>0)", "using Ord_oexp \\<open>Ord \\<alpha>0\\<close>  step.hyps step.prems(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  Ord \\<alpha>0\n  Ord \\<alpha>\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. Ord (\\<omega>_sum \\<beta>s) &&& Ord (\\<omega> \\<up> \\<alpha>0)", "by blast+"], ["proof (state)\nthis:\n  Ord (\\<omega>_sum \\<beta>s)\n  Ord (\\<omega> \\<up> \\<alpha>0)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>_sum \\<beta>s < \\<omega>\\<up>\\<beta>0 * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<beta>0 * \\<omega>", "by (rule \\<omega>_sum_less_\\<omega>_power) (use \\<beta>s step.prems ON in auto)"], ["proof (state)\nthis:\n  \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<beta>0 * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<beta>0 * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<alpha>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 * \\<omega> \\<le> \\<omega> \\<up> \\<alpha>0", "using ON"], ["proof (prove)\nusing this:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta>0 * \\<omega> \\<le> \\<omega> \\<up> \\<alpha>0", "by (metis Ord_\\<omega> Ord_succ oexp_mono_le oexp_succ omega_nonzero succ_le_iff that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta>0 * \\<omega> \\<le> \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<alpha>0", "show False"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<alpha>0\n\ngoal (1 subgoal):\n 1. False", "using \\<alpha>s leD step.prems(5,6)"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<beta>s < \\<omega> \\<up> \\<alpha>0\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "moreover"], ["proof (state)\nthis:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "have False if \"\\<alpha>0 < \\<beta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have Ordc: \"Ord (\\<omega>_sum \\<alpha>s)\" \"Ord (\\<omega>\\<up>\\<beta>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega>_sum \\<alpha>s) &&& Ord (\\<omega> \\<up> \\<beta>0)", "using Ord_oexp \\<open>Ord \\<beta>0\\<close>  step.hyps step.prems(5)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  Ord \\<beta>0\n  Ord \\<alpha>\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n\ngoal (1 subgoal):\n 1. Ord (\\<omega>_sum \\<alpha>s) &&& Ord (\\<omega> \\<up> \\<beta>0)", "by blast+"], ["proof (state)\nthis:\n  Ord (\\<omega>_sum \\<alpha>s)\n  Ord (\\<omega> \\<up> \\<beta>0)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<omega>_sum \\<alpha>s < \\<omega>\\<up>\\<alpha>0 * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha>0 * \\<omega>", "by (rule \\<omega>_sum_less_\\<omega>_power) (use \\<alpha>s step.prems ON in auto)"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha>0 * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<alpha>0 * \\<omega>\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<beta>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 * \\<omega> \\<le> \\<omega> \\<up> \\<beta>0", "using ON"], ["proof (prove)\nusing this:\n  Ord \\<alpha>0\n  list.set \\<alpha>s' \\<subseteq> ON\n  Ord \\<beta>0\n  list.set \\<beta>s' \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>0 * \\<omega> \\<le> \\<omega> \\<up> \\<beta>0", "by (metis Ord_\\<omega> Ord_succ oexp_mono_le oexp_succ omega_nonzero succ_le_iff that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>0 * \\<omega> \\<le> \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<beta>0", "show False"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<beta>0\n\ngoal (1 subgoal):\n 1. False", "using \\<beta>s leD step.prems(5,6)"], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s < \\<omega> \\<up> \\<beta>0\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>\\<alpha> = \\<omega>_sum \\<alpha>s\\<close> leD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "ultimately"], ["proof (chain)\npicking this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False", "have \\<dagger>: \"\\<alpha>0 = \\<beta>0\""], ["proof (prove)\nusing this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<alpha>0 = \\<beta>0", "using Ord_linear_lt \\<open>Ord \\<alpha>0\\<close> \\<open>Ord \\<beta>0\\<close>"], ["proof (prove)\nusing this:\n  \\<beta>0 < \\<alpha>0 \\<Longrightarrow> False\n  \\<alpha>0 < \\<beta>0 \\<Longrightarrow> False\n  \\<lbrakk>Ord ?k; Ord ?l; ?k < ?l \\<Longrightarrow> ?thesis;\n   ?k = ?l \\<Longrightarrow> ?thesis;\n   ?l < ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Ord \\<alpha>0\n  Ord \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha>0 = \\<beta>0", "by blast"], ["proof (state)\nthis:\n  \\<alpha>0 = \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "moreover"], ["proof (state)\nthis:\n  \\<alpha>0 = \\<beta>0\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "have \"\\<alpha>s' = \\<beta>s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>s' = \\<beta>s'", "proof (rule step.IH)"], ["proof (state)\ngoal (7 subgoals):\n 1. ?y \\<in> elts \\<alpha>\n 2. list.set \\<alpha>s' \\<subseteq> ON\n 3. list.set \\<beta>s' \\<subseteq> ON\n 4. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s'\n 5. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s'\n 6. ?y = \\<omega>_sum \\<alpha>s'\n 7. ?y = \\<omega>_sum \\<beta>s'", "show \"\\<omega>_sum \\<alpha>s' \\<in> elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s' \\<in> elts \\<alpha>", "using step.prems \\<alpha>s"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set \\<beta>s \\<subseteq> ON\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s' \\<in> elts \\<alpha>", "by (simp add: Ord_mem_iff_lt \\<omega>_sum_less_self)"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s' \\<in> elts \\<alpha>\n\ngoal (6 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s'\n 4. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s'\n 5. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<alpha>s'\n 6. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'", "show \"\\<omega>_dec \\<alpha>s'\" \"\\<omega>_dec \\<beta>s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s' &&&\n    sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s'", "using \\<alpha>s \\<beta>s step.prems(3,4)"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>0 # \\<alpha>s'\n  \\<beta>s = \\<beta>0 # \\<beta>s'\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s' &&&\n    sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s'", "by auto"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<alpha>s'\n  sorted_wrt (\\<lambda>x y. y \\<le> x) \\<beta>s'\n\ngoal (4 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<alpha>s'\n 4. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'", "have \"\\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s", "using step.prems(5,6)"], ["proof (prove)\nusing this:\n  \\<alpha> = \\<omega>_sum \\<alpha>s\n  \\<alpha> = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s", "by auto"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s\n\ngoal (4 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<alpha>s'\n 4. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'", "then"], ["proof (chain)\npicking this:\n  \\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s", "show \"\\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'\""], ["proof (prove)\nusing this:\n  \\<omega>_sum \\<alpha>s = \\<omega>_sum \\<beta>s\n\ngoal (1 subgoal):\n 1. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'", "by (simp add: \\<dagger> \\<alpha>s \\<beta>s)"], ["proof (state)\nthis:\n  \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<beta>s'\n\ngoal (3 subgoals):\n 1. list.set \\<alpha>s' \\<subseteq> ON\n 2. list.set \\<beta>s' \\<subseteq> ON\n 3. \\<omega>_sum \\<alpha>s' = \\<omega>_sum \\<alpha>s'", "qed (use ON in auto)"], ["proof (state)\nthis:\n  \\<alpha>s' = \\<beta>s'\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<noteq> 0 \\<Longrightarrow> \\<alpha>s = \\<beta>s", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>0 = \\<beta>0\n  \\<alpha>s' = \\<beta>s'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>0 = \\<beta>0\n  \\<alpha>s' = \\<beta>s'\n\ngoal (1 subgoal):\n 1. \\<alpha>s = \\<beta>s", "by (simp add: \\<alpha>s \\<beta>s)"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>s = \\<beta>s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Indecomposable ordinals\\<close>"], ["", "text \\<open>Cf exercise 5 on page 43 of Kunen\\<close>"], ["", "definition indecomposable\n  where \"indecomposable \\<alpha> \\<equiv> Ord \\<alpha> \\<and> (\\<forall>\\<beta> \\<in> elts \\<alpha>. \\<forall>\\<gamma> \\<in> elts \\<alpha>. \\<beta>+\\<gamma> \\<in> elts \\<alpha>)\""], ["", "lemma indecomposableD:\n  \"\\<lbrakk>indecomposable \\<alpha>; \\<beta> < \\<alpha>; \\<gamma> < \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<beta>+\\<gamma> < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>indecomposable \\<alpha>; \\<beta> < \\<alpha>;\n     \\<gamma> < \\<alpha>; Ord \\<beta>; Ord \\<gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<beta> + \\<gamma> < \\<alpha>", "by (meson Ord_mem_iff_lt OrdmemD indecomposable_def)"], ["", "lemma indecomposable_imp_Ord:\n  \"indecomposable \\<alpha> \\<Longrightarrow> Ord \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable \\<alpha> \\<Longrightarrow> Ord \\<alpha>", "using indecomposable_def"], ["proof (prove)\nusing this:\n  indecomposable ?\\<alpha> \\<equiv>\n  Ord ?\\<alpha> \\<and>\n  (\\<forall>\\<beta>\\<in>elts ?\\<alpha>.\n      \\<forall>\\<gamma>\\<in>elts ?\\<alpha>.\n         \\<beta> + \\<gamma> \\<in> elts ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. indecomposable \\<alpha> \\<Longrightarrow> Ord \\<alpha>", "by blast"], ["", "lemma indecomposable_1: \"indecomposable 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable 1", "by (auto simp: indecomposable_def)"], ["", "lemma indecomposable_0: \"indecomposable 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable 0", "by (auto simp: indecomposable_def)"], ["", "lemma indecomposable_succ [simp]: \"indecomposable (succ \\<alpha>) \\<longleftrightarrow> \\<alpha> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable (ZFC_in_HOL.succ \\<alpha>) = (\\<alpha> = 0)", "using not_add_mem_right"], ["proof (prove)\nusing this:\n  ?x + ?y \\<notin> elts ?x\n\ngoal (1 subgoal):\n 1. indecomposable (ZFC_in_HOL.succ \\<alpha>) = (\\<alpha> = 0)", "apply (auto simp: indecomposable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. x + y \\<notin> elts x;\n     Ord (ZFC_in_HOL.succ \\<alpha>); \\<alpha> + \\<alpha> = \\<alpha>;\n     \\<forall>\\<gamma>\\<in>elts \\<alpha>. \\<alpha> + \\<gamma> = \\<alpha>;\n     \\<forall>\\<beta>\\<in>elts \\<alpha>.\n        (\\<beta> + \\<alpha> = \\<alpha> \\<or>\n         \\<beta> + \\<alpha> \\<in> elts \\<alpha>) \\<and>\n        (\\<forall>\\<gamma>\\<in>elts \\<alpha>.\n            \\<beta> + \\<gamma> = \\<alpha> \\<or>\n            \\<beta> + \\<gamma> \\<in> elts \\<alpha>)\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> = 0", "apply (metis add_right_cancel add.right_neutral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma indecomposable_alt:\n  assumes ord: \"Ord \\<alpha>\" \"Ord \\<beta>\" and \\<beta>: \"\\<beta> < \\<alpha>\" and minor: \"\\<And>\\<beta> \\<gamma>. \\<lbrakk>\\<beta> < \\<alpha>; \\<gamma> < \\<alpha>; Ord \\<gamma>\\<rbrakk> \\<Longrightarrow> \\<beta>+\\<gamma> < \\<alpha>\"\n  shows \"\\<beta>+\\<alpha> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "have \"\\<not> \\<beta>+\\<alpha> < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<beta> + \\<alpha> < \\<alpha>", "by (simp add: add_le_left ord leD)"], ["proof (state)\nthis:\n  \\<not> \\<beta> + \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<beta> + \\<alpha> < \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "have \"\\<not> \\<alpha> < \\<beta>+\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<alpha> < \\<beta> + \\<alpha>", "by (metis assms le_Ord_diff less_V_def)"], ["proof (state)\nthis:\n  \\<not> \\<alpha> < \\<beta> + \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<beta> + \\<alpha> < \\<alpha>\n  \\<not> \\<alpha> < \\<beta> + \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<beta> + \\<alpha> < \\<alpha>\n  \\<not> \\<alpha> < \\<beta> + \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "by (simp add: add_le_left less_V_def ord)"], ["proof (state)\nthis:\n  \\<beta> + \\<alpha> = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indecomposable_imp_eq:\n  assumes \"indecomposable \\<alpha>\" \"Ord \\<beta>\" \"\\<beta> < \\<alpha>\"\n  shows \"\\<beta>+\\<alpha> = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<alpha> = \\<alpha>", "by (metis assms indecomposableD indecomposable_def le_Ord_diff less_V_def less_irrefl)"], ["", "lemma indecomposable2:\n  assumes y: \"y < x\" and z: \"z < x\" and minor: \"\\<And>y::V. y < x \\<Longrightarrow> y+x = x\"\n  shows \"y+z < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + z < x", "by (metis add_less_cancel_left y z minor)"], ["", "lemma indecomposable_imp_Limit:\n  assumes indec: \"indecomposable \\<alpha>\" and \"\\<alpha> > 1\"\n  shows \"Limit \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<alpha>", "using indecomposable_imp_Ord [OF indec]"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. Limit \\<alpha>", "proof (cases rule: Ord_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> Limit \\<alpha>\n 2. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> Limit \\<alpha>\n 3. Limit \\<alpha> \\<Longrightarrow> Limit \\<alpha>", "case (succ \\<beta>)"], ["proof (state)\nthis:\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>\n\ngoal (3 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> Limit \\<alpha>\n 2. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> Limit \\<alpha>\n 3. Limit \\<alpha> \\<Longrightarrow> Limit \\<alpha>", "then"], ["proof (chain)\npicking this:\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>\n\ngoal (1 subgoal):\n 1. Limit \\<alpha>", "using assms one_V_def"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  ZFC_in_HOL.succ \\<beta> = \\<alpha>\n  indecomposable \\<alpha>\n  1 < \\<alpha>\n  1 \\<equiv> ZFC_in_HOL.succ 0\n\ngoal (1 subgoal):\n 1. Limit \\<alpha>", "by auto"], ["proof (state)\nthis:\n  Limit \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<alpha> = 0 \\<Longrightarrow> Limit \\<alpha>\n 2. Limit \\<alpha> \\<Longrightarrow> Limit \\<alpha>", "qed (use assms in auto)"], ["", "lemma eq_imp_indecomposable:\n  assumes \"Ord \\<alpha>\" \"\\<And>\\<beta>::V. \\<beta> \\<in> elts \\<alpha> \\<Longrightarrow> \\<beta>+\\<alpha> = \\<alpha>\"\n  shows \"indecomposable \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable \\<alpha>", "by (metis add_mem_right_cancel assms indecomposable_def)"], ["", "lemma indecomposable_\\<omega>_power:\n  assumes \"Ord \\<delta>\"\n  shows \"indecomposable (\\<omega>\\<up>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<delta>)", "unfolding indecomposable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<delta>) \\<and>\n    (\\<forall>\\<beta>\\<in>elts (\\<omega> \\<up> \\<delta>).\n        \\<forall>\\<gamma>\\<in>elts (\\<omega> \\<up> \\<delta>).\n           \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>))", "proof (intro conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ord (\\<omega> \\<up> \\<delta>)\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "show \"Ord (\\<omega>\\<up>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<delta>)", "by (simp add: \\<open>Ord \\<delta>\\<close>)"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "fix \\<beta> \\<gamma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "assume asm: \"\\<beta> \\<in> elts (\\<omega>\\<up>\\<delta>)\" \"\\<gamma> \\<in> elts (\\<omega>\\<up>\\<delta>)\""], ["proof (state)\nthis:\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>)\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>)\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "obtain ord: \"Ord \\<beta>\" \"Ord \\<gamma>\" and \\<beta>: \"\\<beta> < \\<omega>\\<up>\\<delta>\" and \\<gamma>: \"\\<gamma> < \\<omega>\\<up>\\<delta>\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>)\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<beta>; Ord \\<gamma>; \\<beta> < \\<omega> \\<up> \\<delta>;\n      \\<gamma> < \\<omega> \\<up> \\<delta>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson Ord_\\<omega> Ord_in_Ord Ord_oexp OrdmemD \\<open>Ord \\<delta>\\<close>)"], ["proof (state)\nthis:\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<beta> < \\<omega> \\<up> \\<delta>\n  \\<gamma> < \\<omega> \\<up> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>);\n        \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)", "show \"\\<beta> + \\<gamma> \\<in> elts (\\<omega>\\<up>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "using \\<open>Ord \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<delta>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "proof (cases \\<delta> rule: Ord_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 3. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "case 0"], ["proof (state)\nthis:\n  \\<delta> = 0\n\ngoal (3 subgoals):\n 1. \\<delta> = 0 \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 3. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<delta> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta> = 0\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "using \\<open>Ord \\<delta>\\<close> asm"], ["proof (prove)\nusing this:\n  \\<delta> = 0\n  Ord \\<delta>\n  \\<beta> \\<in> elts (\\<omega> \\<up> \\<delta>)\n  \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "by auto"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "case (succ l)"], ["proof (state)\nthis:\n  Ord l\n  ZFC_in_HOL.succ l = \\<delta>\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "have \"\\<exists>x\\<in>elts \\<omega>. \\<beta> + \\<gamma> \\<in> elts (\\<omega>\\<up>l * x)\"\n      if x: \"x \\<in> elts \\<omega>\" \"\\<beta> \\<in> elts (\\<omega>\\<up>l * x)\" and y: \"y \\<in> elts \\<omega>\" \"\\<gamma> \\<in> elts (\\<omega>\\<up>l * y)\"\n      for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "obtain \"Ord x\" \"Ord y\" \"Ord (\\<omega>\\<up>l * x)\" \"Ord (\\<omega>\\<up>l * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord x; Ord y; Ord (\\<omega> \\<up> l * x);\n      Ord (\\<omega> \\<up> l * y)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_\\<omega> Ord_mult Ord_oexp x y nat_into_Ord succ(1)"], ["proof (prove)\nusing this:\n  Ord \\<omega>\n  \\<lbrakk>Ord ?y; Ord ?x\\<rbrakk> \\<Longrightarrow> Ord (?x * ?y)\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  x \\<in> elts \\<omega>\n  \\<beta> \\<in> elts (\\<omega> \\<up> l * x)\n  y \\<in> elts \\<omega>\n  \\<gamma> \\<in> elts (\\<omega> \\<up> l * y)\n  ?n \\<in> elts \\<omega> \\<Longrightarrow> Ord ?n\n  Ord l\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord x; Ord y; Ord (\\<omega> \\<up> l * x);\n      Ord (\\<omega> \\<up> l * y)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  Ord x\n  Ord y\n  Ord (\\<omega> \\<up> l * x)\n  Ord (\\<omega> \\<up> l * y)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "then"], ["proof (chain)\npicking this:\n  Ord x\n  Ord y\n  Ord (\\<omega> \\<up> l * x)\n  Ord (\\<omega> \\<up> l * y)", "have \"\\<beta> + \\<gamma> \\<in> elts (\\<omega>\\<up>l * (x+y))\""], ["proof (prove)\nusing this:\n  Ord x\n  Ord y\n  Ord (\\<omega> \\<up> l * x)\n  Ord (\\<omega> \\<up> l * y)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))", "using add_mult_distrib Ord_add Ord_mem_iff_lt add_strict_mono ord x y"], ["proof (prove)\nusing this:\n  Ord x\n  Ord y\n  Ord (\\<omega> \\<up> l * x)\n  Ord (\\<omega> \\<up> l * y)\n  ?x * (?y + ?z) = ?x * ?y + ?x * ?z\n  \\<lbrakk>Ord ?x; Ord ?y\\<rbrakk> \\<Longrightarrow> Ord (?x + ?y)\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  \\<lbrakk>?\\<alpha> < ?\\<beta>; ?\\<gamma> < ?\\<delta>; Ord ?\\<alpha>;\n   Ord ?\\<beta>; Ord ?\\<gamma>; Ord ?\\<delta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> + ?\\<gamma> < ?\\<beta> + ?\\<delta>\n  Ord \\<beta>\n  Ord \\<gamma>\n  x \\<in> elts \\<omega>\n  \\<beta> \\<in> elts (\\<omega> \\<up> l * x)\n  y \\<in> elts \\<omega>\n  \\<gamma> \\<in> elts (\\<omega> \\<up> l * y)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))", "by presburger"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "then"], ["proof (chain)\npicking this:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "using x y"], ["proof (prove)\nusing this:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * (x + y))\n  x \\<in> elts \\<omega>\n  \\<beta> \\<in> elts (\\<omega> \\<up> l * x)\n  y \\<in> elts \\<omega>\n  \\<gamma> \\<in> elts (\\<omega> \\<up> l * y)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>elts \\<omega>.\n       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>elts \\<omega>.\n     \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> elts \\<omega>;\n   \\<beta> \\<in> elts (\\<omega> \\<up> l * ?x); ?y \\<in> elts \\<omega>;\n   \\<gamma> \\<in> elts (\\<omega> \\<up> l * ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>elts \\<omega>.\n                       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>Ord l; ZFC_in_HOL.succ l = \\<delta>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma>\n                         \\<in> elts (\\<omega> \\<up> \\<delta>)\n 2. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> elts \\<omega>;\n   \\<beta> \\<in> elts (\\<omega> \\<up> l * ?x); ?y \\<in> elts \\<omega>;\n   \\<gamma> \\<in> elts (\\<omega> \\<up> l * ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>elts \\<omega>.\n                       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<omega>;\n   \\<beta> \\<in> elts (\\<omega> \\<up> l * ?x); ?y \\<in> elts \\<omega>;\n   \\<gamma> \\<in> elts (\\<omega> \\<up> l * ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>elts \\<omega>.\n                       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "using \\<open>Ord \\<delta>\\<close> succ ord \\<beta> \\<gamma>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> elts \\<omega>;\n   \\<beta> \\<in> elts (\\<omega> \\<up> l * ?x); ?y \\<in> elts \\<omega>;\n   \\<gamma> \\<in> elts (\\<omega> \\<up> l * ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>elts \\<omega>.\n                       \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> l * x)\n  Ord \\<delta>\n  Ord l\n  ZFC_in_HOL.succ l = \\<delta>\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<beta> < \\<omega> \\<up> \\<delta>\n  \\<gamma> < \\<omega> \\<up> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "by (auto simp: mult_Limit simp flip: Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "case limit"], ["proof (state)\nthis:\n  Limit \\<delta>\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "have \"Ord (\\<omega>\\<up>\\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<delta>)", "by (simp add: \\<open>Ord \\<delta>\\<close>)"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  Ord (\\<omega> \\<up> \\<delta>)", "obtain x y where x: \"x \\<in> elts \\<delta>\" \"Ord x\" \"\\<beta> \\<in> elts (\\<omega>\\<up>x)\"\n      and y: \"y \\<in> elts \\<delta>\" \"Ord y\" \"\\<gamma> \\<in> elts (\\<omega>\\<up>y)\""], ["proof (prove)\nusing this:\n  Ord (\\<omega> \\<up> \\<delta>)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> elts \\<delta>; Ord x;\n         \\<beta> \\<in> elts (\\<omega> \\<up> x); y \\<in> elts \\<delta>;\n         Ord y; \\<gamma> \\<in> elts (\\<omega> \\<up> y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Ord \\<delta>\\<close> limit ord \\<beta> \\<gamma> oexp_Limit"], ["proof (prove)\nusing this:\n  Ord (\\<omega> \\<up> \\<delta>)\n  Ord \\<delta>\n  Limit \\<delta>\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<beta> < \\<omega> \\<up> \\<delta>\n  \\<gamma> < \\<omega> \\<up> \\<delta>\n  Limit ?\\<beta> \\<Longrightarrow>\n  ?\\<alpha> \\<up> ?\\<beta> =\n  (if ?\\<alpha> = 0 then 0\n   else \\<Squnion> ((\\<up>) ?\\<alpha> ` elts ?\\<beta>))\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> elts \\<delta>; Ord x;\n         \\<beta> \\<in> elts (\\<omega> \\<up> x); y \\<in> elts \\<delta>;\n         Ord y; \\<gamma> \\<in> elts (\\<omega> \\<up> y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp flip: Ord_mem_iff_lt intro: Ord_in_Ord)"], ["proof (state)\nthis:\n  x \\<in> elts \\<delta>\n  Ord x\n  \\<beta> \\<in> elts (\\<omega> \\<up> x)\n  y \\<in> elts \\<delta>\n  Ord y\n  \\<gamma> \\<in> elts (\\<omega> \\<up> y)\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts \\<delta>\n  Ord x\n  \\<beta> \\<in> elts (\\<omega> \\<up> x)\n  y \\<in> elts \\<delta>\n  Ord y\n  \\<gamma> \\<in> elts (\\<omega> \\<up> y)", "have \"succ (x \\<squnion> y) \\<in> elts \\<delta>\""], ["proof (prove)\nusing this:\n  x \\<in> elts \\<delta>\n  Ord x\n  \\<beta> \\<in> elts (\\<omega> \\<up> x)\n  y \\<in> elts \\<delta>\n  Ord y\n  \\<gamma> \\<in> elts (\\<omega> \\<up> y)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>", "by (metis Limit_def Ord_linear_le limit sup.absorb2 sup.orderE)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "moreover"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "have \"\\<beta> + \\<gamma> \\<in> elts (\\<omega>\\<up>succ (x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "have oxy: \"Ord (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (x \\<squnion> y)", "using Ord_sup x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?x; Ord ?y\\<rbrakk> \\<Longrightarrow> Ord (?x \\<squnion> ?y)\n  x \\<in> elts \\<delta>\n  Ord x\n  \\<beta> \\<in> elts (\\<omega> \\<up> x)\n  y \\<in> elts \\<delta>\n  Ord y\n  \\<gamma> \\<in> elts (\\<omega> \\<up> y)\n\ngoal (1 subgoal):\n 1. Ord (x \\<squnion> y)", "by blast"], ["proof (state)\nthis:\n  Ord (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "then"], ["proof (chain)\npicking this:\n  Ord (x \\<squnion> y)", "obtain \"\\<omega>\\<up>x \\<le> \\<omega>\\<up>(x \\<squnion> y)\" \"\\<omega>\\<up>y \\<le> \\<omega>\\<up>(x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  Ord (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<omega> \\<up> x \\<le> \\<omega> \\<up> (x \\<squnion> y);\n      \\<omega> \\<up> y \\<le> \\<omega> \\<up> (x \\<squnion> y)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_\\<omega> Ord_linear_le Ord_mem_iff_less_TC Ord_mem_iff_lt le_TC_def less_le_not_le oexp_mono omega_nonzero sup.absorb2 sup.orderE x(2) y(2))"], ["proof (state)\nthis:\n  \\<omega> \\<up> x \\<le> \\<omega> \\<up> (x \\<squnion> y)\n  \\<omega> \\<up> y \\<le> \\<omega> \\<up> (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> x \\<le> \\<omega> \\<up> (x \\<squnion> y)\n  \\<omega> \\<up> y \\<le> \\<omega> \\<up> (x \\<squnion> y)", "have \"\\<beta> \\<in> elts (\\<omega>\\<up>(x \\<squnion> y))\" \"\\<gamma> \\<in> elts (\\<omega>\\<up>(x \\<squnion> y))\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> x \\<le> \\<omega> \\<up> (x \\<squnion> y)\n  \\<omega> \\<up> y \\<le> \\<omega> \\<up> (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y)) &&&\n    \\<gamma> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))", "using x y"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> x \\<le> \\<omega> \\<up> (x \\<squnion> y)\n  \\<omega> \\<up> y \\<le> \\<omega> \\<up> (x \\<squnion> y)\n  x \\<in> elts \\<delta>\n  Ord x\n  \\<beta> \\<in> elts (\\<omega> \\<up> x)\n  y \\<in> elts \\<delta>\n  Ord y\n  \\<gamma> \\<in> elts (\\<omega> \\<up> y)\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y)) &&&\n    \\<gamma> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))", "by blast+"], ["proof (state)\nthis:\n  \\<beta> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))\n  \\<gamma> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))\n  \\<gamma> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))", "have \"\\<beta> + \\<gamma> \\<in> elts (\\<omega>\\<up>(x \\<squnion> y) * succ (succ 0))\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))\n  \\<gamma> \\<in> elts (\\<omega> \\<up> (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts\n           (\\<omega> \\<up> (x \\<squnion> y) *\n            ZFC_in_HOL.succ (ZFC_in_HOL.succ 0))", "by (metis Ord_\\<omega> Ord_add Ord_mem_iff_lt Ord_oexp Ord_sup add_strict_mono mult.right_neutral mult_succ ord one_V_def x(2) y(2))"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma>\n  \\<in> elts\n         (\\<omega> \\<up> (x \\<squnion> y) *\n          ZFC_in_HOL.succ (ZFC_in_HOL.succ 0))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "then"], ["proof (chain)\npicking this:\n  \\<beta> + \\<gamma>\n  \\<in> elts\n         (\\<omega> \\<up> (x \\<squnion> y) *\n          ZFC_in_HOL.succ (ZFC_in_HOL.succ 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> + \\<gamma>\n  \\<in> elts\n         (\\<omega> \\<up> (x \\<squnion> y) *\n          ZFC_in_HOL.succ (ZFC_in_HOL.succ 0))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "apply (simp add: oxy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts\n           (\\<omega> \\<up> (x \\<squnion> y) *\n            ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)) \\<Longrightarrow>\n    \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> (x \\<squnion> y) * \\<omega>)", "using Ord_\\<omega> Ord_mult Ord_oexp Ord_trans mem_0_Ord mult_add_mem_0 oexp_eq_0_iff omega_nonzero oxy succ_in_omega"], ["proof (prove)\nusing this:\n  Ord \\<omega>\n  \\<lbrakk>Ord ?y; Ord ?x\\<rbrakk> \\<Longrightarrow> Ord (?x * ?y)\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n  \\<lbrakk>Ord ?k; ?k \\<noteq> 0\\<rbrakk> \\<Longrightarrow> 0 \\<in> elts ?k\n  (?a * ?x \\<in> elts (?a * ?y)) = (?x \\<in> elts ?y \\<and> 0 \\<in> elts ?a)\n  Ord ?\\<beta> \\<Longrightarrow>\n  (?\\<alpha> \\<up> ?\\<beta> = 0) =\n  (?\\<alpha> = 0 \\<and> ?\\<beta> \\<noteq> 0)\n  \\<omega> \\<noteq> 0\n  Ord (x \\<squnion> y)\n  ?n \\<in> elts \\<omega> \\<Longrightarrow>\n  ZFC_in_HOL.succ ?n \\<in> elts \\<omega>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma>\n    \\<in> elts\n           (\\<omega> \\<up> (x \\<squnion> y) *\n            ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)) \\<Longrightarrow>\n    \\<beta> + \\<gamma>\n    \\<in> elts (\\<omega> \\<up> (x \\<squnion> y) * \\<omega>)", "by presburger"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma>\n  \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma>\n  \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "ultimately"], ["proof (chain)\npicking this:\n  ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>\n  \\<beta> + \\<gamma>\n  \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))", "show ?thesis"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>\n  \\<beta> + \\<gamma>\n  \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "using ord \\<open>Ord (\\<omega>\\<up>\\<delta>)\\<close> limit oexp_Limit"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ (x \\<squnion> y) \\<in> elts \\<delta>\n  \\<beta> + \\<gamma>\n  \\<in> elts (\\<omega> \\<up> ZFC_in_HOL.succ (x \\<squnion> y))\n  Ord \\<beta>\n  Ord \\<gamma>\n  Ord (\\<omega> \\<up> \\<delta>)\n  Limit \\<delta>\n  Limit ?\\<beta> \\<Longrightarrow>\n  ?\\<alpha> \\<up> ?\\<beta> =\n  (if ?\\<alpha> = 0 then 0\n   else \\<Squnion> ((\\<up>) ?\\<alpha> ` elts ?\\<beta>))\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)", "by auto"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts (\\<omega> \\<up> \\<delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<omega>_power_imp_eq:\n  assumes \"\\<beta> < \\<omega>\\<up>\\<delta>\" \"Ord \\<beta>\" \"Ord \\<delta>\" \"\\<delta> \\<noteq> 0\"\n  shows \"\\<beta> + \\<omega>\\<up>\\<delta> = \\<omega>\\<up>\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<omega> \\<up> \\<delta> = \\<omega> \\<up> \\<delta>", "by (simp add: assms indecomposable_\\<omega>_power indecomposable_imp_eq)"], ["", "lemma type_imp_indecomposable:\n  assumes \\<alpha>: \"Ord \\<alpha>\"\n    and minor: \"\\<And>X. X \\<subseteq> elts \\<alpha> \\<Longrightarrow> ordertype X VWF = \\<alpha> \\<or> ordertype (elts \\<alpha> - X) VWF = \\<alpha>\"\n  shows \"indecomposable \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable \\<alpha>", "unfolding indecomposable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<and>\n    (\\<forall>\\<beta>\\<in>elts \\<alpha>.\n        \\<forall>\\<gamma>\\<in>elts \\<alpha>.\n           \\<beta> + \\<gamma> \\<in> elts \\<alpha>)", "proof (intro conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts \\<alpha>;\n        \\<gamma> \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "fix \\<beta> \\<gamma>"], ["proof (state)\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts \\<alpha>;\n        \\<gamma> \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "assume \\<beta>: \"\\<beta> \\<in> elts \\<alpha>\" and \\<gamma>: \"\\<gamma> \\<in> elts \\<alpha>\""], ["proof (state)\nthis:\n  \\<beta> \\<in> elts \\<alpha>\n  \\<gamma> \\<in> elts \\<alpha>\n\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts \\<alpha>;\n        \\<gamma> \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<in> elts \\<alpha>\n  \\<gamma> \\<in> elts \\<alpha>", "obtain \\<beta>\\<gamma>: \"elts \\<beta> \\<subseteq> elts \\<alpha>\" \"elts \\<gamma> \\<subseteq> elts \\<alpha>\" \"Ord \\<beta>\" \"Ord \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts \\<alpha>\n  \\<gamma> \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>elts \\<beta> \\<subseteq> elts \\<alpha>;\n      elts \\<gamma> \\<subseteq> elts \\<alpha>; Ord \\<beta>;\n      Ord \\<gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<alpha> Ord_in_Ord Ord_trans"], ["proof (prove)\nusing this:\n  \\<beta> \\<in> elts \\<alpha>\n  \\<gamma> \\<in> elts \\<alpha>\n  Ord \\<alpha>\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>elts \\<beta> \\<subseteq> elts \\<alpha>;\n      elts \\<gamma> \\<subseteq> elts \\<alpha>; Ord \\<beta>;\n      Ord \\<gamma>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  elts \\<beta> \\<subseteq> elts \\<alpha>\n  elts \\<gamma> \\<subseteq> elts \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>\n\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts \\<alpha>;\n        \\<gamma> \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "then"], ["proof (chain)\npicking this:\n  elts \\<beta> \\<subseteq> elts \\<alpha>\n  elts \\<gamma> \\<subseteq> elts \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>", "have oeq: \"ordertype (elts \\<beta>) VWF = \\<beta>\""], ["proof (prove)\nusing this:\n  elts \\<beta> \\<subseteq> elts \\<alpha>\n  elts \\<gamma> \\<subseteq> elts \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<beta>) VWF = \\<beta>", "by auto"], ["proof (state)\nthis:\n  ordertype (elts \\<beta>) VWF = \\<beta>\n\ngoal (2 subgoals):\n 1. Ord \\<alpha>\n 2. \\<And>\\<beta> \\<gamma>.\n       \\<lbrakk>\\<beta> \\<in> elts \\<alpha>;\n        \\<gamma> \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "show \"\\<beta> + \\<gamma> \\<in> elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<in> elts \\<alpha>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<notin> elts \\<alpha> \\<Longrightarrow> False", "assume \"\\<beta> + \\<gamma> \\<notin> elts \\<alpha>\""], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<notin> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<notin> elts \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<beta> + \\<gamma> \\<notin> elts \\<alpha>", "obtain \\<delta> where \\<delta>: \"Ord \\<delta>\" \"\\<beta> + \\<delta> = \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<beta> + \\<gamma> \\<notin> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<beta> + \\<delta> = \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_ordertype \\<beta>\\<gamma>(1) le_Ord_diff less_eq_V_def minor oeq)"], ["proof (state)\nthis:\n  Ord \\<delta>\n  \\<beta> + \\<delta> = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<notin> elts \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Ord \\<delta>\n  \\<beta> + \\<delta> = \\<alpha>", "have \"\\<delta> \\<in> elts \\<alpha>\""], ["proof (prove)\nusing this:\n  Ord \\<delta>\n  \\<beta> + \\<delta> = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts \\<alpha>", "using Ord_linear \\<beta>\\<gamma> \\<gamma> \\<open>\\<beta> + \\<gamma> \\<notin> elts \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<delta>\n  \\<beta> + \\<delta> = \\<alpha>\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> ?k \\<in> elts ?l \\<or> ?k = ?l \\<or> ?l \\<in> elts ?k\n  elts \\<beta> \\<subseteq> elts \\<alpha>\n  elts \\<gamma> \\<subseteq> elts \\<alpha>\n  Ord \\<beta>\n  Ord \\<gamma>\n  \\<gamma> \\<in> elts \\<alpha>\n  \\<beta> + \\<gamma> \\<notin> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<delta> \\<in> elts \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<delta> \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<notin> elts \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<delta> \\<in> elts \\<alpha>", "have \"ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\""], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "using \\<delta> ordertype_diff Limit_def \\<alpha> \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  \\<delta> \\<in> elts \\<alpha>\n  Ord \\<delta>\n  \\<beta> + \\<delta> = \\<alpha>\n  \\<lbrakk>?\\<beta> + ?\\<delta> = ?\\<alpha>; ?\\<delta> \\<in> elts ?\\<alpha>;\n   Ord ?\\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordertype (elts ?\\<alpha> - elts ?\\<beta>) VWF =\n                    ?\\<delta>\n  Limit ?i \\<equiv>\n  Ord ?i \\<and>\n  0 \\<in> elts ?i \\<and>\n  (\\<forall>y.\n      y \\<in> elts ?i \\<longrightarrow> ZFC_in_HOL.succ y \\<in> elts ?i)\n  Ord \\<alpha>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "by blast"], ["proof (state)\nthis:\n  ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<beta> + \\<gamma> \\<notin> elts \\<alpha> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>", "show False"], ["proof (prove)\nusing this:\n  ordertype (elts \\<alpha> - elts \\<beta>) VWF = \\<delta>\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<beta> \\<open>\\<delta> \\<in> elts \\<alpha>\\<close> \\<open>elts \\<beta> \\<subseteq> elts \\<alpha>\\<close> oeq mem_not_refl minor)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> + \\<gamma> \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "qed (use assms in auto)"], ["", "text \\<open>This proof uses Cantor normal form, yet still is rather long\\<close>"], ["", "proposition indecomposable_is_\\<omega>_power:\n  assumes inc: \"indecomposable \\<mu>\"\n  obtains \"\\<mu> = 0\" | \\<delta> where \"Ord \\<delta>\" \"\\<mu> = \\<omega>\\<up>\\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"\\<mu> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<mu> = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<mu> = 0", "show thesis"], ["proof (prove)\nusing this:\n  \\<mu> = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<mu> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain \"Ord \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ord \\<mu> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Limit_def assms indecomposable_def"], ["proof (prove)\nusing this:\n  Limit ?i \\<equiv>\n  Ord ?i \\<and>\n  0 \\<in> elts ?i \\<and>\n  (\\<forall>y.\n      y \\<in> elts ?i \\<longrightarrow> ZFC_in_HOL.succ y \\<in> elts ?i)\n  indecomposable \\<mu>\n  indecomposable ?\\<alpha> \\<equiv>\n  Ord ?\\<alpha> \\<and>\n  (\\<forall>\\<beta>\\<in>elts ?\\<alpha>.\n      \\<forall>\\<gamma>\\<in>elts ?\\<alpha>.\n         \\<beta> + \\<gamma> \\<in> elts ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. (Ord \\<mu> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  Ord \\<mu>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Ord \\<mu>", "obtain \\<alpha>s ms where Cantor: \"List.set \\<alpha>s \\<subseteq> ON\" \"list.set ms \\<subseteq> {0<..}\"\n                                \"length \\<alpha>s = length ms\" \"Cantor_dec \\<alpha>s\"\n    and \\<mu>: \"\\<mu> = Cantor_sum \\<alpha>s ms\""], ["proof (prove)\nusing this:\n  Ord \\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<mu> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cantor_nf_exists"], ["proof (prove)\nusing this:\n  Ord \\<mu>\n  \\<lbrakk>Ord ?\\<alpha>;\n   \\<And>\\<alpha>s ms.\n      \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n       list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n       sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n       ?\\<alpha> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>s ms.\n        \\<lbrakk>list.set \\<alpha>s \\<subseteq> ON;\n         list.set ms \\<subseteq> {0<..}; length \\<alpha>s = length ms;\n         sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s;\n         \\<mu> = Cantor_sum \\<alpha>s ms\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<mu> = Cantor_sum \\<alpha>s ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "consider (0) \"length \\<alpha>s = 0\" | (1) \"length \\<alpha>s = 1\" | (2) \"length \\<alpha>s \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length \\<alpha>s = 0 \\<Longrightarrow> thesis;\n     length \\<alpha>s = 1 \\<Longrightarrow> thesis;\n     2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length \\<alpha>s = 0 \\<Longrightarrow> ?thesis;\n   length \\<alpha>s = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> length \\<alpha>s \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<mu> = 0 \\<Longrightarrow> thesis;\n     \\<And>\\<delta>.\n        \\<lbrakk>Ord \\<delta>; \\<mu> = \\<omega> \\<up> \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<mu> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length \\<alpha>s = 0 \\<Longrightarrow> ?thesis;\n   length \\<alpha>s = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> length \\<alpha>s \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length \\<alpha>s = 0 \\<Longrightarrow> ?thesis;\n   length \\<alpha>s = 1 \\<Longrightarrow> ?thesis;\n   2 \\<le> length \\<alpha>s \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. length \\<alpha>s = 0 \\<Longrightarrow> thesis\n 2. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 3. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  length \\<alpha>s = 0\n\ngoal (3 subgoals):\n 1. length \\<alpha>s = 0 \\<Longrightarrow> thesis\n 2. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 3. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length \\<alpha>s = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length \\<alpha>s = 0\n\ngoal (1 subgoal):\n 1. thesis", "using \\<mu> assms False indecomposable_def"], ["proof (prove)\nusing this:\n  length \\<alpha>s = 0\n  \\<mu> = Cantor_sum \\<alpha>s ms\n  indecomposable \\<mu>\n  \\<mu> \\<noteq> 0\n  indecomposable ?\\<alpha> \\<equiv>\n  Ord ?\\<alpha> \\<and>\n  (\\<forall>\\<beta>\\<in>elts ?\\<alpha>.\n      \\<forall>\\<gamma>\\<in>elts ?\\<alpha>.\n         \\<beta> + \\<gamma> \\<in> elts ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  length \\<alpha>s = 1\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length \\<alpha>s = 1", "obtain \\<alpha> m where \\<alpha>m: \"\\<alpha>s = [\\<alpha>]\" \"ms = [m]\""], ["proof (prove)\nusing this:\n  length \\<alpha>s = 1\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> m.\n        \\<lbrakk>\\<alpha>s = [\\<alpha>]; ms = [m]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def \\<open>length \\<alpha>s = length ms\\<close> length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  \\<alpha>s = [\\<alpha>]\n  ms = [m]\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = [\\<alpha>]\n  ms = [m]", "obtain \"Ord \\<alpha>\" \"m \\<noteq> 0\" \"Ord (\\<omega>\\<up>\\<alpha>)\""], ["proof (prove)\nusing this:\n  \\<alpha>s = [\\<alpha>]\n  ms = [m]\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<alpha>; m \\<noteq> 0;\n      Ord (\\<omega> \\<up> \\<alpha>)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>list.set \\<alpha>s \\<subseteq> ON\\<close> \\<open>list.set ms \\<subseteq> {0<..}\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>s = [\\<alpha>]\n  ms = [m]\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<alpha>; m \\<noteq> 0;\n      Ord (\\<omega> \\<up> \\<alpha>)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  m \\<noteq> 0\n  Ord (\\<omega> \\<up> \\<alpha>)\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \\<mu>: \"\\<mu> = \\<omega>\\<up>\\<alpha> * ord_of_nat m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m", "using \\<alpha>m"], ["proof (prove)\nusing this:\n  \\<alpha>s = [\\<alpha>]\n  ms = [m]\n\ngoal (1 subgoal):\n 1. \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m", "by (simp add: \\<mu>)"], ["proof (state)\nthis:\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \"m = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "assume \"m \\<noteq> 1\""], ["proof (state)\nthis:\n  m \\<noteq> 1\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  m \\<noteq> 1", "have 2: \"m \\<ge> 2\""], ["proof (prove)\nusing this:\n  m \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> m", "using \\<open>m \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  m \\<noteq> 1\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> m", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> m\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  2 \\<le> m", "have \"m = Suc 0 + Suc 0 + (m-2)\""], ["proof (prove)\nusing this:\n  2 \\<le> m\n\ngoal (1 subgoal):\n 1. m = Suc 0 + Suc 0 + (m - 2)", "by simp"], ["proof (state)\nthis:\n  m = Suc 0 + Suc 0 + (m - 2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  m = Suc 0 + Suc 0 + (m - 2)", "have \"ord_of_nat m = 1 + 1 + ord_of_nat (m-2)\""], ["proof (prove)\nusing this:\n  m = Suc 0 + Suc 0 + (m - 2)\n\ngoal (1 subgoal):\n 1. ord_of_nat m = 1 + 1 + ord_of_nat (m - 2)", "by (metis add.left_neutral mult.left_neutral mult_succ ord_of_nat.simps ord_of_nat_add)"], ["proof (state)\nthis:\n  ord_of_nat m = 1 + 1 + ord_of_nat (m - 2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ord_of_nat m = 1 + 1 + ord_of_nat (m - 2)", "have \\<mu>eq: \"\\<mu> = \\<omega>\\<up>\\<alpha> + \\<omega>\\<up>\\<alpha> + \\<omega>\\<up>\\<alpha> * ord_of_nat (m-2)\""], ["proof (prove)\nusing this:\n  ord_of_nat m = 1 + 1 + ord_of_nat (m - 2)\n\ngoal (1 subgoal):\n 1. \\<mu> =\n    \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n    \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)", "using \\<mu>"], ["proof (prove)\nusing this:\n  ord_of_nat m = 1 + 1 + ord_of_nat (m - 2)\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n\ngoal (1 subgoal):\n 1. \\<mu> =\n    \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n    \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)", "by (simp add: add_mult_distrib)"], ["proof (state)\nthis:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n  \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n  \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "have less: \"\\<omega>\\<up>\\<alpha> < \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> < \\<mu>", "by (metis Ord_\\<omega> OrdmemD \\<mu>eq \\<open>Ord \\<alpha>\\<close> add_le_cancel_left0 add_less_cancel_left0 le_less_trans less_V_def oexp_gt_0_iff zero_in_omega)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "have \"\\<omega>\\<up>\\<alpha> + \\<omega>\\<up>\\<alpha> * ord_of_nat (m-2) < \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n    < \\<mu>", "using \"2\" \"\\<mu>\" \\<open>Ord \\<alpha>\\<close> assms less indecomposableD less_V_def"], ["proof (prove)\nusing this:\n  2 \\<le> m\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n  Ord \\<alpha>\n  indecomposable \\<mu>\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n  \\<lbrakk>indecomposable ?\\<alpha>; ?\\<beta> < ?\\<alpha>;\n   ?\\<gamma> < ?\\<alpha>; Ord ?\\<beta>; Ord ?\\<gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> + ?\\<gamma> < ?\\<alpha>\n  ?x < ?y \\<equiv> ?x \\<le> ?y \\<and> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n    < \\<mu>", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  < \\<mu>\n\ngoal (1 subgoal):\n 1. m \\<noteq> 1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n  \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  < \\<mu>", "show False"], ["proof (prove)\nusing this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n  \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  < \\<mu>\n\ngoal (1 subgoal):\n 1. False", "using indecomposableD [OF inc, of \"\\<omega>\\<up>\\<alpha>\" \"\\<omega>\\<up>\\<alpha> + \\<omega>\\<up>\\<alpha> * ord_of_nat (m-2)\"]"], ["proof (prove)\nusing this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> +\n  \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  \\<omega> \\<up> \\<alpha> < \\<mu>\n  \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n  < \\<mu>\n  \\<lbrakk>\\<omega> \\<up> \\<alpha> < \\<mu>;\n   \\<omega> \\<up> \\<alpha> + \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2)\n   < \\<mu>;\n   Ord (\\<omega> \\<up> \\<alpha>);\n   Ord (\\<omega> \\<up> \\<alpha> +\n        \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2))\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha> +\n                    (\\<omega> \\<up> \\<alpha> +\n                     \\<omega> \\<up> \\<alpha> * ord_of_nat (m - 2))\n                    < \\<mu>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>Ord (\\<omega>\\<up>\\<alpha>)\\<close> add.assoc)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = 1\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  m = 1\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \"Ord \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "using \\<open>List.set \\<alpha>s \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  list.set \\<alpha>s \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "by (simp add: \\<open>\\<alpha>s = [\\<alpha>]\\<close>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (2 subgoals):\n 1. length \\<alpha>s = 1 \\<Longrightarrow> thesis\n 2. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n  m = 1\n  Ord \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> = \\<omega> \\<up> \\<alpha> * ord_of_nat m\n  m = 1\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. thesis", "by (metis One_nat_def mult.right_neutral ord_of_nat.simps one_V_def that(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  2 \\<le> length \\<alpha>s\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  2 \\<le> length \\<alpha>s", "obtain \\<alpha>1 \\<alpha>2 \\<alpha>s' m1 m2 ms' where \\<alpha>m: \"\\<alpha>s = \\<alpha>1#\\<alpha>2#\\<alpha>s'\" \"ms = m1#m2#ms'\""], ["proof (prove)\nusing this:\n  2 \\<le> length \\<alpha>s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>1 \\<alpha>2 \\<alpha>s' m1 m2 ms'.\n        \\<lbrakk>\\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s';\n         ms = m1 # m2 # ms'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Cantor(3) One_nat_def Suc_1 impossible_Cons length_Cons list.size(3) not_numeral_le_zero remdups_adj.cases)"], ["proof (state)\nthis:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'", "obtain \"Ord \\<alpha>1\" \"Ord \\<alpha>2\" \"m1 \\<noteq> 0\" \"m2 \\<noteq> 0\" \"Ord (\\<omega>\\<up>\\<alpha>1)\" \"Ord (\\<omega>\\<up>\\<alpha>2)\"\n                \"list.set \\<alpha>s' \\<subseteq> ON\" \"list.set ms' \\<subseteq> {0<..}\""], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<alpha>1; Ord \\<alpha>2; m1 \\<noteq> 0; m2 \\<noteq> 0;\n      Ord (\\<omega> \\<up> \\<alpha>1); Ord (\\<omega> \\<up> \\<alpha>2);\n      list.set \\<alpha>s' \\<subseteq> ON;\n      list.set ms' \\<subseteq> {0<..}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>list.set \\<alpha>s \\<subseteq> ON\\<close> \\<open>list.set ms \\<subseteq> {0<..}\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>Ord \\<alpha>1; Ord \\<alpha>2; m1 \\<noteq> 0; m2 \\<noteq> 0;\n      Ord (\\<omega> \\<up> \\<alpha>1); Ord (\\<omega> \\<up> \\<alpha>2);\n      list.set \\<alpha>s' \\<subseteq> ON;\n      list.set ms' \\<subseteq> {0<..}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>1\n  Ord \\<alpha>2\n  m1 \\<noteq> 0\n  m2 \\<noteq> 0\n  Ord (\\<omega> \\<up> \\<alpha>1)\n  Ord (\\<omega> \\<up> \\<alpha>2)\n  list.set \\<alpha>s' \\<subseteq> ON\n  list.set ms' \\<subseteq> {0<..}\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have oCs: \"Ord (Cantor_sum \\<alpha>s' ms')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (Cantor_sum \\<alpha>s' ms')", "by (simp add: Ord_Cantor_sum \\<open>list.set \\<alpha>s' \\<subseteq> ON\\<close>)"], ["proof (state)\nthis:\n  Ord (Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \\<alpha>21: \"\\<alpha>2 \\<in> elts \\<alpha>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 \\<in> elts \\<alpha>1", "using Cantor_dec_Cons_iff \\<alpha>m(1) \\<open>Cantor_dec \\<alpha>s\\<close>"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<beta> # ?\\<beta>s) =\n  (?\\<beta> < ?\\<alpha> \\<and>\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<beta> # ?\\<beta>s))\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n\ngoal (1 subgoal):\n 1. \\<alpha>2 \\<in> elts \\<alpha>1", "by (simp add: Ord_mem_iff_lt \\<open>Ord \\<alpha>1\\<close> \\<open>Ord \\<alpha>2\\<close>)"], ["proof (state)\nthis:\n  \\<alpha>2 \\<in> elts \\<alpha>1\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \"\\<omega>\\<up>\\<alpha>2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 \\<noteq> 0", "by (simp add: \\<open>Ord \\<alpha>2\\<close>)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha>2 \\<noteq> 0", "have *: \"(\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms') > 0\""], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'", "by (simp add: OrdmemD \\<open>Ord (\\<omega>\\<up>\\<alpha>2)\\<close> \\<open>m2 \\<noteq> 0\\<close> mem_0_Ord oCs)"], ["proof (state)\nthis:\n  0 < \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \\<mu>: \"\\<mu> = \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + (\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\"\n      (is \"\\<mu> = ?\\<alpha> + ?\\<beta>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> =\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')", "using \\<alpha>m"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'\n\ngoal (1 subgoal):\n 1. \\<mu> =\n    \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')", "by (simp add: \\<mu>)"], ["proof (state)\nthis:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have \"\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms' < \\<omega>\\<up>\\<alpha>1 * ord_of_nat m1 + (\\<omega>\\<up>\\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\"\n      if \"\\<alpha>2 \\<in> elts \\<alpha>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n    < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n      (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')", "proof (rule less_\\<omega>_power)"], ["proof (state)\ngoal (6 subgoals):\n 1. Ord \\<alpha>1\n 2. Ord (Cantor_sum \\<alpha>s' ms')\n 3. \\<alpha>2 \\<in> elts \\<alpha>1\n 4. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>2\n 5. 0 < m1\n 6. 0 < m2", "show \"Cantor_sum \\<alpha>s' ms' < \\<omega>\\<up>\\<alpha>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>2", "using \\<alpha>m Cantor cnf_2"], ["proof (prove)\nusing this:\n  \\<alpha>s = \\<alpha>1 # \\<alpha>2 # \\<alpha>s'\n  ms = m1 # m2 # ms'\n  list.set \\<alpha>s \\<subseteq> ON\n  list.set ms \\<subseteq> {0<..}\n  length \\<alpha>s = length ms\n  sorted_wrt (\\<lambda>x y. y < x) \\<alpha>s\n  \\<lbrakk>list.set (?\\<alpha> # ?\\<alpha>s) \\<subseteq> ON;\n   list.set ?ms \\<subseteq> {0<..}; length ?\\<alpha>s = length ?ms;\n   sorted_wrt (\\<lambda>x y. y < x) (?\\<alpha> # ?\\<alpha>s)\\<rbrakk>\n  \\<Longrightarrow> Cantor_sum ?\\<alpha>s ?ms < \\<omega> \\<up> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>2", "by auto"], ["proof (state)\nthis:\n  Cantor_sum \\<alpha>s' ms' < \\<omega> \\<up> \\<alpha>2\n\ngoal (5 subgoals):\n 1. Ord \\<alpha>1\n 2. Ord (Cantor_sum \\<alpha>s' ms')\n 3. \\<alpha>2 \\<in> elts \\<alpha>1\n 4. 0 < m1\n 5. 0 < m2", "qed (use oCs \\<open>Ord \\<alpha>1\\<close> \\<open>m1 \\<noteq> 0\\<close> \\<open>m2 \\<noteq> 0\\<close> that in auto)"], ["proof (state)\nthis:\n  \\<alpha>2 \\<in> elts \\<alpha>1 \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<alpha>2 \\<in> elts \\<alpha>1 \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')", "have \"?\\<beta> < \\<mu>\""], ["proof (prove)\nusing this:\n  \\<alpha>2 \\<in> elts \\<alpha>1 \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n    < \\<mu>", "using \\<alpha>21"], ["proof (prove)\nusing this:\n  \\<alpha>2 \\<in> elts \\<alpha>1 \\<Longrightarrow>\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n  \\<alpha>2 \\<in> elts \\<alpha>1\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n    < \\<mu>", "by (simp add: \\<mu> \\<alpha>m)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<mu>\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<mu>\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "have less: \"?\\<alpha> < \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>", "using oCs"], ["proof (prove)\nusing this:\n  Ord (Cantor_sum \\<alpha>s' ms')\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>", "by (metis \\<mu> \"*\" add_less_cancel_left add.right_neutral)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<mu>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>", "have False"], ["proof (prove)\nusing this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<mu>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>\n\ngoal (1 subgoal):\n 1. False", "using indecomposableD [OF inc, of \"?\\<alpha>\" \"?\\<beta>\"]"], ["proof (prove)\nusing this:\n  \\<mu> =\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n  (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms')\n  \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n  < \\<mu>\n  \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>\n  \\<lbrakk>\\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 < \\<mu>;\n   \\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 + Cantor_sum \\<alpha>s' ms'\n   < \\<mu>;\n   Ord (\\<omega> \\<up> \\<alpha>1 * ord_of_nat m1);\n   Ord (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 +\n        Cantor_sum \\<alpha>s' ms')\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<up> \\<alpha>1 * ord_of_nat m1 +\n                    (\\<omega> \\<up> \\<alpha>2 * ord_of_nat m2 +\n                     Cantor_sum \\<alpha>s' ms')\n                    < \\<mu>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: \\<open>Ord (\\<omega>\\<up>\\<alpha>1)\\<close> \\<open>Ord (\\<omega>\\<up>\\<alpha>2)\\<close> oCs)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. 2 \\<le> length \\<alpha>s \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary indecomposable_iff_\\<omega>_power:\n   \"indecomposable \\<mu> \\<longleftrightarrow> \\<mu> = 0 \\<or> (\\<exists>\\<delta>. \\<mu> = \\<omega>\\<up>\\<delta> \\<and> Ord \\<delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable \\<mu> =\n    (\\<mu> = 0 \\<or>\n     (\\<exists>\\<delta>.\n         \\<mu> = \\<omega> \\<up> \\<delta> \\<and> Ord \\<delta>))", "by (meson indecomposable_0 indecomposable_\\<omega>_power indecomposable_is_\\<omega>_power)"], ["", "theorem indecomposable_imp_type:\n  fixes X :: \"bool \\<Rightarrow> V set\"\n  assumes \\<gamma>: \"indecomposable \\<gamma>\"\n    and \"\\<And>b. ordertype (X b) VWF \\<le> \\<gamma>\" \"\\<And>b. small (X b)\" \"\\<And>b. X b \\<subseteq> ON\"\n    and \"elts \\<gamma> \\<subseteq> (UN b. X b)\"\n  shows \"\\<exists>b. ordertype (X b) VWF = \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = \\<gamma>", "using \\<gamma> [THEN indecomposable_imp_Ord] assms"], ["proof (prove)\nusing this:\n  Ord \\<gamma>\n  indecomposable \\<gamma>\n  ordertype (X ?b) VWF \\<le> \\<gamma>\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts \\<gamma> \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = \\<gamma>", "proof (induction arbitrary: X)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>X.\n           \\<lbrakk>indecomposable \\<alpha>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<alpha>;\n            \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n            elts \\<alpha> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<alpha>;\n        indecomposable (ZFC_in_HOL.succ \\<alpha>);\n        \\<And>b. ordertype (X b) VWF \\<le> ZFC_in_HOL.succ \\<alpha>;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (ZFC_in_HOL.succ \\<alpha>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF = ZFC_in_HOL.succ \\<alpha>\n 3. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "case (succ \\<beta>)"], ["proof (state)\nthis:\n  Ord \\<beta>\n  \\<lbrakk>indecomposable \\<beta>;\n   \\<And>b. ordertype (?X b) VWF \\<le> \\<beta>; \\<And>b. small (?X b);\n   \\<And>b. ?X b \\<subseteq> ON;\n   elts \\<beta> \\<subseteq> \\<Union> (range ?X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. ordertype (?X b) VWF = \\<beta>\n  indecomposable (ZFC_in_HOL.succ \\<beta>)\n  ordertype (X ?b) VWF \\<le> ZFC_in_HOL.succ \\<beta>\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (ZFC_in_HOL.succ \\<beta>) \\<subseteq> \\<Union> (range X)\n\ngoal (3 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>X.\n           \\<lbrakk>indecomposable \\<alpha>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<alpha>;\n            \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n            elts \\<alpha> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<alpha>;\n        indecomposable (ZFC_in_HOL.succ \\<alpha>);\n        \\<And>b. ordertype (X b) VWF \\<le> ZFC_in_HOL.succ \\<alpha>;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (ZFC_in_HOL.succ \\<alpha>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF = ZFC_in_HOL.succ \\<alpha>\n 3. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "proof (cases \"\\<beta> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "case True"], ["proof (state)\nthis:\n  \\<beta> = 0\n\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<beta> = 0", "have \"\\<exists>b. 0 \\<in> X b\""], ["proof (prove)\nusing this:\n  \\<beta> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>b. 0 \\<in> X b", "using succ.prems(5)"], ["proof (prove)\nusing this:\n  \\<beta> = 0\n  elts (ZFC_in_HOL.succ \\<beta>) \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. \\<exists>b. 0 \\<in> X b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. 0 \\<in> X b\n\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. 0 \\<in> X b", "have \"\\<exists>b. ordertype (X b) VWF \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>b. 0 \\<in> X b\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF \\<noteq> 0", "using succ.prems(3)"], ["proof (prove)\nusing this:\n  \\<exists>b. 0 \\<in> X b\n  small (X ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. ordertype (X b) VWF \\<noteq> 0", "have \"\\<exists>b. ordertype (X b) VWF \\<ge> succ 0\""], ["proof (prove)\nusing this:\n  \\<exists>b. ordertype (X b) VWF \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>b. ZFC_in_HOL.succ 0 \\<le> ordertype (X b) VWF", "by (meson Ord_0 Ord_linear2 Ord_ordertype less_eq_V_0_iff succ_le_iff)"], ["proof (state)\nthis:\n  \\<exists>b. ZFC_in_HOL.succ 0 \\<le> ordertype (X b) VWF\n\ngoal (2 subgoals):\n 1. \\<beta> = 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n 2. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. ZFC_in_HOL.succ 0 \\<le> ordertype (X b) VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>b. ZFC_in_HOL.succ 0 \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "using True succ.prems(2)"], ["proof (prove)\nusing this:\n  \\<exists>b. ZFC_in_HOL.succ 0 \\<le> ordertype (X b) VWF\n  \\<beta> = 0\n  ordertype (X ?b) VWF \\<le> ZFC_in_HOL.succ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "case False"], ["proof (state)\nthis:\n  \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<beta> \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "using succ.prems"], ["proof (prove)\nusing this:\n  \\<beta> \\<noteq> 0\n  indecomposable (ZFC_in_HOL.succ \\<beta>)\n  ordertype (X ?b) VWF \\<le> ZFC_in_HOL.succ \\<beta>\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (ZFC_in_HOL.succ \\<beta>) \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = ZFC_in_HOL.succ \\<beta>\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "case (Limit \\<gamma>)"], ["proof (state)\nthis:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; indecomposable ?\\<xi>;\n   \\<And>b. ordertype (?X b) VWF \\<le> ?\\<xi>; \\<And>b. small (?X b);\n   \\<And>b. ?X b \\<subseteq> ON;\n   elts ?\\<xi> \\<subseteq> \\<Union> (range ?X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. ordertype (?X b) VWF = ?\\<xi>\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; indecomposable ?\\<xi>;\n   \\<And>b. ordertype (?X b) VWF \\<le> ?\\<xi>; \\<And>b. small (?X b);\n   \\<And>b. ?X b \\<subseteq> ON;\n   elts ?\\<xi> \\<subseteq> \\<Union> (range ?X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. ordertype (?X b) VWF = ?\\<xi>\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)", "obtain \\<delta> where \\<delta>: \"\\<gamma> = \\<omega>\\<up>\\<delta>\" and \"\\<delta> \\<noteq> 0\" \"Ord \\<delta>\""], ["proof (prove)\nusing this:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; indecomposable ?\\<xi>;\n   \\<And>b. ordertype (?X b) VWF \\<le> ?\\<xi>; \\<And>b. small (?X b);\n   \\<And>b. ?X b \\<subseteq> ON;\n   elts ?\\<xi> \\<subseteq> \\<Union> (range ?X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. ordertype (?X b) VWF = ?\\<xi>\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<delta>.\n        \\<lbrakk>\\<gamma> = \\<omega> \\<up> \\<delta>; \\<delta> \\<noteq> 0;\n         Ord \\<delta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Limit_eq_Sup_self image_ident indecomposable_is_\\<omega>_power not_succ_Limit oexp_0_right one_V_def zero_not_Limit)"], ["proof (state)\nthis:\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n  \\<delta> \\<noteq> 0\n  Ord \\<delta>\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0\n 2. \\<And>\\<alpha> X.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> X.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; indecomposable \\<xi>;\n            \\<And>b. ordertype (X b) VWF \\<le> \\<xi>; \\<And>b. small (X b);\n            \\<And>b. X b \\<subseteq> ON;\n            elts \\<xi> \\<subseteq> \\<Union> (range X)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = \\<xi>;\n        indecomposable (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b.\n           ordertype (X b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>);\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\n        \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b.\n                            ordertype (X b) VWF =\n                            (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "proof (cases \"Limit \\<delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "case True"], ["proof (state)\nthis:\n  Limit \\<delta>\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have ot: \"\\<exists>b. ordertype (X b \\<inter> elts (\\<omega>\\<up>\\<alpha>)) VWF = \\<omega>\\<up>\\<alpha>\"\n      if \"\\<alpha> \\<in> elts \\<delta>\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF =\n       \\<omega> \\<up> \\<alpha>", "proof (rule Limit.IH)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>\n 2. indecomposable (\\<omega> \\<up> \\<alpha>)\n 3. \\<And>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n       \\<le> \\<omega> \\<up> \\<alpha>\n 4. \\<And>b. small (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n 5. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 6. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "have \"Ord \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "using Ord_in_Ord \\<open>Ord \\<delta>\\<close> that"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  Ord \\<delta>\n  \\<alpha> \\<in> elts \\<delta>\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "by blast"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (6 subgoals):\n 1. \\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>\n 2. indecomposable (\\<omega> \\<up> \\<alpha>)\n 3. \\<And>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n       \\<le> \\<omega> \\<up> \\<alpha>\n 4. \\<And>b. small (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n 5. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 6. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>", "show \"\\<omega>\\<up>\\<alpha> \\<in> elts \\<gamma>\""], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>", "by (simp add: Ord_mem_iff_lt \\<delta> \\<omega>_gt1 \\<open>Ord \\<delta>\\<close> oexp_less that)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>\n\ngoal (5 subgoals):\n 1. indecomposable (\\<omega> \\<up> \\<alpha>)\n 2. \\<And>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n       \\<le> \\<omega> \\<up> \\<alpha>\n 3. \\<And>b. small (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n 4. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 5. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "show \"indecomposable (\\<omega>\\<up>\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<alpha>)", "using \\<open>Ord \\<alpha>\\<close> indecomposable_1 indecomposable_\\<omega>_power"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  indecomposable 1\n  Ord ?\\<delta> \\<Longrightarrow> indecomposable (\\<omega> \\<up> ?\\<delta>)\n\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<alpha>)", "by fastforce"], ["proof (state)\nthis:\n  indecomposable (\\<omega> \\<up> \\<alpha>)\n\ngoal (4 subgoals):\n 1. \\<And>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n       \\<le> \\<omega> \\<up> \\<alpha>\n 2. \\<And>b. small (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n 3. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 4. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "show \"small (X b \\<inter> elts (\\<omega>\\<up>\\<alpha>))\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "by (meson down inf_le2)"], ["proof (state)\nthis:\n  small (X ?b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n       \\<le> \\<omega> \\<up> \\<alpha>\n 2. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 3. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "show \"ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF \\<le> \\<omega> \\<up> \\<alpha>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n    \\<le> \\<omega> \\<up> \\<alpha>", "by (simp add: \\<open>Ord \\<alpha>\\<close> ordertype_le_Ord)"], ["proof (state)\nthis:\n  ordertype (X ?b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n  \\<le> \\<omega> \\<up> \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<And>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n 2. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "show \"X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON", "by (simp add: Limit.prems inf.coboundedI1)"], ["proof (state)\nthis:\n  X ?b \\<inter> elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>a. X a \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "show \"elts (\\<omega> \\<up> \\<alpha>) \\<subseteq> (\\<Union>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "using Limit.prems Limit.hyps \\<open>\\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>\\<close>"], ["proof (prove)\nusing this:\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)\n  Limit \\<gamma>\n  \\<omega> \\<up> \\<alpha> \\<in> elts \\<gamma>\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<alpha>)\n    \\<subseteq> (\\<Union>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))", "by clarsimp (metis Ord_trans UN_E indecomposable_imp_Ord subset_eq)"], ["proof (state)\nthis:\n  elts (\\<omega> \\<up> \\<alpha>)\n  \\<subseteq> (\\<Union>b. X b \\<inter> elts (\\<omega> \\<up> \\<alpha>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> elts \\<delta> \\<Longrightarrow>\n  \\<exists>b.\n     ordertype (X b \\<inter> elts (\\<omega> \\<up> ?\\<alpha>)) VWF =\n     \\<omega> \\<up> ?\\<alpha>\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define A where \"A \\<equiv> \\<lambda>b. {\\<alpha> \\<in> elts \\<delta>. ordertype (X b \\<inter> elts (\\<omega>\\<up>\\<alpha>)) VWF \\<ge> \\<omega>\\<up>\\<alpha>}\""], ["proof (state)\nthis:\n  A \\<equiv>\n  \\<lambda>b.\n     {\\<alpha> \\<in> elts \\<delta>.\n      \\<omega> \\<up> \\<alpha>\n      \\<le> ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF}\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have Asmall: \"small (A b)\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (A b)", "by (simp add: A_def)"], ["proof (state)\nthis:\n  small (A ?b)\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have AON: \"A b \\<subseteq> ON\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. A b \\<subseteq> ON", "using A_def \\<open>Ord \\<delta>\\<close> elts_subset_ON"], ["proof (prove)\nusing this:\n  A \\<equiv>\n  \\<lambda>b.\n     {\\<alpha> \\<in> elts \\<delta>.\n      \\<omega> \\<up> \\<alpha>\n      \\<le> ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF}\n  Ord \\<delta>\n  Ord ?\\<alpha> \\<Longrightarrow> elts ?\\<alpha> \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. A b \\<subseteq> ON", "by blast"], ["proof (state)\nthis:\n  A ?b \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have eq: \"elts \\<delta> = (\\<Union> b. A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<delta> = \\<Union> (range A)", "by (auto simp: A_def) (metis ot eq_refl)"], ["proof (state)\nthis:\n  elts \\<delta> = \\<Union> (range A)\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  elts \\<delta> = \\<Union> (range A)", "obtain b where b: \"Sup (A b) = \\<delta>\""], ["proof (prove)\nusing this:\n  elts \\<delta> = \\<Union> (range A)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<Squnion> (A b) = \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Limit \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  elts \\<delta> = \\<Union> (range A)\n  Limit \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<Squnion> (A b) = \\<delta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (auto simp: UN_bool_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>b. \\<Squnion> (A b) = \\<delta> \\<Longrightarrow> thesis;\n     elts \\<delta> = A True \\<union> A False; Limit \\<delta>\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis AON ON_imp_Ord Ord_Sup Ord_linear_le Limit_eq_Sup_self Sup_Un_distrib Asmall sup.absorb2 sup.orderE)"], ["proof (state)\nthis:\n  \\<Squnion> (A b) = \\<delta>\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"\\<omega>\\<up>\\<alpha> \\<le> ordertype (X b) VWF\" if \"\\<alpha> \\<in> A b\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "have \"(\\<omega>\\<up>\\<alpha>) = ordertype ((X b) \\<inter> elts (\\<omega>\\<up>\\<alpha>)) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> =\n    ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF", "using \\<open>Ord \\<delta>\\<close> that"], ["proof (prove)\nusing this:\n  Ord \\<delta>\n  \\<alpha> \\<in> A b\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> =\n    ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF", "by (simp add: A_def Ord_in_Ord dual_order.antisym ordertype_le_Ord)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> =\n  ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> =\n  ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "have \"\\<dots> \\<le> ordertype (X b) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n    \\<le> ordertype (X b) VWF", "by (simp add: Limit.prems ordertype_VWF_mono)"], ["proof (state)\nthis:\n  ordertype (X b \\<inter> elts (\\<omega> \\<up> \\<alpha>)) VWF\n  \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "finally"], ["proof (chain)\npicking this:\n  \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF", "."], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<alpha> \\<le> ordertype (X b) VWF\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> A b \\<Longrightarrow>\n  \\<omega> \\<up> ?\\<alpha> \\<le> ordertype (X b) VWF\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  ?\\<alpha> \\<in> A b \\<Longrightarrow>\n  \\<omega> \\<up> ?\\<alpha> \\<le> ordertype (X b) VWF", "have \"ordertype (X b) VWF \\<ge> Sup ((\\<lambda>\\<alpha>. \\<omega>\\<up>\\<alpha>) ` A b)\""], ["proof (prove)\nusing this:\n  ?\\<alpha> \\<in> A b \\<Longrightarrow>\n  \\<omega> \\<up> ?\\<alpha> \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF", "by blast"], ["proof (state)\nthis:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"Sup ((\\<lambda>\\<alpha>. \\<omega>\\<up>\\<alpha>) ` A b) = \\<omega> \\<up> Sup (A b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> ((\\<up>) \\<omega> ` A b) = \\<omega> \\<up> \\<Squnion> (A b)", "by (metis b Ord_\\<omega> ZFC_in_HOL.Sup_empty AON \\<open>\\<delta> \\<noteq> 0\\<close> Asmall oexp_Sup omega_nonzero)"], ["proof (state)\nthis:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) = \\<omega> \\<up> \\<Squnion> (A b)\n\ngoal (2 subgoals):\n 1. Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n 2. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) = \\<omega> \\<up> \\<Squnion> (A b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) = \\<omega> \\<up> \\<Squnion> (A b)\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "using Limit.hyps Limit.prems \\<delta> b"], ["proof (prove)\nusing this:\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) \\<le> ordertype (X b) VWF\n  \\<Squnion> ((\\<up>) \\<omega> ` A b) = \\<omega> \\<up> \\<Squnion> (A b)\n  Limit \\<gamma>\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n  \\<Squnion> (A b) = \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "case False"], ["proof (state)\nthis:\n  \\<not> Limit \\<delta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<not> Limit \\<delta>", "obtain \\<beta> where \\<beta>: \"\\<delta> = succ \\<beta>\" \"Ord \\<beta>\""], ["proof (prove)\nusing this:\n  \\<not> Limit \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>\\<delta> = ZFC_in_HOL.succ \\<beta>; Ord \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_cases \\<open>\\<delta> \\<noteq> 0\\<close> \\<open>Ord \\<delta>\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Limit \\<delta>\n  \\<lbrakk>Ord ?k; ?k = 0 \\<Longrightarrow> ?thesis;\n   \\<And>l.\n      \\<lbrakk>Ord l; ZFC_in_HOL.succ l = ?k\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   Limit ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<delta> \\<noteq> 0\n  Ord \\<delta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        \\<lbrakk>\\<delta> = ZFC_in_HOL.succ \\<beta>; Ord \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>", "have Ord\\<omega>\\<beta>: \"Ord (\\<omega>\\<up>\\<beta>)\""], ["proof (prove)\nusing this:\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<beta>)", "using Ord_oexp"], ["proof (prove)\nusing this:\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  \\<lbrakk>Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> Ord (?\\<alpha> \\<up> ?\\<beta>)\n\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<beta>)", "by blast"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have subX12: \"elts (\\<omega>\\<up>\\<beta> * \\<omega>) \\<subseteq> (\\<Union>b. X b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<subseteq> \\<Union> (range X)", "using Limit \\<beta> \\<delta>"], ["proof (prove)\nusing this:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; indecomposable ?\\<xi>;\n   \\<And>b. ordertype (?X b) VWF \\<le> ?\\<xi>; \\<And>b. small (?X b);\n   \\<And>b. ?X b \\<subseteq> ON;\n   elts ?\\<xi> \\<subseteq> \\<Union> (range ?X)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b. ordertype (?X b) VWF = ?\\<xi>\n  indecomposable (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  small (X ?b)\n  X ?b \\<subseteq> ON\n  elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>) \\<subseteq> \\<Union> (range X)\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<subseteq> \\<Union> (range X)", "by auto"], ["proof (state)\nthis:\n  elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define E where \"E \\<equiv> \\<lambda>n. {\\<omega>\\<up>\\<beta> * ord_of_nat n ..< \\<omega>\\<up>\\<beta> * ord_of_nat (Suc n)} \\<inter> ON\""], ["proof (state)\nthis:\n  E \\<equiv>\n  \\<lambda>n.\n     {\\<omega> \\<up> \\<beta> *\n      ord_of_nat n..<\\<omega> \\<up> \\<beta> * ord_of_nat (Suc n)} \\<inter>\n     ON\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have EON: \"E n \\<subseteq> ON\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. E n \\<subseteq> ON", "using E_def"], ["proof (prove)\nusing this:\n  E \\<equiv>\n  \\<lambda>n.\n     {\\<omega> \\<up> \\<beta> *\n      ord_of_nat n..<\\<omega> \\<up> \\<beta> * ord_of_nat (Suc n)} \\<inter>\n     ON\n\ngoal (1 subgoal):\n 1. E n \\<subseteq> ON", "by blast"], ["proof (state)\nthis:\n  E ?n \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have E_imp_less: \"x < y\" if \"i < j\" \"x \\<in> E i\" \"y \\<in> E j\" for x y i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < y", "have \"succ (i) \\<le> ord_of_nat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j", "using that(1)"], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j", "by force"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j\n\ngoal (1 subgoal):\n 1. x < y", "then"], ["proof (chain)\npicking this:\n  ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j", "have \"\\<not> y \\<le> x\""], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x", "using that"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j\n  i < j\n  x \\<in> E i\n  y \\<in> E j\n\ngoal (1 subgoal):\n 1. \\<not> y \\<le> x", "apply (auto simp: E_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ZFC_in_HOL.succ (ord_of_nat i) \\<le> ord_of_nat j; i < j;\n     \\<omega> \\<up> \\<beta> * ord_of_nat i \\<le> x;\n     \\<omega> \\<up> \\<beta> * ord_of_nat j \\<le> y;\n     x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat i); Ord x;\n     y < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat j); Ord y;\n     y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis Ord\\<omega>\\<beta> Ord_ord_of_nat leD mult_cancel_le_iff ord_of_nat.simps(2) order_trans)"], ["proof (state)\nthis:\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. x < y", "with that"], ["proof (chain)\npicking this:\n  i < j\n  x \\<in> E i\n  y \\<in> E j\n  \\<not> y \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  x \\<in> E i\n  y \\<in> E j\n  \\<not> y \\<le> x\n\ngoal (1 subgoal):\n 1. x < y", "by (meson EON ON_imp_Ord Ord_linear2)"], ["proof (state)\nthis:\n  x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < ?j; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y", "have djE: \"disjnt (E i) (E j)\" if \"i \\<noteq> j\" for i j"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. disjnt (E i) (E j)", "using that nat_neq_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n  i \\<noteq> j\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. disjnt (E i) (E j)", "unfolding disjnt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?x < ?y\n  i \\<noteq> j\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. E i \\<inter> E j = {}", "by auto"], ["proof (state)\nthis:\n  ?i \\<noteq> ?j \\<Longrightarrow> disjnt (E ?i) (E ?j)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have less_imp_E: \"i \\<le> j\" if \"x < y\" \"x \\<in> E i\" \"y \\<in> E j\" for x y i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j", "using that E_imp_less [OF _ \\<open>y \\<in> E j\\<close> \\<open>x \\<in> E i\\<close>] leI less_asym"], ["proof (prove)\nusing this:\n  x < y\n  x \\<in> E i\n  y \\<in> E j\n  j < i \\<Longrightarrow> y < x\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  \\<lbrakk>?x < ?y; \\<not> ?P \\<Longrightarrow> ?y < ?x\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x < ?y; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?j\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have inc: \"indecomposable (\\<omega>\\<up>\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<beta>)", "using \\<beta> indecomposable_1 indecomposable_\\<omega>_power"], ["proof (prove)\nusing this:\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  indecomposable 1\n  Ord ?\\<delta> \\<Longrightarrow> indecomposable (\\<omega> \\<up> ?\\<delta>)\n\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<beta>)", "by fastforce"], ["proof (state)\nthis:\n  indecomposable (\\<omega> \\<up> \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have in_En: \"\\<omega>\\<up>\\<beta> * ord_of_nat n + x \\<in> E n\" if \"x \\<in> elts (\\<omega>\\<up>\\<beta>)\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> E n", "using that Ord\\<omega>\\<beta> Ord_in_Ord [OF Ord\\<omega>\\<beta>]"], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta>)\n  Ord (\\<omega> \\<up> \\<beta>)\n  ?m \\<in> elts (\\<omega> \\<up> \\<beta>) \\<Longrightarrow> Ord ?m\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> E n", "by (auto simp: E_def Ord\\<omega>\\<beta> OrdmemD mult_succ)"], ["proof (state)\nthis:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta>) \\<Longrightarrow>\n  \\<omega> \\<up> \\<beta> * ord_of_nat ?n + ?x \\<in> E ?n\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have *: \"elts \\<gamma> = \\<Union>(range E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<gamma> = \\<Union> (range E)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. elts \\<gamma> \\<subseteq> \\<Union> (range E)\n 2. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "have \"\\<exists>m. \\<omega>\\<up>\\<beta> * m \\<le> x \\<and> x < \\<omega>\\<up>\\<beta> * succ (ord_of_nat m)\"\n        if \"x \\<in> elts (\\<omega>\\<up>\\<beta> * ord_of_nat n)\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> x \\<and>\n       x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat n)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> x \\<and>\n       x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)", "apply (clarsimp simp add: mult [of _ \"ord_of_nat n\"] lift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa m.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta>);\n        x = \\<omega> \\<up> \\<beta> * ord_of_nat m + xa; m < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ma.\n                            \\<omega> \\<up> \\<beta> * ord_of_nat ma\n                            \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat m +\n                                  xa \\<and>\n                            \\<omega> \\<up> \\<beta> * ord_of_nat m + xa\n                            < \\<omega> \\<up> \\<beta> *\n                              ZFC_in_HOL.succ (ord_of_nat ma)", "by (metis add_less_cancel_left OrdmemD inc indecomposable_imp_Ord mult_succ plus sup_ge1)"], ["proof (state)\nthis:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  \\<exists>m.\n     \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> ?x \\<and>\n     ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)\n\ngoal (2 subgoals):\n 1. elts \\<gamma> \\<subseteq> \\<Union> (range E)\n 2. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  \\<exists>m.\n     \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> ?x \\<and>\n     ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)\n\ngoal (2 subgoals):\n 1. elts \\<gamma> \\<subseteq> \\<Union> (range E)\n 2. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "have \"Ord x\" if \"x \\<in> elts (\\<omega>\\<up>\\<beta> * ord_of_nat n)\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord x", "by (meson Ord\\<omega>\\<beta> Ord_in_Ord Ord_mult Ord_ord_of_nat that)"], ["proof (state)\nthis:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  Ord ?x\n\ngoal (2 subgoals):\n 1. elts \\<gamma> \\<subseteq> \\<Union> (range E)\n 2. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  \\<exists>m.\n     \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> ?x \\<and>\n     ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  Ord ?x", "show \"elts \\<gamma> \\<subseteq> \\<Union>(range E)\""], ["proof (prove)\nusing this:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  \\<exists>m.\n     \\<omega> \\<up> \\<beta> * ord_of_nat m \\<le> ?x \\<and>\n     ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat m)\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?n) \\<Longrightarrow>\n  Ord ?x\n\ngoal (1 subgoal):\n 1. elts \\<gamma> \\<subseteq> \\<Union> (range E)", "by (auto simp: \\<delta> \\<beta> E_def mult_Limit elts_\\<omega>)"], ["proof (state)\nthis:\n  elts \\<gamma> \\<subseteq> \\<Union> (range E)\n\ngoal (1 subgoal):\n 1. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "have \"x \\<in> elts (\\<omega>\\<up>\\<beta> * succ(ord_of_nat n))\"\n        if \"Ord x\" \"x < \\<omega>\\<up>\\<beta> * succ (n)\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts (\\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat n))", "by (metis that Ord_mem_iff_lt Ord_mult Ord_ord_of_nat inc indecomposable_imp_Ord ord_of_nat.simps(2))"], ["proof (state)\nthis:\n  \\<lbrakk>Ord ?x;\n   ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat ?n)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> elts\n                              (\\<omega> \\<up> \\<beta> *\n                               ZFC_in_HOL.succ (ord_of_nat ?n))\n\ngoal (1 subgoal):\n 1. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Ord ?x;\n   ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat ?n)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> elts\n                              (\\<omega> \\<up> \\<beta> *\n                               ZFC_in_HOL.succ (ord_of_nat ?n))", "show \"\\<Union>(range E) \\<subseteq> elts \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?x;\n   ?x < \\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat ?n)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> elts\n                              (\\<omega> \\<up> \\<beta> *\n                               ZFC_in_HOL.succ (ord_of_nat ?n))\n\ngoal (1 subgoal):\n 1. \\<Union> (range E) \\<subseteq> elts \\<gamma>", "by (force simp: \\<delta> \\<beta> E_def Limit.prems mult_Limit)"], ["proof (state)\nthis:\n  \\<Union> (range E) \\<subseteq> elts \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts \\<gamma> = \\<Union> (range E)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have smE: \"small (E n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (E n)", "by (metis \"*\" complete_lattice_class.Sup_upper down rangeI)"], ["proof (state)\nthis:\n  small (E ?n)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have otE: \"ordertype (E n) VWF = \\<omega>\\<up>\\<beta>\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (E n) VWF = \\<omega> \\<up> \\<beta>", "by (simp add: E_def inc indecomposable_imp_Ord mult_succ ordertype_interval_eq)"], ["proof (state)\nthis:\n  ordertype (E ?n) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define cut where \"cut \\<equiv> \\<lambda>n x. odiff x (\\<omega>\\<up>\\<beta> * ord_of_nat n)\""], ["proof (state)\nthis:\n  cut \\<equiv> \\<lambda>n x. odiff x (\\<omega> \\<up> \\<beta> * ord_of_nat n)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have cutON: \"cut n ` X \\<subseteq> ON\" if \"X \\<subseteq> ON\" for n X"], ["proof (prove)\ngoal (1 subgoal):\n 1. cut n ` X \\<subseteq> ON", "using that"], ["proof (prove)\nusing this:\n  X \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. cut n ` X \\<subseteq> ON", "by (simp add: image_subset_iff cut_def ON_imp_Ord Ord\\<omega>\\<beta> Ord_odiff)"], ["proof (state)\nthis:\n  ?X \\<subseteq> ON \\<Longrightarrow> cut ?n ` ?X \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have cut [simp]: \"cut n (\\<omega> \\<up> \\<beta> * ord_of_nat n + x) = x\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. cut n (\\<omega> \\<up> \\<beta> * ord_of_nat n + x) = x", "by (auto simp: cut_def)"], ["proof (state)\nthis:\n  cut ?n (\\<omega> \\<up> \\<beta> * ord_of_nat ?n + ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have cuteq: \"x \\<in> cut n ` (X \\<inter> E n) \\<longleftrightarrow> \\<omega>\\<up>\\<beta> * ord_of_nat n + x \\<in> X\"\n      if x: \"x \\<in> elts (\\<omega>\\<up>\\<beta>)\" for x X n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> cut n ` (X \\<inter> E n)) =\n    (\\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> cut n ` (X \\<inter> E n) \\<Longrightarrow>\n    \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X\n 2. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X \\<Longrightarrow>\n    x \\<in> cut n ` (X \\<inter> E n)", "show \"\\<omega>\\<up>\\<beta> * ord_of_nat n + x \\<in> X\" if \"x \\<in> cut n ` (X \\<inter> E n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X", "using E_def Ord\\<omega>\\<beta> Ord_odiff_eq image_iff local.cut_def that"], ["proof (prove)\nusing this:\n  E \\<equiv>\n  \\<lambda>n.\n     {\\<omega> \\<up> \\<beta> *\n      ord_of_nat n..<\\<omega> \\<up> \\<beta> * ord_of_nat (Suc n)} \\<inter>\n     ON\n  Ord (\\<omega> \\<up> \\<beta>)\n  \\<lbrakk>?\\<alpha> \\<le> ?\\<beta>; Ord ?\\<alpha>; Ord ?\\<beta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> + odiff ?\\<beta> ?\\<alpha> = ?\\<beta>\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  cut \\<equiv> \\<lambda>n x. odiff x (\\<omega> \\<up> \\<beta> * ord_of_nat n)\n  x \\<in> cut n ` (X \\<inter> E n)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X", "by auto"], ["proof (state)\nthis:\n  x \\<in> cut n ` (X \\<inter> E n) \\<Longrightarrow>\n  \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X \\<Longrightarrow>\n    x \\<in> cut n ` (X \\<inter> E n)", "show \"x \\<in> cut n ` (X \\<inter> E n)\"\n        if \"\\<omega>\\<up>\\<beta> * ord_of_nat n + x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cut n ` (X \\<inter> E n)", "by (metis (full_types) IntI cut image_iff in_En that x)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> * ord_of_nat n + x \\<in> X \\<Longrightarrow>\n  x \\<in> cut n ` (X \\<inter> E n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> elts (\\<omega> \\<up> \\<beta>) \\<Longrightarrow>\n  (?x \\<in> cut ?n ` (?X \\<inter> E ?n)) =\n  (\\<omega> \\<up> \\<beta> * ord_of_nat ?n + ?x \\<in> ?X)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have ot_cuteq: \"ordertype (cut n ` (X \\<inter> E n)) VWF = ordertype (X \\<inter> E n) VWF\" for n X"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (cut n ` (X \\<inter> E n)) VWF =\n    ordertype (X \\<inter> E n) VWF", "proof (rule ordertype_VWF_inc_eq)"], ["proof (state)\ngoal (4 subgoals):\n 1. X \\<inter> E n \\<subseteq> ON\n 2. cut n ` (X \\<inter> E n) \\<subseteq> ON\n 3. small (X \\<inter> E n)\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> X \\<inter> E n; y \\<in> X \\<inter> E n;\n        x < y\\<rbrakk>\n       \\<Longrightarrow> cut n x < cut n y", "show \"X \\<inter> E n \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> E n \\<subseteq> ON", "using E_def"], ["proof (prove)\nusing this:\n  E \\<equiv>\n  \\<lambda>n.\n     {\\<omega> \\<up> \\<beta> *\n      ord_of_nat n..<\\<omega> \\<up> \\<beta> * ord_of_nat (Suc n)} \\<inter>\n     ON\n\ngoal (1 subgoal):\n 1. X \\<inter> E n \\<subseteq> ON", "by blast"], ["proof (state)\nthis:\n  X \\<inter> E n \\<subseteq> ON\n\ngoal (3 subgoals):\n 1. cut n ` (X \\<inter> E n) \\<subseteq> ON\n 2. small (X \\<inter> E n)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> X \\<inter> E n; y \\<in> X \\<inter> E n;\n        x < y\\<rbrakk>\n       \\<Longrightarrow> cut n x < cut n y", "then"], ["proof (chain)\npicking this:\n  X \\<inter> E n \\<subseteq> ON", "show \"cut n ` (X \\<inter> E n) \\<subseteq> ON\""], ["proof (prove)\nusing this:\n  X \\<inter> E n \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. cut n ` (X \\<inter> E n) \\<subseteq> ON", "by (simp add: cutON)"], ["proof (state)\nthis:\n  cut n ` (X \\<inter> E n) \\<subseteq> ON\n\ngoal (2 subgoals):\n 1. small (X \\<inter> E n)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X \\<inter> E n; y \\<in> X \\<inter> E n;\n        x < y\\<rbrakk>\n       \\<Longrightarrow> cut n x < cut n y", "show \"small (X \\<inter> E n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X \\<inter> E n)", "by (meson Int_lower2 smE smaller_than_small)"], ["proof (state)\nthis:\n  small (X \\<inter> E n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X \\<inter> E n; y \\<in> X \\<inter> E n;\n        x < y\\<rbrakk>\n       \\<Longrightarrow> cut n x < cut n y", "show \"cut n x < cut n y\"\n        if \"x \\<in> X \\<inter> E n\" \"y \\<in> X \\<inter> E n\" \"x < y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cut n x < cut n y", "using that \\<open>X \\<inter> E n \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X \\<inter> E n\n  y \\<in> X \\<inter> E n\n  x < y\n  X \\<inter> E n \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. cut n x < cut n y", "by(simp add: E_def Ord\\<omega>\\<beta> Ord_odiff_less_odiff local.cut_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X \\<inter> E n; ?y \\<in> X \\<inter> E n;\n   ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> cut n ?x < cut n ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordertype (cut ?n ` (?X \\<inter> E ?n)) VWF =\n  ordertype (?X \\<inter> E ?n) VWF\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define N where \"N \\<equiv> \\<lambda>b. {n. ordertype (X b \\<inter> E n) VWF = \\<omega>\\<up>\\<beta>}\""], ["proof (state)\nthis:\n  N \\<equiv>\n  \\<lambda>b. {n. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>}\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"\\<exists>b. infinite (N b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. infinite (N b)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "assume \"\\<nexists>b. infinite (N b)\""], ["proof (state)\nthis:\n  \\<nexists>b. infinite (N b)\n\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>b. infinite (N b)", "obtain n where \"\\<And>b. n \\<notin> N b\""], ["proof (prove)\nusing this:\n  \\<nexists>b. infinite (N b)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>b. n \\<notin> N b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (simp add: ex_bool_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n. (\\<And>b. n \\<notin> N b) \\<Longrightarrow> thesis;\n     finite (N True) \\<and> finite (N False)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis (full_types) finite_nat_set_iff_bounded not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  n \\<notin> N ?b\n\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<notin> N ?b\n\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "have \"\\<exists>b. ordertype (cut n ` (X b \\<inter> E n)) VWF = \\<omega>\\<up>\\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       ordertype (cut n ` (X b \\<inter> E n)) VWF = \\<omega> \\<up> \\<beta>", "proof (rule Limit.IH)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<omega> \\<up> \\<beta> \\<in> elts \\<gamma>\n 2. indecomposable (\\<omega> \\<up> \\<beta>)\n 3. \\<And>b.\n       ordertype (cut n ` (X b \\<inter> E n)) VWF\n       \\<le> \\<omega> \\<up> \\<beta>\n 4. \\<And>b. small (cut n ` (X b \\<inter> E n))\n 5. \\<And>b. cut n ` (X b \\<inter> E n) \\<subseteq> ON\n 6. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "show \"\\<omega>\\<up>\\<beta> \\<in> elts \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> \\<in> elts \\<gamma>", "by (metis Limit.hyps Limit_def Limit_omega Ord_mem_iff_less_TC \\<beta> \\<delta> mult_le2 not_succ_Limit oexp_succ omega_nonzero one_V_def)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> \\<in> elts \\<gamma>\n\ngoal (5 subgoals):\n 1. indecomposable (\\<omega> \\<up> \\<beta>)\n 2. \\<And>b.\n       ordertype (cut n ` (X b \\<inter> E n)) VWF\n       \\<le> \\<omega> \\<up> \\<beta>\n 3. \\<And>b. small (cut n ` (X b \\<inter> E n))\n 4. \\<And>b. cut n ` (X b \\<inter> E n) \\<subseteq> ON\n 5. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "show \"indecomposable (\\<omega>\\<up>\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. indecomposable (\\<omega> \\<up> \\<beta>)", "by (simp add: inc)"], ["proof (state)\nthis:\n  indecomposable (\\<omega> \\<up> \\<beta>)\n\ngoal (4 subgoals):\n 1. \\<And>b.\n       ordertype (cut n ` (X b \\<inter> E n)) VWF\n       \\<le> \\<omega> \\<up> \\<beta>\n 2. \\<And>b. small (cut n ` (X b \\<inter> E n))\n 3. \\<And>b. cut n ` (X b \\<inter> E n) \\<subseteq> ON\n 4. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "show \"ordertype (cut n ` (X b \\<inter> E n)) VWF \\<le> \\<omega>\\<up>\\<beta>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (cut n ` (X b \\<inter> E n)) VWF \\<le> \\<omega> \\<up> \\<beta>", "by (metis \"otE\" inf_le2 ordertype_VWF_mono ot_cuteq smE)"], ["proof (state)\nthis:\n  ordertype (cut n ` (X ?b \\<inter> E n)) VWF \\<le> \\<omega> \\<up> \\<beta>\n\ngoal (3 subgoals):\n 1. \\<And>b. small (cut n ` (X b \\<inter> E n))\n 2. \\<And>b. cut n ` (X b \\<inter> E n) \\<subseteq> ON\n 3. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "show \"small (cut n ` (X b \\<inter> E n))\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (cut n ` (X b \\<inter> E n))", "using smE subset_iff_less_eq_V"], ["proof (prove)\nusing this:\n  small (E ?n)\n  small ?B \\<Longrightarrow>\n  (?A \\<subseteq> ?B) = (set ?A \\<le> set ?B \\<and> small ?A)\n\ngoal (1 subgoal):\n 1. small (cut n ` (X b \\<inter> E n))", "by (meson inf_le2 replacement)"], ["proof (state)\nthis:\n  small (cut n ` (X ?b \\<inter> E n))\n\ngoal (2 subgoals):\n 1. \\<And>b. cut n ` (X b \\<inter> E n) \\<subseteq> ON\n 2. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "show \"cut n ` (X b \\<inter> E n) \\<subseteq> ON\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. cut n ` (X b \\<inter> E n) \\<subseteq> ON", "using E_def cutON"], ["proof (prove)\nusing this:\n  E \\<equiv>\n  \\<lambda>n.\n     {\\<omega> \\<up> \\<beta> *\n      ord_of_nat n..<\\<omega> \\<up> \\<beta> * ord_of_nat (Suc n)} \\<inter>\n     ON\n  ?X \\<subseteq> ON \\<Longrightarrow> cut ?n ` ?X \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. cut n ` (X b \\<inter> E n) \\<subseteq> ON", "by auto"], ["proof (state)\nthis:\n  cut n ` (X ?b \\<inter> E n) \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "have \"elts (\\<omega>\\<up>\\<beta> * succ n) \\<subseteq> \\<Union>(range X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat n))\n    \\<subseteq> \\<Union> (range X)", "by (metis Ord\\<omega>\\<beta> Ord_\\<omega> Ord_ord_of_nat less_eq_V_def mult_cancel_le_iff ord_of_nat.simps(2) ord_of_nat_le_omega order_trans subX12)"], ["proof (state)\nthis:\n  elts (\\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat n))\n  \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>a. cut n ` (X a \\<inter> E n))", "then"], ["proof (chain)\npicking this:\n  elts (\\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat n))\n  \\<subseteq> \\<Union> (range X)", "show \"elts (\\<omega>\\<up>\\<beta>) \\<subseteq> (\\<Union>b. cut n ` (X b \\<inter> E n))\""], ["proof (prove)\nusing this:\n  elts (\\<omega> \\<up> \\<beta> * ZFC_in_HOL.succ (ord_of_nat n))\n  \\<subseteq> \\<Union> (range X)\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta>)\n    \\<subseteq> (\\<Union>b. cut n ` (X b \\<inter> E n))", "by (auto simp: mult_succ mult_Limit UN_subset_iff cuteq UN_bool_eq)"], ["proof (state)\nthis:\n  elts (\\<omega> \\<up> \\<beta>)\n  \\<subseteq> (\\<Union>b. cut n ` (X b \\<inter> E n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b.\n     ordertype (cut n ` (X b \\<inter> E n)) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     ordertype (cut n ` (X b \\<inter> E n)) VWF = \\<omega> \\<up> \\<beta>", "have \"\\<exists>b. ordertype (X b \\<inter> E n) VWF = \\<omega>\\<up>\\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     ordertype (cut n ` (X b \\<inter> E n)) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>", "by (simp add: ot_cuteq)"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<nexists>b. infinite (N b) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<notin> N ?b\n  \\<exists>b. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>", "show False"], ["proof (prove)\nusing this:\n  n \\<notin> N ?b\n  \\<exists>b. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: N_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b. infinite (N b)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. infinite (N b)", "obtain b where b: \"infinite (N b)\""], ["proof (prove)\nusing this:\n  \\<exists>b. infinite (N b)\n\ngoal (1 subgoal):\n 1. (\\<And>b. infinite (N b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  infinite (N b)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  infinite (N b)", "obtain \\<phi> :: \"nat \\<Rightarrow> nat\" where \\<phi>: \"bij_betw \\<phi> UNIV (N b)\" and mono: \"strict_mono \\<phi>\""], ["proof (prove)\nusing this:\n  infinite (N b)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>bij_betw \\<phi> UNIV (N b); strict_mono \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson bij_enumerate enumerate_mono strict_mono_def)"], ["proof (state)\nthis:\n  bij_betw \\<phi> UNIV (N b)\n  strict_mono \\<phi>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  bij_betw \\<phi> UNIV (N b)\n  strict_mono \\<phi>", "have \"ordertype (X b \\<inter> E (\\<phi> n)) VWF = \\<omega>\\<up>\\<beta>\" for n"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> UNIV (N b)\n  strict_mono \\<phi>\n\ngoal (1 subgoal):\n 1. ordertype (X b \\<inter> E (\\<phi> n)) VWF = \\<omega> \\<up> \\<beta>", "using N_def bij_betw_imp_surj_on"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> UNIV (N b)\n  strict_mono \\<phi>\n  N \\<equiv>\n  \\<lambda>b. {n. ordertype (X b \\<inter> E n) VWF = \\<omega> \\<up> \\<beta>}\n  bij_betw ?f ?A ?B \\<Longrightarrow> ?f ` ?A = ?B\n\ngoal (1 subgoal):\n 1. ordertype (X b \\<inter> E (\\<phi> n)) VWF = \\<omega> \\<up> \\<beta>", "by blast"], ["proof (state)\nthis:\n  ordertype (X b \\<inter> E (\\<phi> ?n)) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "moreover"], ["proof (state)\nthis:\n  ordertype (X b \\<inter> E (\\<phi> ?n)) VWF = \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"small (X b \\<inter> E (\\<phi> n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X b \\<inter> E (\\<phi> n))", "by (meson inf_le2 smE subset_iff_less_eq_V)"], ["proof (state)\nthis:\n  small (X b \\<inter> E (\\<phi> ?n))\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "ultimately"], ["proof (chain)\npicking this:\n  ordertype (X b \\<inter> E (\\<phi> ?n)) VWF = \\<omega> \\<up> \\<beta>\n  small (X b \\<inter> E (\\<phi> ?n))", "have \"\\<exists>f. bij_betw f (X b \\<inter> E (\\<phi> n)) (elts (\\<omega>\\<up>\\<beta>)) \\<and> (\\<forall>x \\<in> X b \\<inter> E (\\<phi> n). \\<forall>y \\<in> X b \\<inter> E (\\<phi> n). f x < f y \\<longleftrightarrow> (x,y) \\<in> VWF)\"\n        for n"], ["proof (prove)\nusing this:\n  ordertype (X b \\<inter> E (\\<phi> ?n)) VWF = \\<omega> \\<up> \\<beta>\n  small (X b \\<inter> E (\\<phi> ?n))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> E (\\<phi> n))\n        (elts (\\<omega> \\<up> \\<beta>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> E (\\<phi> n).\n           \\<forall>y\\<in>X b \\<inter> E (\\<phi> n).\n              (f x < f y) = ((x, y) \\<in> VWF))", "by (metis Ord_ordertype ordertype_VWF_eq_iff)"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (X b \\<inter> E (\\<phi> ?n))\n      (elts (\\<omega> \\<up> \\<beta>)) \\<and>\n     (\\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n         \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n            (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     bij_betw f (X b \\<inter> E (\\<phi> ?n))\n      (elts (\\<omega> \\<up> \\<beta>)) \\<and>\n     (\\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n         \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n            (f x < f y) = ((x, y) \\<in> VWF))", "obtain F where bijF: \"\\<And>n. bij_betw (F n) (X b \\<inter> E (\\<phi> n)) (elts (\\<omega>\\<up>\\<beta>))\"\n              and F: \"\\<And>n. \\<forall>x \\<in> X b \\<inter> E (\\<phi> n). \\<forall>y \\<in> X b \\<inter> E (\\<phi> n). F n x < F n y \\<longleftrightarrow> (x,y) \\<in> VWF\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     bij_betw f (X b \\<inter> E (\\<phi> ?n))\n      (elts (\\<omega> \\<up> \\<beta>)) \\<and>\n     (\\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n         \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n            (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<lbrakk>\\<And>n.\n                    bij_betw (F n) (X b \\<inter> E (\\<phi> n))\n                     (elts (\\<omega> \\<up> \\<beta>));\n         \\<And>n.\n            \\<forall>x\\<in>X b \\<inter> E (\\<phi> n).\n               \\<forall>y\\<in>X b \\<inter> E (\\<phi> n).\n                  (F n x < F n y) = ((x, y) \\<in> VWF)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bij_betw (F ?n) (X b \\<inter> E (\\<phi> ?n))\n   (elts (\\<omega> \\<up> \\<beta>))\n  \\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n     \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n        (F ?n x < F ?n y) = ((x, y) \\<in> VWF)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  bij_betw (F ?n) (X b \\<inter> E (\\<phi> ?n))\n   (elts (\\<omega> \\<up> \\<beta>))\n  \\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n     \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n        (F ?n x < F ?n y) = ((x, y) \\<in> VWF)", "have F_bound: \"\\<And>n. \\<forall>x \\<in> X b \\<inter> E (\\<phi> n). F n x < \\<omega>\\<up>\\<beta>\""], ["proof (prove)\nusing this:\n  bij_betw (F ?n) (X b \\<inter> E (\\<phi> ?n))\n   (elts (\\<omega> \\<up> \\<beta>))\n  \\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n).\n     \\<forall>y\\<in>X b \\<inter> E (\\<phi> ?n).\n        (F ?n x < F ?n y) = ((x, y) \\<in> VWF)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>x\\<in>X b \\<inter> E (\\<phi> n).\n          F n x < \\<omega> \\<up> \\<beta>", "by (metis Ord_\\<omega> Ord_oexp OrdmemD \\<beta>(2) bij_betw_imp_surj_on image_eqI)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n). F ?n x < \\<omega> \\<up> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have F_Ord: \"\\<And>n. \\<forall>x \\<in> X b \\<inter> E (\\<phi> n). Ord (F n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. \\<forall>x\\<in>X b \\<inter> E (\\<phi> n). Ord (F n x)", "by (metis otE ON_imp_Ord Ord_ordertype bijF bij_betw_def elts_subset_ON imageI)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X b \\<inter> E (\\<phi> ?n). Ord (F ?n x)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have inc: \"\\<phi> n \\<ge> n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> \\<phi> n", "by (simp add: mono strict_mono_imp_increasing)"], ["proof (state)\nthis:\n  ?n \\<le> \\<phi> ?n\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have dj\\<phi>: \"disjnt (E (\\<phi> i)) (E (\\<phi> j))\" if \"i \\<noteq> j\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. disjnt (E (\\<phi> i)) (E (\\<phi> j))", "by (rule djE) (use \\<phi> that in \\<open>auto simp: bij_betw_def inj_def\\<close>)"], ["proof (state)\nthis:\n  ?i \\<noteq> ?j \\<Longrightarrow> disjnt (E (\\<phi> ?i)) (E (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define Y where \"Y \\<equiv> (\\<Union>n. E (\\<phi> n))\""], ["proof (state)\nthis:\n  Y \\<equiv> \\<Union>n. E (\\<phi> n)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"\\<exists>n. y \\<in> E (\\<phi> n)\" if \"y \\<in> Y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. y \\<in> E (\\<phi> n)", "using Y_def that"], ["proof (prove)\nusing this:\n  Y \\<equiv> \\<Union>n. E (\\<phi> n)\n  y \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<exists>n. y \\<in> E (\\<phi> n)", "by blast"], ["proof (state)\nthis:\n  ?y \\<in> Y \\<Longrightarrow> \\<exists>n. ?y \\<in> E (\\<phi> n)\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> Y \\<Longrightarrow> \\<exists>n. ?y \\<in> E (\\<phi> n)", "obtain \\<iota> where \\<iota>: \"\\<And>y. y \\<in> Y \\<Longrightarrow> y \\<in> E (\\<phi> (\\<iota> y))\""], ["proof (prove)\nusing this:\n  ?y \\<in> Y \\<Longrightarrow> \\<exists>n. ?y \\<in> E (\\<phi> n)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<iota>.\n        (\\<And>y.\n            y \\<in> Y \\<Longrightarrow>\n            y \\<in> E (\\<phi> (\\<iota> y))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?y \\<in> Y \\<Longrightarrow> ?y \\<in> E (\\<phi> (\\<iota> ?y))\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"Y \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> ON", "by (auto simp: Y_def E_def)"], ["proof (state)\nthis:\n  Y \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \\<iota>le: \"\\<iota> x \\<le> \\<iota> y\" if \"x < y\" \"x \\<in> Y\" \"y \\<in> Y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> x \\<le> \\<iota> y", "using less_imp_E strict_mono_less_eq that \\<iota> [OF \\<open>x \\<in> Y\\<close>] \\<iota> [OF \\<open>y \\<in> Y\\<close>] mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?j\n  strict_mono ?f \\<Longrightarrow> (?f ?x \\<le> ?f ?y) = (?x \\<le> ?y)\n  x < y\n  x \\<in> Y\n  y \\<in> Y\n  x \\<in> E (\\<phi> (\\<iota> x))\n  y \\<in> E (\\<phi> (\\<iota> y))\n  strict_mono \\<phi>\n\ngoal (1 subgoal):\n 1. \\<iota> x \\<le> \\<iota> y", "unfolding Y_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?x \\<in> E ?i; ?y \\<in> E ?j\\<rbrakk>\n  \\<Longrightarrow> ?i \\<le> ?j\n  strict_mono ?f \\<Longrightarrow> (?f ?x \\<le> ?f ?y) = (?x \\<le> ?y)\n  x < y\n  x \\<in> (\\<Union>n. E (\\<phi> n))\n  y \\<in> (\\<Union>n. E (\\<phi> n))\n  x \\<in> E (\\<phi> (\\<iota> x))\n  y \\<in> E (\\<phi> (\\<iota> y))\n  strict_mono \\<phi>\n\ngoal (1 subgoal):\n 1. \\<iota> x \\<le> \\<iota> y", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x < ?y; ?x \\<in> Y; ?y \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<iota> ?x \\<le> \\<iota> ?y\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have eq\\<iota>: \"x \\<in> E (\\<phi> k) \\<Longrightarrow> \\<iota> x = k\" for x k"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> E (\\<phi> k) \\<Longrightarrow> \\<iota> x = k", "using \\<iota>"], ["proof (prove)\nusing this:\n  ?y \\<in> Y \\<Longrightarrow> ?y \\<in> E (\\<phi> (\\<iota> ?y))\n\ngoal (1 subgoal):\n 1. x \\<in> E (\\<phi> k) \\<Longrightarrow> \\<iota> x = k", "unfolding Y_def"], ["proof (prove)\nusing this:\n  ?y \\<in> (\\<Union>n. E (\\<phi> n)) \\<Longrightarrow>\n  ?y \\<in> E (\\<phi> (\\<iota> ?y))\n\ngoal (1 subgoal):\n 1. x \\<in> E (\\<phi> k) \\<Longrightarrow> \\<iota> x = k", "by (meson UN_I disjnt_iff dj\\<phi> iso_tuple_UNIV_I)"], ["proof (state)\nthis:\n  ?x \\<in> E (\\<phi> ?k) \\<Longrightarrow> \\<iota> ?x = ?k\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have upper: \"\\<omega>\\<up>\\<beta> * ord_of_nat (\\<iota> x) \\<le> x\" if \"x \\<in> Y\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> x) \\<le> x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> x) \\<le> x", "proof (clarsimp simp add: Y_def eq\\<iota>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "assume u: \"u \\<in> elts (\\<omega>\\<up>\\<beta> * ord_of_nat v)\" and v: \"x \\<in> E (\\<phi> v)\""], ["proof (state)\nthis:\n  u \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat v)\n  x \\<in> E (\\<phi> v)\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "then"], ["proof (chain)\npicking this:\n  u \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat v)\n  x \\<in> E (\\<phi> v)", "have \"u < \\<omega>\\<up>\\<beta> * ord_of_nat v\""], ["proof (prove)\nusing this:\n  u \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat v)\n  x \\<in> E (\\<phi> v)\n\ngoal (1 subgoal):\n 1. u < \\<omega> \\<up> \\<beta> * ord_of_nat v", "by (simp add: OrdmemD \\<beta>(2))"], ["proof (state)\nthis:\n  u < \\<omega> \\<up> \\<beta> * ord_of_nat v\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "also"], ["proof (state)\nthis:\n  u < \\<omega> \\<up> \\<beta> * ord_of_nat v\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "have \"\\<dots> \\<le> \\<omega>\\<up>\\<beta> * ord_of_nat (\\<phi> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat v\n    \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v)", "by (simp add: \\<beta>(2) inc)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> * ord_of_nat v\n  \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v)\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "also"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> * ord_of_nat v\n  \\<le> \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v)\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "have \"\\<dots> \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v) \\<le> x", "using v"], ["proof (prove)\nusing this:\n  x \\<in> E (\\<phi> v)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v) \\<le> x", "by (simp add: E_def)"], ["proof (state)\nthis:\n  \\<omega> \\<up> \\<beta> * ord_of_nat (\\<phi> v) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat xaa);\n        x \\<in> E (\\<phi> xaa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> elts x", "finally"], ["proof (chain)\npicking this:\n  u < x", "show \"u \\<in> elts x\""], ["proof (prove)\nusing this:\n  u < x\n\ngoal (1 subgoal):\n 1. u \\<in> elts x", "using \\<open>Y \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  u < x\n  Y \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. u \\<in> elts x", "by (meson ON_imp_Ord Ord_\\<omega> Ord_in_Ord Ord_mem_iff_lt Ord_mult Ord_oexp Ord_ord_of_nat \\<beta>(2) that u)"], ["proof (state)\nthis:\n  u \\<in> elts x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Y \\<Longrightarrow>\n  \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> ?x) \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "define G where \"G \\<equiv> \\<lambda>x. \\<omega>\\<up>\\<beta> * ord_of_nat (\\<iota> x) + F (\\<iota> x) x\""], ["proof (state)\nthis:\n  G \\<equiv>\n  \\<lambda>x.\n     \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> x) + F (\\<iota> x) x\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have G_strict_mono: \"G x < G y\" if \"x < y\" \"x \\<in> X b \\<inter> Y\" \"y \\<in> X b \\<inter> Y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. G x < G y", "proof (cases \"\\<iota> x = \\<iota> y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<iota> x = \\<iota> y \\<Longrightarrow> G x < G y\n 2. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "case True"], ["proof (state)\nthis:\n  \\<iota> x = \\<iota> y\n\ngoal (2 subgoals):\n 1. \\<iota> x = \\<iota> y \\<Longrightarrow> G x < G y\n 2. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "then"], ["proof (chain)\npicking this:\n  \\<iota> x = \\<iota> y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<iota> x = \\<iota> y\n\ngoal (1 subgoal):\n 1. G x < G y", "using that"], ["proof (prove)\nusing this:\n  \\<iota> x = \\<iota> y\n  x < y\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. G x < G y", "unfolding G_def"], ["proof (prove)\nusing this:\n  \\<iota> x = \\<iota> y\n  x < y\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> x) + F (\\<iota> x) x\n    < \\<omega> \\<up> \\<beta> * ord_of_nat (\\<iota> y) + F (\\<iota> y) y", "by (metis F Int_iff add_less_cancel_left Limit.prems(4) ON_imp_Ord VWF_iff_Ord_less \\<iota>)"], ["proof (state)\nthis:\n  G x < G y\n\ngoal (1 subgoal):\n 1. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "case False"], ["proof (state)\nthis:\n  \\<iota> x \\<noteq> \\<iota> y\n\ngoal (1 subgoal):\n 1. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "then"], ["proof (chain)\npicking this:\n  \\<iota> x \\<noteq> \\<iota> y", "have \"\\<iota> x < \\<iota> y\""], ["proof (prove)\nusing this:\n  \\<iota> x \\<noteq> \\<iota> y\n\ngoal (1 subgoal):\n 1. \\<iota> x < \\<iota> y", "by (meson IntE \\<iota>le le_less that)"], ["proof (state)\nthis:\n  \\<iota> x < \\<iota> y\n\ngoal (1 subgoal):\n 1. \\<iota> x \\<noteq> \\<iota> y \\<Longrightarrow> G x < G y", "then"], ["proof (chain)\npicking this:\n  \\<iota> x < \\<iota> y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<iota> x < \\<iota> y\n\ngoal (1 subgoal):\n 1. G x < G y", "using that"], ["proof (prove)\nusing this:\n  \\<iota> x < \\<iota> y\n  x < y\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. G x < G y", "by (simp add: G_def F_Ord F_bound Ord\\<omega>\\<beta> \\<iota> mult_nat_less_add_less)"], ["proof (state)\nthis:\n  G x < G y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x < ?y; ?x \\<in> X b \\<inter> Y;\n   ?y \\<in> X b \\<inter> Y\\<rbrakk>\n  \\<Longrightarrow> G ?x < G ?y\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"ordertype (X b \\<inter> Y) VWF = (\\<omega>\\<up>\\<beta>) * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>", "proof (rule ordertype_VWF_eq_iff [THEN iffD2])"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord (\\<omega> \\<up> \\<beta> * \\<omega>)\n 2. small (X b \\<inter> Y)\n 3. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "show \"Ord (\\<omega>\\<up>\\<beta> * \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<omega> \\<up> \\<beta> * \\<omega>)", "by (simp add: \\<beta>)"], ["proof (state)\nthis:\n  Ord (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal (2 subgoals):\n 1. small (X b \\<inter> Y)\n 2. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "show \"small (X b \\<inter> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X b \\<inter> Y)", "by (meson Limit.prems(3) inf_le1 subset_iff_less_eq_V)"], ["proof (state)\nthis:\n  small (X b \\<inter> Y)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "have \"bij_betw G (X b \\<inter> Y) (elts (\\<omega>\\<up>\\<beta> * \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw G (X b \\<inter> Y) (elts (\\<omega> \\<up> \\<beta> * \\<omega>))", "proof (rule bij_betw_imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on G (X b \\<inter> Y)\n 2. G ` (X b \\<inter> Y) = elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "show \"inj_on G (X b \\<inter> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on G (X b \\<inter> Y)", "proof (rule linorder_inj_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < y; x \\<in> X b \\<inter> Y;\n        y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> G x \\<noteq> G y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X b \\<inter> Y; y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < y; x \\<in> X b \\<inter> Y;\n        y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> G x \\<noteq> G y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X b \\<inter> Y; y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x", "assume xy: \"x < y\" \"x \\<in> (X b \\<inter> Y)\" \"y \\<in> (X b \\<inter> Y)\""], ["proof (state)\nthis:\n  x < y\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x < y; x \\<in> X b \\<inter> Y;\n        y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> G x \\<noteq> G y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X b \\<inter> Y; y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x", "show \"G x \\<noteq> G y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G x \\<noteq> G y", "using G_strict_mono xy"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?x \\<in> X b \\<inter> Y;\n   ?y \\<in> X b \\<inter> Y\\<rbrakk>\n  \\<Longrightarrow> G ?x < G ?y\n  x < y\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. G x \\<noteq> G y", "by force"], ["proof (state)\nthis:\n  G x \\<noteq> G y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X b \\<inter> Y; y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X b \\<inter> Y; y \\<in> X b \\<inter> Y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<or> y \\<le> x", "show \"x \\<le> y \\<or> y \\<le> x\"\n              if \"x \\<in> (X b \\<inter> Y)\" \"y \\<in> (X b \\<inter> Y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "using that \\<open>X b \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X b \\<inter> Y\n  y \\<in> X b \\<inter> Y\n  X b \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "by (clarsimp simp: Y_def) (metis ON_imp_Ord Ord_linear Ord_trans)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X b \\<inter> Y; ?y \\<in> X b \\<inter> Y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on G (X b \\<inter> Y)\n\ngoal (1 subgoal):\n 1. G ` (X b \\<inter> Y) = elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "show \"G ` (X b \\<inter> Y) = elts (\\<omega>\\<up>\\<beta> * \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G ` (X b \\<inter> Y) = elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. G ` (X b \\<inter> Y)\n    \\<subseteq> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n 2. elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n    \\<subseteq> G ` (X b \\<inter> Y)", "show \"G ` (X b \\<inter> Y) \\<subseteq> elts (\\<omega>\\<up>\\<beta> * \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G ` (X b \\<inter> Y)\n    \\<subseteq> elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "using \\<open>X b \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  X b \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. G ` (X b \\<inter> Y)\n    \\<subseteq> elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "apply (clarsimp simp: G_def mult_Limit Y_def eq\\<iota>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>X b \\<subseteq> ON; xa \\<in> X b;\n        xa \\<in> E (\\<phi> n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>elts \\<omega>.\n                            \\<omega> \\<up> \\<beta> * ord_of_nat n + F n xa\n                            \\<in> elts (\\<omega> \\<up> \\<beta> * x)", "by (metis IntI add_mem_right_cancel bijF bij_betw_imp_surj_on image_eqI mult_succ ord_of_nat_\\<omega> succ_in_omega)"], ["proof (state)\nthis:\n  G ` (X b \\<inter> Y) \\<subseteq> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n    \\<subseteq> G ` (X b \\<inter> Y)", "show \"elts (\\<omega>\\<up>\\<beta> * \\<omega>) \\<subseteq> G ` (X b \\<inter> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n    \\<subseteq> G ` (X b \\<inter> Y)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "assume x: \"x \\<in> elts (\\<omega>\\<up>\\<beta> * \\<omega>)\""], ["proof (state)\nthis:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>)", "obtain k where n: \"x \\<in> elts (\\<omega>\\<up>\\<beta> * ord_of_nat (Suc k))\"\n                          and minim: \"\\<And>m. m < Suc k \\<Longrightarrow> x \\<notin> elts (\\<omega>\\<up>\\<beta> * ord_of_nat m)\""], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k));\n         \\<And>m.\n            m < Suc k \\<Longrightarrow>\n            x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using elts_mult_\\<omega>E"], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n  \\<lbrakk>?x \\<in> elts (?y * \\<omega>);\n   \\<And>n.\n      \\<lbrakk>n \\<noteq> 0; ?x \\<in> elts (?y * ord_of_nat n);\n       \\<And>m.\n          m < n \\<Longrightarrow>\n          ?x \\<notin> elts (?y * ord_of_nat m)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k));\n         \\<And>m.\n            m < Suc k \\<Longrightarrow>\n            x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis old.nat.exhaust)"], ["proof (state)\nthis:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k))\n  ?m < Suc k \\<Longrightarrow>\n  x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k))\n  ?m < Suc k \\<Longrightarrow>\n  x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?m)", "obtain y where y: \"y \\<in> elts (\\<omega>\\<up>\\<beta>)\" and xeq: \"x = \\<omega>\\<up>\\<beta> * ord_of_nat k + y\""], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k))\n  ?m < Suc k \\<Longrightarrow>\n  x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?m)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> elts (\\<omega> \\<up> \\<beta>);\n         x = \\<omega> \\<up> \\<beta> * ord_of_nat k + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x"], ["proof (prove)\nusing this:\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * ord_of_nat (Suc k))\n  ?m < Suc k \\<Longrightarrow>\n  x \\<notin> elts (\\<omega> \\<up> \\<beta> * ord_of_nat ?m)\n  x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> elts (\\<omega> \\<up> \\<beta>);\n         x = \\<omega> \\<up> \\<beta> * ord_of_nat k + y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mult_succ elim: mem_plus_V_E)"], ["proof (state)\nthis:\n  y \\<in> elts (\\<omega> \\<up> \\<beta>)\n  x = \\<omega> \\<up> \\<beta> * ord_of_nat k + y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "then"], ["proof (chain)\npicking this:\n  y \\<in> elts (\\<omega> \\<up> \\<beta>)\n  x = \\<omega> \\<up> \\<beta> * ord_of_nat k + y", "have 1: \"inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> (X b \\<inter> E (\\<phi> k))\""], ["proof (prove)\nusing this:\n  y \\<in> elts (\\<omega> \\<up> \\<beta>)\n  x = \\<omega> \\<up> \\<beta> * ord_of_nat k + y\n\ngoal (1 subgoal):\n 1. inv_into (X b \\<inter> E (\\<phi> k)) (F k) y\n    \\<in> X b \\<inter> E (\\<phi> k)", "by (metis bijF bij_betw_def inv_into_into)"], ["proof (state)\nthis:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y\n  \\<in> X b \\<inter> E (\\<phi> k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "then"], ["proof (chain)\npicking this:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y\n  \\<in> X b \\<inter> E (\\<phi> k)", "have \"(inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) \\<in> X b \\<inter> Y\""], ["proof (prove)\nusing this:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y\n  \\<in> X b \\<inter> E (\\<phi> k)\n\ngoal (1 subgoal):\n 1. inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> X b \\<inter> Y", "by (force simp: Y_def)"], ["proof (state)\nthis:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "moreover"], ["proof (state)\nthis:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> X b \\<inter> Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "have \"G (inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G (inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) = x", "by (metis \"1\" G_def Int_iff bijF bij_betw_inv_into_right eq\\<iota> xeq y)"], ["proof (state)\nthis:\n  G (inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<Longrightarrow>\n       x \\<in> G ` (X b \\<inter> Y)", "ultimately"], ["proof (chain)\npicking this:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> X b \\<inter> Y\n  G (inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) = x", "show \"x \\<in> G ` (X b \\<inter> Y)\""], ["proof (prove)\nusing this:\n  inv_into (X b \\<inter> E (\\<phi> k)) (F k) y \\<in> X b \\<inter> Y\n  G (inv_into (X b \\<inter> E (\\<phi> k)) (F k) y) = x\n\ngoal (1 subgoal):\n 1. x \\<in> G ` (X b \\<inter> Y)", "by blast"], ["proof (state)\nthis:\n  x \\<in> G ` (X b \\<inter> Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts (\\<omega> \\<up> \\<beta> * \\<omega>) \\<subseteq> G ` (X b \\<inter> Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G ` (X b \\<inter> Y) = elts (\\<omega> \\<up> \\<beta> * \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw G (X b \\<inter> Y) (elts (\\<omega> \\<up> \\<beta> * \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "moreover"], ["proof (state)\nthis:\n  bij_betw G (X b \\<inter> Y) (elts (\\<omega> \\<up> \\<beta> * \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "have \"(x,y) \\<in> VWF\"\n          if \"x \\<in> X b\" \"x \\<in> Y\" \"y \\<in> X b\" \"y \\<in> Y\" \"G x < G y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "have \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "using that"], ["proof (prove)\nusing this:\n  x \\<in> X b\n  x \\<in> Y\n  y \\<in> X b\n  y \\<in> Y\n  G x < G y\n\ngoal (1 subgoal):\n 1. x < y", "by (metis G_strict_mono Int_iff Limit.prems(4) ON_imp_Ord Ord_linear_lt less_asym)"], ["proof (state)\nthis:\n  x < y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "then"], ["proof (chain)\npicking this:\n  x < y", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "using ON_imp_Ord \\<open>Y \\<subseteq> ON\\<close> that"], ["proof (prove)\nusing this:\n  x < y\n  \\<lbrakk>?H \\<subseteq> ON; ?x \\<in> ?H\\<rbrakk> \\<Longrightarrow> Ord ?x\n  Y \\<subseteq> ON\n  x \\<in> X b\n  x \\<in> Y\n  y \\<in> X b\n  y \\<in> Y\n  G x < G y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> VWF\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   G ?x < G ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   G ?x < G ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "have \"G x < G y\"\n          if \"x \\<in> X b\" \"x \\<in> Y\" \"y \\<in> X b\" \"y \\<in> Y\" \"(x, y) \\<in> VWF\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. G x < G y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G x < G y", "have \"x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "using that ON_imp_Ord \\<open>Y \\<subseteq> ON\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X b\n  x \\<in> Y\n  y \\<in> X b\n  y \\<in> Y\n  (x, y) \\<in> VWF\n  \\<lbrakk>?H \\<subseteq> ON; ?x \\<in> ?H\\<rbrakk> \\<Longrightarrow> Ord ?x\n  Y \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. x < y", "by auto"], ["proof (state)\nthis:\n  x < y\n\ngoal (1 subgoal):\n 1. G x < G y", "then"], ["proof (chain)\npicking this:\n  x < y", "show ?thesis"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. G x < G y", "by (simp add: G_strict_mono that)"], ["proof (state)\nthis:\n  G x < G y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   (?x, ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> G ?x < G ?y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw G (X b \\<inter> Y) (elts (\\<omega> \\<up> \\<beta> * \\<omega>))\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   G ?x < G ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWF\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   (?x, ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> G ?x < G ?y", "show \"\\<exists>f. bij_betw f (X b \\<inter> Y) (elts (\\<omega>\\<up>\\<beta> * \\<omega>)) \\<and> (\\<forall>x\\<in>(X b \\<inter> Y). \\<forall>y\\<in>(X b \\<inter> Y). f x < f y \\<longleftrightarrow> ((x, y) \\<in> VWF))\""], ["proof (prove)\nusing this:\n  bij_betw G (X b \\<inter> Y) (elts (\\<omega> \\<up> \\<beta> * \\<omega>))\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   G ?x < G ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWF\n  \\<lbrakk>?x \\<in> X b; ?x \\<in> Y; ?y \\<in> X b; ?y \\<in> Y;\n   (?x, ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> G ?x < G ?y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (X b \\<inter> Y)\n        (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n       (\\<forall>x\\<in>X b \\<inter> Y.\n           \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (X b \\<inter> Y)\n      (elts (\\<omega> \\<up> \\<beta> * \\<omega>)) \\<and>\n     (\\<forall>x\\<in>X b \\<inter> Y.\n         \\<forall>y\\<in>X b \\<inter> Y. (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "moreover"], ["proof (state)\nthis:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "have \"ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF \\<le> ordertype (X b) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n    \\<le> ordertype (X b) VWF", "using Limit.prems(3) ordertype_VWF_mono"], ["proof (prove)\nusing this:\n  small (X ?b)\n  \\<lbrakk>?X \\<subseteq> ?Y; small ?Y\\<rbrakk>\n  \\<Longrightarrow> ordertype ?X VWF \\<le> ordertype ?Y VWF\n\ngoal (1 subgoal):\n 1. ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n    \\<le> ordertype (X b) VWF", "by auto"], ["proof (state)\nthis:\n  ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n  \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "ultimately"], ["proof (chain)\npicking this:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n  ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n  \\<le> ordertype (X b) VWF", "have \"ordertype (X b) VWF = (\\<omega>\\<up>\\<beta>) * \\<omega>\""], ["proof (prove)\nusing this:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n  ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n  \\<le> ordertype (X b) VWF\n\ngoal (1 subgoal):\n 1. ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>", "using Limit.hyps Limit.prems(2) \\<beta> \\<delta>"], ["proof (prove)\nusing this:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n  ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n  \\<le> ordertype (X b) VWF\n  Limit \\<gamma>\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n\ngoal (1 subgoal):\n 1. ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>", "using Y_def"], ["proof (prove)\nusing this:\n  ordertype (X b \\<inter> Y) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n  ordertype (\\<Union>n. X b \\<inter> E (\\<phi> n)) VWF\n  \\<le> ordertype (X b) VWF\n  Limit \\<gamma>\n  ordertype (X ?b) VWF \\<le> (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n  Y \\<equiv> \\<Union>n. E (\\<phi> n)\n\ngoal (1 subgoal):\n 1. ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>", "by auto"], ["proof (state)\nthis:\n  ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<not> Limit \\<delta> \\<Longrightarrow>\n    \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "then"], ["proof (chain)\npicking this:\n  ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "using Limit.hyps \\<beta> \\<delta>"], ["proof (prove)\nusing this:\n  ordertype (X b) VWF = \\<omega> \\<up> \\<beta> * \\<omega>\n  Limit \\<gamma>\n  \\<delta> = ZFC_in_HOL.succ \\<beta>\n  Ord \\<beta>\n  \\<gamma> = \\<omega> \\<up> \\<delta>\n\ngoal (1 subgoal):\n 1. \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (X b) VWF = (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>indecomposable 0; \\<And>b. ordertype (X b) VWF \\<le> 0;\n        \\<And>b. small (X b); \\<And>b. X b \\<subseteq> ON;\n        elts 0 \\<subseteq> \\<Union> (range X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. ordertype (X b) VWF = 0", "qed auto"], ["", "corollary indecomposable_imp_type2:\n  assumes \\<alpha>: \"indecomposable \\<gamma>\" \"X \\<subseteq> elts \\<gamma>\"\n  shows \"ordertype X VWF = \\<gamma> \\<or> ordertype (elts \\<gamma> - X) VWF = \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<gamma> \\<or>\n    ordertype (elts \\<gamma> - X) VWF = \\<gamma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<gamma> \\<or>\n    ordertype (elts \\<gamma> - X) VWF = \\<gamma>", "have \"Ord \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<gamma>", "using assms indecomposable_imp_Ord"], ["proof (prove)\nusing this:\n  indecomposable \\<gamma>\n  X \\<subseteq> elts \\<gamma>\n  indecomposable ?\\<alpha> \\<Longrightarrow> Ord ?\\<alpha>\n\ngoal (1 subgoal):\n 1. Ord \\<gamma>", "by blast"], ["proof (state)\nthis:\n  Ord \\<gamma>\n\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<gamma> \\<or>\n    ordertype (elts \\<gamma> - X) VWF = \\<gamma>", "have \"\\<exists>b. ordertype (if b then X else elts \\<gamma> - X) VWF = \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       ordertype (if b then X else elts \\<gamma> - X) VWF = \\<gamma>", "proof (rule indecomposable_imp_type)"], ["proof (state)\ngoal (5 subgoals):\n 1. indecomposable \\<gamma>\n 2. \\<And>b.\n       ordertype (if b then X else elts \\<gamma> - X) VWF \\<le> \\<gamma>\n 3. \\<And>b. small (if b then X else elts \\<gamma> - X)\n 4. \\<And>b. (if b then X else elts \\<gamma> - X) \\<subseteq> ON\n 5. elts \\<gamma>\n    \\<subseteq> (\\<Union>b. if b then X else elts \\<gamma> - X)", "show \"ordertype (if b then X else elts \\<gamma> - X) VWF \\<le> \\<gamma>\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (if b then X else elts \\<gamma> - X) VWF \\<le> \\<gamma>", "by (simp add: \\<open>Ord \\<gamma>\\<close> assms ordertype_le_Ord)"], ["proof (state)\nthis:\n  ordertype (if ?b then X else elts \\<gamma> - X) VWF \\<le> \\<gamma>\n\ngoal (4 subgoals):\n 1. indecomposable \\<gamma>\n 2. \\<And>b. small (if b then X else elts \\<gamma> - X)\n 3. \\<And>b. (if b then X else elts \\<gamma> - X) \\<subseteq> ON\n 4. elts \\<gamma>\n    \\<subseteq> (\\<Union>b. if b then X else elts \\<gamma> - X)", "show \"(if b then X else elts \\<gamma> - X) \\<subseteq> ON\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if b then X else elts \\<gamma> - X) \\<subseteq> ON", "using \\<open>Ord \\<gamma>\\<close> assms elts_subset_ON"], ["proof (prove)\nusing this:\n  Ord \\<gamma>\n  indecomposable \\<gamma>\n  X \\<subseteq> elts \\<gamma>\n  Ord ?\\<alpha> \\<Longrightarrow> elts ?\\<alpha> \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. (if b then X else elts \\<gamma> - X) \\<subseteq> ON", "by auto"], ["proof (state)\nthis:\n  (if ?b then X else elts \\<gamma> - X) \\<subseteq> ON\n\ngoal (3 subgoals):\n 1. indecomposable \\<gamma>\n 2. \\<And>b. small (if b then X else elts \\<gamma> - X)\n 3. elts \\<gamma>\n    \\<subseteq> (\\<Union>b. if b then X else elts \\<gamma> - X)", "qed (use assms down in auto)"], ["proof (state)\nthis:\n  \\<exists>b. ordertype (if b then X else elts \\<gamma> - X) VWF = \\<gamma>\n\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<gamma> \\<or>\n    ordertype (elts \\<gamma> - X) VWF = \\<gamma>", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. ordertype (if b then X else elts \\<gamma> - X) VWF = \\<gamma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>b. ordertype (if b then X else elts \\<gamma> - X) VWF = \\<gamma>\n\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<gamma> \\<or>\n    ordertype (elts \\<gamma> - X) VWF = \\<gamma>", "by (metis (full_types))"], ["proof (state)\nthis:\n  ordertype X VWF = \\<gamma> \\<or>\n  ordertype (elts \\<gamma> - X) VWF = \\<gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>From ordinals to order types\\<close>"], ["", "lemma indecomposable_ordertype_eq:\n  assumes indec: \"indecomposable \\<alpha>\" and \\<alpha>: \"ordertype A VWF = \\<alpha>\" and A: \"B \\<subseteq> A\" \"small A\"\n  shows \"ordertype B VWF = \\<alpha> \\<or> ordertype (A-B) VWF = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "assume \"\\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\""], ["proof (state)\nthis:\n  \\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "have \"ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` B) VWF = ordertype B VWF", "using \\<open>B \\<subseteq> A\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` B) VWF = ordertype B VWF", "by (auto intro: ordertype_image_ordermap [OF \\<open>small A\\<close>])"], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "have \"ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "by (metis ordertype_map_image \\<alpha> A elts_of_set ordertype_def replacement)"], ["proof (state)\nthis:\n  ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "have \"ordermap A VWF ` B \\<subseteq> elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A VWF ` B \\<subseteq> elts \\<alpha>", "using \\<alpha> A"], ["proof (prove)\nusing this:\n  ordertype A VWF = \\<alpha>\n  B \\<subseteq> A\n  small A\n\ngoal (1 subgoal):\n 1. ordermap A VWF ` B \\<subseteq> elts \\<alpha>", "by blast"], ["proof (state)\nthis:\n  ordermap A VWF ` B \\<subseteq> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> (ordertype B VWF = \\<alpha> \\<or>\n            ordertype (A - B) VWF = \\<alpha>) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\n  ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\n  ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\n  ordermap A VWF ` B \\<subseteq> elts \\<alpha>", "show False"], ["proof (prove)\nusing this:\n  \\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\n  ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\n  ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\n  ordermap A VWF ` B \\<subseteq> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "using indecomposable_imp_type2 [OF \\<open>indecomposable \\<alpha>\\<close>]  \\<open>small A\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (ordertype B VWF = \\<alpha> \\<or> ordertype (A - B) VWF = \\<alpha>)\n  ordertype (ordermap A VWF ` B) VWF = ordertype B VWF\n  ordertype (elts \\<alpha> - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\n  ordermap A VWF ` B \\<subseteq> elts \\<alpha>\n  ?X \\<subseteq> elts \\<alpha> \\<Longrightarrow>\n  ordertype ?X VWF = \\<alpha> \\<or>\n  ordertype (elts \\<alpha> - ?X) VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma indecomposable_ordertype_ge:\n  assumes indec: \"indecomposable \\<alpha>\" and \\<alpha>: \"ordertype A VWF \\<ge> \\<alpha>\" and small: \"small A\" \"small B\"\n  shows \"ordertype B VWF \\<ge> \\<alpha> \\<or> ordertype (A-B) VWF \\<ge> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "obtain A' where \"A' \\<subseteq> A\" \"ordertype A' VWF = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A'.\n        \\<lbrakk>A' \\<subseteq> A; ordertype A' VWF = \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<alpha> \\<open>small A\\<close> indec indecomposable_def le_ordertype_obtains_subset)"], ["proof (state)\nthis:\n  A' \\<subseteq> A\n  ordertype A' VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "then"], ["proof (chain)\npicking this:\n  A' \\<subseteq> A\n  ordertype A' VWF = \\<alpha>", "have \"ordertype (B \\<inter> A') VWF = \\<alpha> \\<or> ordertype (A'-B) VWF = \\<alpha>\""], ["proof (prove)\nusing this:\n  A' \\<subseteq> A\n  ordertype A' VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. ordertype (B \\<inter> A') VWF = \\<alpha> \\<or>\n    ordertype (A' - B) VWF = \\<alpha>", "by (metis Diff_Diff_Int Diff_subset Int_commute \\<open>small A\\<close> indecomposable_ordertype_eq indec smaller_than_small)"], ["proof (state)\nthis:\n  ordertype (B \\<inter> A') VWF = \\<alpha> \\<or>\n  ordertype (A' - B) VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "moreover"], ["proof (state)\nthis:\n  ordertype (B \\<inter> A') VWF = \\<alpha> \\<or>\n  ordertype (A' - B) VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "have \"ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF", "by (meson Int_lower1 small ordertype_VWF_mono smaller_than_small)"], ["proof (state)\nthis:\n  ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "moreover"], ["proof (state)\nthis:\n  ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "have \"ordertype (A'-B) VWF \\<le> ordertype (A-B) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (A' - B) VWF \\<le> ordertype (A - B) VWF", "by (meson Diff_mono Diff_subset \\<open>A' \\<subseteq> A\\<close> \\<open>small A\\<close> order_refl ordertype_VWF_mono smaller_than_small)"], ["proof (state)\nthis:\n  ordertype (A' - B) VWF \\<le> ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "ultimately"], ["proof (chain)\npicking this:\n  ordertype (B \\<inter> A') VWF = \\<alpha> \\<or>\n  ordertype (A' - B) VWF = \\<alpha>\n  ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF\n  ordertype (A' - B) VWF \\<le> ordertype (A - B) VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype (B \\<inter> A') VWF = \\<alpha> \\<or>\n  ordertype (A' - B) VWF = \\<alpha>\n  ordertype (B \\<inter> A') VWF \\<le> ordertype B VWF\n  ordertype (A' - B) VWF \\<le> ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype B VWF \\<or>\n    \\<alpha> \\<le> ordertype (A - B) VWF", "by blast"], ["proof (state)\nthis:\n  \\<alpha> \\<le> ordertype B VWF \\<or> \\<alpha> \\<le> ordertype (A - B) VWF\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>now for finite partitions\\<close>"], ["", "lemma indecomposable_ordertype_finite_eq:\n  assumes \"indecomposable \\<alpha>\"\n    and \\<A>: \"finite \\<A>\" \"pairwise disjnt \\<A>\" \"\\<Union>\\<A> = A\" \"\\<A> \\<noteq> {}\" \"ordertype A VWF = \\<alpha>\" \"small A\"\n  shows \"\\<exists>X \\<in> \\<A>. ordertype X VWF = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>", "using \\<A>"], ["proof (prove)\nusing this:\n  finite \\<A>\n  pairwise disjnt \\<A>\n  \\<Union> \\<A> = A\n  \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>", "proof (induction arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>pairwise disjnt {}; \\<Union> {} = A; {} \\<noteq> {};\n        ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. ordertype X VWF = \\<alpha>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>pairwise disjnt F; \\<Union> F = A; F \\<noteq> {};\n            ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n           \\<Longrightarrow> \\<exists>X\\<in>F. ordertype X VWF = \\<alpha>;\n        pairwise disjnt (insert x F); \\<Union> (insert x F) = A;\n        insert x F \\<noteq> {}; ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>insert x F.\n                            ordertype X VWF = \\<alpha>", "case (insert X \\<A>)"], ["proof (state)\nthis:\n  finite \\<A>\n  X \\<notin> \\<A>\n  \\<lbrakk>pairwise disjnt \\<A>; \\<Union> \\<A> = ?A; \\<A> \\<noteq> {};\n   ordertype ?A VWF = \\<alpha>; small ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>pairwise disjnt {}; \\<Union> {} = A; {} \\<noteq> {};\n        ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. ordertype X VWF = \\<alpha>\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>pairwise disjnt F; \\<Union> F = A; F \\<noteq> {};\n            ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n           \\<Longrightarrow> \\<exists>X\\<in>F. ordertype X VWF = \\<alpha>;\n        pairwise disjnt (insert x F); \\<Union> (insert x F) = A;\n        insert x F \\<noteq> {}; ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>insert x F.\n                            ordertype X VWF = \\<alpha>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "proof (cases \"\\<A> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<A> = {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n 2. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "case True"], ["proof (state)\nthis:\n  \\<A> = {}\n\ngoal (2 subgoals):\n 1. \\<A> = {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n 2. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<A> = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<A> = {}\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<A> = {}\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "case False"], ["proof (state)\nthis:\n  \\<A> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "have smA: \"small (\\<Union>\\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> \\<A>)", "using insert.prems"], ["proof (prove)\nusing this:\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. small (\\<Union> \\<A>)", "by auto"], ["proof (state)\nthis:\n  small (\\<Union> \\<A>)\n\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "proof (cases \"\\<exists>X \\<in> \\<A>. ordertype X VWF = \\<alpha>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha> \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n 2. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "case True"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>\n\ngoal (2 subgoals):\n 1. \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha> \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n 2. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "have \"X = A - \\<Union>\\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = A - \\<Union> \\<A>", "using insert.hyps insert.prems"], ["proof (prove)\nusing this:\n  finite \\<A>\n  X \\<notin> \\<A>\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. X = A - \\<Union> \\<A>", "by (auto simp: pairwise_insert disjnt_iff)"], ["proof (state)\nthis:\n  X = A - \\<Union> \\<A>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "then"], ["proof (chain)\npicking this:\n  X = A - \\<Union> \\<A>", "have \"ordertype X VWF = \\<alpha>\""], ["proof (prove)\nusing this:\n  X = A - \\<Union> \\<A>\n\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<alpha>", "using indecomposable_ordertype_eq assms insert False"], ["proof (prove)\nusing this:\n  X = A - \\<Union> \\<A>\n  \\<lbrakk>indecomposable ?\\<alpha>; ordertype ?A VWF = ?\\<alpha>;\n   ?B \\<subseteq> ?A; small ?A\\<rbrakk>\n  \\<Longrightarrow> ordertype ?B VWF = ?\\<alpha> \\<or>\n                    ordertype (?A - ?B) VWF = ?\\<alpha>\n  indecomposable \\<alpha>\n  finite \\<A>\n  pairwise disjnt \\<A>\n  \\<Union> \\<A> = A\n  \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n  finite \\<A>\n  X \\<notin> \\<A>\n  \\<lbrakk>pairwise disjnt \\<A>; \\<Union> \\<A> = ?A; \\<A> \\<noteq> {};\n   ordertype ?A VWF = \\<alpha>; small ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n  \\<not> (\\<exists>X\\<in>\\<A>. ordertype X VWF = \\<alpha>)\n\ngoal (1 subgoal):\n 1. ordertype X VWF = \\<alpha>", "by (metis Union_mono cSup_singleton pairwise_insert smA subset_insertI)"], ["proof (state)\nthis:\n  ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               ordertype X VWF = \\<alpha>) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "then"], ["proof (chain)\npicking this:\n  ordertype X VWF = \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "using insert.prems"], ["proof (prove)\nusing this:\n  ordertype X VWF = \\<alpha>\n  pairwise disjnt (insert X \\<A>)\n  \\<Union> (insert X \\<A>) = A\n  insert X \\<A> \\<noteq> {}\n  ordertype A VWF = \\<alpha>\n  small A\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. ordertype X VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>pairwise disjnt {}; \\<Union> {} = A; {} \\<noteq> {};\n        ordertype A VWF = \\<alpha>; small A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. ordertype X VWF = \\<alpha>", "qed auto"], ["", "lemma indecomposable_ordertype_finite_ge:\n  assumes indec: \"indecomposable \\<alpha>\"\n    and \\<A>: \"finite \\<A>\" \"A \\<subseteq> \\<Union>\\<A>\" \"\\<A> \\<noteq> {}\" \"ordertype A VWF \\<ge> \\<alpha>\" \"small (\\<Union>\\<A>)\"\n  shows \"\\<exists>X \\<in> \\<A>. ordertype X VWF \\<ge> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF", "using \\<A>"], ["proof (prove)\nusing this:\n  finite \\<A>\n  A \\<subseteq> \\<Union> \\<A>\n  \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> \\<A>)\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF", "proof (induction arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<subseteq> \\<Union> {}; {} \\<noteq> {};\n        \\<alpha> \\<le> ordertype A VWF; small (\\<Union> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. \\<alpha> \\<le> ordertype X VWF\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>A \\<subseteq> \\<Union> F; F \\<noteq> {};\n            \\<alpha> \\<le> ordertype A VWF; small (\\<Union> F)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>X\\<in>F.\n                                \\<alpha> \\<le> ordertype X VWF;\n        A \\<subseteq> \\<Union> (insert x F); insert x F \\<noteq> {};\n        \\<alpha> \\<le> ordertype A VWF;\n        small (\\<Union> (insert x F))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>insert x F.\n                            \\<alpha> \\<le> ordertype X VWF", "case (insert X \\<A>)"], ["proof (state)\nthis:\n  finite \\<A>\n  X \\<notin> \\<A>\n  \\<lbrakk>?A \\<subseteq> \\<Union> \\<A>; \\<A> \\<noteq> {};\n   \\<alpha> \\<le> ordertype ?A VWF; small (\\<Union> \\<A>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>A \\<subseteq> \\<Union> {}; {} \\<noteq> {};\n        \\<alpha> \\<le> ordertype A VWF; small (\\<Union> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. \\<alpha> \\<le> ordertype X VWF\n 2. \\<And>x F A.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>A.\n           \\<lbrakk>A \\<subseteq> \\<Union> F; F \\<noteq> {};\n            \\<alpha> \\<le> ordertype A VWF; small (\\<Union> F)\\<rbrakk>\n           \\<Longrightarrow> \\<exists>X\\<in>F.\n                                \\<alpha> \\<le> ordertype X VWF;\n        A \\<subseteq> \\<Union> (insert x F); insert x F \\<noteq> {};\n        \\<alpha> \\<le> ordertype A VWF;\n        small (\\<Union> (insert x F))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>insert x F.\n                            \\<alpha> \\<le> ordertype X VWF", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "proof (cases \"\\<A> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<A> = {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n 2. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "case True"], ["proof (state)\nthis:\n  \\<A> = {}\n\ngoal (2 subgoals):\n 1. \\<A> = {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n 2. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "then"], ["proof (chain)\npicking this:\n  \\<A> = {}", "have \"\\<alpha> \\<le> ordertype X VWF\""], ["proof (prove)\nusing this:\n  \\<A> = {}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype X VWF", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<A> = {}\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype X VWF", "by (simp add: order.trans ordertype_VWF_mono)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> ordertype X VWF\n\ngoal (2 subgoals):\n 1. \\<A> = {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n 2. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> ordertype X VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> ordertype X VWF\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "case False"], ["proof (state)\nthis:\n  \\<A> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<A> \\<noteq> {} \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "proof (cases \"\\<exists>X \\<in> \\<A>. ordertype X VWF \\<ge> \\<alpha>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n 2. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "case True"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal (2 subgoals):\n 1. \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n 2. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "then"], ["proof (chain)\npicking this:\n  \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "have \"small (X \\<union> \\<Union>\\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X \\<union> \\<Union> \\<A>)", "using insert.prems"], ["proof (prove)\nusing this:\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (1 subgoal):\n 1. small (X \\<union> \\<Union> \\<A>)", "by auto"], ["proof (state)\nthis:\n  small (X \\<union> \\<Union> \\<A>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "moreover"], ["proof (state)\nthis:\n  small (X \\<union> \\<Union> \\<A>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "have \"ordertype (\\<Union>(insert X \\<A>)) VWF \\<ge> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF", "using insert.prems ordertype_VWF_mono"], ["proof (prove)\nusing this:\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n  \\<lbrakk>?X \\<subseteq> ?Y; small ?Y\\<rbrakk>\n  \\<Longrightarrow> ordertype ?X VWF \\<le> ordertype ?Y VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF", "by blast"], ["proof (state)\nthis:\n  \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF)\n  small (X \\<union> \\<Union> \\<A>)\n  \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF", "have \"ordertype X VWF \\<ge> \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF)\n  small (X \\<union> \\<Union> \\<A>)\n  \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype X VWF", "using indecomposable_ordertype_ge [OF indec]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>X\\<in>\\<A>. \\<alpha> \\<le> ordertype X VWF)\n  small (X \\<union> \\<Union> \\<A>)\n  \\<alpha> \\<le> ordertype (\\<Union> (insert X \\<A>)) VWF\n  \\<lbrakk>\\<alpha> \\<le> ordertype ?A VWF; small ?A; small ?B\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> \\<le> ordertype ?B VWF \\<or>\n                    \\<alpha> \\<le> ordertype (?A - ?B) VWF\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> ordertype X VWF", "by (metis Diff_subset_conv Sup_insert cSup_singleton insert.IH small_sup_iff subset_refl)"], ["proof (state)\nthis:\n  \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>X\\<in>\\<A>.\n               \\<alpha> \\<le> ordertype X VWF) \\<Longrightarrow>\n    \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> ordertype X VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> ordertype X VWF\n  A \\<subseteq> \\<Union> (insert X \\<A>)\n  insert X \\<A> \\<noteq> {}\n  \\<alpha> \\<le> ordertype A VWF\n  small (\\<Union> (insert X \\<A>))\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF", "by blast"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X\\<in>insert X \\<A>. \\<alpha> \\<le> ordertype X VWF\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>A \\<subseteq> \\<Union> {}; {} \\<noteq> {};\n        \\<alpha> \\<le> ordertype A VWF; small (\\<Union> {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>{}. \\<alpha> \\<le> ordertype X VWF", "qed auto"], ["", "end"]]}