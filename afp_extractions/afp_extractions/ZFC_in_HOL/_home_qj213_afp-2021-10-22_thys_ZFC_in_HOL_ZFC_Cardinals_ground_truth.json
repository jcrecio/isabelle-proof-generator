{"file_name": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL/ZFC_Cardinals.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/ZFC_in_HOL", "problem_names": ["lemma singleton_eq_iff [iff]: \"set {a} = set {b} \\<longleftrightarrow> a=b\"", "lemma doubleton_eq_iff: \"set {a,b} = set {c,d} \\<longleftrightarrow> (a=c \\<and> b=d) \\<or> (a=d \\<and> b=c)\"", "lemma vpair_def': \"vpair a b = set {set {a,a},set {a,b}}\"", "lemma vpair_iff [simp]: \"vpair a b = vpair a' b' \\<longleftrightarrow> a=a' \\<and> b=b'\"", "lemmas vpair_inject = vpair_iff [THEN iffD1, THEN conjE, elim!]", "lemma vfst_conv [simp]: \"vfst \\<langle>a,b\\<rangle> = a\"", "lemma vsnd_conv [simp]: \"vsnd \\<langle>a,b\\<rangle> = b\"", "lemma vsplit [simp]: \"vsplit c \\<langle>a,b\\<rangle> = c a b\"", "lemma vpair_neq_fst: \"\\<langle>a,b\\<rangle> \\<noteq> a\"", "lemma vpair_neq_snd: \"\\<langle>a,b\\<rangle> \\<noteq> b\"", "lemma vpair_nonzero [simp]: \"\\<langle>x,y\\<rangle> \\<noteq> 0\"", "lemma zero_notin_vpair: \"0 \\<notin> elts \\<langle>x,y\\<rangle>\"", "lemma inj_on_vpair [simp]: \"inj_on (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) A\"", "lemma pairs_iff_elts: \"(x,y) \\<in> pairs z \\<longleftrightarrow> \\<langle>x,y\\<rangle> \\<in> elts z\"", "lemma VSigma_iff [simp]: \"\\<langle>a,b\\<rangle> \\<in> elts (VSigma A B) \\<longleftrightarrow> a \\<in> elts A \\<and> b \\<in> elts (B a)\"", "lemma VSigmaI [intro!]: \"\\<lbrakk> a \\<in> elts A;  b \\<in> elts (B a)\\<rbrakk>  \\<Longrightarrow> \\<langle>a,b\\<rangle> \\<in> elts (VSigma A B)\"", "lemmas VSigmaD1 = VSigma_iff [THEN iffD1, THEN conjunct1]", "lemmas VSigmaD2 = VSigma_iff [THEN iffD1, THEN conjunct2]", "lemma VSigmaE [elim!]:\n  assumes \"c \\<in> elts (VSigma A B)\"\n  obtains x y where \"x \\<in> elts A\" \"y \\<in> elts (B x)\" \"c=\\<langle>x,y\\<rangle>\"", "lemma VSigmaE2 [elim!]:\n  assumes \"\\<langle>a,b\\<rangle> \\<in> elts (VSigma A B)\" obtains \"a \\<in> elts A\" and \"b \\<in> elts (B a)\"", "lemma VSigma_empty1 [simp]: \"VSigma 0 B = 0\"", "lemma times_iff [simp]: \"\\<langle>a,b\\<rangle> \\<in> elts (vtimes A B) \\<longleftrightarrow> a \\<in> elts A \\<and> b \\<in> elts B\"", "lemma timesI [intro!]: \"\\<lbrakk>a \\<in> elts A;  b \\<in> elts B\\<rbrakk>  \\<Longrightarrow> \\<langle>a,b\\<rangle> \\<in> elts (vtimes A B)\"", "lemma times_empty2 [simp]: \"vtimes A 0 = 0\"", "lemma times_empty_iff: \"VSigma A B = 0 \\<longleftrightarrow> A=0 \\<or> (\\<forall>x \\<in> elts A. B x = 0)\"", "lemma elts_VSigma: \"elts (VSigma a b) = (\\<lambda>(x,y). vpair x y) ` Sigma (elts a) (\\<lambda>x. elts (b x))\"", "lemma small_Times [simp]:\n  assumes \"small A\" \"small B\" \n  shows \"small (A \\<times> B)\"", "lemmas sum_defs = vsum_def Inl_def Inr_def", "lemma Inl_nonzero [simp]:\"Inl x \\<noteq> 0\"", "lemma Inr_nonzero [simp]:\"Inr x \\<noteq> 0\"", "lemma Inl_in_sum_iff [iff]: \"Inl a \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> a \\<in> elts A\"", "lemma Inr_in_sum_iff [iff]: \"Inr b \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> b \\<in> elts B\"", "lemma sumE [elim!]:\n  assumes u: \"u \\<in> elts (A \\<Uplus> B)\"\n  obtains x where \"x \\<in> elts A\" \"u=Inl x\" | y where \"y \\<in> elts B\" \"u=Inr y\"", "lemma Inl_iff [iff]: \"Inl a=Inl b \\<longleftrightarrow> a=b\"", "lemma Inr_iff [iff]: \"Inr a=Inr b \\<longleftrightarrow> a=b\"", "lemma inj_on_Inl [simp]: \"inj_on Inl A\"", "lemma inj_on_Inr [simp]: \"inj_on Inr A\"", "lemma Inl_Inr_iff [iff]: \"Inl a=Inr b \\<longleftrightarrow> False\"", "lemma Inr_Inl_iff [iff]: \"Inr b=Inl a \\<longleftrightarrow> False\"", "lemma sum_empty [simp]: \"0 \\<Uplus> 0 = 0\"", "lemma elts_vsum: \"elts (a \\<Uplus> b) = Inl ` (elts a) \\<union> Inr ` (elts b)\"", "lemma sum_iff: \"u \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> (\\<exists>x. x \\<in> elts A \\<and> u=Inl x) \\<or> (\\<exists>y. y \\<in> elts B \\<and> u=Inr y)\"", "lemma sum_subset_iff: \"A\\<Uplus>B \\<le> C\\<Uplus>D \\<longleftrightarrow> A\\<le>C \\<and> B\\<le>D\"", "lemma sum_equal_iff:\n  fixes A :: V shows \"A\\<Uplus>B = C\\<Uplus>D \\<longleftrightarrow> A=C \\<and> B=D\"", "lemma sum_case_Inl [simp]: \"sum_case f g (Inl x) = f x\"", "lemma sum_case_Inr [simp]: \"sum_case f g (Inr y) = g y\"", "lemma sum_case_non [simp]: \"\\<not> is_sum a \\<Longrightarrow> sum_case f g a = undefined\"", "lemma is_sum_cases: \"(\\<exists>x. z = Inl x \\<or> z = Inr x) \\<or> \\<not> is_sum z\"", "lemma sum_case_split:\n  \"P (sum_case f g a) \\<longleftrightarrow> (\\<forall>x. a = Inl x \\<longrightarrow> P(f x)) \\<and> (\\<forall>y. a = Inr y \\<longrightarrow> P(g y)) \\<and> (\\<not> is_sum a \\<longrightarrow> P undefined)\"", "lemma sum_case_split_asm:\n  \"P (sum_case f g a) \\<longleftrightarrow> \\<not> ((\\<exists>x. a = Inl x \\<and> \\<not> P(f x)) \\<or> (\\<exists>y. a = Inr y \\<and> \\<not> P(g y)) \\<or> (\\<not> is_sum a \\<and> \\<not> P undefined))\"", "lemma small_Un:\n  assumes X: \"small X\" and Y: \"small Y\"\n  shows \"small (X \\<union> Y)\"", "lemma small_UN [simp,intro]:\n  assumes X: \"small X\" and B: \"\\<And>x. x \\<in> X \\<Longrightarrow> small (B x)\"\n  shows \"small (\\<Union>x\\<in>X. B x)\"", "lemma small_Union [simp,intro]:\n  assumes \"\\<A> \\<subseteq> Collect small\" \"small \\<A>\"\n  shows \"small (\\<Union> \\<A>)\"", "lemma beta [simp]:\n  assumes \"x \\<in> elts A\"\n  shows \"app (VLambda A b) x = b x\"", "lemma VPi_I:\n  assumes \"\\<And>x. x \\<in> elts A \\<Longrightarrow> b x \\<in> elts (B x)\"\n  shows \"VLambda A b \\<in> elts (VPi A B)\"", "lemma apply_pair:\n  assumes f: \"f \\<in> elts (VPi A B)\" and x: \"x \\<in> elts A\"\n  shows \"\\<langle>x, app f x\\<rangle> \\<in> elts f\"", "lemma VPi_D:\n  assumes f: \"f \\<in> elts (VPi A B)\" and x: \"x \\<in> elts A\"\n  shows \"app f x \\<in> elts (B x)\"", "lemma VPi_memberD:\n  assumes f: \"f \\<in> elts (VPi A B)\" and p: \"p \\<in> elts f\"\n  obtains x where \"x \\<in> elts A\" \"p = \\<langle>x, app f x\\<rangle>\"", "lemma fun_ext:\n  assumes \"f \\<in> elts (VPi A B)\" \"g \\<in> elts (VPi A B)\" \"\\<And>x. x \\<in> elts A \\<Longrightarrow> app f x = app g x\"\n  shows \"f = g\"", "lemma eta[simp]:\n  assumes \"f \\<in> elts (VPi A B)\"\n  shows \"VLambda A ((app)f) = f\"", "lemma fst_pairs_VLambda: \"fst ` pairs (VLambda A f) = elts A\"", "lemma snd_pairs_VLambda: \"snd ` pairs (VLambda A f) = f ` elts A\"", "lemma VLambda_eq_D1: \"VLambda A f = VLambda B g \\<Longrightarrow> A = B\"", "lemma VLambda_eq_D2: \"\\<lbrakk>VLambda A f = VLambda A g; x \\<in> elts A\\<rbrakk> \\<Longrightarrow> f x = g x\"", "lemma TC: \"TC a = a \\<squnion> \\<Squnion> (TC ` elts a)\"", "lemma TC_0 [simp]: \"TC 0 = 0\"", "lemma arg_subset_TC: \"a \\<le> TC a\"", "lemma Transset_TC: \"Transset(TC a)\"", "lemma TC_least: \"\\<lbrakk>Transset x;  a\\<le>x\\<rbrakk> \\<Longrightarrow> TC a \\<le> x\"", "lemma less_TC_imp_not_le: \"x \\<sqsubset> a \\<Longrightarrow> \\<not> a \\<le> x\"", "lemma non_TC_less_0 [iff]: \"\\<not> (x \\<sqsubset> 0)\"", "lemma less_TC_iff: \"x \\<sqsubset> y \\<longleftrightarrow> (\\<exists>z \\<in> elts y. x \\<sqsubseteq> z)\"", "lemma nonzero_less_TC: \"x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> x\"", "lemma less_irrefl_TC [simp]: \"\\<not> x \\<sqsubset> x\"", "lemma less_asym_TC: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk> \\<Longrightarrow> False\"", "lemma le_antisym_TC: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk> \\<Longrightarrow> x = y\"", "lemma less_imp_le_TC [iff]: \"x \\<sqsubset> y \\<Longrightarrow> x \\<sqsubseteq> y\"", "lemma le_TC_refl [iff]: \"x \\<sqsubseteq> x\"", "lemma less_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\"", "lemma less_le_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubseteq> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\"", "lemma le_less_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubset> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\"", "lemma le_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubseteq> z\"", "lemma TC_sup_distrib: \"TC (x \\<squnion> y) = TC x \\<squnion> TC y\"", "lemma TC_Sup_distrib:\n  assumes \"small X\" shows \"TC (\\<Squnion>X) = \\<Squnion>(TC ` X)\"", "lemma TC': \"TC x = x \\<squnion> TC (\\<Squnion> (elts x))\"", "lemma TC_eq_0_iff [simp]: \"TC x = 0 \\<longleftrightarrow> x=0\"", "lemma TC_induct_down_lemma:\n  assumes ab: \"a \\<sqsubset> b\" and base: \"b \\<le> d\"\n      and step: \"\\<And>y z. \\<lbrakk>y \\<sqsubset> b; y \\<in> elts d; z \\<in> elts y\\<rbrakk> \\<Longrightarrow> z \\<in> elts d\"\n    shows \"a \\<in> elts d\"", "lemma TC_induct_down [consumes 1, case_names base step small]:\n  assumes \"a \\<sqsubset> b\"\n    and \"\\<And>y. y \\<in> elts b \\<Longrightarrow> P y\"\n    and \"\\<And>y z. \\<lbrakk>y \\<sqsubset> b; P y; z \\<in> elts y\\<rbrakk> \\<Longrightarrow> P z\"\n    and \"small (Collect P)\"\n  shows \"P a\"", "lemma rank: \"rank a = set(\\<Union>y \\<in> elts a. elts (succ(rank y)))\"", "lemma rank_Sup: \"rank a = \\<Squnion>((\\<lambda>y. succ(rank y)) ` elts a)\"", "lemma Ord_rank [simp]: \"Ord(rank a)\"", "lemma rank_of_Ord: \"Ord i \\<Longrightarrow> rank i = i\"", "lemma Ord_iff_rank: \"Ord x \\<longleftrightarrow> rank x = x\"", "lemma rank_lt: \"a \\<in> elts b \\<Longrightarrow> rank a < rank b\"", "lemma rank_0 [simp]: \"rank 0 = 0\"", "lemma rank_succ [simp]: \"rank(succ x) = succ(rank x)\"", "lemma rank_mono: \"a \\<le> b \\<Longrightarrow> rank a \\<le> rank b\"", "lemma VsetI: \"rank b \\<sqsubset> i \\<Longrightarrow> b \\<in> elts (Vset i)\"", "lemma Ord_VsetI: \"\\<lbrakk>Ord i; rank b < i\\<rbrakk> \\<Longrightarrow> b \\<in> elts (Vset i)\"", "lemma arg_le_Vset_rank: \"a \\<le> Vset(rank a)\"", "lemma two_in_Vset:\n  obtains \\<alpha> where  \"x \\<in> elts (Vset \\<alpha>)\" \"y \\<in> elts (Vset \\<alpha>)\"", "lemma rank_eq_0_iff [simp]: \"rank x = 0 \\<longleftrightarrow> x=0\"", "lemma small_ranks_imp_small:\n  assumes \"small (rank ` A)\" shows \"small A\"", "lemma rank_Union: \"rank(\\<Squnion> A) = \\<Squnion> (rank ` A)\"", "lemma small_bounded_rank:  \"small {x. rank x \\<in> elts a}\"", "lemma small_bounded_rank_le:  \"small {x. rank x \\<le> a}\"", "lemma TC_rank_lt: \"a \\<sqsubset> b \\<Longrightarrow> rank a < rank b\"", "lemma TC_rank_mem: \"x \\<sqsubset> y \\<Longrightarrow> rank x \\<in> elts (rank y)\"", "lemma wf_TC_less: \"wf {(x,y). x \\<sqsubset> y}\"", "lemma less_TC_minimal:\n  assumes \"P a\"\n  obtains x where \"P x\" \"x \\<sqsubseteq> a\" \"\\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> P y\"", "lemma Vfrom_rank_eq: \"Vfrom A (rank(x)) = Vfrom A x\"", "lemma Vfrom_succ: \"Vfrom A (succ(i)) = A \\<squnion> VPow(Vfrom A i)\"", "lemma Vset_succ_TC:\n  assumes \"x \\<in> elts (Vset (ZFC_in_HOL.succ k))\" \"u \\<sqsubset> x\"\n  shows \"u \\<in> elts (Vset k)\"", "lemma VWO: \"{(x,y). x \\<in> elts y} \\<subseteq> VWO \\<and> Well_order VWO \\<and> Field VWO = UNIV\"", "lemma wf_VWO: \"wf(VWO - Id)\"", "lemma wf_Ord_less: \"wf {(x, y). Ord y \\<and> x < y}\"", "lemma refl_VWO: \"refl VWO\"", "lemma trans_VWO: \"trans VWO\"", "lemma antisym_VWO: \"antisym VWO\"", "lemma total_VWO: \"total VWO\"", "lemma total_VWOId: \"total (VWO-Id)\"", "lemma Linear_order_VWO: \"Linear_order VWO\"", "lemma wo_rel_VWO: \"wo_rel VWO\"", "lemma mem_imp_VWO: \"x \\<in> elts y \\<Longrightarrow> (x,y) \\<in> VWO\"", "lemma less_TC_imp_VWO: \"x \\<sqsubset> y \\<Longrightarrow> (x,y) \\<in> VWO\"", "lemma le_TC_imp_VWO: \"x \\<sqsubseteq> y \\<Longrightarrow> (x,y) \\<in> VWO\"", "lemma le_TC_0_iff [simp]: \"x \\<sqsubseteq> 0 \\<longleftrightarrow> x = 0\"", "lemma less_TC_succ: \" x \\<sqsubset> succ \\<beta> \\<longleftrightarrow> x \\<sqsubset> \\<beta> \\<or> x = \\<beta>\"", "lemma le_TC_succ: \"x \\<sqsubseteq> succ \\<beta> \\<longleftrightarrow> x \\<sqsubseteq> \\<beta> \\<or> x = succ \\<beta>\"", "lemma Transset_TC_eq [simp]: \"Transset x \\<Longrightarrow> TC x = x\"", "lemma Ord_TC_less_iff: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> \\<beta> \\<sqsubset> \\<alpha> \\<longleftrightarrow> \\<beta> < \\<alpha>\"", "lemma Ord_mem_iff_less_TC: \"Ord l \\<Longrightarrow> k \\<in> elts l \\<longleftrightarrow> k \\<sqsubset> l\"", "lemma le_TC_Ord: \"\\<lbrakk>\\<beta> \\<sqsubseteq> \\<alpha>; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> Ord \\<beta>\"", "lemma Ord_less_TC_mem:\n  assumes \"Ord \\<alpha>\" \"\\<beta> \\<sqsubset> \\<alpha>\" shows \"\\<beta> \\<in> elts \\<alpha>\"", "lemma VWO_TC_le: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; (\\<beta>, \\<alpha>) \\<in> VWO\\<rbrakk> \\<Longrightarrow> \\<beta> \\<sqsubseteq> \\<alpha>\"", "lemma VWO_iff_Ord_le [simp]: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> (\\<beta>, \\<alpha>) \\<in> VWO \\<longleftrightarrow> \\<beta> \\<le> \\<alpha>\"", "lemma zero_TC_le [iff]: \"0 \\<sqsubseteq> y\"", "lemma succ_le_TC_iff: \"Ord j \\<Longrightarrow> succ i \\<sqsubseteq> j \\<longleftrightarrow> i \\<sqsubset> j\"", "lemma VWO_0_iff [simp]: \"(x,0) \\<in> VWO \\<longleftrightarrow> x=0\"", "lemma VWO_antisym:\n  assumes \"(x,y) \\<in> VWO\" \"(y,x) \\<in> VWO\" shows \"x=y\"", "lemma wf_VWF [iff]: \"wf VWF\"", "lemma trans_VWF [iff]: \"trans VWF\"", "lemma asym_VWF [iff]: \"asym VWF\"", "lemma total_VWF [iff]: \"total VWF\"", "lemma total_on_VWF [iff]: \"total_on A VWF\"", "lemma VWF_asym:\n  assumes \"(x,y) \\<in> VWF\" \"(y,x) \\<in> VWF\" shows False", "lemma VWF_non_refl [iff]: \"(x,x) \\<notin> VWF\"", "lemma VWF_iff_Ord_less [simp]: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> (\\<alpha>,\\<beta>) \\<in> VWF \\<longleftrightarrow> \\<alpha> < \\<beta>\"", "lemma mem_imp_VWF: \"x \\<in> elts y \\<Longrightarrow> (x,y) \\<in> VWF\"", "lemma ordermap_type:\n    \"small A \\<Longrightarrow> ordermap A r \\<in> A \\<rightarrow> elts (ordertype A r)\"", "lemma ordermap_in_ordertype [intro]: \"\\<lbrakk>a \\<in> A; small A\\<rbrakk> \\<Longrightarrow> ordermap A r a \\<in> elts (ordertype A r)\"", "lemma ordermap: \"wf r \\<Longrightarrow> ordermap A r a = set (ordermap A r ` {y \\<in> A. (y,a) \\<in> r})\"", "lemma Ord_ordermap [iff]: assumes \"wf r\" \"trans r\" shows \"Ord (ordermap A r x)\"", "lemma wf_Ord_ordertype: assumes \"wf r\" \"trans r\" shows \"Ord(ordertype A r)\"", "lemma Ord_ordertype [simp]: \"Ord(ordertype A VWF)\"", "lemma ordertype_singleton [simp]:\n  assumes \"wf r\" \n  shows \"ordertype {x} r = 1\"", "lemma ordermap_mono:\n  assumes wx: \"(w, x) \\<in> r\" and \"wf r\" \"w \\<in> A\" \"small A\"\n    shows \"ordermap A r w \\<in> elts (ordermap A r x)\"", "lemma converse_ordermap_mono:\n  assumes \"ordermap A r y \\<in> elts (ordermap A r x)\" \"wf r\" \"total_on A r\" \"x \\<in> A\" \"y \\<in> A\" \"small A\"\n  shows \"(y, x) \\<in> r\"", "lemma ordermap_surj: \"elts (ordertype A r) \\<subseteq> ordermap A r ` A\"", "lemma ordermap_bij:\n  assumes \"wf r\" \"total_on A r\" \"small A\"\n  shows \"bij_betw (ordermap A r) A (elts (ordertype A r))\"", "lemma ordermap_eq_iff [simp]: \n  \"\\<lbrakk>x \\<in> A; y \\<in> A; wf r; total_on A r; small A\\<rbrakk> \\<Longrightarrow> ordermap A r x = ordermap A r y \\<longleftrightarrow> x = y\"", "lemma inv_into_ordermap: \"\\<alpha> \\<in> elts (ordertype A r) \\<Longrightarrow> inv_into A (ordermap A r) \\<alpha> \\<in> A\"", "lemma ordertype_nat_imp_finite:\n  assumes \"ordertype A r = ord_of_nat m\" \"small A\" \"wf r\" \"total_on A r\"\n  shows \"finite A\"", "lemma wf_ordertype_eqpoll:\n  assumes \"wf r\" \"total_on A r\" \"small A\"\n  shows \"elts (ordertype A r) \\<approx> A\"", "lemma ordertype_eqpoll:\n  assumes \"small A\"\n  shows \"elts (ordertype A VWF) \\<approx> A\"", "lemma ordermap_VWF_0 [simp]: \"ordermap A VWF 0 = 0\"", "lemma ordertype_empty [simp]: \"ordertype {} r = 0\"", "lemma ordertype_eq_0_iff [simp]: \"\\<lbrakk>small X; wf r\\<rbrakk> \\<Longrightarrow> ordertype X r = 0 \\<longleftrightarrow> X = {}\"", "lemma ordermap_mono_less:\n  assumes \"(w, x) \\<in> r\"\n      and \"wf r\" \"trans r\"\n      and \"w \\<in> A\" \"x \\<in> A\"\n      and \"small A\"\n    shows \"ordermap A r w < ordermap A r x\"", "lemma ordermap_mono_le:\n  assumes \"(w, x) \\<in> r \\<or> w=x\"\n      and \"wf r\" \"trans r\"\n      and \"w \\<in> A\" \"x \\<in> A\"\n      and \"small A\"\n    shows \"ordermap A r w \\<le> ordermap A r x\"", "lemma converse_ordermap_le_mono:\n  assumes \"ordermap A r y \\<le> ordermap A r x\" \"wf r\" \"total r\"  \"x \\<in> A\" \"small A\"\n  shows \"(y, x) \\<in> r \\<or> y=x\"", "lemma ordertype_mono:\n  assumes \"X \\<subseteq> Y\" and r: \"wf r\" \"trans r\" and \"small Y\"\n  shows \"ordertype X r \\<le> ordertype Y r\"", "lemma ordertype_UNION_ge:\n  assumes \"A \\<in> \\<A>\" \"wf r\" \"trans r\" \"\\<A> \\<subseteq> Collect small\" \"small \\<A>\"\n  shows \"ordertype A r \\<le> ordertype (\\<Union>\\<A>) r\"", "lemma inv_ordermap_mono_less:\n  assumes \"(inv_into M (ordermap M r) \\<alpha>, inv_into M (ordermap M r) \\<beta>) \\<in> r\" \n    and \"small M\" and \\<alpha>: \"\\<alpha> \\<in> elts (ordertype M r)\" and \\<beta>: \"\\<beta> \\<in> elts (ordertype M r)\"\n    and \"wf r\" \"trans r\"\n  shows \"\\<alpha> < \\<beta>\"", "lemma inv_ordermap_mono_eq:\n  assumes \"inv_into M (ordermap M r) \\<alpha> = inv_into M (ordermap M r) \\<beta>\" \n    and \"\\<alpha> \\<in> elts (ordertype M r)\" \"\\<beta> \\<in> elts (ordertype M r)\"\n  shows \"\\<alpha> = \\<beta>\"", "lemma inv_ordermap_VWF_mono_le:\n  assumes \"inv_into M (ordermap M VWF) \\<alpha> \\<le> inv_into M (ordermap M VWF) \\<beta>\" \n    and \"M \\<subseteq> ON\" \"small M\" and \\<alpha>: \"\\<alpha> \\<in> elts (ordertype M VWF)\" and \\<beta>: \"\\<beta> \\<in> elts (ordertype M VWF)\"\n  shows \"\\<alpha> \\<le> \\<beta>\"", "lemma strict_mono_on_ordertype:\n  assumes \"M \\<subseteq> ON\" \"small M\"\n  obtains f where \"f \\<in> elts (ordertype M VWF) \\<rightarrow> M\" \"strict_mono_on f (elts (ordertype M VWF))\"", "lemma ordermap_inc_eq:\n  assumes \"x \\<in> A\" \"small A\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \n  shows \"ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x\"", "lemma ordertype_inc_eq:\n  assumes \"small A\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \n  shows \"ordertype (\\<pi> ` A) s = ordertype A r\"", "lemma ordertype_inc_le:\n  assumes \"small A\" \"small B\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \"trans s\"\n    and \"\\<pi> ` A \\<subseteq> B\"\n  shows \"ordertype A r \\<le> ordertype B s\"", "lemma ordertype_image_ordermap:\n  assumes \"small A\" \"X \\<subseteq> A\" \"wf r\" \"trans r\" \"total_on X r\"\n  shows \"ordertype (ordermap A r ` X) VWF = ordertype X r\"", "lemma ordertype_map_image:\n  assumes \"B \\<subseteq> A\" \"small A\"\n  shows \"ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\"", "lemma iso_imp_ordertype_eq_ordertype:\n  assumes iso: \"iso r r' f\"\n    and \"wf r\"\n    and \"Total r\"\n    and sm: \"small (Field r)\"\n  shows \"ordertype (Field r) r = ordertype (Field r') r'\"", "lemma ordertype_infinite_ge_\\<omega>:\n  assumes \"infinite A\" \"small A\"\n  shows \"ordertype A VWF \\<ge> \\<omega>\"", "lemma ordertype_eqI:\n  assumes \"wf r\" \"total_on A r\" \"small A\" \"wf s\" \n          \"bij_betw f A B\" \"(\\<forall>x \\<in> A. \\<forall>y \\<in> A. (f x, f y) \\<in> s \\<longleftrightarrow> (x,y) \\<in> r)\"\n  shows \"ordertype A r = ordertype B s\"", "lemma ordermap_eq_self:\n  assumes \"Ord \\<alpha>\" and x: \"x \\<in> elts \\<alpha>\" \n  shows \"ordermap (elts \\<alpha>) VWF x = x\"", "lemma ordertype_eq_Ord [simp]:\n  assumes \"Ord \\<alpha>\" \n  shows \"ordertype (elts \\<alpha>) VWF = \\<alpha>\"", "lemma ordertype_le_Ord:\n  assumes \"Ord \\<alpha>\" \"X \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype X VWF \\<le> \\<alpha>\"", "lemma ordertype_inc_le_Ord:\n  assumes \"small A\" \"Ord \\<alpha>\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> \\<pi> x < \\<pi> y\"\n    and \"wf r\" \"total_on A r\" \n    and sub: \"\\<pi> ` A \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype A r \\<le> \\<alpha>\"", "lemma le_ordertype_obtains_subset:\n  assumes \\<alpha>: \"\\<beta> \\<le> \\<alpha>\" \"ordertype H VWF = \\<alpha>\" and \"small H\" \"Ord \\<beta>\"\n  obtains G where \"G \\<subseteq> H\" \"ordertype G VWF = \\<beta>\"", "lemma ordertype_infinite_\\<omega>:\n  assumes \"A \\<subseteq> elts \\<omega>\" \"infinite A\"\n  shows \"ordertype A VWF = \\<omega>\"", "lemma ordertype_nat_\\<omega>:\n  assumes \"infinite N\" shows \"ordertype N less_than = \\<omega>\"", "lemma Limit_ordertype_imp_Field_Restr:\n  assumes Lim: \"Limit (ordertype A r)\" and r: \"wf r\" \"total_on A r\" and \"small A\"\n  shows \"Field (Restr r A) = A\"", "lemma ordertype_Field_Restr:\n  assumes \"wf r\" \"total_on A r\" \"trans r\" \"small A\" \"Field (Restr r A) = A\"\n  shows \"ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\"", "lemma ordermap_insert:\n  assumes \"Ord \\<alpha>\" and y: \"Ord y\" \"y \\<le> \\<alpha>\" and U: \"U \\<subseteq> elts \\<alpha>\"\n  shows \"ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y\"", "lemma ordertype_insert:\n  assumes \"Ord \\<alpha>\" and U: \"U \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype (insert \\<alpha> U) VWF = succ (ordertype U VWF)\"", "lemma finite_ordertype_le_card:\n  assumes \"finite A\" \"wf r\" \"trans r\" \n  shows \"ordertype A r \\<le> ord_of_nat (card A)\"", "lemma ordertype_VWF_\\<omega>:\n  assumes \"finite A\"\n  shows \"ordertype A VWF \\<in> elts \\<omega>\"", "lemma ordertype_VWF_finite_nat:\n  assumes \"finite A\"\n  shows \"ordertype A VWF = ord_of_nat (card A)\"", "lemma finite_ordertype_eq_card:\n  assumes \"small A\" \"wf r\" \"trans r\" \"total_on A r\"\n  shows \"ordertype A r = ord_of_nat m \\<longleftrightarrow> finite A \\<and> card A = m\"", "lemma ex_bij_betw_strict_mono_card:\n  assumes \"finite M\" \"M \\<subseteq> ON\"\n  obtains h where \"bij_betw h {..<card M} M\" and \"strict_mono_on h {..<card M}\"", "lemma ordertype_finite_less_than [simp]: \n  assumes \"finite A\" shows \"ordertype A less_than = card A\"", "lemma cardinal_cong: \"elts x \\<approx> elts y \\<Longrightarrow> vcard x = vcard y\"", "lemma Card_cardinal_eq: \"Card \\<kappa> \\<Longrightarrow> vcard \\<kappa> = \\<kappa>\"", "lemma Card_is_Ord:\n  assumes \"Card \\<kappa>\" shows \"Ord \\<kappa>\"", "lemma cardinal_eqpoll: \"elts (vcard a) \\<approx> elts a\"", "lemma inj_into_vcard:\n  obtains f where \"f \\<in> elts A \\<rightarrow> elts (vcard A)\" \"inj_on f (elts A)\"", "lemma cardinal_idem [simp]: \"vcard (vcard a) = vcard a\"", "lemma nat_into_Card:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" shows \"Card(\\<alpha>)\"", "lemma Card_ord_of_nat [simp]: \"Card (ord_of_nat n)\"", "lemma Card_0 [iff]: \"Card 0\"", "lemma CardI: \"\\<lbrakk>Ord i; \\<And>j. \\<lbrakk>j < i; Ord j\\<rbrakk> \\<Longrightarrow> \\<not> elts j \\<approx> elts i\\<rbrakk> \\<Longrightarrow> Card i\"", "lemma vcard_0 [simp]: \"vcard 0 = 0\"", "lemma Ord_cardinal [simp,intro!]: \"Ord(vcard a)\"", "lemma Card_iff_initial: \"Card \\<kappa> \\<longleftrightarrow> Ord \\<kappa> \\<and> (\\<forall>\\<alpha>. Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow> ~ elts \\<alpha> \\<approx> elts \\<kappa>)\"", "lemma Card_\\<omega> [iff]: \"Card \\<omega>\"", "lemma lt_Card_imp_lesspoll: \"\\<lbrakk>i < a; Card a; Ord i\\<rbrakk> \\<Longrightarrow> elts i \\<prec> elts a\"", "lemma lepoll_imp_Card_le:\n  assumes \"elts a \\<lesssim> elts b\" shows \"vcard a \\<le> vcard b\"", "lemma lepoll_cardinal_le: \"\\<lbrakk>elts A \\<lesssim> elts i; Ord i\\<rbrakk> \\<Longrightarrow> vcard A \\<le> i\"", "lemma cardinal_le_lepoll: \"vcard A \\<le> \\<alpha> \\<Longrightarrow> elts A \\<lesssim> elts \\<alpha>\"", "lemma lesspoll_imp_Card_less:\n  assumes \"elts a \\<prec> elts b\" shows \"vcard a < vcard b\"", "lemma Card_Union [simp,intro]:\n  assumes A: \"\\<And>x. x \\<in> A \\<Longrightarrow> Card(x)\" shows \"Card(\\<Squnion>A)\"", "lemma Card_UN: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Card(K x)) ==> Card(Sup (K ` A))\"", "lemma transrec3_0 [simp]: \"transrec3 a b c 0 = a\"", "lemma transrec3_succ [simp]:\n     \"transrec3 a b c (succ i) = b i (transrec3 a b c i)\"", "lemma transrec3_Limit [simp]:\n     \"Limit i \\<Longrightarrow>  transrec3 a b c i = c i (\\<lambda>j \\<in> elts i. transrec3 a b c j)\"", "lemma vsum_commute_eqpoll: \"elts (a\\<Uplus>b) \\<approx> elts (b\\<Uplus>a)\"", "lemma cadd_commute: \"i \\<oplus> j = j \\<oplus> i\"", "lemma sum_assoc_bij:\n  \"bij_betw (\\<lambda>z \\<in> elts ((a\\<Uplus>b)\\<Uplus>c). sum_case(sum_case Inl (\\<lambda>y. Inr(Inl y))) (\\<lambda>y. Inr(Inr y)) z)\n      (elts ((a\\<Uplus>b)\\<Uplus>c)) (elts (a\\<Uplus>(b\\<Uplus>c)))\"", "lemma sum_assoc_eqpoll: \"elts ((a\\<Uplus>b)\\<Uplus>c) \\<approx> elts (a\\<Uplus>(b\\<Uplus>c))\"", "lemma elts_vcard_vsum_eqpoll: \"elts (vcard (i \\<Uplus> j)) \\<approx> Inl ` elts i \\<union> Inr ` elts j\"", "lemma cadd_assoc: \"(i \\<oplus> j) \\<oplus> k = i \\<oplus> (j \\<oplus> k)\"", "lemma vsum_0_eqpoll: \"elts (0\\<Uplus>a) \\<approx> elts a\"", "lemma cadd_0 [simp]: \"Card \\<kappa> \\<Longrightarrow> 0 \\<oplus> \\<kappa> = \\<kappa>\"", "lemma cadd_0_right [simp]: \"Card \\<kappa> \\<Longrightarrow> \\<kappa> \\<oplus> 0 = \\<kappa>\"", "lemma vsum_lepoll_self: \"elts a \\<lesssim> elts (a\\<Uplus>b)\"", "lemma cadd_le_self:\n  assumes \\<kappa>: \"Card \\<kappa>\" shows \"\\<kappa> \\<le> \\<kappa> \\<oplus> a\"", "lemma cadd_le_mono: \"\\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa>' \\<oplus> \\<mu>' \\<le> \\<kappa> \\<oplus> \\<mu>\"", "lemma prod_bij: \"\\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n             \\<Longrightarrow> bij_betw (\\<lambda>(x, y). (f x, g y)) (A \\<times> B) (C \\<times> D)\"", "lemma cmult_commute: \"i \\<otimes> j = j \\<otimes> i\"", "lemma elts_vcard_VSigma_eqpoll: \"elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j\"", "lemma cmult_assoc: \"(i \\<otimes> j) \\<otimes> k = i \\<otimes> (j \\<otimes> k)\"", "lemma cadd_cmult_distrib: \"(i \\<oplus> j) \\<otimes> k = (i \\<otimes> k) \\<oplus> (j \\<otimes> k)\"", "lemma cmult_0 [simp]: \"0 \\<otimes> i = 0\"", "lemma cmult_1 [simp]: assumes \"Card \\<kappa>\" shows \"1 \\<otimes> \\<kappa> = \\<kappa>\"", "lemma cmult_square_le: assumes \"Card \\<kappa>\" shows \"\\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>\"", "lemma cmult_le_self: assumes \"Card \\<kappa>\" \"\\<alpha> \\<noteq> 0\" shows \"\\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>\"", "lemma cmult_le_mono: \"\\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa>' \\<otimes> \\<mu>' \\<le> \\<kappa> \\<otimes> \\<mu>\"", "lemma succ_lepoll_succD: \"elts (succ(m)) \\<lesssim> elts (succ(n)) \\<Longrightarrow> elts m \\<lesssim> elts n\"", "lemma succ_eqpoll_cong: \"elts a \\<approx> elts b \\<Longrightarrow> elts (succ(a)) \\<approx> elts (succ(b))\"", "lemma sum_succ_eqpoll: \"elts (succ a \\<Uplus> b) \\<approx> elts (succ(a\\<Uplus>b))\"", "lemma cadd_succ: \"succ m \\<oplus> n = vcard (succ(m \\<oplus> n))\"", "lemma nat_cadd_eq_add: \"ord_of_nat m \\<oplus> ord_of_nat n = ord_of_nat (m + n)\"", "lemma vcard_disjoint_sup:\n  assumes \"x \\<sqinter> y = 0\" shows \"vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y\"", "lemma InfCard_iff: \"InfCard \\<kappa> \\<longleftrightarrow> Card \\<kappa> \\<and> infinite (elts \\<kappa>)\"", "lemma InfCard_ge_ord_of_nat:\n  assumes \"InfCard \\<kappa>\" shows \"ord_of_nat n \\<le> \\<kappa>\"", "lemma InfCard_not_0[iff]: \"\\<not> InfCard 0\"", "lemma less_vcard_VPow: \"vcard A < vcard (VPow A)\"", "lemma greater_Card:\n  assumes \"Card \\<kappa>\" shows \"\\<kappa> < vcard (VPow \\<kappa>)\"", "lemma\n  assumes \"Card \\<kappa>\"\n  shows Card_csucc [simp]: \"Card (csucc \\<kappa>)\" and less_csucc [simp]: \"\\<kappa> < csucc \\<kappa>\"", "lemma le_csucc:\n  assumes \"Card \\<kappa>\" shows \"\\<kappa> \\<le> csucc \\<kappa>\"", "lemma csucc_le: \"\\<lbrakk>Card \\<mu>; \\<kappa> \\<in> elts \\<mu>\\<rbrakk> \\<Longrightarrow> csucc \\<kappa> \\<le> \\<mu>\"", "lemma finite_csucc: \"a \\<in> elts \\<omega> \\<Longrightarrow> csucc a = succ a\"", "lemma Finite_imp_cardinal_cons [simp]:\n  assumes FA: \"finite A\" and a: \"a \\<notin> A\"\n  shows \"vcard (set (insert a A)) = csucc(vcard (set A))\"", "lemma vcard_finite_set: \"finite A \\<Longrightarrow> vcard (set A) = ord_of_nat (card A)\"", "lemma lt_csucc_iff:\n  assumes \"Ord \\<alpha>\" \"Card \\<kappa>\"\n  shows \"\\<alpha> < csucc \\<kappa> \\<longleftrightarrow> vcard \\<alpha> \\<le> \\<kappa>\"", "lemma Card_lt_csucc_iff: \"\\<lbrakk>Card \\<kappa>'; Card \\<kappa>\\<rbrakk> \\<Longrightarrow> (\\<kappa>' < csucc \\<kappa>) = (\\<kappa>' \\<le> \\<kappa>)\"", "lemma InfCard_csucc: \"InfCard \\<kappa> \\<Longrightarrow> InfCard (csucc \\<kappa>)\"", "lemma InfCard_is_Limit:\n  assumes \"InfCard \\<kappa>\" shows \"Limit \\<kappa>\"", "lemma InfCard_csquare_eq:\n  assumes \"InfCard(\\<kappa>)\" shows \"\\<kappa> \\<otimes> \\<kappa> = \\<kappa>\"", "lemma InfCard_le_cmult_eq:\n  assumes \"InfCard \\<kappa>\" \"\\<mu> \\<le> \\<kappa>\" \"\\<mu> \\<noteq> 0\"\n  shows \"\\<kappa> \\<otimes> \\<mu> = \\<kappa>\"", "lemma InfCard_cmult_eq: \"\\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<otimes> \\<mu> = \\<kappa> \\<squnion> \\<mu>\"", "lemma cmult_succ:\n  \"succ(m) \\<otimes> n = n \\<oplus> (m \\<otimes> n)\"", "lemma cmult_2:\n  assumes \"Card n\" shows \"ord_of_nat 2 \\<otimes> n = n \\<oplus> n\"", "lemma InfCard_cdouble_eq:\n  assumes \"InfCard \\<kappa>\" shows \"\\<kappa> \\<oplus> \\<kappa> = \\<kappa>\"", "lemma InfCard_le_cadd_eq: \"\\<lbrakk>InfCard \\<kappa>; \\<mu> \\<le> \\<kappa>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa>\"", "lemma InfCard_cadd_eq: \"\\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa> \\<squnion> \\<mu>\"", "lemma Card_Aleph [simp, intro]:\n     \"Ord \\<alpha> \\<Longrightarrow> Card(Aleph \\<alpha>)\"", "lemma Aleph_0 [simp]: \"\\<aleph>0 = \\<omega>\"", "lemma Aleph_succ [simp]: \"\\<aleph>(succ x) = csucc (\\<aleph> x)\"", "lemma Aleph_Limit: \"Limit \\<gamma> \\<Longrightarrow> \\<aleph> \\<gamma> = \\<Squnion> (Aleph ` elts \\<gamma>)\"", "lemma mem_Aleph_succ: \"Ord \\<alpha> \\<Longrightarrow> \\<aleph>(\\<alpha>) \\<in> elts (\\<aleph>(succ \\<alpha>))\"", "lemma Aleph_increasing:\n  assumes ab: \"\\<alpha> < \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"Aleph(\\<alpha>) < Aleph(\\<beta>)\"", "lemma countable_iff_le_Aleph0: \"countable (elts A) \\<longleftrightarrow> vcard A \\<le> \\<aleph>0\"", "lemma Ord_\\<omega>1 [simp]: \"Ord \\<omega>1\"", "lemma omega_\\<omega>1 [iff]: \"\\<omega> \\<in> elts \\<omega>1\"", "lemma ord_of_nat_\\<omega>1 [iff]: \"ord_of_nat n \\<in> elts \\<omega>1\"", "lemma countable_iff_less_\\<omega>1:\n  assumes \"Ord \\<alpha>\"\n  shows \"countable (elts \\<alpha>) \\<longleftrightarrow> \\<alpha> < \\<omega>1\"", "lemma less_\\<omega>1_imp_countable:\n  assumes \"\\<alpha> \\<in> elts \\<omega>1\"\n  shows \"countable (elts \\<alpha>)\"", "lemma \\<omega>1_gt0 [simp]: \"\\<omega>1 > 0\"", "lemma \\<omega>1_gt1 [simp]: \"\\<omega>1 > 1\"", "lemma Limit_\\<omega>1 [simp]: \"Limit \\<omega>1\""], "translations": [["", "lemma singleton_eq_iff [iff]: \"set {a} = set {b} \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set {a} = set {b}) = (a = b)", "by simp"], ["", "lemma doubleton_eq_iff: \"set {a,b} = set {c,d} \\<longleftrightarrow> (a=c \\<and> b=d) \\<or> (a=d \\<and> b=c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set {a, b} = set {c, d}) =\n    (a = c \\<and> b = d \\<or> a = d \\<and> b = c)", "by (simp add: Set.doubleton_eq_iff)"], ["", "definition vpair :: \"V \\<Rightarrow> V \\<Rightarrow> V\"\n  where \"vpair a b = set {set {a},set {a,b}}\""], ["", "definition vfst :: \"V \\<Rightarrow> V\"\n  where \"vfst p \\<equiv> THE x. \\<exists>y. p = vpair x y\""], ["", "definition vsnd :: \"V \\<Rightarrow> V\"\n  where \"vsnd p \\<equiv> THE y. \\<exists>x. p = vpair x y\""], ["", "definition vsplit :: \"[[V, V] \\<Rightarrow> 'a, V] \\<Rightarrow> 'a::{}\"  \\<comment> \\<open>for pattern-matching\\<close>\n  where \"vsplit c \\<equiv> \\<lambda>p. c (vfst p) (vsnd p)\""], ["", "nonterminal Vs"], ["", "syntax (ASCII)\n  \"_Tuple\"    :: \"[V, Vs] \\<Rightarrow> V\"              (\"<(_,/ _)>\")\n  \"_hpattern\" :: \"[pttrn, patterns] \\<Rightarrow> pttrn\"   (\"<_,/ _>\")"], ["", "syntax\n  \"\"          :: \"V \\<Rightarrow> Vs\"                    (\"_\")\n  \"_Enum\"     :: \"[V, Vs] \\<Rightarrow> Vs\"             (\"_,/ _\")\n  \"_Tuple\"    :: \"[V, Vs] \\<Rightarrow> V\"              (\"\\<langle>(_,/ _)\\<rangle>\")\n  \"_hpattern\" :: \"[pttrn, patterns] \\<Rightarrow> pttrn\"   (\"\\<langle>_,/ _\\<rangle>\")"], ["", "translations\n  \"<x, y, z>\"    \\<rightleftharpoons> \"<x, <y, z>>\"\n  \"<x, y>\"       \\<rightleftharpoons> \"CONST vpair x y\"\n  \"<x, y, z>\"    \\<rightleftharpoons> \"<x, <y, z>>\"\n  \"\\<lambda><x,y,zs>. b\" \\<rightleftharpoons> \"CONST vsplit(\\<lambda>x <y,zs>. b)\"\n  \"\\<lambda><x,y>. b\"    \\<rightleftharpoons> \"CONST vsplit(\\<lambda>x y. b)\""], ["", "lemma vpair_def': \"vpair a b = set {set {a,a},set {a,b}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, b\\<rangle> = set {set {a, a}, set {a, b}}", "by (simp add: vpair_def)"], ["", "lemma vpair_iff [simp]: \"vpair a b = vpair a' b' \\<longleftrightarrow> a=a' \\<and> b=b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>a, b\\<rangle> = \\<langle>a', b'\\<rangle>) =\n    (a = a' \\<and> b = b')", "unfolding vpair_def' doubleton_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a = a' \\<and> a = a' \\<or> a = a' \\<and> a = a') \\<and>\n     (a = a' \\<and> b = b' \\<or> a = b' \\<and> b = a') \\<or>\n     (a = a' \\<and> a = b' \\<or> a = b' \\<and> a = a') \\<and>\n     (a = a' \\<and> b = a' \\<or> a = a' \\<and> b = a')) =\n    (a = a' \\<and> b = b')", "by auto"], ["", "lemmas vpair_inject = vpair_iff [THEN iffD1, THEN conjE, elim!]"], ["", "lemma vfst_conv [simp]: \"vfst \\<langle>a,b\\<rangle> = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vfst \\<langle>a, b\\<rangle> = a", "by (simp add: vfst_def)"], ["", "lemma vsnd_conv [simp]: \"vsnd \\<langle>a,b\\<rangle> = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vsnd \\<langle>a, b\\<rangle> = b", "by (simp add: vsnd_def)"], ["", "lemma vsplit [simp]: \"vsplit c \\<langle>a,b\\<rangle> = c a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vsplit c \\<langle>a, b\\<rangle> = c a b", "by (simp add: vsplit_def)"], ["", "lemma vpair_neq_fst: \"\\<langle>a,b\\<rangle> \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, b\\<rangle> \\<noteq> a", "by (metis elts_of_set insertI1 mem_not_sym small_upair vpair_def')"], ["", "lemma vpair_neq_snd: \"\\<langle>a,b\\<rangle> \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, b\\<rangle> \\<noteq> b", "by (metis elts_of_set insertI1 mem_not_sym small_upair subsetD subset_insertI vpair_def')"], ["", "lemma vpair_nonzero [simp]: \"\\<langle>x,y\\<rangle> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> \\<noteq> 0", "by (metis elts_0 elts_of_set empty_not_insert small_upair vpair_def)"], ["", "lemma zero_notin_vpair: \"0 \\<notin> elts \\<langle>x,y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> elts \\<langle>x, y\\<rangle>", "by (auto simp: vpair_def)"], ["", "lemma inj_on_vpair [simp]: \"inj_on (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) A", "by (auto simp: inj_on_def)"], ["", "subsection \\<open>Generalized Cartesian product\\<close>"], ["", "definition VSigma :: \"V \\<Rightarrow> (V \\<Rightarrow> V) \\<Rightarrow> V\"\n  where \"VSigma A B \\<equiv> set(\\<Union>x \\<in> elts A. \\<Union>y \\<in> elts (B x). {\\<langle>x,y\\<rangle>})\""], ["", "abbreviation vtimes where \"vtimes A B \\<equiv> VSigma A (\\<lambda>x. B)\""], ["", "definition pairs :: \"V \\<Rightarrow> (V * V)set\"\n  where \"pairs r \\<equiv> {(x,y). \\<langle>x,y\\<rangle> \\<in> elts r} \""], ["", "lemma pairs_iff_elts: \"(x,y) \\<in> pairs z \\<longleftrightarrow> \\<langle>x,y\\<rangle> \\<in> elts z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> pairs z) = (\\<langle>x, y\\<rangle> \\<in> elts z)", "by (simp add: pairs_def)"], ["", "lemma VSigma_iff [simp]: \"\\<langle>a,b\\<rangle> \\<in> elts (VSigma A B) \\<longleftrightarrow> a \\<in> elts A \\<and> b \\<in> elts (B a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>a, b\\<rangle> \\<in> elts (VSigma A B)) =\n    (a \\<in> elts A \\<and> b \\<in> elts (B a))", "by (auto simp: VSigma_def UNION_singleton_eq_range)"], ["", "lemma VSigmaI [intro!]: \"\\<lbrakk> a \\<in> elts A;  b \\<in> elts (B a)\\<rbrakk>  \\<Longrightarrow> \\<langle>a,b\\<rangle> \\<in> elts (VSigma A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> elts A; b \\<in> elts (B a)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>a, b\\<rangle> \\<in> elts (VSigma A B)", "by simp"], ["", "lemmas VSigmaD1 = VSigma_iff [THEN iffD1, THEN conjunct1]"], ["", "lemmas VSigmaD2 = VSigma_iff [THEN iffD1, THEN conjunct2]"], ["", "text \\<open>The general elimination rule\\<close>"], ["", "lemma VSigmaE [elim!]:\n  assumes \"c \\<in> elts (VSigma A B)\"\n  obtains x y where \"x \\<in> elts A\" \"y \\<in> elts (B x)\" \"c=\\<langle>x,y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> elts A; y \\<in> elts (B x);\n         c = \\<langle>x, y\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  c \\<in> elts (VSigma A B)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> elts A; y \\<in> elts (B x);\n         c = \\<langle>x, y\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: VSigma_def split: if_split_asm)"], ["", "lemma VSigmaE2 [elim!]:\n  assumes \"\\<langle>a,b\\<rangle> \\<in> elts (VSigma A B)\" obtains \"a \\<in> elts A\" and \"b \\<in> elts (B a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>a \\<in> elts A; b \\<in> elts (B a)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<langle>a, b\\<rangle> \\<in> elts (VSigma A B)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>a \\<in> elts A; b \\<in> elts (B a)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma VSigma_empty1 [simp]: \"VSigma 0 B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VSigma 0 B = 0", "by auto"], ["", "lemma times_iff [simp]: \"\\<langle>a,b\\<rangle> \\<in> elts (vtimes A B) \\<longleftrightarrow> a \\<in> elts A \\<and> b \\<in> elts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>a, b\\<rangle> \\<in> elts (vtimes A B)) =\n    (a \\<in> elts A \\<and> b \\<in> elts B)", "by simp"], ["", "lemma timesI [intro!]: \"\\<lbrakk>a \\<in> elts A;  b \\<in> elts B\\<rbrakk>  \\<Longrightarrow> \\<langle>a,b\\<rangle> \\<in> elts (vtimes A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> elts A; b \\<in> elts B\\<rbrakk>\n    \\<Longrightarrow> \\<langle>a, b\\<rangle> \\<in> elts (vtimes A B)", "by simp"], ["", "lemma times_empty2 [simp]: \"vtimes A 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vtimes A 0 = 0", "using elts_0"], ["proof (prove)\nusing this:\n  elts 0 = {}\n\ngoal (1 subgoal):\n 1. vtimes A 0 = 0", "by blast"], ["", "lemma times_empty_iff: \"VSigma A B = 0 \\<longleftrightarrow> A=0 \\<or> (\\<forall>x \\<in> elts A. B x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (VSigma A B = 0) = (A = 0 \\<or> (\\<forall>x\\<in>elts A. B x = 0))", "by (metis VSigmaE VSigmaI elts_0 empty_iff trad_foundation)"], ["", "lemma elts_VSigma: \"elts (VSigma a b) = (\\<lambda>(x,y). vpair x y) ` Sigma (elts a) (\\<lambda>x. elts (b x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (VSigma a b) =\n    (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (SIGMA x:elts a. elts (b x))", "by auto"], ["", "lemma small_Times [simp]:\n  assumes \"small A\" \"small B\" \n  shows \"small (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (A \\<times> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (A \\<times> B)", "obtain f a g b where \"inj_on f A\" \"inj_on g B\" and f: \"f ` A = elts a\" and g: \"g ` B = elts b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g a b.\n        \\<lbrakk>inj_on f A; inj_on g B; f ` A = elts a;\n         g ` B = elts b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  small A\n  small B\n\ngoal (1 subgoal):\n 1. (\\<And>f g a b.\n        \\<lbrakk>inj_on f A; inj_on g B; f ` A = elts a;\n         g ` B = elts b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: small_def)"], ["proof (state)\nthis:\n  inj_on f A\n  inj_on g B\n  f ` A = elts a\n  g ` B = elts b\n\ngoal (1 subgoal):\n 1. small (A \\<times> B)", "define h where \"h \\<equiv> \\<lambda>(x,y). \\<langle>f x, g y\\<rangle>\""], ["proof (state)\nthis:\n  h \\<equiv> \\<lambda>(x, y). \\<langle>f x, g y\\<rangle>\n\ngoal (1 subgoal):\n 1. small (A \\<times> B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (A \\<times> B)", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of.\n       inj_on V_of (A \\<times> B) \\<and>\n       V_of ` (A \\<times> B) \\<in> range elts", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ?V_of (A \\<times> B)\n 2. ?V_of ` (A \\<times> B) \\<in> range elts", "show \"inj_on h (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on h (A \\<times> B)", "using \\<open>inj_on f A\\<close> \\<open>inj_on g B\\<close>"], ["proof (prove)\nusing this:\n  inj_on f A\n  inj_on g B\n\ngoal (1 subgoal):\n 1. inj_on h (A \\<times> B)", "by (simp add: h_def inj_on_def)"], ["proof (state)\nthis:\n  inj_on h (A \\<times> B)\n\ngoal (1 subgoal):\n 1. h ` (A \\<times> B) \\<in> range elts", "have \"h ` (A \\<times> B) = elts (vtimes a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` (A \\<times> B) = elts (vtimes a b)", "using f g"], ["proof (prove)\nusing this:\n  f ` A = elts a\n  g ` B = elts b\n\ngoal (1 subgoal):\n 1. h ` (A \\<times> B) = elts (vtimes a b)", "by (fastforce simp: h_def image_iff split: prod.split)"], ["proof (state)\nthis:\n  h ` (A \\<times> B) = elts (vtimes a b)\n\ngoal (1 subgoal):\n 1. h ` (A \\<times> B) \\<in> range elts", "then"], ["proof (chain)\npicking this:\n  h ` (A \\<times> B) = elts (vtimes a b)", "show \"h ` (A \\<times> B) \\<in> range elts\""], ["proof (prove)\nusing this:\n  h ` (A \\<times> B) = elts (vtimes a b)\n\ngoal (1 subgoal):\n 1. h ` (A \\<times> B) \\<in> range elts", "by blast"], ["proof (state)\nthis:\n  h ` (A \\<times> B) \\<in> range elts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small (A \\<times> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Disjoint Sum\\<close>"], ["", "definition vsum :: \"V \\<Rightarrow> V \\<Rightarrow> V\" (infixl \"\\<Uplus>\" 65) where\n \"A \\<Uplus> B \\<equiv> (VSigma (set {0}) (\\<lambda>x. A)) \\<squnion> (VSigma (set {1}) (\\<lambda>x. B))\""], ["", "definition Inl :: \"V\\<Rightarrow>V\" where\n     \"Inl a \\<equiv> \\<langle>0,a\\<rangle>\""], ["", "definition Inr :: \"V\\<Rightarrow>V\" where\n     \"Inr b \\<equiv> \\<langle>1,b\\<rangle>\""], ["", "lemmas sum_defs = vsum_def Inl_def Inr_def"], ["", "lemma Inl_nonzero [simp]:\"Inl x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_Cardinals.Inl x \\<noteq> 0", "by (metis Inl_def vpair_nonzero)"], ["", "lemma Inr_nonzero [simp]:\"Inr x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_Cardinals.Inr x \\<noteq> 0", "by (metis Inr_def vpair_nonzero)"], ["", "subsubsection\\<open>Equivalences for the injections and an elimination rule\\<close>"], ["", "lemma Inl_in_sum_iff [iff]: \"Inl a \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> a \\<in> elts A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inl a \\<in> elts (A \\<Uplus> B)) = (a \\<in> elts A)", "by (auto simp: sum_defs)"], ["", "lemma Inr_in_sum_iff [iff]: \"Inr b \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> b \\<in> elts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inr b \\<in> elts (A \\<Uplus> B)) = (b \\<in> elts B)", "by (auto simp: sum_defs)"], ["", "lemma sumE [elim!]:\n  assumes u: \"u \\<in> elts (A \\<Uplus> B)\"\n  obtains x where \"x \\<in> elts A\" \"u=Inl x\" | y where \"y \\<in> elts B\" \"u=Inr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> elts A; u = ZFC_Cardinals.Inl x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>y.\n        \\<lbrakk>y \\<in> elts B; u = ZFC_Cardinals.Inr y\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using u"], ["proof (prove)\nusing this:\n  u \\<in> elts (A \\<Uplus> B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> elts A; u = ZFC_Cardinals.Inl x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>y.\n        \\<lbrakk>y \\<in> elts B; u = ZFC_Cardinals.Inr y\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: sum_defs)"], ["", "subsubsection \\<open>Injection and freeness equivalences, for rewriting\\<close>"], ["", "lemma Inl_iff [iff]: \"Inl a=Inl b \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inl a = ZFC_Cardinals.Inl b) = (a = b)", "by (simp add: sum_defs)"], ["", "lemma Inr_iff [iff]: \"Inr a=Inr b \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inr a = ZFC_Cardinals.Inr b) = (a = b)", "by (simp add: sum_defs)"], ["", "lemma inj_on_Inl [simp]: \"inj_on Inl A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ZFC_Cardinals.Inl A", "by (simp add: inj_on_def)"], ["", "lemma inj_on_Inr [simp]: \"inj_on Inr A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ZFC_Cardinals.Inr A", "by (simp add: inj_on_def)"], ["", "lemma Inl_Inr_iff [iff]: \"Inl a=Inr b \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inl a = ZFC_Cardinals.Inr b) = False", "by (simp add: sum_defs)"], ["", "lemma Inr_Inl_iff [iff]: \"Inr b=Inl a \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inr b = ZFC_Cardinals.Inl a) = False", "by (simp add: sum_defs)"], ["", "lemma sum_empty [simp]: \"0 \\<Uplus> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<Uplus> 0 = 0", "by auto"], ["", "lemma elts_vsum: \"elts (a \\<Uplus> b) = Inl ` (elts a) \\<union> Inr ` (elts b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) =\n    ZFC_Cardinals.Inl ` elts a \\<union> ZFC_Cardinals.Inr ` elts b", "by auto"], ["", "lemma sum_iff: \"u \\<in> elts (A \\<Uplus> B) \\<longleftrightarrow> (\\<exists>x. x \\<in> elts A \\<and> u=Inl x) \\<or> (\\<exists>y. y \\<in> elts B \\<and> u=Inr y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> elts (A \\<Uplus> B)) =\n    ((\\<exists>x. x \\<in> elts A \\<and> u = ZFC_Cardinals.Inl x) \\<or>\n     (\\<exists>y. y \\<in> elts B \\<and> u = ZFC_Cardinals.Inr y))", "by blast"], ["", "lemma sum_subset_iff: \"A\\<Uplus>B \\<le> C\\<Uplus>D \\<longleftrightarrow> A\\<le>C \\<and> B\\<le>D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Uplus> B \\<le> C \\<Uplus> D) = (A \\<le> C \\<and> B \\<le> D)", "by (auto simp: less_eq_V_def)"], ["", "lemma sum_equal_iff:\n  fixes A :: V shows \"A\\<Uplus>B = C\\<Uplus>D \\<longleftrightarrow> A=C \\<and> B=D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<Uplus> B = C \\<Uplus> D) = (A = C \\<and> B = D)", "by (simp add: eq_iff sum_subset_iff)"], ["", "definition is_sum :: \"V \\<Rightarrow> bool\"\n  where \"is_sum z = (\\<exists>x. z = Inl x \\<or> z = Inr x)\""], ["", "definition sum_case  :: \"(V \\<Rightarrow> 'a) \\<Rightarrow> (V \\<Rightarrow> 'a) \\<Rightarrow> V \\<Rightarrow> 'a\"\n  where\n  \"sum_case f g a \\<equiv>\n    THE z. (\\<forall>x. a = Inl x \\<longrightarrow> z = f x) \\<and> (\\<forall>y. a = Inr y \\<longrightarrow> z = g y) \\<and> (\\<not> is_sum a \\<longrightarrow> z = undefined)\""], ["", "lemma sum_case_Inl [simp]: \"sum_case f g (Inl x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_case f g (ZFC_Cardinals.Inl x) = f x", "by (simp add: sum_case_def is_sum_def)"], ["", "lemma sum_case_Inr [simp]: \"sum_case f g (Inr y) = g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_case f g (ZFC_Cardinals.Inr y) = g y", "by (simp add: sum_case_def is_sum_def)"], ["", "lemma sum_case_non [simp]: \"\\<not> is_sum a \\<Longrightarrow> sum_case f g a = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_sum a \\<Longrightarrow> sum_case f g a = undefined", "by (simp add: sum_case_def is_sum_def)"], ["", "lemma is_sum_cases: \"(\\<exists>x. z = Inl x \\<or> z = Inr x) \\<or> \\<not> is_sum z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        z = ZFC_Cardinals.Inl x \\<or> z = ZFC_Cardinals.Inr x) \\<or>\n    \\<not> is_sum z", "by (auto simp: is_sum_def)"], ["", "lemma sum_case_split:\n  \"P (sum_case f g a) \\<longleftrightarrow> (\\<forall>x. a = Inl x \\<longrightarrow> P(f x)) \\<and> (\\<forall>y. a = Inr y \\<longrightarrow> P(g y)) \\<and> (\\<not> is_sum a \\<longrightarrow> P undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (sum_case f g a) =\n    ((\\<forall>x. a = ZFC_Cardinals.Inl x \\<longrightarrow> P (f x)) \\<and>\n     (\\<forall>y. a = ZFC_Cardinals.Inr y \\<longrightarrow> P (g y)) \\<and>\n     (\\<not> is_sum a \\<longrightarrow> P undefined))", "by (cases \"is_sum a\") (auto simp: is_sum_def)"], ["", "lemma sum_case_split_asm:\n  \"P (sum_case f g a) \\<longleftrightarrow> \\<not> ((\\<exists>x. a = Inl x \\<and> \\<not> P(f x)) \\<or> (\\<exists>y. a = Inr y \\<and> \\<not> P(g y)) \\<or> (\\<not> is_sum a \\<and> \\<not> P undefined))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (sum_case f g a) =\n    (\\<not> ((\\<exists>x.\n                 a = ZFC_Cardinals.Inl x \\<and> \\<not> P (f x)) \\<or>\n             (\\<exists>y.\n                 a = ZFC_Cardinals.Inr y \\<and> \\<not> P (g y)) \\<or>\n             \\<not> is_sum a \\<and> \\<not> P undefined))", "by (auto simp: sum_case_split)"], ["", "subsubsection \\<open>Applications of disjoint sums and pairs: general union theorems for small sets\\<close>"], ["", "lemma small_Un:\n  assumes X: \"small X\" and Y: \"small Y\"\n  shows \"small (X \\<union> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X \\<union> Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (X \\<union> Y)", "obtain f g :: \"'a\\<Rightarrow>V\" where f: \"inj_on f X\" and g: \"inj_on g Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>inj_on f X; inj_on g Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms small_def)"], ["proof (state)\nthis:\n  inj_on f X\n  inj_on g Y\n\ngoal (1 subgoal):\n 1. small (X \\<union> Y)", "define h where \"h \\<equiv> \\<lambda>z. if z \\<in> X then Inl (f z) else Inr (g z)\""], ["proof (state)\nthis:\n  h \\<equiv>\n  \\<lambda>z.\n     if z \\<in> X then ZFC_Cardinals.Inl (f z) else ZFC_Cardinals.Inr (g z)\n\ngoal (1 subgoal):\n 1. small (X \\<union> Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (X \\<union> Y)", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of.\n       inj_on V_of (X \\<union> Y) \\<and>\n       V_of ` (X \\<union> Y) \\<in> range elts", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ?V_of (X \\<union> Y)\n 2. ?V_of ` (X \\<union> Y) \\<in> range elts", "show \"inj_on h (X \\<union> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on h (X \\<union> Y)", "using f g"], ["proof (prove)\nusing this:\n  inj_on f X\n  inj_on g Y\n\ngoal (1 subgoal):\n 1. inj_on h (X \\<union> Y)", "by (auto simp add: inj_on_def h_def)"], ["proof (state)\nthis:\n  inj_on h (X \\<union> Y)\n\ngoal (1 subgoal):\n 1. h ` (X \\<union> Y) \\<in> range elts", "show \"h ` (X \\<union> Y) \\<in> range elts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h ` (X \\<union> Y) \\<in> range elts", "by (metis X Y image_Un replacement small_iff_range small_sup_iff)"], ["proof (state)\nthis:\n  h ` (X \\<union> Y) \\<in> range elts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small (X \\<union> Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_UN [simp,intro]:\n  assumes X: \"small X\" and B: \"\\<And>x. x \\<in> X \\<Longrightarrow> small (B x)\"\n  shows \"small (\\<Union>x\\<in>X. B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "obtain f :: \"'a\\<Rightarrow>V\" where f: \"inj_on f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. inj_on f X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (meson assms small_def)"], ["proof (state)\nthis:\n  inj_on f X\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "have \"\\<exists>g. inj_on g (B x) \\<and> g ` (B x) \\<in> range elts\" if \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. inj_on g (B x) \\<and> g ` B x \\<in> range elts", "using B small_def that"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> small (B ?x)\n  small ?X \\<equiv>\n  \\<exists>V_of. inj_on V_of ?X \\<and> V_of ` ?X \\<in> range elts\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>g. inj_on g (B x) \\<and> g ` B x \\<in> range elts", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  \\<exists>g. inj_on g (B ?x) \\<and> g ` B ?x \\<in> range elts\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow>\n  \\<exists>g. inj_on g (B ?x) \\<and> g ` B ?x \\<in> range elts", "obtain g::\"'a \\<Rightarrow> 'b \\<Rightarrow> V\" where g: \"\\<And>x. x \\<in> X \\<Longrightarrow> inj_on (g x) (B x)\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow>\n  \\<exists>g. inj_on g (B ?x) \\<and> g ` B ?x \\<in> range elts\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        (\\<And>x.\n            x \\<in> X \\<Longrightarrow>\n            inj_on (g x) (B x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> inj_on (g ?x) (B ?x)\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "define \\<phi> where \"\\<phi> \\<equiv> \\<lambda>y. @x. x \\<in> X \\<and> y \\<in> B x\""], ["proof (state)\nthis:\n  \\<phi> \\<equiv> \\<lambda>y. SOME x. x \\<in> X \\<and> y \\<in> B x\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "have \\<phi>: \"\\<phi> y \\<in> X \\<and> y \\<in> B (\\<phi> y)\" if \"y \\<in> (\\<Union>x\\<in>X. B x)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> y \\<in> X \\<and> y \\<in> B (\\<phi> y)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> X \\<and> y \\<in> B x) \\<in> X \\<and>\n    y \\<in> B (SOME x. x \\<in> X \\<and> y \\<in> B x)", "by (metis (mono_tags, lifting) UN_E someI that)"], ["proof (state)\nthis:\n  ?y \\<in> \\<Union> (B ` X) \\<Longrightarrow>\n  \\<phi> ?y \\<in> X \\<and> ?y \\<in> B (\\<phi> ?y)\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "define h where \"h \\<equiv> \\<lambda>y. \\<langle>f (\\<phi> y), g (\\<phi> y) y\\<rangle>\""], ["proof (state)\nthis:\n  h \\<equiv> \\<lambda>y. \\<langle>f (\\<phi> y), g (\\<phi> y) y\\<rangle>\n\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> (B ` X))", "unfolding small_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V_of.\n       inj_on V_of (\\<Union> (B ` X)) \\<and>\n       V_of ` \\<Union> (B ` X) \\<in> range elts", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on ?V_of (\\<Union> (B ` X))\n 2. ?V_of ` \\<Union> (B ` X) \\<in> range elts", "show \"inj_on h (\\<Union> (B ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on h (\\<Union> (B ` X))", "using f g \\<phi>"], ["proof (prove)\nusing this:\n  inj_on f X\n  ?x \\<in> X \\<Longrightarrow> inj_on (g ?x) (B ?x)\n  ?y \\<in> \\<Union> (B ` X) \\<Longrightarrow>\n  \\<phi> ?y \\<in> X \\<and> ?y \\<in> B (\\<phi> ?y)\n\ngoal (1 subgoal):\n 1. inj_on h (\\<Union> (B ` X))", "unfolding h_def inj_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. \\<forall>y\\<in>X. f x = f y \\<longrightarrow> x = y\n  ?x \\<in> X \\<Longrightarrow>\n  \\<forall>x\\<in>B ?x.\n     \\<forall>y\\<in>B ?x. g ?x x = g ?x y \\<longrightarrow> x = y\n  ?y \\<in> \\<Union> (B ` X) \\<Longrightarrow>\n  \\<phi> ?y \\<in> X \\<and> ?y \\<in> B (\\<phi> ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (B ` X).\n       \\<forall>y\\<in>\\<Union> (B ` X).\n          \\<langle>f (\\<phi> x), g (\\<phi> x) x\\<rangle> =\n          \\<langle>f (\\<phi> y), g (\\<phi> y) y\\<rangle> \\<longrightarrow>\n          x = y", "by (metis vpair_inject)"], ["proof (state)\nthis:\n  inj_on h (\\<Union> (B ` X))\n\ngoal (1 subgoal):\n 1. h ` \\<Union> (B ` X) \\<in> range elts", "have \"small (h ` \\<Union> (B ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (h ` \\<Union> (B ` X))", "by (simp add: B X image_UN)"], ["proof (state)\nthis:\n  small (h ` \\<Union> (B ` X))\n\ngoal (1 subgoal):\n 1. h ` \\<Union> (B ` X) \\<in> range elts", "then"], ["proof (chain)\npicking this:\n  small (h ` \\<Union> (B ` X))", "show \"h ` \\<Union> (B ` X) \\<in> range elts\""], ["proof (prove)\nusing this:\n  small (h ` \\<Union> (B ` X))\n\ngoal (1 subgoal):\n 1. h ` \\<Union> (B ` X) \\<in> range elts", "using small_iff_range"], ["proof (prove)\nusing this:\n  small (h ` \\<Union> (B ` X))\n  small ?X = (?X \\<in> range elts)\n\ngoal (1 subgoal):\n 1. h ` \\<Union> (B ` X) \\<in> range elts", "by blast"], ["proof (state)\nthis:\n  h ` \\<Union> (B ` X) \\<in> range elts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  small (\\<Union> (B ` X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_Union [simp,intro]:\n  assumes \"\\<A> \\<subseteq> Collect small\" \"small \\<A>\"\n  shows \"small (\\<Union> \\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small (\\<Union> \\<A>)", "using small_UN [of \\<A> \"\\<lambda>x. x\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>small \\<A>;\n   \\<And>x. x \\<in> \\<A> \\<Longrightarrow> small x\\<rbrakk>\n  \\<Longrightarrow> small (\\<Union>x\\<in>\\<A>. x)\n  \\<A> \\<subseteq> Collect small\n  small \\<A>\n\ngoal (1 subgoal):\n 1. small (\\<Union> \\<A>)", "by (simp add: subset_iff)"], ["", "subsection\\<open>Generalised function space and lambda\\<close>"], ["", "definition VLambda :: \"V \\<Rightarrow> (V \\<Rightarrow> V) \\<Rightarrow> V\"\n  where \"VLambda A b \\<equiv> set ((\\<lambda>x. \\<langle>x,b x\\<rangle>) ` elts A)\""], ["", "definition app :: \"[V,V] \\<Rightarrow> V\"\n  where \"app f x \\<equiv> THE y. \\<langle>x,y\\<rangle> \\<in> elts f\""], ["", "lemma beta [simp]:\n  assumes \"x \\<in> elts A\"\n  shows \"app (VLambda A b) x = b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app (VLambda A b) x = b x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> elts A\n\ngoal (1 subgoal):\n 1. app (VLambda A b) x = b x", "by (auto simp: VLambda_def app_def)"], ["", "definition VPi :: \"V \\<Rightarrow> (V \\<Rightarrow> V) \\<Rightarrow> V\"\n  where \"VPi A B \\<equiv> set {f \\<in> elts (VPow(VSigma A B)). elts A \\<le> Domain (pairs f) \\<and> single_valued (pairs f)}\""], ["", "lemma VPi_I:\n  assumes \"\\<And>x. x \\<in> elts A \\<Longrightarrow> b x \\<in> elts (B x)\"\n  shows \"VLambda A b \\<in> elts (VPi A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VLambda A b \\<in> elts (VPi A B)", "proof (clarsimp simp: VPi_def, intro conjI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    VLambda A b \\<le> VSigma A B\n 2. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    elts A \\<subseteq> Domain (pairs (VLambda A b))\n 3. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    single_valued (pairs (VLambda A b))\n 4. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}", "show \"VLambda A b \\<le> VSigma A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VLambda A b \\<le> VSigma A B", "by (auto simp: assms VLambda_def split: if_split_asm)"], ["proof (state)\nthis:\n  VLambda A b \\<le> VSigma A B\n\ngoal (3 subgoals):\n 1. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    elts A \\<subseteq> Domain (pairs (VLambda A b))\n 2. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    single_valued (pairs (VLambda A b))\n 3. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}", "show \"elts A \\<subseteq> Domain (pairs (VLambda A b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts A \\<subseteq> Domain (pairs (VLambda A b))", "by (force simp: VLambda_def pairs_iff_elts)"], ["proof (state)\nthis:\n  elts A \\<subseteq> Domain (pairs (VLambda A b))\n\ngoal (2 subgoals):\n 1. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and>\n         single_valued (pairs f)} \\<Longrightarrow>\n    single_valued (pairs (VLambda A b))\n 2. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}", "show \"single_valued (pairs (VLambda A b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (pairs (VLambda A b))", "by (auto simp: VLambda_def single_valued_def pairs_iff_elts)"], ["proof (state)\nthis:\n  single_valued (pairs (VLambda A b))\n\ngoal (1 subgoal):\n 1. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}", "show \"small {f. f \\<le> VSigma A B \\<and> elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small\n     {f. f \\<le> VSigma A B \\<and>\n         elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}", "by (metis (mono_tags, lifting) down VPow_iff mem_Collect_eq subsetI)"], ["proof (state)\nthis:\n  small\n   {f. f \\<le> VSigma A B \\<and>\n       elts A \\<subseteq> Domain (pairs f) \\<and> single_valued (pairs f)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apply_pair:\n  assumes f: \"f \\<in> elts (VPi A B)\" and x: \"x \\<in> elts A\"\n  shows \"\\<langle>x, app f x\\<rangle> \\<in> elts f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, app f x\\<rangle> \\<in> elts f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>x, app f x\\<rangle> \\<in> elts f", "have \"x \\<in> Domain (pairs f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Domain (pairs f)", "by (metis (no_types, lifting) VPi_def assms elts_of_set empty_iff mem_Collect_eq subsetD)"], ["proof (state)\nthis:\n  x \\<in> Domain (pairs f)\n\ngoal (1 subgoal):\n 1. \\<langle>x, app f x\\<rangle> \\<in> elts f", "then"], ["proof (chain)\npicking this:\n  x \\<in> Domain (pairs f)", "obtain y where y: \"\\<langle>x,y\\<rangle> \\<in> elts f\""], ["proof (prove)\nusing this:\n  x \\<in> Domain (pairs f)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<langle>x, y\\<rangle> \\<in> elts f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pairs_iff_elts"], ["proof (prove)\nusing this:\n  x \\<in> Domain (pairs f)\n  ((?x, ?y) \\<in> pairs ?z) = (\\<langle>?x, ?y\\<rangle> \\<in> elts ?z)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<langle>x, y\\<rangle> \\<in> elts f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<langle>x, y\\<rangle> \\<in> elts f\n\ngoal (1 subgoal):\n 1. \\<langle>x, app f x\\<rangle> \\<in> elts f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, app f x\\<rangle> \\<in> elts f", "unfolding app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, THE y. \\<langle>x, y\\<rangle> \\<in> elts f\\<rangle>\n    \\<in> elts f", "proof (rule theI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>x, ?a\\<rangle> \\<in> elts f\n 2. \\<And>xa. \\<langle>x, xa\\<rangle> \\<in> elts f \\<Longrightarrow> xa = ?a", "show \"\\<langle>x, y\\<rangle> \\<in> elts f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> \\<in> elts f", "by (rule y)"], ["proof (state)\nthis:\n  \\<langle>x, y\\<rangle> \\<in> elts f\n\ngoal (1 subgoal):\n 1. \\<And>xa. \\<langle>x, xa\\<rangle> \\<in> elts f \\<Longrightarrow> xa = y", "show \"z = y\" if \"\\<langle>x, z\\<rangle> \\<in> elts f\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z = y", "using f"], ["proof (prove)\nusing this:\n  f \\<in> elts (VPi A B)\n\ngoal (1 subgoal):\n 1. z = y", "unfolding VPi_def"], ["proof (prove)\nusing this:\n  f \\<in> elts\n           (set {f \\<in> elts (VPow (VSigma A B)).\n                 elts A \\<subseteq> Domain (pairs f) \\<and>\n                 single_valued (pairs f)})\n\ngoal (1 subgoal):\n 1. z = y", "by (metis (mono_tags, lifting) that elts_of_set empty_iff mem_Collect_eq pairs_iff_elts single_valued_def y)"], ["proof (state)\nthis:\n  \\<langle>x, ?z\\<rangle> \\<in> elts f \\<Longrightarrow> ?z = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>x, app f x\\<rangle> \\<in> elts f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma VPi_D:\n  assumes f: \"f \\<in> elts (VPi A B)\" and x: \"x \\<in> elts A\"\n  shows \"app f x \\<in> elts (B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. app f x \\<in> elts (B x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. app f x \\<in> elts (B x)", "have \"f \\<le> VSigma A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> VSigma A B", "by (metis (no_types, lifting) VPi_def elts_of_set empty_iff f VPow_iff mem_Collect_eq)"], ["proof (state)\nthis:\n  f \\<le> VSigma A B\n\ngoal (1 subgoal):\n 1. app f x \\<in> elts (B x)", "then"], ["proof (chain)\npicking this:\n  f \\<le> VSigma A B", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<le> VSigma A B\n\ngoal (1 subgoal):\n 1. app f x \\<in> elts (B x)", "using apply_pair [OF assms]"], ["proof (prove)\nusing this:\n  f \\<le> VSigma A B\n  \\<langle>x, app f x\\<rangle> \\<in> elts f\n\ngoal (1 subgoal):\n 1. app f x \\<in> elts (B x)", "by blast"], ["proof (state)\nthis:\n  app f x \\<in> elts (B x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma VPi_memberD:\n  assumes f: \"f \\<in> elts (VPi A B)\" and p: \"p \\<in> elts f\"\n  obtains x where \"x \\<in> elts A\" \"p = \\<langle>x, app f x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> elts A; p = \\<langle>x, app f x\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> elts A; p = \\<langle>x, app f x\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"f \\<le> VSigma A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> VSigma A B", "by (metis (no_types, lifting) VPi_def elts_of_set empty_iff f VPow_iff mem_Collect_eq)"], ["proof (state)\nthis:\n  f \\<le> VSigma A B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> elts A; p = \\<langle>x, app f x\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  f \\<le> VSigma A B", "obtain x y where \"p = \\<langle>x,y\\<rangle>\" \"x \\<in> elts A\""], ["proof (prove)\nusing this:\n  f \\<le> VSigma A B\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>p = \\<langle>x, y\\<rangle>; x \\<in> elts A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using p"], ["proof (prove)\nusing this:\n  f \\<le> VSigma A B\n  p \\<in> elts f\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>p = \\<langle>x, y\\<rangle>; x \\<in> elts A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p = \\<langle>x, y\\<rangle>\n  x \\<in> elts A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> elts A; p = \\<langle>x, app f x\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = \\<langle>x, y\\<rangle>\n  x \\<in> elts A", "have \"y = app f x\""], ["proof (prove)\nusing this:\n  p = \\<langle>x, y\\<rangle>\n  x \\<in> elts A\n\ngoal (1 subgoal):\n 1. y = app f x", "by (metis (no_types, lifting) VPi_def apply_pair elts_of_set equals0D f mem_Collect_eq p pairs_iff_elts single_valuedD)"], ["proof (state)\nthis:\n  y = app f x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> elts A; p = \\<langle>x, app f x\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  y = app f x", "show thesis"], ["proof (prove)\nusing this:\n  y = app f x\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>p = \\<langle>x, y\\<rangle>\\<close> \\<open>x \\<in> elts A\\<close> that"], ["proof (prove)\nusing this:\n  y = app f x\n  p = \\<langle>x, y\\<rangle>\n  x \\<in> elts A\n  \\<lbrakk>?x \\<in> elts A; p = \\<langle>?x, app f ?x\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_ext:\n  assumes \"f \\<in> elts (VPi A B)\" \"g \\<in> elts (VPi A B)\" \"\\<And>x. x \\<in> elts A \\<Longrightarrow> app f x = app g x\"\n  shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "by (metis VPi_memberD V_equalityI apply_pair assms)"], ["", "lemma eta[simp]:\n  assumes \"f \\<in> elts (VPi A B)\"\n  shows \"VLambda A ((app)f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VLambda A (app f) = f", "proof (rule fun_ext [OF _ assms])"], ["proof (state)\ngoal (2 subgoals):\n 1. VLambda A (app f) \\<in> elts (VPi A B)\n 2. \\<And>x.\n       x \\<in> elts A \\<Longrightarrow> app (VLambda A (app f)) x = app f x", "show \"VLambda A (app f) \\<in> elts (VPi A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VLambda A (app f) \\<in> elts (VPi A B)", "using VPi_D VPi_I assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> elts (VPi ?A ?B); ?x \\<in> elts ?A\\<rbrakk>\n  \\<Longrightarrow> app ?f ?x \\<in> elts (?B ?x)\n  (\\<And>x.\n      x \\<in> elts ?A \\<Longrightarrow>\n      ?b x \\<in> elts (?B x)) \\<Longrightarrow>\n  VLambda ?A ?b \\<in> elts (VPi ?A ?B)\n  f \\<in> elts (VPi A B)\n\ngoal (1 subgoal):\n 1. VLambda A (app f) \\<in> elts (VPi A B)", "by auto"], ["proof (state)\nthis:\n  VLambda A (app f) \\<in> elts (VPi A B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> elts A \\<Longrightarrow> app (VLambda A (app f)) x = app f x", "qed auto"], ["", "lemma fst_pairs_VLambda: \"fst ` pairs (VLambda A f) = elts A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` pairs (VLambda A f) = elts A", "by (force simp: VLambda_def pairs_def)"], ["", "lemma snd_pairs_VLambda: \"snd ` pairs (VLambda A f) = f ` elts A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` pairs (VLambda A f) = f ` elts A", "by (force simp: VLambda_def pairs_def)"], ["", "lemma VLambda_eq_D1: \"VLambda A f = VLambda B g \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VLambda A f = VLambda B g \\<Longrightarrow> A = B", "by (metis ZFC_in_HOL.ext fst_pairs_VLambda)"], ["", "lemma VLambda_eq_D2: \"\\<lbrakk>VLambda A f = VLambda A g; x \\<in> elts A\\<rbrakk> \\<Longrightarrow> f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>VLambda A f = VLambda A g; x \\<in> elts A\\<rbrakk>\n    \\<Longrightarrow> f x = g x", "by (metis beta)"], ["", "subsection\\<open>Transitive closure of a set\\<close>"], ["", "definition TC :: \"V\\<Rightarrow>V\"\n  where \"TC \\<equiv> transrec (\\<lambda>f x. x \\<squnion> \\<Squnion> (f ` elts x))\""], ["", "lemma TC: \"TC a = a \\<squnion> \\<Squnion> (TC ` elts a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC a = a \\<squnion> \\<Squnion> (TC ` elts a)", "by (metis (no_types, lifting) SUP_cong TC_def restrict_apply' transrec)"], ["", "lemma TC_0 [simp]: \"TC 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC 0 = 0", "by (metis TC ZFC_in_HOL.Sup_empty elts_0 image_is_empty sup_V_0_left)"], ["", "lemma arg_subset_TC: \"a \\<le> TC a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> TC a", "by (metis (no_types) TC sup_ge1)"], ["", "lemma Transset_TC: \"Transset(TC a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (TC a)", "proof (induction a rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Transset (TC y)) \\<Longrightarrow>\n       Transset (TC x)", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> Transset (TC ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Transset (TC y)) \\<Longrightarrow>\n       Transset (TC x)", "have 1: \"v \\<in> elts (TC x)\" if \"v \\<in> elts u\" \"u \\<in> elts x\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> elts (TC x)", "using that"], ["proof (prove)\nusing this:\n  v \\<in> elts u\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. v \\<in> elts (TC x)", "unfolding TC [of x]"], ["proof (prove)\nusing this:\n  v \\<in> elts u\n  u \\<in> elts x\n\ngoal (1 subgoal):\n 1. v \\<in> elts (x \\<squnion> \\<Squnion> (TC ` elts x))", "using arg_subset_TC"], ["proof (prove)\nusing this:\n  v \\<in> elts u\n  u \\<in> elts x\n  ?a \\<le> TC ?a\n\ngoal (1 subgoal):\n 1. v \\<in> elts (x \\<squnion> \\<Squnion> (TC ` elts x))", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> elts ?u; ?u \\<in> elts x\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> elts (TC x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Transset (TC y)) \\<Longrightarrow>\n       Transset (TC x)", "have 2: \"v \\<in> elts (TC x)\" if \"v \\<in> elts u\" \"\\<exists>x\\<in>elts x. u \\<in> elts (TC x)\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> elts (TC x)", "using that step"], ["proof (prove)\nusing this:\n  v \\<in> elts u\n  \\<exists>x\\<in>elts x. u \\<in> elts (TC x)\n  ?y \\<in> elts x \\<Longrightarrow> Transset (TC ?y)\n\ngoal (1 subgoal):\n 1. v \\<in> elts (TC x)", "unfolding TC [of x] Transset_def"], ["proof (prove)\nusing this:\n  v \\<in> elts u\n  \\<exists>x\\<in>elts x. u \\<in> elts (TC x)\n  ?y \\<in> elts x \\<Longrightarrow>\n  \\<forall>y\\<in>elts (TC ?y). y \\<le> TC ?y\n\ngoal (1 subgoal):\n 1. v \\<in> elts (x \\<squnion> \\<Squnion> (TC ` elts x))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?v \\<in> elts ?u;\n   \\<exists>x\\<in>elts x. ?u \\<in> elts (TC x)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> elts (TC x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Transset (TC y)) \\<Longrightarrow>\n       Transset (TC x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (TC x)", "unfolding Transset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>elts (TC x). y \\<le> TC x", "by (subst TC) (force intro: 1 2)"], ["proof (state)\nthis:\n  Transset (TC x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TC_least: \"\\<lbrakk>Transset x;  a\\<le>x\\<rbrakk> \\<Longrightarrow> TC a \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Transset x; a \\<le> x\\<rbrakk> \\<Longrightarrow> TC a \\<le> x", "proof (induction a rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; Transset x; y \\<le> x\\<rbrakk>\n                   \\<Longrightarrow> TC y \\<le> x;\n        Transset x; xa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> TC xa \\<le> x", "case (step y)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts y; Transset x; ?y \\<le> x\\<rbrakk>\n  \\<Longrightarrow> TC ?y \\<le> x\n  Transset x\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y \\<in> elts xa; Transset x; y \\<le> x\\<rbrakk>\n                   \\<Longrightarrow> TC y \\<le> x;\n        Transset x; xa \\<le> x\\<rbrakk>\n       \\<Longrightarrow> TC xa \\<le> x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. TC y \\<le> x", "proof (cases \"y=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> TC y \\<le> x\n 2. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "case True"], ["proof (state)\nthis:\n  y = 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow> TC y \\<le> x\n 2. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "then"], ["proof (chain)\npicking this:\n  y = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  y = 0\n\ngoal (1 subgoal):\n 1. TC y \\<le> x", "by auto"], ["proof (state)\nthis:\n  TC y \\<le> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "have \"\\<Squnion> (TC ` elts y) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` elts y) \\<le> x", "proof (rule cSup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. TC ` elts y \\<noteq> {}\n 2. \\<And>xa. xa \\<in> TC ` elts y \\<Longrightarrow> xa \\<le> x", "show \"TC ` elts y \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC ` elts y \\<noteq> {}", "using False"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. TC ` elts y \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  TC ` elts y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> TC ` elts y \\<Longrightarrow> xa \\<le> x", "show \"z \\<le> x\" if \"z \\<in> TC ` elts y\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> x", "using that"], ["proof (prove)\nusing this:\n  z \\<in> TC ` elts y\n\ngoal (1 subgoal):\n 1. z \\<le> x", "by (metis Transset_def image_iff step.IH step.prems vsubsetD)"], ["proof (state)\nthis:\n  ?z \\<in> TC ` elts y \\<Longrightarrow> ?z \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (TC ` elts y) \\<le> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow> TC y \\<le> x", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> (TC ` elts y) \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> (TC ` elts y) \\<le> x\n\ngoal (1 subgoal):\n 1. TC y \\<le> x", "by (simp add: step TC [of y])"], ["proof (state)\nthis:\n  TC y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  TC y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition less_TC (infix \"\\<sqsubset>\" 50)\n  where \"x \\<sqsubset> y \\<equiv> x \\<in> elts (TC y)\""], ["", "definition le_TC (infix \"\\<sqsubseteq>\" 50)\n  where \"x \\<sqsubseteq> y \\<equiv> x \\<sqsubset> y \\<or> x=y\""], ["", "lemma less_TC_imp_not_le: \"x \\<sqsubset> a \\<Longrightarrow> \\<not> a \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubset> a \\<Longrightarrow> \\<not> a \\<le> x", "proof (induction a arbitrary: x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>y xa.\n                   \\<lbrakk>y \\<in> elts x; xa \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> \\<not> y \\<le> xa;\n        xa \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> \\<not> x \\<le> xa", "case (step a)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts a; ?x \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?y \\<le> ?x\n  x \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>y xa.\n                   \\<lbrakk>y \\<in> elts x; xa \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> \\<not> y \\<le> xa;\n        xa \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> \\<not> x \\<le> xa", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> elts a; ?x \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?y \\<le> ?x\n  x \\<sqsubset> a", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts a; ?x \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?y \\<le> ?x\n  x \\<sqsubset> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> x", "unfolding TC[of a] less_TC_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts a; ?x \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?y \\<le> ?x\n  x \\<in> elts (a \\<squnion> \\<Squnion> (TC ` elts a))\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> x", "using Transset_TC Transset_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts a; ?x \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?y \\<le> ?x\n  x \\<in> elts (a \\<squnion> \\<Squnion> (TC ` elts a))\n  Transset (TC ?a)\n  Transset ?x \\<equiv> \\<forall>y\\<in>elts ?x. y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> x", "by force"], ["proof (state)\nthis:\n  \\<not> a \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_TC_less_0 [iff]: \"\\<not> (x \\<sqsubset> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x \\<sqsubset> 0", "using less_TC_imp_not_le"], ["proof (prove)\nusing this:\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sqsubset> 0", "by blast"], ["", "lemma less_TC_iff: \"x \\<sqsubset> y \\<longleftrightarrow> (\\<exists>z \\<in> elts y. x \\<sqsubseteq> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqsubset> y) = (\\<exists>z\\<in>elts y. x \\<sqsubseteq> z)", "by (auto simp: less_TC_def le_TC_def TC [of y])"], ["", "lemma nonzero_less_TC: \"x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> x", "by (metis eps_induct le_TC_def less_TC_iff trad_foundation)"], ["", "lemma less_irrefl_TC [simp]: \"\\<not> x \\<sqsubset> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x \\<sqsubset> x", "using less_TC_imp_not_le"], ["proof (prove)\nusing this:\n  ?x \\<sqsubset> ?a \\<Longrightarrow> \\<not> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<sqsubset> x", "by blast"], ["", "lemma less_asym_TC: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis TC_least Transset_TC Transset_def antisym_conv less_TC_def less_TC_imp_not_le order_refl)"], ["", "lemma le_antisym_TC: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk> \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk>\n    \\<Longrightarrow> x = y", "using less_asym_TC"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubset> ?x\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> x\\<rbrakk>\n    \\<Longrightarrow> x = y", "by blast"], ["", "lemma less_imp_le_TC [iff]: \"x \\<sqsubset> y \\<Longrightarrow> x \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubset> y \\<Longrightarrow> x \\<sqsubseteq> y", "by (simp add: le_TC_def)"], ["", "lemma le_TC_refl [iff]: \"x \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x", "by (simp add: le_TC_def)"], ["", "lemma less_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubset> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubset> z", "by (meson TC_least Transset_TC Transset_def less_TC_def less_eq_V_def subsetD)"], ["", "lemma less_le_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubset> y; y \\<sqsubseteq> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubset> z", "using le_TC_def less_TC_trans"], ["proof (prove)\nusing this:\n  ?x \\<sqsubseteq> ?y \\<equiv> ?x \\<sqsubset> ?y \\<or> ?x = ?y\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubset> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubset> y; y \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubset> z", "by blast"], ["", "lemma le_less_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubset> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubset> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubset> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubset> z", "using le_TC_def less_TC_trans"], ["proof (prove)\nusing this:\n  ?x \\<sqsubseteq> ?y \\<equiv> ?x \\<sqsubset> ?y \\<or> ?x = ?y\n  \\<lbrakk>?x \\<sqsubset> ?y; ?y \\<sqsubset> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubset> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubset> z", "by blast"], ["", "lemma le_TC_trans [trans]: \"\\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk> \\<Longrightarrow> x \\<sqsubseteq> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> z", "using le_TC_def le_less_TC_trans"], ["proof (prove)\nusing this:\n  ?x \\<sqsubseteq> ?y \\<equiv> ?x \\<sqsubset> ?y \\<or> ?x = ?y\n  \\<lbrakk>?x \\<sqsubseteq> ?y; ?y \\<sqsubset> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqsubset> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubseteq> y; y \\<sqsubseteq> z\\<rbrakk>\n    \\<Longrightarrow> x \\<sqsubseteq> z", "by blast"], ["", "lemma TC_sup_distrib: \"TC (x \\<squnion> y) = TC x \\<squnion> TC y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (x \\<squnion> y) = TC x \\<squnion> TC y", "by (simp add: Sup_Un_distrib TC [of \"x \\<squnion> y\"] TC [of x] TC [of y] image_Un sup.assoc sup_left_commute)"], ["", "lemma TC_Sup_distrib:\n  assumes \"small X\" shows \"TC (\\<Squnion>X) = \\<Squnion>(TC ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "have \"\\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x) \\<le> \\<Squnion> (TC ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n    \\<le> \\<Squnion> (TC ` X)", "using assms"], ["proof (prove)\nusing this:\n  small X\n\ngoal (1 subgoal):\n 1. \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n    \\<le> \\<Squnion> (TC ` X)", "apply (auto simp: Sup_le_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>small X; x \\<in> X; xa \\<in> elts x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts (TC x)\n 2. \\<And>y x xa.\n       \\<lbrakk>small X; y \\<in> X; x \\<in> elts y;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts (TC x)", "using arg_subset_TC"], ["proof (prove)\nusing this:\n  ?a \\<le> TC ?a\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>small X; x \\<in> X; xa \\<in> elts x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts (TC x)\n 2. \\<And>y x xa.\n       \\<lbrakk>small X; y \\<in> X; x \\<in> elts y;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts (TC x)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x xa.\n       \\<lbrakk>small X; y \\<in> X; x \\<in> elts y;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts (TC x)", "by (metis TC_least Transset_TC Transset_def arg_subset_TC vsubsetD)"], ["proof (state)\nthis:\n  \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<le> \\<Squnion> (TC ` X)\n\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<le> \\<Squnion> (TC ` X)\n\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "have \"\\<Squnion> (TC ` X) \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (TC ` X)\n    \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)", "proof (clarsimp simp add: Sup_le_iff assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> X; xa \\<in> elts (TC x);\n        \\<forall>x\\<in>X.\n           \\<forall>x\\<in>elts x. xa \\<notin> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. xa \\<in> elts x", "show \"\\<exists>x\\<in>X. y \\<in> elts x\"\n      if \"x \\<in> X\" \"y \\<in> elts (TC x)\" \"\\<forall>x\\<in>X. \\<forall>u\\<in>elts x. y \\<notin> elts (TC u)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. y \\<in> elts x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> elts (TC x)\n  \\<forall>x\\<in>X. \\<forall>u\\<in>elts x. y \\<notin> elts (TC u)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. y \\<in> elts x", "by (auto simp: TC [of x])"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X; ?y \\<in> elts (TC ?x);\n   \\<forall>x\\<in>X. \\<forall>u\\<in>elts x. ?y \\<notin> elts (TC u)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. ?y \\<in> elts x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (TC ` X)\n  \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<le> \\<Squnion> (TC ` X)\n  \\<Squnion> (TC ` X)\n  \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<le> \\<Squnion> (TC ` X)\n  \\<Squnion> (TC ` X)\n  \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "using Sup_Un_distrib TC [of \"\\<Squnion>X\"] image_Union assms"], ["proof (prove)\nusing this:\n  \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<le> \\<Squnion> (TC ` X)\n  \\<Squnion> (TC ` X)\n  \\<le> \\<Squnion> X \\<squnion> \\<Squnion> (\\<Union>x\\<in>X. TC ` elts x)\n  \\<lbrakk>small ?A; small ?B\\<rbrakk>\n  \\<Longrightarrow> \\<Squnion> (?A \\<union> ?B) =\n                    \\<Squnion> ?A \\<squnion> \\<Squnion> ?B\n  TC (\\<Squnion> X) =\n  \\<Squnion> X \\<squnion> \\<Squnion> (TC ` elts (\\<Squnion> X))\n  ?f ` \\<Union> ?S = \\<Union> ((`) ?f ` ?S)\n  small X\n\ngoal (1 subgoal):\n 1. TC (\\<Squnion> X) = \\<Squnion> (TC ` X)", "by (simp add: image_Union inf_sup_aci(5) sup.absorb_iff2)"], ["proof (state)\nthis:\n  TC (\\<Squnion> X) = \\<Squnion> (TC ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TC': \"TC x = x \\<squnion> TC (\\<Squnion> (elts x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TC x = x \\<squnion> TC (\\<Squnion> (elts x))", "by (simp add: TC [of x] TC_Sup_distrib)"], ["", "lemma TC_eq_0_iff [simp]: \"TC x = 0 \\<longleftrightarrow> x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TC x = 0) = (x = 0)", "using arg_subset_TC"], ["proof (prove)\nusing this:\n  ?a \\<le> TC ?a\n\ngoal (1 subgoal):\n 1. (TC x = 0) = (x = 0)", "by fastforce"], ["", "text\\<open>A distinctive induction principle\\<close>"], ["", "lemma TC_induct_down_lemma:\n  assumes ab: \"a \\<sqsubset> b\" and base: \"b \\<le> d\"\n      and step: \"\\<And>y z. \\<lbrakk>y \\<sqsubset> b; y \\<in> elts d; z \\<in> elts y\\<rbrakk> \\<Longrightarrow> z \\<in> elts d\"\n    shows \"a \\<in> elts d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> elts d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> elts d", "have \"Transset (TC b \\<sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (TC b \\<sqinter> d)", "using Transset_TC"], ["proof (prove)\nusing this:\n  Transset (TC ?a)\n\ngoal (1 subgoal):\n 1. Transset (TC b \\<sqinter> d)", "unfolding Transset_def"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>elts (TC ?a). y \\<le> TC ?a\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>elts (TC b \\<sqinter> d). y \\<le> TC b \\<sqinter> d", "by (metis inf.bounded_iff less_TC_def less_eq_V_def local.step subsetI vsubsetD)"], ["proof (state)\nthis:\n  Transset (TC b \\<sqinter> d)\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "moreover"], ["proof (state)\nthis:\n  Transset (TC b \\<sqinter> d)\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "have \"b \\<le> TC b \\<sqinter> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> TC b \\<sqinter> d", "by (simp add: arg_subset_TC base)"], ["proof (state)\nthis:\n  b \\<le> TC b \\<sqinter> d\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "ultimately"], ["proof (chain)\npicking this:\n  Transset (TC b \\<sqinter> d)\n  b \\<le> TC b \\<sqinter> d", "show ?thesis"], ["proof (prove)\nusing this:\n  Transset (TC b \\<sqinter> d)\n  b \\<le> TC b \\<sqinter> d\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "using TC_least [THEN vsubsetD] ab"], ["proof (prove)\nusing this:\n  Transset (TC b \\<sqinter> d)\n  b \\<le> TC b \\<sqinter> d\n  \\<lbrakk>Transset ?b; ?a1 \\<le> ?b; ?c \\<in> elts (TC ?a1)\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> elts ?b\n  a \\<sqsubset> b\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "unfolding less_TC_def"], ["proof (prove)\nusing this:\n  Transset (TC b \\<sqinter> d)\n  b \\<le> TC b \\<sqinter> d\n  \\<lbrakk>Transset ?b; ?a1 \\<le> ?b; ?c \\<in> elts (TC ?a1)\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> elts ?b\n  a \\<in> elts (TC b)\n\ngoal (1 subgoal):\n 1. a \\<in> elts d", "by (meson TC_least le_inf_iff vsubsetD)"], ["proof (state)\nthis:\n  a \\<in> elts d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TC_induct_down [consumes 1, case_names base step small]:\n  assumes \"a \\<sqsubset> b\"\n    and \"\\<And>y. y \\<in> elts b \\<Longrightarrow> P y\"\n    and \"\\<And>y z. \\<lbrakk>y \\<sqsubset> b; P y; z \\<in> elts y\\<rbrakk> \\<Longrightarrow> P z\"\n    and \"small (Collect P)\"\n  shows \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a", "using TC_induct_down_lemma [of a b \"set (Collect P)\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<sqsubset> b; b \\<le> set (Collect P);\n   \\<And>y z.\n      \\<lbrakk>y \\<sqsubset> b; y \\<in> elts (set (Collect P));\n       z \\<in> elts y\\<rbrakk>\n      \\<Longrightarrow> z \\<in> elts (set (Collect P))\\<rbrakk>\n  \\<Longrightarrow> a \\<in> elts (set (Collect P))\n  a \\<sqsubset> b\n  ?y \\<in> elts b \\<Longrightarrow> P ?y\n  \\<lbrakk>?y \\<sqsubset> b; P ?y; ?z \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> P ?z\n  small (Collect P)\n\ngoal (1 subgoal):\n 1. P a", "by (metis elts_of_set mem_Collect_eq vsubsetI)"], ["", "subsection\\<open>Rank of a set\\<close>"], ["", "definition rank :: \"V\\<Rightarrow>V\"\n  where \"rank a \\<equiv> transrec (\\<lambda>f x. set (\\<Union>y\\<in>elts x. elts (succ(f y)))) a\""], ["", "lemma rank: \"rank a = set(\\<Union>y \\<in> elts a. elts (succ(rank y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank a = set (\\<Union>y\\<in>elts a. elts (ZFC_in_HOL.succ (rank y)))", "by (subst rank_def [THEN def_transrec], simp)"], ["", "lemma rank_Sup: \"rank a = \\<Squnion>((\\<lambda>y. succ(rank y)) ` elts a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank a = (SUP y\\<in>elts a. ZFC_in_HOL.succ (rank y))", "by (metis elts_Sup image_image rank replacement set_of_elts small_elts)"], ["", "lemma Ord_rank [simp]: \"Ord(rank a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (rank a)", "proof (induction a rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> Ord (rank y)) \\<Longrightarrow>\n       Ord (rank x)", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> Ord (rank ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow> Ord (rank y)) \\<Longrightarrow>\n       Ord (rank x)", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> elts x \\<Longrightarrow> Ord (rank ?y)", "show ?case"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> Ord (rank ?y)\n\ngoal (1 subgoal):\n 1. Ord (rank x)", "unfolding rank_Sup [of x]"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> Ord (rank ?y)\n\ngoal (1 subgoal):\n 1. Ord (SUP y\\<in>elts x. ZFC_in_HOL.succ (rank y))", "by (metis (mono_tags, lifting) Ord_Sup Ord_succ imageE)"], ["proof (state)\nthis:\n  Ord (rank x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_of_Ord: \"Ord i \\<Longrightarrow> rank i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i \\<Longrightarrow> rank i = i", "apply (induction rule: Ord_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y. y \\<in> elts x \\<Longrightarrow> rank y = y\\<rbrakk>\n       \\<Longrightarrow> rank x = x", "by (metis (no_types, lifting) Ord_equality SUP_cong rank_Sup)"], ["", "lemma Ord_iff_rank: \"Ord x \\<longleftrightarrow> rank x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord x = (rank x = x)", "using Ord_rank [of x] rank_of_Ord"], ["proof (prove)\nusing this:\n  Ord (rank x)\n  Ord ?i \\<Longrightarrow> rank ?i = ?i\n\ngoal (1 subgoal):\n 1. Ord x = (rank x = x)", "by fastforce"], ["", "lemma rank_lt: \"a \\<in> elts b \\<Longrightarrow> rank a < rank b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> elts b \\<Longrightarrow> rank a < rank b", "apply (subst rank [of b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> elts b \\<Longrightarrow>\n    rank a < set (\\<Union>y\\<in>elts b. elts (ZFC_in_HOL.succ (rank y)))", "by (metis (no_types, lifting) Ord_mem_iff_lt Ord_rank small_UN UN_iff elts_of_set elts_succ insert_iff rank small_elts)"], ["", "lemma rank_0 [simp]: \"rank 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank 0 = 0", "unfolding rank_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec\n     (\\<lambda>f x.\n         set (\\<Union>y\\<in>elts x. elts (ZFC_in_HOL.succ (f y))))\n     0 =\n    0", "using transrec"], ["proof (prove)\nusing this:\n  transrec ?H ?a = ?H (restrict (transrec ?H) (elts ?a)) ?a\n\ngoal (1 subgoal):\n 1. transrec\n     (\\<lambda>f x.\n         set (\\<Union>y\\<in>elts x. elts (ZFC_in_HOL.succ (f y))))\n     0 =\n    0", "by fastforce"], ["", "lemma rank_succ [simp]: \"rank(succ x) = succ(rank x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (ZFC_in_HOL.succ x) = ZFC_in_HOL.succ (rank x)", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. rank (ZFC_in_HOL.succ x) \\<le> ZFC_in_HOL.succ (rank x)\n 2. ZFC_in_HOL.succ (rank x) \\<le> rank (ZFC_in_HOL.succ x)", "show \"rank (succ x) \\<le> succ (rank x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (ZFC_in_HOL.succ x) \\<le> ZFC_in_HOL.succ (rank x)", "apply (subst rank [of \"succ x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (\\<Union>y\\<in>elts (ZFC_in_HOL.succ x).\n            elts (ZFC_in_HOL.succ (rank y)))\n    \\<le> ZFC_in_HOL.succ (rank x)", "apply (metis (no_types, lifting) Sup_insert elts_of_set elts_succ equals0D image_insert rank small_sup_iff subset_insertI sup.orderE vsubsetI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rank (ZFC_in_HOL.succ x) \\<le> ZFC_in_HOL.succ (rank x)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (rank x) \\<le> rank (ZFC_in_HOL.succ x)", "show \"succ (rank x) \\<le> rank (succ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (rank x) \\<le> rank (ZFC_in_HOL.succ x)", "by (metis (mono_tags, lifting) ZFC_in_HOL.Sup_upper elts_succ image_insert insertI1 rank_Sup replacement small_elts)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (rank x) \\<le> rank (ZFC_in_HOL.succ x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_mono: \"a \\<le> b \\<Longrightarrow> rank a \\<le> rank b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> rank a \\<le> rank b", "apply (rule vsubsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b; x \\<in> elts (rank a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts (rank b)", "using rank [of a] rank [of b] small_UN"], ["proof (prove)\nusing this:\n  rank a = set (\\<Union>y\\<in>elts a. elts (ZFC_in_HOL.succ (rank y)))\n  rank b = set (\\<Union>y\\<in>elts b. elts (ZFC_in_HOL.succ (rank y)))\n  \\<lbrakk>small ?X;\n   \\<And>x. x \\<in> ?X \\<Longrightarrow> small (?B x)\\<rbrakk>\n  \\<Longrightarrow> small (\\<Union> (?B ` ?X))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a \\<le> b; x \\<in> elts (rank a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> elts (rank b)", "by auto"], ["", "lemma VsetI: \"rank b \\<sqsubset> i \\<Longrightarrow> b \\<in> elts (Vset i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank b \\<sqsubset> i \\<Longrightarrow> b \\<in> elts (Vset i)", "proof (induction i arbitrary: b rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>y b.\n                   \\<lbrakk>y \\<in> elts x; rank b \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> b \\<in> elts (Vset y);\n        rank b \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> b \\<in> elts (Vset x)", "case (step x)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n  rank b \\<sqsubset> x\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>y b.\n                   \\<lbrakk>y \\<in> elts x; rank b \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> b \\<in> elts (Vset y);\n        rank b \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> b \\<in> elts (Vset x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n  rank b \\<sqsubset> x", "consider \"rank b \\<in> elts x\" | \"(\\<exists>y\\<in>elts x. rank b \\<in> elts (TC y))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n  rank b \\<sqsubset> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank b \\<in> elts x \\<Longrightarrow> thesis;\n     \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using le_TC_def less_TC_def less_TC_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n  rank b \\<sqsubset> x\n  ?x \\<sqsubseteq> ?y \\<equiv> ?x \\<sqsubset> ?y \\<or> ?x = ?y\n  ?x \\<sqsubset> ?y \\<equiv> ?x \\<in> elts (TC ?y)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rank b \\<in> elts x \\<Longrightarrow> thesis;\n     \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>rank b \\<in> elts x \\<Longrightarrow> ?thesis;\n   \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>y b.\n                   \\<lbrakk>y \\<in> elts x; rank b \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> b \\<in> elts (Vset y);\n        rank b \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> b \\<in> elts (Vset x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>rank b \\<in> elts x \\<Longrightarrow> ?thesis;\n   \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"\\<exists>y\\<in>elts x. b \\<le> Vset y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>rank b \\<in> elts x \\<Longrightarrow> ?thesis;\n   \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. b \\<le> Vset y", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. rank b \\<in> elts x \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y\n 2. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "case 1"], ["proof (state)\nthis:\n  rank b \\<in> elts x\n\ngoal (2 subgoals):\n 1. rank b \\<in> elts x \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y\n 2. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "then"], ["proof (chain)\npicking this:\n  rank b \\<in> elts x", "have \"b \\<le> Vset (rank b)\""], ["proof (prove)\nusing this:\n  rank b \\<in> elts x\n\ngoal (1 subgoal):\n 1. b \\<le> Vset (rank b)", "unfolding less_eq_V_def subset_iff"], ["proof (prove)\nusing this:\n  rank b \\<in> elts x\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t \\<in> elts b \\<longrightarrow> t \\<in> elts (Vset (rank b))", "by (meson Ord_mem_iff_lt Ord_rank le_TC_refl less_TC_iff rank_lt step.IH)"], ["proof (state)\nthis:\n  b \\<le> Vset (rank b)\n\ngoal (2 subgoals):\n 1. rank b \\<in> elts x \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y\n 2. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "then"], ["proof (chain)\npicking this:\n  b \\<le> Vset (rank b)", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> Vset (rank b)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. b \\<le> Vset y", "using \"1\""], ["proof (prove)\nusing this:\n  b \\<le> Vset (rank b)\n  rank b \\<in> elts x\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. b \\<le> Vset y", "by blast"], ["proof (state)\nthis:\n  \\<exists>y\\<in>elts x. b \\<le> Vset y\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "case 2"], ["proof (state)\nthis:\n  \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y) \\<Longrightarrow>\n    \\<exists>y\\<in>elts x. b \\<le> Vset y", "then"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. b \\<le> Vset y", "using step.IH"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y)\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<sqsubset> ?y\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x. b \\<le> Vset y", "unfolding less_eq_V_def subset_iff less_TC_def"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>elts x. rank b \\<in> elts (TC y)\n  \\<lbrakk>?y \\<in> elts x; rank ?b \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> elts (Vset ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>elts x.\n       \\<forall>t. t \\<in> elts b \\<longrightarrow> t \\<in> elts (Vset y)", "by (meson Ord_mem_iff_lt Ord_rank Transset_TC Transset_def rank_lt vsubsetD)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>elts x. b \\<le> Vset y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>elts x. b \\<le> Vset y\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       \\<lbrakk>\\<And>y b.\n                   \\<lbrakk>y \\<in> elts x; rank b \\<sqsubset> y\\<rbrakk>\n                   \\<Longrightarrow> b \\<in> elts (Vset y);\n        rank b \\<sqsubset> x\\<rbrakk>\n       \\<Longrightarrow> b \\<in> elts (Vset x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>elts x. b \\<le> Vset y", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>elts x. b \\<le> Vset y\n\ngoal (1 subgoal):\n 1. b \\<in> elts (Vset x)", "by (simp add: Vset [of x])"], ["proof (state)\nthis:\n  b \\<in> elts (Vset x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_VsetI: \"\\<lbrakk>Ord i; rank b < i\\<rbrakk> \\<Longrightarrow> b \\<in> elts (Vset i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i; rank b < i\\<rbrakk>\n    \\<Longrightarrow> b \\<in> elts (Vset i)", "by (meson Ord_mem_iff_lt Ord_rank VsetI arg_subset_TC less_TC_def vsubsetD)"], ["", "lemma arg_le_Vset_rank: \"a \\<le> Vset(rank a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Vset (rank a)", "by (simp add: Ord_VsetI rank_lt vsubsetI)"], ["", "lemma two_in_Vset:\n  obtains \\<alpha> where  \"x \\<in> elts (Vset \\<alpha>)\" \"y \\<in> elts (Vset \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<lbrakk>x \\<in> elts (Vset \\<alpha>);\n         y \\<in> elts (Vset \\<alpha>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Ord_rank Ord_VsetI elts_of_set insert_iff rank_lt small_elts small_insert_iff)"], ["", "lemma rank_eq_0_iff [simp]: \"rank x = 0 \\<longleftrightarrow> x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rank x = 0) = (x = 0)", "using arg_le_Vset_rank"], ["proof (prove)\nusing this:\n  ?a \\<le> Vset (rank ?a)\n\ngoal (1 subgoal):\n 1. (rank x = 0) = (x = 0)", "by fastforce"], ["", "lemma small_ranks_imp_small:\n  assumes \"small (rank ` A)\" shows \"small A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small A", "define i where \"i \\<equiv> set (\\<Union>(elts ` (rank ` A)))\""], ["proof (state)\nthis:\n  i \\<equiv> set (\\<Union> (elts ` rank ` A))\n\ngoal (1 subgoal):\n 1. small A", "have \"Ord i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord i", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (set (\\<Union> (elts ` rank ` A)))", "using Ord_Union Ord_rank assms imageE"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. x \\<in> ?X \\<Longrightarrow> Ord x; small ?X\\<rbrakk>\n  \\<Longrightarrow> Ord (set (\\<Union> (elts ` ?X)))\n  Ord (rank ?a)\n  small (rank ` A)\n  \\<lbrakk>?b \\<in> ?f ` ?A;\n   \\<And>x.\n      \\<lbrakk>?b = ?f x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Ord (set (\\<Union> (elts ` rank ` A)))", "by blast"], ["proof (state)\nthis:\n  Ord i\n\ngoal (1 subgoal):\n 1. small A", "have *: \"Vset (rank x) \\<le> (Vset i)\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vset (rank x) \\<le> Vset i", "unfolding i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vset (rank x) \\<le> Vset (set (\\<Union> (elts ` rank ` A)))", "by (metis Ord_rank Sup_V_def ZFC_in_HOL.Sup_upper Vfrom_mono assms imageI le_less that)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> Vset (rank ?x) \\<le> Vset i\n\ngoal (1 subgoal):\n 1. small A", "have \"A \\<subseteq> elts (VPow (Vset i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> elts (VPow (Vset i))", "by (meson \"*\" VPow_iff arg_le_Vset_rank order.trans subsetI)"], ["proof (state)\nthis:\n  A \\<subseteq> elts (VPow (Vset i))\n\ngoal (1 subgoal):\n 1. small A", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> elts (VPow (Vset i))", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> elts (VPow (Vset i))\n\ngoal (1 subgoal):\n 1. small A", "using down"], ["proof (prove)\nusing this:\n  A \\<subseteq> elts (VPow (Vset i))\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n\ngoal (1 subgoal):\n 1. small A", "by blast"], ["proof (state)\nthis:\n  small A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rank_Union: \"rank(\\<Squnion> A) = \\<Squnion> (rank ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rank (\\<Squnion> A) = \\<Squnion> (rank ` A)", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. rank (\\<Squnion> A) \\<le> \\<Squnion> (rank ` A)\n 2. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "have \"elts (SUP y\\<in>elts (\\<Squnion> A). succ (rank y)) \\<subseteq> elts (\\<Squnion> (rank ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (SUP y\\<in>elts (\\<Squnion> A). ZFC_in_HOL.succ (rank y))\n    \\<subseteq> elts (\\<Squnion> (rank ` A))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. rank xa \\<in> elts (rank x)\n 2. \\<And>x xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb;\n        x \\<in> elts (rank xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>A. x \\<in> elts (rank xa)", "(*SLOW*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. rank xa \\<in> elts (rank x)\n 2. \\<And>x xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb;\n        x \\<in> elts (rank xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>A. x \\<in> elts (rank xa)", "using Ord_mem_iff_lt Ord_rank rank_lt"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  Ord (rank ?a)\n  ?a \\<in> elts ?b \\<Longrightarrow> rank ?a < rank ?b\n\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>A. rank xa \\<in> elts (rank x)\n 2. \\<And>x xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb;\n        x \\<in> elts (rank xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>A. x \\<in> elts (rank xa)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>small A; xb \\<in> A; xa \\<in> elts xb;\n        x \\<in> elts (rank xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>A. x \\<in> elts (rank xa)", "by (meson less_le_not_le rank_lt vsubsetD)"], ["proof (state)\nthis:\n  elts (SUP y\\<in>elts (\\<Squnion> A). ZFC_in_HOL.succ (rank y))\n  \\<subseteq> elts (\\<Squnion> (rank ` A))\n\ngoal (2 subgoals):\n 1. rank (\\<Squnion> A) \\<le> \\<Squnion> (rank ` A)\n 2. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "then"], ["proof (chain)\npicking this:\n  elts (SUP y\\<in>elts (\\<Squnion> A). ZFC_in_HOL.succ (rank y))\n  \\<subseteq> elts (\\<Squnion> (rank ` A))", "show \"rank (\\<Squnion> A) \\<le> \\<Squnion> (rank ` A)\""], ["proof (prove)\nusing this:\n  elts (SUP y\\<in>elts (\\<Squnion> A). ZFC_in_HOL.succ (rank y))\n  \\<subseteq> elts (\\<Squnion> (rank ` A))\n\ngoal (1 subgoal):\n 1. rank (\\<Squnion> A) \\<le> \\<Squnion> (rank ` A)", "by (metis less_eq_V_def rank_Sup)"], ["proof (state)\nthis:\n  rank (\\<Squnion> A) \\<le> \\<Squnion> (rank ` A)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "show \"\\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "proof (cases \"small A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\n 2. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "case True"], ["proof (state)\nthis:\n  small A\n\ngoal (2 subgoals):\n 1. small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\n 2. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "then"], ["proof (chain)\npicking this:\n  small A", "show ?thesis"], ["proof (prove)\nusing this:\n  small A\n\ngoal (1 subgoal):\n 1. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "by (metis (mono_tags, lifting) ZFC_in_HOL.Sup_least ZFC_in_HOL.Sup_upper image_iff rank_mono)"], ["proof (state)\nthis:\n  \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\n\ngoal (1 subgoal):\n 1. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "case False"], ["proof (state)\nthis:\n  \\<not> small A\n\ngoal (1 subgoal):\n 1. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "then"], ["proof (chain)\npicking this:\n  \\<not> small A", "have \"\\<not> small (rank ` A)\""], ["proof (prove)\nusing this:\n  \\<not> small A\n\ngoal (1 subgoal):\n 1. \\<not> small (rank ` A)", "using small_ranks_imp_small"], ["proof (prove)\nusing this:\n  \\<not> small A\n  small (rank ` ?A) \\<Longrightarrow> small ?A\n\ngoal (1 subgoal):\n 1. \\<not> small (rank ` A)", "by blast"], ["proof (state)\nthis:\n  \\<not> small (rank ` A)\n\ngoal (1 subgoal):\n 1. \\<not> small A \\<Longrightarrow>\n    \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "then"], ["proof (chain)\npicking this:\n  \\<not> small (rank ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> small (rank ` A)\n\ngoal (1 subgoal):\n 1. \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)", "by blast"], ["proof (state)\nthis:\n  \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (rank ` A) \\<le> rank (\\<Squnion> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_bounded_rank:  \"small {x. rank x \\<in> elts a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "have \"{x. rank x \\<in> elts a} \\<subseteq> {x. rank x \\<sqsubset> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rank x \\<in> elts a} \\<subseteq> {x. rank x \\<sqsubset> a}", "using less_TC_iff"], ["proof (prove)\nusing this:\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. {x. rank x \\<in> elts a} \\<subseteq> {x. rank x \\<sqsubset> a}", "by auto"], ["proof (state)\nthis:\n  {x. rank x \\<in> elts a} \\<subseteq> {x. rank x \\<sqsubset> a}\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "also"], ["proof (state)\nthis:\n  {x. rank x \\<in> elts a} \\<subseteq> {x. rank x \\<sqsubset> a}\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "have \"\\<dots> \\<subseteq> elts (Vset a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rank x \\<sqsubset> a} \\<subseteq> elts (Vset a)", "using VsetI"], ["proof (prove)\nusing this:\n  rank ?b \\<sqsubset> ?i \\<Longrightarrow> ?b \\<in> elts (Vset ?i)\n\ngoal (1 subgoal):\n 1. {x. rank x \\<sqsubset> a} \\<subseteq> elts (Vset a)", "by blast"], ["proof (state)\nthis:\n  {x. rank x \\<sqsubset> a} \\<subseteq> elts (Vset a)\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "finally"], ["proof (chain)\npicking this:\n  {x. rank x \\<in> elts a} \\<subseteq> elts (Vset a)", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. rank x \\<in> elts a} \\<subseteq> elts (Vset a)\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "using down"], ["proof (prove)\nusing this:\n  {x. rank x \\<in> elts a} \\<subseteq> elts (Vset a)\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<in> elts a}", "by simp"], ["proof (state)\nthis:\n  small {x. rank x \\<in> elts a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma small_bounded_rank_le:  \"small {x. rank x \\<le> a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small {x. rank x \\<le> a}", "using small_bounded_rank [of \"VPow a\"] VPow_iff [of _ a]"], ["proof (prove)\nusing this:\n  small {x. rank x \\<in> elts (VPow a)}\n  (?y \\<in> elts (VPow a)) = (?y \\<le> a)\n\ngoal (1 subgoal):\n 1. small {x. rank x \\<le> a}", "by simp"], ["", "lemma TC_rank_lt: \"a \\<sqsubset> b \\<Longrightarrow> rank a < rank b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqsubset> b \\<Longrightarrow> rank a < rank b", "proof (induction rule: TC_induct_down)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y. y \\<in> elts b \\<Longrightarrow> rank y < rank b\n 2. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset> b; rank y < rank b; z \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> rank z < rank b\n 3. small {a. rank a < rank b}", "case (base y)"], ["proof (state)\nthis:\n  y \\<in> elts b\n\ngoal (3 subgoals):\n 1. \\<And>y. y \\<in> elts b \\<Longrightarrow> rank y < rank b\n 2. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset> b; rank y < rank b; z \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> rank z < rank b\n 3. small {a. rank a < rank b}", "then"], ["proof (chain)\npicking this:\n  y \\<in> elts b", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> elts b\n\ngoal (1 subgoal):\n 1. rank y < rank b", "by (simp add: rank_lt)"], ["proof (state)\nthis:\n  rank y < rank b\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset> b; rank y < rank b; z \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> rank z < rank b\n 2. small {a. rank a < rank b}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset> b; rank y < rank b; z \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> rank z < rank b\n 2. small {a. rank a < rank b}", "case (step y z)"], ["proof (state)\nthis:\n  y \\<sqsubset> b\n  z \\<in> elts y\n  rank y < rank b\n\ngoal (2 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset> b; rank y < rank b; z \\<in> elts y\\<rbrakk>\n       \\<Longrightarrow> rank z < rank b\n 2. small {a. rank a < rank b}", "then"], ["proof (chain)\npicking this:\n  y \\<sqsubset> b\n  z \\<in> elts y\n  rank y < rank b", "show ?case"], ["proof (prove)\nusing this:\n  y \\<sqsubset> b\n  z \\<in> elts y\n  rank y < rank b\n\ngoal (1 subgoal):\n 1. rank z < rank b", "using less_trans rank_lt"], ["proof (prove)\nusing this:\n  y \\<sqsubset> b\n  z \\<in> elts y\n  rank y < rank b\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  ?a \\<in> elts ?b \\<Longrightarrow> rank ?a < rank ?b\n\ngoal (1 subgoal):\n 1. rank z < rank b", "by blast"], ["proof (state)\nthis:\n  rank z < rank b\n\ngoal (1 subgoal):\n 1. small {a. rank a < rank b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. small {a. rank a < rank b}", "case small"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. small {a. rank a < rank b}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. small {a. rank a < rank b}", "apply (rule smaller_than_small [OF small_bounded_rank_le [of \"rank b\"]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. rank a < rank b} \\<subseteq> {x. rank x \\<le> rank b}", "by (simp add: Collect_mono less_V_def)"], ["proof (state)\nthis:\n  small {a. rank a < rank b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TC_rank_mem: \"x \\<sqsubset> y \\<Longrightarrow> rank x \\<in> elts (rank y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubset> y \\<Longrightarrow> rank x \\<in> elts (rank y)", "by (simp add: Ord_mem_iff_lt TC_rank_lt)"], ["", "lemma wf_TC_less: \"wf {(x,y). x \\<sqsubset> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). x \\<sqsubset> y}", "proof (rule wf_subset [OF wf_inv_image [OF foundation, of rank]])"], ["proof (state)\ngoal (1 subgoal):\n 1. {(x, y). x \\<sqsubset> y}\n    \\<subseteq> inv_image {(x, y). x \\<in> elts y} rank", "show \"{(x, y). x \\<sqsubset> y} \\<subseteq> inv_image {(x, y). x \\<in> elts y} rank\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<sqsubset> y}\n    \\<subseteq> inv_image {(x, y). x \\<in> elts y} rank", "by (auto simp: TC_rank_mem inv_image_def)"], ["proof (state)\nthis:\n  {(x, y). x \\<sqsubset> y}\n  \\<subseteq> inv_image {(x, y). x \\<in> elts y} rank\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_TC_minimal:\n  assumes \"P a\"\n  obtains x where \"P x\" \"x \\<sqsubseteq> a\" \"\\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>P x; x \\<sqsubseteq> a;\n         \\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wfE_min' [OF wf_TC_less, of \"{x. P x \\<and> x \\<sqsubseteq> a}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{x. P x \\<and> x \\<sqsubseteq> a} \\<noteq> {};\n   \\<And>z.\n      \\<lbrakk>z \\<in> {x. P x \\<and> x \\<sqsubseteq> a};\n       \\<And>y.\n          (y, z) \\<in> {(x, y). x \\<sqsubset> y} \\<Longrightarrow>\n          y \\<notin> {x. P x \\<and> x \\<sqsubseteq> a}\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>P x; x \\<sqsubseteq> a;\n         \\<And>y. y \\<sqsubset> x \\<Longrightarrow> \\<not> P y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (metis le_TC_def less_le_TC_trans assms)"], ["", "lemma Vfrom_rank_eq: \"Vfrom A (rank(x)) = Vfrom A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom A (rank x) = Vfrom A x", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. Vfrom A (rank x) \\<le> Vfrom A x\n 2. Vfrom A x \\<le> Vfrom A (rank x)", "show \"Vfrom A (rank x) \\<le> Vfrom A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom A (rank x) \\<le> Vfrom A x", "proof (induction x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A (rank y) \\<le> Vfrom A y) \\<Longrightarrow>\n       Vfrom A (rank x) \\<le> Vfrom A x", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> Vfrom A (rank ?y) \\<le> Vfrom A ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A (rank y) \\<le> Vfrom A y) \\<Longrightarrow>\n       Vfrom A (rank x) \\<le> Vfrom A x", "have \"(SUP j\\<in>elts (rank x). VPow (Vfrom A j)) \\<le> (SUP j\\<in>elts x. VPow (Vfrom A j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n    \\<le> (SUP j\\<in>elts x. VPow (Vfrom A j))", "apply (rule Sup_least, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xaa j.\n       \\<lbrakk>j \\<in> elts (rank x); xaa \\<le> Vfrom A j\\<rbrakk>\n       \\<Longrightarrow> xaa\n                         \\<in> \\<Union>\n                                (elts `\n                                 (\\<lambda>j. VPow (Vfrom A j)) `\n                                 elts x) \\<and>\n                         small ((\\<lambda>j. VPow (Vfrom A j)) ` elts x)", "apply (simp add: rank [of x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xaa j.\n       \\<lbrakk>\\<exists>x\\<in>elts x.\n                   j = rank x \\<or> j \\<in> elts (rank x);\n        xaa \\<le> Vfrom A j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>elts x. xaa \\<le> Vfrom A x", "using step.IH"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> Vfrom A (rank ?y) \\<le> Vfrom A ?y\n\ngoal (1 subgoal):\n 1. \\<And>xaa j.\n       \\<lbrakk>\\<exists>x\\<in>elts x.\n                   j = rank x \\<or> j \\<in> elts (rank x);\n        xaa \\<le> Vfrom A j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>elts x. xaa \\<le> Vfrom A x", "by (metis Ord_rank OrdmemD Vfrom_mono2 dual_order.trans inf_sup_aci(5) less_V_def sup.orderE)"], ["proof (state)\nthis:\n  (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts x. VPow (Vfrom A j))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A (rank y) \\<le> Vfrom A y) \\<Longrightarrow>\n       Vfrom A (rank x) \\<le> Vfrom A x", "then"], ["proof (chain)\npicking this:\n  (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts x. VPow (Vfrom A j))", "show ?case"], ["proof (prove)\nusing this:\n  (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts x. VPow (Vfrom A j))\n\ngoal (1 subgoal):\n 1. Vfrom A (rank x) \\<le> Vfrom A x", "by (simp add: Vfrom [of _ x] Vfrom [of _ \"rank(x)\"] sup.coboundedI2)"], ["proof (state)\nthis:\n  Vfrom A (rank x) \\<le> Vfrom A x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Vfrom A (rank x) \\<le> Vfrom A x\n\ngoal (1 subgoal):\n 1. Vfrom A x \\<le> Vfrom A (rank x)", "show \"Vfrom A x \\<le> Vfrom A (rank x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom A x \\<le> Vfrom A (rank x)", "proof (induction x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A y \\<le> Vfrom A (rank y)) \\<Longrightarrow>\n       Vfrom A x \\<le> Vfrom A (rank x)", "case (step x)"], ["proof (state)\nthis:\n  ?y \\<in> elts x \\<Longrightarrow> Vfrom A ?y \\<le> Vfrom A (rank ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A y \\<le> Vfrom A (rank y)) \\<Longrightarrow>\n       Vfrom A x \\<le> Vfrom A (rank x)", "have \"(SUP j\\<in>elts x. VPow (Vfrom A j)) \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts x. VPow (Vfrom A j))\n    \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))", "using step.IH TC_rank_mem less_TC_iff"], ["proof (prove)\nusing this:\n  ?y \\<in> elts x \\<Longrightarrow> Vfrom A ?y \\<le> Vfrom A (rank ?y)\n  ?x \\<sqsubset> ?y \\<Longrightarrow> rank ?x \\<in> elts (rank ?y)\n  (?x \\<sqsubset> ?y) = (\\<exists>z\\<in>elts ?y. ?x \\<sqsubseteq> z)\n\ngoal (1 subgoal):\n 1. (SUP j\\<in>elts x. VPow (Vfrom A j))\n    \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))", "by force"], ["proof (state)\nthis:\n  (SUP j\\<in>elts x. VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y \\<in> elts x \\<Longrightarrow>\n           Vfrom A y \\<le> Vfrom A (rank y)) \\<Longrightarrow>\n       Vfrom A x \\<le> Vfrom A (rank x)", "then"], ["proof (chain)\npicking this:\n  (SUP j\\<in>elts x. VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))", "show ?case"], ["proof (prove)\nusing this:\n  (SUP j\\<in>elts x. VPow (Vfrom A j))\n  \\<le> (SUP j\\<in>elts (rank x). VPow (Vfrom A j))\n\ngoal (1 subgoal):\n 1. Vfrom A x \\<le> Vfrom A (rank x)", "by (simp add: Vfrom [of _ x] Vfrom [of _ \"rank(x)\"] sup.coboundedI2)"], ["proof (state)\nthis:\n  Vfrom A x \\<le> Vfrom A (rank x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Vfrom A x \\<le> Vfrom A (rank x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Vfrom_succ: \"Vfrom A (succ(i)) = A \\<squnion> VPow(Vfrom A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vfrom A (ZFC_in_HOL.succ i) = A \\<squnion> VPow (Vfrom A i)", "by (metis Ord_rank Vfrom_rank_eq Vfrom_succ_Ord rank_succ)"], ["", "lemma Vset_succ_TC:\n  assumes \"x \\<in> elts (Vset (ZFC_in_HOL.succ k))\" \"u \\<sqsubset> x\"\n  shows \"u \\<in> elts (Vset k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> elts (Vset (ZFC_in_HOL.succ k))\n  u \\<sqsubset> x\n\ngoal (1 subgoal):\n 1. u \\<in> elts (Vset k)", "apply (simp add: Vfrom_succ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> Vset k; u \\<sqsubset> x\\<rbrakk>\n    \\<Longrightarrow> u \\<in> elts (Vset k)", "using TC_least Transset_Vfrom less_TC_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>Transset ?x; ?a \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> TC ?a \\<le> ?x\n  Transset ?A \\<Longrightarrow> Transset (Vfrom ?A ?i)\n  ?x \\<sqsubset> ?y \\<equiv> ?x \\<in> elts (TC ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> Vset k; u \\<sqsubset> x\\<rbrakk>\n    \\<Longrightarrow> u \\<in> elts (Vset k)", "by auto"], ["", "subsection\\<open>Cardinal Numbers\\<close>"], ["", "text\\<open>We extend the membership relation to a wellordering\\<close>"], ["", "definition VWO :: \"(V \\<times> V) set\"\n  where \"VWO \\<equiv> @r. {(x,y). x \\<in> elts y} \\<subseteq> r \\<and> Well_order r \\<and> Field r = UNIV\""], ["", "lemma VWO: \"{(x,y). x \\<in> elts y} \\<subseteq> VWO \\<and> Well_order VWO \\<and> Field VWO = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n    Well_order VWO \\<and> Field VWO = UNIV", "unfolding VWO_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x \\<in> elts y}\n    \\<subseteq> (SOME r.\n                    {(x, y). x \\<in> elts y} \\<subseteq> r \\<and>\n                    Well_order r \\<and> Field r = UNIV) \\<and>\n    Well_order\n     (SOME r.\n         {(x, y). x \\<in> elts y} \\<subseteq> r \\<and>\n         Well_order r \\<and> Field r = UNIV) \\<and>\n    Field\n     (SOME r.\n         {(x, y). x \\<in> elts y} \\<subseteq> r \\<and>\n         Well_order r \\<and> Field r = UNIV) =\n    UNIV", "by (metis (mono_tags, lifting) VWO_def foundation someI_ex total_well_order_extension)"], ["", "lemma wf_VWO: \"wf(VWO - Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (VWO - Id)", "using VWO well_order_on_def"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n  well_order_on ?A ?r \\<equiv> linear_order_on ?A ?r \\<and> wf (?r - Id)\n\ngoal (1 subgoal):\n 1. wf (VWO - Id)", "by blast"], ["", "lemma wf_Ord_less: \"wf {(x, y). Ord y \\<and> x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(x, y). Ord y \\<and> x < y}", "by (metis (no_types, lifting) Ord_mem_iff_lt eps_induct wfPUNIVI wfP_def)"], ["", "lemma refl_VWO: \"refl VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl VWO", "using VWO order_on_defs"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n  preorder_on ?A ?r \\<equiv> refl_on ?A ?r \\<and> trans ?r\n  partial_order_on ?A ?r \\<equiv> preorder_on ?A ?r \\<and> antisym ?r\n  linear_order_on ?A ?r \\<equiv>\n  partial_order_on ?A ?r \\<and> total_on ?A ?r\n  strict_linear_order_on ?A ?r \\<equiv>\n  trans ?r \\<and> irrefl ?r \\<and> total_on ?A ?r\n  well_order_on ?A ?r \\<equiv> linear_order_on ?A ?r \\<and> wf (?r - Id)\n\ngoal (1 subgoal):\n 1. refl VWO", "by fastforce"], ["", "lemma trans_VWO: \"trans VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans VWO", "using VWO"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n\ngoal (1 subgoal):\n 1. trans VWO", "by (simp add: VWO wo_rel.TRANS wo_rel_def)"], ["", "lemma antisym_VWO: \"antisym VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisym VWO", "using VWO"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n\ngoal (1 subgoal):\n 1. antisym VWO", "by (simp add: VWO wo_rel.ANTISYM wo_rel_def)"], ["", "lemma total_VWO: \"total VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total VWO", "using VWO"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n\ngoal (1 subgoal):\n 1. total VWO", "by (metis wo_rel.TOTAL wo_rel.intro)"], ["", "lemma total_VWOId: \"total (VWO-Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total (VWO - Id)", "by (simp add: total_VWO)"], ["", "lemma Linear_order_VWO: \"Linear_order VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order VWO", "using VWO well_order_on_def"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n  well_order_on ?A ?r \\<equiv> linear_order_on ?A ?r \\<and> wf (?r - Id)\n\ngoal (1 subgoal):\n 1. Linear_order VWO", "by blast"], ["", "lemma wo_rel_VWO: \"wo_rel VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wo_rel VWO", "using VWO wo_rel_def"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n  wo_rel ?r \\<equiv> Well_order ?r\n\ngoal (1 subgoal):\n 1. wo_rel VWO", "by blast"], ["", "subsubsection \\<open>Transitive Closure and VWO\\<close>"], ["", "lemma mem_imp_VWO: \"x \\<in> elts y \\<Longrightarrow> (x,y) \\<in> VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts y \\<Longrightarrow> (x, y) \\<in> VWO", "using VWO"], ["proof (prove)\nusing this:\n  {(x, y). x \\<in> elts y} \\<subseteq> VWO \\<and>\n  Well_order VWO \\<and> Field VWO = UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> elts y \\<Longrightarrow> (x, y) \\<in> VWO", "by blast"], ["", "lemma less_TC_imp_VWO: \"x \\<sqsubset> y \\<Longrightarrow> (x,y) \\<in> VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubset> y \\<Longrightarrow> (x, y) \\<in> VWO", "unfolding less_TC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts (TC y) \\<Longrightarrow> (x, y) \\<in> VWO", "proof (induction y arbitrary: x rule: eps_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>y xa.\n                   \\<lbrakk>y \\<in> elts x; xa \\<in> elts (TC y)\\<rbrakk>\n                   \\<Longrightarrow> (xa, y) \\<in> VWO;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> (xa, x) \\<in> VWO", "case (step y' u)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> elts y'; ?x \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWO\n  u \\<in> elts (TC y')\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>y xa.\n                   \\<lbrakk>y \\<in> elts x; xa \\<in> elts (TC y)\\<rbrakk>\n                   \\<Longrightarrow> (xa, y) \\<in> VWO;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> (xa, x) \\<in> VWO", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y \\<in> elts y'; ?x \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWO\n  u \\<in> elts (TC y')", "consider \"u \\<in> elts y'\" | v where \"v \\<in> elts y'\" \"u \\<in> elts (TC v)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> elts y'; ?x \\<in> elts (TC ?y)\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> VWO\n  u \\<in> elts (TC y')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> elts y' \\<Longrightarrow> thesis;\n     \\<And>v.\n        \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: TC [of y'])"], ["proof (state)\nthis:\n  \\<lbrakk>u \\<in> elts y' \\<Longrightarrow> ?thesis;\n   \\<And>v.\n      \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>y xa.\n                   \\<lbrakk>y \\<in> elts x; xa \\<in> elts (TC y)\\<rbrakk>\n                   \\<Longrightarrow> (xa, y) \\<in> VWO;\n        xa \\<in> elts (TC x)\\<rbrakk>\n       \\<Longrightarrow> (xa, x) \\<in> VWO", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>u \\<in> elts y' \\<Longrightarrow> ?thesis;\n   \\<And>v.\n      \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> elts y' \\<Longrightarrow> ?thesis;\n   \\<And>v.\n      \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (u, y') \\<in> VWO", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> elts y' \\<Longrightarrow> (u, y') \\<in> VWO\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n       \\<Longrightarrow> (u, y') \\<in> VWO", "case 2"], ["proof (state)\nthis:\n  v \\<in> elts y'\n  u \\<in> elts (TC v)\n\ngoal (2 subgoals):\n 1. u \\<in> elts y' \\<Longrightarrow> (u, y') \\<in> VWO\n 2. \\<And>v.\n       \\<lbrakk>v \\<in> elts y'; u \\<in> elts (TC v)\\<rbrakk>\n       \\<Longrightarrow> (u, y') \\<in> VWO", "then"], ["proof (chain)\npicking this:\n  v \\<in> elts y'\n  u \\<in> elts (TC v)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> elts y'\n  u \\<in> elts (TC v)\n\ngoal (1 subgoal):\n 1. (u, y') \\<in> VWO", "by (meson mem_imp_VWO step.IH transD trans_VWO)"], ["proof (state)\nthis:\n  (u, y') \\<in> VWO\n\ngoal (1 subgoal):\n 1. u \\<in> elts y' \\<Longrightarrow> (u, y') \\<in> VWO", "qed (use mem_imp_VWO in blast)"], ["proof (state)\nthis:\n  (u, y') \\<in> VWO\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_TC_imp_VWO: \"x \\<sqsubseteq> y \\<Longrightarrow> (x,y) \\<in> VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow> (x, y) \\<in> VWO", "apply (auto simp: le_TC_def less_TC_imp_VWO)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> (y, y) \\<in> VWO", "by (metis Diff_iff Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO)"], ["", "lemma le_TC_0_iff [simp]: \"x \\<sqsubseteq> 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqsubseteq> 0) = (x = 0)", "by (simp add: le_TC_def)"], ["", "lemma less_TC_succ: \" x \\<sqsubset> succ \\<beta> \\<longleftrightarrow> x \\<sqsubset> \\<beta> \\<or> x = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqsubset> ZFC_in_HOL.succ \\<beta>) =\n    (x \\<sqsubset> \\<beta> \\<or> x = \\<beta>)", "by (metis elts_succ insert_iff le_TC_def less_TC_iff)"], ["", "lemma le_TC_succ: \"x \\<sqsubseteq> succ \\<beta> \\<longleftrightarrow> x \\<sqsubseteq> \\<beta> \\<or> x = succ \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqsubseteq> ZFC_in_HOL.succ \\<beta>) =\n    (x \\<sqsubseteq> \\<beta> \\<or> x = ZFC_in_HOL.succ \\<beta>)", "by (simp add: le_TC_def less_TC_succ)"], ["", "lemma Transset_TC_eq [simp]: \"Transset x \\<Longrightarrow> TC x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset x \\<Longrightarrow> TC x = x", "by (simp add: TC_least arg_subset_TC eq_iff)"], ["", "lemma Ord_TC_less_iff: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> \\<beta> \\<sqsubset> \\<alpha> \\<longleftrightarrow> \\<beta> < \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk>\n    \\<Longrightarrow> (\\<beta> \\<sqsubset> \\<alpha>) = (\\<beta> < \\<alpha>)", "by (metis Ord_def Ord_mem_iff_lt Transset_TC_eq less_TC_def)"], ["", "lemma Ord_mem_iff_less_TC: \"Ord l \\<Longrightarrow> k \\<in> elts l \\<longleftrightarrow> k \\<sqsubset> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord l \\<Longrightarrow> (k \\<in> elts l) = (k \\<sqsubset> l)", "by (simp add: Ord_def less_TC_def)"], ["", "lemma le_TC_Ord: \"\\<lbrakk>\\<beta> \\<sqsubseteq> \\<alpha>; Ord \\<alpha>\\<rbrakk> \\<Longrightarrow> Ord \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<beta> \\<sqsubseteq> \\<alpha>; Ord \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> Ord \\<beta>", "by (metis Ord_def Ord_in_Ord Transset_TC_eq le_TC_def less_TC_def)"], ["", "lemma Ord_less_TC_mem:\n  assumes \"Ord \\<alpha>\" \"\\<beta> \\<sqsubset> \\<alpha>\" shows \"\\<beta> \\<in> elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> \\<in> elts \\<alpha>", "using Ord_def assms less_TC_def"], ["proof (prove)\nusing this:\n  Ord ?x \\<equiv> Transset ?x \\<and> (\\<forall>y\\<in>elts ?x. Transset y)\n  Ord \\<alpha>\n  \\<beta> \\<sqsubset> \\<alpha>\n  ?x \\<sqsubset> ?y \\<equiv> ?x \\<in> elts (TC ?y)\n\ngoal (1 subgoal):\n 1. \\<beta> \\<in> elts \\<alpha>", "by auto"], ["", "lemma VWO_TC_le: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>; (\\<beta>, \\<alpha>) \\<in> VWO\\<rbrakk> \\<Longrightarrow> \\<beta> \\<sqsubseteq> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>;\n     (\\<beta>, \\<alpha>) \\<in> VWO\\<rbrakk>\n    \\<Longrightarrow> \\<beta> \\<sqsubseteq> \\<alpha>", "proof (induct \\<alpha> arbitrary: \\<beta> rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<beta>.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<beta>.\n           \\<lbrakk>y \\<in> elts x; Ord \\<beta>;\n            (\\<beta>, y) \\<in> VWO\\<rbrakk>\n           \\<Longrightarrow> \\<beta> \\<sqsubseteq> y;\n        Ord \\<beta>; (\\<beta>, x) \\<in> VWO\\<rbrakk>\n       \\<Longrightarrow> \\<beta> \\<sqsubseteq> x", "case (step \\<alpha>)"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>; Ord ?\\<beta>;\n   (?\\<beta>, ?y) \\<in> VWO\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<sqsubseteq> ?y\n  Ord \\<beta>\n  (\\<beta>, \\<alpha>) \\<in> VWO\n\ngoal (1 subgoal):\n 1. \\<And>x \\<beta>.\n       \\<lbrakk>Ord x;\n        \\<And>y \\<beta>.\n           \\<lbrakk>y \\<in> elts x; Ord \\<beta>;\n            (\\<beta>, y) \\<in> VWO\\<rbrakk>\n           \\<Longrightarrow> \\<beta> \\<sqsubseteq> y;\n        Ord \\<beta>; (\\<beta>, x) \\<in> VWO\\<rbrakk>\n       \\<Longrightarrow> \\<beta> \\<sqsubseteq> x", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>; Ord ?\\<beta>;\n   (?\\<beta>, ?y) \\<in> VWO\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<sqsubseteq> ?y\n  Ord \\<beta>\n  (\\<beta>, \\<alpha>) \\<in> VWO", "show ?case"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  \\<lbrakk>?y \\<in> elts \\<alpha>; Ord ?\\<beta>;\n   (?\\<beta>, ?y) \\<in> VWO\\<rbrakk>\n  \\<Longrightarrow> ?\\<beta> \\<sqsubseteq> ?y\n  Ord \\<beta>\n  (\\<beta>, \\<alpha>) \\<in> VWO\n\ngoal (1 subgoal):\n 1. \\<beta> \\<sqsubseteq> \\<alpha>", "by (metis Diff_iff Linear_order_VWO Linear_order_in_diff_Id Ord_TC_less_iff Ord_linear2 UNIV_I VWO le_TC_def le_less less_TC_imp_VWO pair_in_Id_conv)"], ["proof (state)\nthis:\n  \\<beta> \\<sqsubseteq> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma VWO_iff_Ord_le [simp]: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> (\\<beta>, \\<alpha>) \\<in> VWO \\<longleftrightarrow> \\<beta> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk>\n    \\<Longrightarrow> ((\\<beta>, \\<alpha>) \\<in> VWO) =\n                      (\\<beta> \\<le> \\<alpha>)", "by (metis VWO_TC_le Ord_TC_less_iff le_TC_def le_TC_imp_VWO le_less)"], ["", "lemma zero_TC_le [iff]: \"0 \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<sqsubseteq> y", "using le_TC_def nonzero_less_TC"], ["proof (prove)\nusing this:\n  ?x \\<sqsubseteq> ?y \\<equiv> ?x \\<sqsubset> ?y \\<or> ?x = ?y\n  ?x \\<noteq> 0 \\<Longrightarrow> 0 \\<sqsubset> ?x\n\ngoal (1 subgoal):\n 1. 0 \\<sqsubseteq> y", "by auto"], ["", "lemma succ_le_TC_iff: \"Ord j \\<Longrightarrow> succ i \\<sqsubseteq> j \\<longleftrightarrow> i \\<sqsubset> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord j \\<Longrightarrow>\n    (ZFC_in_HOL.succ i \\<sqsubseteq> j) = (i \\<sqsubset> j)", "by (metis Ord_in_Ord Ord_linear Ord_mem_iff_less_TC Ord_succ le_TC_def less_TC_succ less_asym_TC)"], ["", "lemma VWO_0_iff [simp]: \"(x,0) \\<in> VWO \\<longleftrightarrow> x=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, 0) \\<in> VWO) = (x = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, 0) \\<in> VWO \\<Longrightarrow> x = 0\n 2. x = 0 \\<Longrightarrow> (x, 0) \\<in> VWO", "show \"x = 0\" if \"(x, 0) \\<in> VWO\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "using zero_TC_le [of x] le_TC_imp_VWO that"], ["proof (prove)\nusing this:\n  0 \\<sqsubseteq> x\n  ?x \\<sqsubseteq> ?y \\<Longrightarrow> (?x, ?y) \\<in> VWO\n  (x, 0) \\<in> VWO\n\ngoal (1 subgoal):\n 1. x = 0", "by (metis DiffI Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO pair_in_Id_conv)"], ["proof (state)\nthis:\n  (x, 0) \\<in> VWO \\<Longrightarrow> x = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> (x, 0) \\<in> VWO", "qed auto"], ["", "lemma VWO_antisym:\n  assumes \"(x,y) \\<in> VWO\" \"(y,x) \\<in> VWO\" shows \"x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (metis Diff_iff IdD Linear_order_VWO Linear_order_in_diff_Id UNIV_I VWO assms)"], ["", "subsubsection \\<open>Relation VWF\\<close>"], ["", "definition VWF where \"VWF \\<equiv> VWO - Id\""], ["", "lemma wf_VWF [iff]: \"wf VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf VWF", "by (simp add: VWF_def wf_VWO)"], ["", "lemma trans_VWF [iff]: \"trans VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans VWF", "by (simp add: VWF_def antisym_VWO trans_VWO trans_diff_Id)"], ["", "lemma asym_VWF [iff]: \"asym VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asym VWF", "by (metis VWF_def asym.intros irrefl_diff_Id wf_VWF wf_not_sym)"], ["", "lemma total_VWF [iff]: \"total VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total VWF", "using VWF_def total_VWOId"], ["proof (prove)\nusing this:\n  VWF \\<equiv> VWO - Id\n  total (VWO - Id)\n\ngoal (1 subgoal):\n 1. total VWF", "by auto"], ["", "lemma total_on_VWF [iff]: \"total_on A VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A VWF", "by (meson UNIV_I total_VWF total_on_def)"], ["", "lemma VWF_asym:\n  assumes \"(x,y) \\<in> VWF\" \"(y,x) \\<in> VWF\" shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using VWF_def assms wf_VWO wf_not_sym"], ["proof (prove)\nusing this:\n  VWF \\<equiv> VWO - Id\n  (x, y) \\<in> VWF\n  (y, x) \\<in> VWF\n  wf (VWO - Id)\n  \\<lbrakk>wf ?r; (?a, ?x) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?a) \\<notin> ?r\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["", "lemma VWF_non_refl [iff]: \"(x,x) \\<notin> VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<notin> VWF", "by simp"], ["", "lemma VWF_iff_Ord_less [simp]: \"\\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk> \\<Longrightarrow> (\\<alpha>,\\<beta>) \\<in> VWF \\<longleftrightarrow> \\<alpha> < \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord \\<alpha>; Ord \\<beta>\\<rbrakk>\n    \\<Longrightarrow> ((\\<alpha>, \\<beta>) \\<in> VWF) = (\\<alpha> < \\<beta>)", "by (simp add: VWF_def less_V_def)"], ["", "lemma mem_imp_VWF: \"x \\<in> elts y \\<Longrightarrow> (x,y) \\<in> VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> elts y \\<Longrightarrow> (x, y) \\<in> VWF", "using VWF_def mem_imp_VWO"], ["proof (prove)\nusing this:\n  VWF \\<equiv> VWO - Id\n  ?x \\<in> elts ?y \\<Longrightarrow> (?x, ?y) \\<in> VWO\n\ngoal (1 subgoal):\n 1. x \\<in> elts y \\<Longrightarrow> (x, y) \\<in> VWF", "by fastforce"], ["", "subsection\\<open>Order types\\<close>"], ["", "definition ordermap :: \"'a set \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> V\"\n  where \"ordermap A r \\<equiv> wfrec r (\\<lambda>f x. set (f ` {y \\<in> A. (y,x) \\<in> r}))\""], ["", "definition ordertype :: \"'a set \\<Rightarrow> ('a \\<times> 'a) set \\<Rightarrow> V\"\n  where \"ordertype A r \\<equiv> set (ordermap A r ` A)\""], ["", "lemma ordermap_type:\n    \"small A \\<Longrightarrow> ordermap A r \\<in> A \\<rightarrow> elts (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A \\<Longrightarrow>\n    ordermap A r \\<in> A \\<rightarrow> elts (ordertype A r)", "by (simp add: ordertype_def)"], ["", "lemma ordermap_in_ordertype [intro]: \"\\<lbrakk>a \\<in> A; small A\\<rbrakk> \\<Longrightarrow> ordermap A r a \\<in> elts (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> A; small A\\<rbrakk>\n    \\<Longrightarrow> ordermap A r a \\<in> elts (ordertype A r)", "by (simp add: ordertype_def)"], ["", "lemma ordermap: \"wf r \\<Longrightarrow> ordermap A r a = set (ordermap A r ` {y \\<in> A. (y,a) \\<in> r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf r \\<Longrightarrow>\n    ordermap A r a = set (ordermap A r ` {y \\<in> A. (y, a) \\<in> r})", "unfolding ordermap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf r \\<Longrightarrow>\n    wfrec r (\\<lambda>f x. set (f ` {y \\<in> A. (y, x) \\<in> r})) a =\n    set (wfrec r (\\<lambda>f x. set (f ` {y \\<in> A. (y, x) \\<in> r})) `\n         {y \\<in> A. (y, a) \\<in> r})", "by (auto simp: wfrec_fixpoint adm_wf_def)"], ["", "lemma Ord_ordermap [iff]: assumes \"wf r\" \"trans r\" shows \"Ord (ordermap A r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordermap A r x)", "using \\<open>wf r\\<close>"], ["proof (prove)\nusing this:\n  wf r\n\ngoal (1 subgoal):\n 1. Ord (ordermap A r x)", "proof (induction x rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           Ord (ordermap A r y)) \\<Longrightarrow>\n       Ord (ordermap A r x)", "case (less u)"], ["proof (state)\nthis:\n  (?y, u) \\<in> r \\<Longrightarrow> Ord (ordermap A r ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           Ord (ordermap A r y)) \\<Longrightarrow>\n       Ord (ordermap A r x)", "have \"Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))", "proof (clarsimp simp add: Transset_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>small (ordermap A r ` {y \\<in> A. (y, u) \\<in> r});\n        x \\<in> elts (ordermap A r y); y \\<in> A; (y, u) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "show \"x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}\"\n      if \"small (ordermap A r ` {y \\<in> A. (y, u) \\<in> r})\"\n        and x: \"x \\<in> elts (ordermap A r y)\" and \"y \\<in> A\" \"(y, u) \\<in> r\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "have \"ordermap A r y = ZFC_in_HOL.set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r y = set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})", "using ordermap assms(1)"], ["proof (prove)\nusing this:\n  wf ?r \\<Longrightarrow>\n  ordermap ?A ?r ?a = set (ordermap ?A ?r ` {y \\<in> ?A. (y, ?a) \\<in> ?r})\n  wf r\n\ngoal (1 subgoal):\n 1. ordermap A r y = set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})", "by force"], ["proof (state)\nthis:\n  ordermap A r y = set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})\n\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "then"], ["proof (chain)\npicking this:\n  ordermap A r y = set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})", "have \"x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}\""], ["proof (prove)\nusing this:\n  ordermap A r y = set (ordermap A r ` {a \\<in> A. (a, y) \\<in> r})\n\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}", "by (metis (no_types, lifting) elts_of_set empty_iff x)"], ["proof (state)\nthis:\n  x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}\n\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "then"], ["proof (chain)\npicking this:\n  x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}", "have \"\\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v\""], ["proof (prove)\nusing this:\n  x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v", "using that transD [OF \\<open>trans r\\<close>]"], ["proof (prove)\nusing this:\n  x \\<in> ordermap A r ` {z \\<in> A. (z, y) \\<in> r}\n  small (ordermap A r ` {y \\<in> A. (y, u) \\<in> r})\n  x \\<in> elts (ordermap A r y)\n  y \\<in> A\n  (y, u) \\<in> r\n  \\<lbrakk>(?x, ?y) \\<in> r; (?y, ?z) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v", "by blast"], ["proof (state)\nthis:\n  \\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v\n\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<in> A \\<and> (v, u) \\<in> r \\<and> x = ordermap A r v\n\ngoal (1 subgoal):\n 1. x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}", "by blast"], ["proof (state)\nthis:\n  x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>small (ordermap A r ` {y \\<in> A. (y, u) \\<in> r});\n   ?x \\<in> elts (ordermap A r ?y); ?y \\<in> A; (?y, u) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ordermap A r ` {y \\<in> A. (y, u) \\<in> r}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           Ord (ordermap A r y)) \\<Longrightarrow>\n       Ord (ordermap A r x)", "moreover"], ["proof (state)\nthis:\n  Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           Ord (ordermap A r y)) \\<Longrightarrow>\n       Ord (ordermap A r x)", "have \"Ord x\"\n    if \"x \\<in> elts (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord x", "using that less"], ["proof (prove)\nusing this:\n  x \\<in> elts (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\n  (?y, u) \\<in> r \\<Longrightarrow> Ord (ordermap A r ?y)\n\ngoal (1 subgoal):\n 1. Ord x", "by (auto simp: split: if_split_asm)"], ["proof (state)\nthis:\n  ?x \\<in> elts\n            (set (ordermap A r `\n                  {y \\<in> A. (y, u) \\<in> r})) \\<Longrightarrow>\n  Ord ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           Ord (ordermap A r y)) \\<Longrightarrow>\n       Ord (ordermap A r x)", "ultimately"], ["proof (chain)\npicking this:\n  Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\n  ?x \\<in> elts\n            (set (ordermap A r `\n                  {y \\<in> A. (y, u) \\<in> r})) \\<Longrightarrow>\n  Ord ?x", "show ?case"], ["proof (prove)\nusing this:\n  Transset (set (ordermap A r ` {y \\<in> A. (y, u) \\<in> r}))\n  ?x \\<in> elts\n            (set (ordermap A r `\n                  {y \\<in> A. (y, u) \\<in> r})) \\<Longrightarrow>\n  Ord ?x\n\ngoal (1 subgoal):\n 1. Ord (ordermap A r u)", "by (metis (full_types) Ord_def ordermap assms(1))"], ["proof (state)\nthis:\n  Ord (ordermap A r u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_Ord_ordertype: assumes \"wf r\" \"trans r\" shows \"Ord(ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "have \"y \\<le> set (ordermap A r ` A)\"\n    if \"y = ordermap A r x\" \"x \\<in> A\" \"small (ordermap A r ` A)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> set (ordermap A r ` A)", "using that"], ["proof (prove)\nusing this:\n  y = ordermap A r x\n  x \\<in> A\n  small (ordermap A r ` A)\n\ngoal (1 subgoal):\n 1. y \\<le> set (ordermap A r ` A)", "by (auto simp: less_eq_V_def ordermap [OF \\<open>wf r\\<close>, of A x])"], ["proof (state)\nthis:\n  \\<lbrakk>?y = ordermap A r ?x; ?x \\<in> A;\n   small (ordermap A r ` A)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> set (ordermap A r ` A)\n\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?y = ordermap A r ?x; ?x \\<in> A;\n   small (ordermap A r ` A)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> set (ordermap A r ` A)\n\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "have \"z \\<le> y\" if \"y \\<in> ordermap A r ` A\" \"z \\<in> elts y\" for y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y", "by (metis Ord_ordermap OrdmemD assms imageE order.strict_implies_order that)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> ordermap A r ` A; ?z \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<le> ?y\n\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y = ordermap A r ?x; ?x \\<in> A;\n   small (ordermap A r ` A)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> set (ordermap A r ` A)\n  \\<lbrakk>?y \\<in> ordermap A r ` A; ?z \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<le> ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = ordermap A r ?x; ?x \\<in> A;\n   small (ordermap A r ` A)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> set (ordermap A r ` A)\n  \\<lbrakk>?y \\<in> ordermap A r ` A; ?z \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<le> ?y\n\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "unfolding ordertype_def Ord_def Transset_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = ordermap A r ?x; ?x \\<in> A;\n   small (ordermap A r ` A)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> set (ordermap A r ` A)\n  \\<lbrakk>?y \\<in> ordermap A r ` A; ?z \\<in> elts ?y\\<rbrakk>\n  \\<Longrightarrow> ?z \\<le> ?y\n\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>elts (set (ordermap A r ` A)).\n        y \\<le> set (ordermap A r ` A)) \\<and>\n    (\\<forall>y\\<in>elts (set (ordermap A r ` A)).\n        \\<forall>ya\\<in>elts y. ya \\<le> y)", "by simp"], ["proof (state)\nthis:\n  Ord (ordertype A r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ord_ordertype [simp]: \"Ord(ordertype A VWF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordertype A VWF)", "using wf_Ord_ordertype"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf ?r; trans ?r\\<rbrakk> \\<Longrightarrow> Ord (ordertype ?A ?r)\n\ngoal (1 subgoal):\n 1. Ord (ordertype A VWF)", "by blast"], ["", "lemma ordertype_singleton [simp]:\n  assumes \"wf r\" \n  shows \"ordertype {x} r = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {x} r = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype {x} r = 1", "have \\<dagger>: \"{y. y = x \\<and> (y, x) \\<in> r} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y = x \\<and> (y, x) \\<in> r} = {}", "using assms"], ["proof (prove)\nusing this:\n  wf r\n\ngoal (1 subgoal):\n 1. {y. y = x \\<and> (y, x) \\<in> r} = {}", "by auto"], ["proof (state)\nthis:\n  {y. y = x \\<and> (y, x) \\<in> r} = {}\n\ngoal (1 subgoal):\n 1. ordertype {x} r = 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {x} r = 1", "by (auto simp add: ordertype_def assms \\<dagger> ordermap [where a=x])"], ["proof (state)\nthis:\n  ordertype {x} r = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>@{term ordermap} preserves the orderings in both directions\\<close>"], ["", "lemma ordermap_mono:\n  assumes wx: \"(w, x) \\<in> r\" and \"wf r\" \"w \\<in> A\" \"small A\"\n    shows \"ordermap A r w \\<in> elts (ordermap A r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r w \\<in> elts (ordermap A r x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordermap A r w \\<in> elts (ordermap A r x)", "have \"small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r", "by (simp add: assms)"], ["proof (state)\nthis:\n  small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r\n\ngoal (1 subgoal):\n 1. ordermap A r w \\<in> elts (ordermap A r x)", "then"], ["proof (chain)\npicking this:\n  small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r", "show ?thesis"], ["proof (prove)\nusing this:\n  small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r\n\ngoal (1 subgoal):\n 1. ordermap A r w \\<in> elts (ordermap A r x)", "using assms ordermap [of r A]"], ["proof (prove)\nusing this:\n  small {a \\<in> A. (a, x) \\<in> r} \\<and> w \\<in> A \\<and> (w, x) \\<in> r\n  (w, x) \\<in> r\n  wf r\n  w \\<in> A\n  small A\n  wf r \\<Longrightarrow>\n  ordermap A r ?a = set (ordermap A r ` {y \\<in> A. (y, ?a) \\<in> r})\n\ngoal (1 subgoal):\n 1. ordermap A r w \\<in> elts (ordermap A r x)", "by (metis (no_types, lifting) elts_of_set image_eqI mem_Collect_eq replacement)"], ["proof (state)\nthis:\n  ordermap A r w \\<in> elts (ordermap A r x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma converse_ordermap_mono:\n  assumes \"ordermap A r y \\<in> elts (ordermap A r x)\" \"wf r\" \"total_on A r\" \"x \\<in> A\" \"y \\<in> A\" \"small A\"\n  shows \"(y, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (y, x) \\<in> r\n 2. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (y, x) \\<in> r\n 2. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "then"], ["proof (chain)\npicking this:\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using assms(1) mem_not_refl"], ["proof (prove)\nusing this:\n  x = y\n  ordermap A r y \\<in> elts (ordermap A r x)\n  ?i \\<notin> elts ?i\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by blast"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "consider \"(x,y) \\<in> r\" | \"(y,x) \\<in> r\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> r \\<Longrightarrow> thesis;\n     (y, x) \\<in> r \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>total_on A r\\<close> assms"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  total_on A r\n  ordermap A r y \\<in> elts (ordermap A r x)\n  wf r\n  total_on A r\n  x \\<in> A\n  y \\<in> A\n  small A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> r \\<Longrightarrow> thesis;\n     (y, x) \\<in> r \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (meson UNIV_I total_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> r \\<Longrightarrow> ?thesis;\n   (y, x) \\<in> r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (y, x) \\<in> r", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x, y) \\<in> r \\<Longrightarrow> ?thesis;\n   (y, x) \\<in> r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) \\<in> r \\<Longrightarrow> ?thesis;\n   (y, x) \\<in> r \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by (meson ordermap_mono assms mem_not_sym)"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordermap_surj: \"elts (ordertype A r) \\<subseteq> ordermap A r ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ordertype A r) \\<subseteq> ordermap A r ` A", "unfolding ordertype_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (set (ordermap A r ` A)) \\<subseteq> ordermap A r ` A", "by simp"], ["", "lemma ordermap_bij:\n  assumes \"wf r\" \"total_on A r\" \"small A\"\n  shows \"bij_betw (ordermap A r) A (elts (ordertype A r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (ordermap A r) A \\<and> ordermap A r ` A = elts (ordertype A r)", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (ordermap A r) A\n 2. ordermap A r ` A = elts (ordertype A r)", "show \"inj_on (ordermap A r) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (ordermap A r) A", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A.\n          ordermap A r x = ordermap A r y \\<longrightarrow> x = y", "by (metis assms mem_not_refl ordermap_mono total_on_def)"], ["proof (state)\nthis:\n  inj_on (ordermap A r) A\n\ngoal (1 subgoal):\n 1. ordermap A r ` A = elts (ordertype A r)", "show \"ordermap A r ` A = elts (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r ` A = elts (ordertype A r)", "by (metis ordertype_def \\<open>small A\\<close> elts_of_set replacement)"], ["proof (state)\nthis:\n  ordermap A r ` A = elts (ordertype A r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordermap_eq_iff [simp]: \n  \"\\<lbrakk>x \\<in> A; y \\<in> A; wf r; total_on A r; small A\\<rbrakk> \\<Longrightarrow> ordermap A r x = ordermap A r y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; y \\<in> A; wf r; total_on A r; small A\\<rbrakk>\n    \\<Longrightarrow> (ordermap A r x = ordermap A r y) = (x = y)", "by (metis bij_betw_iff_bijections ordermap_bij)"], ["", "lemma inv_into_ordermap: \"\\<alpha> \\<in> elts (ordertype A r) \\<Longrightarrow> inv_into A (ordermap A r) \\<alpha> \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> elts (ordertype A r) \\<Longrightarrow>\n    inv_into A (ordermap A r) \\<alpha> \\<in> A", "by (meson in_mono inv_into_into ordermap_surj)"], ["", "lemma ordertype_nat_imp_finite:\n  assumes \"ordertype A r = ord_of_nat m\" \"small A\" \"wf r\" \"total_on A r\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A", "have \"A \\<approx> elts m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<approx> elts (ord_of_nat m)", "using eqpoll_def assms ordermap_bij"], ["proof (prove)\nusing this:\n  ?A \\<approx> ?B \\<equiv> \\<exists>f. bij_betw f ?A ?B\n  ordertype A r = ord_of_nat m\n  small A\n  wf r\n  total_on A r\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n\ngoal (1 subgoal):\n 1. A \\<approx> elts (ord_of_nat m)", "by fastforce"], ["proof (state)\nthis:\n  A \\<approx> elts (ord_of_nat m)\n\ngoal (1 subgoal):\n 1. finite A", "then"], ["proof (chain)\npicking this:\n  A \\<approx> elts (ord_of_nat m)", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<approx> elts (ord_of_nat m)\n\ngoal (1 subgoal):\n 1. finite A", "using eqpoll_finite_iff finite_Ord_omega"], ["proof (prove)\nusing this:\n  A \\<approx> elts (ord_of_nat m)\n  ?A \\<approx> ?B \\<Longrightarrow> finite ?A = finite ?B\n  ?\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. finite A", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_ordertype_eqpoll:\n  assumes \"wf r\" \"total_on A r\" \"small A\"\n  shows \"elts (ordertype A r) \\<approx> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ordertype A r) \\<approx> A", "using assms eqpoll_def eqpoll_sym ordermap_bij"], ["proof (prove)\nusing this:\n  wf r\n  total_on A r\n  small A\n  ?A \\<approx> ?B \\<equiv> \\<exists>f. bij_betw f ?A ?B\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n\ngoal (1 subgoal):\n 1. elts (ordertype A r) \\<approx> A", "by blast"], ["", "lemma ordertype_eqpoll:\n  assumes \"small A\"\n  shows \"elts (ordertype A VWF) \\<approx> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ordertype A VWF) \\<approx> A", "using assms wf_ordertype_eqpoll total_VWF wf_VWF"], ["proof (prove)\nusing this:\n  small A\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> elts (ordertype ?A ?r) \\<approx> ?A\n  total VWF\n  wf VWF\n\ngoal (1 subgoal):\n 1. elts (ordertype A VWF) \\<approx> A", "by (simp add: wf_ordertype_eqpoll total_on_def)"], ["", "subsection \\<open>More advanced @{term ordertype} and @{term ordermap} results\\<close>"], ["", "lemma ordermap_VWF_0 [simp]: \"ordermap A VWF 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A VWF 0 = 0", "by (simp add: ordermap wf_VWO VWF_def)"], ["", "lemma ordertype_empty [simp]: \"ordertype {} r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype {} r = 0", "by (simp add: ordertype_def)"], ["", "lemma ordertype_eq_0_iff [simp]: \"\\<lbrakk>small X; wf r\\<rbrakk> \\<Longrightarrow> ordertype X r = 0 \\<longleftrightarrow> X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>small X; wf r\\<rbrakk>\n    \\<Longrightarrow> (ordertype X r = 0) = (X = {})", "by (metis ordertype_def elts_of_set replacement image_is_empty zero_V_def)"], ["", "lemma ordermap_mono_less:\n  assumes \"(w, x) \\<in> r\"\n      and \"wf r\" \"trans r\"\n      and \"w \\<in> A\" \"x \\<in> A\"\n      and \"small A\"\n    shows \"ordermap A r w < ordermap A r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r w < ordermap A r x", "by (simp add: OrdmemD assms ordermap_mono)"], ["", "lemma ordermap_mono_le:\n  assumes \"(w, x) \\<in> r \\<or> w=x\"\n      and \"wf r\" \"trans r\"\n      and \"w \\<in> A\" \"x \\<in> A\"\n      and \"small A\"\n    shows \"ordermap A r w \\<le> ordermap A r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r w \\<le> ordermap A r x", "by (metis assms dual_order.strict_implies_order eq_refl ordermap_mono_less)"], ["", "lemma converse_ordermap_le_mono:\n  assumes \"ordermap A r y \\<le> ordermap A r x\" \"wf r\" \"total r\"  \"x \\<in> A\" \"small A\"\n  shows \"(y, x) \\<in> r \\<or> y=x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<or> y = x", "by (meson UNIV_I assms mem_not_refl ordermap_mono total_on_def vsubsetD)"], ["", "lemma ordertype_mono:\n  assumes \"X \\<subseteq> Y\" and r: \"wf r\" \"trans r\" and \"small Y\"\n  shows \"ordertype X r \\<le> ordertype Y r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "have \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "using assms smaller_than_small"], ["proof (prove)\nusing this:\n  X \\<subseteq> Y\n  wf r\n  trans r\n  small Y\n  \\<lbrakk>small ?A; ?B \\<subseteq> ?A\\<rbrakk> \\<Longrightarrow> small ?B\n\ngoal (1 subgoal):\n 1. small X", "by fastforce"], ["proof (state)\nthis:\n  small X\n\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "have *: \"ordermap X r x \\<le> ordermap Y r x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap X r x \\<le> ordermap Y r x", "using \\<open>wf r\\<close>"], ["proof (prove)\nusing this:\n  wf r\n\ngoal (1 subgoal):\n 1. ordermap X r x \\<le> ordermap Y r x", "proof (induction x rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           ordermap X r y \\<le> ordermap Y r y) \\<Longrightarrow>\n       ordermap X r x \\<le> ordermap Y r x", "case (less x)"], ["proof (state)\nthis:\n  (?y, x) \\<in> r \\<Longrightarrow> ordermap X r ?y \\<le> ordermap Y r ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           ordermap X r y \\<le> ordermap Y r y) \\<Longrightarrow>\n       ordermap X r x \\<le> ordermap Y r x", "have \"ordermap X r z < ordermap Y r x\" if \"z \\<in> X\" and zx: \"(z,x) \\<in> r\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap X r z < ordermap Y r x", "using less [OF zx] assms"], ["proof (prove)\nusing this:\n  ordermap X r z \\<le> ordermap Y r z\n  X \\<subseteq> Y\n  wf r\n  trans r\n  small Y\n\ngoal (1 subgoal):\n 1. ordermap X r z < ordermap Y r x", "by (meson Ord_linear2 OrdmemD Ord_ordermap ordermap_mono in_mono leD that(1) vsubsetD zx)"], ["proof (state)\nthis:\n  \\<lbrakk>?z \\<in> X; (?z, x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ordermap X r ?z < ordermap Y r x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> r \\<Longrightarrow>\n           ordermap X r y \\<le> ordermap Y r y) \\<Longrightarrow>\n       ordermap X r x \\<le> ordermap Y r x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?z \\<in> X; (?z, x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ordermap X r ?z < ordermap Y r x", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z \\<in> X; (?z, x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ordermap X r ?z < ordermap Y r x\n\ngoal (1 subgoal):\n 1. ordermap X r x \\<le> ordermap Y r x", "by (auto simp add: ordermap [of _ X x] \\<open>small X\\<close> Ord_mem_iff_lt set_image_le_iff less_eq_V_def r)"], ["proof (state)\nthis:\n  ordermap X r x \\<le> ordermap Y r x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordermap X r ?x \\<le> ordermap Y r ?x\n\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "have \"ordermap Y r ` Y = elts (ordertype Y r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap Y r ` Y = elts (ordertype Y r)", "by (metis ordertype_def \\<open>small Y\\<close> elts_of_set replacement)"], ["proof (state)\nthis:\n  ordermap Y r ` Y = elts (ordertype Y r)\n\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "then"], ["proof (chain)\npicking this:\n  ordermap Y r ` Y = elts (ordertype Y r)", "have \"ordertype Y r \\<notin> ordermap X r ` X\""], ["proof (prove)\nusing this:\n  ordermap Y r ` Y = elts (ordertype Y r)\n\ngoal (1 subgoal):\n 1. ordertype Y r \\<notin> ordermap X r ` X", "using \"*\" \\<open>X \\<subseteq> Y\\<close>"], ["proof (prove)\nusing this:\n  ordermap Y r ` Y = elts (ordertype Y r)\n  ordermap X r ?x \\<le> ordermap Y r ?x\n  X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ordertype Y r \\<notin> ordermap X r ` X", "by fastforce"], ["proof (state)\nthis:\n  ordertype Y r \\<notin> ordermap X r ` X\n\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "then"], ["proof (chain)\npicking this:\n  ordertype Y r \\<notin> ordermap X r ` X", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype Y r \\<notin> ordermap X r ` X\n\ngoal (1 subgoal):\n 1. ordertype X r \\<le> ordertype Y r", "by (metis Ord_linear2 Ord_mem_iff_lt ordertype_def wf_Ord_ordertype \\<open>small X\\<close> elts_of_set replacement r)"], ["proof (state)\nthis:\n  ordertype X r \\<le> ordertype Y r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ordertype X r \\<le> ordertype Y r\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ordertype_VWF_mono:\n  assumes \"X \\<subseteq> Y\" \"small Y\"\n  shows \"ordertype X VWF \\<le> ordertype Y VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype X VWF \\<le> ordertype Y VWF", "using assms"], ["proof (prove)\nusing this:\n  X \\<subseteq> Y\n  small Y\n\ngoal (1 subgoal):\n 1. ordertype X VWF \\<le> ordertype Y VWF", "by (simp add: ordertype_mono)"], ["", "lemma ordertype_UNION_ge:\n  assumes \"A \\<in> \\<A>\" \"wf r\" \"trans r\" \"\\<A> \\<subseteq> Collect small\" \"small \\<A>\"\n  shows \"ordertype A r \\<le> ordertype (\\<Union>\\<A>) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ordertype (\\<Union> \\<A>) r", "by (rule ordertype_mono) (use assms in auto)"], ["", "lemma inv_ordermap_mono_less:\n  assumes \"(inv_into M (ordermap M r) \\<alpha>, inv_into M (ordermap M r) \\<beta>) \\<in> r\" \n    and \"small M\" and \\<alpha>: \"\\<alpha> \\<in> elts (ordertype M r)\" and \\<beta>: \"\\<beta> \\<in> elts (ordertype M r)\"\n    and \"wf r\" \"trans r\"\n  shows \"\\<alpha> < \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "have \"\\<alpha> = ordermap M r (inv_into M (ordermap M r) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = ordermap M r (inv_into M (ordermap M r) \\<alpha>)", "by (metis \\<alpha> f_inv_into_f ordermap_surj subset_eq)"], ["proof (state)\nthis:\n  \\<alpha> = ordermap M r (inv_into M (ordermap M r) \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "also"], ["proof (state)\nthis:\n  \\<alpha> = ordermap M r (inv_into M (ordermap M r) \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "have \"\\<dots> < ordermap M r (inv_into M (ordermap M r) \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap M r (inv_into M (ordermap M r) \\<alpha>)\n    < ordermap M r (inv_into M (ordermap M r) \\<beta>)", "by (meson \\<alpha> \\<beta> assms in_mono inv_into_into ordermap_mono_less ordermap_surj)"], ["proof (state)\nthis:\n  ordermap M r (inv_into M (ordermap M r) \\<alpha>)\n  < ordermap M r (inv_into M (ordermap M r) \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "also"], ["proof (state)\nthis:\n  ordermap M r (inv_into M (ordermap M r) \\<alpha>)\n  < ordermap M r (inv_into M (ordermap M r) \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "have \"\\<dots> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap M r (inv_into M (ordermap M r) \\<beta>) = \\<beta>", "by (meson \\<beta> f_inv_into_f in_mono ordermap_surj)"], ["proof (state)\nthis:\n  ordermap M r (inv_into M (ordermap M r) \\<beta>) = \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> < \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> < \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> < \\<beta>", "."], ["proof (state)\nthis:\n  \\<alpha> < \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_ordermap_mono_eq:\n  assumes \"inv_into M (ordermap M r) \\<alpha> = inv_into M (ordermap M r) \\<beta>\" \n    and \"\\<alpha> \\<in> elts (ordertype M r)\" \"\\<beta> \\<in> elts (ordertype M r)\"\n  shows \"\\<alpha> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = \\<beta>", "by (metis assms f_inv_into_f ordermap_surj subsetD)"], ["", "lemma inv_ordermap_VWF_mono_le:\n  assumes \"inv_into M (ordermap M VWF) \\<alpha> \\<le> inv_into M (ordermap M VWF) \\<beta>\" \n    and \"M \\<subseteq> ON\" \"small M\" and \\<alpha>: \"\\<alpha> \\<in> elts (ordertype M VWF)\" and \\<beta>: \"\\<beta> \\<in> elts (ordertype M VWF)\"\n  shows \"\\<alpha> \\<le> \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "have \"\\<alpha> = ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)", "by (metis \\<alpha> f_inv_into_f ordermap_surj subset_eq)"], ["proof (state)\nthis:\n  \\<alpha> = ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "also"], ["proof (state)\nthis:\n  \\<alpha> = ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "have \"\\<dots> \\<le> ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\n    \\<le> ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>)", "by (metis ON_imp_Ord VWF_iff_Ord_less assms dual_order.strict_implies_order elts_of_set eq_refl inv_into_into order.not_eq_order_implies_strict ordermap_mono_less ordertype_def replacement trans_VWF wf_VWF)"], ["proof (state)\nthis:\n  ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\n  \\<le> ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "also"], ["proof (state)\nthis:\n  ordermap M VWF (inv_into M (ordermap M VWF) \\<alpha>)\n  \\<le> ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "have \"\\<dots> = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>) = \\<beta>", "by (meson \\<beta> f_inv_into_f in_mono ordermap_surj)"], ["proof (state)\nthis:\n  ordermap M VWF (inv_into M (ordermap M VWF) \\<beta>) = \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha> \\<le> \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> \\<le> \\<beta>\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<le> \\<beta>", "."], ["proof (state)\nthis:\n  \\<alpha> \\<le> \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_mono_on_ordertype:\n  assumes \"M \\<subseteq> ON\" \"small M\"\n  obtains f where \"f \\<in> elts (ordertype M VWF) \\<rightarrow> M\" \"strict_mono_on f (elts (ordertype M VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> elts (ordertype M VWF) \\<rightarrow> M;\n         strict_mono_on f (elts (ordertype M VWF))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> elts (ordertype M VWF) \\<rightarrow> M;\n         strict_mono_on f (elts (ordertype M VWF))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?f2 \\<in> elts (ordertype M VWF) \\<rightarrow> M\n 2. (\\<And>f.\n        \\<lbrakk>f \\<in> elts (ordertype M VWF) \\<rightarrow> M;\n         strict_mono_on f (elts (ordertype M VWF))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_mono_on ?f2 (elts (ordertype M VWF))", "show \"inv_into M (ordermap M VWF) \\<in> elts (ordertype M VWF) \\<rightarrow> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into M (ordermap M VWF) \\<in> elts (ordertype M VWF) \\<rightarrow> M", "by (meson Pi_I' in_mono inv_into_into ordermap_surj)"], ["proof (state)\nthis:\n  inv_into M (ordermap M VWF) \\<in> elts (ordertype M VWF) \\<rightarrow> M\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> elts (ordertype M VWF) \\<rightarrow> M;\n         strict_mono_on f (elts (ordertype M VWF))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    strict_mono_on (inv_into M (ordermap M VWF)) (elts (ordertype M VWF))", "show \"strict_mono_on (inv_into M (ordermap M VWF)) (elts (ordertype M VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF)) (elts (ordertype M VWF))", "proof (clarsimp simp: strict_mono_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<lbrakk>r \\<in> elts (ordertype M VWF);\n        s \\<in> elts (ordertype M VWF); r < s\\<rbrakk>\n       \\<Longrightarrow> inv_into M (ordermap M VWF) r\n                         < inv_into M (ordermap M VWF) s", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<lbrakk>r \\<in> elts (ordertype M VWF);\n        s \\<in> elts (ordertype M VWF); r < s\\<rbrakk>\n       \\<Longrightarrow> inv_into M (ordermap M VWF) r\n                         < inv_into M (ordermap M VWF) s", "assume \"x \\<in> elts (ordertype M VWF)\" \"y \\<in> elts (ordertype M VWF)\" \"x < y\""], ["proof (state)\nthis:\n  x \\<in> elts (ordertype M VWF)\n  y \\<in> elts (ordertype M VWF)\n  x < y\n\ngoal (1 subgoal):\n 1. \\<And>r s.\n       \\<lbrakk>r \\<in> elts (ordertype M VWF);\n        s \\<in> elts (ordertype M VWF); r < s\\<rbrakk>\n       \\<Longrightarrow> inv_into M (ordermap M VWF) r\n                         < inv_into M (ordermap M VWF) s", "then"], ["proof (chain)\npicking this:\n  x \\<in> elts (ordertype M VWF)\n  y \\<in> elts (ordertype M VWF)\n  x < y", "show \"inv_into M (ordermap M VWF) x < inv_into M (ordermap M VWF) y\""], ["proof (prove)\nusing this:\n  x \\<in> elts (ordertype M VWF)\n  y \\<in> elts (ordertype M VWF)\n  x < y\n\ngoal (1 subgoal):\n 1. inv_into M (ordermap M VWF) x < inv_into M (ordermap M VWF) y", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> elts (ordertype M VWF)\n  y \\<in> elts (ordertype M VWF)\n  x < y\n  M \\<subseteq> ON\n  small M\n\ngoal (1 subgoal):\n 1. inv_into M (ordermap M VWF) x < inv_into M (ordermap M VWF) y", "by (meson ON_imp_Ord Ord_linear2 inv_into_into inv_ordermap_VWF_mono_le leD ordermap_surj subsetD)"], ["proof (state)\nthis:\n  inv_into M (ordermap M VWF) x < inv_into M (ordermap M VWF) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_mono_on (inv_into M (ordermap M VWF)) (elts (ordertype M VWF))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordermap_inc_eq:\n  assumes \"x \\<in> A\" \"small A\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \n  shows \"ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "using \\<open>wf r\\<close> \\<open>x \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  wf r\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "proof (induction x rule: wf_induct_rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A", "have 1: \"{y \\<in> A. (y, x) \\<in> r} = A \\<inter> {y. (y, x) \\<in> r}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. {y \\<in> A. (y, x) \\<in> r} = A \\<inter> {y. (y, x) \\<in> r}", "using r"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A\n  wf r\n  total_on A r\n\ngoal (1 subgoal):\n 1. {y \\<in> A. (y, x) \\<in> r} = A \\<inter> {y. (y, x) \\<in> r}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> A. (y, x) \\<in> r} = A \\<inter> {y. (y, x) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "have 2: \"{y \\<in> \\<pi> ` A. (y, \\<pi> x) \\<in> s} = \\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> \\<pi> ` A. (y, \\<pi> x) \\<in> s} =\n    \\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}", "by auto"], ["proof (state)\nthis:\n  {y \\<in> \\<pi> ` A. (y, \\<pi> x) \\<in> s} =\n  \\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "have inv\\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (\\<pi> x, \\<pi> y) \\<in> s\\<rbrakk> \\<Longrightarrow> (x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (\\<pi> x, \\<pi> y) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> r", "by (metis \\<pi> \\<open>wf s\\<close> \\<open>total_on A r\\<close> total_on_def wf_not_sym)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (\\<pi> ?x, \\<pi> ?y) \\<in> s\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "have eq: \"f ` (\\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}) = (f \\<circ> \\<pi>) ` (A \\<inter> {y. (y, x) \\<in> r})\" for f :: \"'b \\<Rightarrow> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` (\\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}) =\n    (f \\<circ> \\<pi>) ` (A \\<inter> {y. (y, x) \\<in> r})", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. f ` (\\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}) =\n    (f \\<circ> \\<pi>) ` (A \\<inter> {y. (y, x) \\<in> r})", "by (auto simp: image_subset_iff inv\\<pi> \\<pi>)"], ["proof (state)\nthis:\n  ?f ` (\\<pi> ` A \\<inter> {y. (y, \\<pi> x) \\<in> s}) =\n  (?f \\<circ> \\<pi>) ` (A \\<inter> {y. (y, x) \\<in> r})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> r; y \\<in> A\\<rbrakk>\n                   \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> y) =\n                                     ordermap A r y;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "using less"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, x) \\<in> r; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ordermap (\\<pi> ` A) s (\\<pi> ?y) = ordermap A r ?y\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "by (simp add: ordermap [OF \\<open>wf r\\<close>, of _ x] ordermap [OF \\<open>wf s\\<close>, of _ \"\\<pi> x\"] 1 2 eq)"], ["proof (state)\nthis:\n  ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_inc_eq:\n  assumes \"small A\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \n  shows \"ordertype (\\<pi> ` A) s = ordertype A r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<pi> ` A) s = ordertype A r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype (\\<pi> ` A) s = ordertype A r", "have \"ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "using assms that"], ["proof (prove)\nusing this:\n  small A\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (\\<pi> ?x, \\<pi> ?y) \\<in> s\n  wf r\n  total_on A r\n  wf s\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. ordermap (\\<pi> ` A) s (\\<pi> x) = ordermap A r x", "by (auto simp: ordermap_inc_eq)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow>\n  ordermap (\\<pi> ` A) s (\\<pi> ?x) = ordermap A r ?x\n\ngoal (1 subgoal):\n 1. ordertype (\\<pi> ` A) s = ordertype A r", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow>\n  ordermap (\\<pi> ` A) s (\\<pi> ?x) = ordermap A r ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow>\n  ordermap (\\<pi> ` A) s (\\<pi> ?x) = ordermap A r ?x\n\ngoal (1 subgoal):\n 1. ordertype (\\<pi> ` A) s = ordertype A r", "unfolding ordertype_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow>\n  ordermap (\\<pi> ` A) s (\\<pi> ?x) = ordermap A r ?x\n\ngoal (1 subgoal):\n 1. set (ordermap (\\<pi> ` A) s ` \\<pi> ` A) = set (ordermap A r ` A)", "by (metis (no_types, lifting) image_cong image_image)"], ["proof (state)\nthis:\n  ordertype (\\<pi> ` A) s = ordertype A r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_inc_le:\n  assumes \"small A\" \"small B\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> s\"\n    and r: \"wf r\" \"total_on A r\" and \"wf s\" \"trans s\"\n    and \"\\<pi> ` A \\<subseteq> B\"\n  shows \"ordertype A r \\<le> ordertype B s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ordertype B s", "by (metis assms ordertype_inc_eq ordertype_mono)"], ["", "corollary ordertype_VWF_inc_eq:\n  assumes \"A \\<subseteq> ON\" \"\\<pi> ` A \\<subseteq> ON\" \"small A\" and \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; x<y\\<rbrakk> \\<Longrightarrow> \\<pi> x < \\<pi> y\"\n  shows \"ordertype (\\<pi> ` A) VWF = ordertype A VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (\\<pi> ` A) VWF = ordertype A VWF", "proof (rule ordertype_inc_eq)"], ["proof (state)\ngoal (5 subgoals):\n 1. small A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> VWF\n 3. wf VWF\n 4. total_on A VWF\n 5. wf VWF", "show \"(\\<pi> x, \\<pi> y) \\<in> VWF\"\n    if \"x \\<in> A\" \"y \\<in> A\" \"(x, y) \\<in> VWF\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> x, \\<pi> y) \\<in> VWF", "using that ON_imp_Ord assms"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> VWF\n  \\<lbrakk>?H \\<subseteq> ON; ?x \\<in> ?H\\<rbrakk> \\<Longrightarrow> Ord ?x\n  A \\<subseteq> ON\n  \\<pi> ` A \\<subseteq> ON\n  small A\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?x < ?y\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?x < \\<pi> ?y\n\ngoal (1 subgoal):\n 1. (\\<pi> x, \\<pi> y) \\<in> VWF", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> VWF\\<rbrakk>\n  \\<Longrightarrow> (\\<pi> ?x, \\<pi> ?y) \\<in> VWF\n\ngoal (4 subgoals):\n 1. small A\n 2. wf VWF\n 3. total_on A VWF\n 4. wf VWF", "show \"total_on A VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A VWF", "by (meson UNIV_I total_VWF total_on_def)"], ["proof (state)\nthis:\n  total_on A VWF\n\ngoal (3 subgoals):\n 1. small A\n 2. wf VWF\n 3. wf VWF", "qed (use assms in auto)"], ["", "lemma ordertype_image_ordermap:\n  assumes \"small A\" \"X \\<subseteq> A\" \"wf r\" \"trans r\" \"total_on X r\"\n  shows \"ordertype (ordermap A r ` X) VWF = ordertype X r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ordermap A r ` X) VWF = ordertype X r", "proof (rule ordertype_inc_eq)"], ["proof (state)\ngoal (5 subgoals):\n 1. small X\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; y \\<in> X; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (ordermap A r x, ordermap A r y) \\<in> VWF\n 3. wf r\n 4. total_on X r\n 5. wf VWF", "show \"small X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small X", "by (meson assms smaller_than_small)"], ["proof (state)\nthis:\n  small X\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> X; y \\<in> X; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (ordermap A r x, ordermap A r y) \\<in> VWF\n 2. wf r\n 3. total_on X r\n 4. wf VWF", "show \"(ordermap A r x, ordermap A r y) \\<in> VWF\"\n    if \"x \\<in> X\" \"y \\<in> X\" \"(x, y) \\<in> r\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordermap A r x, ordermap A r y) \\<in> VWF", "by (meson that Ord_ordermap VWF_iff_Ord_less assms ordermap_mono_less subsetD)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> X; ?y \\<in> X; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (ordermap A r ?x, ordermap A r ?y) \\<in> VWF\n\ngoal (3 subgoals):\n 1. wf r\n 2. total_on X r\n 3. wf VWF", "qed (use assms in auto)"], ["", "lemma ordertype_map_image:\n  assumes \"B \\<subseteq> A\" \"small A\"\n  shows \"ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF = ordertype (A - B) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "have \"ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)", "using assms"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  small A\n\ngoal (1 subgoal):\n 1. ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)", "by auto"], ["proof (state)\nthis:\n  ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "then"], ["proof (chain)\npicking this:\n  ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)", "have \"ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF = ordertype (ordermap A VWF ` (A - B)) VWF\""], ["proof (prove)\nusing this:\n  ordermap A VWF ` A - ordermap A VWF ` B = ordermap A VWF ` (A - B)\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (ordermap A VWF ` (A - B)) VWF", "by simp"], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n  ordertype (ordermap A VWF ` (A - B)) VWF\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "also"], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n  ordertype (ordermap A VWF ` (A - B)) VWF\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "have \"\\<dots> = ordertype (A - B) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` (A - B)) VWF = ordertype (A - B) VWF", "using \\<open>small A\\<close> ordertype_image_ordermap"], ["proof (prove)\nusing this:\n  small A\n  \\<lbrakk>small ?A; ?X \\<subseteq> ?A; wf ?r; trans ?r;\n   total_on ?X ?r\\<rbrakk>\n  \\<Longrightarrow> ordertype (ordermap ?A ?r ` ?X) VWF = ordertype ?X ?r\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` (A - B)) VWF = ordertype (A - B) VWF", "by fastforce"], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` (A - B)) VWF = ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "finally"], ["proof (chain)\npicking this:\n  ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n  ordertype (A - B) VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n  ordertype (A - B) VWF\n\ngoal (1 subgoal):\n 1. ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n    ordertype (A - B) VWF", "."], ["proof (state)\nthis:\n  ordertype (ordermap A VWF ` A - ordermap A VWF ` B) VWF =\n  ordertype (A - B) VWF\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition ordertype_le_ordertype:\n  assumes r: \"wf r\" \"total_on A r\" and \"small A\"\n  assumes s: \"wf s\" \"total_on B s\" \"trans s\" and \"small B\"\n  shows \"ordertype A r \\<le> ordertype B s \\<longleftrightarrow>\n         (\\<exists>f \\<in> A \\<rightarrow> B. inj_on f A \\<and> (\\<forall>x \\<in> A. \\<forall>y \\<in> A. ((x,y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)))\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r \\<le> ordertype B s) =\n    (\\<exists>f\\<in>A \\<rightarrow> B.\n        inj_on f A \\<and>\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype A r \\<le> ordertype B s \\<Longrightarrow>\n    \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n 2. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "assume L: ?lhs"], ["proof (state)\nthis:\n  ordertype A r \\<le> ordertype B s\n\ngoal (2 subgoals):\n 1. ordertype A r \\<le> ordertype B s \\<Longrightarrow>\n    \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n 2. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "define f where \"f \\<equiv> inv_into B (ordermap B s) \\<circ> ordermap A r\""], ["proof (state)\nthis:\n  f \\<equiv> inv_into B (ordermap B s) \\<circ> ordermap A r\n\ngoal (2 subgoals):\n 1. ordertype A r \\<le> ordertype B s \\<Longrightarrow>\n    \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n 2. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)", "proof (intro bexI conjI ballI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. inj_on ?f A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (?f x, ?f y) \\<in> s\n 3. ?f \\<in> A \\<rightarrow> B", "have AB: \"elts (ordertype A r) \\<subseteq> ordermap B s ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ordertype A r) \\<subseteq> ordermap B s ` B", "by (metis L assms(7) ordertype_def replacement set_of_elts small_elts subset_iff_less_eq_V)"], ["proof (state)\nthis:\n  elts (ordertype A r) \\<subseteq> ordermap B s ` B\n\ngoal (3 subgoals):\n 1. inj_on ?f A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (?f x, ?f y) \\<in> s\n 3. ?f \\<in> A \\<rightarrow> B", "have bijA: \"bij_betw (ordermap A r) A (elts (ordertype A r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "using ordermap_bij \\<open>small A\\<close> r"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n  small A\n  wf r\n  total_on A r\n\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "by blast"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n\ngoal (3 subgoals):\n 1. inj_on ?f A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (?f x, ?f y) \\<in> s\n 3. ?f \\<in> A \\<rightarrow> B", "have \"inv_into B (ordermap B s) (ordermap A r i) \\<in> B\" if \"i \\<in> A\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into B (ordermap B s) (ordermap A r i) \\<in> B", "by (meson L \\<open>small A\\<close> inv_into_into ordermap_in_ordertype ordermap_surj subsetD that vsubsetD)"], ["proof (state)\nthis:\n  ?i \\<in> A \\<Longrightarrow>\n  inv_into B (ordermap B s) (ordermap A r ?i) \\<in> B\n\ngoal (3 subgoals):\n 1. inj_on ?f A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (?f x, ?f y) \\<in> s\n 3. ?f \\<in> A \\<rightarrow> B", "then"], ["proof (chain)\npicking this:\n  ?i \\<in> A \\<Longrightarrow>\n  inv_into B (ordermap B s) (ordermap A r ?i) \\<in> B", "show \"f \\<in> A \\<rightarrow> B\""], ["proof (prove)\nusing this:\n  ?i \\<in> A \\<Longrightarrow>\n  inv_into B (ordermap B s) (ordermap A r ?i) \\<in> B\n\ngoal (1 subgoal):\n 1. f \\<in> A \\<rightarrow> B", "by (auto simp: Pi_iff f_def)"], ["proof (state)\nthis:\n  f \\<in> A \\<rightarrow> B\n\ngoal (2 subgoals):\n 1. inj_on f A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "show \"inj_on f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f A", "proof (clarsimp simp add: f_def inj_on_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A;\n        inv_into B (ordermap B s) (ordermap A r x) =\n        inv_into B (ordermap B s) (ordermap A r y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A;\n        inv_into B (ordermap B s) (ordermap A r x) =\n        inv_into B (ordermap B s) (ordermap A r y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> A\" \"y \\<in> A\"\n        and \"inv_into B (ordermap B s) (ordermap A r x) = inv_into B (ordermap B s) (ordermap A r y)\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  inv_into B (ordermap B s) (ordermap A r x) =\n  inv_into B (ordermap B s) (ordermap A r y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A;\n        inv_into B (ordermap B s) (ordermap A r x) =\n        inv_into B (ordermap B s) (ordermap A r y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  inv_into B (ordermap B s) (ordermap A r x) =\n  inv_into B (ordermap B s) (ordermap A r y)", "have \"ordermap A r x = ordermap A r y\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  inv_into B (ordermap B s) (ordermap A r x) =\n  inv_into B (ordermap B s) (ordermap A r y)\n\ngoal (1 subgoal):\n 1. ordermap A r x = ordermap A r y", "by (meson AB \\<open>small A\\<close> inv_into_injective ordermap_in_ordertype subsetD)"], ["proof (state)\nthis:\n  ordermap A r x = ordermap A r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A;\n        inv_into B (ordermap B s) (ordermap A r x) =\n        inv_into B (ordermap B s) (ordermap A r y)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  ordermap A r x = ordermap A r y", "show \"x = y\""], ["proof (prove)\nusing this:\n  ordermap A r x = ordermap A r y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis \\<open>x \\<in> A\\<close> \\<open>y \\<in> A\\<close> bijA bij_betw_inv_into_left)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "assume \"x \\<in> A\" \"y \\<in> A\" and \"(x, y) \\<in> r\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "have \\<ddagger>: \"ordermap A r y \\<in> ordermap B s ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r y \\<in> ordermap B s ` B", "by (meson L \\<open>y \\<in> A\\<close> \\<open>small A\\<close> in_mono ordermap_in_ordertype ordermap_surj vsubsetD)"], ["proof (state)\nthis:\n  ordermap A r y \\<in> ordermap B s ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "moreover"], ["proof (state)\nthis:\n  ordermap A r y \\<in> ordermap B s ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "have \\<dagger>: \"\\<And>x. inv_into B (ordermap B s) (ordermap A r x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. inv_into B (ordermap B s) (ordermap A r x) = f x", "by (simp add: f_def)"], ["proof (state)\nthis:\n  inv_into B (ordermap B s) (ordermap A r ?x) = f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "then"], ["proof (chain)\npicking this:\n  inv_into B (ordermap B s) (ordermap A r ?x) = f ?x", "have *: \"ordermap B s (f y) = ordermap A r y\""], ["proof (prove)\nusing this:\n  inv_into B (ordermap B s) (ordermap A r ?x) = f ?x\n\ngoal (1 subgoal):\n 1. ordermap B s (f y) = ordermap A r y", "using \\<ddagger>"], ["proof (prove)\nusing this:\n  inv_into B (ordermap B s) (ordermap A r ?x) = f ?x\n  ordermap A r y \\<in> ordermap B s ` B\n\ngoal (1 subgoal):\n 1. ordermap B s (f y) = ordermap A r y", "by (metis f_inv_into_f)"], ["proof (state)\nthis:\n  ordermap B s (f y) = ordermap A r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "moreover"], ["proof (state)\nthis:\n  ordermap B s (f y) = ordermap A r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "have \"ordermap A r x \\<in> ordermap B s ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r x \\<in> ordermap B s ` B", "by (meson L \\<open>x \\<in> A\\<close> \\<open>small A\\<close> in_mono ordermap_in_ordertype ordermap_surj vsubsetD)"], ["proof (state)\nthis:\n  ordermap A r x \\<in> ordermap B s ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "moreover"], ["proof (state)\nthis:\n  ordermap A r x \\<in> ordermap B s ` B\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "have \"ordermap A r x < ordermap A r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r x < ordermap A r y", "using * r s"], ["proof (prove)\nusing this:\n  ordermap B s (f y) = ordermap A r y\n  wf r\n  total_on A r\n  wf s\n  total_on B s\n  trans s\n\ngoal (1 subgoal):\n 1. ordermap A r x < ordermap A r y", "by (metis (no_types) Ord_ordermap OrdmemD \\<open>(x, y) \\<in> r\\<close> \\<open>x \\<in> A\\<close> \\<open>small A\\<close> ordermap_mono)"], ["proof (state)\nthis:\n  ordermap A r x < ordermap A r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "ultimately"], ["proof (chain)\npicking this:\n  ordermap A r y \\<in> ordermap B s ` B\n  ordermap B s (f y) = ordermap A r y\n  ordermap A r x \\<in> ordermap B s ` B\n  ordermap A r x < ordermap A r y", "show \"(f x, f y) \\<in> s\""], ["proof (prove)\nusing this:\n  ordermap A r y \\<in> ordermap B s ` B\n  ordermap B s (f y) = ordermap A r y\n  ordermap A r x \\<in> ordermap B s ` B\n  ordermap A r x < ordermap A r y\n\ngoal (1 subgoal):\n 1. (f x, f y) \\<in> s", "using \\<dagger> s"], ["proof (prove)\nusing this:\n  ordermap A r y \\<in> ordermap B s ` B\n  ordermap B s (f y) = ordermap A r y\n  ordermap A r x \\<in> ordermap B s ` B\n  ordermap A r x < ordermap A r y\n  inv_into B (ordermap B s) (ordermap A r ?x) = f ?x\n  wf s\n  total_on B s\n  trans s\n\ngoal (1 subgoal):\n 1. (f x, f y) \\<in> s", "by (metis assms(7) f_inv_into_f inv_into_into less_asym ordermap_mono_less total_on_def)"], ["proof (state)\nthis:\n  (f x, f y) \\<in> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f\\<in>A \\<rightarrow> B.\n     inj_on f A \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A.\n            (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "assume R: ?rhs"], ["proof (state)\nthis:\n  \\<exists>f\\<in>A \\<rightarrow> B.\n     inj_on f A \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A.\n            (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "then"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>A \\<rightarrow> B.\n     inj_on f A \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A.\n            (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)", "obtain f where f: \"f\\<in>A \\<rightarrow> B\" \"inj_on f A\" \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>A \\<rightarrow> B.\n     inj_on f A \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A.\n            (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> A \\<rightarrow> B; inj_on f A;\n         \\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f \\<in> A \\<rightarrow> B\n  inj_on f A\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. (x, y) \\<in> r \\<longrightarrow> (f x, f y) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>A \\<rightarrow> B.\n       inj_on f A \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              (x, y) \\<in> r \\<longrightarrow>\n              (f x, f y) \\<in> s) \\<Longrightarrow>\n    ordertype A r \\<le> ordertype B s", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ordertype B s", "by (rule ordertype_inc_le [where \\<pi>=f]) (use f assms in auto)"], ["proof (state)\nthis:\n  ordertype A r \\<le> ordertype B s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iso_imp_ordertype_eq_ordertype:\n  assumes iso: \"iso r r' f\"\n    and \"wf r\"\n    and \"Total r\"\n    and sm: \"small (Field r)\"\n  shows \"ordertype (Field r) r = ordertype (Field r') r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (Field r) r = ordertype (Field r') r'", "by (metis (no_types, lifting) iso_forward iso_wf assms iso_Field ordertype_inc_eq sm)"], ["", "lemma ordertype_infinite_ge_\\<omega>:\n  assumes \"infinite A\" \"small A\"\n  shows \"ordertype A VWF \\<ge> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "have \"inj_on (ordermap A VWF) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (ordermap A VWF) A", "by (meson ordermap_bij \\<open>small A\\<close> bij_betw_def total_on_VWF wf_VWF)"], ["proof (state)\nthis:\n  inj_on (ordermap A VWF) A\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "then"], ["proof (chain)\npicking this:\n  inj_on (ordermap A VWF) A", "have \"infinite (ordermap A VWF ` A)\""], ["proof (prove)\nusing this:\n  inj_on (ordermap A VWF) A\n\ngoal (1 subgoal):\n 1. infinite (ordermap A VWF ` A)", "using \\<open>infinite A\\<close> finite_image_iff"], ["proof (prove)\nusing this:\n  inj_on (ordermap A VWF) A\n  infinite A\n  inj_on ?f ?A \\<Longrightarrow> finite (?f ` ?A) = finite ?A\n\ngoal (1 subgoal):\n 1. infinite (ordermap A VWF ` A)", "by blast"], ["proof (state)\nthis:\n  infinite (ordermap A VWF ` A)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "then"], ["proof (chain)\npicking this:\n  infinite (ordermap A VWF ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (ordermap A VWF ` A)\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "using Ord_ordertype \\<open>small A\\<close> infinite_Ord_omega"], ["proof (prove)\nusing this:\n  infinite (ordermap A VWF ` A)\n  Ord (ordertype ?A VWF)\n  small A\n  \\<lbrakk>Ord ?\\<alpha>; infinite (elts ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<le> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "by (auto simp: ordertype_def)"], ["proof (state)\nthis:\n  \\<omega> \\<le> ordertype A VWF\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_eqI:\n  assumes \"wf r\" \"total_on A r\" \"small A\" \"wf s\" \n          \"bij_betw f A B\" \"(\\<forall>x \\<in> A. \\<forall>y \\<in> A. (f x, f y) \\<in> s \\<longleftrightarrow> (x,y) \\<in> r)\"\n  shows \"ordertype A r = ordertype B s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "by (metis assms bij_betw_imp_surj_on ordertype_inc_eq)"], ["", "lemma ordermap_eq_self:\n  assumes \"Ord \\<alpha>\" and x: \"x \\<in> elts \\<alpha>\" \n  shows \"ordermap (elts \\<alpha>) VWF x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (elts \\<alpha>) VWF x = x", "using Ord_in_Ord [OF assms] x"], ["proof (prove)\nusing this:\n  Ord x\n  x \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. ordermap (elts \\<alpha>) VWF x = x", "proof (induction x rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (elts \\<alpha>) VWF y = y;\n        x \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (elts \\<alpha>) VWF x = x", "case (step x)"], ["proof (state)\nthis:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; ?y \\<in> elts \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (elts \\<alpha>) VWF ?y = ?y\n  x \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (elts \\<alpha>) VWF y = y;\n        x \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (elts \\<alpha>) VWF x = x", "have 1: \"{y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} = elts x\" (is \"?A = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} = elts x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} \\<subseteq> elts x\n 2. elts x \\<subseteq> {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF}", "show \"?A \\<subseteq> elts x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} \\<subseteq> elts x", "using \\<open>Ord \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} \\<subseteq> elts x", "by clarify (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less step.hyps)"], ["proof (state)\nthis:\n  {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} \\<subseteq> elts x\n\ngoal (1 subgoal):\n 1. elts x \\<subseteq> {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF}", "show \"elts x \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts x \\<subseteq> {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF}", "using \\<open>Ord \\<alpha>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. elts x \\<subseteq> {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF}", "by clarify (meson Ord_in_Ord Ord_trans OrdmemD VWF_iff_Ord_less step.prems)"], ["proof (state)\nthis:\n  elts x \\<subseteq> {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {y \\<in> elts \\<alpha>. (y, x) \\<in> VWF} = elts x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (elts \\<alpha>) VWF y = y;\n        x \\<in> elts \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (elts \\<alpha>) VWF x = x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (elts \\<alpha>) VWF x = x", "using step"], ["proof (prove)\nusing this:\n  Ord x\n  \\<lbrakk>?y \\<in> elts x; ?y \\<in> elts \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (elts \\<alpha>) VWF ?y = ?y\n  x \\<in> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. ordermap (elts \\<alpha>) VWF x = x", "by (simp add: ordermap [OF wf_VWF, of _ x] 1 Ord_trans [of _ _ \\<alpha>] step.prems \\<open>Ord \\<alpha>\\<close> cong: image_cong)"], ["proof (state)\nthis:\n  ordermap (elts \\<alpha>) VWF x = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_eq_Ord [simp]:\n  assumes \"Ord \\<alpha>\" \n  shows \"ordertype (elts \\<alpha>) VWF = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha>) VWF = \\<alpha>", "using assms ordermap_eq_self [OF assms]"], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  ?x \\<in> elts \\<alpha> \\<Longrightarrow>\n  ordermap (elts \\<alpha>) VWF ?x = ?x\n\ngoal (1 subgoal):\n 1. ordertype (elts \\<alpha>) VWF = \\<alpha>", "by (simp add: ordertype_def)"], ["", "proposition ordertype_eq_iff:\n  assumes \\<alpha>: \"Ord \\<alpha>\" and r: \"wf r\" and \"small A\" \"total_on A r\" \"trans r\"\n  shows \"ordertype A r = \\<alpha> \\<longleftrightarrow>\n         (\\<exists>f. bij_betw f A (elts \\<alpha>) \\<and> (\\<forall>x \\<in> A. \\<forall>y \\<in> A. f x < f y \\<longleftrightarrow> (x,y) \\<in> r))\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r = \\<alpha>) =\n    (\\<exists>f.\n        bij_betw f A (elts \\<alpha>) \\<and>\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> = ordertype A r \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A (elts (ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r))\n 2. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "assume eq: \"\\<alpha> = ordertype A r\""], ["proof (state)\nthis:\n  \\<alpha> = ordertype A r\n\ngoal (2 subgoals):\n 1. \\<alpha> = ordertype A r \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A (elts (ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r))\n 2. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "show \"\\<exists>f. bij_betw f A (elts (ordertype A r)) \\<and> (\\<forall>x\\<in>A. \\<forall>y\\<in>A. f x < f y \\<longleftrightarrow> ((x, y) \\<in> r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f A (elts (ordertype A r)) \\<and>\n       (\\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r))", "proof (intro exI conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ?f A (elts (ordertype A r))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (?f x < ?f y) = ((x, y) \\<in> r)", "show \"bij_betw (ordermap A r) A (elts (ordertype A r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "by (simp add: assms ordermap_bij)"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (ordermap A r x < ordermap A r y) =\n                         ((x, y) \\<in> r)", "then"], ["proof (chain)\npicking this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))", "show \"ordermap A r x < ordermap A r y \\<longleftrightarrow> (x, y) \\<in> r\"\n      if \"x \\<in> A\" \"y \\<in> A\" for x y"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n\ngoal (1 subgoal):\n 1. (ordermap A r x < ordermap A r y) = ((x, y) \\<in> r)", "using that assms"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n  x \\<in> A\n  y \\<in> A\n  Ord \\<alpha>\n  wf r\n  small A\n  total_on A r\n  trans r\n\ngoal (1 subgoal):\n 1. (ordermap A r x < ordermap A r y) = ((x, y) \\<in> r)", "by (metis order.asym ordermap_mono_less total_on_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> (ordermap A r ?x < ordermap A r ?y) = ((?x, ?y) \\<in> r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f A (elts (ordertype A r)) \\<and>\n     (\\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "assume f: \"bij_betw f A (elts \\<alpha>)\" \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. f x < f y \\<longleftrightarrow> (x, y) \\<in> r\""], ["proof (state)\nthis:\n  bij_betw f A (elts \\<alpha>)\n  \\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "have \"ordertype A r = ordertype (elts \\<alpha>) VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r = ordertype (elts \\<alpha>) VWF", "proof (rule ordertype_eqI)"], ["proof (state)\ngoal (6 subgoals):\n 1. wf r\n 2. total_on A r\n 3. small A\n 4. wf VWF\n 5. bij_betw ?f A (elts \\<alpha>)\n 6. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((?f x, ?f y) \\<in> VWF) = ((x, y) \\<in> r)", "show \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. ((f x, f y) \\<in> VWF) = ((x, y) \\<in> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> VWF) = ((x, y) \\<in> r)", "by (meson Ord_in_Ord VWF_iff_Ord_less \\<alpha> bij_betwE f)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> VWF) = ((x, y) \\<in> r)\n\ngoal (5 subgoals):\n 1. wf r\n 2. total_on A r\n 3. small A\n 4. wf VWF\n 5. bij_betw f A (elts \\<alpha>)", "qed (use assms f in auto)"], ["proof (state)\nthis:\n  ordertype A r = ordertype (elts \\<alpha>) VWF\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bij_betw f A (elts \\<alpha>);\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> r)\\<rbrakk>\n       \\<Longrightarrow> ordertype A r = \\<alpha>", "then"], ["proof (chain)\npicking this:\n  ordertype A r = ordertype (elts \\<alpha>) VWF", "show ?lhs"], ["proof (prove)\nusing this:\n  ordertype A r = ordertype (elts \\<alpha>) VWF\n\ngoal (1 subgoal):\n 1. ordertype A r = \\<alpha>", "by (simp add: \\<alpha>)"], ["proof (state)\nthis:\n  ordertype A r = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ordertype_VWF_eq_iff:\n  assumes \"Ord \\<alpha>\" \"small A\"\n  shows \"ordertype A VWF = \\<alpha> \\<longleftrightarrow>\n         (\\<exists>f. bij_betw f A (elts \\<alpha>) \\<and> (\\<forall>x \\<in> A. \\<forall>y \\<in> A. f x < f y \\<longleftrightarrow> (x,y) \\<in> VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A VWF = \\<alpha>) =\n    (\\<exists>f.\n        bij_betw f A (elts \\<alpha>) \\<and>\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. (f x < f y) = ((x, y) \\<in> VWF)))", "by (metis UNIV_I assms ordertype_eq_iff total_VWF total_on_def trans_VWF wf_VWF)"], ["", "lemma ordertype_le_Ord:\n  assumes \"Ord \\<alpha>\" \"X \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype X VWF \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype X VWF \\<le> \\<alpha>", "by (metis assms ordertype_VWF_mono ordertype_eq_Ord small_elts)"], ["", "lemma ordertype_inc_le_Ord:\n  assumes \"small A\" \"Ord \\<alpha>\"\n    and \\<pi>: \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> \\<pi> x < \\<pi> y\"\n    and \"wf r\" \"total_on A r\" \n    and sub: \"\\<pi> ` A \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype A r \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> \\<alpha>", "have \"\\<And>x y. \\<lbrakk>x\\<in>A; y\\<in>A; (x,y) \\<in> r\\<rbrakk> \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (\\<pi> x, \\<pi> y) \\<in> VWF", "by (meson Ord_in_Ord VWF_iff_Ord_less \\<pi> \\<open>Ord \\<alpha>\\<close> sub image_subset_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (\\<pi> ?x, \\<pi> ?y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> \\<alpha>", "with assms"], ["proof (chain)\npicking this:\n  small A\n  Ord \\<alpha>\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?x < \\<pi> ?y\n  wf r\n  total_on A r\n  \\<pi> ` A \\<subseteq> elts \\<alpha>\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (\\<pi> ?x, \\<pi> ?y) \\<in> VWF", "show ?thesis"], ["proof (prove)\nusing this:\n  small A\n  Ord \\<alpha>\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> \\<pi> ?x < \\<pi> ?y\n  wf r\n  total_on A r\n  \\<pi> ` A \\<subseteq> elts \\<alpha>\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; (?x, ?y) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> (\\<pi> ?x, \\<pi> ?y) \\<in> VWF\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> \\<alpha>", "by (metis ordertype_inc_eq ordertype_le_Ord wf_VWF)"], ["proof (state)\nthis:\n  ordertype A r \\<le> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_ordertype_obtains_subset:\n  assumes \\<alpha>: \"\\<beta> \\<le> \\<alpha>\" \"ordertype H VWF = \\<alpha>\" and \"small H\" \"Ord \\<beta>\"\n  obtains G where \"G \\<subseteq> H\" \"ordertype G VWF = \\<beta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (intro exI conjI that)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?G2 \\<subseteq> H\n 2. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ordertype ?G2 VWF = \\<beta>", "let ?f = \"ordermap H VWF\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?G2 \\<subseteq> H\n 2. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ordertype ?G2 VWF = \\<beta>", "show \\<ddagger>: \"inv_into H ?f ` elts \\<beta> \\<subseteq> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into H (ordermap H VWF) ` elts \\<beta> \\<subseteq> H", "unfolding image_subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>elts \\<beta>. inv_into H (ordermap H VWF) x \\<in> H", "by (metis \\<alpha> inv_into_into ordermap_surj subsetD vsubsetD)"], ["proof (state)\nthis:\n  inv_into H (ordermap H VWF) ` elts \\<beta> \\<subseteq> H\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ordertype (inv_into H (ordermap H VWF) ` elts \\<beta>) VWF = \\<beta>", "have \"\\<exists>f. bij_betw f (inv_into H ?f ` elts \\<beta>) (elts \\<beta>) \\<and> (\\<forall>x\\<in>inv_into H ?f ` elts \\<beta>. \\<forall>y\\<in>inv_into H ?f ` elts \\<beta>. (f x < f y) = ((x, y) \\<in> VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (inv_into H (ordermap H VWF) ` elts \\<beta>)\n        (elts \\<beta>) \\<and>\n       (\\<forall>x\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n           \\<forall>y\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n              (f x < f y) = ((x, y) \\<in> VWF))", "proof (intro exI conjI ballI iffI)"], ["proof (state)\ngoal (3 subgoals):\n 1. bij_betw ?f (inv_into H (ordermap H VWF) ` elts \\<beta>) (elts \\<beta>)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ?f x < ?f y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> ?f x < ?f y", "show \"bij_betw ?f (inv_into H ?f ` elts \\<beta>) (elts \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap H VWF) (inv_into H (ordermap H VWF) ` elts \\<beta>)\n     (elts \\<beta>)", "using ordermap_bij [OF wf_VWF total_on_VWF \\<open>small H\\<close>] \\<alpha>"], ["proof (prove)\nusing this:\n  bij_betw (ordermap H VWF) H (elts (ordertype H VWF))\n  \\<beta> \\<le> \\<alpha>\n  ordertype H VWF = \\<alpha>\n\ngoal (1 subgoal):\n 1. bij_betw (ordermap H VWF) (inv_into H (ordermap H VWF) ` elts \\<beta>)\n     (elts \\<beta>)", "by (metis bij_betw_inv_into_RIGHT bij_betw_subset less_eq_V_def \\<ddagger>)"], ["proof (state)\nthis:\n  bij_betw (ordermap H VWF) (inv_into H (ordermap H VWF) ` elts \\<beta>)\n   (elts \\<beta>)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ordermap H VWF x < ordermap H VWF y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> ordermap H VWF x < ordermap H VWF y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ordermap H VWF x < ordermap H VWF y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> ordermap H VWF x < ordermap H VWF y", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ordermap H VWF x < ordermap H VWF y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> ordermap H VWF x < ordermap H VWF y", "assume x: \"x \\<in> inv_into H ?f ` elts \\<beta>\"\n        and y: \"y \\<in> inv_into H ?f ` elts \\<beta>\""], ["proof (state)\nthis:\n  x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n  y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ordermap H VWF x < ordermap H VWF y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        (x, y) \\<in> VWF\\<rbrakk>\n       \\<Longrightarrow> ordermap H VWF x < ordermap H VWF y", "show \"?f x < ?f y\" if \"(x,y) \\<in> VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap H VWF x < ordermap H VWF y", "using that \\<ddagger> \\<open>small H\\<close> in_mono ordermap_mono_less x y"], ["proof (prove)\nusing this:\n  (x, y) \\<in> VWF\n  inv_into H (ordermap H VWF) ` elts \\<beta> \\<subseteq> H\n  small H\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  ?x \\<in> ?A \\<longrightarrow> ?x \\<in> ?B\n  \\<lbrakk>(?w, ?x) \\<in> ?r; wf ?r; trans ?r; ?w \\<in> ?A; ?x \\<in> ?A;\n   small ?A\\<rbrakk>\n  \\<Longrightarrow> ordermap ?A ?r ?w < ordermap ?A ?r ?x\n  x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n  y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n\ngoal (1 subgoal):\n 1. ordermap H VWF x < ordermap H VWF y", "by fastforce"], ["proof (state)\nthis:\n  (x, y) \\<in> VWF \\<Longrightarrow> ordermap H VWF x < ordermap H VWF y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>;\n        ordermap H VWF x < ordermap H VWF y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> VWF", "show \"(x,y) \\<in> VWF\" if \"?f x < ?f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "using that \\<ddagger> \\<open>small H\\<close> in_mono ordermap_mono_less [OF _ wf_VWF trans_VWF] x y"], ["proof (prove)\nusing this:\n  ordermap H VWF x < ordermap H VWF y\n  inv_into H (ordermap H VWF) ` elts \\<beta> \\<subseteq> H\n  small H\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  ?x \\<in> ?A \\<longrightarrow> ?x \\<in> ?B\n  \\<lbrakk>(?w, ?x) \\<in> VWF; ?w \\<in> ?A; ?x \\<in> ?A; small ?A\\<rbrakk>\n  \\<Longrightarrow> ordermap ?A VWF ?w < ordermap ?A VWF ?x\n  x \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n  y \\<in> inv_into H (ordermap H VWF) ` elts \\<beta>\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> VWF", "by (metis UNIV_I less_imp_not_less total_VWF total_on_def)"], ["proof (state)\nthis:\n  ordermap H VWF x < ordermap H VWF y \\<Longrightarrow> (x, y) \\<in> VWF\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (inv_into H (ordermap H VWF) ` elts \\<beta>)\n      (elts \\<beta>) \\<and>\n     (\\<forall>x\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n         \\<forall>y\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n            (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>G \\<subseteq> H; ordertype G VWF = \\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ordertype (inv_into H (ordermap H VWF) ` elts \\<beta>) VWF = \\<beta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     bij_betw f (inv_into H (ordermap H VWF) ` elts \\<beta>)\n      (elts \\<beta>) \\<and>\n     (\\<forall>x\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n         \\<forall>y\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n            (f x < f y) = ((x, y) \\<in> VWF))", "show \"ordertype (inv_into H ?f ` elts \\<beta>) VWF = \\<beta>\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     bij_betw f (inv_into H (ordermap H VWF) ` elts \\<beta>)\n      (elts \\<beta>) \\<and>\n     (\\<forall>x\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n         \\<forall>y\\<in>inv_into H (ordermap H VWF) ` elts \\<beta>.\n            (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (1 subgoal):\n 1. ordertype (inv_into H (ordermap H VWF) ` elts \\<beta>) VWF = \\<beta>", "by (subst ordertype_eq_iff) (use assms in auto)"], ["proof (state)\nthis:\n  ordertype (inv_into H (ordermap H VWF) ` elts \\<beta>) VWF = \\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_infinite_\\<omega>:\n  assumes \"A \\<subseteq> elts \\<omega>\" \"infinite A\"\n  shows \"ordertype A VWF = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A VWF = \\<omega>", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype A VWF \\<le> \\<omega>\n 2. \\<omega> \\<le> ordertype A VWF", "show \"ordertype A VWF \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A VWF \\<le> \\<omega>", "by (simp add: assms ordertype_le_Ord)"], ["proof (state)\nthis:\n  ordertype A VWF \\<le> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "show \"\\<omega> \\<le> ordertype A VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "using assms down ordertype_infinite_ge_\\<omega>"], ["proof (prove)\nusing this:\n  A \\<subseteq> elts \\<omega>\n  infinite A\n  ?Y \\<subseteq> elts ?x \\<Longrightarrow> small ?Y\n  \\<lbrakk>infinite ?A; small ?A\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<le> ordertype ?A VWF\n\ngoal (1 subgoal):\n 1. \\<omega> \\<le> ordertype A VWF", "by auto"], ["proof (state)\nthis:\n  \\<omega> \\<le> ordertype A VWF\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For infinite sets of natural numbers\\<close>"], ["", "lemma ordertype_nat_\\<omega>:\n  assumes \"infinite N\" shows \"ordertype N less_than = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "have \"small N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small N", "by (meson inj_on_def ord_of_nat_inject small_def small_iff_range small_image_nat_V)"], ["proof (state)\nthis:\n  small N\n\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "have \"ordertype (ord_of_nat ` N) VWF = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ord_of_nat ` N) VWF = \\<omega>", "by (force simp: assms finite_image_iff inj_on_def intro: ordertype_infinite_\\<omega>)"], ["proof (state)\nthis:\n  ordertype (ord_of_nat ` N) VWF = \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "moreover"], ["proof (state)\nthis:\n  ordertype (ord_of_nat ` N) VWF = \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "have \"ordertype (ord_of_nat ` N) VWF = ordertype N less_than\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ord_of_nat ` N) VWF = ordertype N less_than", "by (auto intro: ordertype_inc_eq \\<open>small N\\<close>)"], ["proof (state)\nthis:\n  ordertype (ord_of_nat ` N) VWF = ordertype N less_than\n\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "ultimately"], ["proof (chain)\npicking this:\n  ordertype (ord_of_nat ` N) VWF = \\<omega>\n  ordertype (ord_of_nat ` N) VWF = ordertype N less_than", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype (ord_of_nat ` N) VWF = \\<omega>\n  ordertype (ord_of_nat ` N) VWF = ordertype N less_than\n\ngoal (1 subgoal):\n 1. ordertype N less_than = \\<omega>", "by simp"], ["proof (state)\nthis:\n  ordertype N less_than = \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition ordertype_eq_ordertype:\n  assumes r: \"wf r\" \"total_on A r\" \"trans r\" and \"small A\"\n  assumes s: \"wf s\" \"total_on B s\" \"trans s\" and \"small B\"\n  shows \"ordertype A r = ordertype B s \\<longleftrightarrow>\n         (\\<exists>f. bij_betw f A B \\<and> (\\<forall>x \\<in> A. \\<forall>y \\<in> A. (f x, f y) \\<in> s \\<longleftrightarrow> (x,y) \\<in> r))\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r = ordertype B s) =\n    (\\<exists>f.\n        bij_betw f A B \\<and>\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "assume L: ?lhs"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "define \\<gamma> where \"\\<gamma> = ordertype A r\""], ["proof (state)\nthis:\n  \\<gamma> = ordertype A r\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "have A: \"bij_betw (ordermap A r) A (ordermap A r ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (ordermap A r ` A)", "by (meson ordermap_bij assms(4) bij_betw_def r)"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (ordermap A r ` A)\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "have B: \"bij_betw (ordermap B s) B (ordermap B s ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap B s) B (ordermap B s ` B)", "by (meson ordermap_bij assms(8) bij_betw_def s)"], ["proof (state)\nthis:\n  bij_betw (ordermap B s) B (ordermap B s ` B)\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "define f where \"f \\<equiv> inv_into B (ordermap B s) o ordermap A r\""], ["proof (state)\nthis:\n  f \\<equiv> inv_into B (ordermap B s) \\<circ> ordermap A r\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n 2. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ?f A B\n 2. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((?f x, ?f y) \\<in> s) = ((x, y) \\<in> r)", "have bijA: \"bij_betw (ordermap A r) A (elts \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts \\<gamma>)", "unfolding \\<gamma>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "using ordermap_bij \\<open>small A\\<close> r"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n  small A\n  wf r\n  total_on A r\n  trans r\n\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "by blast"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n\ngoal (2 subgoals):\n 1. bij_betw ?f A B\n 2. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((?f x, ?f y) \\<in> s) = ((x, y) \\<in> r)", "moreover"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n\ngoal (2 subgoals):\n 1. bij_betw ?f A B\n 2. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((?f x, ?f y) \\<in> s) = ((x, y) \\<in> r)", "have bijB: \"bij_betw (ordermap B s) B (elts \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap B s) B (elts \\<gamma>)", "by (simp add: L \\<gamma>_def ordermap_bij \\<open>small B\\<close> s)"], ["proof (state)\nthis:\n  bij_betw (ordermap B s) B (elts \\<gamma>)\n\ngoal (2 subgoals):\n 1. bij_betw ?f A B\n 2. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((?f x, ?f y) \\<in> s) = ((x, y) \\<in> r)", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n  bij_betw (ordermap B s) B (elts \\<gamma>)", "show bij: \"bij_betw f A B\""], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n  bij_betw (ordermap B s) B (elts \\<gamma>)\n\ngoal (1 subgoal):\n 1. bij_betw f A B", "unfolding f_def"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n  bij_betw (ordermap B s) B (elts \\<gamma>)\n\ngoal (1 subgoal):\n 1. bij_betw (inv_into B (ordermap B s) \\<circ> ordermap A r) A B", "using bij_betw_comp_iff bij_betw_inv_into"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n  bij_betw (ordermap B s) B (elts \\<gamma>)\n  bij_betw ?f ?A ?A' \\<Longrightarrow>\n  bij_betw ?f' ?A' ?A'' = bij_betw (?f' \\<circ> ?f) ?A ?A''\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij_betw (inv_into B (ordermap B s) \\<circ> ordermap A r) A B", "by blast"], ["proof (state)\nthis:\n  bij_betw f A B\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "have invB: \"\\<And>\\<alpha>. \\<alpha> \\<in> elts \\<gamma> \\<Longrightarrow> ordermap B s (inv_into B (ordermap B s) \\<alpha>) = \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<alpha> \\<in> elts \\<gamma> \\<Longrightarrow>\n       ordermap B s (inv_into B (ordermap B s) \\<alpha>) = \\<alpha>", "by (meson bijB bij_betw_inv_into_right)"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> elts \\<gamma> \\<Longrightarrow>\n  ordermap B s (inv_into B (ordermap B s) ?\\<alpha>) = ?\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "have ordermap_A_\\<gamma>: \"\\<And>a. a \\<in> A \\<Longrightarrow> ordermap A r a \\<in> elts \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ordermap A r a \\<in> elts \\<gamma>", "using bijA bij_betwE"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts \\<gamma>)\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> ordermap A r a \\<in> elts \\<gamma>", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> ordermap A r ?a \\<in> elts \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "have f_in_B: \"\\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> B", "using bij bij_betwE"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> A \\<Longrightarrow> f a \\<in> B", "by fastforce"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> f ?a \\<in> B\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "show \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. (f x, f y) \\<in> s \\<longleftrightarrow> (x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "proof (intro iffI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (f x, f y) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (f x, f y) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "assume \"x \\<in> A\" \"y \\<in> A\" and ins: \"(f x, f y) \\<in> s\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  (f x, f y) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (f x, f y) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  (f x, f y) \\<in> s", "have \"ordermap A r x < ordermap A r y\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  (f x, f y) \\<in> s\n\ngoal (1 subgoal):\n 1. ordermap A r x < ordermap A r y", "unfolding o_def"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  (f x, f y) \\<in> s\n\ngoal (1 subgoal):\n 1. ordermap A r x < ordermap A r y", "by (metis (mono_tags, lifting) f_def \\<open>small B\\<close> comp_apply f_in_B invB ordermap_A_\\<gamma> ordermap_mono_less s(1) s(3))"], ["proof (state)\nthis:\n  ordermap A r x < ordermap A r y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (f x, f y) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> r\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "then"], ["proof (chain)\npicking this:\n  ordermap A r x < ordermap A r y", "show \"(x, y) \\<in> r\""], ["proof (prove)\nusing this:\n  ordermap A r x < ordermap A r y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r", "by (metis \\<open>x \\<in> A\\<close> \\<open>y \\<in> A\\<close> \\<open>small A\\<close> order.asym ordermap_mono_less r total_on_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "assume \"x \\<in> A\" \"y \\<in> A\" and \"(x, y) \\<in> r\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> r", "have \"ordermap A r x < ordermap A r y\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. ordermap A r x < ordermap A r y", "by (simp add: \\<open>small A\\<close> ordermap_mono_less r)"], ["proof (state)\nthis:\n  ordermap A r x < ordermap A r y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "then"], ["proof (chain)\npicking this:\n  ordermap A r x < ordermap A r y", "have \"(f y, f x) \\<notin> s\""], ["proof (prove)\nusing this:\n  ordermap A r x < ordermap A r y\n\ngoal (1 subgoal):\n 1. (f y, f x) \\<notin> s", "by (metis (mono_tags, lifting) \\<open>x \\<in> A\\<close> \\<open>y \\<in> A\\<close> \\<open>small B\\<close> comp_apply f_def f_in_B invB order.asym ordermap_A_\\<gamma> ordermap_mono_less s(1) s(3))"], ["proof (state)\nthis:\n  (f y, f x) \\<notin> s\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "moreover"], ["proof (state)\nthis:\n  (f y, f x) \\<notin> s\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "have \"f y \\<noteq> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f y \\<noteq> f x", "by (metis \\<open>(x, y) \\<in> r\\<close> \\<open>x \\<in> A\\<close> \\<open>y \\<in> A\\<close> bij bij_betw_inv_into_left r(1) wf_not_sym)"], ["proof (state)\nthis:\n  f y \\<noteq> f x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (f x, f y) \\<in> s", "ultimately"], ["proof (chain)\npicking this:\n  (f y, f x) \\<notin> s\n  f y \\<noteq> f x", "show \"(f x, f y) \\<in> s\""], ["proof (prove)\nusing this:\n  (f y, f x) \\<notin> s\n  f y \\<noteq> f x\n\ngoal (1 subgoal):\n 1. (f x, f y) \\<in> s", "by (meson \\<open>x \\<in> A\\<close> \\<open>y \\<in> A\\<close> f_in_B s(2) total_on_def)"], ["proof (state)\nthis:\n  (f x, f y) \\<in> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f A B \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f A B \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f A B \\<and>\n       (\\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              ((f x, f y) \\<in> s) = ((x, y) \\<in> r)) \\<Longrightarrow>\n    ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     bij_betw f A B \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     bij_betw f A B \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "using assms ordertype_eqI"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     bij_betw f A B \\<and>\n     (\\<forall>x\\<in>A.\n         \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r))\n  wf r\n  total_on A r\n  trans r\n  small A\n  wf s\n  total_on B s\n  trans s\n  small B\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A; wf ?s; bij_betw ?f ?A ?B;\n   \\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A.\n         ((?f x, ?f y) \\<in> ?s) = ((x, y) \\<in> ?r)\\<rbrakk>\n  \\<Longrightarrow> ordertype ?A ?r = ordertype ?B ?s\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "by blast"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary ordertype_eq_ordertype_iso:\n  assumes r: \"wf r\" \"total_on A r\" \"trans r\" and \"small A\" and FA: \"Field r = A\"\n  assumes s: \"wf s\" \"total_on B s\" \"trans s\" and \"small B\" and FB: \"Field s = B\"\n  shows \"ordertype A r = ordertype B s \\<longleftrightarrow> (\\<exists>f. iso r s f)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r = ordertype B s) = (\\<exists>f. iso r s f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow> \\<exists>f. iso r s f\n 2. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "assume L: ?lhs"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow> \\<exists>f. iso r s f\n 2. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  ordertype A r = ordertype B s", "obtain f where \"bij_betw f A B\" \"\\<forall>x \\<in> A. \\<forall>y \\<in> A. (f x, f y) \\<in> s \\<longleftrightarrow> (x,y) \\<in> r\""], ["proof (prove)\nusing this:\n  ordertype A r = ordertype B s\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij_betw f A B;\n         \\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ordertype_eq_ordertype"], ["proof (prove)\nusing this:\n  ordertype A r = ordertype B s\n  wf r\n  total_on A r\n  trans r\n  small A\n  Field r = A\n  wf s\n  total_on B s\n  trans s\n  small B\n  Field s = B\n  \\<lbrakk>wf ?r; total_on ?A ?r; trans ?r; small ?A; wf ?s; total_on ?B ?s;\n   trans ?s; small ?B\\<rbrakk>\n  \\<Longrightarrow> (ordertype ?A ?r = ordertype ?B ?s) =\n                    (\\<exists>f.\n                        bij_betw f ?A ?B \\<and>\n                        (\\<forall>x\\<in>?A.\n                            \\<forall>y\\<in>?A.\n                               ((f x, f y) \\<in> ?s) = ((x, y) \\<in> ?r)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij_betw f A B;\n         \\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow> \\<exists>f. iso r s f\n 2. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "show ?rhs"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso r s f", "using FA FB iso_iff2"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n  Field r = A\n  Field s = B\n  iso ?r ?r' ?f =\n  (bij_betw ?f (Field ?r) (Field ?r') \\<and>\n   (\\<forall>a\\<in>Field ?r.\n       \\<forall>b\\<in>Field ?r.\n          ((a, b) \\<in> ?r) = ((?f a, ?f b) \\<in> ?r')))\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso r s f", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. iso r s f\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>f. iso r s f\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso r s f \\<Longrightarrow> ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. iso r s f", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>f. iso r s f\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "using FA FB \\<open>small A\\<close> iso_imp_ordertype_eq_ordertype r"], ["proof (prove)\nusing this:\n  \\<exists>f. iso r s f\n  Field r = A\n  Field s = B\n  small A\n  \\<lbrakk>iso ?r ?r' ?f; wf ?r; Total ?r; small (Field ?r)\\<rbrakk>\n  \\<Longrightarrow> ordertype (Field ?r) ?r = ordertype (Field ?r') ?r'\n  wf r\n  total_on A r\n  trans r\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "by blast"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Limit_ordertype_imp_Field_Restr:\n  assumes Lim: \"Limit (ordertype A r)\" and r: \"wf r\" \"total_on A r\" and \"small A\"\n  shows \"Field (Restr r A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Restr r A) = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Field (Restr r A) = A", "have \"\\<exists>y\\<in>A. (x,y) \\<in> r\" if \"x \\<in> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "let ?oy = \"succ (ordermap A r x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "have \\<section>: \"?oy \\<in> elts (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (ordermap A r x) \\<in> elts (ordertype A r)", "by (simp add: Lim \\<open>small A\\<close> ordermap_in_ordertype succ_in_Limit_iff that)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (ordermap A r x) \\<in> elts (ordertype A r)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "then"], ["proof (chain)\npicking this:\n  ZFC_in_HOL.succ (ordermap A r x) \\<in> elts (ordertype A r)", "have A: \"inv_into A (ordermap A r) ?oy \\<in> A\""], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ (ordermap A r x) \\<in> elts (ordertype A r)\n\ngoal (1 subgoal):\n 1. inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)) \\<in> A", "by (simp add: inv_into_ordermap)"], ["proof (state)\nthis:\n  inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "moreover"], ["proof (state)\nthis:\n  inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)) \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "have \"(x, inv_into A (ordermap A r) ?oy) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)))\n    \\<in> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)))\n    \\<in> r", "have \"ordermap A r x \\<in> elts (ordermap A r (inv_into A (ordermap A r) ?oy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r x\n    \\<in> elts\n           (ordermap A r\n             (inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))))", "by (metis \"\\<section>\" elts_succ f_inv_into_f insert_iff ordermap_surj subsetD)"], ["proof (state)\nthis:\n  ordermap A r x\n  \\<in> elts\n         (ordermap A r\n           (inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))))\n\ngoal (1 subgoal):\n 1. (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)))\n    \\<in> r", "then"], ["proof (chain)\npicking this:\n  ordermap A r x\n  \\<in> elts\n         (ordermap A r\n           (inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))))", "show ?thesis"], ["proof (prove)\nusing this:\n  ordermap A r x\n  \\<in> elts\n         (ordermap A r\n           (inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))))\n\ngoal (1 subgoal):\n 1. (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)))\n    \\<in> r", "by (metis \\<open>small A\\<close> A converse_ordermap_mono r that)"], ["proof (state)\nthis:\n  (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", "ultimately"], ["proof (chain)\npicking this:\n  inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)) \\<in> A\n  (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))) \\<in> r", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x)) \\<in> A\n  (x, inv_into A (ordermap A r) (ZFC_in_HOL.succ (ordermap A r x))) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>A. (x, y) \\<in> r", ".."], ["proof (state)\nthis:\n  \\<exists>y\\<in>A. (x, y) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>A. (?x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. Field (Restr r A) = A", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>A. (?x, y) \\<in> r", "have \"A \\<subseteq> Field (Restr r A)\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> \\<exists>y\\<in>A. (?x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Field (Restr r A)", "by (auto simp: Field_def)"], ["proof (state)\nthis:\n  A \\<subseteq> Field (Restr r A)\n\ngoal (1 subgoal):\n 1. Field (Restr r A) = A", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> Field (Restr r A)", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> Field (Restr r A)\n\ngoal (1 subgoal):\n 1. Field (Restr r A) = A", "by (simp add: Field_Restr_subset subset_antisym)"], ["proof (state)\nthis:\n  Field (Restr r A) = A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_Field_Restr:\n  assumes \"wf r\" \"total_on A r\" \"trans r\" \"small A\" \"Field (Restr r A) = A\"\n  shows \"ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (Field (Restr r A)) (Restr r A) = ordertype A r", "using assms"], ["proof (prove)\nusing this:\n  wf r\n  total_on A r\n  trans r\n  small A\n  Field (Restr r A) = A\n\ngoal (1 subgoal):\n 1. ordertype (Field (Restr r A)) (Restr r A) = ordertype A r", "by (force simp: ordertype_eq_ordertype wf_Restr total_on_def trans_Restr)"], ["", "proposition ordertype_eq_ordertype_iso_Restr:\n  assumes r: \"wf r\" \"total_on A r\" \"trans r\" and \"small A\" and FA: \"Field (Restr r A) = A\"\n  assumes s: \"wf s\" \"total_on B s\" \"trans s\" and \"small B\" and FB: \"Field (Restr s B) = B\"\n  shows \"ordertype A r = ordertype B s \\<longleftrightarrow> (\\<exists>f. iso (Restr r A) (Restr s B) f)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r = ordertype B s) =\n    (\\<exists>f. iso (Restr r A) (Restr s B) f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f. iso (Restr r A) (Restr s B) f\n 2. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "assume L: ?lhs"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f. iso (Restr r A) (Restr s B) f\n 2. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  ordertype A r = ordertype B s", "obtain f where \"bij_betw f A B\" \"\\<forall>x \\<in> A. \\<forall>y \\<in> A. (f x, f y) \\<in> s \\<longleftrightarrow> (x,y) \\<in> r\""], ["proof (prove)\nusing this:\n  ordertype A r = ordertype B s\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij_betw f A B;\n         \\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms ordertype_eq_ordertype"], ["proof (prove)\nusing this:\n  ordertype A r = ordertype B s\n  wf r\n  total_on A r\n  trans r\n  small A\n  Field (Restr r A) = A\n  wf s\n  total_on B s\n  trans s\n  small B\n  Field (Restr s B) = B\n  \\<lbrakk>wf ?r; total_on ?A ?r; trans ?r; small ?A; wf ?s; total_on ?B ?s;\n   trans ?s; small ?B\\<rbrakk>\n  \\<Longrightarrow> (ordertype ?A ?r = ordertype ?B ?s) =\n                    (\\<exists>f.\n                        bij_betw f ?A ?B \\<and>\n                        (\\<forall>x\\<in>?A.\n                            \\<forall>y\\<in>?A.\n                               ((f x, f y) \\<in> ?s) = ((x, y) \\<in> ?r)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>bij_betw f A B;\n         \\<forall>x\\<in>A.\n            \\<forall>y\\<in>A.\n               ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n\ngoal (2 subgoals):\n 1. ordertype A r = ordertype B s \\<Longrightarrow>\n    \\<exists>f. iso (Restr r A) (Restr s B) f\n 2. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "then"], ["proof (chain)\npicking this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)", "show ?rhs"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f", "using FA FB bij_betwE"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n  Field (Restr r A) = A\n  Field (Restr s B) = B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f", "unfolding iso_iff2"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A. ((f x, f y) \\<in> s) = ((x, y) \\<in> r)\n  Field (Restr r A) = A\n  Field (Restr s B) = B\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (Field (Restr r A)) (Field (Restr s B)) \\<and>\n       (\\<forall>a\\<in>Field (Restr r A).\n           \\<forall>b\\<in>Field (Restr r A).\n              ((a, b) \\<in> Restr r A) = ((f a, f b) \\<in> Restr s B))", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "moreover"], ["proof (state)\nthis:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "have \"ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (Field (Restr r A)) (Restr r A) = ordertype A r", "using FA \\<open>small A\\<close> ordertype_Field_Restr r"], ["proof (prove)\nusing this:\n  Field (Restr r A) = A\n  small A\n  \\<lbrakk>wf ?r; total_on ?A ?r; trans ?r; small ?A;\n   Field (Restr ?r ?A) = ?A\\<rbrakk>\n  \\<Longrightarrow> ordertype (Field (Restr ?r ?A)) (Restr ?r ?A) =\n                    ordertype ?A ?r\n  wf r\n  total_on A r\n  trans r\n\ngoal (1 subgoal):\n 1. ordertype (Field (Restr r A)) (Restr r A) = ordertype A r", "by blast"], ["proof (state)\nthis:\n  ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "moreover"], ["proof (state)\nthis:\n  ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "have \"ordertype (Field (Restr s B)) (Restr s B) = ordertype B s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (Field (Restr s B)) (Restr s B) = ordertype B s", "using FB \\<open>small B\\<close> ordertype_Field_Restr s"], ["proof (prove)\nusing this:\n  Field (Restr s B) = B\n  small B\n  \\<lbrakk>wf ?r; total_on ?A ?r; trans ?r; small ?A;\n   Field (Restr ?r ?A) = ?A\\<rbrakk>\n  \\<Longrightarrow> ordertype (Field (Restr ?r ?A)) (Restr ?r ?A) =\n                    ordertype ?A ?r\n  wf s\n  total_on B s\n  trans s\n\ngoal (1 subgoal):\n 1. ordertype (Field (Restr s B)) (Restr s B) = ordertype B s", "by blast"], ["proof (state)\nthis:\n  ordertype (Field (Restr s B)) (Restr s B) = ordertype B s\n\ngoal (1 subgoal):\n 1. \\<exists>f. iso (Restr r A) (Restr s B) f \\<Longrightarrow>\n    ordertype A r = ordertype B s", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n  ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\n  ordertype (Field (Restr s B)) (Restr s B) = ordertype B s", "show ?lhs"], ["proof (prove)\nusing this:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n  ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\n  ordertype (Field (Restr s B)) (Restr s B) = ordertype B s\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "using iso_imp_ordertype_eq_ordertype FA FB \\<open>small A\\<close> r"], ["proof (prove)\nusing this:\n  \\<exists>f. iso (Restr r A) (Restr s B) f\n  ordertype (Field (Restr r A)) (Restr r A) = ordertype A r\n  ordertype (Field (Restr s B)) (Restr s B) = ordertype B s\n  \\<lbrakk>iso ?r ?r' ?f; wf ?r; Total ?r; small (Field ?r)\\<rbrakk>\n  \\<Longrightarrow> ordertype (Field ?r) ?r = ordertype (Field ?r') ?r'\n  Field (Restr r A) = A\n  Field (Restr s B) = B\n  small A\n  wf r\n  total_on A r\n  trans r\n\ngoal (1 subgoal):\n 1. ordertype A r = ordertype B s", "by (fastforce intro: total_on_imp_Total_Restr trans_Restr wf_Int1)"], ["proof (state)\nthis:\n  ordertype A r = ordertype B s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordermap_insert:\n  assumes \"Ord \\<alpha>\" and y: \"Ord y\" \"y \\<le> \\<alpha>\" and U: \"U \\<subseteq> elts \\<alpha>\"\n  shows \"ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y", "using y"], ["proof (prove)\nusing this:\n  Ord y\n  y \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y", "proof (induction rule: Ord_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<le> \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                             ordermap U VWF y;\n        x \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF x =\n                         ordermap U VWF x", "case (step y)"], ["proof (state)\nthis:\n  Ord y\n  \\<lbrakk>?y \\<in> elts y; ?y \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF ?y = ordermap U VWF ?y\n  y \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<le> \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                             ordermap U VWF y;\n        x \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF x =\n                         ordermap U VWF x", "then"], ["proof (chain)\npicking this:\n  Ord y\n  \\<lbrakk>?y \\<in> elts y; ?y \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF ?y = ordermap U VWF ?y\n  y \\<le> \\<alpha>", "have 1: \"{u \\<in> U. (u, y) \\<in> VWF} = elts y \\<inter> U\""], ["proof (prove)\nusing this:\n  Ord y\n  \\<lbrakk>?y \\<in> elts y; ?y \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF ?y = ordermap U VWF ?y\n  y \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. {u \\<in> U. (u, y) \\<in> VWF} = elts y \\<inter> U", "apply (simp add: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord y;\n     \\<And>y.\n        \\<lbrakk>y \\<in> elts y; y \\<le> \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                          ordermap U VWF y;\n     y \\<le> \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         (x \\<in> U \\<and> (x, y) \\<in> VWF) =\n                         (x \\<in> elts y \\<and> x \\<in> U)", "by (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less assms subsetD)"], ["proof (state)\nthis:\n  {u \\<in> U. (u, y) \\<in> VWF} = elts y \\<inter> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<le> \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                             ordermap U VWF y;\n        x \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF x =\n                         ordermap U VWF x", "have 2: \"{u \\<in> insert \\<alpha> U. (u, y) \\<in> VWF} = elts y \\<inter> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u \\<in> insert \\<alpha> U. (u, y) \\<in> VWF} = elts y \\<inter> U", "apply (simp add: set_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((x = \\<alpha> \\<or> x \\<in> U) \\<and> (x, y) \\<in> VWF) =\n       (x \\<in> elts y \\<and> x \\<in> U)", "by (meson Ord_in_Ord Ord_mem_iff_lt VWF_iff_Ord_less assms leD step.hyps step.prems subsetD)"], ["proof (state)\nthis:\n  {u \\<in> insert \\<alpha> U. (u, y) \\<in> VWF} = elts y \\<inter> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ord x;\n        \\<And>y.\n           \\<lbrakk>y \\<in> elts x; y \\<le> \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                             ordermap U VWF y;\n        x \\<le> \\<alpha>\\<rbrakk>\n       \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF x =\n                         ordermap U VWF x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y", "using step"], ["proof (prove)\nusing this:\n  Ord y\n  \\<lbrakk>?y \\<in> elts y; ?y \\<le> \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF ?y = ordermap U VWF ?y\n  y \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y", "apply (simp only: ordermap [OF wf_VWF, of _ y] 1 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord y;\n     \\<And>y.\n        \\<lbrakk>y \\<in> elts y; y \\<le> \\<alpha>\\<rbrakk>\n        \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF y =\n                          ordermap U VWF y;\n     y \\<le> \\<alpha>\\<rbrakk>\n    \\<Longrightarrow> set (ordermap (insert \\<alpha> U) VWF `\n                           (elts y \\<inter> U)) =\n                      set (ordermap U VWF ` (elts y \\<inter> U))", "by (meson Int_lower1 Ord_is_Transset Sup.SUP_cong Transset_def assms(1) in_mono vsubsetD)"], ["proof (state)\nthis:\n  ordermap (insert \\<alpha> U) VWF y = ordermap U VWF y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_insert:\n  assumes \"Ord \\<alpha>\" and U: \"U \\<subseteq> elts \\<alpha>\"\n  shows \"ordertype (insert \\<alpha> U) VWF = succ (ordertype U VWF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "have \\<dagger>: \"{y \\<in> insert \\<alpha> U. (y, \\<alpha>) \\<in> VWF} = U\" \"{y \\<in> U. (y, \\<alpha>) \\<in> VWF} = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y \\<in> insert \\<alpha> U. (y, \\<alpha>) \\<in> VWF} = U &&&\n    {y \\<in> U. (y, \\<alpha>) \\<in> VWF} = U", "using Ord_in_Ord OrdmemD assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  Ord \\<alpha>\n  U \\<subseteq> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. {y \\<in> insert \\<alpha> U. (y, \\<alpha>) \\<in> VWF} = U &&&\n    {y \\<in> U. (y, \\<alpha>) \\<in> VWF} = U", "by auto"], ["proof (state)\nthis:\n  {y \\<in> insert \\<alpha> U. (y, \\<alpha>) \\<in> VWF} = U\n  {y \\<in> U. (y, \\<alpha>) \\<in> VWF} = U\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "have eq: \"\\<And>x. x \\<in> U \\<Longrightarrow> ordermap (insert \\<alpha> U) VWF x = ordermap U VWF x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       ordermap (insert \\<alpha> U) VWF x = ordermap U VWF x", "by (meson Ord_in_Ord Ord_is_Transset Transset_def U assms(1) in_mono ordermap_insert)"], ["proof (state)\nthis:\n  ?x \\<in> U \\<Longrightarrow>\n  ordermap (insert \\<alpha> U) VWF ?x = ordermap U VWF ?x\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "have \"ordertype (insert \\<alpha> U) VWF =\n        ZFC_in_HOL.set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF =\n    set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U))", "by (simp add: ordertype_def ordermap_insert assms eq)"], ["proof (state)\nthis:\n  ordertype (insert \\<alpha> U) VWF =\n  set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U))\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "also"], ["proof (state)\nthis:\n  ordertype (insert \\<alpha> U) VWF =\n  set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U))\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "have \"\\<dots> = succ (ZFC_in_HOL.set (ordermap U VWF ` U))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U)) =\n    ZFC_in_HOL.succ (set (ordermap U VWF ` U))", "using \"\\<dagger>\" U"], ["proof (prove)\nusing this:\n  {y \\<in> insert \\<alpha> U. (y, \\<alpha>) \\<in> VWF} = U\n  {y \\<in> U. (y, \\<alpha>) \\<in> VWF} = U\n  U \\<subseteq> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U)) =\n    ZFC_in_HOL.succ (set (ordermap U VWF ` U))", "by (simp add: ordermap [OF wf_VWF, of _ \\<alpha>] down succ_def vinsert_def)"], ["proof (state)\nthis:\n  set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U)) =\n  ZFC_in_HOL.succ (set (ordermap U VWF ` U))\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "also"], ["proof (state)\nthis:\n  set (insert (ordermap U VWF \\<alpha>) (ordermap U VWF ` U)) =\n  ZFC_in_HOL.succ (set (ordermap U VWF ` U))\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "have \"\\<dots> = succ (ordertype U VWF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ (set (ordermap U VWF ` U)) =\n    ZFC_in_HOL.succ (ordertype U VWF)", "by (simp add: ordertype_def)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ (set (ordermap U VWF ` U)) =\n  ZFC_in_HOL.succ (ordertype U VWF)\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "finally"], ["proof (chain)\npicking this:\n  ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)\n\ngoal (1 subgoal):\n 1. ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)", "."], ["proof (state)\nthis:\n  ordertype (insert \\<alpha> U) VWF = ZFC_in_HOL.succ (ordertype U VWF)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ordertype_le_card:\n  assumes \"finite A\" \"wf r\" \"trans r\" \n  shows \"ordertype A r \\<le> ord_of_nat (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "have \"Ord (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ordertype A r)", "by (simp add: wf_Ord_ordertype assms)"], ["proof (state)\nthis:\n  Ord (ordertype A r)\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "moreover"], ["proof (state)\nthis:\n  Ord (ordertype A r)\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "have \"ordermap A r ` A = elts (ordertype A r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordermap A r ` A = elts (ordertype A r)", "by (simp add: ordertype_def finite_imp_small \\<open>finite A\\<close>)"], ["proof (state)\nthis:\n  ordermap A r ` A = elts (ordertype A r)\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "moreover"], ["proof (state)\nthis:\n  ordermap A r ` A = elts (ordertype A r)\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "have \"card (ordermap A r ` A) \\<le> card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ordermap A r ` A) \\<le> card A", "using \\<open>finite A\\<close> card_image_le"], ["proof (prove)\nusing this:\n  finite A\n  finite ?A \\<Longrightarrow> card (?f ` ?A) \\<le> card ?A\n\ngoal (1 subgoal):\n 1. card (ordermap A r ` A) \\<le> card A", "by blast"], ["proof (state)\nthis:\n  card (ordermap A r ` A) \\<le> card A\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "ultimately"], ["proof (chain)\npicking this:\n  Ord (ordertype A r)\n  ordermap A r ` A = elts (ordertype A r)\n  card (ordermap A r ` A) \\<le> card A", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord (ordertype A r)\n  ordermap A r ` A = elts (ordertype A r)\n  card (ordermap A r ` A) \\<le> card A\n\ngoal (1 subgoal):\n 1. ordertype A r \\<le> ord_of_nat (card A)", "by (metis Ord_linear_le Ord_ord_of_nat \\<open>finite A\\<close> card_ord_of_nat card_seteq finite_imageI less_eq_V_def)"], ["proof (state)\nthis:\n  ordertype A r \\<le> ord_of_nat (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_VWF_\\<omega>:\n  assumes \"finite A\"\n  shows \"ordertype A VWF \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A VWF \\<in> elts \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype A VWF \\<in> elts \\<omega>", "have \"finite (ordermap A VWF ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ordermap A VWF ` A)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (ordermap A VWF ` A)", "by blast"], ["proof (state)\nthis:\n  finite (ordermap A VWF ` A)\n\ngoal (1 subgoal):\n 1. ordertype A VWF \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  finite (ordermap A VWF ` A)", "have \"ordertype A VWF < \\<omega>\""], ["proof (prove)\nusing this:\n  finite (ordermap A VWF ` A)\n\ngoal (1 subgoal):\n 1. ordertype A VWF < \\<omega>", "by (meson Ord_\\<omega> OrdmemD trans_VWF wf_VWF assms finite_ordertype_le_card le_less_trans ord_of_nat_\\<omega>)"], ["proof (state)\nthis:\n  ordertype A VWF < \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype A VWF \\<in> elts \\<omega>", "then"], ["proof (chain)\npicking this:\n  ordertype A VWF < \\<omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype A VWF < \\<omega>\n\ngoal (1 subgoal):\n 1. ordertype A VWF \\<in> elts \\<omega>", "by (simp add: Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  ordertype A VWF \\<in> elts \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_VWF_finite_nat:\n  assumes \"finite A\"\n  shows \"ordertype A VWF = ord_of_nat (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A VWF = ord_of_nat (card A)", "by (metis finite_imp_small ordermap_bij total_on_VWF wf_VWF \\<omega>_def assms bij_betw_same_card card_ord_of_nat elts_of_set f_inv_into_f inf ordertype_VWF_\\<omega>)"], ["", "lemma finite_ordertype_eq_card:\n  assumes \"small A\" \"wf r\" \"trans r\" \"total_on A r\"\n  shows \"ordertype A r = ord_of_nat m \\<longleftrightarrow> finite A \\<and> card A = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "using ordermap_bij [OF \\<open>wf r\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>total_on ?A r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A r) ?A (elts (ordertype ?A r))\n\ngoal (1 subgoal):\n 1. (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>total_on A r; small A\\<rbrakk>\n        \\<Longrightarrow> bij_betw (ordermap A r) A\n                           (elts (ordertype A r))) \\<Longrightarrow>\n    (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "have *: \"bij_betw (ordermap A r) A (elts (ordertype A r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap A r) A (elts (ordertype A r))", "by (simp add: assms ordermap_bij)"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>total_on A r; small A\\<rbrakk>\n        \\<Longrightarrow> bij_betw (ordermap A r) A\n                           (elts (ordertype A r))) \\<Longrightarrow>\n    (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "moreover"], ["proof (state)\nthis:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>total_on A r; small A\\<rbrakk>\n        \\<Longrightarrow> bij_betw (ordermap A r) A\n                           (elts (ordertype A r))) \\<Longrightarrow>\n    (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "have \"card (ordermap A r ` A) = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (ordermap A r ` A) = card A", "by (meson bij_betw_def * card_image)"], ["proof (state)\nthis:\n  card (ordermap A r ` A) = card A\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>total_on A r; small A\\<rbrakk>\n        \\<Longrightarrow> bij_betw (ordermap A r) A\n                           (elts (ordertype A r))) \\<Longrightarrow>\n    (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n  card (ordermap A r ` A) = card A", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n  card (ordermap A r ` A) = card A\n\ngoal (1 subgoal):\n 1. (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "using assms bij_betw_finite bij_betw_imp_surj_on finite_Ord_omega ordertype_VWF_finite_nat wf_Ord_ordertype"], ["proof (prove)\nusing this:\n  bij_betw (ordermap A r) A (elts (ordertype A r))\n  card (ordermap A r ` A) = card A\n  small A\n  wf r\n  trans r\n  total_on A r\n  bij_betw ?f ?A ?B \\<Longrightarrow> finite ?A = finite ?B\n  bij_betw ?f ?A ?B \\<Longrightarrow> ?f ` ?A = ?B\n  ?\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts ?\\<alpha>)\n  finite ?A \\<Longrightarrow> ordertype ?A VWF = ord_of_nat (card ?A)\n  \\<lbrakk>wf ?r; trans ?r\\<rbrakk> \\<Longrightarrow> Ord (ordertype ?A ?r)\n\ngoal (1 subgoal):\n 1. (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)", "by fastforce"], ["proof (state)\nthis:\n  (ordertype A r = ord_of_nat m) = (finite A \\<and> card A = m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_bij_betw_strict_mono_card:\n  assumes \"finite M\" \"M \\<subseteq> ON\"\n  obtains h where \"bij_betw h {..<card M} M\" and \"strict_mono_on h {..<card M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>bij_betw h {..<card M} M;\n         strict_mono_on h {..<card M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>bij_betw h {..<card M} M;\n         strict_mono_on h {..<card M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have bij: \"bij_betw (ordermap M VWF) M (elts (card M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ordermap M VWF) M (elts (ord_of_nat (card M)))", "using Finite_V \\<open>finite M\\<close> ordermap_bij ordertype_VWF_finite_nat"], ["proof (prove)\nusing this:\n  finite ?X \\<Longrightarrow> small ?X\n  finite M\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n  finite ?A \\<Longrightarrow> ordertype ?A VWF = ord_of_nat (card ?A)\n\ngoal (1 subgoal):\n 1. bij_betw (ordermap M VWF) M (elts (ord_of_nat (card M)))", "by fastforce"], ["proof (state)\nthis:\n  bij_betw (ordermap M VWF) M (elts (ord_of_nat (card M)))\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>bij_betw h {..<card M} M;\n         strict_mono_on h {..<card M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?h = \"(inv_into M (ordermap M VWF)) \\<circ> ord_of_nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>bij_betw h {..<card M} M;\n         strict_mono_on h {..<card M}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ?h {..<card M} M\n 2. strict_mono_on ?h {..<card M}", "show bijh: \"bij_betw ?h {..<card M} M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) {..<card M} M", "proof (rule bij_betw_trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ord_of_nat {..<card M} ?B\n 2. bij_betw (inv_into M (ordermap M VWF)) ?B M", "show \"bij_betw ord_of_nat {..<card M} (elts (card M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ord_of_nat {..<card M} (elts (ord_of_nat (card M)))", "by (simp add: bij_betw_def elts_ord_of_nat inj_on_def)"], ["proof (state)\nthis:\n  bij_betw ord_of_nat {..<card M} (elts (ord_of_nat (card M)))\n\ngoal (1 subgoal):\n 1. bij_betw (inv_into M (ordermap M VWF)) (elts (ord_of_nat (card M))) M", "show \"bij_betw (inv_into M (ordermap M VWF)) (elts (card M)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (inv_into M (ordermap M VWF)) (elts (ord_of_nat (card M))) M", "using Finite_V assms bij_betw_inv_into ordermap_bij ordertype_VWF_finite_nat"], ["proof (prove)\nusing this:\n  finite ?X \\<Longrightarrow> small ?X\n  finite M\n  M \\<subseteq> ON\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n  \\<lbrakk>wf ?r; total_on ?A ?r; small ?A\\<rbrakk>\n  \\<Longrightarrow> bij_betw (ordermap ?A ?r) ?A (elts (ordertype ?A ?r))\n  finite ?A \\<Longrightarrow> ordertype ?A VWF = ord_of_nat (card ?A)\n\ngoal (1 subgoal):\n 1. bij_betw (inv_into M (ordermap M VWF)) (elts (ord_of_nat (card M))) M", "by fastforce"], ["proof (state)\nthis:\n  bij_betw (inv_into M (ordermap M VWF)) (elts (ord_of_nat (card M))) M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) {..<card M} M\n\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n     {..<card M}", "show \"strict_mono_on ?h {..<card M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n     {..<card M}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n     {..<card M}", "have \"?h m < ?h n\"\n        if \"m < n\" \"n < card M\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "obtain mn: \"m \\<in> elts (ordertype M VWF)\" \"n \\<in> elts (ordertype M VWF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>ord_of_nat m \\<in> elts (ordertype M VWF);\n      ord_of_nat n \\<in> elts (ordertype M VWF)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>m < n\\<close> \\<open>n < card M\\<close> \\<open>finite M\\<close> ordertype_VWF_finite_nat"], ["proof (prove)\nusing this:\n  m < n\n  n < card M\n  finite M\n  finite ?A \\<Longrightarrow> ordertype ?A VWF = ord_of_nat (card ?A)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>ord_of_nat m \\<in> elts (ordertype M VWF);\n      ord_of_nat n \\<in> elts (ordertype M VWF)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ord_of_nat m \\<in> elts (ordertype M VWF)\n  ord_of_nat n \\<in> elts (ordertype M VWF)\n\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "have ord: \"Ord (?h m)\" \"Ord (?h n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m) &&&\n    Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)", "using bijh assms(2) bij_betwE that"], ["proof (prove)\nusing this:\n  bij_betw (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) {..<card M} M\n  M \\<subseteq> ON\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  m < n\n  n < card M\n\ngoal (1 subgoal):\n 1. Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m) &&&\n    Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)", "by fastforce+"], ["proof (state)\nthis:\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m)\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)\n\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m)\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)\n\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "assume \"\\<not> ?h m < ?h n\""], ["proof (state)\nthis:\n  \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n         < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m)\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)\n  \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n         < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n", "consider \"?h m = ?h n\" | \"?h m > ?h n\""], ["proof (prove)\nusing this:\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m)\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)\n  \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n         < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n             (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n             thesis;\n     (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n     < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Ord_linear_lt"], ["proof (prove)\nusing this:\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m)\n  Ord ((inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n)\n  \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n         < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n  \\<lbrakk>Ord ?k; Ord ?l; ?k < ?l \\<Longrightarrow> ?thesis;\n   ?k = ?l \\<Longrightarrow> ?thesis;\n   ?l < ?k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n             (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n             thesis;\n     (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n     < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>(inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n           (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n            n \\<Longrightarrow>\n           ?thesis;\n   (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n   < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n           < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n              n \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n           (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n            n \\<Longrightarrow>\n           ?thesis;\n   (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n   < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>(inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n           (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n            n \\<Longrightarrow>\n           ?thesis;\n   (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n   < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n    (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n \\<Longrightarrow>\n    False\n 2. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n\ngoal (2 subgoals):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n    (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n \\<Longrightarrow>\n    False\n 2. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n", "have \"m = n\""], ["proof (prove)\nusing this:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n\ngoal (1 subgoal):\n 1. m = n", "by (metis inv_ordermap_mono_eq mn comp_apply ord_of_nat_inject)"], ["proof (state)\nthis:\n  m = n\n\ngoal (2 subgoals):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m =\n    (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n \\<Longrightarrow>\n    False\n 2. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "with \\<open>m < n\\<close>"], ["proof (chain)\npicking this:\n  m < n\n  m = n", "show False"], ["proof (prove)\nusing this:\n  m < n\n  m = n\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "case 2"], ["proof (state)\nthis:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n  < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n\ngoal (1 subgoal):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n  < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m", "have \"ord_of_nat n \\<le> ord_of_nat m\""], ["proof (prove)\nusing this:\n  (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n  < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m\n\ngoal (1 subgoal):\n 1. ord_of_nat n \\<le> ord_of_nat m", "by (metis Finite_V mn assms comp_def inv_ordermap_VWF_mono_le less_imp_le)"], ["proof (state)\nthis:\n  ord_of_nat n \\<le> ord_of_nat m\n\ngoal (1 subgoal):\n 1. (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) n\n    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) m \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ord_of_nat n \\<le> ord_of_nat m", "show ?thesis"], ["proof (prove)\nusing this:\n  ord_of_nat n \\<le> ord_of_nat m\n\ngoal (1 subgoal):\n 1. False", "using leD \\<open>m < n\\<close>"], ["proof (prove)\nusing this:\n  ord_of_nat n \\<le> ord_of_nat m\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  m < n\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m < ?n; ?n < card M\\<rbrakk>\n  \\<Longrightarrow> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?m\n                    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?n\n\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n     {..<card M}", "with assms"], ["proof (chain)\npicking this:\n  finite M\n  M \\<subseteq> ON\n  \\<lbrakk>?m < ?n; ?n < card M\\<rbrakk>\n  \\<Longrightarrow> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?m\n                    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?n", "show ?thesis"], ["proof (prove)\nusing this:\n  finite M\n  M \\<subseteq> ON\n  \\<lbrakk>?m < ?n; ?n < card M\\<rbrakk>\n  \\<Longrightarrow> (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?m\n                    < (inv_into M (ordermap M VWF) \\<circ> ord_of_nat) ?n\n\ngoal (1 subgoal):\n 1. strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n     {..<card M}", "by (auto simp: strict_mono_on_def)"], ["proof (state)\nthis:\n  strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n   {..<card M}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  strict_mono_on (inv_into M (ordermap M VWF) \\<circ> ord_of_nat)\n   {..<card M}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordertype_finite_less_than [simp]: \n  assumes \"finite A\" shows \"ordertype A less_than = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "let ?M = \"ord_of_nat ` A\""], ["proof (state)\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "obtain M: \"finite ?M\" \"?M \\<subseteq> ON\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (ord_of_nat ` A);\n      ord_of_nat ` A \\<subseteq> ON\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_ord_of_nat assms"], ["proof (prove)\nusing this:\n  Ord (ord_of_nat ?k)\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>finite (ord_of_nat ` A);\n      ord_of_nat ` A \\<subseteq> ON\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite (ord_of_nat ` A)\n  ord_of_nat ` A \\<subseteq> ON\n\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "have \"ordertype A less_than = ordertype ?M VWF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype A less_than = ordertype (ord_of_nat ` A) VWF", "by (rule ordertype_inc_eq [symmetric]) (use assms finite_imp_small total_on_def in \\<open>force+\\<close>)"], ["proof (state)\nthis:\n  ordertype A less_than = ordertype (ord_of_nat ` A) VWF\n\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "also"], ["proof (state)\nthis:\n  ordertype A less_than = ordertype (ord_of_nat ` A) VWF\n\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "have \"\\<dots> = card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordertype (ord_of_nat ` A) VWF = ord_of_nat (card A)", "proof (subst ordertype_eq_iff)"], ["proof (state)\ngoal (6 subgoals):\n 1. Ord (ord_of_nat (card A))\n 2. wf VWF\n 3. small (ord_of_nat ` A)\n 4. total_on (ord_of_nat ` A) VWF\n 5. trans VWF\n 6. \\<exists>f.\n       bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n       (\\<forall>x\\<in>ord_of_nat ` A.\n           \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))", "let ?M = \"ord_of_nat ` A\""], ["proof (state)\ngoal (6 subgoals):\n 1. Ord (ord_of_nat (card A))\n 2. wf VWF\n 3. small (ord_of_nat ` A)\n 4. total_on (ord_of_nat ` A) VWF\n 5. trans VWF\n 6. \\<exists>f.\n       bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n       (\\<forall>x\\<in>ord_of_nat ` A.\n           \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))", "obtain h where bijh: \"bij_betw h {..<card A} ?M\" and smh: \"strict_mono_on h {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>bij_betw h {..<card A} (ord_of_nat ` A);\n         strict_mono_on h {..<card A}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis M card_image ex_bij_betw_strict_mono_card inj_on_def ord_of_nat_inject)"], ["proof (state)\nthis:\n  bij_betw h {..<card A} (ord_of_nat ` A)\n  strict_mono_on h {..<card A}\n\ngoal (6 subgoals):\n 1. Ord (ord_of_nat (card A))\n 2. wf VWF\n 3. small (ord_of_nat ` A)\n 4. total_on (ord_of_nat ` A) VWF\n 5. trans VWF\n 6. \\<exists>f.\n       bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n       (\\<forall>x\\<in>ord_of_nat ` A.\n           \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))", "define f where \"f \\<equiv> ord_of_nat \\<circ> inv_into {..<card A} h\""], ["proof (state)\nthis:\n  f \\<equiv> ord_of_nat \\<circ> inv_into {..<card A} h\n\ngoal (6 subgoals):\n 1. Ord (ord_of_nat (card A))\n 2. wf VWF\n 3. small (ord_of_nat ` A)\n 4. total_on (ord_of_nat ` A) VWF\n 5. trans VWF\n 6. \\<exists>f.\n       bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n       (\\<forall>x\\<in>ord_of_nat ` A.\n           \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))", "show \"\\<exists>f. bij_betw f ?M (elts (card A)) \\<and> (\\<forall>x\\<in>?M. \\<forall>y\\<in>?M. f x < f y \\<longleftrightarrow> ((x, y) \\<in> VWF))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n       (\\<forall>x\\<in>ord_of_nat ` A.\n           \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))", "proof (intro exI conjI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. bij_betw ?f (ord_of_nat ` A) (elts (ord_of_nat (card A)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (?f x < ?f y) = ((x, y) \\<in> VWF)", "have \"bij_betw (ord_of_nat \\<circ> inv_into {..<card A} h) (ord_of_nat ` A) (ord_of_nat ` {..<card A})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (ord_of_nat \\<circ> inv_into {..<card A} h) (ord_of_nat ` A)\n     (ord_of_nat ` {..<card A})", "by (meson UNIV_I bijh bij_betw_def bij_betw_inv_into bij_betw_subset bij_betw_trans inj_ord_of_nat subsetI)"], ["proof (state)\nthis:\n  bij_betw (ord_of_nat \\<circ> inv_into {..<card A} h) (ord_of_nat ` A)\n   (ord_of_nat ` {..<card A})\n\ngoal (2 subgoals):\n 1. bij_betw ?f (ord_of_nat ` A) (elts (ord_of_nat (card A)))\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (?f x < ?f y) = ((x, y) \\<in> VWF)", "then"], ["proof (chain)\npicking this:\n  bij_betw (ord_of_nat \\<circ> inv_into {..<card A} h) (ord_of_nat ` A)\n   (ord_of_nat ` {..<card A})", "show \"bij_betw f ?M (elts (card A))\""], ["proof (prove)\nusing this:\n  bij_betw (ord_of_nat \\<circ> inv_into {..<card A} h) (ord_of_nat ` A)\n   (ord_of_nat ` {..<card A})\n\ngoal (1 subgoal):\n 1. bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A)))", "by (metis elts_ord_of_nat f_def)"], ["proof (state)\nthis:\n  bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "assume xy: \"x \\<in> ?M\" \"y \\<in> ?M\""], ["proof (state)\nthis:\n  x \\<in> ord_of_nat ` A\n  y \\<in> ord_of_nat ` A\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "then"], ["proof (chain)\npicking this:\n  x \\<in> ord_of_nat ` A\n  y \\<in> ord_of_nat ` A", "obtain m n where \"x = ord_of_nat m\" \"y = ord_of_nat n\""], ["proof (prove)\nusing this:\n  x \\<in> ord_of_nat ` A\n  y \\<in> ord_of_nat ` A\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>x = ord_of_nat m; y = ord_of_nat n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = ord_of_nat m\n  y = ord_of_nat n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "have \"(f x < f y) \\<longleftrightarrow> ((h \\<circ> inv_into {..<card A} h) x < (h \\<circ> inv_into {..<card A} h) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x < f y) =\n    ((h \\<circ> inv_into {..<card A} h) x\n     < (h \\<circ> inv_into {..<card A} h) y)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ord_of_nat \\<circ> inv_into {..<card A} h) x\n     < (ord_of_nat \\<circ> inv_into {..<card A} h) y) =\n    ((h \\<circ> inv_into {..<card A} h) x\n     < (h \\<circ> inv_into {..<card A} h) y)", "using smh bij_betw_imp_surj_on [OF bijh]"], ["proof (prove)\nusing this:\n  strict_mono_on h {..<card A}\n  h ` {..<card A} = ord_of_nat ` A\n\ngoal (1 subgoal):\n 1. ((ord_of_nat \\<circ> inv_into {..<card A} h) x\n     < (ord_of_nat \\<circ> inv_into {..<card A} h) y) =\n    ((h \\<circ> inv_into {..<card A} h) x\n     < (h \\<circ> inv_into {..<card A} h) y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_mono_on h {..<card A};\n     h ` {..<card A} = ord_of_nat ` A\\<rbrakk>\n    \\<Longrightarrow> (inv_into {..<card A} h x\n                       < inv_into {..<card A} h y) =\n                      (h (inv_into {..<card A} h x)\n                       < h (inv_into {..<card A} h y))", "by (metis (mono_tags, lifting) inv_into_into not_less_iff_gr_or_eq order.asym strict_mono_onD xy)"], ["proof (state)\nthis:\n  (f x < f y) =\n  ((h \\<circ> inv_into {..<card A} h) x\n   < (h \\<circ> inv_into {..<card A} h) y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "also"], ["proof (state)\nthis:\n  (f x < f y) =\n  ((h \\<circ> inv_into {..<card A} h) x\n   < (h \\<circ> inv_into {..<card A} h) y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "have \"\\<dots> = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((h \\<circ> inv_into {..<card A} h) x\n     < (h \\<circ> inv_into {..<card A} h) y) =\n    (x < y)", "using bijh"], ["proof (prove)\nusing this:\n  bij_betw h {..<card A} (ord_of_nat ` A)\n\ngoal (1 subgoal):\n 1. ((h \\<circ> inv_into {..<card A} h) x\n     < (h \\<circ> inv_into {..<card A} h) y) =\n    (x < y)", "by (simp add: bij_betw_inv_into_right xy)"], ["proof (state)\nthis:\n  ((h \\<circ> inv_into {..<card A} h) x\n   < (h \\<circ> inv_into {..<card A} h) y) =\n  (x < y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "also"], ["proof (state)\nthis:\n  ((h \\<circ> inv_into {..<card A} h) x\n   < (h \\<circ> inv_into {..<card A} h) y) =\n  (x < y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "have \"\\<dots> \\<longleftrightarrow> ((x, y) \\<in> VWF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = ((x, y) \\<in> VWF)", "using M(2) ON_imp_Ord xy"], ["proof (prove)\nusing this:\n  ord_of_nat ` A \\<subseteq> ON\n  \\<lbrakk>?H \\<subseteq> ON; ?x \\<in> ?H\\<rbrakk> \\<Longrightarrow> Ord ?x\n  x \\<in> ord_of_nat ` A\n  y \\<in> ord_of_nat ` A\n\ngoal (1 subgoal):\n 1. (x < y) = ((x, y) \\<in> VWF)", "by auto"], ["proof (state)\nthis:\n  (x < y) = ((x, y) \\<in> VWF)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> ord_of_nat ` A; y \\<in> ord_of_nat ` A\\<rbrakk>\n       \\<Longrightarrow> (f x < f y) = ((x, y) \\<in> VWF)", "finally"], ["proof (chain)\npicking this:\n  (f x < f y) = ((x, y) \\<in> VWF)", "show \"(f x < f y) \\<longleftrightarrow> ((x, y) \\<in> VWF)\""], ["proof (prove)\nusing this:\n  (f x < f y) = ((x, y) \\<in> VWF)\n\ngoal (1 subgoal):\n 1. (f x < f y) = ((x, y) \\<in> VWF)", "."], ["proof (state)\nthis:\n  (f x < f y) = ((x, y) \\<in> VWF)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     bij_betw f (ord_of_nat ` A) (elts (ord_of_nat (card A))) \\<and>\n     (\\<forall>x\\<in>ord_of_nat ` A.\n         \\<forall>y\\<in>ord_of_nat ` A. (f x < f y) = ((x, y) \\<in> VWF))\n\ngoal (5 subgoals):\n 1. Ord (ord_of_nat (card A))\n 2. wf VWF\n 3. small (ord_of_nat ` A)\n 4. total_on (ord_of_nat ` A) VWF\n 5. trans VWF", "qed auto"], ["proof (state)\nthis:\n  ordertype (ord_of_nat ` A) VWF = ord_of_nat (card A)\n\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "finally"], ["proof (chain)\npicking this:\n  ordertype A less_than = ord_of_nat (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  ordertype A less_than = ord_of_nat (card A)\n\ngoal (1 subgoal):\n 1. ordertype A less_than = ord_of_nat (card A)", "."], ["proof (state)\nthis:\n  ordertype A less_than = ord_of_nat (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Cardinality of a set\\<close>"], ["", "definition\n  vcard :: \"V\\<Rightarrow>V\"\n  where \"vcard a \\<equiv> (LEAST i. Ord i \\<and> elts i \\<approx> elts a)\""], ["", "definition\n  Card:: \"V\\<Rightarrow>bool\" where \"Card i \\<equiv> i = vcard i\""], ["", "abbreviation CARD where \"CARD \\<equiv> Collect Card\""], ["", "lemma cardinal_cong: \"elts x \\<approx> elts y \\<Longrightarrow> vcard x = vcard y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts x \\<approx> elts y \\<Longrightarrow> vcard x = vcard y", "unfolding vcard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts x \\<approx> elts y \\<Longrightarrow>\n    (LEAST i. Ord i \\<and> elts i \\<approx> elts x) =\n    (LEAST i. Ord i \\<and> elts i \\<approx> elts y)", "by (meson eqpoll_sym eqpoll_trans)"], ["", "lemma Card_cardinal_eq: \"Card \\<kappa> \\<Longrightarrow> vcard \\<kappa> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<kappa> \\<Longrightarrow> vcard \\<kappa> = \\<kappa>", "by (simp add: Card_def)"], ["", "lemma Card_is_Ord:\n  assumes \"Card \\<kappa>\" shows \"Ord \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "obtain \\<alpha> where \"Ord \\<alpha>\" \"elts \\<alpha> \\<approx> elts \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<lbrakk>Ord \\<alpha>;\n         elts \\<alpha> \\<approx> elts \\<kappa>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ord_ordertype ordertype_eqpoll"], ["proof (prove)\nusing this:\n  Ord (ordertype ?A VWF)\n  small ?A \\<Longrightarrow> elts (ordertype ?A VWF) \\<approx> ?A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<lbrakk>Ord \\<alpha>;\n         elts \\<alpha> \\<approx> elts \\<kappa>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ord \\<alpha>\n  elts \\<alpha> \\<approx> elts \\<kappa>\n\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "then"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  elts \\<alpha> \\<approx> elts \\<kappa>", "have \"Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\""], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  elts \\<alpha> \\<approx> elts \\<kappa>\n\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "by (metis Ord_Least)"], ["proof (state)\nthis:\n  Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "then"], ["proof (chain)\npicking this:\n  Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "using Card_def vcard_def assms"], ["proof (prove)\nusing this:\n  Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n  Card ?i \\<equiv> ?i = vcard ?i\n  vcard ?a \\<equiv> LEAST i. Ord i \\<and> elts i \\<approx> elts ?a\n  Card \\<kappa>\n\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "by auto"], ["proof (state)\nthis:\n  Ord \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cardinal_eqpoll: \"elts (vcard a) \\<approx> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard a) \\<approx> elts a", "unfolding vcard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (LEAST i. Ord i \\<and> elts i \\<approx> elts a) \\<approx> elts a", "using ordertype_eqpoll [of \"elts a\"] Ord_LeastI"], ["proof (prove)\nusing this:\n  small (elts a) \\<Longrightarrow>\n  elts (ordertype (elts a) VWF) \\<approx> elts a\n  \\<lbrakk>Ord ?k; ?P ?k\\<rbrakk>\n  \\<Longrightarrow> ?P (LEAST i. Ord i \\<and> ?P i)\n\ngoal (1 subgoal):\n 1. elts (LEAST i. Ord i \\<and> elts i \\<approx> elts a) \\<approx> elts a", "by (meson Ord_ordertype small_elts)"], ["", "lemma inj_into_vcard:\n  obtains f where \"f \\<in> elts A \\<rightarrow> elts (vcard A)\" \"inj_on f (elts A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> elts A \\<rightarrow> elts (vcard A);\n         inj_on f (elts A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cardinal_eqpoll [of A] inj_on_the_inv_into the_inv_into_onto"], ["proof (prove)\nusing this:\n  elts (vcard A) \\<approx> elts A\n  inj_on ?f ?A \\<Longrightarrow> inj_on (the_inv_into ?A ?f) (?f ` ?A)\n  inj_on ?f ?A \\<Longrightarrow> the_inv_into ?A ?f ` ?f ` ?A = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> elts A \\<rightarrow> elts (vcard A);\n         inj_on f (elts A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce simp: Pi_iff bij_betw_def eqpoll_def)"], ["", "lemma cardinal_idem [simp]: \"vcard (vcard a) = vcard a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (vcard a) = vcard a", "using cardinal_cong cardinal_eqpoll"], ["proof (prove)\nusing this:\n  elts ?x \\<approx> elts ?y \\<Longrightarrow> vcard ?x = vcard ?y\n  elts (vcard ?a) \\<approx> elts ?a\n\ngoal (1 subgoal):\n 1. vcard (vcard a) = vcard a", "by blast"], ["", "text\\<open>every natural number is a (finite) cardinal\\<close>"], ["", "lemma nat_into_Card:\n  assumes \"\\<alpha> \\<in> elts \\<omega>\" shows \"Card(\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<alpha>", "proof (unfold Card_def vcard_def, rule sym)"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "obtain n where n: \"\\<alpha> = ord_of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<alpha> = ord_of_nat n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<omega>_def assms elts_of_set imageE inf)"], ["proof (state)\nthis:\n  \\<alpha> = ord_of_nat n\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "have \"Ord(\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> elts \\<omega>\n\ngoal (1 subgoal):\n 1. Ord \\<alpha>", "by auto"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "moreover"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "{"], ["proof (state)\nthis:\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "fix \\<beta>"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "assume \"\\<beta> < \\<alpha>\" \"Ord \\<beta>\" \"elts \\<beta> \\<approx> elts \\<alpha>\""], ["proof (state)\nthis:\n  \\<beta> < \\<alpha>\n  Ord \\<beta>\n  elts \\<beta> \\<approx> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "with n"], ["proof (chain)\npicking this:\n  \\<alpha> = ord_of_nat n\n  \\<beta> < \\<alpha>\n  Ord \\<beta>\n  elts \\<beta> \\<approx> elts \\<alpha>", "have \"elts \\<beta> \\<approx> {..<n}\""], ["proof (prove)\nusing this:\n  \\<alpha> = ord_of_nat n\n  \\<beta> < \\<alpha>\n  Ord \\<beta>\n  elts \\<beta> \\<approx> elts \\<alpha>\n\ngoal (1 subgoal):\n 1. elts \\<beta> \\<approx> {..<n}", "by (simp add: ord_of_nat_eq_initial [of n] eqpoll_trans inj_on_def inj_on_image_eqpoll_self)"], ["proof (state)\nthis:\n  elts \\<beta> \\<approx> {..<n}\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "hence False"], ["proof (prove)\nusing this:\n  elts \\<beta> \\<approx> {..<n}\n\ngoal (1 subgoal):\n 1. False", "using assms n  \\<open>Ord \\<beta>\\<close> \\<open>\\<beta> < \\<alpha>\\<close> \\<open>Ord(\\<alpha>)\\<close>"], ["proof (prove)\nusing this:\n  elts \\<beta> \\<approx> {..<n}\n  \\<alpha> \\<in> elts \\<omega>\n  \\<alpha> = ord_of_nat n\n  Ord \\<beta>\n  \\<beta> < \\<alpha>\n  Ord \\<alpha>\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>elts \\<beta> \\<approx> elts \\<alpha>\\<close> card_seteq eqpoll_finite_iff eqpoll_iff_card finite_lessThan less_eq_V_def less_le_not_le order_refl)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<beta>2 < \\<alpha>; Ord ?\\<beta>2;\n   elts ?\\<beta>2 \\<approx> elts \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "ultimately"], ["proof (chain)\npicking this:\n  Ord \\<alpha>\n  \\<lbrakk>?\\<beta>2 < \\<alpha>; Ord ?\\<beta>2;\n   elts ?\\<beta>2 \\<approx> elts \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> False", "show \"(LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>\""], ["proof (prove)\nusing this:\n  Ord \\<alpha>\n  \\<lbrakk>?\\<beta>2 < \\<alpha>; Ord ?\\<beta>2;\n   elts ?\\<beta>2 \\<approx> elts \\<alpha>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>", "by (metis (no_types, lifting) Least_equality Ord_linear_le eqpoll_refl less_le_not_le)"], ["proof (state)\nthis:\n  (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<alpha>) = \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Card_ord_of_nat [simp]: \"Card (ord_of_nat n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card (ord_of_nat n)", "by (simp add: \\<omega>_def nat_into_Card)"], ["", "lemma Card_0 [iff]: \"Card 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card 0", "by (simp add: nat_into_Card)"], ["", "lemma CardI: \"\\<lbrakk>Ord i; \\<And>j. \\<lbrakk>j < i; Ord j\\<rbrakk> \\<Longrightarrow> \\<not> elts j \\<approx> elts i\\<rbrakk> \\<Longrightarrow> Card i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i;\n     \\<And>j.\n        \\<lbrakk>j < i; Ord j\\<rbrakk>\n        \\<Longrightarrow> \\<not> elts j \\<approx> elts i\\<rbrakk>\n    \\<Longrightarrow> Card i", "unfolding Card_def vcard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord i;\n     \\<And>j.\n        \\<lbrakk>j < i; Ord j\\<rbrakk>\n        \\<Longrightarrow> \\<not> elts j \\<approx> elts i\\<rbrakk>\n    \\<Longrightarrow> i = (LEAST ia. Ord ia \\<and> elts ia \\<approx> elts i)", "by (metis Ord_Least Ord_linear_lt cardinal_eqpoll eqpoll_refl not_less_Ord_Least vcard_def)"], ["", "lemma vcard_0 [simp]: \"vcard 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard 0 = 0", "using Card_0 Card_def"], ["proof (prove)\nusing this:\n  Card 0\n  Card ?i \\<equiv> ?i = vcard ?i\n\ngoal (1 subgoal):\n 1. vcard 0 = 0", "by auto"], ["", "lemma Ord_cardinal [simp,intro!]: \"Ord(vcard a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (vcard a)", "unfolding vcard_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (LEAST i. Ord i \\<and> elts i \\<approx> elts a)", "by (metis Card_def Card_is_Ord cardinal_cong cardinal_eqpoll vcard_def)"], ["", "text\\<open>The cardinals are the initial ordinals.\\<close>"], ["", "lemma Card_iff_initial: \"Card \\<kappa> \\<longleftrightarrow> Ord \\<kappa> \\<and> (\\<forall>\\<alpha>. Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow> ~ elts \\<alpha> \\<approx> elts \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "assume \\<kappa>: \"Card \\<kappa>\" \"elts j \\<approx> elts \\<kappa>\" \"Ord j\""], ["proof (state)\nthis:\n  Card \\<kappa>\n  elts j \\<approx> elts \\<kappa>\n  Ord j\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "assume \"j < \\<kappa>\""], ["proof (state)\nthis:\n  j < \\<kappa>\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "also"], ["proof (state)\nthis:\n  j < \\<kappa>\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "have \"\\<dots> = (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> = (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "using \\<kappa>"], ["proof (prove)\nusing this:\n  Card \\<kappa>\n  elts j \\<approx> elts \\<kappa>\n  Ord j\n\ngoal (1 subgoal):\n 1. \\<kappa> = (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "by (simp add: Card_def vcard_def)"], ["proof (state)\nthis:\n  \\<kappa> = (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "finally"], ["proof (chain)\npicking this:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "have \"j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\""], ["proof (prove)\nusing this:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)", "."], ["proof (state)\nthis:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "hence \"False\""], ["proof (prove)\nusing this:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. False", "using \\<kappa>"], ["proof (prove)\nusing this:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n  Card \\<kappa>\n  elts j \\<approx> elts \\<kappa>\n  Ord j\n\ngoal (1 subgoal):\n 1. False", "using not_less_Ord_Least"], ["proof (prove)\nusing this:\n  j < (LEAST i. Ord i \\<and> elts i \\<approx> elts \\<kappa>)\n  Card \\<kappa>\n  elts j \\<approx> elts \\<kappa>\n  Ord j\n  \\<lbrakk>?k < (LEAST x. Ord x \\<and> ?P x); Ord ?k\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Card \\<kappa>; elts ?j2 \\<approx> elts \\<kappa>; Ord ?j2;\n   ?j2 < \\<kappa>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Card \\<kappa>; elts ?j2 \\<approx> elts \\<kappa>; Ord ?j2;\n   ?j2 < \\<kappa>\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Card \\<kappa>; elts ?j2 \\<approx> elts \\<kappa>; Ord ?j2;\n   ?j2 < \\<kappa>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Card \\<kappa> =\n    (Ord \\<kappa> \\<and>\n     (\\<forall>\\<alpha>.\n         Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n         \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))", "by (blast intro: CardI Card_is_Ord)"], ["proof (state)\nthis:\n  Card \\<kappa> =\n  (Ord \\<kappa> \\<and>\n   (\\<forall>\\<alpha>.\n       Ord \\<alpha> \\<and> \\<alpha> < \\<kappa> \\<longrightarrow>\n       \\<not> elts \\<alpha> \\<approx> elts \\<kappa>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Card_\\<omega> [iff]: \"Card \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Card \\<omega>", "have \"\\<And>\\<alpha> f. \\<lbrakk>\\<alpha> \\<in> elts \\<omega>; bij_betw f (elts \\<alpha>) (elts \\<omega>)\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> f.\n       \\<lbrakk>\\<alpha> \\<in> elts \\<omega>;\n        bij_betw f (elts \\<alpha>) (elts \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "using bij_betw_finite finite_Ord_omega infinite_\\<omega>"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B \\<Longrightarrow> finite ?A = finite ?B\n  ?\\<alpha> \\<in> elts \\<omega> \\<Longrightarrow> finite (elts ?\\<alpha>)\n  infinite (elts \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> f.\n       \\<lbrakk>\\<alpha> \\<in> elts \\<omega>;\n        bij_betw f (elts \\<alpha>) (elts \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<alpha> \\<in> elts \\<omega>;\n   bij_betw ?f (elts ?\\<alpha>) (elts \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Card \\<omega>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<alpha> \\<in> elts \\<omega>;\n   bij_betw ?f (elts ?\\<alpha>) (elts \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<alpha> \\<in> elts \\<omega>;\n   bij_betw ?f (elts ?\\<alpha>) (elts \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. Card \\<omega>", "by (meson CardI Ord_\\<omega> Ord_mem_iff_lt eqpoll_def)"], ["proof (state)\nthis:\n  Card \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_Card_imp_lesspoll: \"\\<lbrakk>i < a; Card a; Ord i\\<rbrakk> \\<Longrightarrow> elts i \\<prec> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < a; Card a; Ord i\\<rbrakk>\n    \\<Longrightarrow> elts i \\<prec> elts a", "by (meson Card_iff_initial less_eq_V_def less_imp_le lesspoll_def subset_imp_lepoll)"], ["", "lemma lepoll_imp_Card_le:\n  assumes \"elts a \\<lesssim> elts b\" shows \"vcard a \\<le> vcard b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard a \\<le> vcard b", "using Ord_cardinal [of a] Ord_cardinal [of b]"], ["proof (prove)\nusing this:\n  Ord (vcard a)\n  Ord (vcard b)\n\ngoal (1 subgoal):\n 1. vcard a \\<le> vcard b", "proof (cases rule: Ord_linear_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. vcard a \\<le> vcard b \\<Longrightarrow> vcard a \\<le> vcard b\n 2. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "case le"], ["proof (state)\nthis:\n  vcard a \\<le> vcard b\n\ngoal (2 subgoals):\n 1. vcard a \\<le> vcard b \\<Longrightarrow> vcard a \\<le> vcard b\n 2. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "thus ?thesis"], ["proof (prove)\nusing this:\n  vcard a \\<le> vcard b\n\ngoal (1 subgoal):\n 1. vcard a \\<le> vcard b", "."], ["proof (state)\nthis:\n  vcard a \\<le> vcard b\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "case ge"], ["proof (state)\nthis:\n  vcard b \\<le> vcard a\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "have \"elts b \\<approx> elts (vcard b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts b \\<approx> elts (vcard b)", "by (simp add: cardinal_eqpoll eqpoll_sym)"], ["proof (state)\nthis:\n  elts b \\<approx> elts (vcard b)\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "also"], ["proof (state)\nthis:\n  elts b \\<approx> elts (vcard b)\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "have \"\\<dots> \\<lesssim> elts (vcard a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard b) \\<lesssim> elts (vcard a)", "by (meson ge less_eq_V_def subset_imp_lepoll)"], ["proof (state)\nthis:\n  elts (vcard b) \\<lesssim> elts (vcard a)\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "also"], ["proof (state)\nthis:\n  elts (vcard b) \\<lesssim> elts (vcard a)\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "have \"\\<dots> \\<approx> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard a) \\<approx> elts a", "by (simp add: cardinal_eqpoll)"], ["proof (state)\nthis:\n  elts (vcard a) \\<approx> elts a\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "finally"], ["proof (chain)\npicking this:\n  elts b \\<lesssim> elts a", "have \"elts b \\<lesssim> elts a\""], ["proof (prove)\nusing this:\n  elts b \\<lesssim> elts a\n\ngoal (1 subgoal):\n 1. elts b \\<lesssim> elts a", "."], ["proof (state)\nthis:\n  elts b \\<lesssim> elts a\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "hence \"elts a \\<approx> elts b\""], ["proof (prove)\nusing this:\n  elts b \\<lesssim> elts a\n\ngoal (1 subgoal):\n 1. elts a \\<approx> elts b", "using assms lepoll_antisym"], ["proof (prove)\nusing this:\n  elts b \\<lesssim> elts a\n  elts a \\<lesssim> elts b\n  \\<lbrakk>?A \\<lesssim> ?B; ?B \\<lesssim> ?A\\<rbrakk>\n  \\<Longrightarrow> ?A \\<approx> ?B\n\ngoal (1 subgoal):\n 1. elts a \\<approx> elts b", "by blast"], ["proof (state)\nthis:\n  elts a \\<approx> elts b\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "hence \"vcard a = vcard b\""], ["proof (prove)\nusing this:\n  elts a \\<approx> elts b\n\ngoal (1 subgoal):\n 1. vcard a = vcard b", "by (rule cardinal_cong)"], ["proof (state)\nthis:\n  vcard a = vcard b\n\ngoal (1 subgoal):\n 1. vcard b \\<le> vcard a \\<Longrightarrow> vcard a \\<le> vcard b", "thus ?thesis"], ["proof (prove)\nusing this:\n  vcard a = vcard b\n\ngoal (1 subgoal):\n 1. vcard a \\<le> vcard b", "by simp"], ["proof (state)\nthis:\n  vcard a \\<le> vcard b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lepoll_cardinal_le: \"\\<lbrakk>elts A \\<lesssim> elts i; Ord i\\<rbrakk> \\<Longrightarrow> vcard A \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>elts A \\<lesssim> elts i; Ord i\\<rbrakk>\n    \\<Longrightarrow> vcard A \\<le> i", "by (metis Ord_Least Ord_linear2 dual_order.trans eqpoll_refl lepoll_imp_Card_le not_less_Ord_Least vcard_def)"], ["", "lemma cardinal_le_lepoll: \"vcard A \\<le> \\<alpha> \\<Longrightarrow> elts A \\<lesssim> elts \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<alpha> \\<Longrightarrow> elts A \\<lesssim> elts \\<alpha>", "by (meson cardinal_eqpoll eqpoll_sym lepoll_trans1 less_eq_V_def subset_imp_lepoll)"], ["", "lemma lesspoll_imp_Card_less:\n  assumes \"elts a \\<prec> elts b\" shows \"vcard a < vcard b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard a < vcard b", "by (metis assms cardinal_eqpoll eqpoll_sym eqpoll_trans le_neq_trans lepoll_imp_Card_le lesspoll_def)"], ["", "lemma Card_Union [simp,intro]:\n  assumes A: \"\\<And>x. x \\<in> A \\<Longrightarrow> Card(x)\" shows \"Card(\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card (\\<Squnion> A)", "proof (rule CardI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ord (\\<Squnion> A)\n 2. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "show \"Ord(\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (\\<Squnion> A)", "using A"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> Card ?x\n\ngoal (1 subgoal):\n 1. Ord (\\<Squnion> A)", "by (simp add: Card_is_Ord Ord_Sup)"], ["proof (state)\nthis:\n  Ord (\\<Squnion> A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "assume j: \"j < \\<Squnion>A\" \"Ord j\""], ["proof (state)\nthis:\n  j < \\<Squnion> A\n  Ord j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "hence \"\\<exists>c\\<in>A. j < c \\<and> Card(c)\""], ["proof (prove)\nusing this:\n  j < \\<Squnion> A\n  Ord j\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>A. j < c \\<and> Card c", "using A"], ["proof (prove)\nusing this:\n  j < \\<Squnion> A\n  Ord j\n  ?x \\<in> A \\<Longrightarrow> Card ?x\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>A. j < c \\<and> Card c", "by (meson Card_is_Ord Ord_linear2 ZFC_in_HOL.Sup_least leD)"], ["proof (state)\nthis:\n  \\<exists>c\\<in>A. j < c \\<and> Card c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>A. j < c \\<and> Card c", "obtain c where c: \"c\\<in>A\" \"j < c\" \"Card(c)\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>A. j < c \\<and> Card c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> A; j < c; Card c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<in> A\n  j < c\n  Card c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "hence jls: \"elts j \\<prec> elts c\""], ["proof (prove)\nusing this:\n  c \\<in> A\n  j < c\n  Card c\n\ngoal (1 subgoal):\n 1. elts j \\<prec> elts c", "using j(2) lt_Card_imp_lesspoll"], ["proof (prove)\nusing this:\n  c \\<in> A\n  j < c\n  Card c\n  Ord j\n  \\<lbrakk>?i < ?a; Card ?a; Ord ?i\\<rbrakk>\n  \\<Longrightarrow> elts ?i \\<prec> elts ?a\n\ngoal (1 subgoal):\n 1. elts j \\<prec> elts c", "by blast"], ["proof (state)\nthis:\n  elts j \\<prec> elts c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "{"], ["proof (state)\nthis:\n  elts j \\<prec> elts c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "assume eqp: \"elts j \\<approx> elts (\\<Squnion>A)\""], ["proof (state)\nthis:\n  elts j \\<approx> elts (\\<Squnion> A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "have  \"elts c \\<lesssim> elts (\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts c \\<lesssim> elts (\\<Squnion> A)", "using c"], ["proof (prove)\nusing this:\n  c \\<in> A\n  j < c\n  Card c\n\ngoal (1 subgoal):\n 1. elts c \\<lesssim> elts (\\<Squnion> A)", "using Sup_V_def ZFC_in_HOL.Sup_upper j(1) less_eq_V_def subset_imp_lepoll"], ["proof (prove)\nusing this:\n  c \\<in> A\n  j < c\n  Card c\n  \\<Squnion> ?X \\<equiv> if small ?X then set (\\<Union> (elts ` ?X)) else 0\n  \\<lbrakk>?x \\<in> ?A; small ?A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n  j < \\<Squnion> A\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?A \\<lesssim> ?B\n\ngoal (1 subgoal):\n 1. elts c \\<lesssim> elts (\\<Squnion> A)", "by fastforce"], ["proof (state)\nthis:\n  elts c \\<lesssim> elts (\\<Squnion> A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "also"], ["proof (state)\nthis:\n  elts c \\<lesssim> elts (\\<Squnion> A)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "have \"... \\<approx> elts j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (\\<Squnion> A) \\<approx> elts j", "by (rule eqpoll_sym [OF eqp])"], ["proof (state)\nthis:\n  elts (\\<Squnion> A) \\<approx> elts j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "also"], ["proof (state)\nthis:\n  elts (\\<Squnion> A) \\<approx> elts j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "have \"... \\<prec> elts c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts j \\<prec> elts c", "by (rule jls)"], ["proof (state)\nthis:\n  elts j \\<prec> elts c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "finally"], ["proof (chain)\npicking this:\n  elts c \\<prec> elts c", "have \"elts c \\<prec> elts c\""], ["proof (prove)\nusing this:\n  elts c \\<prec> elts c\n\ngoal (1 subgoal):\n 1. elts c \\<prec> elts c", "."], ["proof (state)\nthis:\n  elts c \\<prec> elts c\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "hence False"], ["proof (prove)\nusing this:\n  elts c \\<prec> elts c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "}"], ["proof (state)\nthis:\n  elts j \\<approx> elts (\\<Squnion> A) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < \\<Squnion> A; Ord j\\<rbrakk>\n       \\<Longrightarrow> \\<not> elts j \\<approx> elts (\\<Squnion> A)", "thus \"\\<not> elts j \\<approx> elts (\\<Squnion>A)\""], ["proof (prove)\nusing this:\n  elts j \\<approx> elts (\\<Squnion> A) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> elts j \\<approx> elts (\\<Squnion> A)", "by blast"], ["proof (state)\nthis:\n  \\<not> elts j \\<approx> elts (\\<Squnion> A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Card_UN: \"(\\<And>x. x \\<in> A \\<Longrightarrow> Card(K x)) ==> Card(Sup (K ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> Card (K x)) \\<Longrightarrow>\n    Card (\\<Squnion> (K ` A))", "by blast"], ["", "subsection\\<open>Transfinite recursion for definitions based on the three cases of ordinals\\<close>"], ["", "definition\n  transrec3 :: \"[V, [V,V]\\<Rightarrow>V, [V,V\\<Rightarrow>V]\\<Rightarrow>V, V] \\<Rightarrow> V\" where\n    \"transrec3 a b c \\<equiv>\n       transrec (\\<lambda>r x.\n         if x=0 then a\n         else if Limit x then c x (\\<lambda>y \\<in> elts x. r y)\n         else b(pred x) (r (pred x)))\""], ["", "lemma transrec3_0 [simp]: \"transrec3 a b c 0 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec3 a b c 0 = a", "by (simp add: transrec transrec3_def)"], ["", "lemma transrec3_succ [simp]:\n     \"transrec3 a b c (succ i) = b i (transrec3 a b c i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transrec3 a b c (ZFC_in_HOL.succ i) = b i (transrec3 a b c i)", "by (simp add: transrec transrec3_def)"], ["", "lemma transrec3_Limit [simp]:\n     \"Limit i \\<Longrightarrow>  transrec3 a b c i = c i (\\<lambda>j \\<in> elts i. transrec3 a b c j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i \\<Longrightarrow>\n    transrec3 a b c i = c i (restrict (transrec3 a b c) (elts i))", "unfolding transrec3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit i \\<Longrightarrow>\n    transrec\n     (\\<lambda>r x.\n         if x = 0 then a\n         else if Limit x then c x (restrict r (elts x))\n              else b (ZFC_in_HOL.pred x) (r (ZFC_in_HOL.pred x)))\n     i =\n    c i (restrict\n          (transrec\n            (\\<lambda>r x.\n                if x = 0 then a\n                else if Limit x then c x (restrict r (elts x))\n                     else b (ZFC_in_HOL.pred x) (r (ZFC_in_HOL.pred x))))\n          (elts i))", "by (subst transrec) auto"], ["", "subsection \\<open>Cardinal Addition\\<close>"], ["", "definition cadd :: \"[V,V]\\<Rightarrow>V\"       (infixl \\<open>\\<oplus>\\<close> 65)\n  where \"\\<kappa> \\<oplus> \\<mu> \\<equiv> vcard (\\<kappa> \\<Uplus> \\<mu>)\""], ["", "subsubsection\\<open>Cardinal addition is commutative\\<close>"], ["", "lemma vsum_commute_eqpoll: \"elts (a\\<Uplus>b) \\<approx> elts (b\\<Uplus>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)", "have \"bij_betw (\\<lambda>z \\<in> elts (a\\<Uplus>b). sum_case Inr Inl z) (elts (a\\<Uplus>b)) (elts (b\\<Uplus>a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n       (elts (a \\<Uplus> b)))\n     (elts (a \\<Uplus> b)) (elts (b \\<Uplus> a))", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on\n     (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n       (elts (a \\<Uplus> b)))\n     (elts (a \\<Uplus> b)) \\<and>\n    restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)) `\n    elts (a \\<Uplus> b) =\n    elts (b \\<Uplus> a)", "proof (intro conjI inj_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (a \\<Uplus> b); y \\<in> elts (a \\<Uplus> b);\n        restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n         (elts (a \\<Uplus> b)) x =\n        restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n         (elts (a \\<Uplus> b)) y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)) `\n    elts (a \\<Uplus> b) =\n    elts (b \\<Uplus> a)", "show \"restrict (sum_case Inr Inl) (elts (a \\<Uplus> b)) ` elts (a \\<Uplus> b) = elts (b \\<Uplus> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)) `\n    elts (a \\<Uplus> b) =\n    elts (b \\<Uplus> a)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> elts b \\<Longrightarrow>\n       ZFC_Cardinals.Inl xa\n       \\<in> sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl `\n             elts (a \\<Uplus> b)\n 2. \\<And>y.\n       y \\<in> elts a \\<Longrightarrow>\n       ZFC_Cardinals.Inr y\n       \\<in> sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl `\n             elts (a \\<Uplus> b)", "apply (metis (no_types) imageI sum_case_Inr sum_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> elts a \\<Longrightarrow>\n       ZFC_Cardinals.Inr y\n       \\<in> sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl `\n             elts (a \\<Uplus> b)", "by (metis Inl_in_sum_iff imageI sum_case_Inl)"], ["proof (state)\nthis:\n  restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n   (elts (a \\<Uplus> b)) `\n  elts (a \\<Uplus> b) =\n  elts (b \\<Uplus> a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> elts (a \\<Uplus> b); y \\<in> elts (a \\<Uplus> b);\n        restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n         (elts (a \\<Uplus> b)) x =\n        restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n         (elts (a \\<Uplus> b)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "qed auto"], ["proof (state)\nthis:\n  bij_betw\n   (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)))\n   (elts (a \\<Uplus> b)) (elts (b \\<Uplus> a))\n\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)", "then"], ["proof (chain)\npicking this:\n  bij_betw\n   (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)))\n   (elts (a \\<Uplus> b)) (elts (b \\<Uplus> a))", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw\n   (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)))\n   (elts (a \\<Uplus> b)) (elts (b \\<Uplus> a))\n\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)", "using eqpoll_def"], ["proof (prove)\nusing this:\n  bij_betw\n   (restrict (sum_case ZFC_Cardinals.Inr ZFC_Cardinals.Inl)\n     (elts (a \\<Uplus> b)))\n   (elts (a \\<Uplus> b)) (elts (b \\<Uplus> a))\n  ?A \\<approx> ?B \\<equiv> \\<exists>f. bij_betw f ?A ?B\n\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)", "by blast"], ["proof (state)\nthis:\n  elts (a \\<Uplus> b) \\<approx> elts (b \\<Uplus> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cadd_commute: \"i \\<oplus> j = j \\<oplus> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<oplus> j = j \\<oplus> i", "by (simp add: cadd_def cardinal_cong vsum_commute_eqpoll)"], ["", "subsubsection\\<open>Cardinal addition is associative\\<close>"], ["", "lemma sum_assoc_bij:\n  \"bij_betw (\\<lambda>z \\<in> elts ((a\\<Uplus>b)\\<Uplus>c). sum_case(sum_case Inl (\\<lambda>y. Inr(Inl y))) (\\<lambda>y. Inr(Inr y)) z)\n      (elts ((a\\<Uplus>b)\\<Uplus>c)) (elts (a\\<Uplus>(b\\<Uplus>c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (restrict\n       (sum_case\n         (sum_case ZFC_Cardinals.Inl\n           (\\<lambda>y. ZFC_Cardinals.Inr (ZFC_Cardinals.Inl y)))\n         (\\<lambda>y. ZFC_Cardinals.Inr (ZFC_Cardinals.Inr y)))\n       (elts (a \\<Uplus> b \\<Uplus> c)))\n     (elts (a \\<Uplus> b \\<Uplus> c)) (elts (a \\<Uplus> (b \\<Uplus> c)))", "by (rule_tac f' = \"sum_case (\\<lambda>x. Inl (Inl x)) (sum_case (\\<lambda>x. Inl (Inr x)) Inr)\"\n      in bij_betw_byWitness) auto"], ["", "lemma sum_assoc_eqpoll: \"elts ((a\\<Uplus>b)\\<Uplus>c) \\<approx> elts (a\\<Uplus>(b\\<Uplus>c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (a \\<Uplus> b \\<Uplus> c) \\<approx>\n    elts (a \\<Uplus> (b \\<Uplus> c))", "unfolding eqpoll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (elts (a \\<Uplus> b \\<Uplus> c))\n        (elts (a \\<Uplus> (b \\<Uplus> c)))", "by (metis sum_assoc_bij)"], ["", "lemma elts_vcard_vsum_eqpoll: \"elts (vcard (i \\<Uplus> j)) \\<approx> Inl ` elts i \\<union> Inr ` elts j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "have \"elts (i \\<Uplus> j) \\<approx> Inl ` elts i \\<union> Inr ` elts j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (i \\<Uplus> j) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "by (simp add: elts_vsum)"], ["proof (state)\nthis:\n  elts (i \\<Uplus> j) \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "then"], ["proof (chain)\npicking this:\n  elts (i \\<Uplus> j) \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (i \\<Uplus> j) \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "using cardinal_eqpoll eqpoll_trans"], ["proof (prove)\nusing this:\n  elts (i \\<Uplus> j) \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j\n  elts (vcard ?a) \\<approx> elts ?a\n  \\<lbrakk>?A \\<approx> ?B; ?B \\<approx> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<approx> ?C\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j", "by blast"], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j)) \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cadd_assoc: \"(i \\<oplus> j) \\<oplus> k = i \\<oplus> (j \\<oplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<oplus> j \\<oplus> k = i \\<oplus> (j \\<oplus> k)", "proof (unfold cadd_def, rule cardinal_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "have \"elts (vcard(i \\<Uplus> j) \\<Uplus> k) \\<approx> elts ((i \\<Uplus> j) \\<Uplus> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> j \\<Uplus> k)", "by (auto simp: disjnt_def elts_vsum elts_vcard_vsum_eqpoll intro: Un_eqpoll_cong)"], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n  elts (i \\<Uplus> j \\<Uplus> k)\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "also"], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n  elts (i \\<Uplus> j \\<Uplus> k)\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "have \"\\<dots>  \\<approx> elts (i \\<Uplus> (j \\<Uplus> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (i \\<Uplus> j \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> (j \\<Uplus> k))", "by (rule sum_assoc_eqpoll)"], ["proof (state)\nthis:\n  elts (i \\<Uplus> j \\<Uplus> k) \\<approx> elts (i \\<Uplus> (j \\<Uplus> k))\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "also"], ["proof (state)\nthis:\n  elts (i \\<Uplus> j \\<Uplus> k) \\<approx> elts (i \\<Uplus> (j \\<Uplus> k))\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "have \"\\<dots>  \\<approx> elts (i \\<Uplus> vcard(j \\<Uplus> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (i \\<Uplus> (j \\<Uplus> k)) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "by (auto simp: disjnt_def elts_vsum elts_vcard_vsum_eqpoll [THEN eqpoll_sym] intro: Un_eqpoll_cong)"], ["proof (state)\nthis:\n  elts (i \\<Uplus> (j \\<Uplus> k)) \\<approx>\n  elts (i \\<Uplus> vcard (j \\<Uplus> k))\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "finally"], ["proof (chain)\npicking this:\n  elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n  elts (i \\<Uplus> vcard (j \\<Uplus> k))", "show \"elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx> elts (i \\<Uplus> vcard (j \\<Uplus> k))\""], ["proof (prove)\nusing this:\n  elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n  elts (i \\<Uplus> vcard (j \\<Uplus> k))\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n    elts (i \\<Uplus> vcard (j \\<Uplus> k))", "."], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j) \\<Uplus> k) \\<approx>\n  elts (i \\<Uplus> vcard (j \\<Uplus> k))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>0 is the identity for addition\\<close>"], ["", "lemma vsum_0_eqpoll: \"elts (0\\<Uplus>a) \\<approx> elts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (0 \\<Uplus> a) \\<approx> elts a", "by (simp add: elts_vsum)"], ["", "lemma cadd_0 [simp]: \"Card \\<kappa> \\<Longrightarrow> 0 \\<oplus> \\<kappa> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<kappa> \\<Longrightarrow> 0 \\<oplus> \\<kappa> = \\<kappa>", "by (metis Card_def cadd_def cardinal_cong vsum_0_eqpoll)"], ["", "lemma cadd_0_right [simp]: \"Card \\<kappa> \\<Longrightarrow> \\<kappa> \\<oplus> 0 = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card \\<kappa> \\<Longrightarrow> \\<kappa> \\<oplus> 0 = \\<kappa>", "by (simp add: cadd_commute)"], ["", "lemma vsum_lepoll_self: \"elts a \\<lesssim> elts (a\\<Uplus>b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts a \\<lesssim> elts (a \\<Uplus> b)", "unfolding elts_vsum"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts a \\<lesssim>\n    ZFC_Cardinals.Inl ` elts a \\<union> ZFC_Cardinals.Inr ` elts b", "by (meson Inl_iff Un_upper1 inj_onI lepoll_def)"], ["", "lemma cadd_le_self:\n  assumes \\<kappa>: \"Card \\<kappa>\" shows \"\\<kappa> \\<le> \\<kappa> \\<oplus> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<oplus> a", "proof (unfold cadd_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "have \"\\<kappa> \\<le> vcard \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard \\<kappa>", "using Card_def \\<kappa>"], ["proof (prove)\nusing this:\n  Card ?i \\<equiv> ?i = vcard ?i\n  Card \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard \\<kappa>", "by auto"], ["proof (state)\nthis:\n  \\<kappa> \\<le> vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "also"], ["proof (state)\nthis:\n  \\<kappa> \\<le> vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "have \"\\<dots> \\<le> vcard (\\<kappa> \\<Uplus> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "by (simp add: lepoll_imp_Card_le vsum_lepoll_self)"], ["proof (state)\nthis:\n  vcard \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "show \"\\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)\""], ["proof (prove)\nusing this:\n  \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)", "."], ["proof (state)\nthis:\n  \\<kappa> \\<le> vcard (\\<kappa> \\<Uplus> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Monotonicity of addition\\<close>"], ["", "lemma cadd_le_mono: \"\\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa>' \\<oplus> \\<mu>' \\<le> \\<kappa> \\<oplus> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk>\n    \\<Longrightarrow> \\<kappa>' \\<oplus> \\<mu>'\n                      \\<le> \\<kappa> \\<oplus> \\<mu>", "unfolding cadd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk>\n    \\<Longrightarrow> vcard (\\<kappa>' \\<Uplus> \\<mu>')\n                      \\<le> vcard (\\<kappa> \\<Uplus> \\<mu>)", "by (metis (no_types) lepoll_imp_Card_le less_eq_V_def subset_imp_lepoll sum_subset_iff)"], ["", "subsection\\<open>Cardinal multiplication\\<close>"], ["", "definition cmult :: \"[V,V]\\<Rightarrow>V\"       (infixl \\<open>\\<otimes>\\<close> 70)\n  where \"\\<kappa> \\<otimes> \\<mu> \\<equiv> vcard (VSigma \\<kappa> (\\<lambda>z. \\<mu>))\""], ["", "subsubsection\\<open>Cardinal multiplication is commutative\\<close>"], ["", "lemma prod_bij: \"\\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n             \\<Longrightarrow> bij_betw (\\<lambda>(x, y). (f x, g y)) (A \\<times> B) (C \\<times> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n    \\<Longrightarrow> bij_betw (\\<lambda>(x, y). (f x, g y)) (A \\<times> B)\n                       (C \\<times> D)", "apply (rule bij_betw_byWitness [where f' = \"\\<lambda>(x,y). (inv_into A f x, inv_into B g y)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>A \\<times> B.\n                         (case case a of (x, y) \\<Rightarrow> (f x, g y) of\n                          (x, y) \\<Rightarrow>\n                            (inv_into A f x, inv_into B g y)) =\n                         a\n 2. \\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a'\\<in>C \\<times> D.\n                         (case case a' of\n                               (x, y) \\<Rightarrow>\n                                 (inv_into A f x, inv_into B g y) of\n                          (x, y) \\<Rightarrow> (f x, g y)) =\n                         a'\n 3. \\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). (f x, g y)) ` (A \\<times> B)\n                      \\<subseteq> C \\<times> D\n 4. \\<lbrakk>bij_betw f A C; bij_betw g B D\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(x, y). (inv_into A f x, inv_into B g y)) `\n                      (C \\<times> D)\n                      \\<subseteq> A \\<times> B", "apply (auto simp: bij_betw_inv_into_left bij_betw_inv_into_right bij_betwE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>bij_betw f A C; bij_betw g B D; aa \\<in> C;\n        ba \\<in> D\\<rbrakk>\n       \\<Longrightarrow> inv_into A f aa \\<in> A\n 2. \\<And>aa ba.\n       \\<lbrakk>bij_betw f A C; bij_betw g B D; aa \\<in> C;\n        ba \\<in> D\\<rbrakk>\n       \\<Longrightarrow> inv_into B g ba \\<in> B", "using bij_betwE bij_betw_inv_into"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B \\<Longrightarrow> \\<forall>a\\<in>?A. ?f a \\<in> ?B\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>bij_betw f A C; bij_betw g B D; aa \\<in> C;\n        ba \\<in> D\\<rbrakk>\n       \\<Longrightarrow> inv_into A f aa \\<in> A\n 2. \\<And>aa ba.\n       \\<lbrakk>bij_betw f A C; bij_betw g B D; aa \\<in> C;\n        ba \\<in> D\\<rbrakk>\n       \\<Longrightarrow> inv_into B g ba \\<in> B", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cmult_commute: \"i \\<otimes> j = j \\<otimes> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<otimes> j = j \\<otimes> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<otimes> j = j \\<otimes> i", "have \"(\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts i \\<times> elts j) \\<approx> (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n    (elts i \\<times> elts j) \\<approx>\n    (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)", "by (simp add: inj_on_vpair times_commute_eqpoll)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n  (elts i \\<times> elts j) \\<approx>\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)\n\ngoal (1 subgoal):\n 1. i \\<otimes> j = j \\<otimes> i", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n  (elts i \\<times> elts j) \\<approx>\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n  (elts i \\<times> elts j) \\<approx>\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)\n\ngoal (1 subgoal):\n 1. i \\<otimes> j = j \\<otimes> i", "unfolding cmult_def"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n  (elts i \\<times> elts j) \\<approx>\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)\n\ngoal (1 subgoal):\n 1. vcard (vtimes i j) = vcard (vtimes j i)", "using cardinal_cong elts_VSigma"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) `\n  (elts i \\<times> elts j) \\<approx>\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (elts j \\<times> elts i)\n  elts ?x \\<approx> elts ?y \\<Longrightarrow> vcard ?x = vcard ?y\n  elts (VSigma ?a ?b) =\n  (\\<lambda>(x, y). \\<langle>x, y\\<rangle>) ` (SIGMA x:elts ?a. elts (?b x))\n\ngoal (1 subgoal):\n 1. vcard (vtimes i j) = vcard (vtimes j i)", "by auto"], ["proof (state)\nthis:\n  i \\<otimes> j = j \\<otimes> i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Cardinal multiplication is associative\\<close>"], ["", "lemma elts_vcard_VSigma_eqpoll: \"elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j", "have \"elts (vtimes i j) \\<approx> elts i \\<times> elts j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vtimes i j) \\<approx> elts i \\<times> elts j", "by (simp add: elts_VSigma)"], ["proof (state)\nthis:\n  elts (vtimes i j) \\<approx> elts i \\<times> elts j\n\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j", "then"], ["proof (chain)\npicking this:\n  elts (vtimes i j) \\<approx> elts i \\<times> elts j", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (vtimes i j) \\<approx> elts i \\<times> elts j\n\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j", "using cardinal_eqpoll eqpoll_trans"], ["proof (prove)\nusing this:\n  elts (vtimes i j) \\<approx> elts i \\<times> elts j\n  elts (vcard ?a) \\<approx> elts ?a\n  \\<lbrakk>?A \\<approx> ?B; ?B \\<approx> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<approx> ?C\n\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j", "by blast"], ["proof (state)\nthis:\n  elts (vcard (vtimes i j)) \\<approx> elts i \\<times> elts j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cmult_assoc: \"(i \\<otimes> j) \\<otimes> k = i \\<otimes> (j \\<otimes> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<otimes> j \\<otimes> k = i \\<otimes> (j \\<otimes> k)", "unfolding cmult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (vtimes (vcard (vtimes i j)) k) =\n    vcard (vtimes i (vcard (vtimes j k)))", "proof (rule cardinal_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "have \"elts (vcard (vtimes i j)) \\<times> elts k \\<approx> (elts i \\<times> elts j) \\<times> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i j)) \\<times> elts k \\<approx>\n    (elts i \\<times> elts j) \\<times> elts k", "by (blast intro: times_eqpoll_cong elts_vcard_VSigma_eqpoll cardinal_eqpoll)"], ["proof (state)\nthis:\n  elts (vcard (vtimes i j)) \\<times> elts k \\<approx>\n  (elts i \\<times> elts j) \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "also"], ["proof (state)\nthis:\n  elts (vcard (vtimes i j)) \\<times> elts k \\<approx>\n  (elts i \\<times> elts j) \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "have \"\\<dots>  \\<approx> elts i \\<times> (elts j \\<times> elts k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (elts i \\<times> elts j) \\<times> elts k \\<approx>\n    elts i \\<times> elts j \\<times> elts k", "by (rule times_assoc_eqpoll)"], ["proof (state)\nthis:\n  (elts i \\<times> elts j) \\<times> elts k \\<approx>\n  elts i \\<times> elts j \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "also"], ["proof (state)\nthis:\n  (elts i \\<times> elts j) \\<times> elts k \\<approx>\n  elts i \\<times> elts j \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "have \"\\<dots>  \\<approx> elts i \\<times> elts (vcard (vtimes j k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts i \\<times> elts j \\<times> elts k \\<approx>\n    elts i \\<times> elts (vcard (vtimes j k))", "by (blast intro: times_eqpoll_cong elts_vcard_VSigma_eqpoll cardinal_eqpoll eqpoll_sym)"], ["proof (state)\nthis:\n  elts i \\<times> elts j \\<times> elts k \\<approx>\n  elts i \\<times> elts (vcard (vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "finally"], ["proof (chain)\npicking this:\n  elts (vcard (vtimes i j)) \\<times> elts k \\<approx>\n  elts i \\<times> elts (vcard (vtimes j k))", "show \"elts (VSigma (vcard (vtimes i j)) (\\<lambda>z. k)) \\<approx> elts (VSigma i (\\<lambda>z. vcard (vtimes j k)))\""], ["proof (prove)\nusing this:\n  elts (vcard (vtimes i j)) \\<times> elts k \\<approx>\n  elts i \\<times> elts (vcard (vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n    elts (vtimes i (vcard (vtimes j k)))", "by (simp add: elts_VSigma)"], ["proof (state)\nthis:\n  elts (vtimes (vcard (vtimes i j)) k) \\<approx>\n  elts (vtimes i (vcard (vtimes j k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Cardinal multiplication distributes over addition\\<close>"], ["", "lemma cadd_cmult_distrib: \"(i \\<oplus> j) \\<otimes> k = (i \\<otimes> k) \\<oplus> (j \\<otimes> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<oplus> j) \\<otimes> k = i \\<otimes> k \\<oplus> j \\<otimes> k", "unfolding cadd_def cmult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (vtimes (vcard (i \\<Uplus> j)) k) =\n    vcard (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "proof (rule cardinal_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx> elts (vcard (vsum i j)) \\<times> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (i \\<Uplus> j)) \\<times> elts k", "using cardinal_eqpoll elts_vcard_VSigma_eqpoll eqpoll_sym eqpoll_trans"], ["proof (prove)\nusing this:\n  elts (vcard ?a) \\<approx> elts ?a\n  elts (vcard (vtimes ?i ?j)) \\<approx> elts ?i \\<times> elts ?j\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  \\<lbrakk>?A \\<approx> ?B; ?B \\<approx> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<approx> ?C\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (i \\<Uplus> j)) \\<times> elts k", "by blast"], ["proof (state)\nthis:\n  elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n  elts (vcard (i \\<Uplus> j)) \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "also"], ["proof (state)\nthis:\n  elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n  elts (vcard (i \\<Uplus> j)) \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"\\<dots> \\<approx> (Inl ` elts i \\<union> Inr ` elts j) \\<times> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<times> elts k \\<approx>\n    (ZFC_Cardinals.Inl ` elts i \\<union>\n     ZFC_Cardinals.Inr ` elts j) \\<times>\n    elts k", "using elts_vcard_vsum_eqpoll times_eqpoll_cong"], ["proof (prove)\nusing this:\n  elts (vcard (?i \\<Uplus> ?j)) \\<approx>\n  ZFC_Cardinals.Inl ` elts ?i \\<union> ZFC_Cardinals.Inr ` elts ?j\n  \\<lbrakk>?A \\<approx> ?C; ?B \\<approx> ?D\\<rbrakk>\n  \\<Longrightarrow> ?A \\<times> ?B \\<approx> ?C \\<times> ?D\n\ngoal (1 subgoal):\n 1. elts (vcard (i \\<Uplus> j)) \\<times> elts k \\<approx>\n    (ZFC_Cardinals.Inl ` elts i \\<union>\n     ZFC_Cardinals.Inr ` elts j) \\<times>\n    elts k", "by blast"], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j)) \\<times> elts k \\<approx>\n  (ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j) \\<times>\n  elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "also"], ["proof (state)\nthis:\n  elts (vcard (i \\<Uplus> j)) \\<times> elts k \\<approx>\n  (ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j) \\<times>\n  elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"\\<dots> \\<approx> (Inl ` elts i) \\<times> elts k \\<union> (Inr ` elts j) \\<times> elts k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ZFC_Cardinals.Inl ` elts i \\<union>\n     ZFC_Cardinals.Inr ` elts j) \\<times>\n    elts k \\<approx>\n    ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n    ZFC_Cardinals.Inr ` elts j \\<times> elts k", "by (simp add: Sigma_Un_distrib1)"], ["proof (state)\nthis:\n  (ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j) \\<times>\n  elts k \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n  ZFC_Cardinals.Inr ` elts j \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "also"], ["proof (state)\nthis:\n  (ZFC_Cardinals.Inl ` elts i \\<union> ZFC_Cardinals.Inr ` elts j) \\<times>\n  elts k \\<approx>\n  ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n  ZFC_Cardinals.Inr ` elts j \\<times> elts k\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"\\<dots>  \\<approx> elts (vtimes i k \\<Uplus> vtimes j k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n    ZFC_Cardinals.Inr ` elts j \\<times> elts k \\<approx>\n    elts (vtimes i k \\<Uplus> vtimes j k)", "unfolding Plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n    ZFC_Cardinals.Inr ` elts j \\<times> elts k \\<approx>\n    elts (vtimes i k \\<Uplus> vtimes j k)", "by (auto simp: elts_vsum elts_VSigma disjnt_iff intro!: Un_eqpoll_cong times_eqpoll_cong)"], ["proof (state)\nthis:\n  ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n  ZFC_Cardinals.Inr ` elts j \\<times> elts k \\<approx>\n  elts (vtimes i k \\<Uplus> vtimes j k)\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "also"], ["proof (state)\nthis:\n  ZFC_Cardinals.Inl ` elts i \\<times> elts k \\<union>\n  ZFC_Cardinals.Inr ` elts j \\<times> elts k \\<approx>\n  elts (vtimes i k \\<Uplus> vtimes j k)\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"\\<dots>  \\<approx> elts (vcard (vtimes i k \\<Uplus> vtimes j k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vtimes i k \\<Uplus> vtimes j k) \\<approx>\n    elts (vcard (vtimes i k \\<Uplus> vtimes j k))", "by (simp add: cardinal_eqpoll eqpoll_sym)"], ["proof (state)\nthis:\n  elts (vtimes i k \\<Uplus> vtimes j k) \\<approx>\n  elts (vcard (vtimes i k \\<Uplus> vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "also"], ["proof (state)\nthis:\n  elts (vtimes i k \\<Uplus> vtimes j k) \\<approx>\n  elts (vcard (vtimes i k \\<Uplus> vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "have \"\\<dots>  \\<approx> elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (vtimes i k \\<Uplus> vtimes j k)) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "by (metis cadd_assoc cadd_def cardinal_cong cardinal_eqpoll vsum_0_eqpoll vsum_commute_eqpoll)"], ["proof (state)\nthis:\n  elts (vcard (vtimes i k \\<Uplus> vtimes j k)) \\<approx>\n  elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "finally"], ["proof (chain)\npicking this:\n  elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n  elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "show \"elts (VSigma (vcard (i \\<Uplus> j)) (\\<lambda>z. k))\n             \\<approx> elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))\""], ["proof (prove)\nusing this:\n  elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n  elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))\n\ngoal (1 subgoal):\n 1. elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n    elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))", "."], ["proof (state)\nthis:\n  elts (vtimes (vcard (i \\<Uplus> j)) k) \\<approx>\n  elts (vcard (vtimes i k) \\<Uplus> vcard (vtimes j k))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Multiplication by 0 yields 0\\<close>"], ["", "lemma cmult_0 [simp]: \"0 \\<otimes> i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<otimes> i = 0", "using Card_0 Card_def cmult_def"], ["proof (prove)\nusing this:\n  Card 0\n  Card ?i \\<equiv> ?i = vcard ?i\n  ?\\<kappa> \\<otimes> ?\\<mu> \\<equiv> vcard (vtimes ?\\<kappa> ?\\<mu>)\n\ngoal (1 subgoal):\n 1. 0 \\<otimes> i = 0", "by auto"], ["", "text\\<open>1 is the identity for multiplication\\<close>"], ["", "lemma cmult_1 [simp]: assumes \"Card \\<kappa>\" shows \"1 \\<otimes> \\<kappa> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<otimes> \\<kappa> = \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<otimes> \\<kappa> = \\<kappa>", "have \"elts (vtimes (set {0}) \\<kappa>) \\<approx> elts \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vtimes (set {0}) \\<kappa>) \\<approx> elts \\<kappa>", "by (auto simp: elts_VSigma intro!: times_singleton_eqpoll)"], ["proof (state)\nthis:\n  elts (vtimes (set {0}) \\<kappa>) \\<approx> elts \\<kappa>\n\ngoal (1 subgoal):\n 1. 1 \\<otimes> \\<kappa> = \\<kappa>", "then"], ["proof (chain)\npicking this:\n  elts (vtimes (set {0}) \\<kappa>) \\<approx> elts \\<kappa>", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (vtimes (set {0}) \\<kappa>) \\<approx> elts \\<kappa>\n\ngoal (1 subgoal):\n 1. 1 \\<otimes> \\<kappa> = \\<kappa>", "by (metis Card_def assms cardinal_cong cmult_def elts_1 set_of_elts)"], ["proof (state)\nthis:\n  1 \\<otimes> \\<kappa> = \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Some inequalities for multiplication\\<close>"], ["", "lemma cmult_square_le: assumes \"Card \\<kappa>\" shows \"\\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>", "have \"elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)", "using times_square_lepoll [of \"elts \\<kappa>\"] cmult_def elts_vcard_VSigma_eqpoll eqpoll_sym lepoll_trans2"], ["proof (prove)\nusing this:\n  elts \\<kappa> \\<lesssim> elts \\<kappa> \\<times> elts \\<kappa>\n  ?\\<kappa> \\<otimes> ?\\<mu> \\<equiv> vcard (vtimes ?\\<kappa> ?\\<mu>)\n  elts (vcard (vtimes ?i ?j)) \\<approx> elts ?i \\<times> elts ?j\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  \\<lbrakk>?A \\<lesssim> ?B; ?B \\<approx> ?C\\<rbrakk>\n  \\<Longrightarrow> ?A \\<lesssim> ?C\n\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)", "by fastforce"], ["proof (state)\nthis:\n  elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>", "then"], ["proof (chain)\npicking this:\n  elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)", "show ?thesis"], ["proof (prove)\nusing this:\n  elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>", "using Card_def assms cmult_def lepoll_cardinal_le"], ["proof (prove)\nusing this:\n  elts \\<kappa> \\<lesssim> elts (\\<kappa> \\<otimes> \\<kappa>)\n  Card ?i \\<equiv> ?i = vcard ?i\n  Card \\<kappa>\n  ?\\<kappa> \\<otimes> ?\\<mu> \\<equiv> vcard (vtimes ?\\<kappa> ?\\<mu>)\n  \\<lbrakk>elts ?A \\<lesssim> elts ?i; Ord ?i\\<rbrakk>\n  \\<Longrightarrow> vcard ?A \\<le> ?i\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>", "by fastforce"], ["proof (state)\nthis:\n  \\<kappa> \\<le> \\<kappa> \\<otimes> \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Multiplication by a non-empty set\\<close>"], ["", "lemma cmult_le_self: assumes \"Card \\<kappa>\" \"\\<alpha> \\<noteq> 0\" shows \"\\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "have \"\\<kappa> = vcard \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> = vcard \\<kappa>", "using Card_def \\<open>Card \\<kappa>\\<close>"], ["proof (prove)\nusing this:\n  Card ?i \\<equiv> ?i = vcard ?i\n  Card \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> = vcard \\<kappa>", "by blast"], ["proof (state)\nthis:\n  \\<kappa> = vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "also"], ["proof (state)\nthis:\n  \\<kappa> = vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "have \"\\<dots> \\<le> vcard (vtimes \\<kappa> \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard \\<kappa> \\<le> vcard (vtimes \\<kappa> \\<alpha>)", "apply (rule lepoll_imp_Card_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<lesssim> elts (vtimes \\<kappa> \\<alpha>)", "apply (simp add: elts_VSigma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<lesssim> elts \\<kappa> \\<times> elts \\<alpha>", "by (metis ZFC_in_HOL.ext \\<open>\\<alpha> \\<noteq> 0\\<close> elts_0 lepoll_times1)"], ["proof (state)\nthis:\n  vcard \\<kappa> \\<le> vcard (vtimes \\<kappa> \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "also"], ["proof (state)\nthis:\n  vcard \\<kappa> \\<le> vcard (vtimes \\<kappa> \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "have \"\\<dots> = \\<kappa> \\<otimes> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (vtimes \\<kappa> \\<alpha>) = \\<kappa> \\<otimes> \\<alpha>", "by (simp add: cmult_def)"], ["proof (state)\nthis:\n  vcard (vtimes \\<kappa> \\<alpha>) = \\<kappa> \\<otimes> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>", "."], ["proof (state)\nthis:\n  \\<kappa> \\<le> \\<kappa> \\<otimes> \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Monotonicity of multiplication\\<close>"], ["", "lemma cmult_le_mono: \"\\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa>' \\<otimes> \\<mu>' \\<le> \\<kappa> \\<otimes> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk>\n    \\<Longrightarrow> \\<kappa>' \\<otimes> \\<mu>'\n                      \\<le> \\<kappa> \\<otimes> \\<mu>", "unfolding cmult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<kappa>' \\<le> \\<kappa>; \\<mu>' \\<le> \\<mu>\\<rbrakk>\n    \\<Longrightarrow> vcard (vtimes \\<kappa>' \\<mu>')\n                      \\<le> vcard (vtimes \\<kappa> \\<mu>)", "by (auto simp: elts_VSigma intro!: lepoll_imp_Card_le times_lepoll_mono subset_imp_lepoll)"], ["", "subsection\\<open>The finite cardinals\\<close>"], ["", "lemma succ_lepoll_succD: \"elts (succ(m)) \\<lesssim> elts (succ(n)) \\<Longrightarrow> elts m \\<lesssim> elts n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ZFC_in_HOL.succ m) \\<lesssim>\n    elts (ZFC_in_HOL.succ n) \\<Longrightarrow>\n    elts m \\<lesssim> elts n", "by (simp add: insert_lepoll_insertD)"], ["", "text\\<open>Congruence law for @{text succ} under equipollence\\<close>"], ["", "lemma succ_eqpoll_cong: \"elts a \\<approx> elts b \\<Longrightarrow> elts (succ(a)) \\<approx> elts (succ(b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts a \\<approx> elts b \\<Longrightarrow>\n    elts (ZFC_in_HOL.succ a) \\<approx> elts (ZFC_in_HOL.succ b)", "by (simp add: succ_def insert_eqpoll_cong)"], ["", "lemma sum_succ_eqpoll: \"elts (succ a \\<Uplus> b) \\<approx> elts (succ(a\\<Uplus>b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (ZFC_in_HOL.succ a \\<Uplus> b) \\<approx>\n    elts (ZFC_in_HOL.succ (a \\<Uplus> b))", "unfolding eqpoll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       bij_betw f (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n        (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))", "proof (rule exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n     (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))", "let ?f = \"\\<lambda>z. if z=Inl a then a\\<Uplus>b else z\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n     (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))", "let ?g = \"\\<lambda>z. if z=a\\<Uplus>b then Inl a else z\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n     (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))", "show \"bij_betw ?f (elts (succ a \\<Uplus> b)) (elts (succ (a \\<Uplus> b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>z. if z = ZFC_Cardinals.Inl a then a \\<Uplus> b else z)\n     (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n     (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))", "apply (rule bij_betw_byWitness [where f' = ?g], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a \\<Uplus> b = ZFC_Cardinals.Inl x; x \\<in> elts a\\<rbrakk>\n       \\<Longrightarrow> x = a\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> elts b; a \\<Uplus> b = ZFC_Cardinals.Inr y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Inl_in_sum_iff mem_not_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> elts b; a \\<Uplus> b = ZFC_Cardinals.Inr y\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Inr_in_sum_iff mem_not_refl)"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>z. if z = ZFC_Cardinals.Inl a then a \\<Uplus> b else z)\n   (elts (ZFC_in_HOL.succ a \\<Uplus> b))\n   (elts (ZFC_in_HOL.succ (a \\<Uplus> b)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cadd_succ: \"succ m \\<oplus> n = vcard (succ(m \\<oplus> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ m \\<oplus> n = vcard (ZFC_in_HOL.succ (m \\<oplus> n))", "proof (unfold cadd_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "have [intro]: \"elts (m \\<Uplus> n) \\<approx> elts (vcard (m \\<Uplus> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (m \\<Uplus> n) \\<approx> elts (vcard (m \\<Uplus> n))", "using cardinal_eqpoll eqpoll_sym"], ["proof (prove)\nusing this:\n  elts (vcard ?a) \\<approx> elts ?a\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n\ngoal (1 subgoal):\n 1. elts (m \\<Uplus> n) \\<approx> elts (vcard (m \\<Uplus> n))", "by blast"], ["proof (state)\nthis:\n  elts (m \\<Uplus> n) \\<approx> elts (vcard (m \\<Uplus> n))\n\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "have \"vcard (succ m \\<Uplus> n) = vcard (succ(m \\<Uplus> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (m \\<Uplus> n))", "by (rule sum_succ_eqpoll [THEN cardinal_cong])"], ["proof (state)\nthis:\n  vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n  vcard (ZFC_in_HOL.succ (m \\<Uplus> n))\n\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "also"], ["proof (state)\nthis:\n  vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n  vcard (ZFC_in_HOL.succ (m \\<Uplus> n))\n\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "have \"\\<dots> = vcard (succ(vcard (m \\<Uplus> n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ (m \\<Uplus> n)) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "by (blast intro: succ_eqpoll_cong cardinal_cong)"], ["proof (state)\nthis:\n  vcard (ZFC_in_HOL.succ (m \\<Uplus> n)) =\n  vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))\n\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "finally"], ["proof (chain)\npicking this:\n  vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n  vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "show \"vcard (succ m \\<Uplus> n) = vcard (succ(vcard (m \\<Uplus> n)))\""], ["proof (prove)\nusing this:\n  vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n  vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))\n\ngoal (1 subgoal):\n 1. vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n    vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))", "."], ["proof (state)\nthis:\n  vcard (ZFC_in_HOL.succ m \\<Uplus> n) =\n  vcard (ZFC_in_HOL.succ (vcard (m \\<Uplus> n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_cadd_eq_add: \"ord_of_nat m \\<oplus> ord_of_nat n = ord_of_nat (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat m \\<oplus> ord_of_nat n = ord_of_nat (m + n)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. ord_of_nat 0 \\<oplus> ord_of_nat n = ord_of_nat (0 + n)\n 2. \\<And>m.\n       ord_of_nat m \\<oplus> ord_of_nat n =\n       ord_of_nat (m + n) \\<Longrightarrow>\n       ord_of_nat (Suc m) \\<oplus> ord_of_nat n = ord_of_nat (Suc m + n)", "case (Suc m)"], ["proof (state)\nthis:\n  ord_of_nat m \\<oplus> ord_of_nat n = ord_of_nat (m + n)\n\ngoal (2 subgoals):\n 1. ord_of_nat 0 \\<oplus> ord_of_nat n = ord_of_nat (0 + n)\n 2. \\<And>m.\n       ord_of_nat m \\<oplus> ord_of_nat n =\n       ord_of_nat (m + n) \\<Longrightarrow>\n       ord_of_nat (Suc m) \\<oplus> ord_of_nat n = ord_of_nat (Suc m + n)", "thus ?case"], ["proof (prove)\nusing this:\n  ord_of_nat m \\<oplus> ord_of_nat n = ord_of_nat (m + n)\n\ngoal (1 subgoal):\n 1. ord_of_nat (Suc m) \\<oplus> ord_of_nat n = ord_of_nat (Suc m + n)", "by (metis Card_def Card_ord_of_nat add_Suc cadd_succ ord_of_nat.simps(2))"], ["proof (state)\nthis:\n  ord_of_nat (Suc m) \\<oplus> ord_of_nat n = ord_of_nat (Suc m + n)\n\ngoal (1 subgoal):\n 1. ord_of_nat 0 \\<oplus> ord_of_nat n = ord_of_nat (0 + n)", "qed auto"], ["", "lemma vcard_disjoint_sup:\n  assumes \"x \\<sqinter> y = 0\" shows \"vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y", "have \"elts (x \\<squnion> y) \\<approx> elts (x \\<Uplus> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (x \\<squnion> y) \\<approx> elts (x \\<Uplus> y)", "unfolding eqpoll_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))", "proof (rule exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))", "let ?f = \"\\<lambda>z. if z \\<in> elts x then Inl z else Inr z\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))", "let ?g = \"sum_case id id\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))", "show \"bij_betw ?f (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>z.\n         if z \\<in> elts x then ZFC_Cardinals.Inl z\n         else ZFC_Cardinals.Inr z)\n     (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))", "by (rule bij_betw_byWitness [where f' = ?g]) (use assms V_disjoint_iff in auto)"], ["proof (state)\nthis:\n  bij_betw\n   (\\<lambda>z.\n       if z \\<in> elts x then ZFC_Cardinals.Inl z else ZFC_Cardinals.Inr z)\n   (elts (x \\<squnion> y)) (elts (x \\<Uplus> y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  elts (x \\<squnion> y) \\<approx> elts (x \\<Uplus> y)\n\ngoal (1 subgoal):\n 1. vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y", "then"], ["proof (chain)\npicking this:\n  elts (x \\<squnion> y) \\<approx> elts (x \\<Uplus> y)", "show ?thesis"], ["proof (prove)\nusing this:\n  elts (x \\<squnion> y) \\<approx> elts (x \\<Uplus> y)\n\ngoal (1 subgoal):\n 1. vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y", "by (metis cadd_commute cadd_def cardinal_cong cardinal_idem vsum_0_eqpoll cadd_assoc)"], ["proof (state)\nthis:\n  vcard (x \\<squnion> y) = vcard x \\<oplus> vcard y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Infinite cardinals\\<close>"], ["", "definition InfCard :: \"V\\<Rightarrow>bool\"\n  where \"InfCard \\<kappa> \\<equiv> Card \\<kappa> \\<and> \\<omega> \\<le> \\<kappa>\""], ["", "lemma InfCard_iff: \"InfCard \\<kappa> \\<longleftrightarrow> Card \\<kappa> \\<and> infinite (elts \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "proof (cases \"\\<omega> \\<le> \\<kappa>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))\n 2. \\<not> \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "case True"], ["proof (state)\nthis:\n  \\<omega> \\<le> \\<kappa>\n\ngoal (2 subgoals):\n 1. \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))\n 2. \\<not> \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "then"], ["proof (chain)\npicking this:\n  \\<omega> \\<le> \\<kappa>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<omega> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "using inj_ord_of_nat lepoll_def less_eq_V_def"], ["proof (prove)\nusing this:\n  \\<omega> \\<le> \\<kappa>\n  inj ord_of_nat\n  ?A \\<lesssim> ?B \\<equiv>\n  \\<exists>f. inj_on f ?A \\<and> f ` ?A \\<subseteq> ?B\n  ?x \\<le> ?y \\<equiv> elts ?x \\<subseteq> elts ?y\n\ngoal (1 subgoal):\n 1. InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "by (auto simp: InfCard_def \\<omega>_def infinite_le_lepoll)"], ["proof (state)\nthis:\n  InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "case False"], ["proof (state)\nthis:\n  \\<not> \\<omega> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> \\<kappa> \\<Longrightarrow>\n    InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<omega> \\<le> \\<kappa>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<omega> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "using Card_iff_initial InfCard_def infinite_Ord_omega"], ["proof (prove)\nusing this:\n  \\<not> \\<omega> \\<le> \\<kappa>\n  Card ?\\<kappa> =\n  (Ord ?\\<kappa> \\<and>\n   (\\<forall>\\<alpha>.\n       Ord \\<alpha> \\<and> \\<alpha> < ?\\<kappa> \\<longrightarrow>\n       \\<not> elts \\<alpha> \\<approx> elts ?\\<kappa>))\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  \\<lbrakk>Ord ?\\<alpha>; infinite (elts ?\\<alpha>)\\<rbrakk>\n  \\<Longrightarrow> \\<omega> \\<le> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))", "by blast"], ["proof (state)\nthis:\n  InfCard \\<kappa> = (Card \\<kappa> \\<and> infinite (elts \\<kappa>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InfCard_ge_ord_of_nat:\n  assumes \"InfCard \\<kappa>\" shows \"ord_of_nat n \\<le> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n \\<le> \\<kappa>", "using InfCard_def assms ord_of_nat_le_omega"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n  ord_of_nat ?n \\<le> \\<omega>\n\ngoal (1 subgoal):\n 1. ord_of_nat n \\<le> \\<kappa>", "by blast"], ["", "lemma InfCard_not_0[iff]: \"\\<not> InfCard 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> InfCard 0", "by (simp add: InfCard_iff)"], ["", "definition\n  csucc :: \"V\\<Rightarrow>V\"\n  where \"csucc \\<kappa> \\<equiv> LEAST \\<kappa>'. Ord \\<kappa>' \\<and> (Card \\<kappa>' \\<and> \\<kappa> < \\<kappa>')\""], ["", "lemma less_vcard_VPow: \"vcard A < vcard (VPow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard A < vcard (VPow A)", "proof (rule lesspoll_imp_Card_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts A \\<prec> elts (VPow A)", "show \"elts A \\<prec> elts (VPow A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts A \\<prec> elts (VPow A)", "by (simp add: elts_VPow down inj_on_def lesspoll_Pow_self)"], ["proof (state)\nthis:\n  elts A \\<prec> elts (VPow A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma greater_Card:\n  assumes \"Card \\<kappa>\" shows \"\\<kappa> < vcard (VPow \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "have \"\\<kappa> = vcard \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> = vcard \\<kappa>", "using Card_def assms"], ["proof (prove)\nusing this:\n  Card ?i \\<equiv> ?i = vcard ?i\n  Card \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> = vcard \\<kappa>", "by blast"], ["proof (state)\nthis:\n  \\<kappa> = vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "also"], ["proof (state)\nthis:\n  \\<kappa> = vcard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "have \"\\<dots> < vcard (VPow \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard \\<kappa> < vcard (VPow \\<kappa>)", "proof (rule lesspoll_imp_Card_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<prec> elts (VPow \\<kappa>)", "show \"elts \\<kappa> \\<prec> elts (VPow \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts \\<kappa> \\<prec> elts (VPow \\<kappa>)", "by (simp add: elts_VPow down inj_on_def lesspoll_Pow_self)"], ["proof (state)\nthis:\n  elts \\<kappa> \\<prec> elts (VPow \\<kappa>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vcard \\<kappa> < vcard (VPow \\<kappa>)\n\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> < vcard (VPow \\<kappa>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<kappa> < vcard (VPow \\<kappa>)\n\ngoal (1 subgoal):\n 1. \\<kappa> < vcard (VPow \\<kappa>)", "."], ["proof (state)\nthis:\n  \\<kappa> < vcard (VPow \\<kappa>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"Card \\<kappa>\"\n  shows Card_csucc [simp]: \"Card (csucc \\<kappa>)\" and less_csucc [simp]: \"\\<kappa> < csucc \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card (csucc \\<kappa>) &&& \\<kappa> < csucc \\<kappa>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Card (csucc \\<kappa>)\n 2. \\<kappa> < csucc \\<kappa>", "have \"Card (csucc \\<kappa>) \\<and> \\<kappa> < csucc \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card (csucc \\<kappa>) \\<and> \\<kappa> < csucc \\<kappa>", "unfolding csucc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Card\n     (LEAST \\<kappa>'.\n         Ord \\<kappa>' \\<and>\n         Card \\<kappa>' \\<and> \\<kappa> < \\<kappa>') \\<and>\n    \\<kappa>\n    < (LEAST \\<kappa>'.\n          Ord \\<kappa>' \\<and> Card \\<kappa>' \\<and> \\<kappa> < \\<kappa>')", "proof (rule Ord_LeastI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. Ord ?a\n 2. Card ?a \\<and> \\<kappa> < ?a\n 3. \\<And>x.\n       \\<lbrakk>Ord x; Card x \\<and> \\<kappa> < x\\<rbrakk>\n       \\<Longrightarrow> Card x \\<and> \\<kappa> < x", "show \"Card (vcard (VPow \\<kappa>)) \\<and> \\<kappa> < (vcard (VPow \\<kappa>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card (vcard (VPow \\<kappa>)) \\<and> \\<kappa> < vcard (VPow \\<kappa>)", "using Card_def assms greater_Card"], ["proof (prove)\nusing this:\n  Card ?i \\<equiv> ?i = vcard ?i\n  Card \\<kappa>\n  Card ?\\<kappa> \\<Longrightarrow> ?\\<kappa> < vcard (VPow ?\\<kappa>)\n\ngoal (1 subgoal):\n 1. Card (vcard (VPow \\<kappa>)) \\<and> \\<kappa> < vcard (VPow \\<kappa>)", "by auto"], ["proof (state)\nthis:\n  Card (vcard (VPow \\<kappa>)) \\<and> \\<kappa> < vcard (VPow \\<kappa>)\n\ngoal (2 subgoals):\n 1. Ord (vcard (VPow \\<kappa>))\n 2. \\<And>x.\n       \\<lbrakk>Ord x; Card x \\<and> \\<kappa> < x\\<rbrakk>\n       \\<Longrightarrow> Card x \\<and> \\<kappa> < x", "qed auto"], ["proof (state)\nthis:\n  Card (csucc \\<kappa>) \\<and> \\<kappa> < csucc \\<kappa>\n\ngoal (2 subgoals):\n 1. Card (csucc \\<kappa>)\n 2. \\<kappa> < csucc \\<kappa>", "then"], ["proof (chain)\npicking this:\n  Card (csucc \\<kappa>) \\<and> \\<kappa> < csucc \\<kappa>", "show \"Card (csucc \\<kappa>)\" \"\\<kappa> < csucc \\<kappa>\""], ["proof (prove)\nusing this:\n  Card (csucc \\<kappa>) \\<and> \\<kappa> < csucc \\<kappa>\n\ngoal (1 subgoal):\n 1. Card (csucc \\<kappa>) &&& \\<kappa> < csucc \\<kappa>", "by auto"], ["proof (state)\nthis:\n  Card (csucc \\<kappa>)\n  \\<kappa> < csucc \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_csucc:\n  assumes \"Card \\<kappa>\" shows \"\\<kappa> \\<le> csucc \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> csucc \\<kappa>", "by (simp add: assms less_csucc less_imp_le)"], ["", "lemma csucc_le: \"\\<lbrakk>Card \\<mu>; \\<kappa> \\<in> elts \\<mu>\\<rbrakk> \\<Longrightarrow> csucc \\<kappa> \\<le> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Card \\<mu>; \\<kappa> \\<in> elts \\<mu>\\<rbrakk>\n    \\<Longrightarrow> csucc \\<kappa> \\<le> \\<mu>", "unfolding csucc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Card \\<mu>; \\<kappa> \\<in> elts \\<mu>\\<rbrakk>\n    \\<Longrightarrow> (LEAST \\<kappa>'.\n                          Ord \\<kappa>' \\<and>\n                          Card \\<kappa>' \\<and> \\<kappa> < \\<kappa>')\n                      \\<le> \\<mu>", "by (simp add: Card_is_Ord Ord_Least_le OrdmemD)"], ["", "lemma finite_csucc: \"a \\<in> elts \\<omega> \\<Longrightarrow> csucc a = succ a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> elts \\<omega> \\<Longrightarrow> csucc a = ZFC_in_HOL.succ a", "unfolding csucc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> elts \\<omega> \\<Longrightarrow>\n    (LEAST \\<kappa>'.\n        Ord \\<kappa>' \\<and> Card \\<kappa>' \\<and> a < \\<kappa>') =\n    ZFC_in_HOL.succ a", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> elts \\<omega> \\<Longrightarrow>\n    Ord (ZFC_in_HOL.succ a) \\<and>\n    Card (ZFC_in_HOL.succ a) \\<and> a < ZFC_in_HOL.succ a\n 2. \\<And>y.\n       \\<lbrakk>a \\<in> elts \\<omega>;\n        Ord y \\<and> Card y \\<and> a < y\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ a \\<le> y", "show \"Ord (ZFC_in_HOL.succ a) \\<and> Card (ZFC_in_HOL.succ a) \\<and> a < ZFC_in_HOL.succ a\"\n    if \"a \\<in> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord (ZFC_in_HOL.succ a) \\<and>\n    Card (ZFC_in_HOL.succ a) \\<and> a < ZFC_in_HOL.succ a", "using that"], ["proof (prove)\nusing this:\n  a \\<in> elts \\<omega>\n\ngoal (1 subgoal):\n 1. Ord (ZFC_in_HOL.succ a) \\<and>\n    Card (ZFC_in_HOL.succ a) \\<and> a < ZFC_in_HOL.succ a", "by (auto simp: less_V_def less_eq_V_def nat_into_Card)"], ["proof (state)\nthis:\n  a \\<in> elts \\<omega> \\<Longrightarrow>\n  Ord (ZFC_in_HOL.succ a) \\<and>\n  Card (ZFC_in_HOL.succ a) \\<and> a < ZFC_in_HOL.succ a\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>a \\<in> elts \\<omega>;\n        Ord y \\<and> Card y \\<and> a < y\\<rbrakk>\n       \\<Longrightarrow> ZFC_in_HOL.succ a \\<le> y", "show \"ZFC_in_HOL.succ a \\<le> y\"\n    if \"a \\<in> elts \\<omega>\"\n      and \"Ord y \\<and> Card y \\<and> a < y\"\n    for y :: V"], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ a \\<le> y", "using that"], ["proof (prove)\nusing this:\n  a \\<in> elts \\<omega>\n  Ord y \\<and> Card y \\<and> a < y\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ a \\<le> y", "using Ord_mem_iff_lt dual_order.strict_implies_order"], ["proof (prove)\nusing this:\n  a \\<in> elts \\<omega>\n  Ord y \\<and> Card y \\<and> a < y\n  \\<lbrakk>Ord ?k; Ord ?l\\<rbrakk>\n  \\<Longrightarrow> (?k \\<in> elts ?l) = (?k < ?l)\n  ?b < ?a \\<Longrightarrow> ?b \\<le> ?a\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ a \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> elts \\<omega>;\n   Ord ?y \\<and> Card ?y \\<and> a < ?y\\<rbrakk>\n  \\<Longrightarrow> ZFC_in_HOL.succ a \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Finite_imp_cardinal_cons [simp]:\n  assumes FA: \"finite A\" and a: \"a \\<notin> A\"\n  shows \"vcard (set (insert a A)) = csucc(vcard (set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) = csucc (vcard (set A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) = csucc (vcard (set A))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) = csucc (vcard (set A))", "unfolding csucc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) =\n    (LEAST \\<kappa>'.\n        Ord \\<kappa>' \\<and>\n        Card \\<kappa>' \\<and> vcard (set A) < \\<kappa>')", "proof (rule Least_equality [THEN sym])"], ["proof (state)\ngoal (2 subgoals):\n 1. Ord (vcard (set (insert a A))) \\<and>\n    Card (vcard (set (insert a A))) \\<and>\n    vcard (set A) < vcard (set (insert a A))\n 2. \\<And>y.\n       Ord y \\<and> Card y \\<and> vcard (set A) < y \\<Longrightarrow>\n       vcard (set (insert a A)) \\<le> y", "have \"small A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. small A", "by (simp add: FA Finite_V)"], ["proof (state)\nthis:\n  small A\n\ngoal (2 subgoals):\n 1. Ord (vcard (set (insert a A))) \\<and>\n    Card (vcard (set (insert a A))) \\<and>\n    vcard (set A) < vcard (set (insert a A))\n 2. \\<And>y.\n       Ord y \\<and> Card y \\<and> vcard (set A) < y \\<Longrightarrow>\n       vcard (set (insert a A)) \\<le> y", "then"], ["proof (chain)\npicking this:\n  small A", "have \"\\<not> elts (set A) \\<approx> elts (set (insert a A))\""], ["proof (prove)\nusing this:\n  small A\n\ngoal (1 subgoal):\n 1. \\<not> elts (set A) \\<approx> elts (set (insert a A))", "using FA a eqpoll_imp_lepoll eqpoll_sym finite_insert_lepoll"], ["proof (prove)\nusing this:\n  small A\n  finite A\n  a \\<notin> A\n  ?A \\<approx> ?B \\<Longrightarrow> ?A \\<lesssim> ?B\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  finite ?A \\<Longrightarrow> (insert ?a ?A \\<lesssim> ?A) = (?a \\<in> ?A)\n\ngoal (1 subgoal):\n 1. \\<not> elts (set A) \\<approx> elts (set (insert a A))", "by fastforce"], ["proof (state)\nthis:\n  \\<not> elts (set A) \\<approx> elts (set (insert a A))\n\ngoal (2 subgoals):\n 1. Ord (vcard (set (insert a A))) \\<and>\n    Card (vcard (set (insert a A))) \\<and>\n    vcard (set A) < vcard (set (insert a A))\n 2. \\<And>y.\n       Ord y \\<and> Card y \\<and> vcard (set A) < y \\<Longrightarrow>\n       vcard (set (insert a A)) \\<le> y", "then"], ["proof (chain)\npicking this:\n  \\<not> elts (set A) \\<approx> elts (set (insert a A))", "show \"Ord (vcard (set (insert a A))) \\<and> Card (vcard (set (insert a A))) \\<and> vcard (set A) < vcard (set (insert a A))\""], ["proof (prove)\nusing this:\n  \\<not> elts (set A) \\<approx> elts (set (insert a A))\n\ngoal (1 subgoal):\n 1. Ord (vcard (set (insert a A))) \\<and>\n    Card (vcard (set (insert a A))) \\<and>\n    vcard (set A) < vcard (set (insert a A))", "by (simp add: Card_def lesspoll_imp_Card_less lesspoll_def subset_imp_lepoll subset_insertI)"], ["proof (state)\nthis:\n  Ord (vcard (set (insert a A))) \\<and>\n  Card (vcard (set (insert a A))) \\<and>\n  vcard (set A) < vcard (set (insert a A))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       Ord y \\<and> Card y \\<and> vcard (set A) < y \\<Longrightarrow>\n       vcard (set (insert a A)) \\<le> y", "show \"vcard (set (insert a A)) \\<le> i\"\n      if \"Ord i \\<and> Card i \\<and> vcard (set A) < i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "have \"elts (vcard (set A)) \\<approx> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vcard (set A)) \\<approx> A", "by (metis FA finite_imp_small cardinal_eqpoll elts_of_set)"], ["proof (state)\nthis:\n  elts (vcard (set A)) \\<approx> A\n\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "then"], ["proof (chain)\npicking this:\n  elts (vcard (set A)) \\<approx> A", "have less: \"A \\<prec> elts i\""], ["proof (prove)\nusing this:\n  elts (vcard (set A)) \\<approx> A\n\ngoal (1 subgoal):\n 1. A \\<prec> elts i", "using eq_lesspoll_trans eqpoll_sym lt_Card_imp_lesspoll that"], ["proof (prove)\nusing this:\n  elts (vcard (set A)) \\<approx> A\n  \\<lbrakk>?X \\<approx> ?Y; ?Y \\<prec> ?Z\\<rbrakk>\n  \\<Longrightarrow> ?X \\<prec> ?Z\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  \\<lbrakk>?i < ?a; Card ?a; Ord ?i\\<rbrakk>\n  \\<Longrightarrow> elts ?i \\<prec> elts ?a\n  Ord i \\<and> Card i \\<and> vcard (set A) < i\n\ngoal (1 subgoal):\n 1. A \\<prec> elts i", "by blast"], ["proof (state)\nthis:\n  A \\<prec> elts i\n\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "using that less"], ["proof (prove)\nusing this:\n  Ord i \\<and> Card i \\<and> vcard (set A) < i\n  A \\<prec> elts i\n\ngoal (1 subgoal):\n 1. vcard (set (insert a A)) \\<le> i", "by (auto simp: less_imp_insert_lepoll lepoll_cardinal_le)"], ["proof (state)\nthis:\n  vcard (set (insert a A)) \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ord ?i \\<and> Card ?i \\<and> vcard (set A) < ?i \\<Longrightarrow>\n  vcard (set (insert a A)) \\<le> ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vcard (set (insert a A)) = csucc (vcard (set A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vcard_finite_set: \"finite A \\<Longrightarrow> vcard (set A) = ord_of_nat (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> vcard (set A) = ord_of_nat (card A)", "by (induction A rule: finite_induct) (auto simp: set_empty \\<omega>_def finite_csucc)"], ["", "lemma lt_csucc_iff:\n  assumes \"Ord \\<alpha>\" \"Card \\<kappa>\"\n  shows \"\\<alpha> < csucc \\<kappa> \\<longleftrightarrow> vcard \\<alpha> \\<le> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> < csucc \\<kappa>) = (vcard \\<alpha> \\<le> \\<kappa>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> < csucc \\<kappa> \\<Longrightarrow>\n    vcard \\<alpha> \\<le> \\<kappa>\n 2. vcard \\<alpha> \\<le> \\<kappa> \\<Longrightarrow>\n    \\<alpha> < csucc \\<kappa>", "show \"vcard \\<alpha> \\<le> \\<kappa>\" if \"\\<alpha> < csucc \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> \\<kappa>", "have \"vcard \\<alpha> \\<le> csucc \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> csucc \\<kappa>", "by (meson \\<open>Ord \\<alpha>\\<close> dual_order.trans lepoll_cardinal_le lepoll_refl less_le_not_le that)"], ["proof (state)\nthis:\n  vcard \\<alpha> \\<le> csucc \\<kappa>\n\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> \\<kappa>", "then"], ["proof (chain)\npicking this:\n  vcard \\<alpha> \\<le> csucc \\<kappa>", "show ?thesis"], ["proof (prove)\nusing this:\n  vcard \\<alpha> \\<le> csucc \\<kappa>\n\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> \\<kappa>", "by (metis (no_types) Card_def Card_iff_initial Ord_linear2 Ord_mem_iff_lt assms cardinal_eqpoll cardinal_idem csucc_le eq_iff eqpoll_sym that)"], ["proof (state)\nthis:\n  vcard \\<alpha> \\<le> \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> < csucc \\<kappa> \\<Longrightarrow> vcard \\<alpha> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. vcard \\<alpha> \\<le> \\<kappa> \\<Longrightarrow>\n    \\<alpha> < csucc \\<kappa>", "show \"\\<alpha> < csucc \\<kappa>\" if \"vcard \\<alpha> \\<le> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> < csucc \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> < csucc \\<kappa>", "have \"\\<not> csucc \\<kappa> \\<le> \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> csucc \\<kappa> \\<le> \\<alpha>", "using that"], ["proof (prove)\nusing this:\n  vcard \\<alpha> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<not> csucc \\<kappa> \\<le> \\<alpha>", "by (metis Card_csucc Card_def assms(2) le_less_trans lepoll_imp_Card_le less_csucc less_eq_V_def less_le_not_le subset_imp_lepoll)"], ["proof (state)\nthis:\n  \\<not> csucc \\<kappa> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> < csucc \\<kappa>", "then"], ["proof (chain)\npicking this:\n  \\<not> csucc \\<kappa> \\<le> \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> csucc \\<kappa> \\<le> \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<alpha> < csucc \\<kappa>", "by (meson Card_csucc Card_is_Ord Ord_linear2 assms)"], ["proof (state)\nthis:\n  \\<alpha> < csucc \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vcard \\<alpha> \\<le> \\<kappa> \\<Longrightarrow> \\<alpha> < csucc \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Card_lt_csucc_iff: \"\\<lbrakk>Card \\<kappa>'; Card \\<kappa>\\<rbrakk> \\<Longrightarrow> (\\<kappa>' < csucc \\<kappa>) = (\\<kappa>' \\<le> \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Card \\<kappa>'; Card \\<kappa>\\<rbrakk>\n    \\<Longrightarrow> (\\<kappa>' < csucc \\<kappa>) =\n                      (\\<kappa>' \\<le> \\<kappa>)", "by (simp add: lt_csucc_iff Card_cardinal_eq Card_is_Ord)"], ["", "lemma InfCard_csucc: \"InfCard \\<kappa> \\<Longrightarrow> InfCard (csucc \\<kappa>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InfCard \\<kappa> \\<Longrightarrow> InfCard (csucc \\<kappa>)", "using InfCard_def le_csucc"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  Card ?\\<kappa> \\<Longrightarrow> ?\\<kappa> \\<le> csucc ?\\<kappa>\n\ngoal (1 subgoal):\n 1. InfCard \\<kappa> \\<Longrightarrow> InfCard (csucc \\<kappa>)", "by auto"], ["", "text\\<open>Kunen's Lemma 10.11\\<close>"], ["", "lemma InfCard_is_Limit:\n  assumes \"InfCard \\<kappa>\" shows \"Limit \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<kappa>", "proof (rule non_succ_LimitI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<kappa> \\<noteq> 0\n 2. Ord \\<kappa>\n 3. \\<And>y. ZFC_in_HOL.succ y \\<noteq> \\<kappa>", "show \"\\<kappa> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<noteq> 0", "using InfCard_def assms mem_not_refl"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n  ?i \\<notin> elts ?i\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<kappa> \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Ord \\<kappa>\n 2. \\<And>y. ZFC_in_HOL.succ y \\<noteq> \\<kappa>", "show \"Ord \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "using Card_is_Ord InfCard_def assms"], ["proof (prove)\nusing this:\n  Card ?\\<kappa> \\<Longrightarrow> Ord ?\\<kappa>\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n\ngoal (1 subgoal):\n 1. Ord \\<kappa>", "by blast"], ["proof (state)\nthis:\n  Ord \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<And>y. ZFC_in_HOL.succ y \\<noteq> \\<kappa>", "show \"ZFC_in_HOL.succ y \\<noteq> \\<kappa>\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y \\<noteq> \\<kappa>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "assume \"succ y = \\<kappa>\""], ["proof (state)\nthis:\n  ZFC_in_HOL.succ y = \\<kappa>\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ZFC_in_HOL.succ y = \\<kappa>", "have \"Card (succ y)\""], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ y = \\<kappa>\n\ngoal (1 subgoal):\n 1. Card (ZFC_in_HOL.succ y)", "using InfCard_def assms"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ y = \\<kappa>\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n\ngoal (1 subgoal):\n 1. Card (ZFC_in_HOL.succ y)", "by auto"], ["proof (state)\nthis:\n  Card (ZFC_in_HOL.succ y)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Card (ZFC_in_HOL.succ y)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "have \"\\<omega> \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<le> y", "by (metis InfCard_iff Ord_in_Ord \\<open>Ord \\<kappa>\\<close> \\<open>ZFC_in_HOL.succ y = \\<kappa>\\<close> assms elts_succ finite_insert infinite_Ord_omega insertI1)"], ["proof (state)\nthis:\n  \\<omega> \\<le> y\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<omega> \\<le> y\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "have \"elts y \\<approx> elts (succ y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts y \\<approx> elts (ZFC_in_HOL.succ y)", "using InfCard_iff \\<open>ZFC_in_HOL.succ y = \\<kappa>\\<close> assms eqpoll_sym infinite_insert_eqpoll"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> = (Card ?\\<kappa> \\<and> infinite (elts ?\\<kappa>))\n  ZFC_in_HOL.succ y = \\<kappa>\n  InfCard \\<kappa>\n  ?A \\<approx> ?B \\<Longrightarrow> ?B \\<approx> ?A\n  infinite ?A \\<Longrightarrow> insert ?a ?A \\<approx> ?A\n\ngoal (1 subgoal):\n 1. elts y \\<approx> elts (ZFC_in_HOL.succ y)", "by fastforce"], ["proof (state)\nthis:\n  elts y \\<approx> elts (ZFC_in_HOL.succ y)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ y = \\<kappa> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Card (ZFC_in_HOL.succ y)\n  \\<omega> \\<le> y\n  elts y \\<approx> elts (ZFC_in_HOL.succ y)", "show False"], ["proof (prove)\nusing this:\n  Card (ZFC_in_HOL.succ y)\n  \\<omega> \\<le> y\n  elts y \\<approx> elts (ZFC_in_HOL.succ y)\n\ngoal (1 subgoal):\n 1. False", "by (metis Card_iff_initial Ord_in_Ord OrdmemD elts_succ insertI1)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ ?y \\<noteq> \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Toward's Kunen's Corollary 10.13 (1)\\<close>"], ["", "text\\<open>Kunen's Theorem 10.12\\<close>"], ["", "lemma InfCard_csquare_eq:\n  assumes \"InfCard(\\<kappa>)\" shows \"\\<kappa> \\<otimes> \\<kappa> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<kappa> = \\<kappa>", "using infinite_times_eqpoll_self [of \"elts \\<kappa>\"] assms"], ["proof (prove)\nusing this:\n  infinite (elts \\<kappa>) \\<Longrightarrow>\n  elts \\<kappa> \\<times> elts \\<kappa> \\<approx> elts \\<kappa>\n  InfCard \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<kappa> = \\<kappa>", "unfolding InfCard_iff Card_def"], ["proof (prove)\nusing this:\n  infinite (elts \\<kappa>) \\<Longrightarrow>\n  elts \\<kappa> \\<times> elts \\<kappa> \\<approx> elts \\<kappa>\n  \\<kappa> = vcard \\<kappa> \\<and> infinite (elts \\<kappa>)\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<kappa> = \\<kappa>", "by (metis cardinal_cong cardinal_eqpoll cmult_def elts_vcard_VSigma_eqpoll eqpoll_trans)"], ["", "lemma InfCard_le_cmult_eq:\n  assumes \"InfCard \\<kappa>\" \"\\<mu> \\<le> \\<kappa>\" \"\\<mu> \\<noteq> 0\"\n  shows \"\\<kappa> \\<otimes> \\<mu> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<mu> = \\<kappa>", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n 2. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "have \"\\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa> \\<otimes> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa> \\<otimes> \\<kappa>", "by (simp add: assms(2) cmult_le_mono)"], ["proof (state)\nthis:\n  \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa> \\<otimes> \\<kappa>\n\ngoal (2 subgoals):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n 2. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "also"], ["proof (state)\nthis:\n  \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa> \\<otimes> \\<kappa>\n\ngoal (2 subgoals):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n 2. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "have \"\\<dots> \\<le> \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<kappa> \\<le> \\<kappa>", "by (simp add: InfCard_csquare_eq assms(1))"], ["proof (state)\nthis:\n  \\<kappa> \\<otimes> \\<kappa> \\<le> \\<kappa>\n\ngoal (2 subgoals):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n 2. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>", "show \"\\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\""], ["proof (prove)\nusing this:\n  \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>", "."], ["proof (state)\nthis:\n  \\<kappa> \\<otimes> \\<mu> \\<le> \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "show \"\\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "using InfCard_def assms(1) assms(3) cmult_le_self"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n  \\<mu> \\<noteq> 0\n  \\<lbrakk>Card ?\\<kappa>; ?\\<alpha> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ?\\<kappa> \\<le> ?\\<kappa> \\<otimes> ?\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>", "by auto"], ["proof (state)\nthis:\n  \\<kappa> \\<le> \\<kappa> \\<otimes> \\<mu>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Kunen's Corollary 10.13 (1), for cardinal multiplication\\<close>"], ["", "lemma InfCard_cmult_eq: \"\\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<otimes> \\<mu> = \\<kappa> \\<squnion> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> \\<otimes> \\<mu> = \\<kappa> \\<squnion> \\<mu>", "by (metis Card_is_Ord InfCard_def InfCard_le_cmult_eq Ord_linear_le cmult_commute inf_sup_aci(5) mem_not_refl sup.orderE sup_V_0_right zero_in_omega)"], ["", "lemma cmult_succ:\n  \"succ(m) \\<otimes> n = n \\<oplus> (m \\<otimes> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ m \\<otimes> n = n \\<oplus> m \\<otimes> n", "unfolding cmult_def cadd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard (vtimes (ZFC_in_HOL.succ m) n) =\n    vcard (n \\<Uplus> vcard (vtimes m n))", "proof (rule cardinal_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "have \"elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx> elts n <+> elts m \\<times> elts n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts n <+> elts m \\<times> elts n", "by (simp add: elts_VSigma prod_insert_eqpoll)"], ["proof (state)\nthis:\n  elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n  elts n <+> elts m \\<times> elts n\n\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "also"], ["proof (state)\nthis:\n  elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n  elts n <+> elts m \\<times> elts n\n\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "have \"\\<dots> \\<approx> elts (n \\<Uplus> vcard (vtimes m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts n <+> elts m \\<times> elts n \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "unfolding elts_VSigma elts_vsum Plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_Type.Inl ` elts n \\<union>\n    Sum_Type.Inr ` (elts m \\<times> elts n) \\<approx>\n    ZFC_Cardinals.Inl ` elts n \\<union>\n    ZFC_Cardinals.Inr ` elts (vcard (vtimes m n))", "proof (rule Un_eqpoll_cong)"], ["proof (state)\ngoal (4 subgoals):\n 1. Sum_Type.Inl ` elts n \\<approx> ZFC_Cardinals.Inl ` elts n\n 2. Sum_Type.Inr ` (elts m \\<times> elts n) \\<approx>\n    ZFC_Cardinals.Inr ` elts (vcard (vtimes m n))\n 3. disjnt (Sum_Type.Inl ` elts n) (Sum_Type.Inr ` (elts m \\<times> elts n))\n 4. disjnt (ZFC_Cardinals.Inl ` elts n)\n     (ZFC_Cardinals.Inr ` elts (vcard (vtimes m n)))", "show \"(Sum_Type.Inr ` (elts m \\<times> elts n)::(V + V \\<times> V) set) \\<approx> Inr ` elts (vcard (vtimes m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sum_Type.Inr ` (elts m \\<times> elts n) \\<approx>\n    ZFC_Cardinals.Inr ` elts (vcard (vtimes m n))", "by (simp add: elts_vcard_VSigma_eqpoll eqpoll_sym)"], ["proof (state)\nthis:\n  Sum_Type.Inr ` (elts m \\<times> elts n) \\<approx>\n  ZFC_Cardinals.Inr ` elts (vcard (vtimes m n))\n\ngoal (3 subgoals):\n 1. Sum_Type.Inl ` elts n \\<approx> ZFC_Cardinals.Inl ` elts n\n 2. disjnt (Sum_Type.Inl ` elts n) (Sum_Type.Inr ` (elts m \\<times> elts n))\n 3. disjnt (ZFC_Cardinals.Inl ` elts n)\n     (ZFC_Cardinals.Inr ` elts (vcard (vtimes m n)))", "qed (auto simp: disjnt_def)"], ["proof (state)\nthis:\n  elts n <+> elts m \\<times> elts n \\<approx>\n  elts (n \\<Uplus> vcard (vtimes m n))\n\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "finally"], ["proof (chain)\npicking this:\n  elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n  elts (n \\<Uplus> vcard (vtimes m n))", "show \"elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx> elts (n \\<Uplus> vcard (vtimes m n))\""], ["proof (prove)\nusing this:\n  elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n  elts (n \\<Uplus> vcard (vtimes m n))\n\ngoal (1 subgoal):\n 1. elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n    elts (n \\<Uplus> vcard (vtimes m n))", "."], ["proof (state)\nthis:\n  elts (vtimes (ZFC_in_HOL.succ m) n) \\<approx>\n  elts (n \\<Uplus> vcard (vtimes m n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cmult_2:\n  assumes \"Card n\" shows \"ord_of_nat 2 \\<otimes> n = n \\<oplus> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat 2 \\<otimes> n = n \\<oplus> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_of_nat 2 \\<otimes> n = n \\<oplus> n", "have \"ord_of_nat 2 = succ (succ 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat 2 = ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)", "by force"], ["proof (state)\nthis:\n  ord_of_nat 2 = ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)\n\ngoal (1 subgoal):\n 1. ord_of_nat 2 \\<otimes> n = n \\<oplus> n", "then"], ["proof (chain)\npicking this:\n  ord_of_nat 2 = ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ord_of_nat 2 = ZFC_in_HOL.succ (ZFC_in_HOL.succ 0)\n\ngoal (1 subgoal):\n 1. ord_of_nat 2 \\<otimes> n = n \\<oplus> n", "by (simp add: cmult_succ assms)"], ["proof (state)\nthis:\n  ord_of_nat 2 \\<otimes> n = n \\<oplus> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma InfCard_cdouble_eq:\n  assumes \"InfCard \\<kappa>\" shows \"\\<kappa> \\<oplus> \\<kappa> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "have \"\\<kappa> \\<oplus> \\<kappa> = \\<kappa> \\<otimes> ord_of_nat 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa> \\<otimes> ord_of_nat 2", "using InfCard_def assms cmult_2 cmult_commute"], ["proof (prove)\nusing this:\n  InfCard ?\\<kappa> \\<equiv> Card ?\\<kappa> \\<and> \\<omega> \\<le> ?\\<kappa>\n  InfCard \\<kappa>\n  Card ?n \\<Longrightarrow> ord_of_nat 2 \\<otimes> ?n = ?n \\<oplus> ?n\n  ?i \\<otimes> ?j = ?j \\<otimes> ?i\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa> \\<otimes> ord_of_nat 2", "by auto"], ["proof (state)\nthis:\n  \\<kappa> \\<oplus> \\<kappa> = \\<kappa> \\<otimes> ord_of_nat 2\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "also"], ["proof (state)\nthis:\n  \\<kappa> \\<oplus> \\<kappa> = \\<kappa> \\<otimes> ord_of_nat 2\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "have \"\\<dots> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<kappa> \\<otimes> ord_of_nat 2 = \\<kappa>", "by (simp add: InfCard_le_cmult_eq InfCard_ge_ord_of_nat assms)"], ["proof (state)\nthis:\n  \\<kappa> \\<otimes> ord_of_nat 2 = \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "finally"], ["proof (chain)\npicking this:\n  \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<kappa> \\<oplus> \\<kappa> = \\<kappa>\n\ngoal (1 subgoal):\n 1. \\<kappa> \\<oplus> \\<kappa> = \\<kappa>", "."], ["proof (state)\nthis:\n  \\<kappa> \\<oplus> \\<kappa> = \\<kappa>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Corollary 10.13 (1), for cardinal addition\\<close>"], ["", "lemma InfCard_le_cadd_eq: \"\\<lbrakk>InfCard \\<kappa>; \\<mu> \\<le> \\<kappa>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InfCard \\<kappa>; \\<mu> \\<le> \\<kappa>\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa>", "by (metis InfCard_cdouble_eq InfCard_def antisym cadd_le_mono cadd_le_self)"], ["", "lemma InfCard_cadd_eq: \"\\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk> \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa> \\<squnion> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>InfCard \\<kappa>; InfCard \\<mu>\\<rbrakk>\n    \\<Longrightarrow> \\<kappa> \\<oplus> \\<mu> = \\<kappa> \\<squnion> \\<mu>", "by (metis Card_iff_initial InfCard_def InfCard_le_cadd_eq Ord_linear_le cadd_commute sup.absorb2 sup.orderE)"], ["", "subsection \\<open>The Aleph-seqence\\<close>"], ["", "text \\<open>This is the well-known transfinite enumeration of the cardinal numbers.\\<close>"], ["", "definition\n  Aleph :: \"V \\<Rightarrow> V\"   (\\<open>\\<aleph>_\\<close> [90] 90) \n  where \"Aleph \\<equiv> transrec3 \\<omega> (\\<lambda>x r. csucc(r)) (\\<lambda>i r . \\<Squnion> (r ` elts i))\""], ["", "lemma Card_Aleph [simp, intro]:\n     \"Ord \\<alpha> \\<Longrightarrow> Card(Aleph \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<Longrightarrow> Card (\\<aleph>\\<alpha>)", "by (induction \\<alpha> rule: Ord_induct3) (auto simp: Aleph_def)"], ["", "lemma Aleph_0 [simp]: \"\\<aleph>0 = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aleph>0 = \\<omega>", "by (simp add: Aleph_def)"], ["", "lemma Aleph_succ [simp]: \"\\<aleph>(succ x) = csucc (\\<aleph> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aleph>ZFC_in_HOL.succ x = csucc (\\<aleph>x)", "by (simp add: Aleph_def)"], ["", "lemma Aleph_Limit: \"Limit \\<gamma> \\<Longrightarrow> \\<aleph> \\<gamma> = \\<Squnion> (Aleph ` elts \\<gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<gamma> \\<Longrightarrow>\n    \\<aleph>\\<gamma> = \\<Squnion> (Aleph ` elts \\<gamma>)", "by (simp add: Aleph_def)"], ["", "lemma mem_Aleph_succ: \"Ord \\<alpha> \\<Longrightarrow> \\<aleph>(\\<alpha>) \\<in> elts (\\<aleph>(succ \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<alpha> \\<Longrightarrow>\n    \\<aleph>\\<alpha> \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)", "by (simp add: Card_is_Ord Ord_mem_iff_lt)"], ["", "lemma Aleph_increasing:\n  assumes ab: \"\\<alpha> < \\<beta>\" \"Ord \\<alpha>\" \"Ord \\<beta>\" shows \"Aleph(\\<alpha>) < Aleph(\\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "have \"\\<lbrakk>Ord x; x \\<in> elts \\<beta>\\<rbrakk> \\<Longrightarrow> Aleph(x) \\<in> elts (Aleph \\<beta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord x; x \\<in> elts \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<beta>)", "using \\<open>Ord \\<beta>\\<close>"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ord x; x \\<in> elts \\<beta>\\<rbrakk>\n    \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<beta>)", "proof (induct \\<beta> arbitrary: x rule: Ord_induct3)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Ord x; x \\<in> elts 0\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>0)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 3. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "case 0"], ["proof (state)\nthis:\n  Ord x\n  x \\<in> elts 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Ord x; x \\<in> elts 0\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>0)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 3. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "thus ?case"], ["proof (prove)\nusing this:\n  Ord x\n  x \\<in> elts 0\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>0)", "by simp"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<aleph>0)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "case (succ \\<beta>)"], ["proof (state)\nthis:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "then"], ["proof (chain)\npicking this:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)", "consider \"x = \\<beta>\" |\"x \\<in> elts \\<beta>\""], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<beta> \\<Longrightarrow> thesis;\n     x \\<in> elts \\<beta> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using OrdmemD"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<beta> \\<Longrightarrow> thesis;\n     x \\<in> elts \\<beta> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x = \\<beta> \\<Longrightarrow> ?thesis;\n   x \\<in> elts \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Ord \\<alpha>;\n        \\<And>x.\n           \\<lbrakk>Ord x; x \\<in> elts \\<alpha>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<alpha>);\n        Ord x; x \\<in> elts (ZFC_in_HOL.succ \\<alpha>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<alpha>)\n 2. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = \\<beta> \\<Longrightarrow> ?thesis;\n   x \\<in> elts \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = \\<beta> \\<Longrightarrow> ?thesis;\n   x \\<in> elts \\<beta> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. x = \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)\n 2. x \\<in> elts \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "case 1"], ["proof (state)\nthis:\n  x = \\<beta>\n\ngoal (2 subgoals):\n 1. x = \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)\n 2. x \\<in> elts \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "then"], ["proof (chain)\npicking this:\n  x = \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<beta>\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "by (simp add: Card_is_Ord Ord_mem_iff_lt succ.hyps(1))"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)\n\ngoal (1 subgoal):\n 1. x \\<in> elts \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> elts \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "case 2"], ["proof (state)\nthis:\n  x \\<in> elts \\<beta>\n\ngoal (1 subgoal):\n 1. x \\<in> elts \\<beta> \\<Longrightarrow>\n    \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "with succ"], ["proof (chain)\npicking this:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)\n  x \\<in> elts \\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  Ord \\<beta>\n  \\<lbrakk>Ord ?x; ?x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>\\<beta>)\n  Ord x\n  x \\<in> elts (ZFC_in_HOL.succ \\<beta>)\n  x \\<in> elts \\<beta>\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)", "by (metis Aleph_succ Card_Aleph le_csucc vsubsetD)"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<aleph>ZFC_in_HOL.succ \\<beta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "case (Limit \\<gamma>)"], ["proof (state)\nthis:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; Ord ?x; ?x \\<in> elts ?\\<xi>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>?\\<xi>)\n  Ord x\n  x \\<in> elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "hence sc: \"succ x \\<in> elts \\<gamma>\""], ["proof (prove)\nusing this:\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; Ord ?x; ?x \\<in> elts ?\\<xi>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>?\\<xi>)\n  Ord x\n  x \\<in> elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. ZFC_in_HOL.succ x \\<in> elts \\<gamma>", "by (simp add: Limit_def Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  ZFC_in_HOL.succ x \\<in> elts \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "hence \"\\<aleph> x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))\""], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ x \\<in> elts \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))", "using Limit"], ["proof (prove)\nusing this:\n  ZFC_in_HOL.succ x \\<in> elts \\<gamma>\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; Ord ?x; ?x \\<in> elts ?\\<xi>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>?\\<xi>)\n  Ord x\n  x \\<in> elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))", "by blast"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha> x.\n       \\<lbrakk>Limit \\<alpha>;\n        \\<And>\\<xi> x.\n           \\<lbrakk>\\<xi> \\<in> elts \\<alpha>; Ord x;\n            x \\<in> elts \\<xi>\\<rbrakk>\n           \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<xi>);\n        Ord x; x \\<in> elts (SUP \\<xi>\\<in>elts \\<alpha>. \\<xi>)\\<rbrakk>\n       \\<Longrightarrow> \\<aleph>x\n                         \\<in> elts\n                                (\\<aleph>(SUP \\<xi>\\<in>elts \\<alpha>.\n       \\<xi>))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<aleph>x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>(SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>))", "using Limit"], ["proof (prove)\nusing this:\n  \\<aleph>x \\<in> elts (\\<Squnion> (Aleph ` elts \\<gamma>))\n  Limit \\<gamma>\n  \\<lbrakk>?\\<xi> \\<in> elts \\<gamma>; Ord ?x; ?x \\<in> elts ?\\<xi>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x \\<in> elts (\\<aleph>?\\<xi>)\n  Ord x\n  x \\<in> elts (SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>)\n\ngoal (1 subgoal):\n 1. \\<aleph>x \\<in> elts (\\<aleph>(SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>))", "by (simp add: Aleph_Limit)"], ["proof (state)\nthis:\n  \\<aleph>x \\<in> elts (\\<aleph>(SUP \\<xi>\\<in>elts \\<gamma>. \\<xi>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>Ord x; x \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>x \\<in> elts (\\<aleph>\\<beta>)\n\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Ord ?x2; ?x2 \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x2 \\<in> elts (\\<aleph>\\<beta>)\n\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?x2; ?x2 \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x2 \\<in> elts (\\<aleph>\\<beta>)\n\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "using ab"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ord ?x2; ?x2 \\<in> elts \\<beta>\\<rbrakk>\n  \\<Longrightarrow> \\<aleph>?x2 \\<in> elts (\\<aleph>\\<beta>)\n  \\<alpha> < \\<beta>\n  Ord \\<alpha>\n  Ord \\<beta>\n\ngoal (1 subgoal):\n 1. \\<aleph>\\<alpha> < \\<aleph>\\<beta>", "by (simp add: Card_is_Ord Ord_mem_iff_lt)"], ["proof (state)\nthis:\n  \\<aleph>\\<alpha> < \\<aleph>\\<beta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma countable_iff_le_Aleph0: \"countable (elts A) \\<longleftrightarrow> vcard A \\<le> \\<aleph>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts A) = (vcard A \\<le> \\<aleph>0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. countable (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0\n 2. vcard A \\<le> \\<aleph>0 \\<Longrightarrow> countable (elts A)", "show \"vcard A \\<le> \\<aleph>0\"\n    if \"countable (elts A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0", "proof (cases \"finite (elts A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0\n 2. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "case True"], ["proof (state)\nthis:\n  finite (elts A)\n\ngoal (2 subgoals):\n 1. finite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0\n 2. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "then"], ["proof (chain)\npicking this:\n  finite (elts A)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (elts A)\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0", "using vcard_finite_set"], ["proof (prove)\nusing this:\n  finite (elts A)\n  finite ?A \\<Longrightarrow> vcard (set ?A) = ord_of_nat (card ?A)\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0", "by fastforce"], ["proof (state)\nthis:\n  vcard A \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "case False"], ["proof (state)\nthis:\n  infinite (elts A)\n\ngoal (1 subgoal):\n 1. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "then"], ["proof (chain)\npicking this:\n  infinite (elts A)", "have \"elts \\<omega> \\<approx> elts A\""], ["proof (prove)\nusing this:\n  infinite (elts A)\n\ngoal (1 subgoal):\n 1. elts \\<omega> \\<approx> elts A", "using countableE_infinite [OF that]"], ["proof (prove)\nusing this:\n  infinite (elts A)\n  \\<lbrakk>infinite (elts A);\n   \\<And>e. bij_betw e (elts A) UNIV \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. elts \\<omega> \\<approx> elts A", "by (simp add: eqpoll_def \\<omega>_def) (meson bij_betw_def bij_betw_inv bij_betw_trans inj_ord_of_nat)"], ["proof (state)\nthis:\n  elts \\<omega> \\<approx> elts A\n\ngoal (1 subgoal):\n 1. infinite (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0", "then"], ["proof (chain)\npicking this:\n  elts \\<omega> \\<approx> elts A", "show ?thesis"], ["proof (prove)\nusing this:\n  elts \\<omega> \\<approx> elts A\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0", "using Card_\\<omega> Card_def cardinal_cong vcard_def"], ["proof (prove)\nusing this:\n  elts \\<omega> \\<approx> elts A\n  Card \\<omega>\n  Card ?i \\<equiv> ?i = vcard ?i\n  elts ?x \\<approx> elts ?y \\<Longrightarrow> vcard ?x = vcard ?y\n  vcard ?a \\<equiv> LEAST i. Ord i \\<and> elts i \\<approx> elts ?a\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0", "by auto"], ["proof (state)\nthis:\n  vcard A \\<le> \\<aleph>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  countable (elts A) \\<Longrightarrow> vcard A \\<le> \\<aleph>0\n\ngoal (1 subgoal):\n 1. vcard A \\<le> \\<aleph>0 \\<Longrightarrow> countable (elts A)", "show \"countable (elts A)\"\n    if \"vcard A \\<le> \\<aleph>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (elts A)", "have \"elts A \\<lesssim> elts \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elts A \\<lesssim> elts \\<omega>", "using cardinal_le_lepoll [OF that]"], ["proof (prove)\nusing this:\n  elts A \\<lesssim> elts (\\<aleph>0)\n\ngoal (1 subgoal):\n 1. elts A \\<lesssim> elts \\<omega>", "by simp"], ["proof (state)\nthis:\n  elts A \\<lesssim> elts \\<omega>\n\ngoal (1 subgoal):\n 1. countable (elts A)", "then"], ["proof (chain)\npicking this:\n  elts A \\<lesssim> elts \\<omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  elts A \\<lesssim> elts \\<omega>\n\ngoal (1 subgoal):\n 1. countable (elts A)", "by (simp add: countable_iff_lepoll \\<omega>_def inj_ord_of_nat)"], ["proof (state)\nthis:\n  countable (elts A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vcard A \\<le> \\<aleph>0 \\<Longrightarrow> countable (elts A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The ordinal @{term \"\\<omega>1\"}\\<close>"], ["", "abbreviation \"\\<omega>1 \\<equiv> Aleph 1\""], ["", "lemma Ord_\\<omega>1 [simp]: \"Ord \\<omega>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ord \\<omega>1", "by (simp add: Card_is_Ord)"], ["", "lemma omega_\\<omega>1 [iff]: \"\\<omega> \\<in> elts \\<omega>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<in> elts \\<omega>1", "using mem_Aleph_succ one_V_def"], ["proof (prove)\nusing this:\n  Ord ?\\<alpha> \\<Longrightarrow>\n  \\<aleph>?\\<alpha> \\<in> elts (\\<aleph>ZFC_in_HOL.succ ?\\<alpha>)\n  1 \\<equiv> ZFC_in_HOL.succ 0\n\ngoal (1 subgoal):\n 1. \\<omega> \\<in> elts \\<omega>1", "by fastforce"], ["", "lemma ord_of_nat_\\<omega>1 [iff]: \"ord_of_nat n \\<in> elts \\<omega>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_of_nat n \\<in> elts \\<omega>1", "using Ord_\\<omega>1 Ord_trans"], ["proof (prove)\nusing this:\n  Ord \\<omega>1\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n\ngoal (1 subgoal):\n 1. ord_of_nat n \\<in> elts \\<omega>1", "by blast"], ["", "lemma countable_iff_less_\\<omega>1:\n  assumes \"Ord \\<alpha>\"\n  shows \"countable (elts \\<alpha>) \\<longleftrightarrow> \\<alpha> < \\<omega>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts \\<alpha>) = (\\<alpha> < \\<omega>1)", "by (simp add: assms countable_iff_le_Aleph0 lt_csucc_iff one_V_def)"], ["", "lemma less_\\<omega>1_imp_countable:\n  assumes \"\\<alpha> \\<in> elts \\<omega>1\"\n  shows \"countable (elts \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (elts \\<alpha>)", "using Ord_\\<omega>1 Ord_in_Ord OrdmemD assms countable_iff_less_\\<omega>1"], ["proof (prove)\nusing this:\n  Ord \\<omega>1\n  \\<lbrakk>Ord ?k; ?m \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> Ord ?m\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  \\<alpha> \\<in> elts \\<omega>1\n  Ord ?\\<alpha> \\<Longrightarrow>\n  countable (elts ?\\<alpha>) = (?\\<alpha> < \\<omega>1)\n\ngoal (1 subgoal):\n 1. countable (elts \\<alpha>)", "by blast"], ["", "lemma \\<omega>1_gt0 [simp]: \"\\<omega>1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<omega>1", "using Ord_\\<omega>1 Ord_trans OrdmemD"], ["proof (prove)\nusing this:\n  Ord \\<omega>1\n  \\<lbrakk>?i \\<in> elts ?j; ?j \\<in> elts ?k; Ord ?k\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> elts ?k\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n\ngoal (1 subgoal):\n 1. 0 < \\<omega>1", "by blast"], ["", "lemma \\<omega>1_gt1 [simp]: \"\\<omega>1 > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<omega>1", "using Ord_\\<omega>1 OrdmemD \\<omega>_gt1 less_trans"], ["proof (prove)\nusing this:\n  Ord \\<omega>1\n  \\<lbrakk>Ord ?k; ?j \\<in> elts ?k\\<rbrakk> \\<Longrightarrow> ?j < ?k\n  1 < \\<omega>\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. 1 < \\<omega>1", "by blast"], ["", "lemma Limit_\\<omega>1 [simp]: \"Limit \\<omega>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Limit \\<omega>1", "by (simp add: InfCard_def InfCard_is_Limit le_csucc one_V_def)"], ["", "end"]]}