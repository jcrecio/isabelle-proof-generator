{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem/Code_Export.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem", "problem_names": ["lemma [code]:\n  \"hashcode (set xs) = fold (plus o cube o hashcode) (remdups xs) (uint32_of_nat (length (remdups xs)))\"", "lemma [code]:\n  \"hashcode (abs_ltln\\<^sub>P \\<phi>) = hashcode (min_dnf \\<phi>)\"", "lemma min_dnf_rep_abs[simp]:\n  \"min_dnf (Unf (rep_ltln\\<^sub>Q (abs_ltln\\<^sub>Q \\<phi>))) = min_dnf (Unf \\<phi>)\"", "lemma [code]:\n  \"hashcode (abs_ltln\\<^sub>Q \\<phi>) = hashcode (min_dnf (Unf \\<phi>))\""], "translations": [["", "lemma [code]:\n  \"hashcode (set xs) = fold (plus o cube o hashcode) (remdups xs) (uint32_of_nat (length (remdups xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode (set xs) =\n    fold ((+) \\<circ> cube \\<circ> hashcode) (remdups xs)\n     (uint32_of_nat (length (remdups xs)))", "by (simp add: fold_set_fold_remdups length_remdups_card_conv)"], ["", "lemma [code]:\n  \"hashcode (abs_ltln\\<^sub>P \\<phi>) = hashcode (min_dnf \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode (abs_ltln\\<^sub>P \\<phi>) = hashcode (min_dnf \\<phi>)", "by simp"], ["", "lemma min_dnf_rep_abs[simp]:\n  \"min_dnf (Unf (rep_ltln\\<^sub>Q (abs_ltln\\<^sub>Q \\<phi>))) = min_dnf (Unf \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dnf (Unf (rep_ltln\\<^sub>Q (abs_ltln\\<^sub>Q \\<phi>))) =\n    min_dnf (Unf \\<phi>)", "using Quotient3_ltln\\<^sub>Q ltl_prop_equiv_min_dnf ltl_prop_unfold_equiv_def rep_abs_rsp"], ["proof (prove)\nusing this:\n  Quotient3 (\\<sim>\\<^sub>Q) abs_ltln\\<^sub>Q rep_ltln\\<^sub>Q\n  ?\\<phi> \\<sim>\\<^sub>P ?\\<psi> = (min_dnf ?\\<phi> = min_dnf ?\\<psi>)\n  ?\\<phi> \\<sim>\\<^sub>Q ?\\<psi> \\<equiv>\n  Unf ?\\<phi> \\<sim>\\<^sub>P Unf ?\\<psi>\n  \\<lbrakk>Quotient3 ?R ?Abs ?Rep; ?R ?x1.0 ?x2.0\\<rbrakk>\n  \\<Longrightarrow> ?R ?x1.0 (?Rep (?Abs ?x2.0))\n\ngoal (1 subgoal):\n 1. min_dnf (Unf (rep_ltln\\<^sub>Q (abs_ltln\\<^sub>Q \\<phi>))) =\n    min_dnf (Unf \\<phi>)", "by fastforce"], ["", "lemma [code]:\n  \"hashcode (abs_ltln\\<^sub>Q \\<phi>) = hashcode (min_dnf (Unf \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode (abs_ltln\\<^sub>Q \\<phi>) = hashcode (min_dnf (Unf \\<phi>))", "by simp"], ["", "subsection \\<open>LTL to DRA\\<close>"], ["", "declare ltl_to_dra\\<^sub>P.af_letter\\<^sub>F_lifted_semantics [code]"], ["", "declare ltl_to_dra\\<^sub>P.af_letter\\<^sub>G_lifted_semantics [code]"], ["", "declare ltl_to_dra\\<^sub>P.af_letter\\<^sub>\\<nu>_lifted_semantics [code]"], ["", "declare ltl_to_dra\\<^sub>Q.af_letter\\<^sub>F_lifted_semantics [code]"], ["", "declare ltl_to_dra\\<^sub>Q.af_letter\\<^sub>G_lifted_semantics [code]"], ["", "declare ltl_to_dra\\<^sub>Q.af_letter\\<^sub>\\<nu>_lifted_semantics [code]"], ["", "definition atoms_ltlc_list_literals :: \"String.literal ltlc \\<Rightarrow> String.literal list\"\nwhere\n  \"atoms_ltlc_list_literals = atoms_ltlc_list\""], ["", "definition ltlc_to_draei_literals :: \"equiv \\<Rightarrow> String.literal ltlc \\<Rightarrow> (String.literal set, nat) draei\"\nwhere\n  \"ltlc_to_draei_literals = ltlc_to_draei\""], ["", "definition sort_transitions :: \"(nat \\<times> String.literal set \\<times> nat) list \\<Rightarrow> (nat \\<times> String.literal set \\<times> nat) list\"\nwhere\n  \"sort_transitions = sort_key fst\""], ["", "export_code True_ltlc Iff_ltlc ltlc_to_draei_literals Prop PropUnfold\n  alphabetei initialei transitionei conditionei\n  integer_of_nat atoms_ltlc_list_literals sort_transitions set\n  in SML module_name LTL file_prefix LTL_to_DRA"], ["", "subsection \\<open>LTL to NBA\\<close>"], ["", "(* TODO *)"], ["", "subsection \\<open>LTL to LDBA\\<close>"], ["", "(* TODO *)"], ["", "end"]]}