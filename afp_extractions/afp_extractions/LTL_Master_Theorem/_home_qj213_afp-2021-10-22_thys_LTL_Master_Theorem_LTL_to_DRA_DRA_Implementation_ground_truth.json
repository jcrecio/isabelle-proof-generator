{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Implementation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem", "problem_names": ["lemma dra_to_drai_language:\n  \"set \\<Sigma> = alphabet \\<AA> \\<Longrightarrow> language (drai_dra (dra_to_drai \\<AA> \\<Sigma>)) = language \\<AA>\"", "lemma dra_to_drai_rel:\n  assumes\n    \"(\\<Sigma>, alphabet A) \\<in> \\<langle>Id\\<rangle> list_set_rel\"\n  shows\n    \"(dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\"", "lemma draei_language_rel:\n  fixes\n    A :: \"('label, 'state :: hashable) dra\"\n  assumes\n    \"(\\<Sigma>, alphabet A) \\<in> \\<langle>Id\\<rangle> list_set_rel\"\n  and\n    \"finite (DRA.nodes A)\"\n  and\n    \"is_valid_def_hm_size TYPE('state) hms\"\n  shows\n    \"DRA.language (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) = DRA.language A\"", "lemma atoms_ltlc_list_set:\n  \"set (atoms_ltlc_list \\<phi>) = atoms_ltlc \\<phi>\"", "lemma atoms_ltlc_list_distinct:\n  \"distinct (atoms_ltlc_list \\<phi>)\"", "lemma ltl_to_dra_alphabet_rel:\n  \"distinct AP \\<Longrightarrow> (ltl_alphabet AP, alphabet (ltl_to_dra_alphabet \\<psi> (set AP))) \\<in> \\<langle>Id\\<rangle> list_set_rel\"", "lemma ltlc_to_ltln_simplify_atoms:\n  \"atoms_ltln (simplify Slow (ltlc_to_ltln \\<phi>)) \\<subseteq> atoms_ltlc \\<phi>\"", "lemma valid_def_hm_size:\n  \"is_valid_def_hm_size TYPE('state) (Suc (size \\<phi>))\" for \\<phi> :: \"'a ltln\"", "theorem final_correctness:\n  \"to_omega ` language (drae_dra (draei_drae (ltlc_to_draei \\<phi>)))\n    = language_ltlc \\<phi> \\<inter> {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}\""], "translations": [["", "lemma dra_to_drai_language:\n  \"set \\<Sigma> = alphabet \\<AA> \\<Longrightarrow> language (drai_dra (dra_to_drai \\<AA> \\<Sigma>)) = language \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<Sigma> = dra.alphabet \\<AA> \\<Longrightarrow>\n    DRA.language (drai_dra (dra_to_drai \\<AA> \\<Sigma>)) =\n    DRA.language \\<AA>", "by (simp add: dra_to_drai_def drai_dra_def)"], ["", "definition drai_to_draei :: \"nat \\<Rightarrow> ('a, 'b :: hashable) drai \\<Rightarrow> ('a, nat) draei\"\nwhere\n  \"drai_to_draei hms = to_draei_impl (=) bounded_hashcode_nat hms\""], ["", "lemma dra_to_drai_rel:\n  assumes\n    \"(\\<Sigma>, alphabet A) \\<in> \\<langle>Id\\<rangle> list_set_rel\"\n  shows\n    \"(dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "have \"(A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel", "by simp"], ["proof (state)\nthis:\n  (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "then"], ["proof (chain)\npicking this:\n  (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel", "have \"(dra_to_drai A \\<Sigma>, dra (alphabet A) (initial A) (transition A) (condition A)) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\""], ["proof (prove)\nusing this:\n  (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>,\n     dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n    \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "unfolding dra_to_drai_def"], ["proof (prove)\nusing this:\n  (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel\n\ngoal (1 subgoal):\n 1. (drai \\<Sigma> (dra.initial A) (dra.transition A) (condition A),\n     dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n    \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "using assms"], ["proof (prove)\nusing this:\n  (A, A) \\<in> \\<langle>Id, Id\\<rangle>dra_rel\n  (\\<Sigma>, dra.alphabet A) \\<in> \\<langle>Id\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (drai \\<Sigma> (dra.initial A) (dra.transition A) (condition A),\n     dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n    \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "by parametricity"], ["proof (state)\nthis:\n  (dra_to_drai A \\<Sigma>,\n   dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n  \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "then"], ["proof (chain)\npicking this:\n  (dra_to_drai A \\<Sigma>,\n   dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n  \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (dra_to_drai A \\<Sigma>,\n   dra (dra.alphabet A) (dra.initial A) (dra.transition A) (condition A))\n  \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "by simp"], ["proof (state)\nthis:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma draei_language_rel:\n  fixes\n    A :: \"('label, 'state :: hashable) dra\"\n  assumes\n    \"(\\<Sigma>, alphabet A) \\<in> \\<langle>Id\\<rangle> list_set_rel\"\n  and\n    \"finite (DRA.nodes A)\"\n  and\n    \"is_valid_def_hm_size TYPE('state) hms\"\n  shows\n    \"DRA.language (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) = DRA.language A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "have \"(dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "using dra_to_drai_rel assms"], ["proof (prove)\nusing this:\n  (?\\<Sigma>, dra.alphabet ?A)\n  \\<in> \\<langle>Id\\<rangle>list_set_rel \\<Longrightarrow>\n  (dra_to_drai ?A ?\\<Sigma>, ?A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n  (\\<Sigma>, dra.alphabet A) \\<in> \\<langle>Id\\<rangle>list_set_rel\n  finite (DRA.nodes A)\n  is_valid_def_hm_size TYPE('state) hms\n\ngoal (1 subgoal):\n 1. (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "by fast"], ["proof (state)\nthis:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "then"], ["proof (chain)\npicking this:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel", "have \"(drai_to_draei hms (dra_to_drai A \\<Sigma>), to_draei A) \\<in> \\<langle>Id_on (dra.alphabet A), rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat hms\\<rangle> draei_dra_rel\""], ["proof (prove)\nusing this:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (drai_to_draei hms (dra_to_drai A \\<Sigma>), to_draei A)\n    \\<in> \\<langle>Id_on (dra.alphabet A),\n    rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n     hms\\<rangle>draei_dra_rel", "unfolding drai_to_draei_def"], ["proof (prove)\nusing this:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl (=) bounded_hashcode_nat hms (dra_to_drai A \\<Sigma>),\n     to_draei A)\n    \\<in> \\<langle>Id_on (dra.alphabet A),\n    rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n     hms\\<rangle>draei_dra_rel", "using to_draei_impl_refine[unfolded autoref_tag_defs]"], ["proof (prove)\nusing this:\n  (dra_to_drai A \\<Sigma>, A) \\<in> \\<langle>Id, Id\\<rangle>drai_dra_rel\n  \\<lbrakk>finite (DRA.nodes ?A); is_bounded_hashcode ?S ?seq ?bhc;\n   is_valid_def_hm_size TYPE(?'statei) ?hms;\n   (?seq, (=)) \\<in> ?S \\<rightarrow> ?S \\<rightarrow> bool_rel;\n   (?Ai, ?A) \\<in> \\<langle>Id, ?S\\<rangle>drai_dra_rel\\<rbrakk>\n  \\<Longrightarrow> (to_draei_impl ?seq ?bhc ?hms ?Ai, to_draei ?A)\n                    \\<in> \\<langle>Id_on (dra.alphabet ?A),\n                    rel ?Ai ?A ?seq ?bhc ?hms\\<rangle>draei_dra_rel\n\ngoal (1 subgoal):\n 1. (to_draei_impl (=) bounded_hashcode_nat hms (dra_to_drai A \\<Sigma>),\n     to_draei A)\n    \\<in> \\<langle>Id_on (dra.alphabet A),\n    rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n     hms\\<rangle>draei_dra_rel", "by parametricity (simp_all add: assms is_bounded_hashcode_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  (drai_to_draei hms (dra_to_drai A \\<Sigma>), to_draei A)\n  \\<in> \\<langle>Id_on (dra.alphabet A),\n  rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n   hms\\<rangle>draei_dra_rel\n\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "then"], ["proof (chain)\npicking this:\n  (drai_to_draei hms (dra_to_drai A \\<Sigma>), to_draei A)\n  \\<in> \\<langle>Id_on (dra.alphabet A),\n  rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n   hms\\<rangle>draei_dra_rel", "have \"(DRA.language ((drae_dra \\<circ> draei_drae) (drai_to_draei hms (dra_to_drai A \\<Sigma>))), DRA.language (id (to_draei A))) \\<in> \\<langle>\\<langle>Id_on (dra.alphabet A)\\<rangle> stream_rel\\<rangle> set_rel\""], ["proof (prove)\nusing this:\n  (drai_to_draei hms (dra_to_drai A \\<Sigma>), to_draei A)\n  \\<in> \\<langle>Id_on (dra.alphabet A),\n  rel (dra_to_drai A \\<Sigma>) A (=) bounded_hashcode_nat\n   hms\\<rangle>draei_dra_rel\n\ngoal (1 subgoal):\n 1. (DRA.language\n      ((drae_dra \\<circ> draei_drae)\n        (drai_to_draei hms (dra_to_drai A \\<Sigma>))),\n     DRA.language (id (to_draei A)))\n    \\<in> \\<langle>\\<langle>Id_on\n                             (dra.alphabet\n                               A)\\<rangle>stream_rel\\<rangle>set_rel", "by parametricity"], ["proof (state)\nthis:\n  (DRA.language\n    ((drae_dra \\<circ> draei_drae)\n      (drai_to_draei hms (dra_to_drai A \\<Sigma>))),\n   DRA.language (id (to_draei A)))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (dra.alphabet\n                             A)\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "then"], ["proof (chain)\npicking this:\n  (DRA.language\n    ((drae_dra \\<circ> draei_drae)\n      (drai_to_draei hms (dra_to_drai A \\<Sigma>))),\n   DRA.language (id (to_draei A)))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (dra.alphabet\n                             A)\\<rangle>stream_rel\\<rangle>set_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (DRA.language\n    ((drae_dra \\<circ> draei_drae)\n      (drai_to_draei hms (dra_to_drai A \\<Sigma>))),\n   DRA.language (id (to_draei A)))\n  \\<in> \\<langle>\\<langle>Id_on\n                           (dra.alphabet\n                             A)\\<rangle>stream_rel\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. DRA.language\n     (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n    DRA.language A", "by (simp add: to_draei_def)"], ["proof (state)\nthis:\n  DRA.language\n   (drae_dra (draei_drae (drai_to_draei hms (dra_to_drai A \\<Sigma>)))) =\n  DRA.language A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Defining the Alphabet\\<close>"], ["", "fun atoms_ltlc_list :: \"'a ltlc \\<Rightarrow> 'a list\"\nwhere\n  \"atoms_ltlc_list true\\<^sub>c = []\"\n| \"atoms_ltlc_list false\\<^sub>c = []\"\n| \"atoms_ltlc_list prop\\<^sub>c(q) = [q]\"\n| \"atoms_ltlc_list (not\\<^sub>c \\<phi>) = atoms_ltlc_list \\<phi>\"\n| \"atoms_ltlc_list (\\<phi> and\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (\\<phi> or\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (\\<phi> implies\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (X\\<^sub>c \\<phi>) = atoms_ltlc_list \\<phi>\"\n| \"atoms_ltlc_list (F\\<^sub>c \\<phi>) = atoms_ltlc_list \\<phi>\"\n| \"atoms_ltlc_list (G\\<^sub>c \\<phi>) = atoms_ltlc_list \\<phi>\"\n| \"atoms_ltlc_list (\\<phi> U\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (\\<phi> R\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (\\<phi> W\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\"\n| \"atoms_ltlc_list (\\<phi> M\\<^sub>c \\<psi>) = List.union (atoms_ltlc_list \\<phi>) (atoms_ltlc_list \\<psi>)\""], ["", "lemma atoms_ltlc_list_set:\n  \"set (atoms_ltlc_list \\<phi>) = atoms_ltlc \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (atoms_ltlc_list \\<phi>) = atoms_ltlc \\<phi>", "by (induction \\<phi>) simp_all"], ["", "lemma atoms_ltlc_list_distinct:\n  \"distinct (atoms_ltlc_list \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (atoms_ltlc_list \\<phi>)", "by (induction \\<phi>) simp_all"], ["", "definition ltl_alphabet :: \"'a list \\<Rightarrow> 'a set list\"\nwhere\n  \"ltl_alphabet AP = map set (subseqs AP)\""], ["", "subsection \\<open>The Final Constant\\<close>"], ["", "text \\<open>\n  We require the quotient type to be hashable in order to efficiently explore the automaton.\n\\<close>"], ["", "locale dra_implementation = dra_construction_size _ _ _ Abs\n  for\n    Abs :: \"'a ltln \\<Rightarrow> 'ltlq :: hashable\"\nbegin"], ["", "definition ltln_to_draei :: \"'a list \\<Rightarrow> 'a ltln \\<Rightarrow> ('a set, nat) draei\"\nwhere\n  \"ltln_to_draei AP \\<phi> = drai_to_draei (Suc (size \\<phi>)) (dra_to_drai (ltl_to_dra_alphabet \\<phi> (set AP)) (ltl_alphabet AP))\""], ["", "definition ltlc_to_draei :: \"'a ltlc \\<Rightarrow> ('a set, nat) draei\"\nwhere\n  \"ltlc_to_draei \\<phi> = ltln_to_draei (atoms_ltlc_list \\<phi>) (simplify Slow (ltlc_to_ltln \\<phi>))\""], ["", "lemma ltl_to_dra_alphabet_rel:\n  \"distinct AP \\<Longrightarrow> (ltl_alphabet AP, alphabet (ltl_to_dra_alphabet \\<psi> (set AP))) \\<in> \\<langle>Id\\<rangle> list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct AP \\<Longrightarrow>\n    (ltl_alphabet AP, dra.alphabet (ltl_to_dra_alphabet \\<psi> (set AP)))\n    \\<in> \\<langle>Id\\<rangle>list_set_rel", "unfolding ltl_to_dra_alphabet_alphabet ltl_alphabet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct AP \\<Longrightarrow>\n    (map set (subseqs AP), Pow (set AP))\n    \\<in> \\<langle>Id\\<rangle>list_set_rel", "by (simp add: list_set_rel_def in_br_conv subseqs_powset distinct_set_subseqs)"], ["", "lemma ltlc_to_ltln_simplify_atoms:\n  \"atoms_ltln (simplify Slow (ltlc_to_ltln \\<phi>)) \\<subseteq> atoms_ltlc \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_ltln (simplify Slow (ltlc_to_ltln \\<phi>))\n    \\<subseteq> atoms_ltlc \\<phi>", "using ltlc_to_ltln_atoms simplify_atoms"], ["proof (prove)\nusing this:\n  atoms_ltln (ltlc_to_ltln ?\\<phi>) = atoms_ltlc ?\\<phi>\n  atoms_ltln (simplify ?m ?\\<phi>) \\<subseteq> atoms_ltln ?\\<phi>\n\ngoal (1 subgoal):\n 1. atoms_ltln (simplify Slow (ltlc_to_ltln \\<phi>))\n    \\<subseteq> atoms_ltlc \\<phi>", "by fast"], ["", "lemma valid_def_hm_size:\n  \"is_valid_def_hm_size TYPE('state) (Suc (size \\<phi>))\" for \\<phi> :: \"'a ltln\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_valid_def_hm_size TYPE('state) (Suc (size \\<phi>))", "unfolding is_valid_def_hm_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < Suc (size \\<phi>)", "using ltln.size_neq"], ["proof (prove)\nusing this:\n  size ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 < Suc (size \\<phi>)", "by auto"], ["", "theorem final_correctness:\n  \"to_omega ` language (drae_dra (draei_drae (ltlc_to_draei \\<phi>)))\n    = language_ltlc \\<phi> \\<inter> {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (drae_dra (draei_drae (ltlc_to_draei \\<phi>))) =\n    language_ltlc \\<phi> \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", "unfolding ltlc_to_draei_def ltln_to_draei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega `\n    DRA.language\n     (drae_dra\n       (draei_drae\n         (drai_to_draei (Suc (size (simplify Slow (ltlc_to_ltln \\<phi>))))\n           (dra_to_drai\n             (ltl_to_dra_alphabet (simplify Slow (ltlc_to_ltln \\<phi>))\n               (set (atoms_ltlc_list \\<phi>)))\n             (ltl_alphabet (atoms_ltlc_list \\<phi>)))))) =\n    language_ltlc \\<phi> \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", "unfolding draei_language_rel[OF ltl_to_dra_alphabet_rel[OF atoms_ltlc_list_distinct] ltl_to_dra_alphabet_nodes_finite valid_def_hm_size]"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega `\n    DRA.language\n     (ltl_to_dra_alphabet (simplify Slow (ltlc_to_ltln \\<phi>))\n       (set (atoms_ltlc_list \\<phi>))) =\n    language_ltlc \\<phi> \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", "unfolding atoms_ltlc_list_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega `\n    DRA.language\n     (ltl_to_dra_alphabet (simplify Slow (ltlc_to_ltln \\<phi>))\n       (atoms_ltlc \\<phi>)) =\n    language_ltlc \\<phi> \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", "unfolding ltl_to_dra_alphabet_language[OF ltlc_to_ltln_simplify_atoms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. language_ltln (simplify Slow (ltlc_to_ltln \\<phi>)) \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)} =\n    language_ltlc \\<phi> \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", "unfolding ltlc_to_ltln_atoms language_ltln_def language_ltlc_def ltlc_to_ltln_semantics simplify_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<xi>. \\<xi> \\<Turnstile>\\<^sub>c \\<phi>} \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)} =\n    {\\<xi>. \\<xi> \\<Turnstile>\\<^sub>c \\<phi>} \\<inter>\n    {w. range w \\<subseteq> Pow (atoms_ltlc \\<phi>)}", ".."], ["", "end"], ["", "end"]]}