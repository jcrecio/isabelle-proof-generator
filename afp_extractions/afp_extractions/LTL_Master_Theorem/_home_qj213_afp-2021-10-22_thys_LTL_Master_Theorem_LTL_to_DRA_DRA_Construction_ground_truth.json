{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem/LTL_to_DRA/DRA_Construction.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_Master_Theorem", "problem_names": ["lemma af_letter_lifted_semantics:\n  \"\\<up>afletter \\<nu> (Abs \\<phi>) = Abs (af_letter \\<phi> \\<nu>)\"", "lemma af_lifted_semantics:\n  \"\\<up>af (Abs \\<phi>) w = Abs (af \\<phi> w)\"", "lemma af_lifted_range:\n  \"range (\\<up>af (Abs \\<phi>)) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\"", "lemma af_letter\\<^sub>F_lifted_semantics:\n  \"\\<up>afletter\\<^sub>F \\<phi> \\<nu> (Abs \\<psi>) = Abs (af_letter\\<^sub>F \\<phi> \\<psi> \\<nu>)\"", "lemma af_letter\\<^sub>G_lifted_semantics:\n  \"\\<up>afletter\\<^sub>G \\<phi> \\<nu> (Abs \\<psi>) = Abs (af_letter\\<^sub>G \\<phi> \\<psi> \\<nu>)\"", "lemma af\\<^sub>F_lifted_semantics:\n  \"\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>F \\<phi> \\<psi> w)\"", "lemma af\\<^sub>G_lifted_semantics:\n  \"\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>G \\<phi> \\<psi> w)\"", "lemma af_letter\\<^sub>\\<nu>_lifted_semantics:\n  \"\\<up>afletter\\<^sub>\\<nu> X \\<nu> (Abs x, Abs y) = (Abs (fst (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)), Abs (snd (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)))\"", "lemma af\\<^sub>\\<nu>_lifted_semantics:\n  \"\\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) w = (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)), Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)))\"", "lemma dba_run:\n  \"DBA.run (dba UNIV p \\<delta> \\<alpha>) (to_stream w) p\"", "lemma dca_run:\n  \"DCA.run (dca UNIV p \\<delta> \\<alpha>) (to_stream w) p\"", "lemma \\<AA>\\<^sub>\\<mu>_language:\n  \"\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>\"", "lemma \\<AA>\\<^sub>\\<mu>_GF_language:\n  \"\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)\"", "lemma \\<AA>\\<^sub>\\<nu>_language:\n  \"\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>\"", "lemma \\<AA>\\<^sub>\\<nu>_FG_language:\n  \"\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)\"", "lemma \\<CC>_language:\n  \"to_stream w \\<in> DCA.language (\\<CC> \\<phi> X) \\<longleftrightarrow> (\\<exists>i. suffix i w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)\"", "lemma dba_language:\n  \"(\\<And>w. to_stream w \\<in> DBA.language \\<AA> \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow> DBA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}\"", "lemma dca_language:\n  \"(\\<And>w. to_stream w \\<in> DCA.language \\<AA> \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow> DCA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}\"", "lemma \\<AA>\\<^sub>1_language:\n  \"to_omega ` DCA.language (\\<AA>\\<^sub>1 \\<phi> xs) = L\\<^sub>1 \\<phi> (set xs)\"", "lemma \\<AA>\\<^sub>1_alphabet:\n  \"DCA.alphabet (\\<AA>\\<^sub>1 \\<phi> xs) = UNIV\"", "lemma \\<AA>\\<^sub>2_language:\n  \"to_omega ` DBA.language (\\<AA>\\<^sub>2 xs ys) = L\\<^sub>2 (set xs) (set ys)\"", "lemma \\<AA>\\<^sub>2_alphabet:\n  \"DBA.alphabet (\\<AA>\\<^sub>2 xs ys) = UNIV\"", "lemma \\<AA>\\<^sub>3_language:\n  \"to_omega ` DCA.language (\\<AA>\\<^sub>3 xs ys) = L\\<^sub>3 (set xs) (set ys)\"", "lemma \\<AA>\\<^sub>3_alphabet:\n  \"DCA.alphabet (\\<AA>\\<^sub>3 xs ys) = UNIV\"", "lemma \\<AA>'_language:\n  \"to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) = (L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter> L\\<^sub>3 (set xs) (set ys))\"", "lemma \\<AA>'_alphabet:\n  \"DRA.alphabet (\\<AA>' \\<phi> xs ys) = UNIV\"", "lemma ltl_to_dra_language:\n  \"to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>\"", "lemma ltl_to_dra_alphabet:\n  \"alphabet (ltl_to_dra \\<phi>) = UNIV\"", "lemma ltl_to_dra_restricted_language:\n  \"to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) = language_ltln \\<phi>\"", "lemma ltl_to_dra_restricted_alphabet:\n  \"alphabet (ltl_to_dra_restricted \\<phi>) = UNIV\"", "lemma dra_set_alphabet_language:\n  \"\\<Sigma> \\<subseteq> alphabet \\<AA> \\<Longrightarrow> language (dra_set_alphabet \\<AA> \\<Sigma>) = language \\<AA> \\<inter> {s. sset s \\<subseteq> \\<Sigma>}\"", "lemma dra_set_alphabet_alphabet[simp]:\n  \"alphabet (dra_set_alphabet \\<AA> \\<Sigma>) = \\<Sigma>\"", "lemma dra_set_alphabet_nodes:\n  \"\\<Sigma> \\<subseteq> alphabet \\<AA> \\<Longrightarrow> DRA.nodes (dra_set_alphabet \\<AA> \\<Sigma>) \\<subseteq> DRA.nodes \\<AA>\"", "lemma ltl_to_dra_alphabet_language:\n  assumes\n    \"atoms_ltln \\<phi> \\<subseteq> Ap\"\n  shows\n    \"to_omega ` language (ltl_to_dra_alphabet \\<phi> Ap) = language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}\"", "lemma ltl_to_dra_alphabet_alphabet[simp]:\n  \"alphabet (ltl_to_dra_alphabet \\<phi> Ap) = Pow Ap\"", "lemma ltl_to_dra_alphabet_nodes:\n  \"DRA.nodes (ltl_to_dra_alphabet \\<phi> Ap) \\<subseteq> DRA.nodes (ltl_to_dra_restricted \\<phi>)\"", "lemma list_prod_mono:\n  \"f \\<le> g \\<Longrightarrow> (\\<Prod>x\\<leftarrow>xs. f x) \\<le> (\\<Prod>x\\<leftarrow>xs. g x)\" for f g :: \"'a \\<Rightarrow> nat\"", "lemma list_prod_const:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> f x \\<le> c) \\<Longrightarrow> (\\<Prod>x\\<leftarrow>xs. f x) \\<le> c ^ length xs\" for f :: \"'a \\<Rightarrow> nat\"", "lemma card_insert_Suc:\n  \"card (insert x S) \\<le> Suc (card S)\"", "lemma nat_power_le_imp_le:\n  \"0 < a \\<Longrightarrow> a \\<le> b \\<Longrightarrow> x ^ a \\<le> x ^ b\" for x :: nat", "lemma const_less_power:\n  \"n < x ^ n\" if \"x > 1\"", "lemma floorlog_le_const:\n  \"floorlog x n \\<le> n\"", "lemma af\\<^sub>F_lifted_range:\n  \"nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>) \\<Longrightarrow> range (\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>)) \\<subseteq>  {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}\"", "lemma af\\<^sub>G_lifted_range:\n  \"nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>) \\<Longrightarrow> range (\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>)) \\<subseteq>  {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}\"", "lemma \\<AA>\\<^sub>\\<mu>_nodes:\n  \"DBA.nodes (\\<AA>\\<^sub>\\<mu> \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\"", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes:\n  \"DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}\"", "lemma \\<AA>\\<^sub>\\<nu>_nodes:\n  \"DCA.nodes (\\<AA>\\<^sub>\\<nu> \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\"", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes:\n  \"DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}\"", "lemma \\<CC>_nodes_normalise:\n  \"DCA.nodes (\\<CC> \\<phi> X) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> (normalise \\<phi>) X}\"", "lemma \\<CC>_nodes:\n  \"DCA.nodes (\\<CC> \\<phi> X) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\"", "lemma equiv_subset:\n  \"{Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P} \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> P}\"", "lemma equiv_finite':\n  \"finite P \\<Longrightarrow> finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}\"", "lemma equiv_card':\n  \"finite P \\<Longrightarrow> card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P} \\<le> 2 ^ 2 ^ card P\"", "lemma nested_prop_atoms_finite:\n  \"finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\"", "lemma nested_prop_atoms_card:\n  \"card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\"", "lemma nested_prop_atoms\\<^sub>\\<nu>_finite:\n  \"finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\"", "lemma nested_prop_atoms\\<^sub>\\<nu>_card:\n  \"card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X} \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\" (is \"?lhs \\<le> ?rhs\")", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes_finite:\n  \"finite (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\"", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\"", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes_card:\n  \"card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) \\<le> 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n \\<phi>))\"", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes_card:\n  \"card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) \\<le> 2 ^ 2 ^ card (nested_prop_atoms (G\\<^sub>n \\<phi>))\"", "lemma \\<AA>\\<^sub>2_nodes_finite_helper:\n  \"list_all (finite \\<circ> DBA.nodes) (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>)) xs)\"", "lemma \\<AA>\\<^sub>2_nodes_finite:\n  \"finite (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\"", "lemma \\<AA>\\<^sub>3_nodes_finite_helper:\n  \"list_all (finite \\<circ> DCA.nodes) (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)) ys)\"", "lemma \\<AA>\\<^sub>3_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\"", "lemma \\<AA>\\<^sub>2_nodes_card:\n  assumes\n    \"length xs \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set xs \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  shows\n    \"card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\"", "lemma \\<AA>\\<^sub>3_nodes_card:\n  assumes\n    \"length ys \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set ys \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  shows\n    \"card (DCA.nodes (\\<AA>\\<^sub>3 xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)\"", "lemma \\<AA>\\<^sub>1_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))\"", "lemma \\<AA>\\<^sub>1_nodes_card:\n  assumes\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)\"", "lemma \\<AA>'_nodes_finite:\n  \"finite (DRA.nodes (\\<AA>' \\<phi> xs ys))\"", "lemma \\<AA>'_nodes_card:\n  assumes\n    \"length xs \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set xs \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  and\n    \"length ys \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set ys \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  and\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DRA.nodes (\\<AA>' \\<phi> xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)\"", "lemma subformula_nested_prop_atoms_subfrmlsn:\n  \"\\<psi> \\<in> subfrmlsn \\<phi> \\<Longrightarrow> nested_prop_atoms \\<psi> \\<subseteq> subfrmlsn \\<phi>\"", "lemma ltl_to_dra_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra \\<phi>))\"", "lemma ltl_to_dra_restricted_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra_restricted \\<phi>))\"", "lemma ltl_to_dra_alphabet_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra_alphabet \\<phi> AP))\"", "lemma ltl_to_dra_nodes_card:\n  assumes\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DRA.nodes (ltl_to_dra \\<phi>)) \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\"", "theorem ltl_to_dra_size:\n  \"card (DRA.nodes (ltl_to_dra \\<phi>)) \\<le> 2 ^ 2 ^ (2 * size \\<phi> + floorlog 2 (size \\<phi>) + 4)\""], "translations": [["", "lemma af_letter_lifted_semantics:\n  \"\\<up>afletter \\<nu> (Abs \\<phi>) = Abs (af_letter \\<phi> \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>afletter \\<nu> (Abs \\<phi>) = Abs (af_letter \\<phi> \\<nu>)", "by (metis Rep_Abs_eq af_letter_congruent Abs_eq)"], ["", "lemma af_lifted_semantics:\n  \"\\<up>af (Abs \\<phi>) w = Abs (af \\<phi> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>af (Abs \\<phi>) w = Abs (af \\<phi> w)", "by (induction w rule: rev_induct) (auto simp: Abs_eq, insert Rep_Abs_eq af_letter_congruent eq_sym, blast)"], ["", "lemma af_lifted_range:\n  \"range (\\<up>af (Abs \\<phi>)) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<up>af (Abs \\<phi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "using af_lifted_semantics af_nested_prop_atoms"], ["proof (prove)\nusing this:\n  \\<up>af (Abs ?\\<phi>) ?w = Abs (af ?\\<phi> ?w)\n  nested_prop_atoms (af ?\\<phi> ?w) \\<subseteq> nested_prop_atoms ?\\<phi>\n\ngoal (1 subgoal):\n 1. range (\\<up>af (Abs \\<phi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "by blast"], ["", "definition af_letter\\<^sub>F_lifted :: \"'a ltln \\<Rightarrow> 'a set \\<Rightarrow> 'ltlq \\<Rightarrow> 'ltlq\" (\"\\<up>afletter\\<^sub>F\")\nwhere\n  \"\\<up>afletter\\<^sub>F \\<phi> \\<nu> \\<psi> \\<equiv> Abs (af_letter\\<^sub>F \\<phi> (Rep \\<psi>) \\<nu>)\""], ["", "definition af_letter\\<^sub>G_lifted :: \"'a ltln \\<Rightarrow> 'a set \\<Rightarrow> 'ltlq \\<Rightarrow> 'ltlq\" (\"\\<up>afletter\\<^sub>G\")\nwhere\n  \"\\<up>afletter\\<^sub>G \\<phi> \\<nu> \\<psi> \\<equiv> Abs (af_letter\\<^sub>G \\<phi> (Rep \\<psi>) \\<nu>)\""], ["", "lemma af_letter\\<^sub>F_lifted_semantics:\n  \"\\<up>afletter\\<^sub>F \\<phi> \\<nu> (Abs \\<psi>) = Abs (af_letter\\<^sub>F \\<phi> \\<psi> \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>afletter\\<^sub>F \\<phi> \\<nu> (Abs \\<psi>) =\n    Abs (af_letter\\<^sub>F \\<phi> \\<psi> \\<nu>)", "by (metis af_letter\\<^sub>F_lifted_def Rep_inverse af_letter\\<^sub>F_def af_letter_congruent Abs_eq)"], ["", "lemma af_letter\\<^sub>G_lifted_semantics:\n  \"\\<up>afletter\\<^sub>G \\<phi> \\<nu> (Abs \\<psi>) = Abs (af_letter\\<^sub>G \\<phi> \\<psi> \\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>afletter\\<^sub>G \\<phi> \\<nu> (Abs \\<psi>) =\n    Abs (af_letter\\<^sub>G \\<phi> \\<psi> \\<nu>)", "by (metis af_letter\\<^sub>G_lifted_def Rep_inverse af_letter\\<^sub>G_def af_letter_congruent Abs_eq)"], ["", "abbreviation af\\<^sub>F_lifted :: \"'a ltln \\<Rightarrow> 'ltlq \\<Rightarrow> 'a set list \\<Rightarrow> 'ltlq\" (\"\\<up>af\\<^sub>F\")\nwhere\n  \"\\<up>af\\<^sub>F \\<phi> \\<psi> w \\<equiv> fold (\\<up>afletter\\<^sub>F \\<phi>) w \\<psi>\""], ["", "abbreviation af\\<^sub>G_lifted :: \"'a ltln \\<Rightarrow> 'ltlq \\<Rightarrow> 'a set list \\<Rightarrow> 'ltlq\" (\"\\<up>af\\<^sub>G\")\nwhere\n  \"\\<up>af\\<^sub>G \\<phi> \\<psi> w \\<equiv> fold (\\<up>afletter\\<^sub>G \\<phi>) w \\<psi>\""], ["", "lemma af\\<^sub>F_lifted_semantics:\n  \"\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>F \\<phi> \\<psi> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>af\\<^sub>F \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>F \\<phi> \\<psi> w)", "by (induction w rule: rev_induct) (auto simp: af_letter\\<^sub>F_lifted_semantics)"], ["", "lemma af\\<^sub>G_lifted_semantics:\n  \"\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>G \\<phi> \\<psi> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>af\\<^sub>G \\<phi> (Abs \\<psi>) w = Abs (af\\<^sub>G \\<phi> \\<psi> w)", "by (induction w rule: rev_induct) (auto simp: af_letter\\<^sub>G_lifted_semantics)"], ["", "definition af_letter\\<^sub>\\<nu>_lifted :: \"'a ltln set \\<Rightarrow> 'a set \\<Rightarrow> 'ltlq \\<times> 'ltlq \\<Rightarrow> 'ltlq \\<times> 'ltlq\" (\"\\<up>afletter\\<^sub>\\<nu>\")\nwhere\n  \"\\<up>afletter\\<^sub>\\<nu> X \\<nu> p \\<equiv>\n    (Abs (fst (af_letter\\<^sub>\\<nu> X (Rep (fst p), Rep (snd p)) \\<nu>)),\n     Abs (snd (af_letter\\<^sub>\\<nu> X (Rep (fst p), Rep (snd p)) \\<nu>)))\""], ["", "abbreviation af\\<^sub>\\<nu>_lifted :: \"'a ltln set \\<Rightarrow> 'ltlq \\<times> 'ltlq \\<Rightarrow> 'a set list \\<Rightarrow> 'ltlq \\<times> 'ltlq\" (\"\\<up>af\\<^sub>\\<nu>\")\nwhere\n  \"\\<up>af\\<^sub>\\<nu> X p w \\<equiv> fold (\\<up>afletter\\<^sub>\\<nu> X) w p\""], ["", "lemma af_letter\\<^sub>\\<nu>_lifted_semantics:\n  \"\\<up>afletter\\<^sub>\\<nu> X \\<nu> (Abs x, Abs y) = (Abs (fst (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)), Abs (snd (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>afletter\\<^sub>\\<nu> X \\<nu> (Abs x, Abs y) =\n    (Abs (fst (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)),\n     Abs (snd (af_letter\\<^sub>\\<nu> X (x, y) \\<nu>)))", "by (simp add: af_letter\\<^sub>\\<nu>_def af_letter\\<^sub>\\<nu>_lifted_def) (insert GF_advice_congruent Rep_Abs_eq Rep_inverse af_letter_lifted_semantics eq_trans Abs_eq, blast)"], ["", "lemma af\\<^sub>\\<nu>_lifted_semantics:\n  \"\\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) w = (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)), Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) w =\n    (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)),\n     Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) w)))", "apply (induction w rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) [] =\n    (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) [])),\n     Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) [])))\n 2. \\<And>x xs.\n       \\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) xs =\n       (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs)),\n        Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs))) \\<Longrightarrow>\n       \\<up>af\\<^sub>\\<nu> X (Abs \\<xi>, Abs \\<zeta>) (xs @ [x]) =\n       (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) (xs @ [x]))),\n        Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) (xs @ [x]))))", "apply (auto simp: af_letter\\<^sub>\\<nu>_lifted_def af_letter\\<^sub>\\<nu>_lifted_semantics af_letter_lifted_semantics)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fold\n        (\\<lambda>a b.\n            (\\<up>afletter a (fst b),\n             Abs (snd (af_letter\\<^sub>\\<nu> X (Rep (fst b), Rep (snd b))\n                        a))))\n        xs (Abs \\<xi>, Abs \\<zeta>) =\n       (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs)),\n        Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs))) \\<Longrightarrow>\n       Abs (snd (af_letter\\<^sub>\\<nu> X\n                  (Rep (Abs (fst (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs))),\n                   Rep (Abs (snd (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs))))\n                  x)) =\n       Abs (snd (af_letter\\<^sub>\\<nu> X\n                  (af\\<^sub>\\<nu> X (\\<xi>, \\<zeta>) xs) x))", "by (metis (no_types, hide_lams) af_letter\\<^sub>\\<nu>_lifted_def af\\<^sub>\\<nu>_fst af_letter\\<^sub>\\<nu>_lifted_semantics eq_fst_iff prod.sel(2))"], ["", "subsection \\<open>B?chi automata for basic languages\\<close>"], ["", "definition \\<AA>\\<^sub>\\<mu> :: \"'a ltln \\<Rightarrow> ('a set, 'ltlq) dba\" where\n  \"\\<AA>\\<^sub>\\<mu> \\<phi> = dba UNIV (Abs \\<phi>) \\<up>afletter (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\""], ["", "definition \\<AA>\\<^sub>\\<mu>_GF :: \"'a ltln \\<Rightarrow> ('a set, 'ltlq) dba\" where\n  \"\\<AA>\\<^sub>\\<mu>_GF \\<phi> = dba UNIV (Abs (F\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>F \\<phi>) (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\""], ["", "definition \\<AA>\\<^sub>\\<nu> :: \"'a ltln \\<Rightarrow> ('a set, 'ltlq) dca\" where\n  \"\\<AA>\\<^sub>\\<nu> \\<phi> = dca UNIV (Abs \\<phi>) \\<up>afletter (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\""], ["", "definition \\<AA>\\<^sub>\\<nu>_FG :: \"'a ltln \\<Rightarrow> ('a set, 'ltlq) dca\" where\n  \"\\<AA>\\<^sub>\\<nu>_FG \\<phi> = dca UNIV (Abs (G\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>G \\<phi>) (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\""], ["", "lemma dba_run:\n  \"DBA.run (dba UNIV p \\<delta> \\<alpha>) (to_stream w) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.run (dba UNIV p \\<delta> \\<alpha>) (to_stream w) p", "unfolding dba.run_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_stream w \\<in> streams (dba.alphabet (dba UNIV p \\<delta> \\<alpha>))", "by simp"], ["", "lemma dca_run:\n  \"DCA.run (dca UNIV p \\<delta> \\<alpha>) (to_stream w) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.run (dca UNIV p \\<delta> \\<alpha>) (to_stream w) p", "unfolding dca.run_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_stream w \\<in> streams (dca.alphabet (dca UNIV p \\<delta> \\<alpha>))", "by simp"], ["", "lemma \\<AA>\\<^sub>\\<mu>_language:\n  \"\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "assume \"\\<phi> \\<in> \\<mu>LTL\""], ["proof (state)\nthis:\n  \\<phi> \\<in> \\<mu>LTL\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "then"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> \\<mu>LTL", "have \"w \\<Turnstile>\\<^sub>n \\<phi> \\<longleftrightarrow> (\\<forall>n. \\<exists>k\\<ge>n. af \\<phi> (w[0 \\<rightarrow> k]) \\<sim> true\\<^sub>n)\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<mu>LTL\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n \\<phi> =\n    (\\<forall>n.\n        \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n)", "by (meson af_\\<mu>LTL af_prefix_true le_cases)"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (\\<forall>n. \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (\\<forall>n. \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>n. \\<exists>k\\<ge>n. af \\<phi> (w[0 \\<rightarrow> Suc k]) \\<sim> true\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n) =\n    (\\<forall>n.\n        \\<exists>k\\<ge>n. af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n)", "by (meson af_prefix_true le_SucI order_refl)"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix k w) \\<sim> true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n) (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k\\<ge>n.\n           af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n) =\n    infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>))", "by (simp add: infs_snth \\<AA>\\<^sub>\\<mu>_def DBA.transition_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n) =\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n. af \\<phi> (prefix (Suc k) w) \\<sim> true\\<^sub>n) =\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>)) =\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>))", "unfolding \\<AA>\\<^sub>\\<mu>_def dba.initial_def dba.accepting_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace\n       (dba UNIV (Abs \\<phi>) \\<up>afletter\n         (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n       (to_stream w) (Abs \\<phi>)) =\n    (to_stream w\n     \\<in> DBA.language\n            (dba UNIV (Abs \\<phi>) \\<up>afletter\n              (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)))", "by (auto simp: dba_run)"], ["proof (state)\nthis:\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu> \\<phi>) (to_stream w) (Abs \\<phi>)) =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>))", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "by simp"], ["proof (state)\nthis:\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu> \\<phi>)) =\n  w \\<Turnstile>\\<^sub>n \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>\\<mu>_GF_language:\n  \"\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "assume \"\\<phi> \\<in> \\<mu>LTL\""], ["proof (state)\nthis:\n  \\<phi> \\<in> \\<mu>LTL\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "then"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> \\<mu>LTL", "have \"w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) \\<longleftrightarrow> (\\<forall>n. \\<exists>k. af (F\\<^sub>n \\<phi>) (w[n \\<rightarrow> k]) \\<sim>\\<^sub>L true\\<^sub>n)\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<mu>LTL\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n    (\\<forall>n.\n        \\<exists>k.\n           af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n           true\\<^sub>n)", "using ltl_lang_equivalence.af_\\<mu>LTL_GF"], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<mu>LTL\n  ?\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n  ?w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n ?\\<phi>) =\n  (\\<forall>i.\n      \\<exists>j.\n         af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n    (\\<forall>n.\n        \\<exists>k.\n           af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n           true\\<^sub>n)", "by blast"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n  (\\<forall>n.\n      \\<exists>k.\n         af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n  (\\<forall>n.\n      \\<exists>k.\n         af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>n. \\<exists>k>n. af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (w[0 \\<rightarrow> k]) \\<sim> true\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k.\n           af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n           true\\<^sub>n) =\n    (\\<forall>n.\n        \\<exists>k>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n           true\\<^sub>n)", "using af\\<^sub>F_semantics_ltr af\\<^sub>F_semantics_rtl"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>j.\n        af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n        true\\<^sub>n \\<Longrightarrow>\n  \\<forall>i.\n     \\<exists>j>i.\n        af\\<^sub>F ?\\<phi> (F\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n        true\\<^sub>n\n  \\<forall>i.\n     \\<exists>j>i.\n        af\\<^sub>F ?\\<phi> (F\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n        true\\<^sub>n \\<Longrightarrow>\n  \\<forall>i.\n     \\<exists>j.\n        af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n        true\\<^sub>n\n\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k.\n           af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n           true\\<^sub>n) =\n    (\\<forall>n.\n        \\<exists>k>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n           true\\<^sub>n)", "using \\<open>\\<phi> \\<in> \\<mu>LTL\\<close> af_\\<mu>LTL_GF calculation"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>j.\n        af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n        true\\<^sub>n \\<Longrightarrow>\n  \\<forall>i.\n     \\<exists>j>i.\n        af\\<^sub>F ?\\<phi> (F\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n        true\\<^sub>n\n  \\<forall>i.\n     \\<exists>j>i.\n        af\\<^sub>F ?\\<phi> (F\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n        true\\<^sub>n \\<Longrightarrow>\n  \\<forall>i.\n     \\<exists>j.\n        af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n        true\\<^sub>n\n  \\<phi> \\<in> \\<mu>LTL\n  ?\\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n  ?w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n ?\\<phi>) =\n  (\\<forall>i.\n      \\<exists>j.\n         af (F\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n         true\\<^sub>n)\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n  (\\<forall>n.\n      \\<exists>k.\n         af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k.\n           af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n           true\\<^sub>n) =\n    (\\<forall>n.\n        \\<exists>k>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n           true\\<^sub>n)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k.\n         af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n         true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k.\n         af (F\\<^sub>n \\<phi>) (w [n \\<rightarrow> k]) \\<sim>\\<^sub>L\n         true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>n. \\<exists>k\\<ge>n. af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (w[0 \\<rightarrow> Suc k]) \\<sim> true\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n           true\\<^sub>n) =\n    (\\<forall>n.\n        \\<exists>k\\<ge>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n           true\\<^sub>n)", "by (metis less_Suc_eq_le less_imp_Suc_add)"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n         true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k\\<ge>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n         true\\<^sub>n) =\n  (\\<forall>n.\n      \\<exists>k\\<ge>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n         true\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n) (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w) (Abs (F\\<^sub>n \\<phi>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        \\<exists>k\\<ge>n.\n           af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n           true\\<^sub>n) =\n    infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w)\n       (Abs (F\\<^sub>n \\<phi>)))", "by (simp add: infs_snth \\<AA>\\<^sub>\\<mu>_GF_def DBA.transition_def af\\<^sub>F_lifted_semantics Abs_eq[symmetric] af_letter\\<^sub>F_lifted_semantics)"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n         true\\<^sub>n) =\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w)\n     (Abs (F\\<^sub>n \\<phi>)))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<forall>n.\n      \\<exists>k\\<ge>n.\n         af\\<^sub>F \\<phi> (F\\<^sub>n \\<phi>) (prefix (Suc k) w) \\<sim>\n         true\\<^sub>n) =\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w)\n     (Abs (F\\<^sub>n \\<phi>)))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w)\n       (Abs (F\\<^sub>n \\<phi>))) =\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))", "unfolding \\<AA>\\<^sub>\\<mu>_GF_def dba.initial_def dba.accepting_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n     (DBA.trace\n       (dba UNIV (Abs (F\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>F \\<phi>)\n         (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n       (to_stream w) (Abs (F\\<^sub>n \\<phi>))) =\n    (to_stream w\n     \\<in> DBA.language\n            (dba UNIV (Abs (F\\<^sub>n \\<phi>))\n              (\\<up>afletter\\<^sub>F \\<phi>)\n              (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)))", "by (auto simp: dba_run)"], ["proof (state)\nthis:\n  infs (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n)\n   (DBA.trace (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) (to_stream w)\n     (Abs (F\\<^sub>n \\<phi>))) =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<mu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>) =\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)", "by simp"], ["proof (state)\nthis:\n  (to_stream w \\<in> DBA.language (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) =\n  w \\<Turnstile>\\<^sub>n G\\<^sub>n (F\\<^sub>n \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>\\<nu>_language:\n  \"\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "assume \"\\<phi> \\<in> \\<nu>LTL\""], ["proof (state)\nthis:\n  \\<phi> \\<in> \\<nu>LTL\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "then"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> \\<nu>LTL", "have \"w \\<Turnstile>\\<^sub>n \\<phi> \\<longleftrightarrow> (\\<exists>n. \\<forall>k\\<ge>n. \\<not> af \\<phi> (w[0 \\<rightarrow> k]) \\<sim> false\\<^sub>n)\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<nu>LTL\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n \\<phi> =\n    (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n)", "by (meson af_\\<nu>LTL af_prefix_false le_cases order_refl)"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n. \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n. \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>n. \\<forall>k\\<ge>n. \\<not> af \\<phi> (w[0 \\<rightarrow> Suc k]) \\<sim> false\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n) =\n    (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n)", "by (meson af_prefix_false le_SucI order_refl)"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix k w) \\<sim> false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n) (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n) =\n    fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>))", "by (simp add: infs_snth \\<AA>\\<^sub>\\<nu>_def DBA.transition_def af_lifted_semantics Abs_eq[symmetric] af_letter_lifted_semantics)"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n) =\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "also"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af \\<phi> (prefix (Suc k) w) \\<sim> false\\<^sub>n) =\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "have \"\\<dots> \\<longleftrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>)) =\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>))", "unfolding \\<AA>\\<^sub>\\<nu>_def dca.initial_def dca.rejecting_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace\n       (dca UNIV (Abs \\<phi>) \\<up>afletter\n         (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n       (to_stream w) (Abs \\<phi>)) =\n    (to_stream w\n     \\<in> DCA.language\n            (dca UNIV (Abs \\<phi>) \\<up>afletter\n              (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)))", "by (auto simp: dca_run)"], ["proof (state)\nthis:\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu> \\<phi>) (to_stream w) (Abs \\<phi>)) =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>))", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile>\\<^sub>n \\<phi> =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n \\<phi>", "by simp"], ["proof (state)\nthis:\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu> \\<phi>)) =\n  w \\<Turnstile>\\<^sub>n \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>\\<nu>_FG_language:\n  \"\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "assume \"\\<phi> \\<in> \\<nu>LTL\""], ["proof (state)\nthis:\n  \\<phi> \\<in> \\<nu>LTL\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "then"], ["proof (chain)\npicking this:\n  \\<phi> \\<in> \\<nu>LTL", "have \"w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) \\<longleftrightarrow> (\\<exists>k. \\<forall>j. \\<not> af (G\\<^sub>n \\<phi>) (w[k \\<rightarrow> j]) \\<sim>\\<^sub>L false\\<^sub>n)\""], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<nu>LTL\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n    (\\<exists>k.\n        \\<forall>j.\n           \\<not> af (G\\<^sub>n \\<phi>)\n                   (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                  false\\<^sub>n)", "using ltl_lang_equivalence.af_\\<nu>LTL_FG"], ["proof (prove)\nusing this:\n  \\<phi> \\<in> \\<nu>LTL\n  ?\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n  ?w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n ?\\<phi>) =\n  (\\<exists>i.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n ?\\<phi>)\n                 (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n    (\\<exists>k.\n        \\<forall>j.\n           \\<not> af (G\\<^sub>n \\<phi>)\n                   (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                  false\\<^sub>n)", "by blast"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n  (\\<exists>k.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n \\<phi>) (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n  (\\<exists>k.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n \\<phi>) (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>n. \\<forall>k>n. \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (w[0 \\<rightarrow> k]) \\<sim> false\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>k.\n        \\<forall>j.\n           \\<not> af (G\\<^sub>n \\<phi>)\n                   (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                  false\\<^sub>n) =\n    (\\<exists>n.\n        \\<forall>k>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                  false\\<^sub>n)", "using af\\<^sub>G_semantics_ltr af\\<^sub>G_semantics_rtl"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     \\<forall>j.\n        \\<not> af (G\\<^sub>n ?\\<phi>)\n                (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n               false\\<^sub>n \\<Longrightarrow>\n  \\<exists>i.\n     \\<forall>j>i.\n        \\<not> af\\<^sub>G ?\\<phi> (G\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n               false\\<^sub>n\n  \\<exists>i.\n     \\<forall>j>i.\n        \\<not> af\\<^sub>G ?\\<phi> (G\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n               false\\<^sub>n \\<Longrightarrow>\n  \\<exists>i.\n     \\<forall>j.\n        \\<not> af (G\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n               false\\<^sub>n\n\ngoal (1 subgoal):\n 1. (\\<exists>k.\n        \\<forall>j.\n           \\<not> af (G\\<^sub>n \\<phi>)\n                   (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                  false\\<^sub>n) =\n    (\\<exists>n.\n        \\<forall>k>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                  false\\<^sub>n)", "using \\<open>\\<phi> \\<in> \\<nu>LTL\\<close> af_\\<nu>LTL_FG calculation"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     \\<forall>j.\n        \\<not> af (G\\<^sub>n ?\\<phi>)\n                (?w [i \\<rightarrow> j]) \\<sim>\\<^sub>L\n               false\\<^sub>n \\<Longrightarrow>\n  \\<exists>i.\n     \\<forall>j>i.\n        \\<not> af\\<^sub>G ?\\<phi> (G\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n               false\\<^sub>n\n  \\<exists>i.\n     \\<forall>j>i.\n        \\<not> af\\<^sub>G ?\\<phi> (G\\<^sub>n ?\\<phi>) (prefix j ?w) \\<sim>\n               false\\<^sub>n \\<Longrightarrow>\n  \\<exists>i.\n     \\<forall>j.\n        \\<not> af (G\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n               false\\<^sub>n\n  \\<phi> \\<in> \\<nu>LTL\n  ?\\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n  ?w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n ?\\<phi>) =\n  (\\<exists>i.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n ?\\<phi>) (?w [i \\<rightarrow> j]) \\<sim>\n                false\\<^sub>n)\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n  (\\<exists>k.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n \\<phi>) (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. (\\<exists>k.\n        \\<forall>j.\n           \\<not> af (G\\<^sub>n \\<phi>)\n                   (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                  false\\<^sub>n) =\n    (\\<exists>n.\n        \\<forall>k>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                  false\\<^sub>n)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>k.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n \\<phi>) (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<exists>k.\n      \\<forall>j.\n         \\<not> af (G\\<^sub>n \\<phi>) (w [k \\<rightarrow> j]) \\<sim>\\<^sub>L\n                false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>n. \\<forall>k\\<ge>n. \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (w[0 \\<rightarrow> Suc k]) \\<sim> false\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n.\n        \\<forall>k>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                  false\\<^sub>n) =\n    (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                   (prefix (Suc k) w) \\<sim>\n                  false\\<^sub>n)", "by (metis less_Suc_eq_le less_imp_Suc_add)"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                 (prefix (Suc k) w) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>) (prefix k w) \\<sim>\n                false\\<^sub>n) =\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                 (prefix (Suc k) w) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n) (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w) (Abs (G\\<^sub>n \\<phi>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n.\n        \\<forall>k\\<ge>n.\n           \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                   (prefix (Suc k) w) \\<sim>\n                  false\\<^sub>n) =\n    fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w)\n       (Abs (G\\<^sub>n \\<phi>)))", "by (simp add: infs_snth \\<AA>\\<^sub>\\<nu>_FG_def DBA.transition_def af\\<^sub>G_lifted_semantics Abs_eq[symmetric] af_letter\\<^sub>G_lifted_semantics)"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                 (prefix (Suc k) w) \\<sim>\n                false\\<^sub>n) =\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w)\n     (Abs (G\\<^sub>n \\<phi>)))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "also"], ["proof (state)\nthis:\n  (\\<exists>n.\n      \\<forall>k\\<ge>n.\n         \\<not> af\\<^sub>G \\<phi> (G\\<^sub>n \\<phi>)\n                 (prefix (Suc k) w) \\<sim>\n                false\\<^sub>n) =\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w)\n     (Abs (G\\<^sub>n \\<phi>)))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "have \"\\<dots> \\<longleftrightarrow> to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w)\n       (Abs (G\\<^sub>n \\<phi>))) =\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))", "unfolding \\<AA>\\<^sub>\\<nu>_FG_def dca.initial_def dca.rejecting_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n     (DCA.trace\n       (dca UNIV (Abs (G\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>G \\<phi>)\n         (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n       (to_stream w) (Abs (G\\<^sub>n \\<phi>))) =\n    (to_stream w\n     \\<in> DCA.language\n            (dca UNIV (Abs (G\\<^sub>n \\<phi>))\n              (\\<up>afletter\\<^sub>G \\<phi>)\n              (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)))", "by (auto simp: dca_run)"], ["proof (state)\nthis:\n  fins (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) (to_stream w)\n     (Abs (G\\<^sub>n \\<phi>))) =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<nu>LTL \\<Longrightarrow>\n    (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>) =\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n    w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)", "by simp"], ["proof (state)\nthis:\n  (to_stream w \\<in> DCA.language (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) =\n  w \\<Turnstile>\\<^sub>n F\\<^sub>n (G\\<^sub>n \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>A DCA checking the GF-advice Function\\<close>"], ["", "definition \\<CC> :: \"'a ltln \\<Rightarrow> 'a ltln set \\<Rightarrow> ('a set, 'ltlq \\<times> 'ltlq) dca\" where\n  \"\\<CC> \\<phi> X = dca UNIV (Abs \\<phi>, Abs ((normalise \\<phi>)[X]\\<^sub>\\<nu>)) (\\<up>afletter\\<^sub>\\<nu> X) (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\""], ["", "lemma \\<CC>_language:\n  \"to_stream w \\<in> DCA.language (\\<CC> \\<phi> X) \\<longleftrightarrow> (\\<exists>i. suffix i w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "have \"(\\<exists>i. suffix i w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)\n        \\<longleftrightarrow> (\\<exists>m. \\<forall>k\\<ge>m. \\<not> snd (af\\<^sub>\\<nu> X (\\<phi>, (normalise \\<phi>)[X]\\<^sub>\\<nu>) (prefix (Suc k) w)) \\<sim> false\\<^sub>n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n    (\\<exists>m.\n        \\<forall>k\\<ge>m.\n           \\<not> snd (af\\<^sub>\\<nu> X\n                        (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                        (prefix (Suc k) w)) \\<sim>\n                  false\\<^sub>n)", "using af\\<^sub>\\<nu>_semantics_ltr af\\<^sub>\\<nu>_semantics_rtl"], ["proof (prove)\nusing this:\n  \\<exists>i.\n     suffix i\n      ?w \\<Turnstile>\\<^sub>n af ?\\<phi>\n                               (prefix i\n                                 ?w)[?X]\\<^sub>\\<nu> \\<Longrightarrow>\n  \\<exists>m.\n     \\<forall>k\\<ge>m.\n        \\<not> snd (af\\<^sub>\\<nu> ?X\n                     (?\\<phi>, normalise ?\\<phi>[?X]\\<^sub>\\<nu>)\n                     (prefix (Suc k) ?w)) \\<sim>\n               false\\<^sub>n\n  \\<exists>n.\n     \\<forall>k\\<ge>n.\n        \\<not> snd (af\\<^sub>\\<nu> ?X\n                     (?\\<phi>, normalise ?\\<phi>[?X]\\<^sub>\\<nu>)\n                     (prefix (Suc k) ?w)) \\<sim>\n               false\\<^sub>n \\<Longrightarrow>\n  \\<exists>i.\n     suffix i\n      ?w \\<Turnstile>\\<^sub>n af ?\\<phi> (prefix i ?w)[?X]\\<^sub>\\<nu>\n\ngoal (1 subgoal):\n 1. (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n    (\\<exists>m.\n        \\<forall>k\\<ge>m.\n           \\<not> snd (af\\<^sub>\\<nu> X\n                        (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                        (prefix (Suc k) w)) \\<sim>\n                  false\\<^sub>n)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>i.\n      suffix i\n       w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n  (\\<exists>m.\n      \\<forall>k\\<ge>m.\n         \\<not> snd (af\\<^sub>\\<nu> X\n                      (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                      (prefix (Suc k) w)) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "also"], ["proof (state)\nthis:\n  (\\<exists>i.\n      suffix i\n       w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n  (\\<exists>m.\n      \\<forall>k\\<ge>m.\n         \\<not> snd (af\\<^sub>\\<nu> X\n                      (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                      (prefix (Suc k) w)) \\<sim>\n                false\\<^sub>n)\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "have \"\\<dots> \\<longleftrightarrow> fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n) (DCA.trace (\\<CC> \\<phi> X) (to_stream w) (Abs \\<phi>, Abs ((normalise \\<phi>)[X]\\<^sub>\\<nu>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        \\<forall>k\\<ge>m.\n           \\<not> snd (af\\<^sub>\\<nu> X\n                        (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                        (prefix (Suc k) w)) \\<sim>\n                  false\\<^sub>n) =\n    fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<CC> \\<phi> X) (to_stream w)\n       (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)))", "by(simp add: infs_snth \\<CC>_def DCA.transition_def af\\<^sub>\\<nu>_lifted_semantics af_letter\\<^sub>\\<nu>_lifted_semantics Abs_eq)"], ["proof (state)\nthis:\n  (\\<exists>m.\n      \\<forall>k\\<ge>m.\n         \\<not> snd (af\\<^sub>\\<nu> X\n                      (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                      (prefix (Suc k) w)) \\<sim>\n                false\\<^sub>n) =\n  fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<CC> \\<phi> X) (to_stream w)\n     (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "also"], ["proof (state)\nthis:\n  (\\<exists>m.\n      \\<forall>k\\<ge>m.\n         \\<not> snd (af\\<^sub>\\<nu> X\n                      (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>)\n                      (prefix (Suc k) w)) \\<sim>\n                false\\<^sub>n) =\n  fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<CC> \\<phi> X) (to_stream w)\n     (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "have \"\\<dots> \\<longleftrightarrow> to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\n     (DCA.trace (\\<CC> \\<phi> X) (to_stream w)\n       (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))) =\n    (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X))", "by (simp add: \\<CC>_def dca.initial_def dca.rejecting_def dca.language_def dca_run)"], ["proof (state)\nthis:\n  fins (\\<lambda>p. snd p = \\<up>false\\<^sub>n)\n   (DCA.trace (\\<CC> \\<phi> X) (to_stream w)\n     (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))) =\n  (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "finally"], ["proof (chain)\npicking this:\n  (\\<exists>i.\n      suffix i\n       w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n  (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>i.\n      suffix i\n       w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>) =\n  (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X))\n\ngoal (1 subgoal):\n 1. (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n    (\\<exists>i.\n        suffix i\n         w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)", "by blast"], ["proof (state)\nthis:\n  (to_stream w \\<in> DCA.language (\\<CC> \\<phi> X)) =\n  (\\<exists>i.\n      suffix i w \\<Turnstile>\\<^sub>n af \\<phi> (prefix i w)[X]\\<^sub>\\<nu>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>A DRA for each combination of sets X and Y\\<close>"], ["", "lemma dba_language:\n  \"(\\<And>w. to_stream w \\<in> DBA.language \\<AA> \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow> DBA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        (to_stream w \\<in> DBA.language \\<AA>) =\n        w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow>\n    DBA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}", "by (metis (mono_tags, lifting) Collect_cong dba.language_def mem_Collect_eq to_stream_to_omega)"], ["", "lemma dca_language:\n  \"(\\<And>w. to_stream w \\<in> DCA.language \\<AA> \\<longleftrightarrow> w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow> DCA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        (to_stream w \\<in> DCA.language \\<AA>) =\n        w \\<Turnstile>\\<^sub>n \\<phi>) \\<Longrightarrow>\n    DCA.language \\<AA> = {w. to_omega w \\<Turnstile>\\<^sub>n \\<phi>}", "by (metis (mono_tags, lifting) Collect_cong dca.language_def mem_Collect_eq to_stream_to_omega)"], ["", "definition \\<AA>\\<^sub>1 :: \"'a ltln \\<Rightarrow> 'a ltln list \\<Rightarrow> ('a set, 'ltlq \\<times> 'ltlq) dca\" where\n  \"\\<AA>\\<^sub>1 \\<phi> xs = \\<CC> \\<phi> (set xs)\""], ["", "lemma \\<AA>\\<^sub>1_language:\n  \"to_omega ` DCA.language (\\<AA>\\<^sub>1 \\<phi> xs) = L\\<^sub>1 \\<phi> (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DCA.language (\\<AA>\\<^sub>1 \\<phi> xs) =\n    L\\<^sub>1 \\<phi> (set xs)", "by (simp add: \\<AA>\\<^sub>1_def L\\<^sub>1_def set_eq_iff \\<CC>_language)"], ["", "lemma \\<AA>\\<^sub>1_alphabet:\n  \"DCA.alphabet (\\<AA>\\<^sub>1 \\<phi> xs) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dca.alphabet (\\<AA>\\<^sub>1 \\<phi> xs) = UNIV", "unfolding \\<AA>\\<^sub>1_def \\<CC>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dca.alphabet\n     (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[set xs]\\<^sub>\\<nu>))\n       (\\<up>afletter\\<^sub>\\<nu> (set xs))\n       (\\<lambda>p. snd p = \\<up>false\\<^sub>n)) =\n    UNIV", "by simp"], ["", "definition \\<AA>\\<^sub>2 :: \"'a ltln list \\<Rightarrow> 'a ltln list \\<Rightarrow> ('a set, 'ltlq list degen) dba\" where\n  \"\\<AA>\\<^sub>2 xs ys = DBA_Combine.intersect_list (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>)) xs)\""], ["", "lemma \\<AA>\\<^sub>2_language:\n  \"to_omega ` DBA.language (\\<AA>\\<^sub>2 xs ys) = L\\<^sub>2 (set xs) (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DBA.language (\\<AA>\\<^sub>2 xs ys) =\n    L\\<^sub>2 (set xs) (set ys)", "by (simp add: \\<AA>\\<^sub>2_def L\\<^sub>2_def set_eq_iff dba_language[OF \\<AA>\\<^sub>\\<mu>_GF_language[OF FG_advice_\\<mu>LTL(1)]])"], ["", "lemma \\<AA>\\<^sub>2_alphabet:\n  \"DBA.alphabet (\\<AA>\\<^sub>2 xs ys) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dba.alphabet (\\<AA>\\<^sub>2 xs ys) = UNIV", "by (simp add: \\<AA>\\<^sub>2_def \\<AA>\\<^sub>\\<mu>_GF_def)"], ["", "definition \\<AA>\\<^sub>3 :: \"'a ltln list \\<Rightarrow> 'a ltln list \\<Rightarrow> ('a set, 'ltlq list) dca\" where\n  \"\\<AA>\\<^sub>3 xs ys = DCA_Combine.intersect_list (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)) ys)\""], ["", "lemma \\<AA>\\<^sub>3_language:\n  \"to_omega ` DCA.language (\\<AA>\\<^sub>3 xs ys) = L\\<^sub>3 (set xs) (set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DCA.language (\\<AA>\\<^sub>3 xs ys) =\n    L\\<^sub>3 (set xs) (set ys)", "by (simp add: \\<AA>\\<^sub>3_def L\\<^sub>3_def set_eq_iff dca_language[OF \\<AA>\\<^sub>\\<nu>_FG_language[OF GF_advice_\\<nu>LTL(1)]])"], ["", "lemma \\<AA>\\<^sub>3_alphabet:\n  \"DCA.alphabet (\\<AA>\\<^sub>3 xs ys) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dca.alphabet (\\<AA>\\<^sub>3 xs ys) = UNIV", "by (simp add: \\<AA>\\<^sub>3_def \\<AA>\\<^sub>\\<nu>_FG_def)"], ["", "definition \"\\<AA>' \\<phi> xs ys = intersect_bc (\\<AA>\\<^sub>2 xs ys) (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs) (\\<AA>\\<^sub>3 xs ys))\""], ["", "lemma \\<AA>'_language:\n  \"to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) = (L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter> L\\<^sub>3 (set xs) (set ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) =\n    L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys)", "by (simp add: \\<AA>'_def \\<AA>\\<^sub>1_language \\<AA>\\<^sub>2_language \\<AA>\\<^sub>3_language) fastforce"], ["", "lemma \\<AA>'_alphabet:\n  \"DRA.alphabet (\\<AA>' \\<phi> xs ys) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet (\\<AA>' \\<phi> xs ys) = UNIV", "by (simp add: \\<AA>'_def \\<AA>\\<^sub>1_alphabet \\<AA>\\<^sub>2_alphabet \\<AA>\\<^sub>3_alphabet)"], ["", "subsection \\<open>A DRA for @{term \"L(\\<phi>)\"}\\<close>"], ["", "text \\<open>\n  This is the final constant constructing a deterministic Rabin automaton\n  using the pure version of the  @{thm master_theorem}.\n\\<close>"], ["", "definition \"ltl_to_dra \\<phi> = DRA_Combine.union_list (map (\\<lambda>(xs, ys). \\<AA>' \\<phi> xs ys) (advice_sets \\<phi>))\""], ["", "lemma ltl_to_dra_language:\n  \"to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "have \"(\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>). dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>). dra.alphabet (\\<AA>' \\<phi> a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b))", "using advice_sets_not_empty"], ["proof (prove)\nusing this:\n  advice_sets ?\\<phi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b))", "by (simp add: \\<AA>'_alphabet)"], ["proof (state)\nthis:\n  (\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "then"], ["proof (chain)\npicking this:\n  (\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))", "have *: \"DRA.language (DRA_Combine.union_list (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n    \\<Union> (DRA.language ` set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\""], ["proof (prove)\nusing this:\n  (\\<Inter>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))\n\ngoal (1 subgoal):\n 1. DRA.language\n     (DRA_Combine.union_list\n       (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n    \\<Union>\n     (DRA.language `\n      set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))", "by (simp add: split_def)"], ["proof (state)\nthis:\n  DRA.language\n   (DRA_Combine.union_list\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n  \\<Union>\n   (DRA.language `\n    set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "have \"language_ltln \\<phi> = \\<Union> {(L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y) | X Y. X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and> Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language_ltln \\<phi> =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>}", "unfolding master_theorem_language"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>}", "by auto"], ["proof (state)\nthis:\n  language_ltln \\<phi> =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "also"], ["proof (state)\nthis:\n  language_ltln \\<phi> =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "have \"\\<dots> = \\<Union> {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter> L\\<^sub>3 (set xs) (set ys) | xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}", "unfolding advice_sets_subformulas"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      \\<exists>xs ys.\n         X = set xs \\<and>\n         Y = set ys \\<and> (xs, ys) \\<in> set (advice_sets \\<phi>)} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>} =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "also"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi>} =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "have \"\\<dots> = \\<Union> {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) | xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)} =\n    \\<Union>\n     {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n      (xs, ys) \\<in> set (advice_sets \\<phi>)}", "by (simp add: \\<AA>'_language)"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (advice_sets \\<phi>)} =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "finally"], ["proof (chain)\npicking this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (advice_sets \\<phi>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "using *"], ["proof (prove)\nusing this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (advice_sets \\<phi>)}\n  DRA.language\n   (DRA_Combine.union_list\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n  \\<Union>\n   (DRA.language `\n    set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>", "by (auto simp add: ltl_to_dra_def)"], ["proof (state)\nthis:\n  to_omega ` DRA.language (ltl_to_dra \\<phi>) = language_ltln \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltl_to_dra_alphabet:\n  \"alphabet (ltl_to_dra \\<phi>) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet (ltl_to_dra \\<phi>) = UNIV", "by (auto simp: ltl_to_dra_def \\<AA>'_alphabet)"], ["", "subsection \\<open>A DRA for @{term \"L(\\<phi>)\"} with Restricted Advice Sets\\<close>"], ["", "text \\<open>\n  The following constant uses the @{thm master_theorem_restricted} to reduce\n  the size of the resulting automaton.\n\\<close>"], ["", "definition \"ltl_to_dra_restricted \\<phi> = DRA_Combine.union_list (map (\\<lambda>(xs, ys). \\<AA>' \\<phi> xs ys) (restricted_advice_sets \\<phi>))\""], ["", "lemma ltl_to_dra_restricted_language:\n  \"to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) = language_ltln \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "have \"(\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>). dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>). dra.alphabet (\\<AA>' \\<phi> a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b))", "using restricted_advice_sets_not_empty"], ["proof (prove)\nusing this:\n  restricted_advice_sets ?\\<phi> \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b)) =\n    (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n        dra.alphabet (\\<AA>' \\<phi> a b))", "by (simp add: \\<AA>'_alphabet)"], ["proof (state)\nthis:\n  (\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "then"], ["proof (chain)\npicking this:\n  (\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))", "have *: \"DRA.language (DRA_Combine.union_list (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (restricted_advice_sets \\<phi>))) =\n    \\<Union> (DRA.language ` set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (restricted_advice_sets \\<phi>)))\""], ["proof (prove)\nusing this:\n  (\\<Inter>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b)) =\n  (\\<Union>(a, b)\\<in>set (restricted_advice_sets \\<phi>).\n      dra.alphabet (\\<AA>' \\<phi> a b))\n\ngoal (1 subgoal):\n 1. DRA.language\n     (DRA_Combine.union_list\n       (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n         (restricted_advice_sets \\<phi>))) =\n    \\<Union>\n     (DRA.language `\n      set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n            (restricted_advice_sets \\<phi>)))", "by (simp add: split_def)"], ["proof (state)\nthis:\n  DRA.language\n   (DRA_Combine.union_list\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n       (restricted_advice_sets \\<phi>))) =\n  \\<Union>\n   (DRA.language `\n    set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n          (restricted_advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "have \"language_ltln \\<phi> = \\<Union> {(L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y) | X Y. X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter> restricted_subformulas \\<phi> \\<and> Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter> restricted_subformulas \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. language_ltln \\<phi> =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi>}", "unfolding master_theorem_restricted_language"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi>} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi>}", "by auto"], ["proof (state)\nthis:\n  language_ltln \\<phi> =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi>}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "also"], ["proof (state)\nthis:\n  language_ltln \\<phi> =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi>}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "have \"\\<dots> = \\<Union> {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter> L\\<^sub>3 (set xs) (set ys) | xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi> \\<and>\n      Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                    restricted_subformulas \\<phi>} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}", "unfolding restricted_advice_sets_subformulas"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n      \\<exists>xs ys.\n         X = set xs \\<and>\n         Y = set ys \\<and>\n         (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)} =\n    \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi>} =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "also"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> X \\<inter> L\\<^sub>2 X Y \\<inter> L\\<^sub>3 X Y |X Y.\n    X \\<subseteq> subformulas\\<^sub>\\<mu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi> \\<and>\n    Y \\<subseteq> subformulas\\<^sub>\\<nu> \\<phi> \\<inter>\n                  restricted_subformulas \\<phi>} =\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "have \"\\<dots> = \\<Union> {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) | xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {L\\<^sub>1 \\<phi> (set xs) \\<inter>\n      L\\<^sub>2 (set xs) (set ys) \\<inter>\n      L\\<^sub>3 (set xs) (set ys) |\n      xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)} =\n    \\<Union>\n     {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n      (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}", "by (simp add: \\<AA>'_language)"], ["proof (state)\nthis:\n  \\<Union>\n   {L\\<^sub>1 \\<phi> (set xs) \\<inter> L\\<^sub>2 (set xs) (set ys) \\<inter>\n    L\\<^sub>3 (set xs) (set ys) |\n    xs ys. (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)} =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "finally"], ["proof (chain)\npicking this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "using *"], ["proof (prove)\nusing this:\n  language_ltln \\<phi> =\n  \\<Union>\n   {to_omega ` DRA.language (\\<AA>' \\<phi> xs ys) |xs ys.\n    (xs, ys) \\<in> set (restricted_advice_sets \\<phi>)}\n  DRA.language\n   (DRA_Combine.union_list\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n       (restricted_advice_sets \\<phi>))) =\n  \\<Union>\n   (DRA.language `\n    set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n          (restricted_advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n    language_ltln \\<phi>", "by (auto simp add: ltl_to_dra_restricted_def)"], ["proof (state)\nthis:\n  to_omega ` DRA.language (ltl_to_dra_restricted \\<phi>) =\n  language_ltln \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltl_to_dra_restricted_alphabet:\n  \"alphabet (ltl_to_dra_restricted \\<phi>) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet (ltl_to_dra_restricted \\<phi>) = UNIV", "by (auto simp: ltl_to_dra_restricted_def \\<AA>'_alphabet)"], ["", "subsection \\<open>A DRA for @{term \"L(\\<phi>)\"} with a finite alphabet\\<close>"], ["", "text \\<open>\n  Until this point, we use @{term UNIV} as the alphabet in all places.\n  To explore the automaton, however, we need a way to fix the alphabet\n  to some finite set.\n\\<close>"], ["", "definition dra_set_alphabet :: \"('a set, 'b) dra \\<Rightarrow> 'a set set \\<Rightarrow> ('a set, 'b) dra\"\nwhere\n  \"dra_set_alphabet \\<AA> \\<Sigma> = dra \\<Sigma> (initial \\<AA>) (transition \\<AA>) (condition \\<AA>)\""], ["", "lemma dra_set_alphabet_language:\n  \"\\<Sigma> \\<subseteq> alphabet \\<AA> \\<Longrightarrow> language (dra_set_alphabet \\<AA> \\<Sigma>) = language \\<AA> \\<inter> {s. sset s \\<subseteq> \\<Sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<subseteq> dra.alphabet \\<AA> \\<Longrightarrow>\n    DRA.language (dra_set_alphabet \\<AA> \\<Sigma>) =\n    DRA.language \\<AA> \\<inter> {s. sset s \\<subseteq> \\<Sigma>}", "by (auto simp add: dra_set_alphabet_def dra.language_def set_eq_iff dra.run_alt_def streams_iff_sset)"], ["", "lemma dra_set_alphabet_alphabet[simp]:\n  \"alphabet (dra_set_alphabet \\<AA> \\<Sigma>) = \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet (dra_set_alphabet \\<AA> \\<Sigma>) = \\<Sigma>", "unfolding dra_set_alphabet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet\n     (dra \\<Sigma> (dra.initial \\<AA>) (dra.transition \\<AA>)\n       (condition \\<AA>)) =\n    \\<Sigma>", "by simp"], ["", "lemma dra_set_alphabet_nodes:\n  \"\\<Sigma> \\<subseteq> alphabet \\<AA> \\<Longrightarrow> DRA.nodes (dra_set_alphabet \\<AA> \\<Sigma>) \\<subseteq> DRA.nodes \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<subseteq> dra.alphabet \\<AA> \\<Longrightarrow>\n    DRA.nodes (dra_set_alphabet \\<AA> \\<Sigma>) \\<subseteq> DRA.nodes \\<AA>", "unfolding dra_set_alphabet_def dra.nodes_alt_def dra.reachable_alt_def dra.path_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma> \\<subseteq> dra.alphabet \\<AA> \\<Longrightarrow>\n    (\\<Union>p\\<in>{p. p =\n                       dra.initial\n                        (dra \\<Sigma> (dra.initial \\<AA>)\n                          (dra.transition \\<AA>) (condition \\<AA>))}.\n        {DRA.target\n          (dra \\<Sigma> (dra.initial \\<AA>) (dra.transition \\<AA>)\n            (condition \\<AA>))\n          r p |\n         r. r \\<in> lists\n                     (dra.alphabet\n                       (dra \\<Sigma> (dra.initial \\<AA>)\n                         (dra.transition \\<AA>) (condition \\<AA>)))})\n    \\<subseteq> (\\<Union>p\\<in>{p. p = dra.initial \\<AA>}.\n                    {DRA.target \\<AA> r p |r.\n                     r \\<in> lists (dra.alphabet \\<AA>)})", "by auto"], ["", "definition \"ltl_to_dra_alphabet \\<phi> Ap = dra_set_alphabet (ltl_to_dra_restricted \\<phi>) (Pow Ap)\""], ["", "lemma ltl_to_dra_alphabet_language:\n  assumes\n    \"atoms_ltln \\<phi> \\<subseteq> Ap\"\n  shows\n    \"to_omega ` language (ltl_to_dra_alphabet \\<phi> Ap) = language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_alphabet \\<phi> Ap) =\n    language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_alphabet \\<phi> Ap) =\n    language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}", "have 1: \"Pow Ap \\<subseteq> alphabet (ltl_to_dra_restricted \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow Ap \\<subseteq> dra.alphabet (ltl_to_dra_restricted \\<phi>)", "unfolding ltl_to_dra_restricted_alphabet"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow Ap \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  Pow Ap \\<subseteq> dra.alphabet (ltl_to_dra_restricted \\<phi>)\n\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_alphabet \\<phi> Ap) =\n    language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega ` DRA.language (ltl_to_dra_alphabet \\<phi> Ap) =\n    language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}", "unfolding ltl_to_dra_alphabet_def dra_set_alphabet_language[OF 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_omega `\n    (DRA.language (ltl_to_dra_restricted \\<phi>) \\<inter>\n     {s. sset s \\<subseteq> Pow Ap}) =\n    language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}", "by (simp add: ltl_to_dra_restricted_language sset_range) force"], ["proof (state)\nthis:\n  to_omega ` DRA.language (ltl_to_dra_alphabet \\<phi> Ap) =\n  language_ltln \\<phi> \\<inter> {w. range w \\<subseteq> Pow Ap}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltl_to_dra_alphabet_alphabet[simp]:\n  \"alphabet (ltl_to_dra_alphabet \\<phi> Ap) = Pow Ap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet (ltl_to_dra_alphabet \\<phi> Ap) = Pow Ap", "unfolding ltl_to_dra_alphabet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dra.alphabet\n     (dra_set_alphabet (ltl_to_dra_restricted \\<phi>) (Pow Ap)) =\n    Pow Ap", "by simp"], ["", "lemma ltl_to_dra_alphabet_nodes:\n  \"DRA.nodes (ltl_to_dra_alphabet \\<phi> Ap) \\<subseteq> DRA.nodes (ltl_to_dra_restricted \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DRA.nodes (ltl_to_dra_alphabet \\<phi> Ap)\n    \\<subseteq> DRA.nodes (ltl_to_dra_restricted \\<phi>)", "unfolding ltl_to_dra_alphabet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DRA.nodes (dra_set_alphabet (ltl_to_dra_restricted \\<phi>) (Pow Ap))\n    \\<subseteq> DRA.nodes (ltl_to_dra_restricted \\<phi>)", "by (rule dra_set_alphabet_nodes) (simp add: ltl_to_dra_restricted_alphabet)"], ["", "end"], ["", "subsection \\<open>Verified Bounds for Number of Nodes\\<close>"], ["", "text \\<open>\n  Using two additional assumptions, we can show a double-exponential size bound\n  for the constructed automaton.\n\\<close>"], ["", "(* TODO add to HOL/Groups_List.thy *)"], ["", "lemma list_prod_mono:\n  \"f \\<le> g \\<Longrightarrow> (\\<Prod>x\\<leftarrow>xs. f x) \\<le> (\\<Prod>x\\<leftarrow>xs. g x)\" for f g :: \"'a \\<Rightarrow> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> g \\<Longrightarrow>\n    prod_list (map f xs) \\<le> prod_list (map g xs)", "by (induction xs) (auto simp: le_funD mult_le_mono)"], ["", "(* TODO add to HOL/Groups_List.thy *)"], ["", "lemma list_prod_const:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> f x \\<le> c) \\<Longrightarrow> (\\<Prod>x\\<leftarrow>xs. f x) \\<le> c ^ length xs\" for f :: \"'a \\<Rightarrow> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> f x \\<le> c) \\<Longrightarrow>\n    prod_list (map f xs) \\<le> c ^ length xs", "by (induction xs) (auto simp: mult_le_mono)"], ["", "(* TODO add to HOL/Finite_Set.thy *)"], ["", "lemma card_insert_Suc:\n  \"card (insert x S) \\<le> Suc (card S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x S) \\<le> Suc (card S)", "by (metis Suc_n_not_le_n card.infinite card_insert_if finite_insert linear)"], ["", "(* TODO add to HOL/Power.thy *)"], ["", "lemma nat_power_le_imp_le:\n  \"0 < a \\<Longrightarrow> a \\<le> b \\<Longrightarrow> x ^ a \\<le> x ^ b\" for x :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; a \\<le> b\\<rbrakk> \\<Longrightarrow> x ^ a \\<le> x ^ b", "by (metis leD linorder_le_less_linear nat_power_less_imp_less neq0_conv power_eq_0_iff)"], ["", "(* TODO add to HOL/Power.thy *)"], ["", "lemma const_less_power:\n  \"n < x ^ n\" if \"x > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < x ^ n", "using that"], ["proof (prove)\nusing this:\n  1 < x\n\ngoal (1 subgoal):\n 1. n < x ^ n", "by (induction n) (auto simp: less_trans_Suc)"], ["", "(* TODO add to HOL-Library/Log_Nat.thy *)"], ["", "lemma floorlog_le_const:\n  \"floorlog x n \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. floorlog x n \\<le> n", "by (induction n) (simp add: floorlog_eq_zero_iff, metis Suc_lessI floorlog_le_iff le_SucI power_inject_exp)"], ["", "locale dra_construction_size = dra_construction + transition_functions_size +\n  assumes\n    equiv_finite: \"finite P \\<Longrightarrow> finite {Abs \\<psi> | \\<psi>. prop_atoms \\<psi> \\<subseteq> P}\"\n  assumes\n    equiv_card: \"finite P \\<Longrightarrow> card {Abs \\<psi> | \\<psi>. prop_atoms \\<psi> \\<subseteq> P} \\<le> 2 ^ 2 ^ card P\"\nbegin"], ["", "lemma af\\<^sub>F_lifted_range:\n  \"nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>) \\<Longrightarrow> range (\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>)) \\<subseteq>  {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>) \\<Longrightarrow>\n    range (\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}", "using af\\<^sub>F_lifted_semantics af\\<^sub>F_nested_prop_atoms"], ["proof (prove)\nusing this:\n  \\<up>af\\<^sub>F ?\\<phi> (Abs ?\\<psi>) ?w =\n  Abs (af\\<^sub>F ?\\<phi> ?\\<psi> ?w)\n  nested_prop_atoms ?\\<psi>\n  \\<subseteq> nested_prop_atoms (F\\<^sub>n ?\\<phi>) \\<Longrightarrow>\n  nested_prop_atoms (af\\<^sub>F ?\\<phi> ?\\<psi> ?w)\n  \\<subseteq> nested_prop_atoms (F\\<^sub>n ?\\<phi>)\n\ngoal (1 subgoal):\n 1. nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>) \\<Longrightarrow>\n    range (\\<up>af\\<^sub>F \\<phi> (Abs \\<psi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}", "by blast"], ["", "lemma af\\<^sub>G_lifted_range:\n  \"nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>) \\<Longrightarrow> range (\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>)) \\<subseteq>  {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>) \\<Longrightarrow>\n    range (\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}", "using af\\<^sub>G_lifted_semantics af\\<^sub>G_nested_prop_atoms"], ["proof (prove)\nusing this:\n  \\<up>af\\<^sub>G ?\\<phi> (Abs ?\\<psi>) ?w =\n  Abs (af\\<^sub>G ?\\<phi> ?\\<psi> ?w)\n  nested_prop_atoms ?\\<psi>\n  \\<subseteq> nested_prop_atoms (G\\<^sub>n ?\\<phi>) \\<Longrightarrow>\n  nested_prop_atoms (af\\<^sub>G ?\\<phi> ?\\<psi> ?w)\n  \\<subseteq> nested_prop_atoms (G\\<^sub>n ?\\<phi>)\n\ngoal (1 subgoal):\n 1. nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>) \\<Longrightarrow>\n    range (\\<up>af\\<^sub>G \\<phi> (Abs \\<psi>))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}", "by blast"], ["", "lemma \\<AA>\\<^sub>\\<mu>_nodes:\n  \"DBA.nodes (\\<AA>\\<^sub>\\<mu> \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.nodes (\\<AA>\\<^sub>\\<mu> \\<phi>)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "unfolding \\<AA>\\<^sub>\\<mu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.nodes\n     (dba UNIV (Abs \\<phi>) \\<up>afletter\n       (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "using af_lifted_semantics af_nested_prop_atoms"], ["proof (prove)\nusing this:\n  \\<up>af (Abs ?\\<phi>) ?w = Abs (af ?\\<phi> ?w)\n  nested_prop_atoms (af ?\\<phi> ?w) \\<subseteq> nested_prop_atoms ?\\<phi>\n\ngoal (1 subgoal):\n 1. DBA.nodes\n     (dba UNIV (Abs \\<phi>) \\<up>afletter\n       (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "by fastforce"], ["", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes:\n  \"DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}", "unfolding \\<AA>\\<^sub>\\<mu>_GF_def dba.nodes_alt_def dba.reachable_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dba.initial\n                        (dba UNIV (Abs (F\\<^sub>n \\<phi>))\n                          (\\<up>afletter\\<^sub>F \\<phi>)\n                          (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))}.\n        {DBA.target\n          (dba UNIV (Abs (F\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>F \\<phi>)\n            (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n          r p |\n         r. DBA.path\n             (dba UNIV (Abs (F\\<^sub>n \\<phi>))\n               (\\<up>afletter\\<^sub>F \\<phi>)\n               (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}", "using af\\<^sub>F_nested_prop_atoms[of \"F\\<^sub>n \\<phi>\"]"], ["proof (prove)\nusing this:\n  nested_prop_atoms (F\\<^sub>n \\<phi>)\n  \\<subseteq> nested_prop_atoms (F\\<^sub>n ?\\<phi>) \\<Longrightarrow>\n  nested_prop_atoms (af\\<^sub>F ?\\<phi> (F\\<^sub>n \\<phi>) ?w)\n  \\<subseteq> nested_prop_atoms (F\\<^sub>n ?\\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dba.initial\n                        (dba UNIV (Abs (F\\<^sub>n \\<phi>))\n                          (\\<up>afletter\\<^sub>F \\<phi>)\n                          (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))}.\n        {DBA.target\n          (dba UNIV (Abs (F\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>F \\<phi>)\n            (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n          r p |\n         r. DBA.path\n             (dba UNIV (Abs (F\\<^sub>n \\<phi>))\n               (\\<up>afletter\\<^sub>F \\<phi>)\n               (\\<lambda>\\<psi>. \\<psi> = \\<up>true\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (F\\<^sub>n \\<phi>)}", "by (auto simp: af\\<^sub>F_lifted_semantics)"], ["", "lemma \\<AA>\\<^sub>\\<nu>_nodes:\n  \"DCA.nodes (\\<AA>\\<^sub>\\<nu> \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.nodes (\\<AA>\\<^sub>\\<nu> \\<phi>)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "unfolding \\<AA>\\<^sub>\\<nu>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.nodes\n     (dca UNIV (Abs \\<phi>) \\<up>afletter\n       (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "using af_lifted_semantics af_nested_prop_atoms"], ["proof (prove)\nusing this:\n  \\<up>af (Abs ?\\<phi>) ?w = Abs (af ?\\<phi> ?w)\n  nested_prop_atoms (af ?\\<phi> ?w) \\<subseteq> nested_prop_atoms ?\\<phi>\n\ngoal (1 subgoal):\n 1. DCA.nodes\n     (dca UNIV (Abs \\<phi>) \\<up>afletter\n       (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>}", "by fastforce"], ["", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes:\n  \"DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}", "unfolding \\<AA>\\<^sub>\\<nu>_FG_def dca.nodes_alt_def dca.reachable_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dca.initial\n                        (dca UNIV (Abs (G\\<^sub>n \\<phi>))\n                          (\\<up>afletter\\<^sub>G \\<phi>)\n                          (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))}.\n        {DCA.target\n          (dca UNIV (Abs (G\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>G \\<phi>)\n            (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n          r p |\n         r. DCA.path\n             (dca UNIV (Abs (G\\<^sub>n \\<phi>))\n               (\\<up>afletter\\<^sub>G \\<phi>)\n               (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}", "using af\\<^sub>G_nested_prop_atoms[of \"G\\<^sub>n \\<phi>\"]"], ["proof (prove)\nusing this:\n  nested_prop_atoms (G\\<^sub>n \\<phi>)\n  \\<subseteq> nested_prop_atoms (G\\<^sub>n ?\\<phi>) \\<Longrightarrow>\n  nested_prop_atoms (af\\<^sub>G ?\\<phi> (G\\<^sub>n \\<phi>) ?w)\n  \\<subseteq> nested_prop_atoms (G\\<^sub>n ?\\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dca.initial\n                        (dca UNIV (Abs (G\\<^sub>n \\<phi>))\n                          (\\<up>afletter\\<^sub>G \\<phi>)\n                          (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))}.\n        {DCA.target\n          (dca UNIV (Abs (G\\<^sub>n \\<phi>)) (\\<up>afletter\\<^sub>G \\<phi>)\n            (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n          r p |\n         r. DCA.path\n             (dca UNIV (Abs (G\\<^sub>n \\<phi>))\n               (\\<up>afletter\\<^sub>G \\<phi>)\n               (\\<lambda>\\<psi>. \\<psi> = \\<up>false\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms (G\\<^sub>n \\<phi>)}", "by (auto simp: af\\<^sub>G_lifted_semantics)"], ["", "lemma \\<CC>_nodes_normalise:\n  \"DCA.nodes (\\<CC> \\<phi> X) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> (normalise \\<phi>) X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.nodes (\\<CC> \\<phi> X)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n                {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms\\<^sub>\\<nu>\n                              (normalise \\<phi>) X}", "unfolding \\<CC>_def dca.nodes_alt_def dca.reachable_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dca.initial\n                        (dca UNIV\n                          (Abs \\<phi>,\n                           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n                          (\\<up>afletter\\<^sub>\\<nu> X)\n                          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))}.\n        {DCA.target\n          (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n            (\\<up>afletter\\<^sub>\\<nu> X)\n            (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n          r p |\n         r. DCA.path\n             (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n               (\\<up>afletter\\<^sub>\\<nu> X)\n               (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n                {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms\\<^sub>\\<nu>\n                              (normalise \\<phi>) X}", "apply (auto simp add: af\\<^sub>\\<nu>_lifted_semantics af_letter\\<^sub>\\<nu>_lifted_semantics)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (fst (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>\n 2. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> (normalise \\<phi>) X", "using af\\<^sub>\\<nu>_fst_nested_prop_atoms"], ["proof (prove)\nusing this:\n  nested_prop_atoms (fst (af\\<^sub>\\<nu> ?X ?p ?w))\n  \\<subseteq> nested_prop_atoms (fst ?p)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (fst (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>\n 2. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> (normalise \\<phi>) X", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> (normalise \\<phi>) X", "by (metis GF_advice_nested_prop_atoms\\<^sub>\\<nu> af\\<^sub>\\<nu>_snd_nested_prop_atoms Abs_eq af\\<^sub>\\<nu>_lifted_semantics fst_conv normalise_eq snd_conv sup.absorb_iff1)"], ["", "lemma \\<CC>_nodes:\n  \"DCA.nodes (\\<CC> \\<phi> X) \\<subseteq> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times> {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DCA.nodes (\\<CC> \\<phi> X)\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n                {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "unfolding \\<CC>_def dca.nodes_alt_def dca.reachable_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>{p. p =\n                       dca.initial\n                        (dca UNIV\n                          (Abs \\<phi>,\n                           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n                          (\\<up>afletter\\<^sub>\\<nu> X)\n                          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))}.\n        {DCA.target\n          (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n            (\\<up>afletter\\<^sub>\\<nu> X)\n            (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n          r p |\n         r. DCA.path\n             (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n               (\\<up>afletter\\<^sub>\\<nu> X)\n               (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n             r p})\n    \\<subseteq> {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n                {Abs \\<psi> |\\<psi>.\n                 nested_prop_atoms \\<psi>\n                 \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "apply (auto simp add: af\\<^sub>\\<nu>_lifted_semantics af_letter\\<^sub>\\<nu>_lifted_semantics)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (fst (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>\n 2. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X", "using af\\<^sub>\\<nu>_fst_nested_prop_atoms"], ["proof (prove)\nusing this:\n  nested_prop_atoms (fst (af\\<^sub>\\<nu> ?X ?p ?w))\n  \\<subseteq> nested_prop_atoms (fst ?p)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (fst (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>\n 2. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       DCA.path\n        (dca UNIV (Abs \\<phi>, Abs (normalise \\<phi>[X]\\<^sub>\\<nu>))\n          (\\<up>afletter\\<^sub>\\<nu> X)\n          (\\<lambda>p. snd p = \\<up>false\\<^sub>n))\n        r (Abs \\<phi>,\n           Abs (normalise \\<phi>[X]\\<^sub>\\<nu>)) \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          Abs (snd (af\\<^sub>\\<nu> X\n                     (\\<phi>, normalise \\<phi>[X]\\<^sub>\\<nu>) r)) =\n          Abs \\<psi> \\<and>\n          nested_prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X", "by (metis (no_types, hide_lams) GF_advice_nested_prop_atoms\\<^sub>\\<nu> af\\<^sub>\\<nu>_snd_nested_prop_atoms fst_eqD nested_prop_atoms\\<^sub>\\<nu>_subset normalise_nested_propos order_refl order_trans snd_eqD sup.order_iff)"], ["", "lemma equiv_subset:\n  \"{Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P} \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}\n    \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> P}", "using prop_atoms_nested_prop_atoms"], ["proof (prove)\nusing this:\n  prop_atoms ?\\<phi> \\<subseteq> nested_prop_atoms ?\\<phi>\n\ngoal (1 subgoal):\n 1. {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}\n    \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> P}", "by blast"], ["", "lemma equiv_finite':\n  \"finite P \\<Longrightarrow> finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow>\n    finite {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}", "using equiv_finite equiv_subset finite_subset"], ["proof (prove)\nusing this:\n  finite ?P \\<Longrightarrow>\n  finite {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> ?P}\n  {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> ?P}\n  \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> ?P}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow>\n    finite {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}", "by fast"], ["", "lemma equiv_card':\n  \"finite P \\<Longrightarrow> card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P} \\<le> 2 ^ 2 ^ card P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite P \\<Longrightarrow>\n    card {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> P}\n    \\<le> 2 ^ 2 ^ card P", "by (metis (mono_tags, lifting) equiv_card equiv_subset equiv_finite card_mono le_trans)"], ["", "lemma nested_prop_atoms_finite:\n  \"finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}", "using equiv_finite'[OF Equivalence_Relations.nested_prop_atoms_finite]"], ["proof (prove)\nusing this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms ?\\<phi>1}\n\ngoal (1 subgoal):\n 1. finite\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}", "."], ["", "lemma nested_prop_atoms_card:\n  \"card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "using equiv_card'[OF Equivalence_Relations.nested_prop_atoms_finite]"], ["proof (prove)\nusing this:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms ?\\<phi>1}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms ?\\<phi>1)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "."], ["", "lemma nested_prop_atoms\\<^sub>\\<nu>_finite:\n  \"finite {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "using equiv_finite'[OF nested_prop_atoms\\<^sub>\\<nu>_finite]"], ["proof (prove)\nusing this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> ?\\<phi>1 ?X1}\n\ngoal (1 subgoal):\n 1. finite\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "by fast"], ["", "lemma nested_prop_atoms\\<^sub>\\<nu>_card:\n  \"card {Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X} \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "have \"finite {Abs \\<psi> | \\<psi>. prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {Abs \\<psi> |\\<psi>.\n      prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "by (simp add: nested_prop_atoms\\<^sub>\\<nu>_finite Advice.nested_prop_atoms\\<^sub>\\<nu>_finite equiv_finite)"], ["proof (state)\nthis:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "then"], ["proof (chain)\npicking this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "have \"?lhs \\<le> card {Abs \\<psi> | \\<psi>. prop_atoms \\<psi> \\<subseteq> (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)}\""], ["proof (prove)\nusing this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> card\n           {Abs \\<psi> |\\<psi>.\n            prop_atoms \\<psi>\n            \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "using card_mono equiv_subset"], ["proof (prove)\nusing this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n  {Abs \\<psi> |\\<psi>. nested_prop_atoms \\<psi> \\<subseteq> ?P}\n  \\<subseteq> {Abs \\<psi> |\\<psi>. prop_atoms \\<psi> \\<subseteq> ?P}\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> card\n           {Abs \\<psi> |\\<psi>.\n            prop_atoms \\<psi>\n            \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}", "by blast"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> card\n         {Abs \\<psi> |\\<psi>.\n          prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "also"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> card\n         {Abs \\<psi> |\\<psi>.\n          prop_atoms \\<psi>\n          \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "have \"\\<dots> \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)", "using equiv_card[OF Advice.nested_prop_atoms\\<^sub>\\<nu>_finite]"], ["proof (prove)\nusing this:\n  card\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> ?\\<phi>1 ?X1}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> ?\\<phi>1 ?X1)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)", "by fast"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "also"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "using nested_prop_atoms\\<^sub>\\<nu>_card"], ["proof (prove)\nusing this:\n  card (nested_prop_atoms\\<^sub>\\<nu> ?\\<phi> ?X)\n  \\<le> card (nested_prop_atoms ?\\<phi>)\n\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "by auto"], ["proof (state)\nthis:\n  2 ^ 2 ^ card (nested_prop_atoms\\<^sub>\\<nu> \\<phi> X)\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "finally"], ["proof (chain)\npicking this:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "."], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes_finite:\n  \"finite (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))", "using finite_subset[OF \\<AA>\\<^sub>\\<mu>_GF_nodes nested_prop_atoms_finite]"], ["proof (prove)\nusing this:\n  finite (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF ?\\<phi>3))\n\ngoal (1 subgoal):\n 1. finite (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))", "."], ["", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))", "using finite_subset[OF \\<AA>\\<^sub>\\<nu>_FG_nodes nested_prop_atoms_finite]"], ["proof (prove)\nusing this:\n  finite (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG ?\\<phi>3))\n\ngoal (1 subgoal):\n 1. finite (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))", "."], ["", "lemma \\<AA>\\<^sub>\\<mu>_GF_nodes_card:\n  \"card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>)) \\<le> 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n \\<phi>))", "using le_trans[OF card_mono[OF nested_prop_atoms_finite \\<AA>\\<^sub>\\<mu>_GF_nodes] nested_prop_atoms_card]"], ["proof (prove)\nusing this:\n  card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF ?\\<phi>6))\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n ?\\<phi>6))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF \\<phi>))\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n \\<phi>))", "."], ["", "lemma \\<AA>\\<^sub>\\<nu>_FG_nodes_card:\n  \"card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>)) \\<le> 2 ^ 2 ^ card (nested_prop_atoms (G\\<^sub>n \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms (G\\<^sub>n \\<phi>))", "using le_trans[OF card_mono[OF nested_prop_atoms_finite \\<AA>\\<^sub>\\<nu>_FG_nodes] nested_prop_atoms_card]"], ["proof (prove)\nusing this:\n  card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG ?\\<phi>6))\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms (G\\<^sub>n ?\\<phi>6))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG \\<phi>))\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms (G\\<^sub>n \\<phi>))", "."], ["", "lemma \\<AA>\\<^sub>2_nodes_finite_helper:\n  \"list_all (finite \\<circ> DBA.nodes) (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DBA.nodes)\n     (map (\\<lambda>\\<psi>.\n              \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))\n       xs)", "by (auto simp: list.pred_map list_all_iff \\<AA>\\<^sub>\\<mu>_GF_nodes_finite)"], ["", "lemma \\<AA>\\<^sub>2_nodes_finite:\n  \"finite (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DBA.nodes (\\<AA>\\<^sub>2 xs ys))", "unfolding \\<AA>\\<^sub>2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (DBA.nodes\n       (DBA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))\n           xs)))", "using DBA_Combine.intersect_list_nodes_finite \\<AA>\\<^sub>2_nodes_finite_helper"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DBA.nodes) ?AA \\<Longrightarrow>\n  finite (DBA.nodes (DBA_Combine.intersect_list ?AA))\n  list_all (finite \\<circ> DBA.nodes)\n   (map (\\<lambda>\\<psi>.\n            \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ?ys]\\<^sub>\\<mu>))\n     ?xs)\n\ngoal (1 subgoal):\n 1. finite\n     (DBA.nodes\n       (DBA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))\n           xs)))", "."], ["", "lemma \\<AA>\\<^sub>3_nodes_finite_helper:\n  \"list_all (finite \\<circ> DCA.nodes) (map (\\<lambda>\\<psi>. \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DCA.nodes)\n     (map (\\<lambda>\\<psi>.\n              \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))\n       ys)", "by (auto simp: list.pred_map list_all_iff \\<AA>\\<^sub>\\<nu>_FG_nodes_finite)"], ["", "lemma \\<AA>\\<^sub>3_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "unfolding \\<AA>\\<^sub>3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (DCA.nodes\n       (DCA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))\n           ys)))", "using DCA_Combine.intersect_list_nodes_finite \\<AA>\\<^sub>3_nodes_finite_helper"], ["proof (prove)\nusing this:\n  list_all (finite \\<circ> DCA.nodes) ?AA \\<Longrightarrow>\n  finite (DCA.nodes (DCA_Combine.intersect_list ?AA))\n  list_all (finite \\<circ> DCA.nodes)\n   (map (\\<lambda>\\<psi>.\n            \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set ?xs]\\<^sub>\\<nu>))\n     ?ys)\n\ngoal (1 subgoal):\n 1. finite\n     (DCA.nodes\n       (DCA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))\n           ys)))", "."], ["", "lemma \\<AA>\\<^sub>2_nodes_card:\n  assumes\n    \"length xs \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set xs \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  shows\n    \"card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have 1: \"\\<And>\\<psi>. \\<psi> \\<in> set xs \\<Longrightarrow> card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)) \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "assume \"\\<psi> \\<in> set xs\""], ["proof (state)\nthis:\n  \\<psi> \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "have \"card (nested_prop_atoms (F\\<^sub>n (\\<psi>[set ys]\\<^sub>\\<mu>)))\n          \\<le> Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n    \\<le> Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))", "by (simp add: card_insert_Suc)"], ["proof (state)\nthis:\n  card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "also"], ["proof (state)\nthis:\n  card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "have \"\\<dots> \\<le> Suc (card (nested_prop_atoms \\<psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\n    \\<le> Suc (card (nested_prop_atoms \\<psi>))", "by (simp add: FG_advice_nested_prop_atoms_card)"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\n  \\<le> Suc (card (nested_prop_atoms \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "also"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms (\\<psi>[set ys]\\<^sub>\\<mu>)))\n  \\<le> Suc (card (nested_prop_atoms \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "have \"\\<dots> \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (nested_prop_atoms \\<psi>)) \\<le> Suc n", "by (simp add: assms(2) \\<open>\\<psi> \\<in> set xs\\<close>)"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms \\<psi>)) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set xs \\<Longrightarrow>\n       card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n       \\<le> Suc n", "finally"], ["proof (chain)\npicking this:\n  card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc n", "show \"card (nested_prop_atoms (F\\<^sub>n (\\<psi>[set ys]\\<^sub>\\<mu>))) \\<le> Suc n\""], ["proof (prove)\nusing this:\n  card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc n\n\ngoal (1 subgoal):\n 1. card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n    \\<le> Suc n", "."], ["proof (state)\nthis:\n  card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<psi>1 \\<in> set xs \\<Longrightarrow>\n  card (nested_prop_atoms (F\\<^sub>n ?\\<psi>1[set ys]\\<^sub>\\<mu>))\n  \\<le> Suc n\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"(\\<Prod>\\<psi>\\<leftarrow>xs. card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))\n        \\<le> (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^ 2 ^ card (nested_prop_atoms (F\\<^sub>n (\\<psi>[set ys]\\<^sub>\\<mu>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                   (DBA.nodes\n                                     (\\<AA>\\<^sub>\\<mu>_GF\n (\\<psi>[set ys]\\<^sub>\\<mu>))))\n    \\<le> (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n  2 ^ card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)))", "by (rule list_prod_mono) (insert \\<AA>\\<^sub>\\<mu>_GF_nodes_card le_fun_def, blast)"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n2 ^ card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n2 ^ card (nested_prop_atoms (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> (2 ^ 2 ^ Suc n) ^ length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n                                  2 ^\n                                  card\n                                   (nested_prop_atoms\n                                     (F\\<^sub>n \\<psi>[set\n                  ys]\\<^sub>\\<mu>)))\n    \\<le> (2 ^ 2 ^ Suc n) ^ length xs", "by (rule list_prod_const) (metis 1 Suc_leI nat_power_le_imp_le nat_power_eq_Suc_0_iff neq0_conv pos2 zero_less_power)"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n                                2 ^\n                                card\n                                 (nested_prop_atoms\n                                   (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)))\n  \\<le> (2 ^ 2 ^ Suc n) ^ length xs\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. 2 ^\n                                2 ^\n                                card\n                                 (nested_prop_atoms\n                                   (F\\<^sub>n \\<psi>[set ys]\\<^sub>\\<mu>)))\n  \\<le> (2 ^ 2 ^ Suc n) ^ length xs\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> (2 ^ 2 ^ Suc n) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ Suc n) ^ length xs \\<le> (2 ^ 2 ^ Suc n) ^ n", "using assms(1) nat_power_le_imp_le"], ["proof (prove)\nusing this:\n  length xs \\<le> n\n  \\<lbrakk>0 < ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?x ^ ?a \\<le> ?x ^ ?b\n\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ Suc n) ^ length xs \\<le> (2 ^ 2 ^ Suc n) ^ n", "by fastforce"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ length xs \\<le> (2 ^ 2 ^ Suc n) ^ n\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ length xs \\<le> (2 ^ 2 ^ Suc n) ^ n\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> = 2 ^ (n * 2 ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ Suc n) ^ n = 2 ^ (n * 2 ^ Suc n)", "by (metis Groups.mult_ac(2) power_mult)"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ n = 2 ^ (n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ n = 2 ^ (n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)", "by (cases \"n = 0\") (auto simp: floorlog_bounds less_imp_le_nat)"], ["proof (state)\nthis:\n  2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> = 2 ^ 2 ^ (Suc n + floorlog 2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n) = 2 ^ 2 ^ (Suc n + floorlog 2 n)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n) = 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)", "have 2: \"(\\<Prod>\\<psi>\\<leftarrow>xs. card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>)))) \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)\""], ["proof (prove)\nusing this:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                   (DBA.nodes\n                                     (\\<AA>\\<^sub>\\<mu>_GF\n (\\<psi>[set ys]\\<^sub>\\<mu>))))\n    \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)", "."], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) \\<le> max 1 (length xs) * (\\<Prod>\\<psi>\\<leftarrow>xs. card (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> max 1 (length xs) *\n          (\\<Prod>\\<psi>\\<leftarrow>xs. card\n   (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))", "using DBA_Combine.intersect_list_nodes_card[OF \\<AA>\\<^sub>2_nodes_finite_helper]"], ["proof (prove)\nusing this:\n  card\n   (DBA.nodes\n     (DBA_Combine.intersect_list\n       (map (\\<lambda>\\<psi>.\n                \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ?ys1]\\<^sub>\\<mu>))\n         ?xs1)))\n  \\<le> max 1\n         (length\n           (map (\\<lambda>\\<psi>.\n                    \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ?ys1]\\<^sub>\\<mu>))\n             ?xs1)) *\n        prod_list\n         (map (card \\<circ> DBA.nodes)\n           (map (\\<lambda>\\<psi>.\n                    \\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ?ys1]\\<^sub>\\<mu>))\n             ?xs1))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> max 1 (length xs) *\n          (\\<Prod>\\<psi>\\<leftarrow>xs. card\n   (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))", "by (auto simp: \\<AA>\\<^sub>2_def comp_def)"], ["proof (state)\nthis:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n  \\<le> max 1 (length xs) *\n        (\\<Prod>\\<psi>\\<leftarrow>xs. card\n (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n  \\<le> max 1 (length xs) *\n        (\\<Prod>\\<psi>\\<leftarrow>xs. card\n (DBA.nodes (\\<AA>\\<^sub>\\<mu>_GF (\\<psi>[set ys]\\<^sub>\\<mu>))))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 (length xs) *\n    (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                   (DBA.nodes\n                                     (\\<AA>\\<^sub>\\<mu>_GF\n (\\<psi>[set ys]\\<^sub>\\<mu>))))\n    \\<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)", "using assms(1) 2"], ["proof (prove)\nusing this:\n  length xs \\<le> n\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. max 1 (length xs) *\n    (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                   (DBA.nodes\n                                     (\\<AA>\\<^sub>\\<mu>_GF\n (\\<psi>[set ys]\\<^sub>\\<mu>))))\n    \\<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)", "by (simp add: mult_le_mono)"], ["proof (state)\nthis:\n  max 1 (length xs) *\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  max 1 (length xs) *\n  (\\<Prod>\\<psi>\\<leftarrow>xs. card\n                                 (DBA.nodes\n                                   (\\<AA>\\<^sub>\\<mu>_GF\n                                     (\\<psi>[set ys]\\<^sub>\\<mu>))))\n  \\<le> max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> 2 ^ (floorlog 2 n) * 2 ^ 2 ^ (Suc n + floorlog 2 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n    \\<le> 2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)", "by (cases \"n = 0\") (auto simp: floorlog_bounds less_imp_le_nat)"], ["proof (state)\nthis:\n  max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n  \\<le> 2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  max 1 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n  \\<le> 2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> = 2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n) =\n    2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n) =\n  2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  2 ^ floorlog 2 n * 2 ^ 2 ^ (Suc n + floorlog 2 n) =\n  2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\n    \\<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))", "by (simp add: floorlog_le_const)"], ["proof (state)\nthis:\n  2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\n  \\<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "also"], ["proof (state)\nthis:\n  2 ^ (floorlog 2 n + 2 ^ (Suc n + floorlog 2 n))\n  \\<le> 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "have \"\\<dots> \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (n + 2 ^ (Suc n + floorlog 2 n))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "by simp (metis const_less_power Suc_1 add_Suc_right add_leE lessI less_imp_le_nat power_Suc)"], ["proof (state)\nthis:\n  2 ^ (n + 2 ^ (Suc n + floorlog 2 n)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "finally"], ["proof (chain)\npicking this:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\n\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)", "."], ["proof (state)\nthis:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>3_nodes_card:\n  assumes\n    \"length ys \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set ys \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  shows\n    \"card (DCA.nodes (\\<AA>\\<^sub>3 xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have 1: \"\\<And>\\<psi>. \\<psi> \\<in> set ys \\<Longrightarrow> card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))) \\<le> 2 ^ 2 ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "assume \"\\<psi> \\<in> set ys\""], ["proof (state)\nthis:\n  \\<psi> \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "have \"card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n          \\<le> Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n    \\<le> Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))", "by (simp add: card_insert_Suc)"], ["proof (state)\nthis:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "also"], ["proof (state)\nthis:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "have \"\\<dots> \\<le> Suc (card (nested_prop_atoms \\<psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\n    \\<le> Suc (card (nested_prop_atoms \\<psi>))", "by (simp add: GF_advice_nested_prop_atoms_card)"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\n  \\<le> Suc (card (nested_prop_atoms \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "also"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms (\\<psi>[set xs]\\<^sub>\\<nu>)))\n  \\<le> Suc (card (nested_prop_atoms \\<psi>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "have \"\\<dots> \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (card (nested_prop_atoms \\<psi>)) \\<le> Suc n", "by (simp add: assms(2) \\<open>\\<psi> \\<in> set ys\\<close>)"], ["proof (state)\nthis:\n  Suc (card (nested_prop_atoms \\<psi>)) \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc n", "have 2: \"card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>)) \\<le> Suc n\""], ["proof (prove)\nusing this:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc n\n\ngoal (1 subgoal):\n 1. card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n    \\<le> Suc n", "."], ["proof (state)\nthis:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<in> set ys \\<Longrightarrow>\n       card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n       \\<le> 2 ^ 2 ^ Suc n", "then"], ["proof (chain)\npicking this:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc n", "show \"?thesis \\<psi>\""], ["proof (prove)\nusing this:\n  card (nested_prop_atoms (G\\<^sub>n \\<psi>[set xs]\\<^sub>\\<nu>))\n  \\<le> Suc n\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n    \\<le> 2 ^ 2 ^ Suc n", "by (intro le_trans[OF \\<AA>\\<^sub>\\<nu>_FG_nodes_card]) (meson one_le_numeral power_increasing)"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>)))\n  \\<le> 2 ^ 2 ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<psi>1 \\<in> set ys \\<Longrightarrow>\n  card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (?\\<psi>1[set xs]\\<^sub>\\<nu>)))\n  \\<le> 2 ^ 2 ^ Suc n\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"card (DCA.nodes (\\<AA>\\<^sub>3 xs ys)) \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card\n   (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))", "unfolding \\<AA>\\<^sub>3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (DCA.nodes\n       (DCA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))\n           ys)))\n    \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card\n   (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))", "using DCA_Combine.intersect_list_nodes_card[OF \\<AA>\\<^sub>3_nodes_finite_helper]"], ["proof (prove)\nusing this:\n  card\n   (DCA.nodes\n     (DCA_Combine.intersect_list\n       (map (\\<lambda>\\<psi>.\n                \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set ?xs1]\\<^sub>\\<nu>))\n         ?ys1)))\n  \\<le> prod_list\n         (map (card \\<circ> DCA.nodes)\n           (map (\\<lambda>\\<psi>.\n                    \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set ?xs1]\\<^sub>\\<nu>))\n             ?ys1))\n\ngoal (1 subgoal):\n 1. card\n     (DCA.nodes\n       (DCA_Combine.intersect_list\n         (map (\\<lambda>\\<psi>.\n                  \\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))\n           ys)))\n    \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card\n   (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card\n (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "also"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> (\\<Prod>\\<psi>\\<leftarrow>ys. card\n (DCA.nodes (\\<AA>\\<^sub>\\<nu>_FG (\\<psi>[set xs]\\<^sub>\\<nu>))))\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"\\<dots> \\<le> (2 ^ 2 ^ Suc n) ^ length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<psi>\\<leftarrow>ys. card\n                                   (DCA.nodes\n                                     (\\<AA>\\<^sub>\\<nu>_FG\n (\\<psi>[set xs]\\<^sub>\\<nu>))))\n    \\<le> (2 ^ 2 ^ Suc n) ^ length ys", "by (rule list_prod_const) (rule 1)"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>ys. card\n                                 (DCA.nodes\n                                   (\\<AA>\\<^sub>\\<nu>_FG\n                                     (\\<psi>[set xs]\\<^sub>\\<nu>))))\n  \\<le> (2 ^ 2 ^ Suc n) ^ length ys\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<psi>\\<leftarrow>ys. card\n                                 (DCA.nodes\n                                   (\\<AA>\\<^sub>\\<nu>_FG\n                                     (\\<psi>[set xs]\\<^sub>\\<nu>))))\n  \\<le> (2 ^ 2 ^ Suc n) ^ length ys\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"\\<dots> \\<le> (2 ^ 2 ^ Suc n) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ Suc n) ^ length ys \\<le> (2 ^ 2 ^ Suc n) ^ n", "by (simp add: assms(1) power_increasing)"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ length ys \\<le> (2 ^ 2 ^ Suc n) ^ n\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ length ys \\<le> (2 ^ 2 ^ Suc n) ^ n\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"\\<dots> \\<le> 2 ^ (n * 2 ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ Suc n) ^ n \\<le> 2 ^ (n * 2 ^ Suc n)", "by (metis le_refl mult.commute power_mult)"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ n \\<le> 2 ^ (n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ Suc n) ^ n \\<le> 2 ^ (n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"\\<dots> \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)", "by (cases \\<open>n > 0\\<close>) (simp_all add: floorlog_bounds less_imp_le_nat)"], ["proof (state)\nthis:\n  2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "also"], ["proof (state)\nthis:\n  2 ^ (n * 2 ^ Suc n) \\<le> 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "have \"\\<dots> = 2 ^ 2 ^ (n + floorlog 2 n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n) = 2 ^ 2 ^ (n + floorlog 2 n + 1)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ (2 ^ floorlog 2 n * 2 ^ Suc n) = 2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "finally"], ["proof (chain)\npicking this:\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)", "."], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>\\<^sub>1_nodes_finite:\n  \"finite (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))", "unfolding \\<AA>\\<^sub>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DCA.nodes (\\<CC> \\<phi> (set xs)))", "by (metis (no_types, lifting) finite_subset \\<CC>_nodes finite_SigmaI nested_prop_atoms\\<^sub>\\<nu>_finite nested_prop_atoms_finite)"], ["", "lemma \\<AA>\\<^sub>1_nodes_card:\n  assumes\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "let ?fst = \"{Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "let ?snd = \"{Abs \\<psi> | \\<psi>. nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have 1: \"card (nested_prop_atoms \\<phi>) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (nested_prop_atoms \\<phi>) \\<le> n", "by (meson card_mono[OF subfrmlsn_finite nested_prop_atoms_subfrmlsn] assms le_trans)"], ["proof (state)\nthis:\n  card (nested_prop_atoms \\<phi>) \\<le> n\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have \"card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> card (?fst \\<times> ?snd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))\n    \\<le> card\n           ({Abs \\<psi> |\\<psi>.\n             nested_prop_atoms \\<psi>\n             \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n            {Abs \\<psi> |\\<psi>.\n             nested_prop_atoms \\<psi>\n             \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)})", "unfolding \\<AA>\\<^sub>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<CC> \\<phi> (set xs)))\n    \\<le> card\n           ({Abs \\<psi> |\\<psi>.\n             nested_prop_atoms \\<psi>\n             \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n            {Abs \\<psi> |\\<psi>.\n             nested_prop_atoms \\<psi>\n             \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)})", "by (rule card_mono) (simp_all add: \\<CC>_nodes nested_prop_atoms\\<^sub>\\<nu>_finite nested_prop_atoms_finite)"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))\n  \\<le> card\n         ({Abs \\<psi> |\\<psi>.\n           nested_prop_atoms \\<psi>\n           \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n          {Abs \\<psi> |\\<psi>.\n           nested_prop_atoms \\<psi>\n           \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)})\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "also"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs))\n  \\<le> card\n         ({Abs \\<psi> |\\<psi>.\n           nested_prop_atoms \\<psi>\n           \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n          {Abs \\<psi> |\\<psi>.\n           nested_prop_atoms \\<psi>\n           \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)})\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have \"\\<dots> = card ?fst * card ?snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({Abs \\<psi> |\\<psi>.\n       nested_prop_atoms \\<psi>\n       \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n      {Abs \\<psi> |\\<psi>.\n       nested_prop_atoms \\<psi>\n       \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}) =\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}", "using nested_prop_atoms\\<^sub>\\<nu>_finite card_cartesian_product"], ["proof (prove)\nusing this:\n  finite\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> ?\\<phi> ?X}\n  card (?A \\<times> ?B) = card ?A * card ?B\n\ngoal (1 subgoal):\n 1. card\n     ({Abs \\<psi> |\\<psi>.\n       nested_prop_atoms \\<psi>\n       \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n      {Abs \\<psi> |\\<psi>.\n       nested_prop_atoms \\<psi>\n       \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}) =\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}", "by blast"], ["proof (state)\nthis:\n  card\n   ({Abs \\<psi> |\\<psi>.\n     nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n    {Abs \\<psi> |\\<psi>.\n     nested_prop_atoms \\<psi>\n     \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}) =\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "also"], ["proof (state)\nthis:\n  card\n   ({Abs \\<psi> |\\<psi>.\n     nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} \\<times>\n    {Abs \\<psi> |\\<psi>.\n     nested_prop_atoms \\<psi>\n     \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}) =\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have \"\\<dots> \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) * 2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n          2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "using nested_prop_atoms\\<^sub>\\<nu>_card nested_prop_atoms_card mult_le_mono"], ["proof (prove)\nusing this:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> ?\\<phi> ?X}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms ?\\<phi>)\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms ?\\<phi>}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms ?\\<phi>)\n  \\<lbrakk>?i \\<le> ?j; ?k \\<le> ?l\\<rbrakk>\n  \\<Longrightarrow> ?i * ?k \\<le> ?j * ?l\n\ngoal (1 subgoal):\n 1. card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n    card\n     {Abs \\<psi> |\\<psi>.\n      nested_prop_atoms \\<psi>\n      \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n    \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n          2 ^ 2 ^ card (nested_prop_atoms \\<phi>)", "by blast"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n        2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "also"], ["proof (state)\nthis:\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi> \\<subseteq> nested_prop_atoms \\<phi>} *\n  card\n   {Abs \\<psi> |\\<psi>.\n    nested_prop_atoms \\<psi>\n    \\<subseteq> nested_prop_atoms\\<^sub>\\<nu> \\<phi> (set xs)}\n  \\<le> 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n        2 ^ 2 ^ card (nested_prop_atoms \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have \"\\<dots> = 2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n    2 ^ 2 ^ card (nested_prop_atoms \\<phi>) =\n    2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1)", "by (simp add: semiring_normalization_rules(36))"], ["proof (state)\nthis:\n  2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n  2 ^ 2 ^ card (nested_prop_atoms \\<phi>) =\n  2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "also"], ["proof (state)\nthis:\n  2 ^ 2 ^ card (nested_prop_atoms \\<phi>) *\n  2 ^ 2 ^ card (nested_prop_atoms \\<phi>) =\n  2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "have \"\\<dots> \\<le> 2 ^ 2 ^ (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1) \\<le> 2 ^ 2 ^ (n + 1)", "using assms 1"], ["proof (prove)\nusing this:\n  card (subfrmlsn \\<phi>) \\<le> n\n  card (nested_prop_atoms \\<phi>) \\<le> n\n\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1) \\<le> 2 ^ 2 ^ (n + 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ 2 ^ (card (nested_prop_atoms \\<phi>) + 1) \\<le> 2 ^ 2 ^ (n + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "finally"], ["proof (chain)\npicking this:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)", "."], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) \\<le> 2 ^ 2 ^ (n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<AA>'_nodes_finite:\n  \"finite (DRA.nodes (\\<AA>' \\<phi> xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DRA.nodes (\\<AA>' \\<phi> xs ys))", "unfolding \\<AA>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))", "using intersect_nodes_finite intersect_bc_nodes_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DCA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DCA.nodes (DCA_Combine.intersect ?A ?B))\n  \\<lbrakk>finite (DBA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DRA.nodes (intersect_bc ?A ?B))\n\ngoal (1 subgoal):\n 1. finite\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))", "using \\<AA>\\<^sub>1_nodes_finite \\<AA>\\<^sub>2_nodes_finite \\<AA>\\<^sub>3_nodes_finite"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (DCA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DCA.nodes (DCA_Combine.intersect ?A ?B))\n  \\<lbrakk>finite (DBA.nodes ?A); finite (DCA.nodes ?B)\\<rbrakk>\n  \\<Longrightarrow> finite (DRA.nodes (intersect_bc ?A ?B))\n  finite (DCA.nodes (\\<AA>\\<^sub>1 ?\\<phi> ?xs))\n  finite (DBA.nodes (\\<AA>\\<^sub>2 ?xs ?ys))\n  finite (DCA.nodes (\\<AA>\\<^sub>3 ?xs ?ys))\n\ngoal (1 subgoal):\n 1. finite\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))", "by fast"], ["", "lemma \\<AA>'_nodes_card:\n  assumes\n    \"length xs \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set xs \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  and\n    \"length ys \\<le> n\"\n  and\n    \"\\<And>\\<psi>. \\<psi> \\<in> set ys \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\"\n  and\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DRA.nodes (\\<AA>' \\<phi> xs ys)) \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "have \"n + 1 \\<le> n + floorlog 2 n + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 \\<le> n + floorlog 2 n + 2", "by auto"], ["proof (state)\nthis:\n  n + 1 \\<le> n + floorlog 2 n + 2\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "then"], ["proof (chain)\npicking this:\n  n + 1 \\<le> n + floorlog 2 n + 2", "have 1: \"(2::nat) ^ (n + 1) \\<le> 2 ^ (n + floorlog 2 n + 2)\""], ["proof (prove)\nusing this:\n  n + 1 \\<le> n + floorlog 2 n + 2\n\ngoal (1 subgoal):\n 1. 2 ^ (n + 1) \\<le> 2 ^ (n + floorlog 2 n + 2)", "using one_le_numeral power_increasing"], ["proof (prove)\nusing this:\n  n + 1 \\<le> n + floorlog 2 n + 2\n  (1::?'a) \\<le> numeral ?n\n  \\<lbrakk>?n \\<le> ?N; (1::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a ^ ?n \\<le> ?a ^ ?N\n\ngoal (1 subgoal):\n 1. 2 ^ (n + 1) \\<le> 2 ^ (n + floorlog 2 n + 2)", "by blast"], ["proof (state)\nthis:\n  2 ^ (n + 1) \\<le> 2 ^ (n + floorlog 2 n + 2)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "have \"card (DRA.nodes (\\<AA>' \\<phi> xs ys)) \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) * card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) * card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\" (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n          card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n          card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "proof (unfold \\<AA>'_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. card\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))\n    \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n          card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n          card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "have \"card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) * card (DCA.nodes (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs) (\\<AA>\\<^sub>3 xs ys))) \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n    card\n     (DCA.nodes\n       (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n         (\\<AA>\\<^sub>3 xs ys)))\n    \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n          card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n          card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "by (simp add: intersect_nodes_card[OF \\<AA>\\<^sub>1_nodes_finite \\<AA>\\<^sub>3_nodes_finite])"], ["proof (state)\nthis:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n  card\n   (DCA.nodes\n     (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n       (\\<AA>\\<^sub>3 xs ys)))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n\ngoal (1 subgoal):\n 1. card\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))\n    \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n          card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n          card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "then"], ["proof (chain)\npicking this:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n  card\n   (DCA.nodes\n     (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n       (\\<AA>\\<^sub>3 xs ys)))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "show \"card (DRA.nodes (intersect_bc (\\<AA>\\<^sub>2 xs ys) (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs) (\\<AA>\\<^sub>3 xs ys)))) \\<le> ?rhs\""], ["proof (prove)\nusing this:\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n  card\n   (DCA.nodes\n     (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n       (\\<AA>\\<^sub>3 xs ys)))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n\ngoal (1 subgoal):\n 1. card\n     (DRA.nodes\n       (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n         (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n           (\\<AA>\\<^sub>3 xs ys))))\n    \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n          card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n          card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))", "by (meson intersect_bc_nodes_card[OF \\<AA>\\<^sub>2_nodes_finite intersect_nodes_finite[OF \\<AA>\\<^sub>1_nodes_finite \\<AA>\\<^sub>3_nodes_finite]] basic_trans_rules(23))"], ["proof (state)\nthis:\n  card\n   (DRA.nodes\n     (intersect_bc (\\<AA>\\<^sub>2 xs ys)\n       (DCA_Combine.intersect (\\<AA>\\<^sub>1 \\<phi> xs)\n         (\\<AA>\\<^sub>3 xs ys))))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n  \\<le> card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n        card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n        card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "have \"\\<dots> \\<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) * 2 ^ 2 ^ (n + floorlog 2 n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n    card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n    card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n          2 ^ 2 ^ (n + floorlog 2 n + 1)", "using \\<AA>\\<^sub>1_nodes_card[OF assms(5)] \\<AA>\\<^sub>2_nodes_card[OF assms(1,2)] \\<AA>\\<^sub>3_nodes_card[OF assms(3,4)]"], ["proof (prove)\nusing this:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> ?xs)) \\<le> 2 ^ 2 ^ (n + 1)\n  (\\<And>\\<psi>.\n      \\<psi> \\<in> set xs \\<Longrightarrow>\n      \\<psi> \\<in> set xs) \\<Longrightarrow>\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ?ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 2)\n  (\\<And>\\<psi>.\n      \\<psi> \\<in> set ys \\<Longrightarrow>\n      \\<psi> \\<in> set ys) \\<Longrightarrow>\n  card (DCA.nodes (\\<AA>\\<^sub>3 ?xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal (1 subgoal):\n 1. card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n    card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n    card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n    \\<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n          2 ^ 2 ^ (n + floorlog 2 n + 1)", "by (metis mult_le_mono)"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n        2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  card (DCA.nodes (\\<AA>\\<^sub>1 \\<phi> xs)) *\n  card (DBA.nodes (\\<AA>\\<^sub>2 xs ys)) *\n  card (DCA.nodes (\\<AA>\\<^sub>3 xs ys))\n  \\<le> 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n        2 ^ 2 ^ (n + floorlog 2 n + 1)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "have \"\\<dots> = 2 ^ (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n    2 ^ 2 ^ (n + floorlog 2 n + 1) =\n    2 ^\n    (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))", "by (metis power_add)"], ["proof (state)\nthis:\n  2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n  2 ^ 2 ^ (n + floorlog 2 n + 1) =\n  2 ^\n  (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  2 ^ 2 ^ (n + 1) * 2 ^ 2 ^ (n + floorlog 2 n + 2) *\n  2 ^ 2 ^ (n + floorlog 2 n + 1) =\n  2 ^\n  (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "have \"\\<dots> \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^\n    (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\n    \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))", "using 1"], ["proof (prove)\nusing this:\n  2 ^ (n + 1) \\<le> 2 ^ (n + floorlog 2 n + 2)\n\ngoal (1 subgoal):\n 1. 2 ^\n    (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\n    \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))", "by auto"], ["proof (state)\nthis:\n  2 ^\n  (2 ^ (n + 1) + 2 ^ (n + floorlog 2 n + 2) + 2 ^ (n + floorlog 2 n + 1))\n  \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "finally"], ["proof (chain)\npicking this:\n  card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n  \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))", "show ?thesis"], ["proof (prove)\nusing this:\n  card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n  \\<le> 2 ^ (4 * 2 ^ (n + floorlog 2 n + 2))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n    \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)", "by (simp add: numeral.simps(2) power_add)"], ["proof (state)\nthis:\n  card (DRA.nodes (\\<AA>' \\<phi> xs ys))\n  \\<le> 2 ^ 2 ^ (n + floorlog 2 n + 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subformula_nested_prop_atoms_subfrmlsn:\n  \"\\<psi> \\<in> subfrmlsn \\<phi> \\<Longrightarrow> nested_prop_atoms \\<psi> \\<subseteq> subfrmlsn \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> subfrmlsn \\<phi> \\<Longrightarrow>\n    nested_prop_atoms \\<psi> \\<subseteq> subfrmlsn \\<phi>", "using nested_prop_atoms_subfrmlsn subfrmlsn_subset"], ["proof (prove)\nusing this:\n  nested_prop_atoms ?\\<phi> \\<subseteq> subfrmlsn ?\\<phi>\n  ?\\<psi> \\<in> subfrmlsn ?\\<phi> \\<Longrightarrow>\n  subfrmlsn ?\\<psi> \\<subseteq> subfrmlsn ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> subfrmlsn \\<phi> \\<Longrightarrow>\n    nested_prop_atoms \\<psi> \\<subseteq> subfrmlsn \\<phi>", "by blast"], ["", "lemma ltl_to_dra_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DRA.nodes (ltl_to_dra \\<phi>))", "unfolding ltl_to_dra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (DRA.nodes\n       (DRA_Combine.union_list\n         (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))))", "apply (rule DRA_Combine.union_list_nodes_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DRA.nodes)\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))", "apply (simp add: split_def \\<AA>'_alphabet advice_sets_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DRA.nodes)\n     (map (\\<lambda>p. \\<AA>' \\<phi> (fst p) (snd p)) (advice_sets \\<phi>))", "apply (simp add: list.pred_set split_def \\<AA>'_nodes_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ltl_to_dra_restricted_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra_restricted \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DRA.nodes (ltl_to_dra_restricted \\<phi>))", "unfolding ltl_to_dra_restricted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (DRA.nodes\n       (DRA_Combine.union_list\n         (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n           (restricted_advice_sets \\<phi>))))", "apply (rule DRA_Combine.union_list_nodes_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DRA.nodes)\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n       (restricted_advice_sets \\<phi>))", "apply (simp add: split_def \\<AA>'_alphabet advice_sets_not_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DRA.nodes)\n     (map (\\<lambda>p. \\<AA>' \\<phi> (fst p) (snd p))\n       (restricted_advice_sets \\<phi>))", "apply (simp add: list.pred_set split_def \\<AA>'_nodes_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ltl_to_dra_alphabet_nodes_finite:\n  \"finite (DRA.nodes (ltl_to_dra_alphabet \\<phi> AP))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DRA.nodes (ltl_to_dra_alphabet \\<phi> AP))", "using ltl_to_dra_alphabet_nodes ltl_to_dra_restricted_nodes_finite finite_subset"], ["proof (prove)\nusing this:\n  DRA.nodes (ltl_to_dra_alphabet ?\\<phi> ?Ap)\n  \\<subseteq> DRA.nodes (ltl_to_dra_restricted ?\\<phi>)\n  finite (DRA.nodes (ltl_to_dra_restricted ?\\<phi>))\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (DRA.nodes (ltl_to_dra_alphabet \\<phi> AP))", "by fast"], ["", "lemma ltl_to_dra_nodes_card:\n  assumes\n    \"card (subfrmlsn \\<phi>) \\<le> n\"\n  shows\n    \"card (DRA.nodes (ltl_to_dra \\<phi>)) \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "let ?map = \"map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have 1: \"\\<And>x::nat. x > 0 \\<Longrightarrow> x ^ length (advice_sets \\<phi>) \\<le> x ^ 2 ^ card (subfrmlsn \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       0 < x \\<Longrightarrow>\n       x ^ length (advice_sets \\<phi>) \\<le> x ^ 2 ^ card (subfrmlsn \\<phi>)", "by (metis advice_sets_length linorder_not_less nat_power_less_imp_less)"], ["proof (state)\nthis:\n  0 < ?x1 \\<Longrightarrow>\n  ?x1 ^ length (advice_sets \\<phi>) \\<le> ?x1 ^ 2 ^ card (subfrmlsn \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"card (DRA.nodes (ltl_to_dra \\<phi>)) \\<le> prod_list (map (card \\<circ> DRA.nodes) ?map)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> prod_list\n           (map (card \\<circ> DRA.nodes)\n             (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n               (advice_sets \\<phi>)))", "unfolding ltl_to_dra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (DRA.nodes\n       (DRA_Combine.union_list\n         (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))))\n    \\<le> prod_list\n           (map (card \\<circ> DRA.nodes)\n             (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y)\n               (advice_sets \\<phi>)))", "apply (rule DRA_Combine.union_list_nodes_card)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (finite \\<circ> DRA.nodes)\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))", "unfolding list.pred_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball\n     (set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n     (finite \\<circ> DRA.nodes)", "using \\<AA>'_nodes_finite"], ["proof (prove)\nusing this:\n  finite (DRA.nodes (\\<AA>' ?\\<phi> ?xs ?ys))\n\ngoal (1 subgoal):\n 1. Ball\n     (set (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n     (finite \\<circ> DRA.nodes)", "by auto"], ["proof (state)\nthis:\n  card (DRA.nodes (ltl_to_dra \\<phi>))\n  \\<le> prod_list\n         (map (card \\<circ> DRA.nodes)\n           (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  card (DRA.nodes (ltl_to_dra \\<phi>))\n  \\<le> prod_list\n         (map (card \\<circ> DRA.nodes)\n           (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>)))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> = (\\<Prod>(x, y)\\<leftarrow>advice_sets \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list\n     (map (card \\<circ> DRA.nodes)\n       (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n    (\\<Prod>(x,\n        y)\\<leftarrow>advice_sets\n                       \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))", "by (induction \"advice_sets \\<phi>\") (auto, metis (no_types, lifting) comp_apply split_def)"], ["proof (state)\nthis:\n  prod_list\n   (map (card \\<circ> DRA.nodes)\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n  (\\<Prod>(x,\n      y)\\<leftarrow>advice_sets\n                     \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  prod_list\n   (map (card \\<circ> DRA.nodes)\n     (map (\\<lambda>(x, y). \\<AA>' \\<phi> x y) (advice_sets \\<phi>))) =\n  (\\<Prod>(x,\n      y)\\<leftarrow>advice_sets\n                     \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        y)\\<leftarrow>advice_sets\n                       \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\n    \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)", "proof (rule list_prod_const, unfold split_def, rule \\<AA>'_nodes_card)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (fst x) \\<le> n\n 2. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (fst x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 3. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (snd x) \\<le> n\n 4. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 5. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       card (subfrmlsn \\<phi>) \\<le> n", "show \"\\<And>x. x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow> length (fst x) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (fst x) \\<le> n", "using advice_sets_element_length assms"], ["proof (prove)\nusing this:\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  length ?xs \\<le> card (subfrmlsn ?\\<phi>)\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  length ?ys \\<le> card (subfrmlsn ?\\<phi>)\n  card (subfrmlsn \\<phi>) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (fst x) \\<le> n", "by fastforce"], ["proof (state)\nthis:\n  ?x1 \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n  length (fst ?x1) \\<le> n\n\ngoal (4 subgoals):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (fst x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 2. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (snd x) \\<le> n\n 3. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 4. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       card (subfrmlsn \\<phi>) \\<le> n", "show \"\\<And>x \\<psi>. \\<lbrakk>x \\<in> set (advice_sets \\<phi>); \\<psi> \\<in> set (fst x)\\<rbrakk> \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (fst x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n", "using advice_sets_element_subfrmlsn(1) assms subformula_nested_prop_atoms_subfrmlsn subformulas\\<^sub>\\<mu>_subfrmlsn"], ["proof (prove)\nusing this:\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  set ?xs \\<subseteq> subformulas\\<^sub>\\<mu> ?\\<phi>\n  card (subfrmlsn \\<phi>) \\<le> n\n  ?\\<psi> \\<in> subfrmlsn ?\\<phi> \\<Longrightarrow>\n  nested_prop_atoms ?\\<psi> \\<subseteq> subfrmlsn ?\\<phi>\n  subformulas\\<^sub>\\<mu> ?\\<phi> \\<subseteq> subfrmlsn ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (fst x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n", "by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> set (advice_sets \\<phi>);\n   ?\\<psi>1 \\<in> set (fst ?x1)\\<rbrakk>\n  \\<Longrightarrow> card (nested_prop_atoms ?\\<psi>1) \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (snd x) \\<le> n\n 2. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 3. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       card (subfrmlsn \\<phi>) \\<le> n", "show \"\\<And>x. x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow> length (snd x) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (snd x) \\<le> n", "using advice_sets_element_length assms"], ["proof (prove)\nusing this:\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  length ?xs \\<le> card (subfrmlsn ?\\<phi>)\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  length ?ys \\<le> card (subfrmlsn ?\\<phi>)\n  card (subfrmlsn \\<phi>) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       length (snd x) \\<le> n", "by fastforce"], ["proof (state)\nthis:\n  ?x1 \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n  length (snd ?x1) \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\n 2. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       card (subfrmlsn \\<phi>) \\<le> n", "show \"\\<And>x \\<psi>. \\<lbrakk>x \\<in> set (advice_sets \\<phi>); \\<psi> \\<in> set (snd x)\\<rbrakk> \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n", "using advice_sets_element_subfrmlsn(2) assms subformula_nested_prop_atoms_subfrmlsn subformulas\\<^sub>\\<nu>_subfrmlsn"], ["proof (prove)\nusing this:\n  (?xs, ?ys) \\<in> set (advice_sets ?\\<phi>) \\<Longrightarrow>\n  set ?ys \\<subseteq> subformulas\\<^sub>\\<nu> ?\\<phi>\n  card (subfrmlsn \\<phi>) \\<le> n\n  ?\\<psi> \\<in> subfrmlsn ?\\<phi> \\<Longrightarrow>\n  nested_prop_atoms ?\\<psi> \\<subseteq> subfrmlsn ?\\<phi>\n  subformulas\\<^sub>\\<nu> ?\\<phi> \\<subseteq> subfrmlsn ?\\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<psi>.\n       \\<lbrakk>x \\<in> set (advice_sets \\<phi>);\n        \\<psi> \\<in> set (snd x)\\<rbrakk>\n       \\<Longrightarrow> card (nested_prop_atoms \\<psi>) \\<le> n", "by (metis (no_types, lifting) card_mono subfrmlsn_finite subset_iff sup.absorb_iff2 sup.coboundedI1 surjective_pairing)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> set (advice_sets \\<phi>);\n   ?\\<psi>1 \\<in> set (snd ?x1)\\<rbrakk>\n  \\<Longrightarrow> card (nested_prop_atoms ?\\<psi>1) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (advice_sets \\<phi>) \\<Longrightarrow>\n       card (subfrmlsn \\<phi>) \\<le> n", "qed (insert assms, blast)"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      y)\\<leftarrow>advice_sets\n                     \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      y)\\<leftarrow>advice_sets\n                     \\<phi>. card (DRA.nodes (\\<AA>' \\<phi> x y)))\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ card (subfrmlsn \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\n    \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)", "by (simp add: 1)"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ length (advice_sets \\<phi>)\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ (2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)\n    \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n", "by (simp add: assms power_increasing)"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ card (subfrmlsn \\<phi>)\n  \\<le> (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> = 2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n =\n    2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))", "by (simp add: ac_simps power_mult [symmetric])"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n =\n  2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "also"], ["proof (state)\nthis:\n  (2 ^ 2 ^ (n + floorlog 2 n + 4)) ^ 2 ^ n =\n  2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4))\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "have \"\\<dots> = 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4)) =\n    2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "by (simp add: power_add) (simp add: mult_2 power_add)"], ["proof (state)\nthis:\n  2 ^ (2 ^ n * 2 ^ (n + floorlog 2 n + 4)) =\n  2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "finally"], ["proof (chain)\npicking this:\n  card (DRA.nodes (ltl_to_dra \\<phi>))\n  \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (DRA.nodes (ltl_to_dra \\<phi>))\n  \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)", "."], ["proof (state)\nthis:\n  card (DRA.nodes (ltl_to_dra \\<phi>))\n  \\<le> 2 ^ 2 ^ (2 * n + floorlog 2 n + 4)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We verify the size bound of the automaton to be double exponential.\\<close>"], ["", "theorem ltl_to_dra_size:\n  \"card (DRA.nodes (ltl_to_dra \\<phi>)) \\<le> 2 ^ 2 ^ (2 * size \\<phi> + floorlog 2 (size \\<phi>) + 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * size \\<phi> + floorlog 2 (size \\<phi>) + 4)", "using ltl_to_dra_nodes_card subfrmlsn_card"], ["proof (prove)\nusing this:\n  card (subfrmlsn ?\\<phi>) \\<le> ?n \\<Longrightarrow>\n  card (DRA.nodes (ltl_to_dra ?\\<phi>))\n  \\<le> 2 ^ 2 ^ (2 * ?n + floorlog 2 ?n + 4)\n  card (subfrmlsn ?\\<phi>) \\<le> size ?\\<phi>\n\ngoal (1 subgoal):\n 1. card (DRA.nodes (ltl_to_dra \\<phi>))\n    \\<le> 2 ^ 2 ^ (2 * size \\<phi> + floorlog 2 (size \\<phi>) + 4)", "by blast"], ["", "end"], ["", "end"]]}