{"file_name": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders/Kruskal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders", "problem_names": ["lemma mk_inject [iff]:\n  assumes \"(f, length ss) \\<in> F\" and \"(g, length ts) \\<in> F\"\n  shows \"mk f ss = mk g ts \\<longleftrightarrow> f = g \\<and> ss = ts\"", "lemma almost_full_on_trees:\n  assumes \"almost_full_on P F\"\n  shows \"almost_full_on (emb P) trees\" (is \"almost_full_on ?P ?A\")", "lemma list_emb_trans_right:\n  assumes \"list_emb P xs ys\" and \"list_emb (\\<lambda>y z. P y z \\<and> (\\<forall>x. P x y \\<longrightarrow> P x z)) ys zs\" \n  shows \"list_emb P xs zs\"", "lemma emb_trans:\n  assumes trans: \"\\<And>f g h. f \\<in> F \\<Longrightarrow> g \\<in> F \\<Longrightarrow> h \\<in> F \\<Longrightarrow> P f g \\<Longrightarrow> P g h \\<Longrightarrow> P f h\"\n  assumes \"emb P s t\" and \"emb P t u\"\n  shows \"emb P s u\"", "lemma transp_on_emb:\n  assumes \"transp_on P F\"\n  shows \"transp_on (emb P) trees\"", "lemma kruskal:\n  assumes \"wqo_on P F\"\n  shows \"wqo_on (emb P) trees\""], "translations": [["", "lemma mk_inject [iff]:\n  assumes \"(f, length ss) \\<in> F\" and \"(g, length ts) \\<in> F\"\n  shows \"mk f ss = mk g ts \\<longleftrightarrow> f = g \\<and> ss = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "assume \"mk f ss = mk g ts\""], ["proof (state)\nthis:\n  mk f ss = mk g ts\n\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "then"], ["proof (chain)\npicking this:\n  mk f ss = mk g ts", "have \"root (mk f ss) = root (mk g ts)\"\n      and \"args (mk f ss) = args (mk g ts)\""], ["proof (prove)\nusing this:\n  mk f ss = mk g ts\n\ngoal (1 subgoal):\n 1. root (mk f ss) = root (mk g ts) &&& args (mk f ss) = args (mk g ts)", "by auto"], ["proof (state)\nthis:\n  root (mk f ss) = root (mk g ts)\n  args (mk f ss) = args (mk g ts)\n\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "}"], ["proof (state)\nthis:\n  mk f ss = mk g ts \\<Longrightarrow> root (mk f ss) = root (mk g ts)\n  mk f ss = mk g ts \\<Longrightarrow> args (mk f ss) = args (mk g ts)\n\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "using root_mk [OF assms(1)] and root_mk [OF assms(2)]\n      and args_mk [OF assms(1)] and args_mk [OF assms(2)]"], ["proof (prove)\nusing this:\n  root (mk f ss) = (f, length ss)\n  root (mk g ts) = (g, length ts)\n  args (mk f ss) = ss\n  args (mk g ts) = ts\n\ngoal (1 subgoal):\n 1. (mk f ss = mk g ts) = (f = g \\<and> ss = ts)", "by auto"], ["proof (state)\nthis:\n  (mk f ss = mk g ts) = (f = g \\<and> ss = ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive emb for P\nwhere\n  arg: \"\\<lbrakk>(f, m) \\<in> F; length ts = m; \\<forall>t\\<in>set ts. t \\<in> trees;\n    t \\<in> set ts; emb P s t\\<rbrakk> \\<Longrightarrow> emb P s (mk f ts)\" |\n  list_emb: \"\\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m; length ts = n;\n    \\<forall>s \\<in> set ss. s \\<in> trees; \\<forall>t \\<in> set ts. t \\<in> trees;\n    P (f, m) (g, n); list_emb (emb P) ss ts\\<rbrakk> \\<Longrightarrow> emb P (mk f ss) (mk g ts)\"\n  monos list_emb_mono"], ["", "lemma almost_full_on_trees:\n  assumes \"almost_full_on P F\"\n  shows \"almost_full_on (emb P) trees\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (emb P) trees", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "interpret mbs ?A"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> almost_full_on (emb P) trees\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "from mbs' [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>BAD (emb P).\n     \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g", "obtain m\n    where bad: \"m \\<in> BAD ?P\"\n    and min: \"\\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good ?P g\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>BAD (emb P).\n     \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> BAD (emb P);\n         \\<forall>g.\n            (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m \\<in> BAD (emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  m \\<in> BAD (emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g", "have trees: \"\\<And>i. m i \\<in> trees\""], ["proof (prove)\nusing this:\n  m \\<in> BAD (emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g\n\ngoal (1 subgoal):\n 1. \\<And>i. m i \\<in> trees", "by auto"], ["proof (state)\nthis:\n  m ?i \\<in> trees\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "define r where \"r i = root (m i)\" for i"], ["proof (state)\nthis:\n  r ?i = root (m ?i)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "define a where \"a i = args (m i)\" for i"], ["proof (state)\nthis:\n  a ?i = args (m ?i)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "define S where \"S = \\<Union>{set (a i) | i. True}\""], ["proof (state)\nthis:\n  S = \\<Union> {set (a i) |i. True}\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have m: \"\\<And>i. m i = mk (fst (r i)) (a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. m i = mk (fst (r i)) (a i)", "by (simp add: r_def a_def mk_root_args [OF trees])"], ["proof (state)\nthis:\n  m ?i = mk (fst (r ?i)) (a ?i)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have lists: \"\\<forall>i. a i \\<in> lists S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. a i \\<in> lists S", "by (auto simp: a_def S_def)"], ["proof (state)\nthis:\n  \\<forall>i. a i \\<in> lists S\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have arity: \"\\<And>i. length (a i) = snd (r i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. length (a i) = snd (r i)", "using trees_arity [OF trees]"], ["proof (prove)\nusing this:\n  length (args (m ?i1)) = snd (root (m ?i1))\n\ngoal (1 subgoal):\n 1. \\<And>i. length (a i) = snd (r i)", "by (auto simp: r_def a_def)"], ["proof (state)\nthis:\n  length (a ?i) = snd (r ?i)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  length (a ?i) = snd (r ?i)", "have sig: \"\\<And>i. (fst (r i), length (a i)) \\<in> F\""], ["proof (prove)\nusing this:\n  length (a ?i) = snd (r ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i. (fst (r i), length (a i)) \\<in> F", "using trees_root [OF trees]"], ["proof (prove)\nusing this:\n  length (a ?i) = snd (r ?i)\n  root (m ?i1) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>i. (fst (r i), length (a i)) \\<in> F", "by (auto simp: a_def r_def)"], ["proof (state)\nthis:\n  (fst (r ?i), length (a ?i)) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have a_trees: \"\\<And>i. \\<forall>t \\<in> set (a i). t \\<in> trees\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. \\<forall>t\\<in>set (a i). t \\<in> trees", "by (auto simp: a_def trees_args [OF trees])"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (a ?i). t \\<in> trees\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have \"almost_full_on ?P S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (emb P) S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> almost_full_on (emb P) S\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> almost_full_on (emb P) S", "obtain s :: \"nat \\<Rightarrow> 'a\"\n      where S: \"\\<And>i. s i \\<in> S\" and bad_s: \"bad ?P s\""], ["proof (prove)\nusing this:\n  \\<not> almost_full_on (emb P) S\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<And>i. s i \\<in> S; bad (emb P) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: almost_full_on_def)"], ["proof (state)\nthis:\n  s ?i \\<in> S\n  bad (emb P) s\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "define n where \"n = (LEAST n. \\<exists>k. s k \\<in> set (a n))\""], ["proof (state)\nthis:\n  n = (LEAST n. \\<exists>k. s k \\<in> set (a n))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have \"\\<exists>n. \\<exists>k. s k \\<in> set (a n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n k. s k \\<in> set (a n)", "using S"], ["proof (prove)\nusing this:\n  s ?i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>n k. s k \\<in> set (a n)", "by (force simp: S_def)"], ["proof (state)\nthis:\n  \\<exists>n k. s k \\<in> set (a n)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "from LeastI_ex [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>k. s k \\<in> set (a (LEAST n. \\<exists>k. s k \\<in> set (a n)))", "obtain k\n      where sk: \"s k \\<in> set (a n)\""], ["proof (prove)\nusing this:\n  \\<exists>k. s k \\<in> set (a (LEAST n. \\<exists>k. s k \\<in> set (a n)))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        s k \\<in> set (a n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  s k \\<in> set (a n)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have args: \"\\<And>k. \\<exists>m \\<ge> n. s k \\<in> set (a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>m\\<ge>n. s k \\<in> set (a m)", "using S"], ["proof (prove)\nusing this:\n  s ?i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>m\\<ge>n. s k \\<in> set (a m)", "by (auto simp: S_def) (metis Least_le n_def)"], ["proof (state)\nthis:\n  \\<exists>m\\<ge>n. s ?k \\<in> set (a m)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "define m' where \"m' i = (if i < n then m i else s (k + (i - n)))\" for i"], ["proof (state)\nthis:\n  m' ?i = (if ?i < n then m ?i else s (k + (?i - n)))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have m'_less: \"\\<And>i. i < n \\<Longrightarrow> m' i = m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> m' i = m i", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> m' ?i = m ?i\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have m'_geq: \"\\<And>i. i \\<ge> n \\<Longrightarrow> m' i = s (k + (i - n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. n \\<le> i \\<Longrightarrow> m' i = s (k + (i - n))", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  n \\<le> ?i \\<Longrightarrow> m' ?i = s (k + (?i - n))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have \"bad ?P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad (emb P) m'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "assume \"good ?P m'\""], ["proof (state)\nthis:\n  good (emb P) m'\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  good (emb P) m'", "obtain i j where \"i < j\" and emb: \"?P (m' i) (m' j)\""], ["proof (prove)\nusing this:\n  good (emb P) m'\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; emb P (m' i) (m' j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  emb P (m' i) (m' j)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  i < j\n  emb P (m' i) (m' j)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "assume \"j < n\""], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  emb P (m' i) (m' j)\n  j < n", "have \"?P (m i) (m j)\""], ["proof (prove)\nusing this:\n  i < j\n  emb P (m' i) (m' j)\n  j < n\n\ngoal (1 subgoal):\n 1. emb P (m i) (m j)", "by (auto simp: m'_less)"], ["proof (state)\nthis:\n  emb P (m i) (m j)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and bad"], ["proof (chain)\npicking this:\n  i < j\n  m \\<in> BAD (emb P)\n  emb P (m i) (m j)", "have False"], ["proof (prove)\nusing this:\n  i < j\n  m \\<in> BAD (emb P)\n  emb P (m i) (m j)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  j < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  j < n \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "assume \"n \\<le> i\""], ["proof (state)\nthis:\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  emb P (m' i) (m' j)\n  n \\<le> i", "have \"?P (s (k + (i - n))) (s (k + (j - n)))\"\n          and \"k + (i - n) < k + (j - n)\""], ["proof (prove)\nusing this:\n  i < j\n  emb P (m' i) (m' j)\n  n \\<le> i\n\ngoal (1 subgoal):\n 1. emb P (s (k + (i - n))) (s (k + (j - n))) &&& k + (i - n) < k + (j - n)", "by (auto simp: m'_geq)"], ["proof (state)\nthis:\n  emb P (s (k + (i - n))) (s (k + (j - n)))\n  k + (i - n) < k + (j - n)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with bad_s"], ["proof (chain)\npicking this:\n  bad (emb P) s\n  emb P (s (k + (i - n))) (s (k + (j - n)))\n  k + (i - n) < k + (j - n)", "have False"], ["proof (prove)\nusing this:\n  bad (emb P) s\n  emb P (s (k + (i - n))) (s (k + (j - n)))\n  k + (i - n) < k + (j - n)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  n \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  n \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "assume \"i < n\" and \"n \\<le> j\""], ["proof (state)\nthis:\n  i < n\n  n \\<le> j\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  emb P (m' i) (m' j)\n  i < n\n  n \\<le> j", "have *: \"?P (m i) (s (k + (j - n)))\""], ["proof (prove)\nusing this:\n  i < j\n  emb P (m' i) (m' j)\n  i < n\n  n \\<le> j\n\ngoal (1 subgoal):\n 1. emb P (m i) (s (k + (j - n)))", "by (auto simp: m'_less m'_geq)"], ["proof (state)\nthis:\n  emb P (m i) (s (k + (j - n)))\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "with args"], ["proof (chain)\npicking this:\n  \\<exists>m\\<ge>n. s ?k \\<in> set (a m)\n  emb P (m i) (s (k + (j - n)))", "obtain l where \"l \\<ge> n\" and **: \"s (k + (j - n)) \\<in> set (a l)\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>n. s ?k \\<in> set (a m)\n  emb P (m i) (s (k + (j - n)))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n \\<le> l; s (k + (j - n)) \\<in> set (a l)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n \\<le> l\n  s (k + (j - n)) \\<in> set (a l)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "from emb.arg [OF sig [of l] _ a_trees [of l] ** *]"], ["proof (chain)\npicking this:\n  length (a l) = length (a l) \\<Longrightarrow>\n  emb P (m i) (mk (fst (r l)) (a l))", "have \"?P (m i) (m l)\""], ["proof (prove)\nusing this:\n  length (a l) = length (a l) \\<Longrightarrow>\n  emb P (m i) (mk (fst (r l)) (a l))\n\ngoal (1 subgoal):\n 1. emb P (m i) (m l)", "by (simp add: m)"], ["proof (state)\nthis:\n  emb P (m i) (m l)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  emb P (m i) (m l)\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "have \"i < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < l", "using \\<open>i < n\\<close> and \\<open>n \\<le> l\\<close>"], ["proof (prove)\nusing this:\n  i < n\n  n \\<le> l\n\ngoal (1 subgoal):\n 1. i < l", "by auto"], ["proof (state)\nthis:\n  i < l\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  emb P (m i) (m l)\n  i < l", "have False"], ["proof (prove)\nusing this:\n  emb P (m i) (m l)\n  i < l\n\ngoal (1 subgoal):\n 1. False", "using bad"], ["proof (prove)\nusing this:\n  emb P (m i) (m l)\n  i < l\n  m \\<in> BAD (emb P)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < n; n \\<le> j\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (emb P) m' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j < n \\<Longrightarrow> False\n  n \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < n; n \\<le> j\\<rbrakk> \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  j < n \\<Longrightarrow> False\n  n \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < n; n \\<le> j\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  j < n \\<Longrightarrow> False\n  n \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < n; n \\<le> j\\<rbrakk> \\<Longrightarrow> False\n  i < j\n\ngoal (1 subgoal):\n 1. False", "by arith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bad (emb P) m'\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bad (emb P) m'\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "have \"(m, m') \\<in> gseq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "have \"m \\<in> SEQ ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> SEQ trees", "using trees"], ["proof (prove)\nusing this:\n  m ?i \\<in> trees\n\ngoal (1 subgoal):\n 1. m \\<in> SEQ trees", "by auto"], ["proof (state)\nthis:\n  m \\<in> SEQ trees\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "moreover"], ["proof (state)\nthis:\n  m \\<in> SEQ trees\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "have \"m' \\<in> SEQ ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<in> SEQ trees", "using trees and S and trees_args [OF trees]"], ["proof (prove)\nusing this:\n  m ?i \\<in> trees\n  s ?i \\<in> S\n  ?s \\<in> set (args (m ?i1)) \\<Longrightarrow> ?s \\<in> trees\n\ngoal (1 subgoal):\n 1. m' \\<in> SEQ trees", "by (auto simp: m'_def a_def S_def)"], ["proof (state)\nthis:\n  m' \\<in> SEQ trees\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "moreover"], ["proof (state)\nthis:\n  m' \\<in> SEQ trees\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "have \"\\<forall>i < n. m i = m' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. m i = m' i", "by (auto simp: m'_less)"], ["proof (state)\nthis:\n  \\<forall>i<n. m i = m' i\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<n. m i = m' i\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "have \"size (m' n) < size (m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (m' n) < size (m n)", "using sk and size_arg [OF trees, unfolded m]"], ["proof (prove)\nusing this:\n  s k \\<in> set (a n)\n  ?s \\<in> set (args (mk (fst (r ?i1)) (a ?i1))) \\<Longrightarrow>\n  size ?s < size (mk (fst (r ?i1)) (a ?i1))\n\ngoal (1 subgoal):\n 1. size (m' n) < size (m n)", "by (auto simp: m m'_geq root_mk [OF sig] args_mk [OF sig])"], ["proof (state)\nthis:\n  size (m' n) < size (m n)\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "ultimately"], ["proof (chain)\npicking this:\n  m \\<in> SEQ trees\n  m' \\<in> SEQ trees\n  \\<forall>i<n. m i = m' i\n  size (m' n) < size (m n)", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> SEQ trees\n  m' \\<in> SEQ trees\n  \\<forall>i<n. m i = m' i\n  size (m' n) < size (m n)\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "by (auto simp: gseq_def)"], ["proof (state)\nthis:\n  (m, m') \\<in> gseq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (m, m') \\<in> gseq\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) S \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bad (emb P) m'\n  (m, m') \\<in> gseq", "show False"], ["proof (prove)\nusing this:\n  bad (emb P) m'\n  (m, m') \\<in> gseq\n\ngoal (1 subgoal):\n 1. False", "using min"], ["proof (prove)\nusing this:\n  bad (emb P) m'\n  (m, m') \\<in> gseq\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (emb P) g\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (emb P) S\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "from almost_full_on_lists [OF this, THEN almost_full_on_imp_homogeneous_subseq, OF lists]"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and>\n        list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))", "obtain \\<phi> :: \"nat \\<Rightarrow> nat\"\n    where less: \"\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j\"\n      and lemb: \"\\<And>i j. i < j \\<Longrightarrow> list_emb ?P (a (\\<phi> i)) (a (\\<phi> j))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and>\n        list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j;\n         \\<And>i j.\n            i < j \\<Longrightarrow>\n            list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  ?i < ?j \\<Longrightarrow> list_emb (emb P) (a (\\<phi> ?i)) (a (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "have roots: \"\\<And>i. r (\\<phi> i) \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. r (\\<phi> i) \\<in> F", "using trees [THEN trees_root]"], ["proof (prove)\nusing this:\n  root (m ?i1) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>i. r (\\<phi> i) \\<in> F", "by (auto simp: r_def)"], ["proof (state)\nthis:\n  r (\\<phi> ?i) \\<in> F\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r (\\<phi> ?i) \\<in> F", "have \"r \\<circ> \\<phi> \\<in> SEQ F\""], ["proof (prove)\nusing this:\n  r (\\<phi> ?i) \\<in> F\n\ngoal (1 subgoal):\n 1. r \\<circ> \\<phi> \\<in> SEQ F", "by auto"], ["proof (state)\nthis:\n  r \\<circ> \\<phi> \\<in> SEQ F\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  almost_full_on P F\n  r \\<circ> \\<phi> \\<in> SEQ F", "have \"good P (r \\<circ> \\<phi>)\""], ["proof (prove)\nusing this:\n  almost_full_on P F\n  r \\<circ> \\<phi> \\<in> SEQ F\n\ngoal (1 subgoal):\n 1. good P (r \\<circ> \\<phi>)", "by (auto simp: almost_full_on_def)"], ["proof (state)\nthis:\n  good P (r \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  good P (r \\<circ> \\<phi>)", "obtain i j\n    where \"i < j\" and \"P (r (\\<phi> i)) (r (\\<phi> j))\""], ["proof (prove)\nusing this:\n  good P (r \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; P (r (\\<phi> i)) (r (\\<phi> j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  P (r (\\<phi> i)) (r (\\<phi> j))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "with lemb [OF \\<open>i < j\\<close>]"], ["proof (chain)\npicking this:\n  list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))\n  i < j\n  P (r (\\<phi> i)) (r (\\<phi> j))", "have \"?P (m (\\<phi> i)) (m (\\<phi> j))\""], ["proof (prove)\nusing this:\n  list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))\n  i < j\n  P (r (\\<phi> i)) (r (\\<phi> j))\n\ngoal (1 subgoal):\n 1. emb P (m (\\<phi> i)) (m (\\<phi> j))", "using sig and arity and a_trees"], ["proof (prove)\nusing this:\n  list_emb (emb P) (a (\\<phi> i)) (a (\\<phi> j))\n  i < j\n  P (r (\\<phi> i)) (r (\\<phi> j))\n  (fst (r ?i), length (a ?i)) \\<in> F\n  length (a ?i) = snd (r ?i)\n  \\<forall>t\\<in>set (a ?i). t \\<in> trees\n\ngoal (1 subgoal):\n 1. emb P (m (\\<phi> i)) (m (\\<phi> j))", "by (auto simp: m intro!: emb.list_emb)"], ["proof (state)\nthis:\n  emb P (m (\\<phi> i)) (m (\\<phi> j))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (emb P) trees \\<Longrightarrow> False", "with less [OF \\<open>i < j\\<close>] and bad"], ["proof (chain)\npicking this:\n  \\<phi> i < \\<phi> j\n  m \\<in> BAD (emb P)\n  emb P (m (\\<phi> i)) (m (\\<phi> j))", "show False"], ["proof (prove)\nusing this:\n  \\<phi> i < \\<phi> j\n  m \\<in> BAD (emb P)\n  emb P (m (\\<phi> i)) (m (\\<phi> j))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive_cases\n  emb_mk2 [consumes 1, case_names arg list_emb]: \"emb P s (mk g ts)\""], ["", "inductive_cases\n  list_emb_Nil2_cases: \"list_emb P xs []\" and\n  list_emb_Cons_cases: \"list_emb P xs (y#ys)\""], ["", "lemma list_emb_trans_right:\n  assumes \"list_emb P xs ys\" and \"list_emb (\\<lambda>y z. P y z \\<and> (\\<forall>x. P x y \\<longrightarrow> P x z)) ys zs\" \n  shows \"list_emb P xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_emb P xs zs", "using assms(2, 1)"], ["proof (prove)\nusing this:\n  list_emb\n   (\\<lambda>y z. P y z \\<and> (\\<forall>x. P x y \\<longrightarrow> P x z))\n   ys zs\n  list_emb P xs ys\n\ngoal (1 subgoal):\n 1. list_emb P xs zs", "by (induct arbitrary: xs) (auto elim!: list_emb_Nil2_cases list_emb_Cons_cases)"], ["", "lemma emb_trans:\n  assumes trans: \"\\<And>f g h. f \\<in> F \\<Longrightarrow> g \\<in> F \\<Longrightarrow> h \\<in> F \\<Longrightarrow> P f g \\<Longrightarrow> P g h \\<Longrightarrow> P f h\"\n  assumes \"emb P s t\" and \"emb P t u\"\n  shows \"emb P s u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emb P s u", "using assms(3, 2)"], ["proof (prove)\nusing this:\n  emb P t u\n  emb P s t\n\ngoal (1 subgoal):\n 1. emb P s u", "proof (induct arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f m ts t s sa.\n       \\<lbrakk>(f, m) \\<in> F; length ts = m;\n        \\<forall>t\\<in>set ts. t \\<in> trees; t \\<in> set ts; emb P s t;\n        \\<And>sa. emb P sa s \\<Longrightarrow> emb P sa t;\n        emb P sa s\\<rbrakk>\n       \\<Longrightarrow> emb P sa (mk f ts)\n 2. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "case (arg f m ts v)"], ["proof (state)\nthis:\n  (f, m) \\<in> F\n  length ts = m\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  v \\<in> set ts\n  emb P s_ v\n  emb P ?s s_ \\<Longrightarrow> emb P ?s v\n  emb P s s_\n\ngoal (2 subgoals):\n 1. \\<And>f m ts t s sa.\n       \\<lbrakk>(f, m) \\<in> F; length ts = m;\n        \\<forall>t\\<in>set ts. t \\<in> trees; t \\<in> set ts; emb P s t;\n        \\<And>sa. emb P sa s \\<Longrightarrow> emb P sa t;\n        emb P sa s\\<rbrakk>\n       \\<Longrightarrow> emb P sa (mk f ts)\n 2. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "then"], ["proof (chain)\npicking this:\n  (f, m) \\<in> F\n  length ts = m\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  v \\<in> set ts\n  emb P s_ v\n  emb P ?s s_ \\<Longrightarrow> emb P ?s v\n  emb P s s_", "show ?case"], ["proof (prove)\nusing this:\n  (f, m) \\<in> F\n  length ts = m\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  v \\<in> set ts\n  emb P s_ v\n  emb P ?s s_ \\<Longrightarrow> emb P ?s v\n  emb P s s_\n\ngoal (1 subgoal):\n 1. emb P s (mk f ts)", "by (auto intro: emb.arg)"], ["proof (state)\nthis:\n  emb P s (mk f ts)\n\ngoal (1 subgoal):\n 1. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "case (list_emb f m g n ss ts)"], ["proof (state)\nthis:\n  (f, m) \\<in> F\n  (g, n) \\<in> F\n  length ss = m\n  length ts = n\n  \\<forall>s\\<in>set ss. s \\<in> trees\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  P (f, m) (g, n)\n  list_emb\n   (\\<lambda>x1 x2.\n       emb P x1 x2 \\<and>\n       (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n   ss ts\n  emb P s (mk f ss)\n\ngoal (1 subgoal):\n 1. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "note IH = this"], ["proof (state)\nthis:\n  (f, m) \\<in> F\n  (g, n) \\<in> F\n  length ss = m\n  length ts = n\n  \\<forall>s\\<in>set ss. s \\<in> trees\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  P (f, m) (g, n)\n  list_emb\n   (\\<lambda>x1 x2.\n       emb P x1 x2 \\<and>\n       (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n   ss ts\n  emb P s (mk f ss)\n\ngoal (1 subgoal):\n 1. \\<And>f m g n ss ts s.\n       \\<lbrakk>(f, m) \\<in> F; (g, n) \\<in> F; length ss = m;\n        length ts = n; \\<forall>s\\<in>set ss. s \\<in> trees;\n        \\<forall>t\\<in>set ts. t \\<in> trees; P (f, m) (g, n);\n        list_emb\n         (\\<lambda>x1 x2.\n             emb P x1 x2 \\<and>\n             (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n         ss ts;\n        emb P s (mk f ss)\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "from \\<open>emb P s (mk f ss)\\<close>"], ["proof (chain)\npicking this:\n  emb P s (mk f ss)", "show ?case"], ["proof (prove)\nusing this:\n  emb P s (mk f ss)\n\ngoal (1 subgoal):\n 1. emb P s (mk g ts)", "proof (cases rule: emb_mk2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa tsa t.\n       \\<lbrakk>mk f ss = mk fa tsa; (fa, length tsa) \\<in> F;\n        \\<forall>t\\<in>set tsa. t \\<in> trees; t \\<in> set tsa;\n        emb P s t\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)\n 2. \\<And>fa ga ssa tsa.\n       \\<lbrakk>s = mk fa ssa; mk f ss = mk ga tsa;\n        (fa, length ssa) \\<in> F; (ga, length tsa) \\<in> F;\n        \\<forall>s\\<in>set ssa. s \\<in> trees;\n        \\<forall>t\\<in>set tsa. t \\<in> trees;\n        P (fa, length ssa) (ga, length tsa);\n        list_emb (emb P) ssa tsa\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "case arg"], ["proof (state)\nthis:\n  mk f ss = mk f_ ts_\n  (f_, length ts_) \\<in> F\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  t_ \\<in> set ts_\n  emb P s t_\n\ngoal (2 subgoals):\n 1. \\<And>fa tsa t.\n       \\<lbrakk>mk f ss = mk fa tsa; (fa, length tsa) \\<in> F;\n        \\<forall>t\\<in>set tsa. t \\<in> trees; t \\<in> set tsa;\n        emb P s t\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)\n 2. \\<And>fa ga ssa tsa.\n       \\<lbrakk>s = mk fa ssa; mk f ss = mk ga tsa;\n        (fa, length ssa) \\<in> F; (ga, length tsa) \\<in> F;\n        \\<forall>s\\<in>set ssa. s \\<in> trees;\n        \\<forall>t\\<in>set tsa. t \\<in> trees;\n        P (fa, length ssa) (ga, length tsa);\n        list_emb (emb P) ssa tsa\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "then"], ["proof (chain)\npicking this:\n  mk f ss = mk f_ ts_\n  (f_, length ts_) \\<in> F\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  t_ \\<in> set ts_\n  emb P s t_", "show ?thesis"], ["proof (prove)\nusing this:\n  mk f ss = mk f_ ts_\n  (f_, length ts_) \\<in> F\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  t_ \\<in> set ts_\n  emb P s t_\n\ngoal (1 subgoal):\n 1. emb P s (mk g ts)", "using IH"], ["proof (prove)\nusing this:\n  mk f ss = mk f_ ts_\n  (f_, length ts_) \\<in> F\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  t_ \\<in> set ts_\n  emb P s t_\n  (f, m) \\<in> F\n  (g, n) \\<in> F\n  length ss = m\n  length ts = n\n  \\<forall>s\\<in>set ss. s \\<in> trees\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  P (f, m) (g, n)\n  list_emb\n   (\\<lambda>x1 x2.\n       emb P x1 x2 \\<and>\n       (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n   ss ts\n  emb P s (mk f ss)\n\ngoal (1 subgoal):\n 1. emb P s (mk g ts)", "by (auto elim!: list_emb_set intro: emb.arg)"], ["proof (state)\nthis:\n  emb P s (mk g ts)\n\ngoal (1 subgoal):\n 1. \\<And>fa ga ssa tsa.\n       \\<lbrakk>s = mk fa ssa; mk f ss = mk ga tsa;\n        (fa, length ssa) \\<in> F; (ga, length tsa) \\<in> F;\n        \\<forall>s\\<in>set ssa. s \\<in> trees;\n        \\<forall>t\\<in>set tsa. t \\<in> trees;\n        P (fa, length ssa) (ga, length tsa);\n        list_emb (emb P) ssa tsa\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa ga ssa tsa.\n       \\<lbrakk>s = mk fa ssa; mk f ss = mk ga tsa;\n        (fa, length ssa) \\<in> F; (ga, length tsa) \\<in> F;\n        \\<forall>s\\<in>set ssa. s \\<in> trees;\n        \\<forall>t\\<in>set tsa. t \\<in> trees;\n        P (fa, length ssa) (ga, length tsa);\n        list_emb (emb P) ssa tsa\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "case list_emb"], ["proof (state)\nthis:\n  s = mk f_ ss_\n  mk f ss = mk g_ ts_\n  (f_, length ss_) \\<in> F\n  (g_, length ts_) \\<in> F\n  \\<forall>s\\<in>set ss_. s \\<in> trees\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  P (f_, length ss_) (g_, length ts_)\n  list_emb (emb P) ss_ ts_\n\ngoal (1 subgoal):\n 1. \\<And>fa ga ssa tsa.\n       \\<lbrakk>s = mk fa ssa; mk f ss = mk ga tsa;\n        (fa, length ssa) \\<in> F; (ga, length tsa) \\<in> F;\n        \\<forall>s\\<in>set ssa. s \\<in> trees;\n        \\<forall>t\\<in>set tsa. t \\<in> trees;\n        P (fa, length ssa) (ga, length tsa);\n        list_emb (emb P) ssa tsa\\<rbrakk>\n       \\<Longrightarrow> emb P s (mk g ts)", "then"], ["proof (chain)\npicking this:\n  s = mk f_ ss_\n  mk f ss = mk g_ ts_\n  (f_, length ss_) \\<in> F\n  (g_, length ts_) \\<in> F\n  \\<forall>s\\<in>set ss_. s \\<in> trees\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  P (f_, length ss_) (g_, length ts_)\n  list_emb (emb P) ss_ ts_", "show ?thesis"], ["proof (prove)\nusing this:\n  s = mk f_ ss_\n  mk f ss = mk g_ ts_\n  (f_, length ss_) \\<in> F\n  (g_, length ts_) \\<in> F\n  \\<forall>s\\<in>set ss_. s \\<in> trees\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  P (f_, length ss_) (g_, length ts_)\n  list_emb (emb P) ss_ ts_\n\ngoal (1 subgoal):\n 1. emb P s (mk g ts)", "using IH"], ["proof (prove)\nusing this:\n  s = mk f_ ss_\n  mk f ss = mk g_ ts_\n  (f_, length ss_) \\<in> F\n  (g_, length ts_) \\<in> F\n  \\<forall>s\\<in>set ss_. s \\<in> trees\n  \\<forall>t\\<in>set ts_. t \\<in> trees\n  P (f_, length ss_) (g_, length ts_)\n  list_emb (emb P) ss_ ts_\n  (f, m) \\<in> F\n  (g, n) \\<in> F\n  length ss = m\n  length ts = n\n  \\<forall>s\\<in>set ss. s \\<in> trees\n  \\<forall>t\\<in>set ts. t \\<in> trees\n  P (f, m) (g, n)\n  list_emb\n   (\\<lambda>x1 x2.\n       emb P x1 x2 \\<and>\n       (\\<forall>x. emb P x x1 \\<longrightarrow> emb P x x2))\n   ss ts\n  emb P s (mk f ss)\n\ngoal (1 subgoal):\n 1. emb P s (mk g ts)", "by (auto intro: emb.intros dest: trans list_emb_trans_right)"], ["proof (state)\nthis:\n  emb P s (mk g ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emb P s (mk g ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transp_on_emb:\n  assumes \"transp_on P F\"\n  shows \"transp_on (emb P) trees\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp_on (emb P) trees", "using assms and emb_trans [of P]"], ["proof (prove)\nusing this:\n  transp_on P F\n  \\<lbrakk>\\<And>f g h.\n              \\<lbrakk>f \\<in> F; g \\<in> F; h \\<in> F; P f g;\n               P g h\\<rbrakk>\n              \\<Longrightarrow> P f h;\n   emb P ?s ?t; emb P ?t ?u\\<rbrakk>\n  \\<Longrightarrow> emb P ?s ?u\n\ngoal (1 subgoal):\n 1. transp_on (emb P) trees", "unfolding transp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>F.\n     \\<forall>y\\<in>F.\n        \\<forall>z\\<in>F. P x y \\<and> P y z \\<longrightarrow> P x z\n  \\<lbrakk>\\<And>f g h.\n              \\<lbrakk>f \\<in> F; g \\<in> F; h \\<in> F; P f g;\n               P g h\\<rbrakk>\n              \\<Longrightarrow> P f h;\n   emb P ?s ?t; emb P ?t ?u\\<rbrakk>\n  \\<Longrightarrow> emb P ?s ?u\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>trees.\n       \\<forall>y\\<in>trees.\n          \\<forall>z\\<in>trees.\n             emb P x y \\<and> emb P y z \\<longrightarrow> emb P x z", "by blast"], ["", "lemma kruskal:\n  assumes \"wqo_on P F\"\n  shows \"wqo_on (emb P) trees\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wqo_on (emb P) trees", "using almost_full_on_trees [of P] and assms"], ["proof (prove)\nusing this:\n  almost_full_on P F \\<Longrightarrow> almost_full_on (emb P) trees\n  wqo_on P F\n\ngoal (1 subgoal):\n 1. wqo_on (emb P) trees", "by (metis transp_on_emb wqo_on_def)"], ["", "end"], ["", "end"]]}