{"file_name": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders/Almost_Full_Relations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders", "problem_names": ["lemma (in mbs) mbs':\n  assumes \"\\<not> almost_full_on P A\"\n  shows \"\\<exists>m \\<in> BAD P. \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good P g\"", "lemma with_bot_iff [iff]:\n  \"Some x \\<in> A\\<^sub>\\<bottom> \\<longleftrightarrow> x \\<in> A\"", "lemma NoneI [simp, intro]:\n  \"None \\<in> A\\<^sub>\\<bottom>\"", "lemma not_None_the_mem [simp]:\n  \"x \\<noteq> None \\<Longrightarrow> the x \\<in> A \\<longleftrightarrow> x \\<in> A\\<^sub>\\<bottom>\"", "lemma with_bot_cases:\n  \"u \\<in> A\\<^sub>\\<bottom> \\<Longrightarrow> (\\<And>x. x \\<in> A \\<Longrightarrow> u = Some x \\<Longrightarrow> P) \\<Longrightarrow> (u = None \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma with_bot_empty_conv [iff]:\n  \"A\\<^sub>\\<bottom> = {None} \\<longleftrightarrow> A = {}\"", "lemma with_bot_UNIV [simp]:\n  \"UNIV\\<^sub>\\<bottom> = UNIV\"", "lemma None_imp_good_option_le [simp]:\n  assumes \"f i = None\"\n  shows \"good (option_le P) f\"", "lemma almost_full_on_with_bot:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (option_le P) A\\<^sub>\\<bottom>\" (is \"almost_full_on ?P ?A\")", "lemma not_sum_le_cases:\n  assumes \"\\<not> sum_le P Q a b\"\n    and \"\\<And>x y. \\<lbrakk>a = Inl x; b = Inl y; \\<not> P x y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inr x; b = Inr y; \\<not> Q x y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inl x; b = Inr y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inr x; b = Inl y\\<rbrakk> \\<Longrightarrow> thesis\"\n  shows thesis", "lemma almost_full_on_Plus:\n  assumes \"almost_full_on P A\" and \"almost_full_on Q B\"\n  shows \"almost_full_on (sum_le P Q) (A <+> B)\" (is \"almost_full_on ?P ?A\")", "lemma prod_le_True [simp]:\n  \"prod_le P (\\<lambda>_ _. True) a b = P (fst a) (fst b)\"", "lemma almost_full_on_Sigma:\n  assumes \"almost_full_on P1 A1\" and \"almost_full_on P2 A2\"\n  shows \"almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\" (is \"almost_full_on ?P ?A\")", "lemma almost_full_on_lists:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (list_emb P) (lists A)\" (is \"almost_full_on ?P ?A\")", "lemma almost_full_on_UNIV_nat:\n  \"almost_full_on (\\<le>) (UNIV :: nat set)\""], "translations": [["", "lemma (in mbs) mbs':\n  assumes \"\\<not> almost_full_on P A\"\n  shows \"\\<exists>m \\<in> BAD P. \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good P g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>BAD P.\n       \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good P g", "using assms and mbs"], ["proof (prove)\nusing this:\n  \\<not> almost_full_on P A\n  ?h \\<in> BAD ?P \\<Longrightarrow>\n  \\<exists>f\\<in>BAD ?P.\n     \\<forall>g. (f, g) \\<in> gseq \\<longrightarrow> good ?P g\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>BAD P.\n       \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good P g", "unfolding almost_full_on_def"], ["proof (prove)\nusing this:\n  \\<not> Ball (SEQ A) (good P)\n  ?h \\<in> BAD ?P \\<Longrightarrow>\n  \\<exists>f\\<in>BAD ?P.\n     \\<forall>g. (f, g) \\<in> gseq \\<longrightarrow> good ?P g\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>BAD P.\n       \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good P g", "by blast"], ["", "(*TODO: move to Option.thy of Isabelle/HOL?*)"], ["", "subsection \\<open>Adding a Bottom Element to a Set\\<close>"], ["", "definition with_bot :: \"'a set \\<Rightarrow> 'a option set\" (\"_\\<^sub>\\<bottom>\" [1000] 1000)\nwhere\n  \"A\\<^sub>\\<bottom> = {None} \\<union> Some ` A\""], ["", "lemma with_bot_iff [iff]:\n  \"Some x \\<in> A\\<^sub>\\<bottom> \\<longleftrightarrow> x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Some x \\<in> A\\<^sub>\\<bottom>) = (x \\<in> A)", "by (auto simp: with_bot_def)"], ["", "lemma NoneI [simp, intro]:\n  \"None \\<in> A\\<^sub>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<in> A\\<^sub>\\<bottom>", "by (simp add: with_bot_def)"], ["", "lemma not_None_the_mem [simp]:\n  \"x \\<noteq> None \\<Longrightarrow> the x \\<in> A \\<longleftrightarrow> x \\<in> A\\<^sub>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> None \\<Longrightarrow>\n    (the x \\<in> A) = (x \\<in> A\\<^sub>\\<bottom>)", "by auto"], ["", "lemma with_bot_cases:\n  \"u \\<in> A\\<^sub>\\<bottom> \\<Longrightarrow> (\\<And>x. x \\<in> A \\<Longrightarrow> u = Some x \\<Longrightarrow> P) \\<Longrightarrow> (u = None \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> A\\<^sub>\\<bottom>;\n     \\<And>x. \\<lbrakk>x \\<in> A; u = Some x\\<rbrakk> \\<Longrightarrow> P;\n     u = None \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "lemma with_bot_empty_conv [iff]:\n  \"A\\<^sub>\\<bottom> = {None} \\<longleftrightarrow> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A\\<^sub>\\<bottom> = {None}) = (A = {})", "by (auto elim: with_bot_cases)"], ["", "lemma with_bot_UNIV [simp]:\n  \"UNIV\\<^sub>\\<bottom> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV\\<^sub>\\<bottom> = UNIV", "proof (rule set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> UNIV\\<^sub>\\<bottom>) = (x \\<in> UNIV)", "fix x :: \"'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> UNIV\\<^sub>\\<bottom>) = (x \\<in> UNIV)", "show \"x \\<in> UNIV\\<^sub>\\<bottom> \\<longleftrightarrow> x \\<in> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> UNIV\\<^sub>\\<bottom>) = (x \\<in> UNIV)", "by (cases x) auto"], ["proof (state)\nthis:\n  (x \\<in> UNIV\\<^sub>\\<bottom>) = (x \\<in> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Adding a Bottom Element to an Almost-Full Set\\<close>"], ["", "fun\n  option_le :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a option \\<Rightarrow> 'a option \\<Rightarrow> bool\"\nwhere\n  \"option_le P None y = True\" |\n  \"option_le P (Some x) None = False\" |\n  \"option_le P (Some x) (Some y) = P x y\""], ["", "lemma None_imp_good_option_le [simp]:\n  assumes \"f i = None\"\n  shows \"good (option_le P) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good (option_le P) f", "by (rule goodI [of i \"Suc i\"]) (auto simp: assms)"], ["", "lemma almost_full_on_with_bot:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (option_le P) A\\<^sub>\\<bottom>\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (option_le P) A\\<^sub>\\<bottom>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A\\<^sub>\\<bottom> \\<Longrightarrow>\n       good (option_le P) f", "fix f :: \"nat \\<Rightarrow> 'a option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A\\<^sub>\\<bottom> \\<Longrightarrow>\n       good (option_le P) f", "assume *: \"\\<forall>i. f i \\<in> ?A\""], ["proof (state)\nthis:\n  \\<forall>i. f i \\<in> A\\<^sub>\\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A\\<^sub>\\<bottom> \\<Longrightarrow>\n       good (option_le P) f", "show \"good ?P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good (option_le P) f", "proof (cases \"\\<forall>i. f i \\<noteq> None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "case True"], ["proof (state)\nthis:\n  \\<forall>i. f i \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. f i \\<noteq> None", "have **: \"\\<And>i. Some (the (f i)) = f i\"\n      and \"\\<And>i. the (f i) \\<in> A\""], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>i. Some (the (f i)) = f i) &&& (\\<And>i. the (f i) \\<in> A)", "using *"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<noteq> None\n  \\<forall>i. f i \\<in> A\\<^sub>\\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>i. Some (the (f i)) = f i) &&& (\\<And>i. the (f i) \\<in> A)", "by auto"], ["proof (state)\nthis:\n  Some (the (f ?i)) = f ?i\n  the (f ?i) \\<in> A\n\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "with almost_full_onD [OF assms, of \"the \\<circ> f\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i. (the \\<circ> f) i \\<in> A;\n   \\<And>i j.\n      \\<lbrakk>i < j; P ((the \\<circ> f) i) ((the \\<circ> f) j)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Some (the (f ?i)) = f ?i\n  the (f ?i) \\<in> A", "obtain i j where \"i < j\"\n      and \"P (the (f i)) (the (f j))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. (the \\<circ> f) i \\<in> A;\n   \\<And>i j.\n      \\<lbrakk>i < j; P ((the \\<circ> f) i) ((the \\<circ> f) j)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Some (the (f ?i)) = f ?i\n  the (f ?i) \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; P (the (f i)) (the (f j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  P (the (f i)) (the (f j))\n\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "then"], ["proof (chain)\npicking this:\n  i < j\n  P (the (f i)) (the (f j))", "have \"?P (Some (the (f i))) (Some (the (f j)))\""], ["proof (prove)\nusing this:\n  i < j\n  P (the (f i)) (the (f j))\n\ngoal (1 subgoal):\n 1. option_le P (Some (the (f i))) (Some (the (f j)))", "by simp"], ["proof (state)\nthis:\n  option_le P (Some (the (f i))) (Some (the (f j)))\n\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "then"], ["proof (chain)\npicking this:\n  option_le P (Some (the (f i))) (Some (the (f j)))", "have \"?P (f i) (f j)\""], ["proof (prove)\nusing this:\n  option_le P (Some (the (f i))) (Some (the (f j)))\n\ngoal (1 subgoal):\n 1. option_le P (f i) (f j)", "unfolding **"], ["proof (prove)\nusing this:\n  option_le P (f i) (f j)\n\ngoal (1 subgoal):\n 1. option_le P (f i) (f j)", "."], ["proof (state)\nthis:\n  option_le P (f i) (f j)\n\ngoal (2 subgoals):\n 1. \\<forall>i. f i \\<noteq> None \\<Longrightarrow> good (option_le P) f\n 2. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "with \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  option_le P (f i) (f j)", "show \"good ?P f\""], ["proof (prove)\nusing this:\n  i < j\n  option_le P (f i) (f j)\n\ngoal (1 subgoal):\n 1. good (option_le P) f", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (option_le P) f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. f i \\<noteq> None) \\<Longrightarrow>\n    good (option_le P) f", "qed auto"], ["proof (state)\nthis:\n  good (option_le P) f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Disjoint Union of Almost-Full Sets\\<close>"], ["", "fun\n  sum_le :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a + 'b \\<Rightarrow> 'a + 'b \\<Rightarrow> bool\"\nwhere\n  \"sum_le P Q (Inl x) (Inl y) = P x y\" |\n  \"sum_le P Q (Inr x) (Inr y) = Q x y\" |\n  \"sum_le P Q x y = False\""], ["", "lemma not_sum_le_cases:\n  assumes \"\\<not> sum_le P Q a b\"\n    and \"\\<And>x y. \\<lbrakk>a = Inl x; b = Inl y; \\<not> P x y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inr x; b = Inr y; \\<not> Q x y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inl x; b = Inr y\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<And>x y. \\<lbrakk>a = Inr x; b = Inl y\\<rbrakk> \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> sum_le P Q a b\n  \\<lbrakk>a = Inl ?x; b = Inl ?y; \\<not> P ?x ?y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>a = Inr ?x; b = Inr ?y; \\<not> Q ?x ?y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>a = Inl ?x; b = Inr ?y\\<rbrakk> \\<Longrightarrow> thesis\n  \\<lbrakk>a = Inr ?x; b = Inl ?y\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (cases a b rule: sum.exhaust [case_product sum.exhaust]) auto"], ["", "text \\<open>\n  When two sets are almost-full, then their disjoint sum is almost-full.\n\\<close>"], ["", "lemma almost_full_on_Plus:\n  assumes \"almost_full_on P A\" and \"almost_full_on Q B\"\n  shows \"almost_full_on (sum_le P Q) (A <+> B)\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (sum_le P Q) (A <+> B)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "fix f :: \"nat \\<Rightarrow> ('a + 'b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "let ?I = \"f -` Inl ` A\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "let ?J = \"f -` Inr ` B\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "assume \"\\<forall>i. f i \\<in> ?A\""], ["proof (state)\nthis:\n  \\<forall>i. f i \\<in> A <+> B\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. f i \\<in> A <+> B", "have *: \"?J = (UNIV::nat set) - ?I\""], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<in> A <+> B\n\ngoal (1 subgoal):\n 1. f -` Inr ` B = UNIV - f -` Inl ` A", "by (fastforce)"], ["proof (state)\nthis:\n  f -` Inr ` B = UNIV - f -` Inl ` A\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> A <+> B \\<Longrightarrow> good (sum_le P Q) f", "show \"good ?P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good (sum_le P Q) f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. bad (sum_le P Q) f \\<Longrightarrow> False", "assume bad: \"bad ?P f\""], ["proof (state)\nthis:\n  bad (sum_le P Q) f\n\ngoal (1 subgoal):\n 1. bad (sum_le P Q) f \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"finite ?I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "assume \"finite ?I\""], ["proof (state)\nthis:\n  finite (f -` Inl ` A)\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  finite (f -` Inl ` A)", "have \"infinite ?J\""], ["proof (prove)\nusing this:\n  finite (f -` Inl ` A)\n\ngoal (1 subgoal):\n 1. infinite (f -` Inr ` B)", "by (auto simp: *)"], ["proof (state)\nthis:\n  infinite (f -` Inr ` B)\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite (f -` Inr ` B)", "interpret infinitely_many1 \"\\<lambda>i. f i \\<in> Inr ` B\""], ["proof (prove)\nusing this:\n  infinite (f -` Inr ` B)\n\ngoal (1 subgoal):\n 1. infinitely_many1 (\\<lambda>i. f i \\<in> Inr ` B)", "by (unfold_locales) (simp add: infinite_nat_iff_unbounded)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "have [dest]: \"\\<And>i x. f (enum i) = Inl x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x. f (enum i) = Inl x \\<Longrightarrow> False", "using enum_P"], ["proof (prove)\nusing this:\n  f (enum ?i) \\<in> Inr ` B\n\ngoal (1 subgoal):\n 1. \\<And>i x. f (enum i) = Inl x \\<Longrightarrow> False", "by (auto simp: image_iff) (metis Inr_Inl_False)"], ["proof (state)\nthis:\n  f (enum ?i) = Inl ?x \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "let ?f = \"\\<lambda>i. projr (f (enum i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "have B: \"\\<And>i. ?f i \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. projr (f (enum i)) \\<in> B", "using enum_P"], ["proof (prove)\nusing this:\n  f (enum ?i) \\<in> Inr ` B\n\ngoal (1 subgoal):\n 1. \\<And>i. projr (f (enum i)) \\<in> B", "by (auto simp: image_iff) (metis sum.sel(2))"], ["proof (state)\nthis:\n  projr (f (enum ?i)) \\<in> B\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  projr (f (enum ?i)) \\<in> B\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "fix i j :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i < j", "have \"enum i < enum j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. enum i < enum j", "using enum_less"], ["proof (prove)\nusing this:\n  i < j\n  ?i < ?j \\<Longrightarrow> enum ?i < enum ?j\n\ngoal (1 subgoal):\n 1. enum i < enum j", "by auto"], ["proof (state)\nthis:\n  enum i < enum j\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "with bad"], ["proof (chain)\npicking this:\n  bad (sum_le P Q) f\n  enum i < enum j", "have \"\\<not> ?P (f (enum i)) (f (enum j))\""], ["proof (prove)\nusing this:\n  bad (sum_le P Q) f\n  enum i < enum j\n\ngoal (1 subgoal):\n 1. \\<not> sum_le P Q (f (enum i)) (f (enum j))", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))", "have \"\\<not> Q (?f i) (?f j)\""], ["proof (prove)\nusing this:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))\n\ngoal (1 subgoal):\n 1. \\<not> Q (projr (f (enum i))) (projr (f (enum j)))", "by (auto elim: not_sum_le_cases)"], ["proof (state)\nthis:\n  \\<not> Q (projr (f (enum i))) (projr (f (enum j)))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> Q (projr (f (enum ?i2))) (projr (f (enum ?j2)))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> Q (projr (f (enum ?i2))) (projr (f (enum ?j2)))", "have \"bad Q ?f\""], ["proof (prove)\nusing this:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> Q (projr (f (enum ?i2))) (projr (f (enum ?j2)))\n\ngoal (1 subgoal):\n 1. bad Q (\\<lambda>i. projr (f (enum i)))", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  bad Q (\\<lambda>i. projr (f (enum i)))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bad Q (\\<lambda>i. projr (f (enum i)))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "from \\<open>almost_full_on Q B\\<close> and B"], ["proof (chain)\npicking this:\n  almost_full_on Q B\n  projr (f (enum ?i)) \\<in> B", "have \"good Q ?f\""], ["proof (prove)\nusing this:\n  almost_full_on Q B\n  projr (f (enum ?i)) \\<in> B\n\ngoal (1 subgoal):\n 1. good Q (\\<lambda>i. projr (f (enum i)))", "by (auto simp: good_def almost_full_on_def)"], ["proof (state)\nthis:\n  good Q (\\<lambda>i. projr (f (enum i)))\n\ngoal (2 subgoals):\n 1. finite (f -` Inl ` A) \\<Longrightarrow> False\n 2. infinite (f -` Inl ` A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bad Q (\\<lambda>i. projr (f (enum i)))\n  good Q (\\<lambda>i. projr (f (enum i)))", "show False"], ["proof (prove)\nusing this:\n  bad Q (\\<lambda>i. projr (f (enum i)))\n  good Q (\\<lambda>i. projr (f (enum i)))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "assume \"infinite ?I\""], ["proof (state)\nthis:\n  infinite (f -` Inl ` A)\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  infinite (f -` Inl ` A)", "interpret infinitely_many1 \"\\<lambda>i. f i \\<in> Inl ` A\""], ["proof (prove)\nusing this:\n  infinite (f -` Inl ` A)\n\ngoal (1 subgoal):\n 1. infinitely_many1 (\\<lambda>i. f i \\<in> Inl ` A)", "by (unfold_locales) (simp add: infinite_nat_iff_unbounded)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "have [dest]: \"\\<And>i x. f (enum i) = Inr x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x. f (enum i) = Inr x \\<Longrightarrow> False", "using enum_P"], ["proof (prove)\nusing this:\n  f (enum ?i) \\<in> Inl ` A\n\ngoal (1 subgoal):\n 1. \\<And>i x. f (enum i) = Inr x \\<Longrightarrow> False", "by (auto simp: image_iff) (metis Inr_Inl_False)"], ["proof (state)\nthis:\n  f (enum ?i) = Inr ?x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "let ?f = \"\\<lambda>i. projl (f (enum i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "have A: \"\\<forall>i. ?f i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. projl (f (enum i)) \\<in> A", "using enum_P"], ["proof (prove)\nusing this:\n  f (enum ?i) \\<in> Inl ` A\n\ngoal (1 subgoal):\n 1. \\<forall>i. projl (f (enum i)) \\<in> A", "by (auto simp: image_iff) (metis sum.sel(1))"], ["proof (state)\nthis:\n  \\<forall>i. projl (f (enum i)) \\<in> A\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<forall>i. projl (f (enum i)) \\<in> A\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "fix i j :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i < j", "have \"enum i < enum j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. enum i < enum j", "using enum_less"], ["proof (prove)\nusing this:\n  i < j\n  ?i < ?j \\<Longrightarrow> enum ?i < enum ?j\n\ngoal (1 subgoal):\n 1. enum i < enum j", "by auto"], ["proof (state)\nthis:\n  enum i < enum j\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "with bad"], ["proof (chain)\npicking this:\n  bad (sum_le P Q) f\n  enum i < enum j", "have \"\\<not> ?P (f (enum i)) (f (enum j))\""], ["proof (prove)\nusing this:\n  bad (sum_le P Q) f\n  enum i < enum j\n\ngoal (1 subgoal):\n 1. \\<not> sum_le P Q (f (enum i)) (f (enum j))", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))", "have \"\\<not> P (?f i) (?f j)\""], ["proof (prove)\nusing this:\n  \\<not> sum_le P Q (f (enum i)) (f (enum j))\n\ngoal (1 subgoal):\n 1. \\<not> P (projl (f (enum i))) (projl (f (enum j)))", "by (auto elim: not_sum_le_cases)"], ["proof (state)\nthis:\n  \\<not> P (projl (f (enum i))) (projl (f (enum j)))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> P (projl (f (enum ?i2))) (projl (f (enum ?j2)))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> P (projl (f (enum ?i2))) (projl (f (enum ?j2)))", "have \"bad P ?f\""], ["proof (prove)\nusing this:\n  ?i2 < ?j2 \\<Longrightarrow>\n  \\<not> P (projl (f (enum ?i2))) (projl (f (enum ?j2)))\n\ngoal (1 subgoal):\n 1. bad P (\\<lambda>i. projl (f (enum i)))", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  bad P (\\<lambda>i. projl (f (enum i)))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bad P (\\<lambda>i. projl (f (enum i)))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "from \\<open>almost_full_on P A\\<close> and A"], ["proof (chain)\npicking this:\n  almost_full_on P A\n  \\<forall>i. projl (f (enum i)) \\<in> A", "have \"good P ?f\""], ["proof (prove)\nusing this:\n  almost_full_on P A\n  \\<forall>i. projl (f (enum i)) \\<in> A\n\ngoal (1 subgoal):\n 1. good P (\\<lambda>i. projl (f (enum i)))", "by (auto simp: good_def almost_full_on_def)"], ["proof (state)\nthis:\n  good P (\\<lambda>i. projl (f (enum i)))\n\ngoal (1 subgoal):\n 1. infinite (f -` Inl ` A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bad P (\\<lambda>i. projl (f (enum i)))\n  good P (\\<lambda>i. projl (f (enum i)))", "show False"], ["proof (prove)\nusing this:\n  bad P (\\<lambda>i. projl (f (enum i)))\n  good P (\\<lambda>i. projl (f (enum i)))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  good (sum_le P Q) f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Dickson's Lemma for Almost-Full Relations\\<close>"], ["", "text \\<open>\n  When two sets are almost-full, then their Cartesian product is almost-full.\n\\<close>"], ["", "definition\n  prod_le :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> 'a \\<times> 'b \\<Rightarrow> bool\"\nwhere\n  \"prod_le P1 P2 = (\\<lambda>(p1, p2) (q1, q2). P1 p1 q1 \\<and> P2 p2 q2)\""], ["", "lemma prod_le_True [simp]:\n  \"prod_le P (\\<lambda>_ _. True) a b = P (fst a) (fst b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_le P (\\<lambda>_ _. True) a b = P (fst a) (fst b)", "by (auto simp: prod_le_def)"], ["", "lemma almost_full_on_Sigma:\n  assumes \"almost_full_on P1 A1\" and \"almost_full_on P2 A2\"\n  shows \"almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (prod_le P1 P2) (A1 \\<times> A2)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "assume \"\\<not> almost_full_on ?P ?A\""], ["proof (state)\nthis:\n  \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2)", "obtain f where f: \"\\<forall>i. f i \\<in> ?A\"\n    and bad: \"bad ?P f\""], ["proof (prove)\nusing this:\n  \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<forall>i. f i \\<in> A1 \\<times> A2;\n         bad (prod_le P1 P2) f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: almost_full_on_def)"], ["proof (state)\nthis:\n  \\<forall>i. f i \\<in> A1 \\<times> A2\n  bad (prod_le P1 P2) f\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "let ?W = \"\\<lambda>x y. P1 (fst x) (fst y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "let ?B = \"\\<lambda>x y. P2 (snd x) (snd y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "from f"], ["proof (chain)\npicking this:\n  \\<forall>i. f i \\<in> A1 \\<times> A2", "have fst: \"\\<forall>i. fst (f i) \\<in> A1\" and snd: \"\\<forall>i. snd (f i) \\<in> A2\""], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<in> A1 \\<times> A2\n\ngoal (1 subgoal):\n 1. \\<forall>i. fst (f i) \\<in> A1 &&& \\<forall>i. snd (f i) \\<in> A2", "by (metis SigmaE fst_conv, metis SigmaE snd_conv)"], ["proof (state)\nthis:\n  \\<forall>i. fst (f i) \\<in> A1\n  \\<forall>i. snd (f i) \\<in> A2\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "from almost_full_on_imp_homogeneous_subseq [OF assms(1) fst]"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and>\n        P1 (fst (f (\\<phi> i))) (fst (f (\\<phi> j)))", "obtain \\<phi> :: \"nat \\<Rightarrow> nat\" where mono: \"\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j\"\n    and *: \"\\<And>i j. i < j \\<Longrightarrow> ?W (f (\\<phi> i)) (f (\\<phi> j))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and>\n        P1 (fst (f (\\<phi> i))) (fst (f (\\<phi> j)))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j;\n         \\<And>i j.\n            i < j \\<Longrightarrow>\n            P1 (fst (f (\\<phi> i))) (fst (f (\\<phi> j)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?i2 < ?j2 \\<Longrightarrow> \\<phi> ?i2 < \\<phi> ?j2\n  ?i2 < ?j2 \\<Longrightarrow>\n  P1 (fst (f (\\<phi> ?i2))) (fst (f (\\<phi> ?j2)))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "from snd"], ["proof (chain)\npicking this:\n  \\<forall>i. snd (f i) \\<in> A2", "have \"\\<forall>i. snd (f (\\<phi> i)) \\<in> A2\""], ["proof (prove)\nusing this:\n  \\<forall>i. snd (f i) \\<in> A2\n\ngoal (1 subgoal):\n 1. \\<forall>i. snd (f (\\<phi> i)) \\<in> A2", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. snd (f (\\<phi> i)) \\<in> A2\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. snd (f (\\<phi> i)) \\<in> A2", "have \"snd \\<circ> f \\<circ> \\<phi> \\<in> SEQ A2\""], ["proof (prove)\nusing this:\n  \\<forall>i. snd (f (\\<phi> i)) \\<in> A2\n\ngoal (1 subgoal):\n 1. snd \\<circ> f \\<circ> \\<phi> \\<in> SEQ A2", "by auto"], ["proof (state)\nthis:\n  snd \\<circ> f \\<circ> \\<phi> \\<in> SEQ A2\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "with assms(2)"], ["proof (chain)\npicking this:\n  almost_full_on P2 A2\n  snd \\<circ> f \\<circ> \\<phi> \\<in> SEQ A2", "have \"good P2 (snd \\<circ> f \\<circ> \\<phi>)\""], ["proof (prove)\nusing this:\n  almost_full_on P2 A2\n  snd \\<circ> f \\<circ> \\<phi> \\<in> SEQ A2\n\ngoal (1 subgoal):\n 1. good P2 (snd \\<circ> f \\<circ> \\<phi>)", "by (auto simp: almost_full_on_def)"], ["proof (state)\nthis:\n  good P2 (snd \\<circ> f \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  good P2 (snd \\<circ> f \\<circ> \\<phi>)", "obtain i j :: nat\n    where \"i < j\" and \"?B (f (\\<phi> i)) (f (\\<phi> j))\""], ["proof (prove)\nusing this:\n  good P2 (snd \\<circ> f \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j;\n         P2 (snd (f (\\<phi> i))) (snd (f (\\<phi> j)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  P2 (snd (f (\\<phi> i))) (snd (f (\\<phi> j)))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "with * [OF \\<open>i < j\\<close>]"], ["proof (chain)\npicking this:\n  P1 (fst (f (\\<phi> i))) (fst (f (\\<phi> j)))\n  i < j\n  P2 (snd (f (\\<phi> i))) (snd (f (\\<phi> j)))", "have \"?P (f (\\<phi> i)) (f (\\<phi> j))\""], ["proof (prove)\nusing this:\n  P1 (fst (f (\\<phi> i))) (fst (f (\\<phi> j)))\n  i < j\n  P2 (snd (f (\\<phi> i))) (snd (f (\\<phi> j)))\n\ngoal (1 subgoal):\n 1. prod_le P1 P2 (f (\\<phi> i)) (f (\\<phi> j))", "by (simp add: case_prod_beta prod_le_def)"], ["proof (state)\nthis:\n  prod_le P1 P2 (f (\\<phi> i)) (f (\\<phi> j))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (prod_le P1 P2) (A1 \\<times> A2) \\<Longrightarrow>\n    False", "with mono [OF \\<open>i < j\\<close>] and bad"], ["proof (chain)\npicking this:\n  \\<phi> i < \\<phi> j\n  bad (prod_le P1 P2) f\n  prod_le P1 P2 (f (\\<phi> i)) (f (\\<phi> j))", "show False"], ["proof (prove)\nusing this:\n  \\<phi> i < \\<phi> j\n  bad (prod_le P1 P2) f\n  prod_le P1 P2 (f (\\<phi> i)) (f (\\<phi> j))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Higman's Lemma for Almost-Full Relations\\<close>"], ["", "lemma almost_full_on_lists:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (list_emb P) (lists A)\" (is \"almost_full_on ?P ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (list_emb P) (lists A)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "interpret mbs ?A"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> almost_full_on (list_emb P) (lists A)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "from mbs' [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>BAD (list_emb P).\n     \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g", "obtain m\n    where bad: \"m \\<in> BAD ?P\"\n    and min: \"\\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good ?P g\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>BAD (list_emb P).\n     \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> BAD (list_emb P);\n         \\<forall>g.\n            (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  m \\<in> BAD (list_emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  m \\<in> BAD (list_emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g", "have lists: \"\\<And>i. m i \\<in> lists A\"\n    and ne: \"\\<And>i. m i \\<noteq> []\""], ["proof (prove)\nusing this:\n  m \\<in> BAD (list_emb P)\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g\n\ngoal (1 subgoal):\n 1. (\\<And>i. m i \\<in> lists A) &&& (\\<And>i. m i \\<noteq> [])", "by auto"], ["proof (state)\nthis:\n  m ?i \\<in> lists A\n  m ?i \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "define h t where \"h = (\\<lambda>i. hd (m i))\" and \"t = (\\<lambda>i. tl (m i))\""], ["proof (state)\nthis:\n  h = (\\<lambda>i. hd (m i))\n  t = (\\<lambda>i. tl (m i))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have m: \"\\<And>i. m i = h i # t i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. m i = h i # t i", "using ne"], ["proof (prove)\nusing this:\n  m ?i \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i. m i = h i # t i", "by (simp add: h_def t_def)"], ["proof (state)\nthis:\n  m ?i = h ?i # t ?i\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have \"\\<forall>i. h i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. h i \\<in> A", "using ne_lists [OF ne] and lists"], ["proof (prove)\nusing this:\n  m ?i1 \\<in> lists ?A \\<Longrightarrow> hd (m ?i1) \\<in> ?A\n  m ?i1 \\<in> lists ?A \\<Longrightarrow> tl (m ?i1) \\<in> lists ?A\n  m ?i \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<forall>i. h i \\<in> A", "by (auto simp add: h_def)"], ["proof (state)\nthis:\n  \\<forall>i. h i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "from almost_full_on_imp_homogeneous_subseq [OF assms this]"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and> P (h (\\<phi> i)) (h (\\<phi> j))", "obtain \\<phi> :: \"nat \\<Rightarrow> nat\"\n    where less: \"\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j\"\n      and P: \"\\<forall>i j. i < j \\<longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and> P (h (\\<phi> i)) (h (\\<phi> j))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j;\n         \\<forall>i j.\n            i < j \\<longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  \\<forall>i j. i < j \\<longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have bad_t: \"bad ?P (t \\<circ> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad (list_emb P) (t \\<circ> \\<phi>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "assume \"good ?P (t \\<circ> \\<phi>)\""], ["proof (state)\nthis:\n  good (list_emb P) (t \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  good (list_emb P) (t \\<circ> \\<phi>)", "obtain i j where \"i < j\" and \"?P (t (\\<phi> i)) (t (\\<phi> j))\""], ["proof (prove)\nusing this:\n  good (list_emb P) (t \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; list_emb P (t (\\<phi> i)) (t (\\<phi> j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "with P"], ["proof (chain)\npicking this:\n  \\<forall>i j. i < j \\<longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))", "have \"P (h (\\<phi> i)) (h (\\<phi> j))\""], ["proof (prove)\nusing this:\n  \\<forall>i j. i < j \\<longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))\n\ngoal (1 subgoal):\n 1. P (h (\\<phi> i)) (h (\\<phi> j))", "by blast"], ["proof (state)\nthis:\n  P (h (\\<phi> i)) (h (\\<phi> j))\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))\n  P (h (\\<phi> i)) (h (\\<phi> j))", "have \"?P (m (\\<phi> i)) (m (\\<phi> j))\""], ["proof (prove)\nusing this:\n  i < j\n  list_emb P (t (\\<phi> i)) (t (\\<phi> j))\n  P (h (\\<phi> i)) (h (\\<phi> j))\n\ngoal (1 subgoal):\n 1. list_emb P (m (\\<phi> i)) (m (\\<phi> j))", "by (subst (1 2) m) (rule list_emb_Cons2, auto)"], ["proof (state)\nthis:\n  list_emb P (m (\\<phi> i)) (m (\\<phi> j))\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "with less and \\<open>i < j\\<close>"], ["proof (chain)\npicking this:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  i < j\n  list_emb P (m (\\<phi> i)) (m (\\<phi> j))", "have \"good ?P m\""], ["proof (prove)\nusing this:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  i < j\n  list_emb P (m (\\<phi> i)) (m (\\<phi> j))\n\ngoal (1 subgoal):\n 1. good (list_emb P) m", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (list_emb P) m\n\ngoal (1 subgoal):\n 1. good (list_emb P) (t \\<circ> \\<phi>) \\<Longrightarrow> False", "with bad"], ["proof (chain)\npicking this:\n  m \\<in> BAD (list_emb P)\n  good (list_emb P) m", "show False"], ["proof (prove)\nusing this:\n  m \\<in> BAD (list_emb P)\n  good (list_emb P) m\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bad (list_emb P) (t \\<circ> \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "define m' where \"m' = (\\<lambda>i. if i < \\<phi> 0 then m i else t (\\<phi> (i - \\<phi> 0)))\""], ["proof (state)\nthis:\n  m' = (\\<lambda>i. if i < \\<phi> 0 then m i else t (\\<phi> (i - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have m'_less: \"\\<And>i. i < \\<phi> 0 \\<Longrightarrow> m' i = m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < \\<phi> 0 \\<Longrightarrow> m' i = m i", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  ?i < \\<phi> 0 \\<Longrightarrow> m' ?i = m ?i\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have m'_geq: \"\\<And>i. i \\<ge> \\<phi> 0 \\<Longrightarrow> m' i = t (\\<phi> (i - \\<phi> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<phi> 0 \\<le> i \\<Longrightarrow> m' i = t (\\<phi> (i - \\<phi> 0))", "by (simp add: m'_def)"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> ?i \\<Longrightarrow> m' ?i = t (\\<phi> (?i - \\<phi> 0))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have \"\\<forall>i. m' i \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. m' i \\<in> lists A", "using ne_lists [OF ne] and lists"], ["proof (prove)\nusing this:\n  m ?i1 \\<in> lists ?A \\<Longrightarrow> hd (m ?i1) \\<in> ?A\n  m ?i1 \\<in> lists ?A \\<Longrightarrow> tl (m ?i1) \\<in> lists ?A\n  m ?i \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<forall>i. m' i \\<in> lists A", "by (auto simp: m'_def t_def)"], ["proof (state)\nthis:\n  \\<forall>i. m' i \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. m' i \\<in> lists A\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have \"length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (m' (\\<phi> 0)) < length (m (\\<phi> 0))", "using ne"], ["proof (prove)\nusing this:\n  m ?i \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (m' (\\<phi> 0)) < length (m (\\<phi> 0))", "by (simp add: t_def m'_geq)"], ["proof (state)\nthis:\n  length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have \"\\<forall>j<\\<phi> 0. m' j = m j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<\\<phi> 0. m' j = m j", "by (auto simp: m'_less)"], ["proof (state)\nthis:\n  \\<forall>j<\\<phi> 0. m' j = m j\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i. m' i \\<in> lists A\n  length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\n  \\<forall>j<\\<phi> 0. m' j = m j", "have \"(m, m') \\<in> gseq\""], ["proof (prove)\nusing this:\n  \\<forall>i. m' i \\<in> lists A\n  length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\n  \\<forall>j<\\<phi> 0. m' j = m j\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "using lists"], ["proof (prove)\nusing this:\n  \\<forall>i. m' i \\<in> lists A\n  length (m' (\\<phi> 0)) < length (m (\\<phi> 0))\n  \\<forall>j<\\<phi> 0. m' j = m j\n  m ?i \\<in> lists A\n\ngoal (1 subgoal):\n 1. (m, m') \\<in> gseq", "by (auto simp: gseq_def)"], ["proof (state)\nthis:\n  (m, m') \\<in> gseq\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (m, m') \\<in> gseq\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "have \"bad ?P m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad (list_emb P) m'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "assume \"good ?P m'\""], ["proof (state)\nthis:\n  good (list_emb P) m'\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  good (list_emb P) m'", "obtain i j where \"i < j\" and emb: \"?P (m' i) (m' j)\""], ["proof (prove)\nusing this:\n  good (list_emb P) m'\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; list_emb P (m' i) (m' j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  i < j\n  list_emb P (m' i) (m' j)\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  i < j\n  list_emb P (m' i) (m' j)\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "assume \"j < \\<phi> 0\""], ["proof (state)\nthis:\n  j < \\<phi> 0\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  list_emb P (m' i) (m' j)\n  j < \\<phi> 0", "have \"?P (m i) (m j)\""], ["proof (prove)\nusing this:\n  i < j\n  list_emb P (m' i) (m' j)\n  j < \\<phi> 0\n\ngoal (1 subgoal):\n 1. list_emb P (m i) (m j)", "by (auto simp: m'_less)"], ["proof (state)\nthis:\n  list_emb P (m i) (m j)\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and bad"], ["proof (chain)\npicking this:\n  i < j\n  m \\<in> BAD (list_emb P)\n  list_emb P (m i) (m j)", "have False"], ["proof (prove)\nusing this:\n  i < j\n  m \\<in> BAD (list_emb P)\n  list_emb P (m i) (m j)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  j < \\<phi> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  j < \\<phi> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  j < \\<phi> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "assume \"\\<phi> 0 \\<le> i\""], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  list_emb P (m' i) (m' j)\n  \\<phi> 0 \\<le> i", "have \"?P (t (\\<phi> (i - \\<phi> 0))) (t (\\<phi> (j - \\<phi> 0)))\"\n        and \"i - \\<phi> 0 < j - \\<phi> 0\""], ["proof (prove)\nusing this:\n  i < j\n  list_emb P (m' i) (m' j)\n  \\<phi> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. list_emb P (t (\\<phi> (i - \\<phi> 0))) (t (\\<phi> (j - \\<phi> 0))) &&&\n    i - \\<phi> 0 < j - \\<phi> 0", "by (auto simp: m'_geq)"], ["proof (state)\nthis:\n  list_emb P (t (\\<phi> (i - \\<phi> 0))) (t (\\<phi> (j - \\<phi> 0)))\n  i - \\<phi> 0 < j - \\<phi> 0\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "with bad_t"], ["proof (chain)\npicking this:\n  bad (list_emb P) (t \\<circ> \\<phi>)\n  list_emb P (t (\\<phi> (i - \\<phi> 0))) (t (\\<phi> (j - \\<phi> 0)))\n  i - \\<phi> 0 < j - \\<phi> 0", "have False"], ["proof (prove)\nusing this:\n  bad (list_emb P) (t \\<circ> \\<phi>)\n  list_emb P (t (\\<phi> (i - \\<phi> 0))) (t (\\<phi> (j - \\<phi> 0)))\n  i - \\<phi> 0 < j - \\<phi> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "assume \"i < \\<phi> 0\" and \"\\<phi> 0 \\<le> j\""], ["proof (state)\nthis:\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  list_emb P (m' i) (m' j)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j", "have \"?P (m i) (t (\\<phi> (j - \\<phi> 0)))\""], ["proof (prove)\nusing this:\n  i < j\n  list_emb P (m' i) (m' j)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. list_emb P (m i) (t (\\<phi> (j - \\<phi> 0)))", "by (simp add: m'_less m'_geq)"], ["proof (state)\nthis:\n  list_emb P (m i) (t (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "from list_emb_Cons [OF this, of \"h (\\<phi> (j - \\<phi> 0))\"]"], ["proof (chain)\npicking this:\n  list_emb P (m i) (h (\\<phi> (j - \\<phi> 0)) # t (\\<phi> (j - \\<phi> 0)))", "have \"?P (m i) (m (\\<phi> (j - \\<phi> 0)))\""], ["proof (prove)\nusing this:\n  list_emb P (m i) (h (\\<phi> (j - \\<phi> 0)) # t (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))", "using ne"], ["proof (prove)\nusing this:\n  list_emb P (m i) (h (\\<phi> (j - \\<phi> 0)) # t (\\<phi> (j - \\<phi> 0)))\n  m ?i \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))", "by (simp add: h_def t_def)"], ["proof (state)\nthis:\n  list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "have \"i < \\<phi> (j - \\<phi> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < \\<phi> (j - \\<phi> 0)", "using less [of 0 \"j - \\<phi> 0\"] and \\<open>i < \\<phi> 0\\<close> and \\<open>\\<phi> 0 \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  0 < j - \\<phi> 0 \\<Longrightarrow> \\<phi> 0 < \\<phi> (j - \\<phi> 0)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. i < \\<phi> (j - \\<phi> 0)", "by (cases \"j = \\<phi> 0\") auto"], ["proof (state)\nthis:\n  i < \\<phi> (j - \\<phi> 0)\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))\n  i < \\<phi> (j - \\<phi> 0)", "have False"], ["proof (prove)\nusing this:\n  list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))\n  i < \\<phi> (j - \\<phi> 0)\n\ngoal (1 subgoal):\n 1. False", "using bad"], ["proof (prove)\nusing this:\n  list_emb P (m i) (m (\\<phi> (j - \\<phi> 0)))\n  i < \\<phi> (j - \\<phi> 0)\n  m \\<in> BAD (list_emb P)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. good (list_emb P) m' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  j < \\<phi> 0 \\<Longrightarrow> False\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk> \\<Longrightarrow> False", "show False"], ["proof (prove)\nusing this:\n  j < \\<phi> 0 \\<Longrightarrow> False\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  j < \\<phi> 0 \\<Longrightarrow> False\n  \\<phi> 0 \\<le> i \\<Longrightarrow> False\n  \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk> \\<Longrightarrow> False\n  i < j\n\ngoal (1 subgoal):\n 1. False", "by arith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bad (list_emb P) m'\n\ngoal (1 subgoal):\n 1. \\<not> almost_full_on (list_emb P) (lists A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (m, m') \\<in> gseq\n  bad (list_emb P) m'", "show False"], ["proof (prove)\nusing this:\n  (m, m') \\<in> gseq\n  bad (list_emb P) m'\n\ngoal (1 subgoal):\n 1. False", "using min"], ["proof (prove)\nusing this:\n  (m, m') \\<in> gseq\n  bad (list_emb P) m'\n  \\<forall>g. (m, g) \\<in> gseq \\<longrightarrow> good (list_emb P) g\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Natural Numbers\\<close>"], ["", "lemma almost_full_on_UNIV_nat:\n  \"almost_full_on (\\<le>) (UNIV :: nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "let ?P = \"subseq :: bool list \\<Rightarrow> bool list \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "have *: \"length ` (UNIV :: bool list set) = (UNIV :: nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj length", "by (metis Ex_list_of_length surj_def)"], ["proof (state)\nthis:\n  surj length\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "have \"almost_full_on (\\<le>) (length ` (UNIV :: bool list set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) (range length)", "proof (rule almost_full_on_hom)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; ?P x y\\<rbrakk>\n       \\<Longrightarrow> length x \\<le> length y\n 2. almost_full_on ?P UNIV", "fix xs ys :: \"bool list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; ?P x y\\<rbrakk>\n       \\<Longrightarrow> length x \\<le> length y\n 2. almost_full_on ?P UNIV", "assume \"?P xs ys\""], ["proof (state)\nthis:\n  subseq xs ys\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; ?P x y\\<rbrakk>\n       \\<Longrightarrow> length x \\<le> length y\n 2. almost_full_on ?P UNIV", "then"], ["proof (chain)\npicking this:\n  subseq xs ys", "show \"length xs \\<le> length ys\""], ["proof (prove)\nusing this:\n  subseq xs ys\n\ngoal (1 subgoal):\n 1. length xs \\<le> length ys", "by (metis list_emb_length)"], ["proof (state)\nthis:\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. almost_full_on subseq UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_full_on subseq UNIV", "have \"finite (UNIV :: bool set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by auto"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on subseq UNIV", "from almost_full_on_lists [OF eq_almost_full_on_finite_set [OF this]]"], ["proof (chain)\npicking this:\n  almost_full_on subseq (lists UNIV)", "show \"almost_full_on ?P UNIV\""], ["proof (prove)\nusing this:\n  almost_full_on subseq (lists UNIV)\n\ngoal (1 subgoal):\n 1. almost_full_on subseq UNIV", "unfolding lists_UNIV"], ["proof (prove)\nusing this:\n  almost_full_on subseq UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on subseq UNIV", "."], ["proof (state)\nthis:\n  almost_full_on subseq UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_full_on (\\<le>) (range length)\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "then"], ["proof (chain)\npicking this:\n  almost_full_on (\\<le>) (range length)", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_full_on (\\<le>) (range length)\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "unfolding *"], ["proof (prove)\nusing this:\n  almost_full_on (\\<le>) UNIV\n\ngoal (1 subgoal):\n 1. almost_full_on (\\<le>) UNIV", "."], ["proof (state)\nthis:\n  almost_full_on (\\<le>) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}