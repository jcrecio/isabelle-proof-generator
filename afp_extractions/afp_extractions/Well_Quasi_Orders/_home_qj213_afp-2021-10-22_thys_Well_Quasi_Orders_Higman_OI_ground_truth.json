{"file_name": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders/Higman_OI.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Well_Quasi_Orders", "problem_names": ["lemma wfp_on_strict_suffix:\n  \"wfp_on strict_suffix A\"", "lemma po_on_strict_suffix:\n  \"po_on strict_suffix A\"", "lemma antisymp_on_LEX:\n  assumes \"irreflp_on P A\" and \"antisymp_on P A\"\n  shows \"antisymp_on (LEX P) (SEQ A)\"", "lemma LEX_trans:\n  assumes \"transp_on P A\" and \"f \\<in> SEQ A\" and \"g \\<in> SEQ A\" and \"h \\<in> SEQ A\"\n    and \"LEX P f g\" and \"LEX P g h\"\n  shows \"LEX P f h\"", "lemma qo_on_LEXEQ:\n  \"transp_on P A \\<Longrightarrow> qo_on (LEXEQ P) (SEQ A)\"", "lemma glb_LEX_lexmin:\n  assumes \"chain_on (LEX P) C (SEQ A)\" and \"C \\<noteq> {}\"\n  shows \"glb (LEX P) C (lexmin C)\"", "lemma dc_on_LEXEQ:\n  \"dc_on (LEXEQ P) (SEQ A)\"", "lemma pt_open_onD:\n  \"pt_open_on Q A \\<Longrightarrow> Q f \\<Longrightarrow> f \\<in> A \\<Longrightarrow> (\\<exists>n. (\\<forall>g\\<in>A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g))\"", "lemma pt_open_on_good:\n  \"pt_open_on (good Q) (SEQ A)\"", "lemma pt_open_on_imp_open_on_LEXEQ:\n  assumes \"pt_open_on Q (SEQ A)\"\n  shows \"open_on (LEXEQ P) Q (SEQ A)\"", "lemma open_on_good:\n  \"open_on (LEXEQ P) (good Q) (SEQ A)\"", "lemma open_on_LEXEQ_imp_pt_open_on_counterexample:\n  fixes a b :: \"'a\"\n  defines \"A \\<equiv> {a, b}\" and \"P \\<equiv> (\\<lambda>x y. False)\" and \"Q \\<equiv> (\\<lambda>f. \\<forall>i. f i = b)\"\n  assumes [simp]: \"a \\<noteq> b\"\n  shows \"minimal_element P A\" and \"open_on (LEXEQ P) Q (SEQ A)\"\n    and \"\\<not> pt_open_on Q (SEQ A)\"", "lemma higman:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (list_emb P) (lists A)\""], "translations": [["", "lemma wfp_on_strict_suffix:\n  \"wfp_on strict_suffix A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp_on strict_suffix A", "by (rule wfp_on_mono [OF subset_refl, of _ _ \"measure_on length A\"])\n   (auto simp: strict_suffix_def suffix_def)"], ["", "lemma po_on_strict_suffix:\n  \"po_on strict_suffix A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. po_on strict_suffix A", "by (force simp: strict_suffix_def po_on_def transp_on_def irreflp_on_def)"], ["", "subsection \\<open>Lexicographic Order on Infinite Sequences\\<close>"], ["", "lemma antisymp_on_LEX:\n  assumes \"irreflp_on P A\" and \"antisymp_on P A\"\n  shows \"antisymp_on (LEX P) (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymp_on (LEX P) (SEQ A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> SEQ A; b \\<in> SEQ A; LEX P a b; LEX P b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> SEQ A; b \\<in> SEQ A; LEX P a b; LEX P b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "assume SEQ: \"f \\<in> SEQ A\" \"g \\<in> SEQ A\" and \"LEX P f g\" and \"LEX P g f\""], ["proof (state)\nthis:\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  LEX P f g\n  LEX P g f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> SEQ A; b \\<in> SEQ A; LEX P a b; LEX P b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "then"], ["proof (chain)\npicking this:\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  LEX P f g\n  LEX P g f", "obtain i j where \"P (f i) (g i)\" and \"P (g j) (f j)\"\n    and \"\\<forall>k<i. f k = g k\" and \"\\<forall>k<j. g k = f k\""], ["proof (prove)\nusing this:\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  LEX P f g\n  LEX P g f\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>P (f i) (g i); P (g j) (f j); \\<forall>k<i. f k = g k;\n         \\<forall>k<j. g k = f k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: LEX_def)"], ["proof (state)\nthis:\n  P (f i) (g i)\n  P (g j) (f j)\n  \\<forall>k<i. f k = g k\n  \\<forall>k<j. g k = f k\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> SEQ A; b \\<in> SEQ A; LEX P a b; LEX P b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "then"], ["proof (chain)\npicking this:\n  P (f i) (g i)\n  P (g j) (f j)\n  \\<forall>k<i. f k = g k\n  \\<forall>k<j. g k = f k", "have \"P (f (min i j)) (f (min i j))\""], ["proof (prove)\nusing this:\n  P (f i) (g i)\n  P (g j) (f j)\n  \\<forall>k<i. f k = g k\n  \\<forall>k<j. g k = f k\n\ngoal (1 subgoal):\n 1. P (f (min i j)) (f (min i j))", "using assms(2) and SEQ"], ["proof (prove)\nusing this:\n  P (f i) (g i)\n  P (g j) (f j)\n  \\<forall>k<i. f k = g k\n  \\<forall>k<j. g k = f k\n  antisymp_on P A\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. P (f (min i j)) (f (min i j))", "by (cases \"i = j\") (auto simp: antisymp_on_def min_def, force)"], ["proof (state)\nthis:\n  P (f (min i j)) (f (min i j))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> SEQ A; b \\<in> SEQ A; LEX P a b; LEX P b a\\<rbrakk>\n       \\<Longrightarrow> a = b", "with assms(1) and SEQ"], ["proof (chain)\npicking this:\n  irreflp_on P A\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  P (f (min i j)) (f (min i j))", "show  \"f = g\""], ["proof (prove)\nusing this:\n  irreflp_on P A\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  P (f (min i j)) (f (min i j))\n\ngoal (1 subgoal):\n 1. f = g", "by (auto simp: irreflp_on_def)"], ["proof (state)\nthis:\n  f = g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LEX_trans:\n  assumes \"transp_on P A\" and \"f \\<in> SEQ A\" and \"g \\<in> SEQ A\" and \"h \\<in> SEQ A\"\n    and \"LEX P f g\" and \"LEX P g h\"\n  shows \"LEX P f h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LEX P f h", "using assms"], ["proof (prove)\nusing this:\n  transp_on P A\n  f \\<in> SEQ A\n  g \\<in> SEQ A\n  h \\<in> SEQ A\n  LEX P f g\n  LEX P g h\n\ngoal (1 subgoal):\n 1. LEX P f h", "by (auto simp: LEX_def transp_on_def) (metis less_trans linorder_neqE_nat)"], ["", "lemma qo_on_LEXEQ:\n  \"transp_on P A \\<Longrightarrow> qo_on (LEXEQ P) (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp_on P A \\<Longrightarrow> qo_on (LEXEQ P) (SEQ A)", "by (auto simp: qo_on_def reflp_on_def transp_on_def [of \"LEXEQ P\"] dest: LEX_trans)"], ["", "context minimal_element\nbegin"], ["", "lemma glb_LEX_lexmin:\n  assumes \"chain_on (LEX P) C (SEQ A)\" and \"C \\<noteq> {}\"\n  shows \"glb (LEX P) C (lexmin C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glb (LEX P) C (lexmin C)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lb (LEX P) C (lexmin C)\n 2. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "have \"C \\<subseteq> SEQ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> SEQ A", "using assms"], ["proof (prove)\nusing this:\n  chain_on (LEX P) C (SEQ A)\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C \\<subseteq> SEQ A", "by (auto simp: chain_on_def)"], ["proof (state)\nthis:\n  C \\<subseteq> SEQ A\n\ngoal (2 subgoals):\n 1. lb (LEX P) C (lexmin C)\n 2. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "then"], ["proof (chain)\npicking this:\n  C \\<subseteq> SEQ A", "have \"lexmin C \\<in> SEQ A\""], ["proof (prove)\nusing this:\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "using \\<open>C \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  C \\<subseteq> SEQ A\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "by (intro lexmin_SEQ_mem)"], ["proof (state)\nthis:\n  lexmin C \\<in> SEQ A\n\ngoal (2 subgoals):\n 1. lb (LEX P) C (lexmin C)\n 2. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "note * = \\<open>C \\<subseteq> SEQ A\\<close> \\<open>C \\<noteq> {}\\<close>"], ["proof (state)\nthis:\n  C \\<subseteq> SEQ A\n  C \\<noteq> {}\n\ngoal (2 subgoals):\n 1. lb (LEX P) C (lexmin C)\n 2. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "note lex = LEX_imp_less [folded irreflp_on_def, OF po [THEN po_on_imp_irreflp_on]]\n  \\<comment> \\<open>\\<open>lexmin C\\<close> is a lower bound\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> SEQ A \\<or> ?g \\<in> SEQ A; LEX P ?f ?g;\n   \\<forall>i<?k. ?f i = ?g i; ?f ?k \\<noteq> ?g ?k\\<rbrakk>\n  \\<Longrightarrow> P (?f ?k) (?g ?k)\n\ngoal (2 subgoals):\n 1. lb (LEX P) C (lexmin C)\n 2. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "show \"lb (LEX P) C (lexmin C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lb (LEX P) C (lexmin C)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> C \\<Longrightarrow> LEXEQ P (lexmin C) y", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> C \\<Longrightarrow> LEXEQ P (lexmin C) y", "assume \"f \\<in> C\""], ["proof (state)\nthis:\n  f \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> C \\<Longrightarrow> LEXEQ P (lexmin C) y", "then"], ["proof (chain)\npicking this:\n  f \\<in> C", "show \"LEXEQ P (lexmin C) f\""], ["proof (prove)\nusing this:\n  f \\<in> C\n\ngoal (1 subgoal):\n 1. LEXEQ P (lexmin C) f", "proof (cases \"f = lexmin C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "define i where \"i = (LEAST i. f i \\<noteq> lexmin C i)\""], ["proof (state)\nthis:\n  i = (LEAST i. f i \\<noteq> lexmin C i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "case False"], ["proof (state)\nthis:\n  f \\<noteq> lexmin C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> lexmin C", "have neq: \"\\<exists>i. f i \\<noteq> lexmin C i\""], ["proof (prove)\nusing this:\n  f \\<noteq> lexmin C\n\ngoal (1 subgoal):\n 1. \\<exists>i. f i \\<noteq> lexmin C i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. f i \\<noteq> lexmin C i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "from LeastI_ex [OF this, folded i_def]\n        and not_less_Least [where P = \"\\<lambda>i. f i \\<noteq> lexmin C i\", folded i_def]"], ["proof (chain)\npicking this:\n  f i \\<noteq> lexmin C i\n  ?k < i \\<Longrightarrow> \\<not> f ?k \\<noteq> lexmin C ?k", "have neq: \"f i \\<noteq> lexmin C i\" and eq: \"\\<forall>j<i. f j = lexmin C j\""], ["proof (prove)\nusing this:\n  f i \\<noteq> lexmin C i\n  ?k < i \\<Longrightarrow> \\<not> f ?k \\<noteq> lexmin C ?k\n\ngoal (1 subgoal):\n 1. f i \\<noteq> lexmin C i &&& \\<forall>j<i. f j = lexmin C j", "by auto"], ["proof (state)\nthis:\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "then"], ["proof (chain)\npicking this:\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j", "have **: \"f \\<in> eq_upto C (lexmin C) i\" \"f i \\<in> ith (eq_upto C (lexmin C) i) i\""], ["proof (prove)\nusing this:\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j\n\ngoal (1 subgoal):\n 1. f \\<in> eq_upto C (lexmin C) i &&&\n    f i \\<in> ith (eq_upto C (lexmin C) i) i", "using \\<open>f \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j\n  f \\<in> C\n\ngoal (1 subgoal):\n 1. f \\<in> eq_upto C (lexmin C) i &&&\n    f i \\<in> ith (eq_upto C (lexmin C) i) i", "by force+"], ["proof (state)\nthis:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "moreover"], ["proof (state)\nthis:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "from **"], ["proof (chain)\npicking this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i", "have \"\\<not> P (f i) (lexmin C i)\""], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n\ngoal (1 subgoal):\n 1. \\<not> P (f i) (lexmin C i)", "using lexmin_minimal [OF *, of \"f i\" i] and \\<open>f \\<in> C\\<close> and \\<open>C \\<subseteq> SEQ A\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n  \\<lbrakk>f i \\<in> A; P (f i) (lexmin C i)\\<rbrakk>\n  \\<Longrightarrow> f i \\<notin> ith (eq_upto C (lexmin C) i) i\n  f \\<in> C\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. \\<not> P (f i) (lexmin C i)", "by blast"], ["proof (state)\nthis:\n  \\<not> P (f i) (lexmin C i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "moreover"], ["proof (state)\nthis:\n  \\<not> P (f i) (lexmin C i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "obtain g where \"g \\<in> eq_upto C (lexmin C) (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        g \\<in> eq_upto C (lexmin C) (Suc i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using eq_upto_lexmin_non_empty [OF *]"], ["proof (prove)\nusing this:\n  eq_upto C (lexmin C) ?i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        g \\<in> eq_upto C (lexmin C) (Suc i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> eq_upto C (lexmin C) (Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n  \\<not> P (f i) (lexmin C i)\n  g \\<in> eq_upto C (lexmin C) (Suc i)", "have \"P (lexmin C i) (f i)\""], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n  \\<not> P (f i) (lexmin C i)\n  g \\<in> eq_upto C (lexmin C) (Suc i)\n\ngoal (1 subgoal):\n 1. P (lexmin C i) (f i)", "using neq and \\<open>C \\<subseteq> SEQ A\\<close> and assms(1) and lex [of g f i] and lex [of f g i]"], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C (lexmin C) i\n  f i \\<in> ith (eq_upto C (lexmin C) i) i\n  \\<not> P (f i) (lexmin C i)\n  g \\<in> eq_upto C (lexmin C) (Suc i)\n  f i \\<noteq> lexmin C i\n  C \\<subseteq> SEQ A\n  chain_on (LEX P) C (SEQ A)\n  \\<lbrakk>g \\<in> SEQ A \\<or> f \\<in> SEQ A; LEX P g f;\n   \\<forall>ia<i. g ia = f ia; g i \\<noteq> f i\\<rbrakk>\n  \\<Longrightarrow> P (g i) (f i)\n  \\<lbrakk>f \\<in> SEQ A \\<or> g \\<in> SEQ A; LEX P f g;\n   \\<forall>ia<i. f ia = g ia; f i \\<noteq> g i\\<rbrakk>\n  \\<Longrightarrow> P (f i) (g i)\n\ngoal (1 subgoal):\n 1. P (lexmin C i) (f i)", "by (auto simp: eq_upto_def chain_on_def)"], ["proof (state)\nthis:\n  P (lexmin C i) (f i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f\n 2. \\<lbrakk>f \\<in> C; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "with eq"], ["proof (chain)\npicking this:\n  \\<forall>j<i. f j = lexmin C j\n  P (lexmin C i) (f i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j<i. f j = lexmin C j\n  P (lexmin C i) (f i)\n\ngoal (1 subgoal):\n 1. LEXEQ P (lexmin C) f", "by (auto simp: LEX_def)"], ["proof (state)\nthis:\n  LEXEQ P (lexmin C) f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> C; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P (lexmin C) f", "qed simp"], ["proof (state)\nthis:\n  LEXEQ P (lexmin C) f\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>\\<open>lexmin C\\<close> is greater than or equal to any other lower bound\\<close>"], ["proof (state)\nthis:\n  lb (LEX P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "assume lb: \"lb (LEX P) C f\""], ["proof (state)\nthis:\n  lb (LEX P) C f\n\ngoal (1 subgoal):\n 1. \\<And>y. lb (LEX P) C y \\<Longrightarrow> LEXEQ P y (lexmin C)", "then"], ["proof (chain)\npicking this:\n  lb (LEX P) C f", "show \"LEXEQ P f (lexmin C)\""], ["proof (prove)\nusing this:\n  lb (LEX P) C f\n\ngoal (1 subgoal):\n 1. LEXEQ P f (lexmin C)", "proof (cases \"f = lexmin C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "define i where \"i = (LEAST i. f i \\<noteq> lexmin C i)\""], ["proof (state)\nthis:\n  i = (LEAST i. f i \\<noteq> lexmin C i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "case False"], ["proof (state)\nthis:\n  f \\<noteq> lexmin C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> lexmin C", "have neq: \"\\<exists>i. f i \\<noteq> lexmin C i\""], ["proof (prove)\nusing this:\n  f \\<noteq> lexmin C\n\ngoal (1 subgoal):\n 1. \\<exists>i. f i \\<noteq> lexmin C i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. f i \\<noteq> lexmin C i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "from LeastI_ex [OF this, folded i_def]\n      and not_less_Least [where P = \"\\<lambda>i. f i \\<noteq> lexmin C i\", folded i_def]"], ["proof (chain)\npicking this:\n  f i \\<noteq> lexmin C i\n  ?k < i \\<Longrightarrow> \\<not> f ?k \\<noteq> lexmin C ?k", "have neq: \"f i \\<noteq> lexmin C i\" and eq: \"\\<forall>j<i. f j = lexmin C j\""], ["proof (prove)\nusing this:\n  f i \\<noteq> lexmin C i\n  ?k < i \\<Longrightarrow> \\<not> f ?k \\<noteq> lexmin C ?k\n\ngoal (1 subgoal):\n 1. f i \\<noteq> lexmin C i &&& \\<forall>j<i. f j = lexmin C j", "by auto"], ["proof (state)\nthis:\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "obtain h where \"h \\<in> eq_upto C (lexmin C) (Suc i)\" and \"h \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> eq_upto C (lexmin C) (Suc i); h \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eq_upto_lexmin_non_empty [OF *]"], ["proof (prove)\nusing this:\n  eq_upto C (lexmin C) ?i \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h \\<in> eq_upto C (lexmin C) (Suc i); h \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eq_upto_def)"], ["proof (state)\nthis:\n  h \\<in> eq_upto C (lexmin C) (Suc i)\n  h \\<in> C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "then"], ["proof (chain)\npicking this:\n  h \\<in> eq_upto C (lexmin C) (Suc i)\n  h \\<in> C", "have [simp]: \"\\<And>j. j < Suc i \\<Longrightarrow> h j = lexmin C j\""], ["proof (prove)\nusing this:\n  h \\<in> eq_upto C (lexmin C) (Suc i)\n  h \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>j. j < Suc i \\<Longrightarrow> h j = lexmin C j", "by auto"], ["proof (state)\nthis:\n  ?j < Suc i \\<Longrightarrow> h ?j = lexmin C ?j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "with lb and \\<open>h \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  lb (LEX P) C f\n  h \\<in> C\n  ?j < Suc i \\<Longrightarrow> h ?j = lexmin C ?j", "have \"LEX P f h\""], ["proof (prove)\nusing this:\n  lb (LEX P) C f\n  h \\<in> C\n  ?j < Suc i \\<Longrightarrow> h ?j = lexmin C ?j\n\ngoal (1 subgoal):\n 1. LEX P f h", "using neq"], ["proof (prove)\nusing this:\n  lb (LEX P) C f\n  h \\<in> C\n  ?j < Suc i \\<Longrightarrow> h ?j = lexmin C ?j\n  f i \\<noteq> lexmin C i\n\ngoal (1 subgoal):\n 1. LEX P f h", "by (auto simp: lb_def)"], ["proof (state)\nthis:\n  LEX P f h\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "then"], ["proof (chain)\npicking this:\n  LEX P f h", "have \"P (f i) (h i)\""], ["proof (prove)\nusing this:\n  LEX P f h\n\ngoal (1 subgoal):\n 1. P (f i) (h i)", "using neq and eq and \\<open>C \\<subseteq> SEQ A\\<close> and \\<open>h \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  LEX P f h\n  f i \\<noteq> lexmin C i\n  \\<forall>j<i. f j = lexmin C j\n  C \\<subseteq> SEQ A\n  h \\<in> C\n\ngoal (1 subgoal):\n 1. P (f i) (h i)", "by (intro lex) auto"], ["proof (state)\nthis:\n  P (f i) (h i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)\n 2. \\<lbrakk>lb (LEX P) C f; f \\<noteq> lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "with eq"], ["proof (chain)\npicking this:\n  \\<forall>j<i. f j = lexmin C j\n  P (f i) (h i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j<i. f j = lexmin C j\n  P (f i) (h i)\n\ngoal (1 subgoal):\n 1. LEXEQ P f (lexmin C)", "by (auto simp: LEX_def)"], ["proof (state)\nthis:\n  LEXEQ P f (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lb (LEX P) C f; f = lexmin C\\<rbrakk>\n    \\<Longrightarrow> LEXEQ P f (lexmin C)", "qed simp"], ["proof (state)\nthis:\n  LEXEQ P f (lexmin C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dc_on_LEXEQ:\n  \"dc_on (LEXEQ P) (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dc_on (LEXEQ P) (SEQ A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "assume \"chain_on (LEXEQ P) C (SEQ A)\" and \"C \\<noteq> {}\""], ["proof (state)\nthis:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "then"], ["proof (chain)\npicking this:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}", "have chain: \"chain_on (LEX P) C (SEQ A)\""], ["proof (prove)\nusing this:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. chain_on (LEX P) C (SEQ A)", "by (auto simp: chain_on_def)"], ["proof (state)\nthis:\n  chain_on (LEX P) C (SEQ A)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "then"], ["proof (chain)\npicking this:\n  chain_on (LEX P) C (SEQ A)", "have \"C \\<subseteq> SEQ A\""], ["proof (prove)\nusing this:\n  chain_on (LEX P) C (SEQ A)\n\ngoal (1 subgoal):\n 1. C \\<subseteq> SEQ A", "by (auto simp: chain_on_def)"], ["proof (state)\nthis:\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "then"], ["proof (chain)\npicking this:\n  C \\<subseteq> SEQ A", "have \"lexmin C \\<in> SEQ A\""], ["proof (prove)\nusing this:\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "using \\<open>C \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  C \\<subseteq> SEQ A\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "by (intro lexmin_SEQ_mem)"], ["proof (state)\nthis:\n  lexmin C \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "have \"glb (LEX P) C (lexmin C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. glb (LEX P) C (lexmin C)", "by (rule glb_LEX_lexmin [OF chain \\<open>C \\<noteq> {}\\<close>])"], ["proof (state)\nthis:\n  glb (LEX P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "then"], ["proof (chain)\npicking this:\n  glb (LEX P) C (lexmin C)", "have \"glb (LEXEQ P) C (lexmin C)\""], ["proof (prove)\nusing this:\n  glb (LEX P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. glb (LEXEQ P) C (lexmin C)", "by (auto simp: glb_def lb_def)"], ["proof (state)\nthis:\n  glb (LEXEQ P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x", "with \\<open>lexmin C \\<in> SEQ A\\<close>"], ["proof (chain)\npicking this:\n  lexmin C \\<in> SEQ A\n  glb (LEXEQ P) C (lexmin C)", "show \"\\<exists>f \\<in> SEQ A. glb (LEXEQ P) C f\""], ["proof (prove)\nusing this:\n  lexmin C \\<in> SEQ A\n  glb (LEXEQ P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>SEQ A. glb (LEXEQ P) C f", "by blast"], ["proof (state)\nthis:\n  \\<exists>f\\<in>SEQ A. glb (LEXEQ P) C f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  Properties that only depend on finite initial segments of a sequence\n  (i.e., which are open with respect to the product topology).\n\\<close>"], ["", "definition \"pt_open_on Q A \\<longleftrightarrow> (\\<forall>f\\<in>A. Q f \\<longleftrightarrow> (\\<exists>n. (\\<forall>g\\<in>A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)))\""], ["", "lemma pt_open_onD:\n  \"pt_open_on Q A \\<Longrightarrow> Q f \\<Longrightarrow> f \\<in> A \\<Longrightarrow> (\\<exists>n. (\\<forall>g\\<in>A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pt_open_on Q A; Q f; f \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>g\\<in>A.\n                            (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g", "unfolding pt_open_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>f\\<in>A.\n                Q f =\n                (\\<exists>n.\n                    \\<forall>g\\<in>A.\n                       (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g);\n     Q f; f \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>g\\<in>A.\n                            (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g", "by blast"], ["", "lemma pt_open_on_good:\n  \"pt_open_on (good Q) (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pt_open_on (good Q) (SEQ A)", "proof (unfold pt_open_on_def, intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> SEQ A \\<Longrightarrow>\n       good Q f =\n       (\\<exists>n.\n           \\<forall>g\\<in>SEQ A.\n              (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> SEQ A \\<Longrightarrow>\n       good Q f =\n       (\\<exists>n.\n           \\<forall>g\\<in>SEQ A.\n              (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)", "assume f: \"f \\<in> SEQ A\""], ["proof (state)\nthis:\n  f \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> SEQ A \\<Longrightarrow>\n       good Q f =\n       (\\<exists>n.\n           \\<forall>g\\<in>SEQ A.\n              (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)", "show \"good Q f = (\\<exists>n. \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good Q f =\n    (\\<exists>n.\n        \\<forall>g\\<in>SEQ A.\n           (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. good Q f \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n 2. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "assume \"good Q f\""], ["proof (state)\nthis:\n  good Q f\n\ngoal (2 subgoals):\n 1. good Q f \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n 2. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "then"], ["proof (chain)\npicking this:\n  good Q f", "obtain i and j where *: \"i < j\" \"Q (f i) (f j)\""], ["proof (prove)\nusing this:\n  good Q f\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; Q (f i) (f j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  Q (f i) (f j)\n\ngoal (2 subgoals):\n 1. good Q f \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n 2. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "have \"\\<forall>g\\<in>SEQ A. (\\<forall>i<Suc j. g i = f i) \\<longrightarrow> good Q g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>SEQ A.\n       (\\<forall>i<Suc j. g i = f i) \\<longrightarrow> good Q g", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> SEQ A; \\<forall>i<Suc j. g i = f i\\<rbrakk>\n       \\<Longrightarrow> good Q g", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> SEQ A; \\<forall>i<Suc j. g i = f i\\<rbrakk>\n       \\<Longrightarrow> good Q g", "assume \"g \\<in> SEQ A\" and \"\\<forall>i<Suc j. g i = f i\""], ["proof (state)\nthis:\n  g \\<in> SEQ A\n  \\<forall>i<Suc j. g i = f i\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>g \\<in> SEQ A; \\<forall>i<Suc j. g i = f i\\<rbrakk>\n       \\<Longrightarrow> good Q g", "then"], ["proof (chain)\npicking this:\n  g \\<in> SEQ A\n  \\<forall>i<Suc j. g i = f i", "show \"good Q g\""], ["proof (prove)\nusing this:\n  g \\<in> SEQ A\n  \\<forall>i<Suc j. g i = f i\n\ngoal (1 subgoal):\n 1. good Q g", "using *"], ["proof (prove)\nusing this:\n  g \\<in> SEQ A\n  \\<forall>i<Suc j. g i = f i\n  i < j\n  Q (f i) (f j)\n\ngoal (1 subgoal):\n 1. good Q g", "by (force simp: good_def)"], ["proof (state)\nthis:\n  good Q g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>g\\<in>SEQ A.\n     (\\<forall>i<Suc j. g i = f i) \\<longrightarrow> good Q g\n\ngoal (2 subgoals):\n 1. good Q f \\<Longrightarrow>\n    \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n 2. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "then"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>SEQ A.\n     (\\<forall>i<Suc j. g i = f i) \\<longrightarrow> good Q g", "show \"\\<exists>n. \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>SEQ A.\n     (\\<forall>i<Suc j. g i = f i) \\<longrightarrow> good Q g\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g", ".."], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>g\\<in>SEQ A.\n        (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "assume \"\\<exists>n. \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\""], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>g\\<in>SEQ A.\n        (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>g\\<in>SEQ A.\n          (\\<forall>i<n. g i = f i) \\<longrightarrow>\n          good Q g \\<Longrightarrow>\n    good Q f", "with f"], ["proof (chain)\npicking this:\n  f \\<in> SEQ A\n  \\<exists>n.\n     \\<forall>g\\<in>SEQ A.\n        (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g", "show \"good Q f\""], ["proof (prove)\nusing this:\n  f \\<in> SEQ A\n  \\<exists>n.\n     \\<forall>g\\<in>SEQ A.\n        (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g\n\ngoal (1 subgoal):\n 1. good Q f", "by blast"], ["proof (state)\nthis:\n  good Q f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  good Q f =\n  (\\<exists>n.\n      \\<forall>g\\<in>SEQ A.\n         (\\<forall>i<n. g i = f i) \\<longrightarrow> good Q g)\n\ngoal:\nNo subgoals!", "qed"], ["", "context minimal_element\nbegin"], ["", "lemma pt_open_on_imp_open_on_LEXEQ:\n  assumes \"pt_open_on Q (SEQ A)\"\n  shows \"open_on (LEXEQ P) Q (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open_on (LEXEQ P) Q (SEQ A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "assume chain: \"chain_on (LEXEQ P) C (SEQ A)\" and ne: \"C \\<noteq> {}\"\n    and \"\\<exists>g\\<in>SEQ A. glb (LEXEQ P) C g \\<and> Q g\""], ["proof (state)\nthis:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}\n  \\<exists>g\\<in>SEQ A. glb (LEXEQ P) C g \\<and> Q g\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "then"], ["proof (chain)\npicking this:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}\n  \\<exists>g\\<in>SEQ A. glb (LEXEQ P) C g \\<and> Q g", "obtain g where g: \"g \\<in> SEQ A\" and \"glb (LEXEQ P) C g\"\n    and Q: \"Q g\""], ["proof (prove)\nusing this:\n  chain_on (LEXEQ P) C (SEQ A)\n  C \\<noteq> {}\n  \\<exists>g\\<in>SEQ A. glb (LEXEQ P) C g \\<and> Q g\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> SEQ A; glb (LEXEQ P) C g; Q g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> SEQ A\n  glb (LEXEQ P) C g\n  Q g\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "then"], ["proof (chain)\npicking this:\n  g \\<in> SEQ A\n  glb (LEXEQ P) C g\n  Q g", "have glb: \"glb (LEX P) C g\""], ["proof (prove)\nusing this:\n  g \\<in> SEQ A\n  glb (LEXEQ P) C g\n  Q g\n\ngoal (1 subgoal):\n 1. glb (LEX P) C g", "by (auto simp: glb_def lb_def)"], ["proof (state)\nthis:\n  glb (LEX P) C g\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "from chain"], ["proof (chain)\npicking this:\n  chain_on (LEXEQ P) C (SEQ A)", "have \"chain_on (LEX P) C (SEQ A)\" and C: \"C \\<subseteq> SEQ A\""], ["proof (prove)\nusing this:\n  chain_on (LEXEQ P) C (SEQ A)\n\ngoal (1 subgoal):\n 1. chain_on (LEX P) C (SEQ A) &&& C \\<subseteq> SEQ A", "by (auto simp: chain_on_def)"], ["proof (state)\nthis:\n  chain_on (LEX P) C (SEQ A)\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "note * = glb_LEX_lexmin [OF this(1) ne]"], ["proof (state)\nthis:\n  glb (LEX P) C (lexmin C)\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "have \"lexmin C \\<in> SEQ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "using ne and C"], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. lexmin C \\<in> SEQ A", "by (intro lexmin_SEQ_mem)"], ["proof (state)\nthis:\n  lexmin C \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "from glb_unique [OF _ g this glb *]\n    and antisymp_on_LEX [OF po_on_imp_irreflp_on [OF po] po_on_imp_antisymp_on [OF po]]"], ["proof (chain)\npicking this:\n  antisymp_on (LEX P) (SEQ A) \\<Longrightarrow> g = lexmin C\n  antisymp_on (LEX P) (SEQ A)", "have [simp]: \"lexmin C = g\""], ["proof (prove)\nusing this:\n  antisymp_on (LEX P) (SEQ A) \\<Longrightarrow> g = lexmin C\n  antisymp_on (LEX P) (SEQ A)\n\ngoal (1 subgoal):\n 1. lexmin C = g", "by auto"], ["proof (state)\nthis:\n  lexmin C = g\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "from assms [THEN pt_open_onD, OF Q g]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     \\<forall>ga\\<in>SEQ A.\n        (\\<forall>i<n. ga i = g i) \\<longrightarrow> Q ga", "obtain n :: nat where **: \"\\<And>h. h \\<in> SEQ A \\<Longrightarrow> (\\<forall>i<n. h i = g i) \\<longrightarrow> Q h\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     \\<forall>ga\\<in>SEQ A.\n        (\\<forall>i<n. ga i = g i) \\<longrightarrow> Q ga\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>h.\n            h \\<in> SEQ A \\<Longrightarrow>\n            (\\<forall>i<n. h i = g i) \\<longrightarrow>\n            Q h) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?h \\<in> SEQ A \\<Longrightarrow>\n  (\\<forall>i<n. ?h i = g i) \\<longrightarrow> Q ?h\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "from eq_upto_lexmin_non_empty [OF C ne, of n]"], ["proof (chain)\npicking this:\n  eq_upto C (lexmin C) n \\<noteq> {}", "obtain f where \"f \\<in> eq_upto C g n\""], ["proof (prove)\nusing this:\n  eq_upto C (lexmin C) n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        f \\<in> eq_upto C g n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> eq_upto C g n\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "then"], ["proof (chain)\npicking this:\n  f \\<in> eq_upto C g n", "have \"f \\<in> C\" and \"Q f\""], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C g n\n\ngoal (1 subgoal):\n 1. f \\<in> C &&& Q f", "using ** [of f] and C"], ["proof (prove)\nusing this:\n  f \\<in> eq_upto C g n\n  f \\<in> SEQ A \\<Longrightarrow>\n  (\\<forall>i<n. f i = g i) \\<longrightarrow> Q f\n  C \\<subseteq> SEQ A\n\ngoal (1 subgoal):\n 1. f \\<in> C &&& Q f", "by force+"], ["proof (state)\nthis:\n  f \\<in> C\n  Q f\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>chain_on (LEXEQ P) C (SEQ A); C \\<noteq> {};\n        \\<exists>x\\<in>SEQ A. glb (LEXEQ P) C x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>C. Q y", "then"], ["proof (chain)\npicking this:\n  f \\<in> C\n  Q f", "show \"\\<exists>f\\<in>C. Q f\""], ["proof (prove)\nusing this:\n  f \\<in> C\n  Q f\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>C. Q f", "by blast"], ["proof (state)\nthis:\n  \\<exists>f\\<in>C. Q f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma open_on_good:\n  \"open_on (LEXEQ P) (good Q) (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open_on (LEXEQ P) (good Q) (SEQ A)", "by (intro pt_open_on_imp_open_on_LEXEQ pt_open_on_good)"], ["", "end"], ["", "lemma open_on_LEXEQ_imp_pt_open_on_counterexample:\n  fixes a b :: \"'a\"\n  defines \"A \\<equiv> {a, b}\" and \"P \\<equiv> (\\<lambda>x y. False)\" and \"Q \\<equiv> (\\<lambda>f. \\<forall>i. f i = b)\"\n  assumes [simp]: \"a \\<noteq> b\"\n  shows \"minimal_element P A\" and \"open_on (LEXEQ P) Q (SEQ A)\"\n    and \"\\<not> pt_open_on Q (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_element P A &&&\n    open_on (LEXEQ P) Q (SEQ A) &&& \\<not> pt_open_on Q (SEQ A)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. minimal_element P A\n 2. open_on (LEXEQ P) Q (SEQ A)\n 3. \\<not> pt_open_on Q (SEQ A)", "show \"minimal_element P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_element P A", "by standard (auto simp: P_def po_on_def irreflp_on_def transp_on_def wfp_on_def)"], ["proof (state)\nthis:\n  minimal_element P A\n\ngoal (2 subgoals):\n 1. open_on (LEXEQ P) Q (SEQ A)\n 2. \\<not> pt_open_on Q (SEQ A)", "show \"open_on (LEXEQ P) Q (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open_on (LEXEQ P) Q (SEQ A)", "by (auto simp: P_def open_on_def chain_on_def SEQ_def glb_def lb_def LEX_def)"], ["proof (state)\nthis:\n  open_on (LEXEQ P) Q (SEQ A)\n\ngoal (1 subgoal):\n 1. \\<not> pt_open_on Q (SEQ A)", "show \"\\<not> pt_open_on Q (SEQ A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pt_open_on Q (SEQ A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "define f :: \"nat \\<Rightarrow> 'a\" where \"f \\<equiv> (\\<lambda>x. b)\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>x. b\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "have \"f \\<in> SEQ A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> SEQ A", "by (auto simp: A_def f_def)"], ["proof (state)\nthis:\n  f \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f \\<in> SEQ A\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "assume \"pt_open_on Q (SEQ A)\""], ["proof (state)\nthis:\n  pt_open_on Q (SEQ A)\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  f \\<in> SEQ A\n  pt_open_on Q (SEQ A)", "have \"Q f \\<longleftrightarrow> (\\<exists>n. (\\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g))\""], ["proof (prove)\nusing this:\n  f \\<in> SEQ A\n  pt_open_on Q (SEQ A)\n\ngoal (1 subgoal):\n 1. Q f =\n    (\\<exists>n.\n        \\<forall>g\\<in>SEQ A.\n           (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)", "unfolding pt_open_on_def"], ["proof (prove)\nusing this:\n  f \\<in> SEQ A\n  \\<forall>f\\<in>SEQ A.\n     Q f =\n     (\\<exists>n.\n         \\<forall>g\\<in>SEQ A.\n            (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)\n\ngoal (1 subgoal):\n 1. Q f =\n    (\\<exists>n.\n        \\<forall>g\\<in>SEQ A.\n           (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)", "by blast"], ["proof (state)\nthis:\n  Q f =\n  (\\<exists>n.\n      \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Q f =\n  (\\<exists>n.\n      \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "have \"Q f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q f", "by (auto simp: Q_def f_def)"], ["proof (state)\nthis:\n  Q f\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Q f\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "have \"\\<exists>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<and> \\<not> Q g\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<and> \\<not> Q g", "by (intro bexI [of _ \"f(n := a)\"]) (auto simp: f_def Q_def A_def)"], ["proof (state)\nthis:\n  \\<exists>g\\<in>SEQ A. (\\<forall>i<?n. g i = f i) \\<and> \\<not> Q g\n\ngoal (1 subgoal):\n 1. pt_open_on Q (SEQ A) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Q f =\n  (\\<exists>n.\n      \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)\n  Q f\n  \\<exists>g\\<in>SEQ A. (\\<forall>i<?n. g i = f i) \\<and> \\<not> Q g", "show False"], ["proof (prove)\nusing this:\n  Q f =\n  (\\<exists>n.\n      \\<forall>g\\<in>SEQ A. (\\<forall>i<n. g i = f i) \\<longrightarrow> Q g)\n  Q f\n  \\<exists>g\\<in>SEQ A. (\\<forall>i<?n. g i = f i) \\<and> \\<not> Q g\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> pt_open_on Q (SEQ A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma higman:\n  assumes \"almost_full_on P A\"\n  shows \"almost_full_on (list_emb P) (lists A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_full_on (list_emb P) (lists A)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> lists A \\<Longrightarrow> good (list_emb P) f", "interpret minimal_element strict_suffix \"lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_element strict_suffix (lists A)", "by (unfold_locales) (intro po_on_strict_suffix wfp_on_strict_suffix)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> lists A \\<Longrightarrow> good (list_emb P) f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> lists A \\<Longrightarrow> good (list_emb P) f", "presume \"f \\<in> SEQ (lists A)\""], ["proof (state)\nthis:\n  f \\<in> SEQ (lists A)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> lists A \\<Longrightarrow> good (list_emb P) f", "with qo_on_LEXEQ [OF po_on_imp_transp_on [OF po_on_strict_suffix]] and dc_on_LEXEQ and open_on_good"], ["proof (chain)\npicking this:\n  qo_on (LEXEQ strict_suffix) (SEQ ?A)\n  dc_on (LEXEQ strict_suffix) (SEQ (lists A))\n  open_on (LEXEQ strict_suffix) (good ?Q) (SEQ (lists A))\n  f \\<in> SEQ (lists A)", "show \"good (list_emb P) f\""], ["proof (prove)\nusing this:\n  qo_on (LEXEQ strict_suffix) (SEQ ?A)\n  dc_on (LEXEQ strict_suffix) (SEQ (lists A))\n  open_on (LEXEQ strict_suffix) (good ?Q) (SEQ (lists A))\n  f \\<in> SEQ (lists A)\n\ngoal (1 subgoal):\n 1. good (list_emb P) f", "proof (induct rule: open_induct_on)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> SEQ (lists A);\n        \\<And>y.\n           \\<lbrakk>y \\<in> SEQ (lists A);\n            strict (LEXEQ strict_suffix) y x\\<rbrakk>\n           \\<Longrightarrow> good (list_emb P) y\\<rbrakk>\n       \\<Longrightarrow> good (list_emb P) x", "case (less f)"], ["proof (state)\nthis:\n  f \\<in> SEQ (lists A)\n  \\<lbrakk>?y \\<in> SEQ (lists A);\n   strict (LEXEQ strict_suffix) ?y f\\<rbrakk>\n  \\<Longrightarrow> good (list_emb P) ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> SEQ (lists A);\n        \\<And>y.\n           \\<lbrakk>y \\<in> SEQ (lists A);\n            strict (LEXEQ strict_suffix) y x\\<rbrakk>\n           \\<Longrightarrow> good (list_emb P) y\\<rbrakk>\n       \\<Longrightarrow> good (list_emb P) x", "define h where \"h i = hd (f i)\" for i"], ["proof (state)\nthis:\n  h ?i = hd (f ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> SEQ (lists A);\n        \\<And>y.\n           \\<lbrakk>y \\<in> SEQ (lists A);\n            strict (LEXEQ strict_suffix) y x\\<rbrakk>\n           \\<Longrightarrow> good (list_emb P) y\\<rbrakk>\n       \\<Longrightarrow> good (list_emb P) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. good (list_emb P) f", "proof (cases \"\\<exists>i. f i = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "case False"], ["proof (state)\nthis:\n  \\<nexists>i. f i = []\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i. f i = []", "have ne: \"\\<forall>i. f i \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<nexists>i. f i = []\n\ngoal (1 subgoal):\n 1. \\<forall>i. f i \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. f i \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "with \\<open>f \\<in> SEQ (lists A)\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> SEQ (lists A)\n  \\<forall>i. f i \\<noteq> []", "have \"\\<forall>i. h i \\<in> A\""], ["proof (prove)\nusing this:\n  f \\<in> SEQ (lists A)\n  \\<forall>i. f i \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>i. h i \\<in> A", "by (auto simp: h_def ne_lists)"], ["proof (state)\nthis:\n  \\<forall>i. h i \\<in> A\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "from almost_full_on_imp_homogeneous_subseq [OF assms this]"], ["proof (chain)\npicking this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and> P (h (\\<phi> i)) (h (\\<phi> j))", "obtain \\<phi> :: \"nat \\<Rightarrow> nat\" where mono: \"\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j\"\n        and P: \"\\<And>i j. i < j \\<Longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<phi>.\n     \\<forall>i j.\n        i < j \\<longrightarrow>\n        \\<phi> i < \\<phi> j \\<and> P (h (\\<phi> i)) (h (\\<phi> j))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j;\n         \\<And>i j.\n            i < j \\<Longrightarrow> P (h (\\<phi> i)) (h (\\<phi> j))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  ?i < ?j \\<Longrightarrow> P (h (\\<phi> ?i)) (h (\\<phi> ?j))\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "define f' where \"f' i = (if i < \\<phi> 0 then f i else tl (f (\\<phi> (i - \\<phi> 0))))\" for i"], ["proof (state)\nthis:\n  f' ?i = (if ?i < \\<phi> 0 then f ?i else tl (f (\\<phi> (?i - \\<phi> 0))))\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "have f': \"f' \\<in> SEQ (lists A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<in> SEQ (lists A)", "using ne and \\<open>f \\<in> SEQ (lists A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<noteq> []\n  f \\<in> SEQ (lists A)\n\ngoal (1 subgoal):\n 1. f' \\<in> SEQ (lists A)", "by (auto simp: f'_def dest: list.set_sel)"], ["proof (state)\nthis:\n  f' \\<in> SEQ (lists A)\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "have [simp]: \"\\<And>i. \\<phi> 0 \\<le> i \\<Longrightarrow> h (\\<phi> (i - \\<phi> 0)) # f' i = f (\\<phi> (i - \\<phi> 0))\"\n        \"\\<And>i. i < \\<phi> 0 \\<Longrightarrow> f' i = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<phi> 0 \\<le> i \\<Longrightarrow>\n        h (\\<phi> (i - \\<phi> 0)) # f' i = f (\\<phi> (i - \\<phi> 0))) &&&\n    (\\<And>i. i < \\<phi> 0 \\<Longrightarrow> f' i = f i)", "using ne"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<phi> 0 \\<le> i \\<Longrightarrow>\n        h (\\<phi> (i - \\<phi> 0)) # f' i = f (\\<phi> (i - \\<phi> 0))) &&&\n    (\\<And>i. i < \\<phi> 0 \\<Longrightarrow> f' i = f i)", "by (auto simp: f'_def h_def)"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> ?i \\<Longrightarrow>\n  h (\\<phi> (?i - \\<phi> 0)) # f' ?i = f (\\<phi> (?i - \\<phi> 0))\n  ?i < \\<phi> 0 \\<Longrightarrow> f' ?i = f ?i\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "moreover"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> ?i \\<Longrightarrow>\n  h (\\<phi> (?i - \\<phi> 0)) # f' ?i = f (\\<phi> (?i - \\<phi> 0))\n  ?i < \\<phi> 0 \\<Longrightarrow> f' ?i = f ?i\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "have \"strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))", "using ne"], ["proof (prove)\nusing this:\n  \\<forall>i. f i \\<noteq> []\n\ngoal (1 subgoal):\n 1. strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))", "by (auto simp: f'_def)"], ["proof (state)\nthis:\n  strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> 0 \\<le> ?i \\<Longrightarrow>\n  h (\\<phi> (?i - \\<phi> 0)) # f' ?i = f (\\<phi> (?i - \\<phi> 0))\n  ?i < \\<phi> 0 \\<Longrightarrow> f' ?i = f ?i\n  strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))", "have \"LEX strict_suffix f' f\""], ["proof (prove)\nusing this:\n  \\<phi> 0 \\<le> ?i \\<Longrightarrow>\n  h (\\<phi> (?i - \\<phi> 0)) # f' ?i = f (\\<phi> (?i - \\<phi> 0))\n  ?i < \\<phi> 0 \\<Longrightarrow> f' ?i = f ?i\n  strict_suffix (f' (\\<phi> 0)) (f (\\<phi> 0))\n\ngoal (1 subgoal):\n 1. LEX strict_suffix f' f", "by (auto simp: LEX_def)"], ["proof (state)\nthis:\n  LEX strict_suffix f' f\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "with LEX_imp_not_LEX [OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>strict_suffix x y; strict_suffix y z\\<rbrakk>\n              \\<Longrightarrow> strict_suffix x z;\n   \\<And>x. \\<not> strict_suffix x x\\<rbrakk>\n  \\<Longrightarrow> \\<not> LEX strict_suffix f f'\n  LEX strict_suffix f' f", "have \"strict (LEXEQ strict_suffix) f' f\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>strict_suffix x y; strict_suffix y z\\<rbrakk>\n              \\<Longrightarrow> strict_suffix x z;\n   \\<And>x. \\<not> strict_suffix x x\\<rbrakk>\n  \\<Longrightarrow> \\<not> LEX strict_suffix f f'\n  LEX strict_suffix f' f\n\ngoal (1 subgoal):\n 1. strict (LEXEQ strict_suffix) f' f", "using po_on_strict_suffix [of UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>strict_suffix x y; strict_suffix y z\\<rbrakk>\n              \\<Longrightarrow> strict_suffix x z;\n   \\<And>x. \\<not> strict_suffix x x\\<rbrakk>\n  \\<Longrightarrow> \\<not> LEX strict_suffix f f'\n  LEX strict_suffix f' f\n  po_on strict_suffix UNIV\n\ngoal (1 subgoal):\n 1. strict (LEXEQ strict_suffix) f' f", "unfolding po_on_def irreflp_on_def transp_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z.\n              \\<lbrakk>strict_suffix x y; strict_suffix y z\\<rbrakk>\n              \\<Longrightarrow> strict_suffix x z;\n   \\<And>x. \\<not> strict_suffix x x\\<rbrakk>\n  \\<Longrightarrow> \\<not> LEX strict_suffix f f'\n  LEX strict_suffix f' f\n  (\\<forall>a\\<in>UNIV. \\<not> strict_suffix a a) \\<and>\n  (\\<forall>x\\<in>UNIV.\n      \\<forall>y\\<in>UNIV.\n         \\<forall>z\\<in>UNIV.\n            strict_suffix x y \\<and> strict_suffix y z \\<longrightarrow>\n            strict_suffix x z)\n\ngoal (1 subgoal):\n 1. strict (LEXEQ strict_suffix) f' f", "by blast"], ["proof (state)\nthis:\n  strict (LEXEQ strict_suffix) f' f\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "from less(2) [OF f' this]"], ["proof (chain)\npicking this:\n  good (list_emb P) f'", "have \"good (list_emb P) f'\""], ["proof (prove)\nusing this:\n  good (list_emb P) f'\n\ngoal (1 subgoal):\n 1. good (list_emb P) f'", "."], ["proof (state)\nthis:\n  good (list_emb P) f'\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "then"], ["proof (chain)\npicking this:\n  good (list_emb P) f'", "obtain i j where \"i < j\" and emb: \"list_emb P (f' i) (f' j)\""], ["proof (prove)\nusing this:\n  good (list_emb P) f'\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; list_emb P (f' i) (f' j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  i < j\n  list_emb P (f' i) (f' j)\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "consider \"j < \\<phi> 0\" | \"\\<phi> 0 \\<le> i\" | \"i < \\<phi> 0\" and \"\\<phi> 0 \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < \\<phi> 0 \\<Longrightarrow> thesis;\n     \\<phi> 0 \\<le> i \\<Longrightarrow> thesis;\n     \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>j < \\<phi> 0 \\<Longrightarrow> ?thesis;\n   \\<phi> 0 \\<le> i \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f\n 2. \\<nexists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < \\<phi> 0 \\<Longrightarrow> ?thesis;\n   \\<phi> 0 \\<le> i \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < \\<phi> 0 \\<Longrightarrow> ?thesis;\n   \\<phi> 0 \\<le> i \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. good (list_emb P) f", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. j < \\<phi> 0 \\<Longrightarrow> good (list_emb P) f\n 2. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 3. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "case 1"], ["proof (state)\nthis:\n  j < \\<phi> 0\n\ngoal (3 subgoals):\n 1. j < \\<phi> 0 \\<Longrightarrow> good (list_emb P) f\n 2. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 3. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "with \\<open>i < j\\<close> and emb"], ["proof (chain)\npicking this:\n  i < j\n  list_emb P (f' i) (f' j)\n  j < \\<phi> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  list_emb P (f' i) (f' j)\n  j < \\<phi> 0\n\ngoal (1 subgoal):\n 1. good (list_emb P) f", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "case 2"], ["proof (state)\nthis:\n  \\<phi> 0 \\<le> i\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "with \\<open>i < j\\<close> and P"], ["proof (chain)\npicking this:\n  i < j\n  ?i < ?j \\<Longrightarrow> P (h (\\<phi> ?i)) (h (\\<phi> ?j))\n  \\<phi> 0 \\<le> i", "have \"P (h (\\<phi> (i - \\<phi> 0))) (h (\\<phi> (j - \\<phi> 0)))\""], ["proof (prove)\nusing this:\n  i < j\n  ?i < ?j \\<Longrightarrow> P (h (\\<phi> ?i)) (h (\\<phi> ?j))\n  \\<phi> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. P (h (\\<phi> (i - \\<phi> 0))) (h (\\<phi> (j - \\<phi> 0)))", "by auto"], ["proof (state)\nthis:\n  P (h (\\<phi> (i - \\<phi> 0))) (h (\\<phi> (j - \\<phi> 0)))\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "with emb"], ["proof (chain)\npicking this:\n  list_emb P (f' i) (f' j)\n  P (h (\\<phi> (i - \\<phi> 0))) (h (\\<phi> (j - \\<phi> 0)))", "have \"list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i) (h (\\<phi> (j - \\<phi> 0)) # f' j)\""], ["proof (prove)\nusing this:\n  list_emb P (f' i) (f' j)\n  P (h (\\<phi> (i - \\<phi> 0))) (h (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i)\n     (h (\\<phi> (j - \\<phi> 0)) # f' j)", "by auto"], ["proof (state)\nthis:\n  list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i)\n   (h (\\<phi> (j - \\<phi> 0)) # f' j)\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "then"], ["proof (chain)\npicking this:\n  list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i)\n   (h (\\<phi> (j - \\<phi> 0)) # f' j)", "have \"list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\""], ["proof (prove)\nusing this:\n  list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i)\n   (h (\\<phi> (j - \\<phi> 0)) # f' j)\n\ngoal (1 subgoal):\n 1. list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))", "using 2 and \\<open>i < j\\<close>"], ["proof (prove)\nusing this:\n  list_emb P (h (\\<phi> (i - \\<phi> 0)) # f' i)\n   (h (\\<phi> (j - \\<phi> 0)) # f' j)\n  \\<phi> 0 \\<le> i\n  i < j\n\ngoal (1 subgoal):\n 1. list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))", "by auto"], ["proof (state)\nthis:\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "moreover"], ["proof (state)\nthis:\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "with 2 and \\<open>i <j\\<close>"], ["proof (chain)\npicking this:\n  \\<phi> 0 \\<le> i\n  i < j\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))", "have \"\\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)\""], ["proof (prove)\nusing this:\n  \\<phi> 0 \\<le> i\n  i < j\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. \\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)", "using mono"], ["proof (prove)\nusing this:\n  \\<phi> 0 \\<le> i\n  i < j\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n\ngoal (1 subgoal):\n 1. \\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)", "by auto"], ["proof (state)\nthis:\n  \\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)\n\ngoal (2 subgoals):\n 1. \\<phi> 0 \\<le> i \\<Longrightarrow> good (list_emb P) f\n 2. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "ultimately"], ["proof (chain)\npicking this:\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n  \\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_emb P (f (\\<phi> (i - \\<phi> 0))) (f (\\<phi> (j - \\<phi> 0)))\n  \\<phi> (i - \\<phi> 0) < \\<phi> (j - \\<phi> 0)\n\ngoal (1 subgoal):\n 1. good (list_emb P) f", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "case 3"], ["proof (state)\nthis:\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "with emb"], ["proof (chain)\npicking this:\n  list_emb P (f' i) (f' j)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j", "have \"list_emb P (f i) (f' j)\""], ["proof (prove)\nusing this:\n  list_emb P (f' i) (f' j)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. list_emb P (f i) (f' j)", "by auto"], ["proof (state)\nthis:\n  list_emb P (f i) (f' j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "moreover"], ["proof (state)\nthis:\n  list_emb P (f i) (f' j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "have \"f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j", "using 3"], ["proof (prove)\nusing this:\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j", "by auto"], ["proof (state)\nthis:\n  f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "ultimately"], ["proof (chain)\npicking this:\n  list_emb P (f i) (f' j)\n  f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j", "have \"list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))\""], ["proof (prove)\nusing this:\n  list_emb P (f i) (f' j)\n  f (\\<phi> (j - \\<phi> 0)) = h (\\<phi> (j - \\<phi> 0)) # f' j\n\ngoal (1 subgoal):\n 1. list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))", "by auto"], ["proof (state)\nthis:\n  list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "moreover"], ["proof (state)\nthis:\n  list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "have \"i < \\<phi> (j - \\<phi> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < \\<phi> (j - \\<phi> 0)", "using mono [of 0 \"j - \\<phi> 0\"] and 3"], ["proof (prove)\nusing this:\n  0 < j - \\<phi> 0 \\<Longrightarrow> \\<phi> 0 < \\<phi> (j - \\<phi> 0)\n  i < \\<phi> 0\n  \\<phi> 0 \\<le> j\n\ngoal (1 subgoal):\n 1. i < \\<phi> (j - \\<phi> 0)", "by force"], ["proof (state)\nthis:\n  i < \\<phi> (j - \\<phi> 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < \\<phi> 0; \\<phi> 0 \\<le> j\\<rbrakk>\n    \\<Longrightarrow> good (list_emb P) f", "ultimately"], ["proof (chain)\npicking this:\n  list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))\n  i < \\<phi> (j - \\<phi> 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  list_emb P (f i) (f (\\<phi> (j - \\<phi> 0)))\n  i < \\<phi> (j - \\<phi> 0)\n\ngoal (1 subgoal):\n 1. good (list_emb P) f", "by (auto simp: good_def)"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal (1 subgoal):\n 1. \\<exists>i. f i = [] \\<Longrightarrow> good (list_emb P) f", "qed auto"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  good (list_emb P) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i. f i \\<in> lists A \\<Longrightarrow> f \\<in> SEQ (lists A)", "qed blast"], ["", "end"]]}