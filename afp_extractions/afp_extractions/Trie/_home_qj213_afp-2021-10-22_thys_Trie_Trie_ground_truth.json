{"file_name": "/home/qj213/afp-2021-10-22/thys/Trie/Trie.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Trie", "problem_names": ["lemma trie_induct [case_names Trie, induct type]:\n  \"(\\<And>vo kvs. (\\<And>k t. (k, t) \\<in> set kvs \\<Longrightarrow> P t) \\<Longrightarrow> P (Trie vo kvs)) \\<Longrightarrow> P t\"", "lemma update_trie_induct:\n  \"\\<lbrakk>\\<And>v ps. P [] (Trie v ps); \\<And>k ks v ps. (\\<And>x. P ks x) \\<Longrightarrow> P (k#ks) (Trie v ps)\\<rbrakk> \\<Longrightarrow> P xs t\"", "lemma update_trie_Nil[simp]: \"update_trie [] v (Trie vo ts) = Trie (Some v) ts\"", "lemma update_trie_Cons[simp]: \"update_trie (k#ks) v (Trie vo ts) =\n  Trie vo (AList.update_with_aux (Trie None []) k (update_trie ks v) ts)\"", "lemma invar_empty [simp]: \"invar_trie empty_trie\"", "lemma is_empty_conv: \"is_empty_trie ts \\<longleftrightarrow> ts = Trie None []\"", "lemma lookup_empty [simp]: \"lookup_trie empty_trie = Map.empty\"", "lemma lookup_empty' [simp]: \"lookup_trie (Trie None []) ks = None\"", "lemma lookup_update:\n  \"lookup_trie (update_trie ks v t) ks' = (if ks = ks' then Some v else lookup_trie t ks')\"", "lemma lookup_update':\n  \"lookup_trie (update_trie ks v t) = (lookup_trie t)(ks \\<mapsto> v)\"", "lemma lookup_eq_Some_iff:\nassumes invar: \"invar_trie ((Trie vo kvs) :: ('key, 'val) trie)\"\nshows \"lookup_trie (Trie vo kvs) ks = Some v \\<longleftrightarrow>\n    (ks = [] \\<and> vo = Some v) \\<or>\n    (\\<exists>k t ks'. ks = k # ks' \\<and> \n        (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v)\"", "lemma lookup_eq_None_iff:\nassumes invar: \"invar_trie ((Trie vo kvs) :: ('key, 'val) trie)\"\nshows \"lookup_trie (Trie vo kvs) ks = None \\<longleftrightarrow>\n    (ks = [] \\<and> vo = None) \\<or>\n    (\\<exists>k ks'. ks = k # ks' \\<and> (\\<forall>t. (k, t) \\<in> set kvs \\<longrightarrow> lookup_trie t ks' = None))\"", "lemma update_not_empty: \"\\<not> is_empty_trie (update_trie ks v t)\"", "lemma invar_trie_update: \"invar_trie t \\<Longrightarrow> invar_trie (update_trie ks v t)\"", "lemma is_empty_lookup_empty:\n  \"invar_trie t \\<Longrightarrow> is_empty_trie t \\<longleftrightarrow> lookup_trie t = Map.empty\"", "lemma lookup_update_with_trie:\n  \"lookup_trie (update_with_trie ks f t) ks' =\n  (if ks' = ks then Some(f(lookup_trie t ks')) else lookup_trie t ks')\"", "lemma delete_eq_empty_lookup_other_fail:\n  \"\\<lbrakk> delete_trie ks t = Trie None []; ks' \\<noteq> ks \\<rbrakk> \\<Longrightarrow> lookup_trie t ks' = None\"", "lemma lookup_delete: \"invar_trie t \\<Longrightarrow>\n  lookup_trie (delete_trie ks t) ks' =\n  (if ks = ks' then None else lookup_trie t ks')\"", "lemma lookup_delete':\n  \"invar_trie t \\<Longrightarrow> lookup_trie (delete_trie ks t) = (lookup_trie t)(ks := None)\"", "lemma invar_trie_delete:\n  \"invar_trie t \\<Longrightarrow> invar_trie (delete_trie ks t)\"", "lemma nonempty_update_with_aux: \"AList.update_with_aux v k f ps \\<noteq> []\"", "lemma nonempty_update_with_trie: \"\\<not> is_empty_trie (update_with_trie ks f t)\"", "lemma invar_update_with_trie:\n  \"invar_trie t \\<Longrightarrow> invar_trie (update_with_trie ks f t)\"", "lemma dom_lookup: \n  \"dom (lookup_trie (Trie vo kts)) = \n  (\\<Union>k\\<in>dom (map_of kts). Cons k ` dom (lookup_trie (the (map_of kts k)))) \\<union>\n  (if vo = None then {} else {[]})\"", "lemma finite_dom_lookup:\n  \"finite (dom (lookup_trie t))\"", "lemma dom_lookup_empty_conv: \"invar_trie t \\<Longrightarrow> dom (lookup_trie t) = {} \\<longleftrightarrow> is_empty_trie t\"", "lemma ran_lookup_Trie: \"invar_trie (Trie vo ps) \\<Longrightarrow>\n  ran (lookup_trie (Trie vo ps)) =\n  (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {v}) \\<union> (UN (k,t) : set ps. ran(lookup_trie t))\"", "lemma all_trie_eq_ran:\n  \"invar_trie t \\<Longrightarrow> all_trie P t = (\\<forall>x \\<in> ran(lookup_trie t). P x)\""], "translations": [["", "lemma trie_induct [case_names Trie, induct type]:\n  \"(\\<And>vo kvs. (\\<And>k t. (k, t) \\<in> set kvs \\<Longrightarrow> P t) \\<Longrightarrow> P (Trie vo kvs)) \\<Longrightarrow> P t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vo kvs.\n        (\\<And>k t.\n            (k, t) \\<in> set kvs \\<Longrightarrow> P t) \\<Longrightarrow>\n        P (Trie vo kvs)) \\<Longrightarrow>\n    P t", "by induction_schema (pat_completeness, lexicographic_order)"], ["", "definition empty_trie :: \"('k, 'v) trie\" where\n\"empty_trie = Trie None []\""], ["", "fun is_empty_trie :: \"('k, 'v) trie \\<Rightarrow> bool\" where\n\"is_empty_trie (Trie v m) = (v = None \\<and> m = [])\""], ["", "fun lookup_trie :: \"('k, 'v) trie \\<Rightarrow> 'k list \\<Rightarrow> 'v option\" where\n\"lookup_trie (Trie v m) [] = v\" |\n\"lookup_trie (Trie v m) (k#ks) =\n   (case map_of m k of\n      None \\<Rightarrow> None |\n      Some st \\<Rightarrow> lookup_trie st ks)\""], ["", "fun update_with_trie ::\n  \"'k list \\<Rightarrow> ('v option \\<Rightarrow> 'v) \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> ('k, 'v) trie\" where\n\"update_with_trie []     f (Trie v ps)  = Trie (Some(f v)) ps\" |\n\"update_with_trie (k#ks) f (Trie v ps) =\n  Trie v (AList.update_with_aux empty_trie k (update_with_trie ks f) ps)\""], ["", "text\\<open>The function argument \\<open>f\\<close> of @{const update_with_trie}\ndoes not return an optional value because @{const None} could break the invariant\nthat no empty tries are contained in a trie because @{const AList.update_with_aux}\ncannot recognise and remove empty tries.\nTherefore the delete function is implemented separately rather than via\n@{const update_with_trie}.\n\nDo not use @{const update_with_trie} if most of the calls do not change\nthe entry (because of the garbage this creates); use @{const lookup_trie} possibly\nfollowed by \\<open>update_trie\\<close>. This shortcoming could be addressed if\n\\<open>f\\<close> indicated that the entry is unchanged, eg by @{const None}.\\<close>"], ["", "definition update_trie :: \"'k list \\<Rightarrow> 'v \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> ('k, 'v) trie\" where\n\"update_trie ks v = update_with_trie ks (%_. v)\""], ["", "lemma update_trie_induct:\n  \"\\<lbrakk>\\<And>v ps. P [] (Trie v ps); \\<And>k ks v ps. (\\<And>x. P ks x) \\<Longrightarrow> P (k#ks) (Trie v ps)\\<rbrakk> \\<Longrightarrow> P xs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v ps. P [] (Trie v ps);\n     \\<And>k ks v ps.\n        (\\<And>x. P ks x) \\<Longrightarrow> P (k # ks) (Trie v ps)\\<rbrakk>\n    \\<Longrightarrow> P xs t", "by induction_schema (pat_completeness, lexicographic_order)"], ["", "lemma update_trie_Nil[simp]: \"update_trie [] v (Trie vo ts) = Trie (Some v) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_trie [] v (Trie vo ts) = Trie (Some v) ts", "by(simp add: update_trie_def)"], ["", "lemma update_trie_Cons[simp]: \"update_trie (k#ks) v (Trie vo ts) =\n  Trie vo (AList.update_with_aux (Trie None []) k (update_trie ks v) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update_trie (k # ks) v (Trie vo ts) =\n    Trie vo (AList.update_with_aux (Trie None []) k (update_trie ks v) ts)", "by(simp add: update_trie_def empty_trie_def)"], ["", "(* A simple implementation of delete; does not shrink the trie!\ndefinition delete_trie :: \"'k list \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> ('k, 'v) trie\" where\n\"delete_trie ks t = update_with_trie ks (\\<lambda>_. None) t\"\n*)"], ["", "fun delete_trie :: \"'key list \\<Rightarrow> ('key, 'val) trie \\<Rightarrow> ('key, 'val) trie\"\nwhere\n\"delete_trie [] (Trie vo ts) = Trie None ts\" |\n\"delete_trie (k#ks) (Trie vo ts) =\n   (case map_of ts k of\n      None \\<Rightarrow> Trie vo ts |\n      Some t \\<Rightarrow> let t' = delete_trie ks t \n                in if is_empty_trie t'\n                   then Trie vo (AList.delete_aux k ts)\n                   else Trie vo (AList.update k t' ts))\""], ["", "fun all_trie :: \"('v \\<Rightarrow> bool) \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> bool\" where\n\"all_trie p (Trie v ps) =\n  ((case v of None \\<Rightarrow> True | Some v \\<Rightarrow> p v) \\<and> (\\<forall>(k,t) \\<in> set ps. all_trie p t))\""], ["", "fun invar_trie :: \"('key, 'val) trie \\<Rightarrow> bool\" where\n\"invar_trie (Trie vo kts) =\n  (distinct (map fst kts) \\<and>\n   (\\<forall>(k, t) \\<in> set kts. \\<not> is_empty_trie t \\<and> invar_trie t))\""], ["", "subsection \\<open>Empty trie\\<close>"], ["", "lemma invar_empty [simp]: \"invar_trie empty_trie\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie empty_trie", "by(simp add: empty_trie_def)"], ["", "lemma is_empty_conv: \"is_empty_trie ts \\<longleftrightarrow> ts = Trie None []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_empty_trie ts = (ts = Trie None [])", "by(cases ts)(simp)"], ["", "subsection \\<open>@{const lookup_trie}\\<close>"], ["", "lemma lookup_empty [simp]: \"lookup_trie empty_trie = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie empty_trie = Map.empty", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_trie empty_trie x = None", "fix ks"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. lookup_trie empty_trie x = None", "show \"lookup_trie empty_trie ks = Map.empty ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie empty_trie ks = None", "by(cases ks)(auto simp add: empty_trie_def)"], ["proof (state)\nthis:\n  lookup_trie empty_trie ks = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_empty' [simp]: \"lookup_trie (Trie None []) ks = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (Trie None []) ks = None", "by(simp add: lookup_empty[unfolded empty_trie_def])"], ["", "lemma lookup_update:\n  \"lookup_trie (update_trie ks v t) ks' = (if ks = ks' then Some v else lookup_trie t ks')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_trie ks v t) ks' =\n    (if ks = ks' then Some v else lookup_trie t ks')", "proof(induct ks t arbitrary: ks' rule: update_trie_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va ps ks'.\n       lookup_trie (update_trie [] v (Trie va ps)) ks' =\n       (if [] = ks' then Some v else lookup_trie (Trie va ps) ks')\n 2. \\<And>k ks va ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_trie ks v x) ks' =\n           (if ks = ks' then Some v\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_trie (k # ks) v (Trie va ps)) ks' =\n       (if k # ks = ks' then Some v else lookup_trie (Trie va ps) ks')", "case (1 vo ts ks')"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>va ps ks'.\n       lookup_trie (update_trie [] v (Trie va ps)) ks' =\n       (if [] = ks' then Some v else lookup_trie (Trie va ps) ks')\n 2. \\<And>k ks va ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_trie ks v x) ks' =\n           (if ks = ks' then Some v\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_trie (k # ks) v (Trie va ps)) ks' =\n       (if k # ks = ks' then Some v else lookup_trie (Trie va ps) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_trie [] v (Trie vo ts)) ks' =\n    (if [] = ks' then Some v else lookup_trie (Trie vo ts) ks')", "by(fastforce simp add: neq_Nil_conv dest: not_sym)"], ["proof (state)\nthis:\n  lookup_trie (update_trie [] v (Trie vo ts)) ks' =\n  (if [] = ks' then Some v else lookup_trie (Trie vo ts) ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks va ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_trie ks v x) ks' =\n           (if ks = ks' then Some v\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_trie (k # ks) v (Trie va ps)) ks' =\n       (if k # ks = ks' then Some v else lookup_trie (Trie va ps) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks va ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_trie ks v x) ks' =\n           (if ks = ks' then Some v\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_trie (k # ks) v (Trie va ps)) ks' =\n       (if k # ks = ks' then Some v else lookup_trie (Trie va ps) ks')", "case (2 k ks vo ts ks')"], ["proof (state)\nthis:\n  lookup_trie (update_trie ks v ?x) ?ks' =\n  (if ks = ?ks' then Some v else lookup_trie ?x ?ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks va ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_trie ks v x) ks' =\n           (if ks = ks' then Some v\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_trie (k # ks) v (Trie va ps)) ks' =\n       (if k # ks = ks' then Some v else lookup_trie (Trie va ps) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_trie (k # ks) v (Trie vo ts)) ks' =\n    (if k # ks = ks' then Some v else lookup_trie (Trie vo ts) ks')", "by(cases ks')(auto simp add: map_of_update_with_aux 2 split: option.split)"], ["proof (state)\nthis:\n  lookup_trie (update_trie (k # ks) v (Trie vo ts)) ks' =\n  (if k # ks = ks' then Some v else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_update':\n  \"lookup_trie (update_trie ks v t) = (lookup_trie t)(ks \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_trie ks v t) = lookup_trie t(ks \\<mapsto> v)", "by(rule ext)(simp add: lookup_update)"], ["", "lemma lookup_eq_Some_iff:\nassumes invar: \"invar_trie ((Trie vo kvs) :: ('key, 'val) trie)\"\nshows \"lookup_trie (Trie vo kvs) ks = Some v \\<longleftrightarrow>\n    (ks = [] \\<and> vo = Some v) \\<or>\n    (\\<exists>k t ks'. ks = k # ks' \\<and> \n        (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "proof (cases ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. ks = [] \\<Longrightarrow>\n    (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n 2. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "case Nil"], ["proof (state)\nthis:\n  ks = []\n\ngoal (2 subgoals):\n 1. ks = [] \\<Longrightarrow>\n    (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n 2. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ks = []\n\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "by simp"], ["proof (state)\nthis:\n  (lookup_trie (Trie vo kvs) ks = Some v) =\n  (ks = [] \\<and> vo = Some v \\<or>\n   (\\<exists>k t ks'.\n       ks = k # ks' \\<and>\n       (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "case (Cons k ks')"], ["proof (state)\nthis:\n  ks = k # ks'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "note ks_eq[simp] = Cons"], ["proof (state)\nthis:\n  ks = k # ks'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks = a # list \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "proof (cases \"map_of kvs k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of kvs k = None \\<Longrightarrow>\n    (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n 2. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "case None"], ["proof (state)\nthis:\n  map_of kvs k = None\n\ngoal (2 subgoals):\n 1. map_of kvs k = None \\<Longrightarrow>\n    (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n 2. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of kvs k = None\n\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of kvs k = None \\<Longrightarrow>\n    \\<forall>t.\n       (k, t) \\<in> set kvs \\<longrightarrow>\n       lookup_trie t ks' \\<noteq> Some v", "apply (auto simp add: map_of_eq_None_iff image_iff Ball_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (lookup_trie (Trie vo kvs) ks = Some v) =\n  (ks = [] \\<and> vo = Some v \\<or>\n   (\\<exists>k t ks'.\n       ks = k # ks' \\<and>\n       (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "case (Some t')"], ["proof (state)\nthis:\n  map_of kvs k = Some t'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "note map_eq = this"], ["proof (state)\nthis:\n  map_of kvs k = Some t'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "from invar"], ["proof (chain)\npicking this:\n  invar_trie (Trie vo kvs)", "have dist_kvs: \"distinct (map fst kvs)\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. distinct (map fst kvs)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst kvs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of kvs k = Some a \\<Longrightarrow>\n       (lookup_trie (Trie vo kvs) ks = Some v) =\n       (ks = [] \\<and> vo = Some v \\<or>\n        (\\<exists>k t ks'.\n            ks = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "from map_of_eq_Some_iff[OF dist_kvs, of k] map_eq"], ["proof (chain)\npicking this:\n  (map_of kvs k = Some ?y) = ((k, ?y) \\<in> set kvs)\n  map_of kvs k = Some t'", "show ?thesis"], ["proof (prove)\nusing this:\n  (map_of kvs k = Some ?y) = ((k, ?y) \\<in> set kvs)\n  map_of kvs k = Some t'\n\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = Some v) =\n    (ks = [] \\<and> vo = Some v \\<or>\n     (\\<exists>k t ks'.\n         ks = k # ks' \\<and>\n         (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))", "by simp metis"], ["proof (state)\nthis:\n  (lookup_trie (Trie vo kvs) ks = Some v) =\n  (ks = [] \\<and> vo = Some v \\<or>\n   (\\<exists>k t ks'.\n       ks = k # ks' \\<and>\n       (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (lookup_trie (Trie vo kvs) ks = Some v) =\n  (ks = [] \\<and> vo = Some v \\<or>\n   (\\<exists>k t ks'.\n       ks = k # ks' \\<and>\n       (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_eq_None_iff:\nassumes invar: \"invar_trie ((Trie vo kvs) :: ('key, 'val) trie)\"\nshows \"lookup_trie (Trie vo kvs) ks = None \\<longleftrightarrow>\n    (ks = [] \\<and> vo = None) \\<or>\n    (\\<exists>k ks'. ks = k # ks' \\<and> (\\<forall>t. (k, t) \\<in> set kvs \\<longrightarrow> lookup_trie t ks' = None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = None) =\n    (ks = [] \\<and> vo = None \\<or>\n     (\\<exists>k ks'.\n         ks = k # ks' \\<and>\n         (\\<forall>t.\n             (k, t) \\<in> set kvs \\<longrightarrow>\n             lookup_trie t ks' = None)))", "using lookup_eq_Some_iff[of vo kvs ks, OF invar]"], ["proof (prove)\nusing this:\n  (lookup_trie (Trie vo kvs) ks = Some ?v) =\n  (ks = [] \\<and> vo = Some ?v \\<or>\n   (\\<exists>k t ks'.\n       ks = k # ks' \\<and>\n       (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some ?v))\n\ngoal (1 subgoal):\n 1. (lookup_trie (Trie vo kvs) ks = None) =\n    (ks = [] \\<and> vo = None \\<or>\n     (\\<exists>k ks'.\n         ks = k # ks' \\<and>\n         (\\<forall>t.\n             (k, t) \\<in> set kvs \\<longrightarrow>\n             lookup_trie t ks' = None)))", "apply (cases ks)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                (lookup_trie (Trie vo kvs) ks = Some v) =\n                (ks = [] \\<and> vo = Some v \\<or>\n                 (\\<exists>k t ks'.\n                     ks = k # ks' \\<and>\n                     (k, t) \\<in> set kvs \\<and>\n                     lookup_trie t ks' = Some v));\n     ks = []\\<rbrakk>\n    \\<Longrightarrow> (lookup_trie (Trie vo kvs) ks = None) =\n                      (ks = [] \\<and> vo = None \\<or>\n                       (\\<exists>k ks'.\n                           ks = k # ks' \\<and>\n                           (\\<forall>t.\n                               (k, t) \\<in> set kvs \\<longrightarrow>\n                               lookup_trie t ks' = None)))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>v.\n                   (lookup_trie (Trie vo kvs) ks = Some v) =\n                   (ks = [] \\<and> vo = Some v \\<or>\n                    (\\<exists>k t ks'.\n                        ks = k # ks' \\<and>\n                        (k, t) \\<in> set kvs \\<and>\n                        lookup_trie t ks' = Some v));\n        ks = a # list\\<rbrakk>\n       \\<Longrightarrow> (lookup_trie (Trie vo kvs) ks = None) =\n                         (ks = [] \\<and> vo = None \\<or>\n                          (\\<exists>k ks'.\n                              ks = k # ks' \\<and>\n                              (\\<forall>t.\n                                  (k, t) \\<in> set kvs \\<longrightarrow>\n                                  lookup_trie t ks' = None)))", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>v.\n                   (lookup_trie (Trie vo kvs) ks = Some v) =\n                   (ks = [] \\<and> vo = Some v \\<or>\n                    (\\<exists>k t ks'.\n                        ks = k # ks' \\<and>\n                        (k, t) \\<in> set kvs \\<and>\n                        lookup_trie t ks' = Some v));\n        ks = a # list\\<rbrakk>\n       \\<Longrightarrow> (lookup_trie (Trie vo kvs) ks = None) =\n                         (ks = [] \\<and> vo = None \\<or>\n                          (\\<exists>k ks'.\n                              ks = k # ks' \\<and>\n                              (\\<forall>t.\n                                  (k, t) \\<in> set kvs \\<longrightarrow>\n                                  lookup_trie t ks' = None)))", "apply (auto split: option.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list t.\n       \\<lbrakk>\\<And>v.\n                   \\<forall>t.\n                      (a, t) \\<in> set kvs \\<longrightarrow>\n                      lookup_trie t list \\<noteq> Some v;\n        ks = a # list; map_of kvs a = None; (a, t) \\<in> set kvs\\<rbrakk>\n       \\<Longrightarrow> lookup_trie t list = None\n 2. \\<And>a list x2 t.\n       \\<lbrakk>\\<And>v.\n                   \\<forall>t.\n                      (a, t) \\<in> set kvs \\<longrightarrow>\n                      lookup_trie t list \\<noteq> Some v;\n        ks = a # list; map_of kvs a = Some x2; lookup_trie x2 list = None;\n        (a, t) \\<in> set kvs\\<rbrakk>\n       \\<Longrightarrow> lookup_trie t list = None\n 3. \\<And>a list x2.\n       \\<lbrakk>\\<And>v.\n                   (lookup_trie x2 list = Some v) =\n                   (\\<exists>t.\n                       (a, t) \\<in> set kvs \\<and>\n                       lookup_trie t list = Some v);\n        ks = a # list; map_of kvs a = Some x2;\n        \\<forall>t.\n           (a, t) \\<in> set kvs \\<longrightarrow>\n           lookup_trie t list = None\\<rbrakk>\n       \\<Longrightarrow> lookup_trie x2 list = None", "apply (metis option.simps(3) weak_map_of_SomeI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list x2 t.\n       \\<lbrakk>\\<And>v.\n                   \\<forall>t.\n                      (a, t) \\<in> set kvs \\<longrightarrow>\n                      lookup_trie t list \\<noteq> Some v;\n        ks = a # list; map_of kvs a = Some x2; lookup_trie x2 list = None;\n        (a, t) \\<in> set kvs\\<rbrakk>\n       \\<Longrightarrow> lookup_trie t list = None\n 2. \\<And>a list x2.\n       \\<lbrakk>\\<And>v.\n                   (lookup_trie x2 list = Some v) =\n                   (\\<exists>t.\n                       (a, t) \\<in> set kvs \\<and>\n                       lookup_trie t list = Some v);\n        ks = a # list; map_of kvs a = Some x2;\n        \\<forall>t.\n           (a, t) \\<in> set kvs \\<longrightarrow>\n           lookup_trie t list = None\\<rbrakk>\n       \\<Longrightarrow> lookup_trie x2 list = None", "apply (metis option.exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list x2.\n       \\<lbrakk>\\<And>v.\n                   (lookup_trie x2 list = Some v) =\n                   (\\<exists>t.\n                       (a, t) \\<in> set kvs \\<and>\n                       lookup_trie t list = Some v);\n        ks = a # list; map_of kvs a = Some x2;\n        \\<forall>t.\n           (a, t) \\<in> set kvs \\<longrightarrow>\n           lookup_trie t list = None\\<rbrakk>\n       \\<Longrightarrow> lookup_trie x2 list = None", "apply (metis option.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma update_not_empty: \"\\<not> is_empty_trie (update_trie ks v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (update_trie ks v t)", "apply(cases t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       t = Trie x1 x2 \\<Longrightarrow>\n       \\<not> is_empty_trie (update_trie ks v t)", "apply(rename_tac kvs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 kvs.\n       t = Trie x1 kvs \\<Longrightarrow>\n       \\<not> is_empty_trie (update_trie ks v t)", "apply(cases ks)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 kvs.\n       \\<lbrakk>t = Trie x1 kvs; ks = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_trie (update_trie ks v t)\n 2. \\<And>x1 kvs a list.\n       \\<lbrakk>t = Trie x1 kvs; ks = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_trie (update_trie ks v t)", "apply(case_tac [2] kvs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 kvs.\n       \\<lbrakk>t = Trie x1 kvs; ks = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_trie (update_trie ks v t)\n 2. \\<And>x1 kvs a list.\n       \\<lbrakk>t = Trie x1 kvs; ks = a # list; kvs = []\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_trie (update_trie ks v t)\n 3. \\<And>x1 kvs a list aa lista.\n       \\<lbrakk>t = Trie x1 kvs; ks = a # list; kvs = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<not> is_empty_trie (update_trie ks v t)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar_trie_update: \"invar_trie t \\<Longrightarrow> invar_trie (update_trie ks v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow> invar_trie (update_trie ks v t)", "by(induct ks t rule: update_trie_induct)(auto simp add: set_update_with_aux update_not_empty split: option.splits)"], ["", "lemma is_empty_lookup_empty:\n  \"invar_trie t \\<Longrightarrow> is_empty_trie t \\<longleftrightarrow> lookup_trie t = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow>\n    is_empty_trie t = (lookup_trie t = Map.empty)", "proof(induct t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> is_empty_trie t =\n                                     (lookup_trie t = Map.empty);\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> is_empty_trie (Trie vo kvs) =\n                         (lookup_trie (Trie vo kvs) = Map.empty)", "case (Trie vo kvs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?t) \\<in> set kvs; invar_trie ?t\\<rbrakk>\n  \\<Longrightarrow> is_empty_trie ?t = (lookup_trie ?t = Map.empty)\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> is_empty_trie t =\n                                     (lookup_trie t = Map.empty);\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> is_empty_trie (Trie vo kvs) =\n                         (lookup_trie (Trie vo kvs) = Map.empty)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?t) \\<in> set kvs; invar_trie ?t\\<rbrakk>\n  \\<Longrightarrow> is_empty_trie ?t = (lookup_trie ?t = Map.empty)\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. is_empty_trie (Trie vo kvs) = (lookup_trie (Trie vo kvs) = Map.empty)", "apply(cases kvs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>k t.\n                \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                \\<Longrightarrow> is_empty_trie t =\n                                  (lookup_trie t = Map.empty);\n     invar_trie (Trie vo kvs); kvs = []\\<rbrakk>\n    \\<Longrightarrow> is_empty_trie (Trie vo kvs) =\n                      (lookup_trie (Trie vo kvs) = Map.empty)\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> is_empty_trie t =\n                                     (lookup_trie t = Map.empty);\n        invar_trie (Trie vo kvs); kvs = a # list\\<rbrakk>\n       \\<Longrightarrow> is_empty_trie (Trie vo kvs) =\n                         (lookup_trie (Trie vo kvs) = Map.empty)", "apply(auto simp add: fun_eq_iff elim: allE[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b list.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>k = a \\<and> t = b \\<or> (k, t) \\<in> set list;\n                    invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> is_empty_trie t =\n                                     (\\<forall>x. lookup_trie t x = None);\n        kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            lookup_trie (Trie vo ((a, b) # list)) x = Some y", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b list.\n       \\<lbrakk>kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b;\n        \\<lbrakk>?k21 a b list = a \\<and> ?t23 a b list = b \\<or>\n                 (?k21 a b list, ?t23 a b list) \\<in> set list;\n         invar_trie (?t23 a b list)\\<rbrakk>\n        \\<Longrightarrow> is_empty_trie (?t23 a b list) =\n                          (\\<forall>x.\n                              lookup_trie (?t23 a b list) x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            lookup_trie (Trie vo ((a, b) # list)) x = Some y", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b list.\n       \\<lbrakk>kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b\\<rbrakk>\n       \\<Longrightarrow> ?k21 a b list = a \\<and> ?t23 a b list = b \\<or>\n                         (?k21 a b list, ?t23 a b list) \\<in> set list\n 2. \\<And>a b list.\n       \\<lbrakk>kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b;\n        invar_trie (?t23 a b list) \\<Longrightarrow>\n        is_empty_trie (?t23 a b list) =\n        (\\<forall>x. lookup_trie (?t23 a b list) x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            lookup_trie (Trie vo ((a, b) # list)) x = Some y", "apply(rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b list.\n       \\<lbrakk>kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b\\<rbrakk>\n       \\<Longrightarrow> ?k21 a b list = a \\<and> ?t23 a b list = b\n 2. \\<And>a b list.\n       \\<lbrakk>kvs = (a, b) # list; a \\<notin> fst ` set list;\n        distinct (map fst list);\n        \\<forall>x\\<in>set list.\n           case x of\n           (k, t) \\<Rightarrow> \\<not> is_empty_trie t \\<and> invar_trie t;\n        \\<not> is_empty_trie b; invar_trie b;\n        invar_trie (?t23 a b list) \\<Longrightarrow>\n        is_empty_trie (?t23 a b list) =\n        (\\<forall>x. lookup_trie (?t23 a b list) x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x y.\n                            lookup_trie (Trie vo ((a, b) # list)) x = Some y", "apply(fastforce intro: exI[where x=\"a # b\" for a b])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_empty_trie (Trie vo kvs) = (lookup_trie (Trie vo kvs) = Map.empty)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_update_with_trie:\n  \"lookup_trie (update_with_trie ks f t) ks' =\n  (if ks' = ks then Some(f(lookup_trie t ks')) else lookup_trie t ks')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_with_trie ks f t) ks' =\n    (if ks' = ks then Some (f (lookup_trie t ks')) else lookup_trie t ks')", "proof(induction ks t arbitrary: ks' rule: update_trie_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v ps ks'.\n       lookup_trie (update_with_trie [] f (Trie v ps)) ks' =\n       (if ks' = [] then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')\n 2. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v ps ks'.\n       lookup_trie (update_with_trie [] f (Trie v ps)) ks' =\n       (if ks' = [] then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')\n 2. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (update_with_trie [] f (Trie v_ ps_)) ks' =\n    (if ks' = [] then Some (f (lookup_trie (Trie v_ ps_) ks'))\n     else lookup_trie (Trie v_ ps_) ks')", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  lookup_trie (update_with_trie [] f (Trie v_ ps_)) ks' =\n  (if ks' = [] then Some (f (lookup_trie (Trie v_ ps_) ks'))\n   else lookup_trie (Trie v_ ps_) ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "have *: \"\\<And>xs y ys. (xs \\<noteq> y#ys) = (xs = [] \\<or> (\\<exists>x zs. xs = x#zs \\<and> (x \\<noteq> y \\<or> zs \\<noteq> ys)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs y ys.\n       (xs \\<noteq> y # ys) =\n       (xs = [] \\<or>\n        (\\<exists>x zs.\n            xs = x # zs \\<and> (x \\<noteq> y \\<or> zs \\<noteq> ys)))", "by auto (metis neq_Nil_conv)"], ["proof (state)\nthis:\n  (?xs \\<noteq> ?y # ?ys) =\n  (?xs = [] \\<or>\n   (\\<exists>x zs.\n       ?xs = x # zs \\<and> (x \\<noteq> ?y \\<or> zs \\<noteq> ?ys)))\n\ngoal (1 subgoal):\n 1. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "case 2"], ["proof (state)\nthis:\n  lookup_trie (update_with_trie ks_ f ?x1) ?ks'1 =\n  (if ?ks'1 = ks_ then Some (f (lookup_trie ?x1 ?ks'1))\n   else lookup_trie ?x1 ?ks'1)\n\ngoal (1 subgoal):\n 1. \\<And>k ks v ps ks'.\n       (\\<And>x ks'.\n           lookup_trie (update_with_trie ks f x) ks' =\n           (if ks' = ks then Some (f (lookup_trie x ks'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (update_with_trie (k # ks) f (Trie v ps)) ks' =\n       (if ks' = k # ks then Some (f (lookup_trie (Trie v ps) ks'))\n        else lookup_trie (Trie v ps) ks')", "thus ?case"], ["proof (prove)\nusing this:\n  lookup_trie (update_with_trie ks_ f ?x1) ?ks'1 =\n  (if ?ks'1 = ks_ then Some (f (lookup_trie ?x1 ?ks'1))\n   else lookup_trie ?x1 ?ks'1)\n\ngoal (1 subgoal):\n 1. lookup_trie (update_with_trie (k_ # ks_) f (Trie v_ ps_)) ks' =\n    (if ks' = k_ # ks_ then Some (f (lookup_trie (Trie v_ ps_) ks'))\n     else lookup_trie (Trie v_ ps_) ks')", "by(auto simp: * map_of_update_with_aux split: option.split)"], ["proof (state)\nthis:\n  lookup_trie (update_with_trie (k_ # ks_) f (Trie v_ ps_)) ks' =\n  (if ks' = k_ # ks_ then Some (f (lookup_trie (Trie v_ ps_) ks'))\n   else lookup_trie (Trie v_ ps_) ks')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{const delete_trie}\\<close>"], ["", "lemma delete_eq_empty_lookup_other_fail:\n  \"\\<lbrakk> delete_trie ks t = Trie None []; ks' \\<noteq> ks \\<rbrakk> \\<Longrightarrow> lookup_trie t ks' = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>delete_trie ks t = Trie None []; ks' \\<noteq> ks\\<rbrakk>\n    \\<Longrightarrow> lookup_trie t ks' = None", "proof(induct ks t arbitrary: ks' rule: delete_trie.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vo ts ks'.\n       \\<lbrakk>delete_trie [] (Trie vo ts) = Trie None [];\n        ks' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2;\n                    delete_trie ks x2 = Trie None [];\n                    ks' \\<noteq> ks\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie x2 ks' = None;\n        delete_trie (k # ks) (Trie vo ts) = Trie None [];\n        ks' \\<noteq> k # ks\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case 1"], ["proof (state)\nthis:\n  delete_trie [] (Trie vo_ ts_) = Trie None []\n  ks' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>vo ts ks'.\n       \\<lbrakk>delete_trie [] (Trie vo ts) = Trie None [];\n        ks' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2;\n                    delete_trie ks x2 = Trie None [];\n                    ks' \\<noteq> ks\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie x2 ks' = None;\n        delete_trie (k # ks) (Trie vo ts) = Trie None [];\n        ks' \\<noteq> k # ks\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "thus ?case"], ["proof (prove)\nusing this:\n  delete_trie [] (Trie vo_ ts_) = Trie None []\n  ks' \\<noteq> []\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo_ ts_) ks' = None", "by(auto simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  lookup_trie (Trie vo_ ts_) ks' = None\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2;\n                    delete_trie ks x2 = Trie None [];\n                    ks' \\<noteq> ks\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie x2 ks' = None;\n        delete_trie (k # ks) (Trie vo ts) = Trie None [];\n        ks' \\<noteq> k # ks\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2;\n                    delete_trie ks x2 = Trie None [];\n                    ks' \\<noteq> ks\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie x2 ks' = None;\n        delete_trie (k # ks) (Trie vo ts) = Trie None [];\n        ks' \\<noteq> k # ks\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case (2 k ks vo ts)"], ["proof (state)\nthis:\n  \\<lbrakk>map_of ts k = Some ?x2.0; delete_trie ks ?x2.0 = Trie None [];\n   ?ks' \\<noteq> ks\\<rbrakk>\n  \\<Longrightarrow> lookup_trie ?x2.0 ?ks' = None\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n  ks' \\<noteq> k # ks\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2;\n                    delete_trie ks x2 = Trie None [];\n                    ks' \\<noteq> ks\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie x2 ks' = None;\n        delete_trie (k # ks) (Trie vo ts) = Trie None [];\n        ks' \\<noteq> k # ks\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "proof(cases \"map_of ts k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (Trie vo ts) ks' = None", "case (Some t)"], ["proof (state)\nthis:\n  map_of ts k = Some t\n\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (Trie vo ts) ks' = None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "proof(cases ks')"], ["proof (state)\ngoal (2 subgoals):\n 1. ks' = [] \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>a list.\n       ks' = a # list \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case (Cons k' ks'')"], ["proof (state)\nthis:\n  ks' = k' # ks''\n\ngoal (2 subgoals):\n 1. ks' = [] \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. \\<And>a list.\n       ks' = a # list \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "proof(cases \"k' = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. k' \\<noteq> k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case False"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. k' \\<noteq> k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "from Some Cons \"2.prems\"(1)"], ["proof (chain)\npicking this:\n  map_of ts k = Some t\n  ks' = k' # ks''\n  delete_trie (k # ks) (Trie vo ts) = Trie None []", "have \"AList.delete_aux k ts = []\""], ["proof (prove)\nusing this:\n  map_of ts k = Some t\n  ks' = k' # ks''\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n\ngoal (1 subgoal):\n 1. AList.delete_aux k ts = []", "by(clarsimp simp add: Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  AList.delete_aux k ts = []\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. k' \\<noteq> k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "with False"], ["proof (chain)\npicking this:\n  k' \\<noteq> k\n  AList.delete_aux k ts = []", "have \"map_of ts k' = None\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k\n  AList.delete_aux k ts = []\n\ngoal (1 subgoal):\n 1. map_of ts k' = None", "by(cases \"map_of ts k'\")(auto dest: map_of_SomeD simp add: delete_aux_eq_Nil_conv)"], ["proof (state)\nthis:\n  map_of ts k' = None\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None\n 2. k' \\<noteq> k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k' = None\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "using False Some Cons \"2.prems\"(1)"], ["proof (prove)\nusing this:\n  map_of ts k' = None\n  k' \\<noteq> k\n  map_of ts k = Some t\n  ks' = k' # ks''\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "by simp"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case True"], ["proof (state)\nthis:\n  k' = k\n\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "with Some \"2.prems\" Cons"], ["proof (chain)\npicking this:\n  map_of ts k = Some t\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n  ks' \\<noteq> k # ks\n  ks' = k' # ks''\n  k' = k", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = Some t\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n  ks' \\<noteq> k # ks\n  ks' = k' # ks''\n  k' = k\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "by(clarsimp simp add: \"2.hyps\" Let_def is_empty_conv split: if_split_asm)"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal (1 subgoal):\n 1. ks' = [] \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "qed(insert Some \"2.prems\"(1), simp add: Let_def split: if_split_asm)"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal (1 subgoal):\n 1. map_of ts k = None \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of ts k = None \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "case None"], ["proof (state)\nthis:\n  map_of ts k = None\n\ngoal (1 subgoal):\n 1. map_of ts k = None \\<Longrightarrow> lookup_trie (Trie vo ts) ks' = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = None\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "using \"2.prems\"(1)"], ["proof (prove)\nusing this:\n  map_of ts k = None\n  delete_trie (k # ks) (Trie vo ts) = Trie None []\n\ngoal (1 subgoal):\n 1. lookup_trie (Trie vo ts) ks' = None", "by simp"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (Trie vo ts) ks' = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_delete: \"invar_trie t \\<Longrightarrow>\n  lookup_trie (delete_trie ks t) ks' =\n  (if ks = ks' then None else lookup_trie t ks')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow>\n    lookup_trie (delete_trie ks t) ks' =\n    (if ks = ks' then None else lookup_trie t ks')", "proof(induct ks t arbitrary: ks' rule: delete_trie.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vo ts ks'.\n       invar_trie (Trie vo ts) \\<Longrightarrow>\n       lookup_trie (delete_trie [] (Trie vo ts)) ks' =\n       (if [] = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie (delete_trie ks x2) ks' =\n                                     (if ks = ks' then None\nelse lookup_trie x2 ks');\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts))\n                          ks' =\n                         (if k # ks = ks' then None\n                          else lookup_trie (Trie vo ts) ks')", "case 1"], ["proof (state)\nthis:\n  invar_trie (Trie vo_ ts_)\n\ngoal (2 subgoals):\n 1. \\<And>vo ts ks'.\n       invar_trie (Trie vo ts) \\<Longrightarrow>\n       lookup_trie (delete_trie [] (Trie vo ts)) ks' =\n       (if [] = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie (delete_trie ks x2) ks' =\n                                     (if ks = ks' then None\nelse lookup_trie x2 ks');\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts))\n                          ks' =\n                         (if k # ks = ks' then None\n                          else lookup_trie (Trie vo ts) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie [] (Trie vo_ ts_)) ks' =\n    (if [] = ks' then None else lookup_trie (Trie vo_ ts_) ks')", "by(fastforce dest: not_sym simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  lookup_trie (delete_trie [] (Trie vo_ ts_)) ks' =\n  (if [] = ks' then None else lookup_trie (Trie vo_ ts_) ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie (delete_trie ks x2) ks' =\n                                     (if ks = ks' then None\nelse lookup_trie x2 ks');\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts))\n                          ks' =\n                         (if k # ks = ks' then None\n                          else lookup_trie (Trie vo ts) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie (delete_trie ks x2) ks' =\n                                     (if ks = ks' then None\nelse lookup_trie x2 ks');\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts))\n                          ks' =\n                         (if k # ks = ks' then None\n                          else lookup_trie (Trie vo ts) ks')", "case (2 k ks vo ts)"], ["proof (state)\nthis:\n  \\<lbrakk>map_of ts k = Some ?x2.0; invar_trie ?x2.0\\<rbrakk>\n  \\<Longrightarrow> lookup_trie (delete_trie ks ?x2.0) ?ks' =\n                    (if ks = ?ks' then None else lookup_trie ?x2.0 ?ks')\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts ks'.\n       \\<lbrakk>\\<And>x2 ks'.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> lookup_trie (delete_trie ks x2) ks' =\n                                     (if ks = ks' then None\nelse lookup_trie x2 ks');\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts))\n                          ks' =\n                         (if k # ks = ks' then None\n                          else lookup_trie (Trie vo ts) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "proof(cases ks')"], ["proof (state)\ngoal (2 subgoals):\n 1. ks' = [] \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>a list.\n       ks' = a # list \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case Nil"], ["proof (state)\nthis:\n  ks' = []\n\ngoal (2 subgoals):\n 1. ks' = [] \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>a list.\n       ks' = a # list \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "thus ?thesis"], ["proof (prove)\nusing this:\n  ks' = []\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "by(simp split: option.split add: Let_def)"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks' = a # list \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks' = a # list \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case [simp]: (Cons k' ks'')"], ["proof (state)\nthis:\n  ks' = k' # ks''\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ks' = a # list \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "proof(cases \"k' = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. k' \\<noteq> k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case False"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. k' \\<noteq> k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "thus ?thesis"], ["proof (prove)\nusing this:\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "using \"2.prems\""], ["proof (prove)\nusing this:\n  k' \\<noteq> k\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "by(auto simp add: Let_def update_conv' map_of_delete_aux split: option.split)"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case [simp]: True"], ["proof (state)\nthis:\n  k' = k\n\ngoal (1 subgoal):\n 1. k' = k \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "proof(cases \"map_of ts k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case None"], ["proof (state)\nthis:\n  map_of ts k = None\n\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow>\n    lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = None\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "by simp"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "case (Some t)"], ["proof (state)\nthis:\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n       (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "proof(cases \"is_empty_trie (delete_trie ks t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of ts k = Some t; is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')\n 2. \\<lbrakk>map_of ts k = Some t;\n     \\<not> is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')", "case True"], ["proof (state)\nthis:\n  is_empty_trie (delete_trie ks t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of ts k = Some t; is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')\n 2. \\<lbrakk>map_of ts k = Some t;\n     \\<not> is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')", "with Some \"2.prems\""], ["proof (chain)\npicking this:\n  map_of ts k = Some t\n  invar_trie (Trie vo ts)\n  is_empty_trie (delete_trie ks t)", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = Some t\n  invar_trie (Trie vo ts)\n  is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "by(auto simp add: map_of_delete_aux is_empty_conv dest: delete_eq_empty_lookup_other_fail)"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of ts k = Some t;\n     \\<not> is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of ts k = Some t;\n     \\<not> is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')", "case False"], ["proof (state)\nthis:\n  \\<not> is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of ts k = Some t;\n     \\<not> is_empty_trie (delete_trie ks t)\\<rbrakk>\n    \\<Longrightarrow> lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n                      (if k # ks = ks' then None\n                       else lookup_trie (Trie vo ts) ks')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "using Some 2"], ["proof (prove)\nusing this:\n  \\<not> is_empty_trie (delete_trie ks t)\n  map_of ts k = Some t\n  \\<lbrakk>map_of ts k = Some ?x2.0; invar_trie ?x2.0\\<rbrakk>\n  \\<Longrightarrow> lookup_trie (delete_trie ks ?x2.0) ?ks' =\n                    (if ks = ?ks' then None else lookup_trie ?x2.0 ?ks')\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n    (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')", "by(auto simp add: update_conv')"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup_trie (delete_trie (k # ks) (Trie vo ts)) ks' =\n  (if k # ks = ks' then None else lookup_trie (Trie vo ts) ks')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_delete':\n  \"invar_trie t \\<Longrightarrow> lookup_trie (delete_trie ks t) = (lookup_trie t)(ks := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow>\n    lookup_trie (delete_trie ks t) = (lookup_trie t)(ks := None)", "by(rule ext)(simp add: lookup_delete)"], ["", "lemma invar_trie_delete:\n  \"invar_trie t \\<Longrightarrow> invar_trie (delete_trie ks t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow> invar_trie (delete_trie ks t)", "proof(induct ks t rule: delete_trie.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vo ts.\n       invar_trie (Trie vo ts) \\<Longrightarrow>\n       invar_trie (delete_trie [] (Trie vo ts))\n 2. \\<And>k ks vo ts.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> invar_trie (delete_trie ks x2);\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> invar_trie (delete_trie (k # ks) (Trie vo ts))", "case 1"], ["proof (state)\nthis:\n  invar_trie (Trie vo_ ts_)\n\ngoal (2 subgoals):\n 1. \\<And>vo ts.\n       invar_trie (Trie vo ts) \\<Longrightarrow>\n       invar_trie (delete_trie [] (Trie vo ts))\n 2. \\<And>k ks vo ts.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> invar_trie (delete_trie ks x2);\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> invar_trie (delete_trie (k # ks) (Trie vo ts))", "thus ?case"], ["proof (prove)\nusing this:\n  invar_trie (Trie vo_ ts_)\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie [] (Trie vo_ ts_))", "by simp"], ["proof (state)\nthis:\n  invar_trie (delete_trie [] (Trie vo_ ts_))\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> invar_trie (delete_trie ks x2);\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> invar_trie (delete_trie (k # ks) (Trie vo ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> invar_trie (delete_trie ks x2);\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> invar_trie (delete_trie (k # ks) (Trie vo ts))", "case (2 k ks vo ts)"], ["proof (state)\nthis:\n  \\<lbrakk>map_of ts k = Some ?x2.0; invar_trie ?x2.0\\<rbrakk>\n  \\<Longrightarrow> invar_trie (delete_trie ks ?x2.0)\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. \\<And>k ks vo ts.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>map_of ts k = Some x2; invar_trie x2\\<rbrakk>\n                   \\<Longrightarrow> invar_trie (delete_trie ks x2);\n        invar_trie (Trie vo ts)\\<rbrakk>\n       \\<Longrightarrow> invar_trie (delete_trie (k # ks) (Trie vo ts))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "proof(cases \"map_of ts k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "case None"], ["proof (state)\nthis:\n  map_of ts k = None\n\ngoal (2 subgoals):\n 1. map_of ts k = None \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of ts k = None\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "using \"2.prems\""], ["proof (prove)\nusing this:\n  map_of ts k = None\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "by simp"], ["proof (state)\nthis:\n  invar_trie (delete_trie (k # ks) (Trie vo ts))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "case (Some t)"], ["proof (state)\nthis:\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "with \"2.prems\""], ["proof (chain)\npicking this:\n  invar_trie (Trie vo ts)\n  map_of ts k = Some t", "have \"invar_trie t\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo ts)\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. invar_trie t", "by auto"], ["proof (state)\nthis:\n  invar_trie t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "with Some"], ["proof (chain)\npicking this:\n  map_of ts k = Some t\n  invar_trie t", "have \"invar_trie (delete_trie ks t)\""], ["proof (prove)\nusing this:\n  map_of ts k = Some t\n  invar_trie t\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie ks t)", "by(rule 2)"], ["proof (state)\nthis:\n  invar_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "from \"2.prems\" Some"], ["proof (chain)\npicking this:\n  invar_trie (Trie vo ts)\n  map_of ts k = Some t", "have distinct: \"distinct (map fst ts)\" \"\\<not> is_empty_trie t\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo ts)\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. distinct (map fst ts) &&& \\<not> is_empty_trie t", "by auto"], ["proof (state)\nthis:\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of ts k = Some a \\<Longrightarrow>\n       invar_trie (delete_trie (k # ks) (Trie vo ts))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "proof(cases \"is_empty_trie (delete_trie ks t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "case True"], ["proof (state)\nthis:\n  is_empty_trie (delete_trie ks t)\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "{"], ["proof (state)\nthis:\n  is_empty_trie (delete_trie ks t)\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "fix k' t'"], ["proof (state)\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "assume k't': \"(k', t') \\<in> set (AList.delete_aux k ts)\""], ["proof (state)\nthis:\n  (k', t') \\<in> set (AList.delete_aux k ts)\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "with distinct"], ["proof (chain)\npicking this:\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n  (k', t') \\<in> set (AList.delete_aux k ts)", "have \"map_of (AList.delete_aux k ts) k' = Some t'\""], ["proof (prove)\nusing this:\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n  (k', t') \\<in> set (AList.delete_aux k ts)\n\ngoal (1 subgoal):\n 1. map_of (AList.delete_aux k ts) k' = Some t'", "by simp"], ["proof (state)\nthis:\n  map_of (AList.delete_aux k ts) k' = Some t'\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "hence \"map_of ts k' = Some t'\""], ["proof (prove)\nusing this:\n  map_of (AList.delete_aux k ts) k' = Some t'\n\ngoal (1 subgoal):\n 1. map_of ts k' = Some t'", "using distinct"], ["proof (prove)\nusing this:\n  map_of (AList.delete_aux k ts) k' = Some t'\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n\ngoal (1 subgoal):\n 1. map_of ts k' = Some t'", "by (auto \n            simp del: map_of_eq_Some_iff\n            simp add: map_of_delete_aux \n            split: if_split_asm)"], ["proof (state)\nthis:\n  map_of ts k' = Some t'\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "with \"2.prems\""], ["proof (chain)\npicking this:\n  invar_trie (Trie vo ts)\n  map_of ts k' = Some t'", "have \"\\<not> is_empty_trie t' \\<and> invar_trie t'\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo ts)\n  map_of ts k' = Some t'\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie t' \\<and> invar_trie t'", "by auto"], ["proof (state)\nthis:\n  \\<not> is_empty_trie t' \\<and> invar_trie t'\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "}"], ["proof (state)\nthis:\n  (?k'2, ?t'2) \\<in> set (AList.delete_aux k ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "with \"2.prems\""], ["proof (chain)\npicking this:\n  invar_trie (Trie vo ts)\n  (?k'2, ?t'2) \\<in> set (AList.delete_aux k ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2", "have \"invar_trie (Trie vo (AList.delete_aux k ts))\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo ts)\n  (?k'2, ?t'2) \\<in> set (AList.delete_aux k ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2\n\ngoal (1 subgoal):\n 1. invar_trie (Trie vo (AList.delete_aux k ts))", "by auto"], ["proof (state)\nthis:\n  invar_trie (Trie vo (AList.delete_aux k ts))\n\ngoal (2 subgoals):\n 1. is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))\n 2. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar_trie (Trie vo (AList.delete_aux k ts))\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "using True Some"], ["proof (prove)\nusing this:\n  invar_trie (Trie vo (AList.delete_aux k ts))\n  is_empty_trie (delete_trie ks t)\n  map_of ts k = Some t\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "by(simp)"], ["proof (state)\nthis:\n  invar_trie (delete_trie (k # ks) (Trie vo ts))\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "case False"], ["proof (state)\nthis:\n  \\<not> is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "{"], ["proof (state)\nthis:\n  \\<not> is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "fix k' t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "assume k't':\"(k', t') \\<in> set (AList.update k (delete_trie ks t) ts)\""], ["proof (state)\nthis:\n  (k', t') \\<in> set (AList.update k (delete_trie ks t) ts)\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "hence \"map_of (AList.update k (delete_trie ks t) ts) k' = Some t'\""], ["proof (prove)\nusing this:\n  (k', t') \\<in> set (AList.update k (delete_trie ks t) ts)\n\ngoal (1 subgoal):\n 1. map_of (AList.update k (delete_trie ks t) ts) k' = Some t'", "using \"2.prems\""], ["proof (prove)\nusing this:\n  (k', t') \\<in> set (AList.update k (delete_trie ks t) ts)\n  invar_trie (Trie vo ts)\n\ngoal (1 subgoal):\n 1. map_of (AList.update k (delete_trie ks t) ts) k' = Some t'", "by(auto simp add: distinct_update)"], ["proof (state)\nthis:\n  map_of (AList.update k (delete_trie ks t) ts) k' = Some t'\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "hence eq: \"((map_of ts)(k \\<mapsto> delete_trie ks t)) k' = Some t'\""], ["proof (prove)\nusing this:\n  map_of (AList.update k (delete_trie ks t) ts) k' = Some t'\n\ngoal (1 subgoal):\n 1. (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'", "unfolding update_conv"], ["proof (prove)\nusing this:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n\ngoal (1 subgoal):\n 1. (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'", "."], ["proof (state)\nthis:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "have \"\\<not> is_empty_trie t' \\<and> invar_trie t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie t' \\<and> invar_trie t'", "proof(cases \"k' = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> \\<not> is_empty_trie t' \\<and> invar_trie t'\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "case True"], ["proof (state)\nthis:\n  k' = k\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> \\<not> is_empty_trie t' \\<and> invar_trie t'\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "with eq"], ["proof (chain)\npicking this:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n  k' = k", "have \"t' = delete_trie ks t\""], ["proof (prove)\nusing this:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n  k' = k\n\ngoal (1 subgoal):\n 1. t' = delete_trie ks t", "by simp"], ["proof (state)\nthis:\n  t' = delete_trie ks t\n\ngoal (2 subgoals):\n 1. k' = k \\<Longrightarrow> \\<not> is_empty_trie t' \\<and> invar_trie t'\n 2. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "with \\<open>invar_trie (delete_trie ks t)\\<close> False"], ["proof (chain)\npicking this:\n  invar_trie (delete_trie ks t)\n  \\<not> is_empty_trie (delete_trie ks t)\n  t' = delete_trie ks t", "show ?thesis"], ["proof (prove)\nusing this:\n  invar_trie (delete_trie ks t)\n  \\<not> is_empty_trie (delete_trie ks t)\n  t' = delete_trie ks t\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie t' \\<and> invar_trie t'", "by simp"], ["proof (state)\nthis:\n  \\<not> is_empty_trie t' \\<and> invar_trie t'\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "case False"], ["proof (state)\nthis:\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "with eq distinct"], ["proof (chain)\npicking this:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n  k' \\<noteq> k", "have \"(k', t') \\<in> set ts\""], ["proof (prove)\nusing this:\n  (map_of ts(k \\<mapsto> delete_trie ks t)) k' = Some t'\n  distinct (map fst ts)\n  \\<not> is_empty_trie t\n  k' \\<noteq> k\n\ngoal (1 subgoal):\n 1. (k', t') \\<in> set ts", "by simp"], ["proof (state)\nthis:\n  (k', t') \\<in> set ts\n\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    \\<not> is_empty_trie t' \\<and> invar_trie t'", "with \"2.prems\""], ["proof (chain)\npicking this:\n  invar_trie (Trie vo ts)\n  (k', t') \\<in> set ts", "show ?thesis"], ["proof (prove)\nusing this:\n  invar_trie (Trie vo ts)\n  (k', t') \\<in> set ts\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie t' \\<and> invar_trie t'", "by auto"], ["proof (state)\nthis:\n  \\<not> is_empty_trie t' \\<and> invar_trie t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_empty_trie t' \\<and> invar_trie t'\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "}"], ["proof (state)\nthis:\n  (?k'2, ?t'2)\n  \\<in> set (AList.update k (delete_trie ks t) ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (delete_trie ks t) \\<Longrightarrow>\n    invar_trie (delete_trie (k # ks) (Trie vo ts))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?k'2, ?t'2)\n  \\<in> set (AList.update k (delete_trie ks t) ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "using Some \"2.prems\" False"], ["proof (prove)\nusing this:\n  (?k'2, ?t'2)\n  \\<in> set (AList.update k (delete_trie ks t) ts) \\<Longrightarrow>\n  \\<not> is_empty_trie ?t'2 \\<and> invar_trie ?t'2\n  map_of ts k = Some t\n  invar_trie (Trie vo ts)\n  \\<not> is_empty_trie (delete_trie ks t)\n\ngoal (1 subgoal):\n 1. invar_trie (delete_trie (k # ks) (Trie vo ts))", "by(auto simp add: distinct_update)"], ["proof (state)\nthis:\n  invar_trie (delete_trie (k # ks) (Trie vo ts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar_trie (delete_trie (k # ks) (Trie vo ts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar_trie (delete_trie (k # ks) (Trie vo ts))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{const update_with_trie}\\<close>"], ["", "(* FIXME mv *)"], ["", "lemma nonempty_update_with_aux: \"AList.update_with_aux v k f ps \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AList.update_with_aux v k f ps \\<noteq> []", "by (induction ps) auto"], ["", "lemma nonempty_update_with_trie: \"\\<not> is_empty_trie (update_with_trie ks f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (update_with_trie ks f t)", "by(induction ks t rule: update_trie_induct)\n  (auto simp: nonempty_update_with_aux)"], ["", "lemma invar_update_with_trie:\n  \"invar_trie t \\<Longrightarrow> invar_trie (update_with_trie ks f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow> invar_trie (update_with_trie ks f t)", "by(induction ks f t rule: update_with_trie.induct)\n  (auto simp: set_update_with_aux nonempty_update_with_trie\n     split: option.split prod.splits)"], ["", "subsection \\<open>Domain of a trie\\<close>"], ["", "lemma dom_lookup: \n  \"dom (lookup_trie (Trie vo kts)) = \n  (\\<Union>k\\<in>dom (map_of kts). Cons k ` dom (lookup_trie (the (map_of kts k)))) \\<union>\n  (if vo = None then {} else {[]})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (lookup_trie (Trie vo kts)) =\n    (\\<Union>k\\<in>dom (map_of kts).\n        (#) k ` dom (lookup_trie (the (map_of kts k)))) \\<union>\n    (if vo = None then {} else {[]})", "unfolding dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. lookup_trie (Trie vo kts) a \\<noteq> None} =\n    (\\<Union>k\\<in>{a. map_of kts a \\<noteq> None}.\n        (#) k `\n        {a. lookup_trie (the (map_of kts k)) a \\<noteq> None}) \\<union>\n    (if vo = None then {} else {[]})", "apply(rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>k\\<in>{a. map_of kts a \\<noteq> None}.\n        (#) k `\n        {a. lookup_trie (the (map_of kts k)) a \\<noteq> None}) \\<union>\n    (if vo = None then {} else {[]}) =\n    {a. lookup_trie (Trie vo kts) a \\<noteq> None}", "apply(safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x k xa y ya.\n       \\<lbrakk>map_of kts k = Some y;\n        lookup_trie (the (map_of kts k)) xa = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            lookup_trie (Trie vo kts) (k # xa) = Some y\n 2. \\<And>x.\n       x \\<in> (if vo = None then {} else {[]}) \\<Longrightarrow>\n       \\<exists>y. lookup_trie (Trie vo kts) x = Some y\n 3. \\<And>x y.\n       \\<lbrakk>x \\<notin> (if vo = None then {} else {[]});\n        lookup_trie (Trie vo kts) x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>k\\<in>{a.\n           map_of kts a \\<noteq> None}.\n                                     (#) k `\n                                     {a.\nlookup_trie (the (map_of kts k)) a \\<noteq> None})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (if vo = None then {} else {[]}) \\<Longrightarrow>\n       \\<exists>y. lookup_trie (Trie vo kts) x = Some y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<notin> (if vo = None then {} else {[]});\n        lookup_trie (Trie vo kts) x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>k\\<in>{a.\n           map_of kts a \\<noteq> None}.\n                                     (#) k `\n                                     {a.\nlookup_trie (the (map_of kts k)) a \\<noteq> None})", "apply(clarsimp simp add: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<notin> (if vo = None then {} else {[]});\n        lookup_trie (Trie vo kts) x = Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>k\\<in>{a.\n           map_of kts a \\<noteq> None}.\n                                     (#) k `\n                                     {a.\nlookup_trie (the (map_of kts k)) a \\<noteq> None})", "apply(case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<notin> (if vo = None then {} else {[]});\n        lookup_trie (Trie vo kts) x = Some y; x = []\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>k\\<in>{a.\n           map_of kts a \\<noteq> None}.\n                                     (#) k `\n                                     {a.\nlookup_trie (the (map_of kts k)) a \\<noteq> None})\n 2. \\<And>x y a list.\n       \\<lbrakk>x \\<notin> (if vo = None then {} else {[]});\n        lookup_trie (Trie vo kts) x = Some y; x = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>k\\<in>{a.\n           map_of kts a \\<noteq> None}.\n                                     (#) k `\n                                     {a.\nlookup_trie (the (map_of kts k)) a \\<noteq> None})", "apply(auto split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma finite_dom_lookup:\n  \"finite (dom (lookup_trie t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (lookup_trie t))", "proof(induct t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       (\\<And>k t.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           finite (dom (lookup_trie t))) \\<Longrightarrow>\n       finite (dom (lookup_trie (Trie vo kvs)))", "case (Trie vo kts)"], ["proof (state)\nthis:\n  (?k, ?t) \\<in> set kts \\<Longrightarrow> finite (dom (lookup_trie ?t))\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       (\\<And>k t.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           finite (dom (lookup_trie t))) \\<Longrightarrow>\n       finite (dom (lookup_trie (Trie vo kvs)))", "have \"finite (\\<Union>k\\<in>dom (map_of kts). Cons k ` dom (lookup_trie (the (map_of kts k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>k\\<in>dom (map_of kts).\n         (#) k ` dom (lookup_trie (the (map_of kts k))))", "proof(rule finite_UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom (map_of kts))\n 2. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "show \"finite (dom (map_of kts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map_of kts))", "by(rule finite_dom_map_of)"], ["proof (state)\nthis:\n  finite (dom (map_of kts))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "assume \"k \\<in> dom (map_of kts)\""], ["proof (state)\nthis:\n  k \\<in> dom (map_of kts)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "then"], ["proof (chain)\npicking this:\n  k \\<in> dom (map_of kts)", "obtain v where \"(k, v) \\<in> set kts\" \"map_of kts k = Some v\""], ["proof (prove)\nusing this:\n  k \\<in> dom (map_of kts)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>(k, v) \\<in> set kts; map_of kts k = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest: map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v) \\<in> set kts\n  map_of kts k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "hence \"finite (dom (lookup_trie (the (map_of kts k))))\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set kts\n  map_of kts k = Some v\n\ngoal (1 subgoal):\n 1. finite (dom (lookup_trie (the (map_of kts k))))", "by simp(rule Trie)"], ["proof (state)\nthis:\n  finite (dom (lookup_trie (the (map_of kts k))))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in> dom (map_of kts) \\<Longrightarrow>\n       finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "thus \"finite (Cons k ` dom (lookup_trie (the (map_of kts k))))\""], ["proof (prove)\nusing this:\n  finite (dom (lookup_trie (the (map_of kts k))))\n\ngoal (1 subgoal):\n 1. finite ((#) k ` dom (lookup_trie (the (map_of kts k))))", "by(rule finite_imageI)"], ["proof (state)\nthis:\n  finite ((#) k ` dom (lookup_trie (the (map_of kts k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   (\\<Union>k\\<in>dom (map_of kts).\n       (#) k ` dom (lookup_trie (the (map_of kts k))))\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       (\\<And>k t.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           finite (dom (lookup_trie t))) \\<Longrightarrow>\n       finite (dom (lookup_trie (Trie vo kvs)))", "thus ?case"], ["proof (prove)\nusing this:\n  finite\n   (\\<Union>k\\<in>dom (map_of kts).\n       (#) k ` dom (lookup_trie (the (map_of kts k))))\n\ngoal (1 subgoal):\n 1. finite (dom (lookup_trie (Trie vo kts)))", "by(simp add: dom_lookup)"], ["proof (state)\nthis:\n  finite (dom (lookup_trie (Trie vo kts)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dom_lookup_empty_conv: \"invar_trie t \\<Longrightarrow> dom (lookup_trie t) = {} \\<longleftrightarrow> is_empty_trie t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow>\n    (dom (lookup_trie t) = {}) = is_empty_trie t", "proof(induct t)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> (dom (lookup_trie t) = {}) =\n                                     is_empty_trie t;\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> (dom (lookup_trie (Trie vo kvs)) = {}) =\n                         is_empty_trie (Trie vo kvs)", "case (Trie vo kvs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?t) \\<in> set kvs; invar_trie ?t\\<rbrakk>\n  \\<Longrightarrow> (dom (lookup_trie ?t) = {}) = is_empty_trie ?t\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs.\n       \\<lbrakk>\\<And>k t.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> (dom (lookup_trie t) = {}) =\n                                     is_empty_trie t;\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> (dom (lookup_trie (Trie vo kvs)) = {}) =\n                         is_empty_trie (Trie vo kvs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom (lookup_trie (Trie vo kvs)) = {}) = is_empty_trie (Trie vo kvs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dom (lookup_trie (Trie vo kvs)) = {} \\<Longrightarrow>\n    is_empty_trie (Trie vo kvs)\n 2. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "assume dom: \"dom (lookup_trie (Trie vo kvs)) = {}\""], ["proof (state)\nthis:\n  dom (lookup_trie (Trie vo kvs)) = {}\n\ngoal (2 subgoals):\n 1. dom (lookup_trie (Trie vo kvs)) = {} \\<Longrightarrow>\n    is_empty_trie (Trie vo kvs)\n 2. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "have \"vo = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vo = None", "proof(cases vo)"], ["proof (state)\ngoal (2 subgoals):\n 1. vo = None \\<Longrightarrow> vo = None\n 2. \\<And>a. vo = Some a \\<Longrightarrow> vo = None", "case (Some v)"], ["proof (state)\nthis:\n  vo = Some v\n\ngoal (2 subgoals):\n 1. vo = None \\<Longrightarrow> vo = None\n 2. \\<And>a. vo = Some a \\<Longrightarrow> vo = None", "hence \"[] \\<in> dom (lookup_trie (Trie vo kvs))\""], ["proof (prove)\nusing this:\n  vo = Some v\n\ngoal (1 subgoal):\n 1. [] \\<in> dom (lookup_trie (Trie vo kvs))", "by auto"], ["proof (state)\nthis:\n  [] \\<in> dom (lookup_trie (Trie vo kvs))\n\ngoal (2 subgoals):\n 1. vo = None \\<Longrightarrow> vo = None\n 2. \\<And>a. vo = Some a \\<Longrightarrow> vo = None", "with dom"], ["proof (chain)\npicking this:\n  dom (lookup_trie (Trie vo kvs)) = {}\n  [] \\<in> dom (lookup_trie (Trie vo kvs))", "have False"], ["proof (prove)\nusing this:\n  dom (lookup_trie (Trie vo kvs)) = {}\n  [] \\<in> dom (lookup_trie (Trie vo kvs))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. vo = None \\<Longrightarrow> vo = None\n 2. \\<And>a. vo = Some a \\<Longrightarrow> vo = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. vo = None", ".."], ["proof (state)\nthis:\n  vo = None\n\ngoal (1 subgoal):\n 1. vo = None \\<Longrightarrow> vo = None", "qed"], ["proof (state)\nthis:\n  vo = None\n\ngoal (2 subgoals):\n 1. dom (lookup_trie (Trie vo kvs)) = {} \\<Longrightarrow>\n    is_empty_trie (Trie vo kvs)\n 2. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "moreover"], ["proof (state)\nthis:\n  vo = None\n\ngoal (2 subgoals):\n 1. dom (lookup_trie (Trie vo kvs)) = {} \\<Longrightarrow>\n    is_empty_trie (Trie vo kvs)\n 2. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "have \"kvs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kvs = []", "proof(cases kvs)"], ["proof (state)\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "case (Cons kt kvs')"], ["proof (state)\nthis:\n  kvs = kt # kvs'\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "with \\<open>invar_trie (Trie vo kvs)\\<close>"], ["proof (chain)\npicking this:\n  invar_trie (Trie vo kvs)\n  kvs = kt # kvs'", "have \"\\<not> is_empty_trie (snd kt)\" \"invar_trie (snd kt)\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo kvs)\n  kvs = kt # kvs'\n\ngoal (1 subgoal):\n 1. \\<not> is_empty_trie (snd kt) &&& invar_trie (snd kt)", "by auto"], ["proof (state)\nthis:\n  \\<not> is_empty_trie (snd kt)\n  invar_trie (snd kt)\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "from Cons"], ["proof (chain)\npicking this:\n  kvs = kt # kvs'", "have \"(fst kt, snd kt) \\<in> set kvs\""], ["proof (prove)\nusing this:\n  kvs = kt # kvs'\n\ngoal (1 subgoal):\n 1. (fst kt, snd kt) \\<in> set kvs", "by simp"], ["proof (state)\nthis:\n  (fst kt, snd kt) \\<in> set kvs\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "hence \"dom (lookup_trie (snd kt)) = {} \\<longleftrightarrow> is_empty_trie (snd kt)\""], ["proof (prove)\nusing this:\n  (fst kt, snd kt) \\<in> set kvs\n\ngoal (1 subgoal):\n 1. (dom (lookup_trie (snd kt)) = {}) = is_empty_trie (snd kt)", "using \\<open>invar_trie (snd kt)\\<close>"], ["proof (prove)\nusing this:\n  (fst kt, snd kt) \\<in> set kvs\n  invar_trie (snd kt)\n\ngoal (1 subgoal):\n 1. (dom (lookup_trie (snd kt)) = {}) = is_empty_trie (snd kt)", "by(rule Trie)"], ["proof (state)\nthis:\n  (dom (lookup_trie (snd kt)) = {}) = is_empty_trie (snd kt)\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "with \\<open>\\<not> is_empty_trie (snd kt)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> is_empty_trie (snd kt)\n  (dom (lookup_trie (snd kt)) = {}) = is_empty_trie (snd kt)", "have \"dom (lookup_trie (snd kt)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> is_empty_trie (snd kt)\n  (dom (lookup_trie (snd kt)) = {}) = is_empty_trie (snd kt)\n\ngoal (1 subgoal):\n 1. dom (lookup_trie (snd kt)) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  dom (lookup_trie (snd kt)) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "with dom Cons"], ["proof (chain)\npicking this:\n  dom (lookup_trie (Trie vo kvs)) = {}\n  kvs = kt # kvs'\n  dom (lookup_trie (snd kt)) \\<noteq> {}", "have False"], ["proof (prove)\nusing this:\n  dom (lookup_trie (Trie vo kvs)) = {}\n  kvs = kt # kvs'\n  dom (lookup_trie (snd kt)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by(auto simp add: dom_lookup)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. kvs = [] \\<Longrightarrow> kvs = []\n 2. \\<And>a list. kvs = a # list \\<Longrightarrow> kvs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. kvs = []", ".."], ["proof (state)\nthis:\n  kvs = []\n\ngoal (1 subgoal):\n 1. kvs = [] \\<Longrightarrow> kvs = []", "qed"], ["proof (state)\nthis:\n  kvs = []\n\ngoal (2 subgoals):\n 1. dom (lookup_trie (Trie vo kvs)) = {} \\<Longrightarrow>\n    is_empty_trie (Trie vo kvs)\n 2. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "ultimately"], ["proof (chain)\npicking this:\n  vo = None\n  kvs = []", "show \"is_empty_trie (Trie vo kvs)\""], ["proof (prove)\nusing this:\n  vo = None\n  kvs = []\n\ngoal (1 subgoal):\n 1. is_empty_trie (Trie vo kvs)", "by simp"], ["proof (state)\nthis:\n  is_empty_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "assume \"is_empty_trie (Trie vo kvs)\""], ["proof (state)\nthis:\n  is_empty_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. is_empty_trie (Trie vo kvs) \\<Longrightarrow>\n    dom (lookup_trie (Trie vo kvs)) = {}", "thus \"dom (lookup_trie (Trie vo kvs)) = {}\""], ["proof (prove)\nusing this:\n  is_empty_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. dom (lookup_trie (Trie vo kvs)) = {}", "by(simp add: lookup_empty[unfolded empty_trie_def])"], ["proof (state)\nthis:\n  dom (lookup_trie (Trie vo kvs)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (dom (lookup_trie (Trie vo kvs)) = {}) = is_empty_trie (Trie vo kvs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Range of a trie\\<close>"], ["", "lemma ran_lookup_Trie: \"invar_trie (Trie vo ps) \\<Longrightarrow>\n  ran (lookup_trie (Trie vo ps)) =\n  (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {v}) \\<union> (UN (k,t) : set ps. ran(lookup_trie t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie (Trie vo ps) \\<Longrightarrow>\n    ran (lookup_trie (Trie vo ps)) =\n    (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {v}) \\<union>\n    (\\<Union>(k, t)\\<in>set ps. ran (lookup_trie t))", "by(auto simp add: ran_def lookup_eq_Some_iff split: prod.splits option.split)"], ["", "lemma all_trie_eq_ran:\n  \"invar_trie t \\<Longrightarrow> all_trie P t = (\\<forall>x \\<in> ran(lookup_trie t). P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow>\n    all_trie P t = (\\<forall>x\\<in>ran (lookup_trie t). P x)", "by(induction P t rule: all_trie.induct)\n  (auto simp add: ran_lookup_Trie split: prod.splits option.split)"], ["", "end"]]}