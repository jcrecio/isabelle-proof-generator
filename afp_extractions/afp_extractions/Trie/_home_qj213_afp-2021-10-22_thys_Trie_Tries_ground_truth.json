{"file_name": "/home/qj213/afp-2021-10-22/thys/Trie/Tries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Trie", "problem_names": ["lemma lookup_Nil[simp]:\n  \"lookup_tries (Trie vo ps) [] = (case vo of None \\<Rightarrow> [] | Some vs \\<Rightarrow> vs)\"", "lemma lookup_Cons[simp]: \"lookup_tries (Trie vo ps) (a#as) =\n  (case map_of ps a of None \\<Rightarrow> [] | Some at \\<Rightarrow> lookup_tries at as)\"", "lemma lookup_empty[simp]: \"lookup_tries (Trie None []) as = []\"", "theorem lookup_update:\n \"lookup_tries (update_trie as vs t) bs =\n (if as=bs then vs else lookup_tries t bs)\"", "theorem lookup_update_with:\n \"lookup_tries (update_with_tries as f t) bs =\n (if as=bs then f(lookup_tries t as) else lookup_tries t bs)\"", "lemma invar_insert_tries: \"invar_trie t \\<Longrightarrow> invar_trie(insert_tries as v t)\"", "lemma invar_inserts_tries:\n  \"invar_trie t \\<Longrightarrow> invar_trie (inserts_tries key xs t)\"", "lemma invar_of_list: \"invar_trie (tries_of_list key xs)\"", "lemma set_lookup_insert_tries: \"set (lookup_tries (insert_tries ks a t) ks') =\n  (if ks' = ks then Set.insert a (set(lookup_tries t ks')) else set(lookup_tries t ks'))\"", "lemma in_set_lookup_inserts_tries:\n  \"(v \\<in> set(lookup_tries (inserts_tries key vs t) (key v))) =\n   (v \\<in> set vs \\<union> set(lookup_tries t (key v)))\"", "lemma in_set_lookup_of_list:\n  \"v \\<in> set(lookup_tries (tries_of_list key vs) (key v)) = (v \\<in> set vs)\"", "lemma in_set_lookup_inserts_triesD:\n  \"v \\<in> set(lookup_tries (inserts_tries key vs t) xs) \\<Longrightarrow>\n  v \\<in> set vs \\<union> set(lookup_tries t xs)\"", "lemma in_set_lookup_of_listD:\n  \"v \\<in> set(lookup_tries (tries_of_list f vs) xs) \\<Longrightarrow> v \\<in> set vs\"", "lemma set_tries_eq_ran: \"set_tries t = Union(set ` ran(lookup_trie t))\"", "lemma set_tries_empty[simp]: \"set_tries (Trie None []) = {}\"", "lemma set_tries_insert[simp]:\n  \"set_tries (insert_tries a x t) = Set.insert x (set_tries t)\"", "lemma set_insert_tries:\n  \"set_tries (inserts_tries key xs t) =\n   set xs Un set_tries t\"", "lemma set_tries_of_list[simp]:\n  \"set_tries(tries_of_list key xs) = set xs\"", "lemma in_set_lookup_set_triesD:\n  \"x\\<in>set (lookup_tries t a) \\<Longrightarrow> x \\<in> set_tries t\""], "translations": [["", "lemma lookup_Nil[simp]:\n  \"lookup_tries (Trie vo ps) [] = (case vo of None \\<Rightarrow> [] | Some vs \\<Rightarrow> vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_tries (Trie vo ps) [] =\n    (case vo of None \\<Rightarrow> [] | Some vs \\<Rightarrow> vs)", "by (simp add: lookup_tries_def)"], ["", "lemma lookup_Cons[simp]: \"lookup_tries (Trie vo ps) (a#as) =\n  (case map_of ps a of None \\<Rightarrow> [] | Some at \\<Rightarrow> lookup_tries at as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_tries (Trie vo ps) (a # as) =\n    (case map_of ps a of None \\<Rightarrow> []\n     | Some at \\<Rightarrow> lookup_tries at as)", "by (simp add: lookup_tries_def split: option.split)"], ["", "lemma lookup_empty[simp]: \"lookup_tries (Trie None []) as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_tries (Trie None []) as = []", "by(case_tac as, simp_all add: lookup_tries_def)"], ["", "theorem lookup_update:\n \"lookup_tries (update_trie as vs t) bs =\n (if as=bs then vs else lookup_tries t bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_tries (update_trie as vs t) bs =\n    (if as = bs then vs else lookup_tries t bs)", "by(auto simp add: lookup_tries_def lookup_update)"], ["", "theorem lookup_update_with:\n \"lookup_tries (update_with_tries as f t) bs =\n (if as=bs then f(lookup_tries t as) else lookup_tries t bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_tries (update_with_tries as f t) bs =\n    (if as = bs then f (lookup_tries t as) else lookup_tries t bs)", "by(auto simp add: lookup_tries_def update_with_tries_def lookup_update_with_trie\n  split: option.split)"], ["", "subsection \\<open>@{const insert_tries}, @{const inserts_tries}, @{const tries_of_list}\\<close>"], ["", "lemma invar_insert_tries: \"invar_trie t \\<Longrightarrow> invar_trie(insert_tries as v t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow> invar_trie (insert_tries as v t)", "by(simp add: insert_tries_def invar_update_with_trie split: option.split)"], ["", "lemma invar_inserts_tries:\n  \"invar_trie t \\<Longrightarrow> invar_trie (inserts_tries key xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie t \\<Longrightarrow> invar_trie (inserts_tries key xs t)", "by(induct xs arbitrary: t)(auto simp: invar_insert_tries inserts_tries_def)"], ["", "lemma invar_of_list: \"invar_trie (tries_of_list key xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie (tries_of_list key xs)", "by(simp add: tries_of_list_def invar_inserts_tries)"], ["", "lemma set_lookup_insert_tries: \"set (lookup_tries (insert_tries ks a t) ks') =\n  (if ks' = ks then Set.insert a (set(lookup_tries t ks')) else set(lookup_tries t ks'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (lookup_tries (insert_tries ks a t) ks') =\n    (if ks' = ks then insert a (set (lookup_tries t ks'))\n     else set (lookup_tries t ks'))", "by(simp add: lookup_tries_def insert_tries_def lookup_update_with_trie set_eq_iff split: option.split)"], ["", "lemma in_set_lookup_inserts_tries:\n  \"(v \\<in> set(lookup_tries (inserts_tries key vs t) (key v))) =\n   (v \\<in> set vs \\<union> set(lookup_tries t (key v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> set (lookup_tries (inserts_tries key vs t) (key v))) =\n    (v \\<in> set vs \\<union> set (lookup_tries t (key v)))", "by(induct vs arbitrary: t)\n  (auto simp add: inserts_tries_def set_lookup_insert_tries)"], ["", "lemma in_set_lookup_of_list:\n  \"v \\<in> set(lookup_tries (tries_of_list key vs) (key v)) = (v \\<in> set vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> set (lookup_tries (tries_of_list key vs) (key v))) =\n    (v \\<in> set vs)", "by(simp add: tries_of_list_def in_set_lookup_inserts_tries)"], ["", "lemma in_set_lookup_inserts_triesD:\n  \"v \\<in> set(lookup_tries (inserts_tries key vs t) xs) \\<Longrightarrow>\n  v \\<in> set vs \\<union> set(lookup_tries t xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (lookup_tries (inserts_tries key vs t) xs) \\<Longrightarrow>\n    v \\<in> set vs \\<union> set (lookup_tries t xs)", "apply(induct vs arbitrary: t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       v \\<in> set (lookup_tries (inserts_tries key [] t)\n                     xs) \\<Longrightarrow>\n       v \\<in> set [] \\<union> set (lookup_tries t xs)\n 2. \\<And>a vs t.\n       \\<lbrakk>\\<And>t.\n                   v \\<in> set (lookup_tries (inserts_tries key vs t)\n                                 xs) \\<Longrightarrow>\n                   v \\<in> set vs \\<union> set (lookup_tries t xs);\n        v \\<in> set (lookup_tries (inserts_tries key (a # vs) t)\n                      xs)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> set (a # vs) \\<union>\n                                 set (lookup_tries t xs)", "apply (simp add: inserts_tries_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs t.\n       \\<lbrakk>\\<And>t.\n                   v \\<in> set (lookup_tries (inserts_tries key vs t)\n                                 xs) \\<Longrightarrow>\n                   v \\<in> set vs \\<union> set (lookup_tries t xs);\n        v \\<in> set (lookup_tries (inserts_tries key (a # vs) t)\n                      xs)\\<rbrakk>\n       \\<Longrightarrow> v \\<in> set (a # vs) \\<union>\n                                 set (lookup_tries t xs)", "apply (simp add: inserts_tries_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs t.\n       \\<lbrakk>\\<And>t.\n                   v \\<in> set (lookup_tries\n                                 (fold (\\<lambda>v. insert_tries (key v) v)\n                                   vs t)\n                                 xs) \\<Longrightarrow>\n                   v \\<in> set vs \\<or> v \\<in> set (lookup_tries t xs);\n        v \\<in> set (lookup_tries\n                      (fold (\\<lambda>v. insert_tries (key v) v) vs\n                        (insert_tries (key a) a t))\n                      xs)\\<rbrakk>\n       \\<Longrightarrow> v = a \\<or>\n                         v \\<in> set vs \\<or>\n                         v \\<in> set (lookup_tries t xs)", "apply (fastforce simp add: set_lookup_insert_tries split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_set_lookup_of_listD:\n  \"v \\<in> set(lookup_tries (tries_of_list f vs) xs) \\<Longrightarrow> v \\<in> set vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (lookup_tries (tries_of_list f vs) xs) \\<Longrightarrow>\n    v \\<in> set vs", "by(auto simp: tries_of_list_def dest: in_set_lookup_inserts_triesD)"], ["", "subsection \\<open>@{const set_tries}\\<close>"], ["", "lemma set_tries_eq_ran: \"set_tries t = Union(set ` ran(lookup_trie t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tries t = \\<Union> (set ` ran (lookup_trie t))", "apply(auto simp add: set_eq_iff set_tries_def lookup_tries_def ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa a uu_.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> xa) =\n                   (\\<exists>uu_.\n                       Some uu_ = lookup_trie t a \\<and> x \\<in> set uu_);\n        Some uu_ = lookup_trie t a; x \\<in> set uu_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>a. lookup_trie t a = Some xa) \\<and>\n                            x \\<in> set xa\n 2. \\<And>x xa a.\n       \\<lbrakk>x \\<in> set xa; lookup_trie t a = Some xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>a.\n                                \\<forall>x.\n                                   (x \\<in> xa) =\n                                   (\\<exists>uu_.\n Some uu_ = lookup_trie t a \\<and> x \\<in> set uu_)) \\<and>\n                            x \\<in> xa", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa a.\n       \\<lbrakk>x \\<in> set xa; lookup_trie t a = Some xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>a.\n                                \\<forall>x.\n                                   (x \\<in> xa) =\n                                   (\\<exists>uu_.\n Some uu_ = lookup_trie t a \\<and> x \\<in> set uu_)) \\<and>\n                            x \\<in> xa", "by (metis option.inject)"], ["", "lemma set_tries_empty[simp]: \"set_tries (Trie None []) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tries (Trie None []) = {}", "by(simp add: set_tries_def)"], ["", "lemma set_tries_insert[simp]:\n  \"set_tries (insert_tries a x t) = Set.insert x (set_tries t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tries (insert_tries a x t) = insert x (set_tries t)", "apply(auto simp: set_tries_def lookup_update set_lookup_insert_tries)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa aa.\n       xa \\<in> set (lookup_tries t aa) \\<Longrightarrow>\n       \\<exists>xb.\n          (\\<exists>aa.\n              (aa = a \\<longrightarrow>\n               xb = insert x (set (lookup_tries t a))) \\<and>\n              (aa \\<noteq> a \\<longrightarrow>\n               xb = set (lookup_tries t aa))) \\<and>\n          xa \\<in> xb", "by (metis insert_iff)"], ["", "lemma set_insert_tries:\n  \"set_tries (inserts_tries key xs t) =\n   set xs Un set_tries t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tries (inserts_tries key xs t) = set xs \\<union> set_tries t", "by(induct xs arbitrary: t) (auto simp: inserts_tries_def)"], ["", "lemma set_tries_of_list[simp]:\n  \"set_tries(tries_of_list key xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tries (tries_of_list key xs) = set xs", "by(simp add: tries_of_list_def set_insert_tries)"], ["", "lemma in_set_lookup_set_triesD:\n  \"x\\<in>set (lookup_tries t a) \\<Longrightarrow> x \\<in> set_tries t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (lookup_tries t a) \\<Longrightarrow> x \\<in> set_tries t", "by(auto simp: set_tries_def)"], ["", "end"]]}