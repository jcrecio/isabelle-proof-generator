{"file_name": "/home/qj213/afp-2021-10-22/thys/Completeness/Formula.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Completeness", "problem_names": ["lemma X_deX[simp]: \"X (deX a) = a\"", "lemma nextX_nextX[iff]: \"nextX x = nextX y = (x =  y)\"", "lemma inj_nextX: \"inj nextX\"", "lemma ind': \"P zeroX ==> (! v . P v --> P (nextX v)) ==> P v'\"", "lemma ind: \"\\<lbrakk> P zeroX; \\<And> v. P v \\<Longrightarrow> P (nextX v) \\<rbrakk> \\<Longrightarrow> P v'\"", "lemma zeroX_nextX[iff]: \"zeroX ~= nextX a\" \\<comment> \\<open>FIXME iff?\\<close>", "lemmas nextX_zeroX[iff] = not_sym[OF zeroX_nextX]", "lemma nextX: \"nextX (X n) = X (Suc n)\"", "lemma vblcase_zeroX[simp]: \"vblcase a b zeroX = a\"", "lemma vblcase_nextX[simp]: \"vblcase a b (nextX n) = b n\"", "lemma vbl_cases: \"x = zeroX | (? y . x = nextX y)\"", "lemma vbl_casesE: \"\\<lbrakk> x = zeroX \\<Longrightarrow> P; \\<And> y. x = nextX y \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma comp_vblcase: \"f o vblcase a b = vblcase (f a) (f o b)\"", "lemma equalOn_vblcaseI': \"equalOn (preImage nextX A) f g ==> equalOn A (vblcase x f) (vblcase x g)\"", "lemma equalOn_vblcaseI: \"(zeroX : A --> x=y) ==> equalOn (preImage nextX A) f g ==> equalOn A (vblcase x f) (vblcase y g)\"", "lemma X_deX_connection: \"X n : A = (n : (deX ` A))\"", "lemma finiteFreshVar: \"finite A ==> freshVar A ~: A\"", "lemma freshVarI: \"[| finite A; B <= A |] ==> freshVar A ~: B\"", "lemma freshVarI2: \"finite A ==> !x . x ~: A --> P x ==> P (freshVar A)\"", "lemmas vblsimps = vblcase_zeroX vblcase_nextX zeroX_nextX\n  nextX_zeroX nextX_nextX comp_vblcase", "lemma signsE: \"\\<lbrakk> signs = Neg \\<Longrightarrow> P; signs = Pos \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma expand_case_signs: \"Q(case_signs vpos vneg F) = ( \n  (F = Pos --> Q (vpos)) & \n  (F = Neg --> Q (vneg)) \n )\"", "lemma sign_arg_cong: \"x = y ==> sign z x = sign z y\"", "lemma formula_signs_induct: \"[|\n  ! p vs. P (FAtom Pos p vs);\n  ! p vs. P (FAtom Neg p vs);\n  !! A B  . [| P A; P B |] ==> P (FConj Pos A B);\n  !! A B  . [| P A; P B |] ==> P (FConj Neg A B);\n  !! A    . [| P A |] ==> P (FAll  Pos A); \n  !! A    . [| P A |] ==> P (FAll  Neg A) \n  |]\n  ==> P A\"", "lemma formula_signs_cases: \"!!P. \n  [| !! p vs . P (FAtom Pos p vs); \n  !! p vs . P (FAtom Neg p vs); \n  !! f1 f2  . P (FConj Pos f1 f2); \n  !! f1 f2  . P (FConj Neg f1 f2); \n  !! f1    . P (FAll  Pos f1); \n  !! f1    . P (FAll  Neg f1) |] \n  ==> P A\"", "lemma strong_formula_induct': \"!A. (! B. size B < size A --> P B) --> P A ==> ! A. size A = n --> P (A::formula)\"", "lemma strong_formula_induct: \"(! A. (! B. size B < size A --> P B) --> P A) ==> P (A::formula)\"", "lemma sizelemmas: \"size A < size (FConj z A B)\"\n  \"size B < size (FConj z A B)\"\n  \"size A < size (FAll  z A)\"", "lemma expand_case_formula:\n  \"Q(case_formula fatom fconj fall F) = ( \n  (! z P vs  . F = FAtom z P vs  --> Q (fatom z P vs)) & \n  (! z A0 A1 . F = FConj z A0 A1 --> Q (fconj z A0 A1)) & \n  (! z A     . F = FAll  z A     --> Q (fall  z A)) \n )\"", "lemma dualCompose: \"dual p q r o dual P Q R = dual (p o P) (q o Q) (r o R)\"", "lemma dualFNot': \"dual invSign invSign invSign = FNot\"", "lemma dualFNot: \"dual invSign id id (FNot A) = FNot (dual invSign id id A)\"", "lemma dualId: \"dual id id id A = A\"", "lemma freeVarsF_FNot[simp]: \"freeVarsF (FNot A) = freeVarsF A\"", "lemma finite_freeVarsF[simp]: \"finite (freeVarsF A)\"", "lemma freeVarsFL_nil[simp]: \"freeVarsFL ([]) = {}\"", "lemma freeVarsFL_cons: \"freeVarsFL (A#Gamma) = freeVarsF A \\<union> freeVarsFL Gamma\"", "lemma finite_freeVarsFL[simp]: \"finite (freeVarsFL gamma)\"", "lemma freeVarsDual: \"freeVarsF (dual p q r A) = freeVarsF A\"", "lemma size_subF: \"!!theta. size (subF theta A) = size (A::formula)\"", "lemma subFNot: \"!!theta. subF theta (FNot A) = FNot (subF theta A)\"", "lemma subFDual: \"!!theta. subF theta (dual p q r A) = dual p q r (subF theta A)\"", "lemma size_instance: \"!!v. size (instanceF v A) = size (A::formula)\"", "lemma instanceFDual: \"instanceF u (dual p q r A) = dual p q r (instanceF u A)\"", "lemma evalP_arg2_cong: \"x = y ==> evalP M p x = evalP M p y\"", "lemma objectsNonEmpty: \"objects M \\<noteq> {}\"", "lemma modelsNonEmptyI: \"fst (Rep_model M) \\<noteq> {}\"", "lemma evalF_FAll: \"evalF M phi (FAll Pos A) = (!x: (objects M). (evalF M (vblcase x (%v .phi v)) A))\"", "lemma evalF_FEx: \"evalF M phi (FAll Neg A) = ( ? x:(objects M). (evalF M (vblcase x (%v. phi v)) A))\"", "lemma evalF_arg2_cong: \"x = y ==> evalF M p x = evalF M p y\"", "lemma evalF_FNot: \"!!phi. evalF M phi (FNot A) = (\\<not> evalF M phi A)\"", "lemma evalF_equiv[rule_format]: \"! f g. (equalOn (freeVarsF A) f g) \\<longrightarrow> (evalF M f A = evalF M g A)\"", "lemma evalF_subF_eq: \"!phi theta. evalF M phi (subF theta A) = evalF M (phi o theta) A\"", "lemma o_id'[simp]: \"f o (% x. x) = f\"", "lemma evalF_instance: \"evalF M phi (instanceF u A) = evalF M (vblcase (phi u) phi) A\"", "lemma s[simp]:\" FConj signs formula1 formula2 \\<noteq> formula1\"", "lemma s'[simp]:\" FConj signs formula1 formula2 \\<noteq> formula2\"", "lemma instanceF_E: \"instanceF g formula \\<noteq> FAll signs formula\""], "translations": [["", "lemma X_deX[simp]: \"X (deX a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (deX a) = a", "by(cases a) simp"], ["", "definition \"zeroX = X 0\""], ["", "primrec\n  nextX :: \"vbl => vbl\" where\n  \"nextX (X n) = X (Suc n)\""], ["", "definition\n  vblcase :: \"['a,vbl => 'a,vbl] => 'a\" where\n  \"vblcase a f n = (@z. (n=zeroX \\<longrightarrow> z=a) \\<and> (!x. n=nextX x \\<longrightarrow> z=f(x)))\""], ["", "declare [[case_translation vblcase zeroX nextX]]"], ["", "definition\n  freshVar :: \"vbl set => vbl\" where\n  \"freshVar vs = X (LEAST n. n \\<notin> deX ` vs)\""], ["", "lemma nextX_nextX[iff]: \"nextX x = nextX y = (x =  y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nextX x = nextX y) = (x = y)", "by(cases x, cases y) auto"], ["", "lemma inj_nextX: \"inj nextX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj nextX", "by(auto simp add: inj_on_def)"], ["", "lemma ind': \"P zeroX ==> (! v . P v --> P (nextX v)) ==> P v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v)\\<rbrakk>\n    \\<Longrightarrow> P v'", "apply (case_tac v', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X x\\<rbrakk>\n       \\<Longrightarrow> P (X x)", "apply(rename_tac nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X nat\\<rbrakk>\n       \\<Longrightarrow> P (X nat)", "apply(induct_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X nat\\<rbrakk>\n       \\<Longrightarrow> P (X 0)\n 2. \\<And>nat n.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X nat; P (X n)\\<rbrakk>\n       \\<Longrightarrow> P (X (Suc n))", "apply(simp add: zeroX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X nat; P (X n)\\<rbrakk>\n       \\<Longrightarrow> P (X (Suc n))", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>P zeroX; \\<forall>v. P v \\<longrightarrow> P (nextX v);\n        v' = X nat; P (X n)\\<rbrakk>\n       \\<Longrightarrow> P (X (Suc n))", "apply (drule_tac x=\"X n\" in spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ind: \"\\<lbrakk> P zeroX; \\<And> v. P v \\<Longrightarrow> P (nextX v) \\<rbrakk> \\<Longrightarrow> P v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P zeroX; \\<And>v. P v \\<Longrightarrow> P (nextX v)\\<rbrakk>\n    \\<Longrightarrow> P v'", "apply(rule ind')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P zeroX; \\<And>v. P v \\<Longrightarrow> P (nextX v)\\<rbrakk>\n    \\<Longrightarrow> P zeroX\n 2. \\<lbrakk>P zeroX; \\<And>v. P v \\<Longrightarrow> P (nextX v)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. P v \\<longrightarrow> P (nextX v)", "by auto"], ["", "lemma zeroX_nextX[iff]: \"zeroX ~= nextX a\" \\<comment> \\<open>FIXME iff?\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. zeroX \\<noteq> nextX a", "apply(case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. a = X x \\<Longrightarrow> zeroX \\<noteq> nextX a", "apply(simp add: zeroX_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas nextX_zeroX[iff] = not_sym[OF zeroX_nextX]"], ["", "lemma nextX: \"nextX (X n) = X (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nextX (X n) = X (Suc n)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma vblcase_zeroX[simp]: \"vblcase a b zeroX = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case zeroX of zeroX \\<Rightarrow> a | nextX x \\<Rightarrow> b x) = a", "by(simp add: vblcase_def)"], ["", "lemma vblcase_nextX[simp]: \"vblcase a b (nextX n) = b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case nextX n of zeroX \\<Rightarrow> a | nextX x \\<Rightarrow> b x) =\n    b n", "by(simp add: vblcase_def)"], ["", "lemma vbl_cases: \"x = zeroX | (? y . x = nextX y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = zeroX \\<or> (\\<exists>y. x = nextX y)", "apply(case_tac x, rename_tac m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       x = X m \\<Longrightarrow> x = zeroX \\<or> (\\<exists>y. x = nextX y)", "apply(case_tac m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>x = X m; m = 0\\<rbrakk>\n       \\<Longrightarrow> x = zeroX \\<or> (\\<exists>y. x = nextX y)\n 2. \\<And>m nat.\n       \\<lbrakk>x = X m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> x = zeroX \\<or> (\\<exists>y. x = nextX y)", "apply(simp add: zeroX_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m nat.\n       \\<lbrakk>x = X m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> x = zeroX \\<or> (\\<exists>y. x = nextX y)", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m nat.\n       \\<lbrakk>x = X m; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x = nextX y", "apply (rule_tac x=\"X nat\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma vbl_casesE: \"\\<lbrakk> x = zeroX \\<Longrightarrow> P; \\<And> y. x = nextX y \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = zeroX \\<Longrightarrow> P;\n     \\<And>y. x = nextX y \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply(auto intro: vbl_cases[elim_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma comp_vblcase: \"f o vblcase a b = vblcase (f a) (f o b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> vblcase a b = vblcase (f a) (f \\<circ> b)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (f \\<circ> vblcase a b) x =\n       (case x of zeroX \\<Rightarrow> f a\n        | nextX x \\<Rightarrow> (f \\<circ> b) x)", "apply(rule_tac x = x in vbl_casesE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = zeroX \\<Longrightarrow>\n       (f \\<circ> vblcase a b) x =\n       (case x of zeroX \\<Rightarrow> f a\n        | nextX x \\<Rightarrow> (f \\<circ> b) x)\n 2. \\<And>x y.\n       x = nextX y \\<Longrightarrow>\n       (f \\<circ> vblcase a b) x =\n       (case x of zeroX \\<Rightarrow> f a\n        | nextX x \\<Rightarrow> (f \\<circ> b) x)", "apply(simp_all add: vblcase_zeroX vblcase_nextX)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma equalOn_vblcaseI': \"equalOn (preImage nextX A) f g ==> equalOn A (vblcase x f) (vblcase x g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equalOn (preImage nextX A) f g \\<Longrightarrow>\n    equalOn A (vblcase x f) (vblcase x g)", "apply(simp add: equalOn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>preImage nextX A. f x = g x \\<Longrightarrow>\n    \\<forall>xa\\<in>A.\n       (case xa of zeroX \\<Rightarrow> x | nextX x \\<Rightarrow> f x) =\n       (case xa of zeroX \\<Rightarrow> x | nextX x \\<Rightarrow> g x)", "apply(rule+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x\\<in>preImage nextX A. f x = g x;\n        xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (case xa of zeroX \\<Rightarrow> x\n                          | nextX x \\<Rightarrow> f x) =\n                         (case xa of zeroX \\<Rightarrow> x\n                          | nextX x \\<Rightarrow> g x)", "apply (case_tac xa rule: vbl_casesE, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x\\<in>preImage nextX A. f x = g x; nextX y \\<in> A;\n        x = nextX y\\<rbrakk>\n       \\<Longrightarrow> f y = g y", "apply(drule_tac x=y in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>nextX y \\<in> A; x = nextX y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> preImage nextX A\n 2. \\<And>x y.\n       \\<lbrakk>nextX y \\<in> A; x = nextX y; f y = g y\\<rbrakk>\n       \\<Longrightarrow> f y = g y", "apply(simp add: preImage_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>nextX y \\<in> A; x = nextX y; f y = g y\\<rbrakk>\n       \\<Longrightarrow> f y = g y", "by assumption"], ["", "lemma equalOn_vblcaseI: \"(zeroX : A --> x=y) ==> equalOn (preImage nextX A) f g ==> equalOn A (vblcase x f) (vblcase y g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>zeroX \\<in> A \\<longrightarrow> x = y;\n     equalOn (preImage nextX A) f g\\<rbrakk>\n    \\<Longrightarrow> equalOn A (vblcase x f) (vblcase y g)", "apply (rule equalOnI, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>zeroX \\<in> A \\<longrightarrow> x = y;\n        equalOn (preImage nextX A) f g; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (case xa of zeroX \\<Rightarrow> x\n                          | nextX x \\<Rightarrow> f x) =\n                         (case xa of zeroX \\<Rightarrow> y\n                          | nextX x \\<Rightarrow> g x)", "apply (case_tac xa rule: vbl_casesE, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>zeroX \\<in> A \\<longrightarrow> x = y;\n        equalOn (preImage nextX A) f g; nextX ya \\<in> A;\n        xa = nextX ya\\<rbrakk>\n       \\<Longrightarrow> f ya = g ya", "apply(simp add: preImage_def equalOn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma X_deX_connection: \"X n : A = (n : (deX ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X n \\<in> A) = (n \\<in> deX ` A)", "by force"], ["", "lemma finiteFreshVar: \"finite A ==> freshVar A ~: A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> freshVar A \\<notin> A", "apply(simp add: freshVar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> X (LEAST n. n \\<notin> deX ` A) \\<notin> A", "apply(simp add: X_deX_connection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    (LEAST n. n \\<notin> deX ` A) \\<notin> deX ` A", "apply(rule_tac LeastI_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> \\<exists>x. x \\<notin> deX ` A", "apply(rule_tac x=\"(Suc (Max (deX ` A)))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> Suc (Max (deX ` A)) \\<notin> deX ` A", "apply(rule natset_finite_max)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow> finite (deX ` A)", "by force"], ["", "lemma freshVarI: \"[| finite A; B <= A |] ==> freshVar A ~: B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> freshVar A \\<notin> B", "apply(auto dest!: finiteFreshVar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma freshVarI2: \"finite A ==> !x . x ~: A --> P x ==> P (freshVar A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A;\n     \\<forall>x. x \\<notin> A \\<longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P (freshVar A)", "apply(auto dest!: finiteFreshVar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas vblsimps = vblcase_zeroX vblcase_nextX zeroX_nextX\n  nextX_zeroX nextX_nextX comp_vblcase"], ["", "subsection \"Predicates\""], ["", "datatype predicate = Predicate nat"], ["", "datatype signs = Pos | Neg"], ["", "lemma signsE: \"\\<lbrakk> signs = Neg \\<Longrightarrow> P; signs = Pos \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>signs = Neg \\<Longrightarrow> P;\n     signs = Pos \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply(cases signs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma expand_case_signs: \"Q(case_signs vpos vneg F) = ( \n  (F = Pos --> Q (vpos)) & \n  (F = Neg --> Q (vneg)) \n )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (case F of Pos \\<Rightarrow> vpos | Neg \\<Rightarrow> vneg) =\n    ((F = Pos \\<longrightarrow> Q vpos) \\<and>\n     (F = Neg \\<longrightarrow> Q vneg))", "by(induct F) simp_all"], ["", "primrec sign :: \"signs \\<Rightarrow> bool \\<Rightarrow> bool\"\nwhere\n  \"sign Pos x = x\"\n| \"sign Neg x = (\\<not> x)\""], ["", "lemma sign_arg_cong: \"x = y ==> sign z x = sign z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> sign z x = sign z y", "by simp"], ["", "primrec invSign :: \"signs \\<Rightarrow> signs\"\nwhere\n  \"invSign Pos = Neg\"\n| \"invSign Neg = Pos\""], ["", "subsection \"Formulas\""], ["", "datatype formula =\n    FAtom signs predicate \"(vbl list)\"\n  | FConj signs formula formula\n  | FAll  signs formula"], ["", "subsection \"formula signs induct, formula signs cases\""], ["", "lemma formula_signs_induct: \"[|\n  ! p vs. P (FAtom Pos p vs);\n  ! p vs. P (FAtom Neg p vs);\n  !! A B  . [| P A; P B |] ==> P (FConj Pos A B);\n  !! A B  . [| P A; P B |] ==> P (FConj Neg A B);\n  !! A    . [| P A |] ==> P (FAll  Pos A); \n  !! A    . [| P A |] ==> P (FAll  Neg A) \n  |]\n  ==> P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p vs. P (FAtom Pos p vs);\n     \\<forall>p vs. P (FAtom Neg p vs);\n     \\<And>A B.\n        \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Pos A B);\n     \\<And>A B.\n        \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Neg A B);\n     \\<And>A. P A \\<Longrightarrow> P (FAll Pos A);\n     \\<And>A. P A \\<Longrightarrow> P (FAll Neg A)\\<rbrakk>\n    \\<Longrightarrow> P A", "apply(induct_tac A)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>p vs. P (FAtom Pos p vs);\n        \\<forall>p vs. P (FAtom Neg p vs);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Pos A B);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Neg A B);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Pos A);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Neg A)\\<rbrakk>\n       \\<Longrightarrow> P (FAtom x1 x2 x3)\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>p vs. P (FAtom Pos p vs);\n        \\<forall>p vs. P (FAtom Neg p vs);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Pos A B);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Neg A B);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Pos A);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Neg A); P x2; P x3\\<rbrakk>\n       \\<Longrightarrow> P (FConj x1 x2 x3)\n 3. \\<And>x1 x2.\n       \\<lbrakk>\\<forall>p vs. P (FAtom Pos p vs);\n        \\<forall>p vs. P (FAtom Neg p vs);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Pos A B);\n        \\<And>A B.\n           \\<lbrakk>P A; P B\\<rbrakk> \\<Longrightarrow> P (FConj Neg A B);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Pos A);\n        \\<And>A. P A \\<Longrightarrow> P (FAll Neg A); P x2\\<rbrakk>\n       \\<Longrightarrow> P (FAll x1 x2)", "apply(rule signs.induct, force, force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma formula_signs_cases: \"!!P. \n  [| !! p vs . P (FAtom Pos p vs); \n  !! p vs . P (FAtom Neg p vs); \n  !! f1 f2  . P (FConj Pos f1 f2); \n  !! f1 f2  . P (FConj Neg f1 f2); \n  !! f1    . P (FAll  Pos f1); \n  !! f1    . P (FAll  Neg f1) |] \n  ==> P A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<And>p vs. P (FAtom Pos p vs);\n        \\<And>p vs. P (FAtom Neg p vs); \\<And>f1 f2. P (FConj Pos f1 f2);\n        \\<And>f1 f2. P (FConj Neg f1 f2); \\<And>f1. P (FAll Pos f1);\n        \\<And>f1. P (FAll Neg f1)\\<rbrakk>\n       \\<Longrightarrow> P A", "apply(induct_tac A)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P x1 x2 x3.\n       \\<lbrakk>\\<And>p vs. P (FAtom Pos p vs);\n        \\<And>p vs. P (FAtom Neg p vs); \\<And>f1 f2. P (FConj Pos f1 f2);\n        \\<And>f1 f2. P (FConj Neg f1 f2); \\<And>f1. P (FAll Pos f1);\n        \\<And>f1. P (FAll Neg f1)\\<rbrakk>\n       \\<Longrightarrow> P (FAtom x1 x2 x3)\n 2. \\<And>P x1 x2 x3.\n       \\<lbrakk>\\<And>p vs. P (FAtom Pos p vs);\n        \\<And>p vs. P (FAtom Neg p vs); \\<And>f1 f2. P (FConj Pos f1 f2);\n        \\<And>f1 f2. P (FConj Neg f1 f2); \\<And>f1. P (FAll Pos f1);\n        \\<And>f1. P (FAll Neg f1); P x2; P x3\\<rbrakk>\n       \\<Longrightarrow> P (FConj x1 x2 x3)\n 3. \\<And>P x1 x2.\n       \\<lbrakk>\\<And>p vs. P (FAtom Pos p vs);\n        \\<And>p vs. P (FAtom Neg p vs); \\<And>f1 f2. P (FConj Pos f1 f2);\n        \\<And>f1 f2. P (FConj Neg f1 f2); \\<And>f1. P (FAll Pos f1);\n        \\<And>f1. P (FAll Neg f1); P x2\\<rbrakk>\n       \\<Longrightarrow> P (FAll x1 x2)", "apply(rule signs.induct, force, force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n    \\<comment> \\<open>induction using nat induction, not wellfounded induction\\<close>"], ["", "lemma strong_formula_induct': \"!A. (! B. size B < size A --> P B) --> P A ==> ! A. size A = n --> P (A::formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       (\\<forall>B. size B < size A \\<longrightarrow> P B) \\<longrightarrow>\n       P A \\<Longrightarrow>\n    \\<forall>A. size A = n \\<longrightarrow> P A", "by (induct_tac n rule: nat_less_induct, blast)"], ["", "lemma strong_formula_induct: \"(! A. (! B. size B < size A --> P B) --> P A) ==> P (A::formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       (\\<forall>B. size B < size A \\<longrightarrow> P B) \\<longrightarrow>\n       P A \\<Longrightarrow>\n    P A", "by (rule strong_formula_induct'[rule_format], blast+)"], ["", "lemma sizelemmas: \"size A < size (FConj z A B)\"\n  \"size B < size (FConj z A B)\"\n  \"size A < size (FAll  z A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size A < size (FConj z A B) &&&\n    size B < size (FConj z A B) &&& size A < size (FAll z A)", "by auto"], ["", "lemma expand_case_formula:\n  \"Q(case_formula fatom fconj fall F) = ( \n  (! z P vs  . F = FAtom z P vs  --> Q (fatom z P vs)) & \n  (! z A0 A1 . F = FConj z A0 A1 --> Q (fconj z A0 A1)) & \n  (! z A     . F = FAll  z A     --> Q (fall  z A)) \n )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (case F of FAtom x xa xb \\<Rightarrow> fatom x xa xb\n       | FConj x xa xb \\<Rightarrow> fconj x xa xb\n       | FAll x xa \\<Rightarrow> fall x xa) =\n    ((\\<forall>z P vs.\n         F = FAtom z P vs \\<longrightarrow> Q (fatom z P vs)) \\<and>\n     (\\<forall>z A0 A1.\n         F = FConj z A0 A1 \\<longrightarrow> Q (fconj z A0 A1)) \\<and>\n     (\\<forall>z A. F = FAll z A \\<longrightarrow> Q (fall z A)))", "apply(cases F)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       F = FAtom x11 x12 x13 \\<Longrightarrow>\n       Q (case F of FAtom x xa xb \\<Rightarrow> fatom x xa xb\n          | FConj x xa xb \\<Rightarrow> fconj x xa xb\n          | FAll x xa \\<Rightarrow> fall x xa) =\n       ((\\<forall>z P vs.\n            F = FAtom z P vs \\<longrightarrow> Q (fatom z P vs)) \\<and>\n        (\\<forall>z A0 A1.\n            F = FConj z A0 A1 \\<longrightarrow> Q (fconj z A0 A1)) \\<and>\n        (\\<forall>z A. F = FAll z A \\<longrightarrow> Q (fall z A)))\n 2. \\<And>x21 x22 x23.\n       F = FConj x21 x22 x23 \\<Longrightarrow>\n       Q (case F of FAtom x xa xb \\<Rightarrow> fatom x xa xb\n          | FConj x xa xb \\<Rightarrow> fconj x xa xb\n          | FAll x xa \\<Rightarrow> fall x xa) =\n       ((\\<forall>z P vs.\n            F = FAtom z P vs \\<longrightarrow> Q (fatom z P vs)) \\<and>\n        (\\<forall>z A0 A1.\n            F = FConj z A0 A1 \\<longrightarrow> Q (fconj z A0 A1)) \\<and>\n        (\\<forall>z A. F = FAll z A \\<longrightarrow> Q (fall z A)))\n 3. \\<And>x31 x32.\n       F = FAll x31 x32 \\<Longrightarrow>\n       Q (case F of FAtom x xa xb \\<Rightarrow> fatom x xa xb\n          | FConj x xa xb \\<Rightarrow> fconj x xa xb\n          | FAll x xa \\<Rightarrow> fall x xa) =\n       ((\\<forall>z P vs.\n            F = FAtom z P vs \\<longrightarrow> Q (fatom z P vs)) \\<and>\n        (\\<forall>z A0 A1.\n            F = FConj z A0 A1 \\<longrightarrow> Q (fconj z A0 A1)) \\<and>\n        (\\<forall>z A. F = FAll z A \\<longrightarrow> Q (fall z A)))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec FNot :: \"formula => formula\"\nwhere\n  FNot_FAtom: \"FNot (FAtom z P vs)  = FAtom (invSign z) P vs\"\n| FNot_FConj: \"FNot (FConj z A0 A1) = FConj (invSign z) (FNot A0) (FNot A1)\"    \n| FNot_FAll:  \"FNot (FAll  z body)  = FAll  (invSign z) (FNot body)\""], ["", "primrec neg  :: \"signs => signs\"\nwhere\n  \"neg Pos = Neg\"\n| \"neg Neg = Pos\""], ["", "primrec\n  dual :: \"[(signs => signs),(signs => signs),(signs => signs)] => formula => formula\"\nwhere\n  dual_FAtom: \"dual p q r (FAtom z P vs)  = FAtom (p z) P vs\"\n| dual_FConj: \"dual p q r (FConj z A0 A1) = FConj (q z) (dual p q r A0) (dual p q r A1)\"\n| dual_FAll:  \"dual p q r (FAll  z body)  = FAll  (r z) (dual p q r body)\""], ["", "lemma dualCompose: \"dual p q r o dual P Q R = dual (p o P) (q o Q) (r o R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual p q r \\<circ> dual P Q R =\n    dual (p \\<circ> P) (q \\<circ> Q) (r \\<circ> R)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (dual p q r \\<circ> dual P Q R) x =\n       dual (p \\<circ> P) (q \\<circ> Q) (r \\<circ> R) x", "apply (induct_tac x, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dualFNot': \"dual invSign invSign invSign = FNot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual invSign invSign invSign = FNot", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. dual invSign invSign invSign x = FNot x", "apply(induct_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1 x2 x3.\n       dual invSign invSign invSign (FAtom x1 x2 x3) = FNot (FAtom x1 x2 x3)\n 2. \\<And>x x1 x2 x3.\n       \\<lbrakk>dual invSign invSign invSign x2 = FNot x2;\n        dual invSign invSign invSign x3 = FNot x3\\<rbrakk>\n       \\<Longrightarrow> dual invSign invSign invSign (FConj x1 x2 x3) =\n                         FNot (FConj x1 x2 x3)\n 3. \\<And>x x1 x2.\n       dual invSign invSign invSign x2 = FNot x2 \\<Longrightarrow>\n       dual invSign invSign invSign (FAll x1 x2) = FNot (FAll x1 x2)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dualFNot: \"dual invSign id id (FNot A) = FNot (dual invSign id id A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual invSign id id (FNot A) = FNot (dual invSign id id A)", "by(induct A) (auto simp: id_def)"], ["", "lemma dualId: \"dual id id id A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dual id id id A = A", "by(induct A) (auto simp: id_def)"], ["", "subsection \"Frees\""], ["", "primrec freeVarsF  :: \"formula => vbl set\"\nwhere\n  freeVarsFAtom: \"freeVarsF (FAtom z P vs)  = set vs\"\n| freeVarsFConj: \"freeVarsF (FConj z A0 A1) = (freeVarsF A0) Un (freeVarsF A1)\"    \n| freeVarsFAll:  \"freeVarsF (FAll  z body)  = preImage nextX (freeVarsF body)\""], ["", "definition\n  freeVarsFL :: \"formula list => vbl set\" where\n  \"freeVarsFL gamma = Union (freeVarsF ` (set gamma))\""], ["", "lemma freeVarsF_FNot[simp]: \"freeVarsF (FNot A) = freeVarsF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeVarsF (FNot A) = freeVarsF A", "by(induct A) auto"], ["", "lemma finite_freeVarsF[simp]: \"finite (freeVarsF A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (freeVarsF A)", "by(induct A) (auto simp add: inj_nextX finite_preImage)"], ["", "lemma freeVarsFL_nil[simp]: \"freeVarsFL ([]) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeVarsFL [] = {}", "by(simp add: freeVarsFL_def)"], ["", "lemma freeVarsFL_cons: \"freeVarsFL (A#Gamma) = freeVarsF A \\<union> freeVarsFL Gamma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeVarsFL (A # Gamma) = freeVarsF A \\<union> freeVarsFL Gamma", "by(simp add: freeVarsFL_def)\n    \\<comment> \\<open>FIXME not simp, since simp stops some later lemmas because the simpset isn't confluent\\<close>"], ["", "lemma finite_freeVarsFL[simp]: \"finite (freeVarsFL gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (freeVarsFL gamma)", "by(induct gamma) (auto simp: freeVarsFL_cons)"], ["", "lemma freeVarsDual: \"freeVarsF (dual p q r A) = freeVarsF A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freeVarsF (dual p q r A) = freeVarsF A", "by(induct A) auto"], ["", "subsection \"Substitutions\""], ["", "primrec subF :: \"[vbl => vbl,formula] => formula\"\nwhere\n  subFAtom: \"subF theta (FAtom z P vs)  = FAtom z P (map theta vs)\"\n| subFConj: \"subF theta (FConj z A0 A1) = FConj z (subF theta A0) (subF theta A1)\"\n| subFAll: \"subF theta (FAll z body)  = \n  FAll  z (subF (% v . (case v of zeroX => zeroX | nextX v => nextX (theta v))) body)\""], ["", "lemma size_subF: \"!!theta. size (subF theta A) = size (A::formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>theta. size (subF theta A) = size A", "by(induct A) auto"], ["", "lemma subFNot: \"!!theta. subF theta (FNot A) = FNot (subF theta A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>theta. subF theta (FNot A) = FNot (subF theta A)", "by(induct A) auto"], ["", "lemma subFDual: \"!!theta. subF theta (dual p q r A) = dual p q r (subF theta A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>theta. subF theta (dual p q r A) = dual p q r (subF theta A)", "by(induct A) auto"], ["", "definition\n  instanceF :: \"[vbl,formula] => formula\" where\n  \"instanceF w body = subF (%v. case v of zeroX => w | nextX v => v) body\""], ["", "lemma size_instance: \"!!v. size (instanceF v A) = size (A::formula)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. size (instanceF v A) = size A", "by(induct A) (auto simp: instanceF_def size_subF)"], ["", "lemma instanceFDual: \"instanceF u (dual p q r A) = dual p q r (instanceF u A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instanceF u (dual p q r A) = dual p q r (instanceF u A)", "by(induct A) (simp_all add: instanceF_def subFDual)"], ["", "subsection \"Models\""], ["", "typedecl\n  object"], ["", "axiomatization obj :: \"nat => object\"\nwhere inj_obj: \"inj obj\""], ["", "subsection \"model, non empty set and positive atom valuation\""], ["", "definition \"model = {z :: (object set * ([predicate,object list] => bool)). (fst z ~= {})}\""], ["", "typedef model = model"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> model", "unfolding model_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {z. fst z \\<noteq> {}}", "by auto"], ["", "definition\n  objects :: \"model => object set\" where\n  \"objects M = fst (Rep_model M)\""], ["", "definition\n  evalP :: \"model => predicate => object list => bool\" where\n  \"evalP M = snd (Rep_model M)\""], ["", "lemma evalP_arg2_cong: \"x = y ==> evalP M p x = evalP M p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> evalP M p x = evalP M p y", "by simp"], ["", "lemma objectsNonEmpty: \"objects M \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. objects M \\<noteq> {}", "using Rep_model[of M]"], ["proof (prove)\nusing this:\n  Rep_model M \\<in> model\n\ngoal (1 subgoal):\n 1. objects M \\<noteq> {}", "by(simp add: objects_def model_def)"], ["", "lemma modelsNonEmptyI: \"fst (Rep_model M) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Rep_model M) \\<noteq> {}", "using Rep_model[of M]"], ["proof (prove)\nusing this:\n  Rep_model M \\<in> model\n\ngoal (1 subgoal):\n 1. fst (Rep_model M) \\<noteq> {}", "by(simp add: objects_def model_def)"], ["", "subsection \"Validity\""], ["", "primrec evalF :: \"[model,vbl => object,formula] => bool\"\nwhere\n  evalFAtom: \"evalF M phi (FAtom z P vs)  = sign z (evalP M P (map phi vs))\"\n| evalFConj: \"evalF M phi (FConj z A0 A1) = sign z (sign z (evalF M phi A0) & sign z (evalF M phi A1))\"\n| evalFAll:  \"evalF M phi (FAll  z body)  = sign z (!x: (objects M).\n                                                       sign z\n                                                            (evalF M (%v . (case v of\n                                                                                zeroX   => x\n                                                                              | nextX v => phi v)) body))\""], ["", "definition\n  valid :: \"formula => bool\" where\n  \"valid F \\<longleftrightarrow> (\\<forall>M phi. evalF M phi F = True)\""], ["", "lemma evalF_FAll: \"evalF M phi (FAll Pos A) = (!x: (objects M). (evalF M (vblcase x (%v .phi v)) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalF M phi (FAll Pos A) =\n    (\\<forall>x\\<in>objects M. evalF M (vblcase x phi) A)", "by simp"], ["", "lemma evalF_FEx: \"evalF M phi (FAll Neg A) = ( ? x:(objects M). (evalF M (vblcase x (%v. phi v)) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalF M phi (FAll Neg A) =\n    (\\<exists>x\\<in>objects M. evalF M (vblcase x phi) A)", "by simp"], ["", "lemma evalF_arg2_cong: \"x = y ==> evalF M p x = evalF M p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> evalF M p x = evalF M p y", "by simp"], ["", "lemma evalF_FNot: \"!!phi. evalF M phi (FNot A) = (\\<not> evalF M phi A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>phi. evalF M phi (FNot A) = (\\<not> evalF M phi A)", "by(induct A rule: formula_signs_induct) simp_all"], ["", "lemma evalF_equiv[rule_format]: \"! f g. (equalOn (freeVarsF A) f g) \\<longrightarrow> (evalF M f A = evalF M g A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g.\n       equalOn (freeVarsF A) f g \\<longrightarrow> evalF M f A = evalF M g A", "apply(induct A)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<forall>f g.\n          equalOn (freeVarsF (FAtom x1 x2 x3)) f g \\<longrightarrow>\n          evalF M f (FAtom x1 x2 x3) = evalF M g (FAtom x1 x2 x3)\n 2. \\<And>x1 A1 A2.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A1) f g \\<longrightarrow>\n                   evalF M f A1 = evalF M g A1;\n        \\<forall>f g.\n           equalOn (freeVarsF A2) f g \\<longrightarrow>\n           evalF M f A2 = evalF M g A2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>f g.\n                            equalOn (freeVarsF (FConj x1 A1 A2)) f\n                             g \\<longrightarrow>\n                            evalF M f (FConj x1 A1 A2) =\n                            evalF M g (FConj x1 A1 A2)\n 3. \\<And>x1 A.\n       \\<forall>f g.\n          equalOn (freeVarsF A) f g \\<longrightarrow>\n          evalF M f A = evalF M g A \\<Longrightarrow>\n       \\<forall>f g.\n          equalOn (freeVarsF (FAll x1 A)) f g \\<longrightarrow>\n          evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply (force simp:equalOn_def cong: map_cong, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 A1 A2 f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A1) f g \\<longrightarrow>\n                   evalF M f A1 = evalF M g A1;\n        \\<forall>f g.\n           equalOn (freeVarsF A2) f g \\<longrightarrow>\n           evalF M f A2 = evalF M g A2;\n        equalOn (freeVarsF (FConj x1 A1 A2)) f g\\<rbrakk>\n       \\<Longrightarrow> evalF M f (FConj x1 A1 A2) =\n                         evalF M g (FConj x1 A1 A2)\n 2. \\<And>x1 A.\n       \\<forall>f g.\n          equalOn (freeVarsF A) f g \\<longrightarrow>\n          evalF M f A = evalF M g A \\<Longrightarrow>\n       \\<forall>f g.\n          equalOn (freeVarsF (FAll x1 A)) f g \\<longrightarrow>\n          evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 A1 A2 f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A1) f g \\<longrightarrow>\n                   evalF M f A1 = evalF M g A1;\n        \\<forall>f g.\n           equalOn (freeVarsF A2) f g \\<longrightarrow>\n           evalF M f A2 = evalF M g A2;\n        equalOn (freeVarsF A1 \\<union> freeVarsF A2) f g\\<rbrakk>\n       \\<Longrightarrow> sign x1\n                          (sign x1 (evalF M f A1) \\<and>\n                           sign x1 (evalF M f A2)) =\n                         sign x1\n                          (sign x1 (evalF M g A1) \\<and>\n                           sign x1 (evalF M g A2))\n 2. \\<And>x1 A.\n       \\<forall>f g.\n          equalOn (freeVarsF A) f g \\<longrightarrow>\n          evalF M f A = evalF M g A \\<Longrightarrow>\n       \\<forall>f g.\n          equalOn (freeVarsF (FAll x1 A)) f g \\<longrightarrow>\n          evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply(drule_tac equalOn_UnD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 A1 A2 f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A1) f g \\<longrightarrow>\n                   evalF M f A1 = evalF M g A1;\n        \\<forall>f g.\n           equalOn (freeVarsF A2) f g \\<longrightarrow>\n           evalF M f A2 = evalF M g A2;\n        equalOn (freeVarsF A1) f g \\<and>\n        equalOn (freeVarsF A2) f g\\<rbrakk>\n       \\<Longrightarrow> sign x1\n                          (sign x1 (evalF M f A1) \\<and>\n                           sign x1 (evalF M f A2)) =\n                         sign x1\n                          (sign x1 (evalF M g A1) \\<and>\n                           sign x1 (evalF M g A2))\n 2. \\<And>x1 A.\n       \\<forall>f g.\n          equalOn (freeVarsF A) f g \\<longrightarrow>\n          evalF M f A = evalF M g A \\<Longrightarrow>\n       \\<forall>f g.\n          equalOn (freeVarsF (FAll x1 A)) f g \\<longrightarrow>\n          evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 A.\n       \\<forall>f g.\n          equalOn (freeVarsF A) f g \\<longrightarrow>\n          evalF M f A = evalF M g A \\<Longrightarrow>\n       \\<forall>f g.\n          equalOn (freeVarsF (FAll x1 A)) f g \\<longrightarrow>\n          evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 A f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (freeVarsF (FAll x1 A)) f g\\<rbrakk>\n       \\<Longrightarrow> evalF M f (FAll x1 A) = evalF M g (FAll x1 A)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 A f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g\\<rbrakk>\n       \\<Longrightarrow> sign x1\n                          (\\<forall>x\\<in>objects M.\n                              sign x1\n                               (evalF M\n                                 (\\<lambda>v.\n                                     case v of zeroX \\<Rightarrow> x\n                                     | nextX v \\<Rightarrow> f v)\n                                 A)) =\n                         sign x1\n                          (\\<forall>x\\<in>objects M.\n                              sign x1\n                               (evalF M\n                                 (\\<lambda>v.\n                                     case v of zeroX \\<Rightarrow> x\n                                     | nextX v \\<Rightarrow> g v)\n                                 A))", "apply(rename_tac signs A f g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs A f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g\\<rbrakk>\n       \\<Longrightarrow> sign signs\n                          (\\<forall>x\\<in>objects M.\n                              sign signs\n                               (evalF M\n                                 (\\<lambda>v.\n                                     case v of zeroX \\<Rightarrow> x\n                                     | nextX v \\<Rightarrow> f v)\n                                 A)) =\n                         sign signs\n                          (\\<forall>x\\<in>objects M.\n                              sign signs\n                               (evalF M\n                                 (\\<lambda>v.\n                                     case v of zeroX \\<Rightarrow> x\n                                     | nextX v \\<Rightarrow> g v)\n                                 A))", "apply(rule_tac f = \"sign signs\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs A f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>objects M.\n                             sign signs\n                              (evalF M\n                                (\\<lambda>v.\n                                    case v of zeroX \\<Rightarrow> x\n                                    | nextX v \\<Rightarrow> f v)\n                                A)) =\n                         (\\<forall>x\\<in>objects M.\n                             sign signs\n                              (evalF M\n                                (\\<lambda>v.\n                                    case v of zeroX \\<Rightarrow> x\n                                    | nextX v \\<Rightarrow> g v)\n                                A))", "apply(rule ball_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>signs A f g.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g\\<rbrakk>\n       \\<Longrightarrow> objects M = objects M\n 2. \\<And>signs A f g x.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow> f v)\n                            A) =\n                         sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow> g v)\n                            A)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs A f g x.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow> f v)\n                            A) =\n                         sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow> g v)\n                            A)", "apply(rule_tac f = \"sign signs\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs A f g x.\n       \\<lbrakk>\\<forall>f g.\n                   equalOn (freeVarsF A) f g \\<longrightarrow>\n                   evalF M f A = evalF M g A;\n        equalOn (preImage nextX (freeVarsF A)) f g;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> evalF M\n                          (\\<lambda>v.\n                              case v of zeroX \\<Rightarrow> x\n                              | nextX v \\<Rightarrow> f v)\n                          A =\n                         evalF M\n                          (\\<lambda>v.\n                              case v of zeroX \\<Rightarrow> x\n                              | nextX v \\<Rightarrow> g v)\n                          A", "apply(force intro: equalOn_vblcaseI')"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>FIXME tricky to automate cong args convincingly?\\<close>\n\n    \\<comment> \\<open>composition of substitutions\\<close>"], ["", "lemma evalF_subF_eq: \"!phi theta. evalF M phi (subF theta A) = evalF M (phi o theta) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>phi theta.\n       evalF M phi (subF theta A) = evalF M (phi \\<circ> theta) A", "apply(induct_tac A)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<forall>phi theta.\n          evalF M phi (subF theta (FAtom x1 x2 x3)) =\n          evalF M (phi \\<circ> theta) (FAtom x1 x2 x3)\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta x2) =\n                   evalF M (phi \\<circ> theta) x2;\n        \\<forall>phi theta.\n           evalF M phi (subF theta x3) =\n           evalF M (phi \\<circ> theta) x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>phi theta.\n                            evalF M phi (subF theta (FConj x1 x2 x3)) =\n                            evalF M (phi \\<circ> theta) (FConj x1 x2 x3)\n 3. \\<And>x1 x2.\n       \\<forall>phi theta.\n          evalF M phi (subF theta x2) =\n          evalF M (phi \\<circ> theta) x2 \\<Longrightarrow>\n       \\<forall>phi theta.\n          evalF M phi (subF theta (FAll x1 x2)) =\n          evalF M (phi \\<circ> theta) (FAll x1 x2)", "apply(simp del: o_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta x2) =\n                   evalF M (phi \\<circ> theta) x2;\n        \\<forall>phi theta.\n           evalF M phi (subF theta x3) =\n           evalF M (phi \\<circ> theta) x3\\<rbrakk>\n       \\<Longrightarrow> \\<forall>phi theta.\n                            evalF M phi (subF theta (FConj x1 x2 x3)) =\n                            evalF M (phi \\<circ> theta) (FConj x1 x2 x3)\n 2. \\<And>x1 x2.\n       \\<forall>phi theta.\n          evalF M phi (subF theta x2) =\n          evalF M (phi \\<circ> theta) x2 \\<Longrightarrow>\n       \\<forall>phi theta.\n          evalF M phi (subF theta (FAll x1 x2)) =\n          evalF M (phi \\<circ> theta) (FAll x1 x2)", "apply(simp del: o_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<forall>phi theta.\n          evalF M phi (subF theta x2) =\n          evalF M (phi \\<circ> theta) x2 \\<Longrightarrow>\n       \\<forall>phi theta.\n          evalF M phi (subF theta (FAll x1 x2)) =\n          evalF M (phi \\<circ> theta) (FAll x1 x2)", "apply(intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 phi theta.\n       \\<forall>phi theta.\n          evalF M phi (subF theta x2) =\n          evalF M (phi \\<circ> theta) x2 \\<Longrightarrow>\n       evalF M phi (subF theta (FAll x1 x2)) =\n       evalF M (phi \\<circ> theta) (FAll x1 x2)", "apply(simp del: o_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 phi theta.\n       \\<forall>phi theta.\n          evalF M phi (subF theta x2) =\n          evalF M (phi \\<circ> theta) x2 \\<Longrightarrow>\n       sign x1\n        (\\<forall>x\\<in>objects M.\n            sign x1\n             (evalF M\n               ((\\<lambda>a.\n                    case a of zeroX \\<Rightarrow> x\n                    | nextX x \\<Rightarrow> phi x) \\<circ>\n                (\\<lambda>a.\n                    case a of zeroX \\<Rightarrow> zeroX\n                    | nextX v \\<Rightarrow> nextX (theta v)))\n               x2)) =\n       sign x1\n        (\\<forall>x\\<in>objects M.\n            sign x1\n             (evalF M\n               (\\<lambda>v.\n                   case v of zeroX \\<Rightarrow> x\n                   | nextX v \\<Rightarrow> (phi \\<circ> theta) v)\n               x2))", "apply(rename_tac signs phi0 phi theta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta.\n       \\<forall>phi theta.\n          evalF M phi (subF theta phi0) =\n          evalF M (phi \\<circ> theta) phi0 \\<Longrightarrow>\n       sign signs\n        (\\<forall>x\\<in>objects M.\n            sign signs\n             (evalF M\n               ((\\<lambda>a.\n                    case a of zeroX \\<Rightarrow> x\n                    | nextX x \\<Rightarrow> phi x) \\<circ>\n                (\\<lambda>a.\n                    case a of zeroX \\<Rightarrow> zeroX\n                    | nextX v \\<Rightarrow> nextX (theta v)))\n               phi0)) =\n       sign signs\n        (\\<forall>x\\<in>objects M.\n            sign signs\n             (evalF M\n               (\\<lambda>v.\n                   case v of zeroX \\<Rightarrow> x\n                   | nextX v \\<Rightarrow> (phi \\<circ> theta) v)\n               phi0))", "apply(rule_tac f=\"sign signs\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta.\n       \\<forall>phi theta.\n          evalF M phi (subF theta phi0) =\n          evalF M (phi \\<circ> theta) phi0 \\<Longrightarrow>\n       (\\<forall>x\\<in>objects M.\n           sign signs\n            (evalF M\n              ((\\<lambda>a.\n                   case a of zeroX \\<Rightarrow> x\n                   | nextX x \\<Rightarrow> phi x) \\<circ>\n               (\\<lambda>a.\n                   case a of zeroX \\<Rightarrow> zeroX\n                   | nextX v \\<Rightarrow> nextX (theta v)))\n              phi0)) =\n       (\\<forall>x\\<in>objects M.\n           sign signs\n            (evalF M\n              (\\<lambda>v.\n                  case v of zeroX \\<Rightarrow> x\n                  | nextX v \\<Rightarrow> (phi \\<circ> theta) v)\n              phi0))", "apply(rule ball_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>signs phi0 phi theta.\n       \\<forall>phi theta.\n          evalF M phi (subF theta phi0) =\n          evalF M (phi \\<circ> theta) phi0 \\<Longrightarrow>\n       objects M = objects M\n 2. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> sign signs\n                          (evalF M\n                            ((\\<lambda>a.\n                                 case a of zeroX \\<Rightarrow> x\n                                 | nextX x \\<Rightarrow> phi x) \\<circ>\n                             (\\<lambda>a.\n                                 case a of zeroX \\<Rightarrow> zeroX\n                                 | nextX v \\<Rightarrow> nextX (theta v)))\n                            phi0) =\n                         sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow>\n                                    (phi \\<circ> theta) v)\n                            phi0)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> sign signs\n                          (evalF M\n                            ((\\<lambda>a.\n                                 case a of zeroX \\<Rightarrow> x\n                                 | nextX x \\<Rightarrow> phi x) \\<circ>\n                             (\\<lambda>a.\n                                 case a of zeroX \\<Rightarrow> zeroX\n                                 | nextX v \\<Rightarrow> nextX (theta v)))\n                            phi0) =\n                         sign signs\n                          (evalF M\n                            (\\<lambda>v.\n                                case v of zeroX \\<Rightarrow> x\n                                | nextX v \\<Rightarrow>\n                                    (phi \\<circ> theta) v)\n                            phi0)", "apply(rule_tac f=\"sign signs\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> evalF M\n                          ((\\<lambda>a.\n                               case a of zeroX \\<Rightarrow> x\n                               | nextX x \\<Rightarrow> phi x) \\<circ>\n                           (\\<lambda>a.\n                               case a of zeroX \\<Rightarrow> zeroX\n                               | nextX v \\<Rightarrow> nextX (theta v)))\n                          phi0 =\n                         evalF M\n                          (\\<lambda>v.\n                              case v of zeroX \\<Rightarrow> x\n                              | nextX v \\<Rightarrow> (phi \\<circ> theta) v)\n                          phi0", "apply(subgoal_tac \"(vblcase x phi \\<circ> vblcase zeroX (\\<lambda>v. nextX (theta v))) = (vblcase x (phi \\<circ> theta))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M;\n        vblcase x phi \\<circ> vblcase zeroX (\\<lambda>v. nextX (theta v)) =\n        vblcase x (phi \\<circ> theta)\\<rbrakk>\n       \\<Longrightarrow> evalF M\n                          ((\\<lambda>a.\n                               case a of zeroX \\<Rightarrow> x\n                               | nextX x \\<Rightarrow> phi x) \\<circ>\n                           (\\<lambda>a.\n                               case a of zeroX \\<Rightarrow> zeroX\n                               | nextX v \\<Rightarrow> nextX (theta v)))\n                          phi0 =\n                         evalF M\n                          (\\<lambda>v.\n                              case v of zeroX \\<Rightarrow> x\n                              | nextX v \\<Rightarrow> (phi \\<circ> theta) v)\n                          phi0\n 2. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> vblcase x phi \\<circ>\n                         vblcase zeroX (\\<lambda>v. nextX (theta v)) =\n                         vblcase x (phi \\<circ> theta)", "apply(simp del: o_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta x.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> vblcase x phi \\<circ>\n                         vblcase zeroX (\\<lambda>v. nextX (theta v)) =\n                         vblcase x (phi \\<circ> theta)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>signs phi0 phi theta x xa.\n       \\<lbrakk>\\<forall>phi theta.\n                   evalF M phi (subF theta phi0) =\n                   evalF M (phi \\<circ> theta) phi0;\n        x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> (vblcase x phi \\<circ>\n                          vblcase zeroX (\\<lambda>v. nextX (theta v)))\n                          xa =\n                         (case xa of zeroX \\<Rightarrow> x\n                          | nextX x \\<Rightarrow> (phi \\<circ> theta) x)", "apply (case_tac xa rule: vbl_casesE, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma o_id'[simp]: \"f o (% x. x) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (\\<lambda>x. x) = f", "by (fold id_def, simp)"], ["", "lemma evalF_instance: \"evalF M phi (instanceF u A) = evalF M (vblcase (phi u) phi) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalF M phi (instanceF u A) = evalF M (vblcase (phi u) phi) A", "apply(simp add: instanceF_def evalF_subF_eq vblsimps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\\<comment> \\<open>FIXME move\\<close>"], ["", "lemma s[simp]:\" FConj signs formula1 formula2 \\<noteq> formula1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FConj signs formula1 formula2 \\<noteq> formula1", "apply(induct_tac formula1, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma s'[simp]:\" FConj signs formula1 formula2 \\<noteq> formula2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FConj signs formula1 formula2 \\<noteq> formula2", "apply(induct formula2, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma instanceF_E: \"instanceF g formula \\<noteq> FAll signs formula\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instanceF g formula \\<noteq> FAll signs formula", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. instanceF g formula = FAll signs formula \\<Longrightarrow> False", "apply(subgoal_tac \"Suc (size (instanceF g formula)) = (size (FAll signs formula))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>instanceF g formula = FAll signs formula;\n     Suc (size (instanceF g formula)) = size (FAll signs formula)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. instanceF g formula = FAll signs formula \\<Longrightarrow>\n    Suc (size (instanceF g formula)) = size (FAll signs formula)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. instanceF g formula = FAll signs formula \\<Longrightarrow>\n    Suc (size (instanceF g formula)) = size (FAll signs formula)", "apply(simp (no_asm) only: size_instance[rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. instanceF g formula = FAll signs formula \\<Longrightarrow>\n    Suc (size formula) = size (FAll signs formula)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}