{"file_name": "/home/qj213/afp-2021-10-22/thys/Completeness/Soundness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Completeness", "problem_names": ["lemma permutation_validS: \"fs <~~> gs --> (validS fs = validS gs)\"", "lemma modelAssigns_vblcase: \"phi \\<in> modelAssigns M \\<Longrightarrow>  x \\<in> objects M \\<Longrightarrow> vblcase x phi \\<in> modelAssigns M\"", "lemma tmp: \"(!x : A. P x | Q) ==> (! x : A. P x) | Q \"", "lemma soundnessFAll: \"!!Gamma.\n  [| u ~: freeVarsFL (FAll Pos A # Gamma); \n  validS (instanceF u A # Gamma) |] \n  ==> validS (FAll Pos A # Gamma)\"", "lemma soundnessFEx: \"validS (instanceF x A # Gamma) ==> validS (FAll Neg A # Gamma)\"", "lemma soundnessFCut: \"[| validS (C # Gamma); validS (FNot C # Delta) |] ==> validS (Gamma @ Delta)\"", "lemma soundness: \"fs : deductions(PC) ==> (validS fs)\"", "lemma completeness: \"fs : deductions (PC) = validS fs\""], "translations": [["", "lemma permutation_validS: \"fs <~~> gs --> (validS fs = validS gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs <~~> gs \\<longrightarrow> validS fs = validS gs", "apply(simp add: validS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs <~~> gs \\<longrightarrow>\n    (\\<forall>M. \\<forall>phi\\<in>modelAssigns M. evalS M phi fs) =\n    (\\<forall>M. \\<forall>phi\\<in>modelAssigns M. evalS M phi gs)", "apply(simp add: evalS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fs <~~> gs \\<longrightarrow>\n    (\\<forall>M.\n        \\<forall>phi\\<in>modelAssigns M.\n           \\<exists>f\\<in>set fs. evalF M phi f) =\n    (\\<forall>M.\n        \\<forall>phi\\<in>modelAssigns M.\n           \\<exists>f\\<in>set gs. evalF M phi f)", "apply(simp add: perm_set_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma modelAssigns_vblcase: \"phi \\<in> modelAssigns M \\<Longrightarrow>  x \\<in> objects M \\<Longrightarrow> vblcase x phi \\<in> modelAssigns M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>phi \\<in> modelAssigns M; x \\<in> objects M\\<rbrakk>\n    \\<Longrightarrow> vblcase x phi \\<in> modelAssigns M", "apply (simp add: modelAssigns_def, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>range phi \\<subseteq> objects M; x \\<in> objects M;\n        xa \\<in> range\n                  (\\<lambda>xa.\n                      case xa of zeroX \\<Rightarrow> x\n                      | nextX x \\<Rightarrow> phi x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> objects M", "apply(erule_tac rangeE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>range phi \\<subseteq> objects M; x \\<in> objects M;\n        xa =\n        (case xaa of zeroX \\<Rightarrow> x\n         | nextX x \\<Rightarrow> phi x)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> objects M", "apply(case_tac xaa rule: vbl_casesE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tmp: \"(!x : A. P x | Q) ==> (! x : A. P x) | Q \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A. P x \\<or> Q \\<Longrightarrow>\n    (\\<forall>x\\<in>A. P x) \\<or> Q", "by blast"], ["", "lemma soundnessFAll: \"!!Gamma.\n  [| u ~: freeVarsFL (FAll Pos A # Gamma); \n  validS (instanceF u A # Gamma) |] \n  ==> validS (FAll Pos A # Gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        validS (instanceF u A # Gamma)\\<rbrakk>\n       \\<Longrightarrow> validS (FAll Pos A # Gamma)", "apply (simp add: validS_def, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        \\<forall>M.\n           \\<forall>phi\\<in>modelAssigns M.\n              evalF M phi (instanceF u A) \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> \\<forall>phi\\<in>modelAssigns M.\n                            (\\<forall>x\\<in>objects M.\n                                evalF M (vblcase x phi) A) \\<or>\n                            evalS M phi Gamma", "apply (drule_tac x=M in spec, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi (instanceF u A) \\<or> evalS M phi Gamma;\n        phi \\<in> modelAssigns M\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply(simp add: evalF_instance)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M (vblcase (phi u) phi) A \\<or> evalS M phi Gamma;\n        phi \\<in> modelAssigns M\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply (rule tmp, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M (vblcase (phi u) phi) A \\<or> evalS M phi Gamma;\n        phi \\<in> modelAssigns M; x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(drule_tac x=\"% y. if y = u then x else phi y\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>y. if y = u then x else phi y)\n                         \\<in> modelAssigns M\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M\n         (vblcase (if u = u then x else phi u)\n           (\\<lambda>y. if y = u then x else phi y))\n         A \\<or>\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(simp add: modelAssigns_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        range phi \\<subseteq> objects M; x \\<in> objects M\\<rbrakk>\n       \\<Longrightarrow> phi ` {y. y \\<noteq> u} \\<subseteq> objects M\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M\n         (vblcase (if u = u then x else phi u)\n           (\\<lambda>y. if y = u then x else phi y))\n         A \\<or>\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M\n         (vblcase (if u = u then x else phi u)\n           (\\<lambda>y. if y = u then x else phi y))\n         A \\<or>\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M\n         (vblcase (if u = u then x else phi u)\n           (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply (rule disjI1, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(subgoal_tac \"evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y)) A = evalF M (vblcase x phi) A\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y)) A;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y)) A =\n        evalF M (vblcase x phi) A\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> evalF M\n                          (vblcase x\n                            (\\<lambda>y. if y = u then x else phi y))\n                          A =\n                         evalF M (vblcase x phi) A\n 3. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> evalF M\n                          (vblcase x\n                            (\\<lambda>y. if y = u then x else phi y))\n                          A =\n                         evalF M (vblcase x phi) A\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(rule evalF_equiv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> equalOn (freeVarsF A)\n                          (vblcase x\n                            (\\<lambda>y. if y = u then x else phi y))\n                          (vblcase x phi)\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(rule equalOn_vblcaseI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> zeroX \\<in> freeVarsF A \\<longrightarrow> x = x\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> equalOn (preImage nextX (freeVarsF A))\n                          (\\<lambda>y. if y = u then x else phi y) phi\n 3. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(rule,rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> equalOn (preImage nextX (freeVarsF A))\n                          (\\<lambda>y. if y = u then x else phi y) phi\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(simp add: freeVarsFL_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> preImage nextX (freeVarsF A) \\<and>\n                u \\<notin> freeVarsFL Gamma;\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalF M (vblcase x (\\<lambda>y. if y = u then x else phi y))\n         A\\<rbrakk>\n       \\<Longrightarrow> equalOn (preImage nextX (freeVarsF A))\n                          (\\<lambda>y. if y = u then x else phi y) phi\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply (rule equalOnI, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalF M (vblcase x phi) A \\<or> evalS M phi Gamma", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M phi Gamma", "apply(subgoal_tac \"evalS M (\\<lambda>y. if y = u then x else phi y) Gamma = evalS M phi Gamma\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma =\n        evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M phi Gamma\n 2. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M (\\<lambda>y. if y = u then x else phi y)\n                          Gamma =\n                         evalS M phi Gamma", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M (\\<lambda>y. if y = u then x else phi y)\n                          Gamma =\n                         evalS M phi Gamma", "apply(rule evalS_equiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> equalOn (freeVarsFL Gamma)\n                          (\\<lambda>y. if y = u then x else phi y) phi", "apply(rule equalOnI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Gamma M phi x.\n       \\<lbrakk>u \\<notin> freeVarsFL (FAll Pos A # Gamma);\n        phi \\<in> modelAssigns M; x \\<in> objects M;\n        evalS M (\\<lambda>y. if y = u then x else phi y) Gamma\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>freeVarsFL Gamma.\n                            (if xa = u then x else phi xa) = phi xa", "apply(force simp: freeVarsFL_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma soundnessFEx: \"validS (instanceF x A # Gamma) ==> validS (FAll Neg A # Gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validS (instanceF x A # Gamma) \\<Longrightarrow>\n    validS (FAll Neg A # Gamma)", "apply(simp add: validS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>M.\n       \\<forall>phi\\<in>modelAssigns M.\n          evalF M phi (instanceF x A) \\<or>\n          evalS M phi Gamma \\<Longrightarrow>\n    \\<forall>M.\n       \\<forall>phi\\<in>modelAssigns M.\n          (\\<exists>x\\<in>objects M. evalF M (vblcase x phi) A) \\<or>\n          evalS M phi Gamma", "apply (simp add: evalF_instance, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>\\<forall>M.\n                   \\<forall>phi\\<in>modelAssigns M.\n                      evalF M (vblcase (phi x) phi) A \\<or>\n                      evalS M phi Gamma;\n        phi \\<in> modelAssigns M\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply(drule_tac x=M in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M (vblcase (phi x) phi) A \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply (drule_tac x=phi in bspec, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M (vblcase (phi x) phi) A \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M (vblcase (phi x) phi) A\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma\n 2. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M; evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply(rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M (vblcase (phi x) phi) A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>objects M. evalF M (vblcase x phi) A\n 2. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M; evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply (rule_tac x=\"phi x\" in bexI, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M (vblcase (phi x) phi) A\\<rbrakk>\n       \\<Longrightarrow> phi x \\<in> objects M\n 2. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M; evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply(force dest: modelAssignsD subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M; evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x\\<in>objects M.\n                             evalF M (vblcase x phi) A) \\<or>\n                         evalS M phi Gamma", "apply (rule disjI2, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma soundnessFCut: \"[| validS (C # Gamma); validS (FNot C # Delta) |] ==> validS (Gamma @ Delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>validS (C # Gamma); validS (FNot C # Delta)\\<rbrakk>\n    \\<Longrightarrow> validS (Gamma @ Delta)", "(*  apply(force simp: validS_def evalS_append evalS_cons evalF_FNot)*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>validS (C # Gamma); validS (FNot C # Delta)\\<rbrakk>\n    \\<Longrightarrow> validS (Gamma @ Delta)", "apply (simp add: validS_def, rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>\\<forall>M.\n                   \\<forall>phi\\<in>modelAssigns M.\n                      evalF M phi C \\<or> evalS M phi Gamma;\n        \\<forall>M.\n           \\<forall>phi\\<in>modelAssigns M.\n              evalF M phi (FNot C) \\<or> evalS M phi Delta;\n        phi \\<in> modelAssigns M\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply(drule_tac x=M in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>\\<forall>M.\n                   \\<forall>phi\\<in>modelAssigns M.\n                      evalF M phi (FNot C) \\<or> evalS M phi Delta;\n        phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi C \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply(drule_tac x=M in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi C \\<or> evalS M phi Gamma;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi (FNot C) \\<or> evalS M phi Delta\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply(drule_tac x=phi in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi (FNot C) \\<or> evalS M phi Delta\\<rbrakk>\n       \\<Longrightarrow> phi \\<in> modelAssigns M\n 2. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi (FNot C) \\<or> evalS M phi Delta;\n        evalF M phi C \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        \\<forall>phi\\<in>modelAssigns M.\n           evalF M phi (FNot C) \\<or> evalS M phi Delta;\n        evalF M phi C \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply(drule_tac x=phi in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M phi C \\<or> evalS M phi Gamma\\<rbrakk>\n       \\<Longrightarrow> phi \\<in> modelAssigns M\n 2. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M phi C \\<or> evalS M phi Gamma;\n        evalF M phi (FNot C) \\<or> evalS M phi Delta\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M phi.\n       \\<lbrakk>phi \\<in> modelAssigns M;\n        evalF M phi C \\<or> evalS M phi Gamma;\n        evalF M phi (FNot C) \\<or> evalS M phi Delta\\<rbrakk>\n       \\<Longrightarrow> evalS M phi (Gamma @ Delta)", "apply (simp add: evalS_append evalF_FNot, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma soundness: \"fs : deductions(PC) ==> (validS fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fs \\<in> deductions PC \\<Longrightarrow> validS fs", "apply(erule_tac deductions.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<in> Pow (deductions PC \\<inter> {a. validS a})\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(drule_tac PowD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a}\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(subgoal_tac \"prems \\<subseteq>  {x. validS x}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a};\n        prems \\<subseteq> {x. validS x}\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a}\\<rbrakk>\n       \\<Longrightarrow> prems \\<subseteq> {x. validS x}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a}\\<rbrakk>\n       \\<Longrightarrow> prems \\<subseteq> {x. validS x}\n 2. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a};\n        prems \\<subseteq> {x. validS x}\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> deductions PC \\<inter> {a. validS a};\n        prems \\<subseteq> {x. validS x}\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(thin_tac \"prems \\<subseteq> deductions PC \\<inter> {x. validS x}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        prems \\<subseteq> {x. validS x}\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(simp add: subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> PC;\n        \\<forall>x\\<in>prems. validS x\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(simp add: PC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>(conc, prems) \\<in> Perms \\<or>\n                (conc, prems) \\<in> Axioms \\<or>\n                (conc, prems) \\<in> Conjs \\<or>\n                (conc, prems) \\<in> Disjs \\<or>\n                (conc, prems) \\<in> Alls \\<or>\n                (conc, prems) \\<in> Exs \\<or>\n                (conc, prems) \\<in> Weaks \\<or>\n                (conc, prems) \\<in> Contrs \\<or> (conc, prems) \\<in> Cuts;\n        \\<forall>x\\<in>prems. validS x\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(elim disjE)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Perms\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Axioms\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Conjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Disjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Alls\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 6. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 7. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 8. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 9. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp add: Perms_def permutation_validS)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Axioms\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Conjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Disjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Alls\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 6. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 7. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 8. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Axioms_def validS_def evalS_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Conjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Disjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Alls\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 6. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 7. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Conjs_def validS_def evalS_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Disjs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Alls\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 6. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Disjs_def validS_def evalS_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Alls\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(simp add: Alls_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        \\<exists>A x Gamma.\n           conc = FAll Pos A # Gamma \\<and>\n           prems = {instanceF x A # Gamma} \\<and>\n           x \\<notin> freeVarsFL (FAll Pos A # Gamma)\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 5. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force intro: soundnessFAll)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Exs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(simp add: Exs_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        \\<exists>A x Gamma.\n           conc = FAll Neg A # Gamma \\<and>\n           prems = {instanceF x A # Gamma}\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 4. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force intro: soundnessFEx)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Weaks\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 3. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Weaks_def validS_def evalS_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Contrs\\<rbrakk>\n       \\<Longrightarrow> validS conc\n 2. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Contrs_def validS_def evalS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>conc prems.\n       \\<lbrakk>\\<forall>x\\<in>prems. validS x;\n        (conc, prems) \\<in> Cuts\\<rbrakk>\n       \\<Longrightarrow> validS conc", "apply(force simp: Cuts_def intro: soundnessFCut)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma completeness: \"fs : deductions (PC) = validS fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fs \\<in> deductions PC) = validS fs", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. fs \\<in> deductions PC \\<Longrightarrow> validS fs\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions PC", "apply(rule soundness)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fs \\<in> deductions PC \\<Longrightarrow> fs \\<in> deductions PC\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions PC", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. validS fs \\<Longrightarrow> fs \\<in> deductions PC", "apply(subgoal_tac \"fs : deductions CutFreePC\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> fs \\<in> deductions PC\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply(rule subsetD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> ?A6 \\<subseteq> deductions PC\n 2. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> fs \\<in> ?A6\n 3. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> fs \\<in> ?A6\n 2. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> ?A6 \\<subseteq> deductions PC\n 3. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> deductions CutFreePC \\<subseteq> deductions PC\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply(rule mono_deductions)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>validS fs; fs \\<in> deductions CutFreePC\\<rbrakk>\n    \\<Longrightarrow> CutFreePC \\<subseteq> PC\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply(simp add: PC_def CutFreePC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>validS fs;\n     fs \\<in> deductions\n               (Perms \\<union>\n                (Axioms \\<union>\n                 (Conjs \\<union>\n                  (Disjs \\<union>\n                   (Alls \\<union>\n                    (Exs \\<union> (Weaks \\<union> Contrs)))))))\\<rbrakk>\n    \\<Longrightarrow> Axioms\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Conjs\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Disjs\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Alls\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Exs\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Weaks\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts))))))) \\<and>\n                      Contrs\n                      \\<subseteq> Perms \\<union>\n                                  (Axioms \\<union>\n                                   (Conjs \\<union>\n                                    (Disjs \\<union>\n                                     (Alls \\<union>\n(Exs \\<union> (Weaks \\<union> (Contrs \\<union> Cuts)))))))\n 2. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. validS fs \\<Longrightarrow> fs \\<in> deductions CutFreePC", "apply(rule adequacy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. validS fs \\<Longrightarrow> validS fs", "by assumption"], ["", "end"]]}