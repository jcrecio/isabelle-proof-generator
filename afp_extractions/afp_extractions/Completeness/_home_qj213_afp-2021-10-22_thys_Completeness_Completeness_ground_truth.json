{"file_name": "/home/qj213/afp-2021-10-22/thys/Completeness/Completeness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Completeness", "problem_names": ["lemma finite_subs: \"finite (subs gamma)\"", "lemma fansSubs: \"fans subs\"", "lemma subs_def2:  \n\"!!gamma.\n   ~ SATAxiom (sequent gamma) ==> \n   subs gamma = (case nforms gamma of \n                     []     => {} \n                   | nA#nAs => let (n,A) = nA \n                               in  (case A of \n                                        FAtom z P vs  => subsFAtom (atoms gamma) nAs z P vs \n                                      | FConj z A0 A1 => subsFConj (atoms gamma) nAs z A0 A1 \n                                      | FAll  z A     => subsFAll  (atoms gamma) nAs n z A (freeVarsFL (sequent gamma))))\"", "lemma proofTree_def2: \"proofTree = ( % x . bounded x & founded subs (SATAxiom o sequent) x)\"", "lemma inheritedProofTree: \"inherited subs proofTree\"", "lemma proofTreeI: \"[| bounded A; founded subs (SATAxiom o sequent) A |] ==> proofTree A\"", "lemma proofTreeBounded: \"proofTree A ==> bounded A\"", "lemma proofTreeTerminal: \"proofTree A ==> (n,delta) : A ==> terminal subs delta ==> SATAxiom (sequent delta)\"", "lemma snd_o_Pair: \"(snd o (Pair x)) = (% x. x)\"", "lemma sequent_pseq: \"sequent (pseq fs) = fs\"", "lemma SATAxiomTerminal[rule_format]: \"SATAxiom (sequent gamma) --> terminal subs gamma\"", "lemma SATAxiomBounded:\"SATAxiom (sequent gamma) ==> bounded (tree subs gamma)\"", "lemma SATAxiomFounded: \"SATAxiom (sequent gamma) ==> founded subs (SATAxiom o sequent) (tree subs gamma)\"", "lemma SATAxiomProofTree[rule_format]: \"SATAxiom (sequent gamma) --> proofTree (tree subs gamma)\"", "lemma SATAxiomEq: \"(proofTree (tree subs gamma) & terminal subs gamma) = SATAxiom (sequent gamma)\"", "lemma SAT_deduction: \"SATAxiom x ==> x : deductions CutFreePC\"", "lemma subsJustified': \n  notes ss = subs_def2 nforms_def Let_def atoms_def sequent_def subsFAtom_def subsFConj_def subsFAll_def\n  shows \"\\<not> SATAxiom (sequent (ats, (n, f) # list)) --> \\<not> terminal subs (ats, (n, f) # list) \n  --> (\\<forall>sigma\\<in>subs (ats, (n, f) # list). sequent sigma \\<in> deductions CutFreePC) \n  --> sequent (ats, (n, f) # list) \\<in> deductions CutFreePC\"", "lemma subsJustified: \"!! gamma. ~ terminal subs gamma\n  ==> ! sigma : subs gamma . sequent sigma : deductions (CutFreePC)\n  ==> sequent gamma : deductions (CutFreePC)\"", "lemmas proofTreeD = proofTree_def [THEN iffD1]", "lemma proofTreeDeductionD[rule_format]: \"proofTree(tree subs gamma) \\<Longrightarrow> sequent gamma : deductions (CutFreePC)\"", "lemma contains_def2: \"contains f iA n = (iA : set (nforms (f n)))\"", "lemma considers_def2: \"considers f iA n = ( ? nAs . nforms (f n) = iA#nAs)\"", "lemmas containsI = contains_def2[THEN iffD2]", "lemma nformsNoContains: \"[| branch subs gamma f; !n . ~proofTree (tree subs (f n)); nforms (f n) = []  |] ==> ~ contains f iA n\"", "lemma nformsTerminal: \"nforms (f n) = [] ==> terminal subs (f n)\"", "lemma nformsStops: \"!!f.\n  [| branch subs gamma f; !n . ~proofTree (tree subs (f n));\n     nforms (f n) = [] |]\n  ==> nforms (f (Suc n)) = [] & atoms (f (Suc n)) = atoms (f n)\"", "lemma terminalNFormCases: \"!!f. terminal subs (f n) | (? i A nAs . nforms (f n) = (i,A)#nAs)\"", "lemma cases[elim_format]: \"terminal subs (f n) | (\\<not> (terminal subs (f n) \\<and> (? i A nAs . nforms (f n) = (i,A)#nAs)))\"", "lemma containsNotTerminal: \"[| branch subs gamma f; !n . ~proofTree (tree subs (f n)); contains f iA n |] ==> ~ (terminal subs (f n))\"", "lemma containsPropagates: \"!!f.\n  [| branch subs gamma f; !n . ~proofTree (tree subs (f n));\n     contains f iA n |]\n  ==> contains f iA (Suc n) | considers f iA n\"", "lemma noConsidersD: \"!!f. ~considers f iA n ==> nforms (f n) = x#xs ==> iA ~= x\"", "lemma considersD: \"!!f. considers f iA n ==> ? xs . nforms (f n) = iA#xs\"", "lemma contains_initially: \n  \"branch subs (pseq gamma) f \\<Longrightarrow> A : set gamma \\<Longrightarrow> (contains f (0,A) 0)\"", "lemma contains_initialEVs: \n  \"branch subs (pseq gamma) f \\<Longrightarrow>  A : set gamma \\<Longrightarrow> EV (contains f (0,A))\"", "lemmas r = wf_induct[of \"measure msrFn\", OF wf_measure] for msrFn", "lemmas r' = r[simplified measure_def inv_image_def less_than_def less_eq mem_Collect_eq]", "lemma r'': \"(\\<forall> x. (\\<forall> y. ( ((msrFn::'a \\<Rightarrow> nat) y) < ((msrFn :: 'a \\<Rightarrow> nat) x)) \\<longrightarrow> P y) \\<longrightarrow> P x) \\<Longrightarrow> P a\"", "lemma terminationRule [rule_format]:\n  \"! n. P n --> (~(P (Suc n)) | (P (Suc n) & msrFn (Suc n) < (msrFn::nat => nat) n)) ==> P m --> (? n . P n & ~(P (Suc n)))\"\n  (is \"_ \\<Longrightarrow> ?P m\")", "lemma exp3Min: \"exp 3 a > 0\"", "lemma exp1: \"exp 3 (A) + exp 3 (B) < 3 * ((exp 3 A) * (exp 3 B))\"", "lemma exp1': \"exp 3 (A) < 3 * ((exp 3 A) * (exp 3 B)) + C\"", "lemma exp2: \"Suc 0 < 3 * exp 3 (B)\"", "lemma expSum: \"exp x (a+b) = (exp x a) * (exp x b)\"", "lemma costBarrierDecreases':\n  notes ss = subs_def2 nforms_def Let_def subsFAtom_def subsFConj_def subsFAll_def costBarrier_def atoms_def exp3Min expSum\n  shows \"~SATAxiom (sequent \n(a, (num,fm) # list)) --> iA ~= (num, fm) --> \\<not> proofTree (tree subs (a, (num, fm) # list)) --> fSucn : subs (a, (num, fm) # list) --> iA \\<in> set list --> costBarrier iA (fSucn) < costBarrier iA (a, (num, fm) # list)\"", "lemma costBarrierDecreases: \n  \"[| branch subs gamma f;\n  !n . ~proofTree (tree subs (f n));\n  contains f iA n;\n  ~(considers f iA) n\n  |] ==> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\"", "lemma considersContains: \"considers f iA n \\<Longrightarrow> contains f iA n\"", "lemma containsConsiders: \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f iA) |]\n  ==> EV (considers f iA)\"", "lemma lemmA: \n  \"[| branch subs gamma f; ! n. ~ proofTree (tree subs (f n));\n    EV (contains f (i,A)) |]\n ==> ? n nAs. ~SATAxiom (sequent (f n)) & (nforms (f n) = (i,A) # nAs & f (Suc n) : subs (f n))\"", "lemma EV_disj: \"(EV P | EV Q) = EV (\\<lambda>n. P n | Q n)\"", "lemma evContainsConj: \"[| EV (contains f (i,FConj Pos A0 A1)); \n  branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n  |] ==> EV (contains f (0,A0)) | EV (contains f (0,A1))\"", "lemma evContainsDisj: \"[| EV (contains f (i,FConj Neg A0 A1)); \n  branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n  |] ==> EV (contains f (0,A0)) & EV (contains f (0,A1))\"", "lemma evContainsAll: \n  \"[| EV (contains f (i,FAll Pos body)); branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n     |]\n   ==> ? v . EV (contains f (0,instanceF v body))\"", "lemma evContainsEx_instance: \n  \"[| EV (contains f (i,FAll Neg body)); branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n      |]\n  ==> EV (contains f (0,instanceF (X i) body))\"", "lemma evContainsEx_repeat: \"\n  [| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (i,FAll Neg body)) |]\n   ==> EV (contains f (Suc i,FAll Neg body))\"", "lemma lemma1: \"[| P A n ; !A n. P A n --> P A (Suc n) |]\n   ==> P A (n + m)\"", "lemma lemma2: \n  \"[| P A n ; P B m ; ! A n. P A n --> P A (Suc n) |]\n  ==> ? n . P A n & P B n\"", "lemma notTerminalNotSATAxiom: \"\\<not> terminal subs gamma \\<Longrightarrow> \\<not> SATAxiom (sequent gamma)\"", "lemma notTerminalNforms: \"\\<not> terminal subs (f n) \\<Longrightarrow> nforms (f n) \\<noteq> []\"", "lemma atomsPropagate: \"[| branch subs gamma f |]\n   ==> x : set (atoms (f n)) --> x : set (atoms (f (Suc n)))\"", "lemma evContainsEx0_allRepeats: \n  \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (0,FAll Neg A)) |]\n  ==> EV (contains f (i,FAll Neg A))\"", "lemma evContainsEx0_allInstances:\n  \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (0,FAll Neg A)) |]\n  ==> EV (contains f (0,instanceF (X i) A))\"", "lemma containsPSeq0D: \"branch subs (pseq fs) f \\<Longrightarrow> contains f (i,A) 0 \\<Longrightarrow> i=0\"", "lemma claim: \"(A | B | C) = (~C --> ~B --> A)\"", "lemma natPredCases: \"(!n. P n) | (~P 0) | (? n . P n & ~ P (Suc n))\"", "lemma containsNotTerminal': \n  \"\\<lbrakk> branch subs gamma f; !n . ~proofTree (tree subs (f n)); contains f iA n \\<rbrakk> \\<Longrightarrow> ~ (terminal subs (f n))\"", "lemma notTerminalSucNotTerminal: \"\\<lbrakk> \\<not> terminal subs (f (Suc n)); branch subs gamma f \\<rbrakk> \\<Longrightarrow> \\<not> terminal subs (f n)\"", "lemma evContainsExSuc_containsEx:\n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (Suc i,FAll Neg body)) |]\n  ==> EV (contains f (i,FAll Neg body))\"", "lemma evContainsEx_containsEx0: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n)) |]\n  ==> EV (contains f (i,FAll Neg A)) -->\n      EV (contains f (0,FAll Neg A))\"", "lemma evContainsExval: \n  \"[| EV (contains f (i,FAll Neg body)); branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n))\n  |] \n  ==> ! v . EV (contains f (0,instanceF v body))\"", "lemma atomsInSequentI[rule_format]: \"  (z,P,vs) : set (fst ps) -->\n     FAtom z P vs : set (sequent ps)\"", "lemma evContainsAtom1: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (i,FAtom z P vs)) |]\n  ==> ? n . (z,P,vs) : set (fst (f n))\"", "lemmas atomsPropagate'' = atomsPropagate[rule_format]", "lemmas atomsPropagate' = atomsPropagate''[simplified atoms_def, simplified]", "lemma evContainsAtom: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n   EV (contains f (i,FAtom z P vs)) |]\n  ==> ? n . (! m . FAtom z P vs : set (sequent (f (n + m))))\"", "lemma notEvContainsBothAtoms: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n)) |]\n  ==> ~ EV (contains f (i,FAtom Pos p vs)) |\n      ~ EV (contains f (j,FAtom Neg p vs))\"", "lemma counterModelInRepn: \"(counterM f,counterEvalP f) : model\"", "lemmas Abs_counterModel_inverse = counterModelInRepn[THEN Abs_model_inverse]", "lemma inv_obj_obj: \"inv obj (obj n) = n\"", "lemma map_X_map_counterAssign: \"map X (map (inv obj) (map counterAssign xs)) = xs\"", "lemma objectsCounterModel: \"objects (counterModel f) =  { z . ? i . z = obj i }\"", "lemma inCounterM: \"counterAssign v : objects (counterModel f)\"", "lemma counterAssign_eqI[rule_format]: \"x : objects (counterModel f) --> z = X (inv obj x) --> counterAssign z = x\"", "lemma evalPCounterModel: \"M = counterModel f ==> evalP M = counterEvalP f\"", "lemma path_evalF': \n  notes ss = evalPCounterModel counterEvalP_def map_X_map_counterAssign map_map[symmetric]\n  and ss1 = instanceF_def evalF_subF_eq comp_vblcase id_def[symmetric]\n  shows \"[| branch subs (pseq fs) f; \n  !n . ~ proofTree (tree subs (f n))\n  |] ==> (? i . EV (contains f (i,A))) \\<longrightarrow> ~(evalF (counterModel f) counterAssign A)\"", "lemmas path_evalF'' = mp[OF path_evalF']", "lemma counterAssignModelAssign: \"counterAssign : modelAssigns (counterModel gamma)\"", "lemma branch_contains_initially: \"branch subs (pseq fs) f \\<Longrightarrow> x : set fs \\<Longrightarrow> contains f (0,x) 0\"", "lemma path_evalF: \n  \"[| branch subs (pseq fs) f;\n  \\<forall>n. \\<not> proofTree (tree subs (f n)); \n  x \\<in> set fs\n  |] ==> \\<not> evalF (counterModel f) counterAssign x\"", "lemma validProofTree: \"~proofTree (tree subs (pseq fs)) ==> ~(validS fs)\"", "lemma adequacy[simplified sequent_pseq]: \"validS fs ==> (sequent (pseq fs)) : deductions CutFreePC\""], "translations": [["", "lemma finite_subs: \"finite (subs gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subs gamma)", "apply(simp add: subs_def subsFAtom_def subsFConj_def subsFAll_def Let_def split_beta split: if_splits list.split formula.split signs.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fansSubs: \"fans subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fans subs", "apply(rule fansI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. finite (subs A)", "apply(rule, rule finite_subs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subs_def2:  \n\"!!gamma.\n   ~ SATAxiom (sequent gamma) ==> \n   subs gamma = (case nforms gamma of \n                     []     => {} \n                   | nA#nAs => let (n,A) = nA \n                               in  (case A of \n                                        FAtom z P vs  => subsFAtom (atoms gamma) nAs z P vs \n                                      | FConj z A0 A1 => subsFConj (atoms gamma) nAs z A0 A1 \n                                      | FAll  z A     => subsFAll  (atoms gamma) nAs n z A (freeVarsFL (sequent gamma))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma.\n       \\<not> SATAxiom (sequent gamma) \\<Longrightarrow>\n       subs gamma =\n       (case nforms gamma of [] \\<Rightarrow> {}\n        | nA # nAs \\<Rightarrow>\n            let (n, A) = nA\n            in case A of\n               FAtom z P vs \\<Rightarrow> subsFAtom (atoms gamma) nAs z P vs\n               | FConj z A0 A1 \\<Rightarrow>\n                   subsFConj (atoms gamma) nAs z A0 A1\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms gamma) nAs n z A\n                    (freeVarsFL (sequent gamma)))", "apply(simp add: subs_def Let_def nforms_def atoms_def split_beta split: list.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"inherited: proofTree\""], ["", "lemma proofTree_def2: \"proofTree = ( % x . bounded x & founded subs (SATAxiom o sequent) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proofTree =\n    (\\<lambda>x. bounded x \\<and> founded subs (SATAxiom \\<circ> sequent) x)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       proofTree x =\n       (bounded x \\<and> founded subs (SATAxiom \\<circ> sequent) x)", "apply(simp add: proofTree_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inheritedProofTree: \"inherited subs proofTree\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inherited subs proofTree", "apply(simp add: proofTree_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inherited subs\n     (\\<lambda>x.\n         bounded x \\<and> founded subs (SATAxiom \\<circ> sequent) x)", "apply(auto intro: inheritedJoinI inheritedBounded inheritedFounded)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proofTreeI: \"[| bounded A; founded subs (SATAxiom o sequent) A |] ==> proofTree A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded A; founded subs (SATAxiom \\<circ> sequent) A\\<rbrakk>\n    \\<Longrightarrow> proofTree A", "apply(simp add: proofTree_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proofTreeBounded: \"proofTree A ==> bounded A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proofTree A \\<Longrightarrow> bounded A", "apply(simp add: proofTree_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proofTreeTerminal: \"proofTree A ==> (n,delta) : A ==> terminal subs delta ==> SATAxiom (sequent delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>proofTree A; (n, delta) \\<in> A; terminal subs delta\\<rbrakk>\n    \\<Longrightarrow> SATAxiom (sequent delta)", "apply(simp add: proofTree_def founded_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded A \\<and>\n             (\\<forall>x\\<in>A.\n                 case x of\n                 (n, delta) \\<Rightarrow>\n                   terminal subs delta \\<longrightarrow>\n                   SATAxiom (sequent delta));\n     (n, delta) \\<in> A; terminal subs delta\\<rbrakk>\n    \\<Longrightarrow> SATAxiom (sequent delta)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"pseq: lemma\""], ["", "lemma snd_o_Pair: \"(snd o (Pair x)) = (% x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd \\<circ> Pair x = (\\<lambda>x. x)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. (snd \\<circ> Pair x) xa = xa", "by simp"], ["", "lemma sequent_pseq: \"sequent (pseq fs) = fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequent (pseq fs) = fs", "by (simp add: pseq_def sequent_def snd_o_Pair)"], ["", "subsection \"SATAxiom: proofTree\""], ["", "lemma SATAxiomTerminal[rule_format]: \"SATAxiom (sequent gamma) --> terminal subs gamma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<longrightarrow> terminal subs gamma", "apply(simp add: subs_def proofTree_def terminal_def founded_def bounded_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SATAxiomBounded:\"SATAxiom (sequent gamma) ==> bounded (tree subs gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<Longrightarrow> bounded (tree subs gamma)", "apply(frule SATAxiomTerminal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SATAxiom (sequent gamma); terminal subs gamma\\<rbrakk>\n    \\<Longrightarrow> bounded (tree subs gamma)", "apply(subst treeEquation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SATAxiom (sequent gamma); terminal subs gamma\\<rbrakk>\n    \\<Longrightarrow> bounded\n                       (insert (0, gamma)\n                         (\\<Union>delta\\<in>subs gamma.\n                             incLevel ` tree subs delta))", "apply(simp add: subs_def proofTree_def terminal_def founded_def bounded_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<Longrightarrow>\n    \\<exists>N. boundedBy N {(0, gamma)}", "apply(force simp add: boundedByInsert boundedByEmpty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SATAxiomFounded: \"SATAxiom (sequent gamma) ==> founded subs (SATAxiom o sequent) (tree subs gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<Longrightarrow>\n    founded subs (SATAxiom \\<circ> sequent) (tree subs gamma)", "apply(frule SATAxiomTerminal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SATAxiom (sequent gamma); terminal subs gamma\\<rbrakk>\n    \\<Longrightarrow> founded subs (SATAxiom \\<circ> sequent)\n                       (tree subs gamma)", "apply(subst treeEquation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SATAxiom (sequent gamma); terminal subs gamma\\<rbrakk>\n    \\<Longrightarrow> founded subs (SATAxiom \\<circ> sequent)\n                       (insert (0, gamma)\n                         (\\<Union>delta\\<in>subs gamma.\n                             incLevel ` tree subs delta))", "apply(simp add: subs_def proofTree_def terminal_def founded_def bounded_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SATAxiomProofTree[rule_format]: \"SATAxiom (sequent gamma) --> proofTree (tree subs gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<longrightarrow> proofTree (tree subs gamma)", "apply(blast intro: proofTreeI SATAxiomBounded SATAxiomFounded)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SATAxiomEq: \"(proofTree (tree subs gamma) & terminal subs gamma) = SATAxiom (sequent gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proofTree (tree subs gamma) \\<and> terminal subs gamma) =\n    SATAxiom (sequent gamma)", "apply(blast intro: SATAxiomProofTree proofTreeTerminal tree.tree0  SATAxiomTerminal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>FIXME tjr blast sensitive to obj imp vs meta imp for pTT\\<close>"], ["", "subsection \"SATAxioms are deductions: - needed\""], ["", "lemma SAT_deduction: \"SATAxiom x ==> x : deductions CutFreePC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom x \\<Longrightarrow> x \\<in> deductions CutFreePC", "apply(simp add: SATAxiom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n vs.\n       FAtom Pos n vs \\<in> set x \\<and>\n       FAtom Neg n vs \\<in> set x \\<Longrightarrow>\n    x \\<in> deductions CutFreePC", "apply(elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n vs.\n       FAtom Pos n vs \\<in> set x \\<and>\n       FAtom Neg n vs \\<in> set x \\<Longrightarrow>\n       x \\<in> deductions CutFreePC", "apply(rule_tac x=\"[FAtom Pos n vs,FAtom Neg n vs]\" in inDed_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n vs.\n       FAtom Pos n vs \\<in> set x \\<and>\n       FAtom Neg n vs \\<in> set x \\<Longrightarrow>\n       [FAtom Pos n vs, FAtom Neg n vs] \\<in> deductions CutFreePC\n 2. \\<And>n vs.\n       FAtom Pos n vs \\<in> set x \\<and>\n       FAtom Neg n vs \\<in> set x \\<Longrightarrow>\n       set [FAtom Pos n vs, FAtom Neg n vs] \\<subseteq> set x", "apply (blast intro!: SATAxiomI rulesInPCs, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"proofTrees are deductions: subs respects rules - messy start and end\""], ["", "lemma subsJustified': \n  notes ss = subs_def2 nforms_def Let_def atoms_def sequent_def subsFAtom_def subsFConj_def subsFAll_def\n  shows \"\\<not> SATAxiom (sequent (ats, (n, f) # list)) --> \\<not> terminal subs (ats, (n, f) # list) \n  --> (\\<forall>sigma\\<in>subs (ats, (n, f) # list). sequent sigma \\<in> deductions CutFreePC) \n  --> sequent (ats, (n, f) # list) \\<in> deductions CutFreePC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> SATAxiom (sequent (ats, (n, f) # list)) \\<longrightarrow>\n    \\<not> terminal subs (ats, (n, f) # list) \\<longrightarrow>\n    (\\<forall>sigma\\<in>subs (ats, (n, f) # list).\n        sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n    sequent (ats, (n, f) # list) \\<in> deductions CutFreePC", "apply (rule_tac A=f in formula_signs_cases, clarify)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom (sequent (ats, (n, FAtom Pos p vs) # list));\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FAtom Pos p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FAtom Pos p vs) # list)\n                         \\<in> deductions CutFreePC\n 2. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAtom Neg p vs) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FAtom Neg p vs) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAtom Neg p vs) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAtom Neg p vs) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FAtom Neg p vs) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAtom Neg p vs) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule PermI)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> ?Gamma'8 p vs \\<in> deductions CutFreePC\n 2. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats <~~>\n                         ?Gamma'8 p vs\n 3. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 4. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAtom Neg p vs) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FAtom Neg p vs) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAtom Neg p vs) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 7. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 8. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats <~~>\n                         map snd list @\n                         FAtom Pos p vs #\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n 2. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 3. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAtom Neg p vs) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FAtom Neg p vs) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAtom Neg p vs) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 7. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule perm_append_Cons)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Pos p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Pos p vs) # list);\n        map snd list @\n        FAtom Pos p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 2. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAtom Neg p vs) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FAtom Neg p vs) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAtom Neg p vs) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply (rule rulesInPCs, clarify)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom (sequent (ats, (n, FAtom Neg p vs) # list));\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FAtom Neg p vs) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FAtom Neg p vs) # list)\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule PermI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> ?Gamma'18 p vs \\<in> deductions CutFreePC\n 2. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats <~~>\n                         ?Gamma'18 p vs\n 3. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 7. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats <~~>\n                         map snd list @\n                         FAtom Neg p vs #\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n 2. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule perm_append_Cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAtom Neg p vs #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAtom Neg p vs) # list);\n        map snd list @\n        FAtom Neg p vs # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Pos f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Pos f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply (rule rulesInPCs, clarify)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (ats, (n, FConj Pos f1 f2) # list));\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FConj Pos f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FConj Pos f1 f2) # list)\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC \\<and>\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(elim conjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule ConjI')"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Conjs \\<subseteq> CutFreePC\n 5. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 6. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 7. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 8. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Conjs \\<subseteq> CutFreePC\n 4. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 5. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 7. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC\n 2. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Conjs \\<subseteq> CutFreePC\n 3. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Pos f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Pos f1 f2) # list);\n        f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC;\n        f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Perms \\<subseteq> CutFreePC\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule rulesInPCs)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (ats, (n, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       \\<not> terminal subs\n               (ats, (n, FConj Neg f1 f2) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FConj Neg f1 f2) # list) \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (ats, (n, FConj Neg f1 f2) # list));\n        \\<not> terminal subs (ats, (n, FConj Neg f1 f2) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FConj Neg f1 f2) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FConj Neg f1 f2) # list)\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Neg f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Neg f1 f2) # list);\n        f1 # f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FConj Neg f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule DisjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Neg f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Neg f1 f2) # list);\n        f1 # f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> f1 #\n                         f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Neg f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Neg f1 f2) # list);\n        f1 # f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Disjs \\<subseteq> CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FConj Neg f1 f2 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FConj Neg f1 f2) # list);\n        f1 # f2 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Disjs \\<subseteq> CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule rulesInPCs)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Pos f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Pos f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Pos f1) # list) \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom (sequent (ats, (n, FAll Pos f1) # list));\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FAll Pos f1) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FAll Pos f1) # list)\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule AllI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> instanceF (?w48 f1) f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> ?w48 f1\n                         \\<notin> freeVarsFL\n                                   (FAll Pos f1 #\n                                    map snd list @\n                                    map (\\<lambda>(z, x, y). FAtom z x y)\n                                     ats)\n 3. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Alls \\<subseteq> CutFreePC\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> freshVar\n                          (freeVarsFL\n                            (FAll Pos f1 #\n                             map snd list @\n                             map (\\<lambda>(z, x, y). FAtom z x y) ats))\n                         \\<notin> freeVarsFL\n                                   (FAll Pos f1 #\n                                    map snd list @\n                                    map (\\<lambda>(z, x, y). FAtom z x y)\n                                     ats)\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Alls \\<subseteq> CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule finiteFreshVar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (freeVarsFL\n                            (FAll Pos f1 #\n                             map snd list @\n                             map (\\<lambda>(z, x, y). FAtom z x y) ats))\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Alls \\<subseteq> CutFreePC\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply(rule finite_freeVarsFL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Pos f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Pos f1) # list);\n        instanceF\n         (freshVar\n           (freeVarsFL\n             (FAll Pos f1 #\n              map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)))\n         f1 #\n        map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Alls \\<subseteq> CutFreePC\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (ats, (n, FAll Neg f1) # list)) \\<longrightarrow>\n       \\<not> terminal subs (ats, (n, FAll Neg f1) # list) \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent (ats, (n, FAll Neg f1) # list) \\<in> deductions CutFreePC", "apply (rule rulesInPCs, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom (sequent (ats, (n, FAll Neg f1) # list));\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        \\<forall>sigma\\<in>subs (ats, (n, FAll Neg f1) # list).\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent (ats, (n, FAll Neg f1) # list)\n                         \\<in> deductions CutFreePC", "apply(simp add: ss)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC", "apply(rule ContrI) \\<comment> \\<open>!\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> FAll Neg f1 #\n                         FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC", "apply(rule_tac w = \"X n\" in ExI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> instanceF (X n) f1 #\n                         FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats\n                         \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Exs \\<subseteq> CutFreePC\n 3. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC", "apply(rule inDed_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> ?x62 f1 \\<in> deductions CutFreePC\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> set (?x62 f1)\n                         \\<subseteq> set\n(instanceF (X n) f1 #\n FAll Neg f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)\n 3. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Exs \\<subseteq> CutFreePC\n 4. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> set (instanceF (X n) f1 #\n                              map snd list @\n                              FAll Neg f1 #\n                              map (\\<lambda>(z, x, y). FAtom z x y) ats)\n                         \\<subseteq> set\n(instanceF (X n) f1 #\n FAll Neg f1 # map snd list @ map (\\<lambda>(z, x, y). FAtom z x y) ats)\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Exs \\<subseteq> CutFreePC\n 3. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Exs \\<subseteq> CutFreePC\n 2. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom\n                        (FAll Neg f1 #\n                         map snd list @\n                         map (\\<lambda>(z, x, y). FAtom z x y) ats);\n        \\<not> terminal subs (ats, (n, FAll Neg f1) # list);\n        instanceF (X n) f1 #\n        map snd list @\n        FAll Neg f1 # map (\\<lambda>(z, x, y). FAtom z x y) ats\n        \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> Contrs \\<subseteq> CutFreePC", "apply(rule rulesInPCs)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subsJustified: \"!! gamma. ~ terminal subs gamma\n  ==> ! sigma : subs gamma . sequent sigma : deductions (CutFreePC)\n  ==> sequent gamma : deductions (CutFreePC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(case_tac \"SATAxiom (sequent gamma)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gamma.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        SATAxiom (sequent gamma)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC\n 2. \\<And>gamma.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(erule SAT_deduction)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(case_tac gamma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma a b.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (a, b)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(rename_tac ats nfs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma ats nfs.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (ats, nfs)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(case_tac nfs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gamma ats nfs.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (ats, nfs);\n        nfs = []\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC\n 2. \\<And>gamma ats nfs a list.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (ats, nfs);\n        nfs = a # list\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(simp add: terminal_def subs_def sequent_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma ats nfs a list.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (ats, nfs);\n        nfs = a # list\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gamma ats nfs a list aa b.\n       \\<lbrakk>\\<not> terminal subs gamma;\n        \\<forall>sigma\\<in>subs gamma.\n           sequent sigma \\<in> deductions CutFreePC;\n        \\<not> SATAxiom (sequent gamma); gamma = (ats, nfs); nfs = a # list;\n        a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> sequent gamma \\<in> deductions CutFreePC", "apply(blast intro: subsJustified'[rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"proofTrees are deductions: instance of boundedTreeInduction\""], ["", "lemmas proofTreeD = proofTree_def [THEN iffD1]"], ["", "lemma proofTreeDeductionD[rule_format]: \"proofTree(tree subs gamma) \\<Longrightarrow> sequent gamma : deductions (CutFreePC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proofTree (tree subs gamma) \\<Longrightarrow>\n    sequent gamma \\<in> deductions CutFreePC", "apply(rule boundedTreeInduction[OF fansSubs])"], ["proof (prove)\ngoal (3 subgoals):\n 1. proofTree (tree subs gamma) \\<Longrightarrow> bounded (tree subs gamma)\n 2. proofTree (tree subs gamma) \\<Longrightarrow>\n    founded subs (\\<lambda>a. sequent a \\<in> deductions CutFreePC)\n     (tree subs gamma)\n 3. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>delta.\n       \\<not> terminal subs delta \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs delta.\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent delta \\<in> deductions CutFreePC", "apply(erule proofTreeBounded)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proofTree (tree subs gamma) \\<Longrightarrow>\n    founded subs (\\<lambda>a. sequent a \\<in> deductions CutFreePC)\n     (tree subs gamma)\n 2. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>delta.\n       \\<not> terminal subs delta \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs delta.\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent delta \\<in> deductions CutFreePC", "apply(rule foundedMono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proofTree (tree subs gamma) \\<Longrightarrow>\n    founded subs ?P5 (tree subs gamma)\n 2. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>x. ?P5 x \\<longrightarrow> sequent x \\<in> deductions CutFreePC\n 3. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>delta.\n       \\<not> terminal subs delta \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs delta.\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent delta \\<in> deductions CutFreePC", "apply (force dest: proofTreeD, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>a b.\n       SATAxiom (sequent (a, b)) \\<longrightarrow>\n       sequent (a, b) \\<in> deductions CutFreePC\n 2. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>delta.\n       \\<not> terminal subs delta \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs delta.\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent delta \\<in> deductions CutFreePC", "apply(blast intro: SAT_deduction foundedMono subsJustified)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proofTree (tree subs gamma) \\<Longrightarrow>\n    \\<forall>delta.\n       \\<not> terminal subs delta \\<longrightarrow>\n       (\\<forall>sigma\\<in>subs delta.\n           sequent sigma \\<in> deductions CutFreePC) \\<longrightarrow>\n       sequent delta \\<in> deductions CutFreePC", "apply(blast intro:  subsJustified)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"contains, considers:\""], ["", "lemma contains_def2: \"contains f iA n = (iA : set (nforms (f n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contains f iA n = (iA \\<in> set (nforms (f n)))", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma considers_def2: \"considers f iA n = ( ? nAs . nforms (f n) = iA#nAs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. considers f iA n = (\\<exists>nAs. nforms (f n) = iA # nAs)", "apply(simp add: considers_def nforms_def split: list.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas containsI = contains_def2[THEN iffD2]"], ["", "subsection \"path: nforms = [] implies\""], ["", "lemma nformsNoContains: \"[| branch subs gamma f; !n . ~proofTree (tree subs (f n)); nforms (f n) = []  |] ==> ~ contains f iA n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     nforms (f n) = []\\<rbrakk>\n    \\<Longrightarrow> \\<not> contains f iA n", "apply(simp add: contains_def2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>FIXME tjr assumptions not required\\<close>"], ["", "lemma nformsTerminal: \"nforms (f n) = [] ==> terminal subs (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nforms (f n) = [] \\<Longrightarrow> terminal subs (f n)", "apply(simp add: subs_def Let_def terminal_def nforms_def split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nformsStops: \"!!f.\n  [| branch subs gamma f; !n . ~proofTree (tree subs (f n));\n     nforms (f n) = [] |]\n  ==> nforms (f (Suc n)) = [] & atoms (f (Suc n)) = atoms (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        nforms (f n) = []\\<rbrakk>\n       \\<Longrightarrow> nforms (f (Suc n)) = [] \\<and>\n                         atoms (f (Suc n)) = atoms (f n)", "apply(subgoal_tac \"f (Suc n) = f n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); nforms (f n) = [];\n        f (Suc n) = f n\\<rbrakk>\n       \\<Longrightarrow> nforms (f (Suc n)) = [] \\<and>\n                         atoms (f (Suc n)) = atoms (f n)\n 2. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        nforms (f n) = []\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) = f n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        nforms (f n) = []\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) = f n", "apply(blast intro: branchStops nformsTerminal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"path: cases\""], ["", "lemma terminalNFormCases: \"!!f. terminal subs (f n) | (? i A nAs . nforms (f n) = (i,A)#nAs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       terminal subs (f n) \\<or>\n       (\\<exists>i A nAs. nforms (f n) = (i, A) # nAs)", "apply (rule disjCI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i A nAs.\n          nforms (f n) \\<noteq> (i, A) # nAs \\<Longrightarrow>\n       terminal subs (f n)", "apply(rule nformsTerminal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<forall>i A nAs.\n          nforms (f n) \\<noteq> (i, A) # nAs \\<Longrightarrow>\n       nforms (f n) = []", "apply(case_tac \"nforms (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>i A nAs. nforms (f n) \\<noteq> (i, A) # nAs;\n        nforms (f n) = []\\<rbrakk>\n       \\<Longrightarrow> nforms (f n) = []\n 2. \\<And>f a list.\n       \\<lbrakk>\\<forall>i A nAs. nforms (f n) \\<noteq> (i, A) # nAs;\n        nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> nforms (f n) = []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a list.\n       \\<lbrakk>\\<forall>i A nAs. nforms (f n) \\<noteq> (i, A) # nAs;\n        nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> nforms (f n) = []", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cases[elim_format]: \"terminal subs (f n) | (\\<not> (terminal subs (f n) \\<and> (? i A nAs . nforms (f n) = (i,A)#nAs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal subs (f n) \\<or>\n    \\<not> (terminal subs (f n) \\<and>\n            (\\<exists>i A nAs. nforms (f n) = (i, A) # nAs))", "apply(auto elim: terminalNFormCases[elim_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"path: contains not terminal and propagate condition\""], ["", "lemma containsNotTerminal: \"[| branch subs gamma f; !n . ~proofTree (tree subs (f n)); contains f iA n |] ==> ~ (terminal subs (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     contains f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(case_tac \"SATAxiom (sequent (f n))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(blast dest: SATAxiomEq[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f; contains f iA n;\n     \\<not> SATAxiom (sequent (f n));\n     \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply (simp add:  subs_def subs_def subsFAtom_def subsFConj_def subsFAll_def Let_def contains_def terminal_def nforms_def split_beta branch_def split: list.split signs.split expand_case_formula, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma containsPropagates: \"!!f.\n  [| branch subs gamma f; !n . ~proofTree (tree subs (f n));\n     contains f iA n |]\n  ==> contains f iA (Suc n) | considers f iA n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply(frule_tac containsNotTerminal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f (?iA f) (?n f)\n 3. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f (?n f))\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f (?iA f) (?n f)\n 2. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f (?n f))\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply(frule_tac branchSubs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> terminal subs (f (?n5 f))\n 2. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n);\n        f (Suc (?n5 f)) \\<in> subs (f (?n5 f))\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply(case_tac \"considers f iA n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n\n 2. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n) \\<or> considers f iA n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (Suc n)", "apply(simp add: contains_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        iA \\<in> set (snd (f n)); \\<not> terminal subs (f n);\n        f (Suc n) \\<in> subs (f n); \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac \"f n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        iA \\<in> set (snd (f n)); \\<not> terminal subs (f n);\n        f (Suc n) \\<in> subs (f n); \\<not> considers f iA n;\n        f n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set b;\n        \\<not> terminal subs (a, b); f (Suc n) \\<in> subs (a, b);\n        \\<not> considers f iA n; f n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(drule split_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, b); f (Suc n) \\<in> subs (a, b);\n        \\<not> considers f iA n; f n = (a, b);\n        \\<exists>ys zs. b = ys @ iA # zs\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, b); f (Suc n) \\<in> subs (a, b);\n        \\<not> considers f iA n; f n = (a, b); b = ys @ iA # zs\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, ys @ iA # zs);\n        f (Suc n) \\<in> subs (a, ys @ iA # zs); \\<not> considers f iA n;\n        f n = (a, ys @ iA # zs); b = ys @ iA # zs\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a b ys zs.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, ys @ iA # zs);\n        f (Suc n) \\<in> subs (a, ys @ iA # zs); \\<not> considers f iA n;\n        f n = (a, ys @ iA # zs); b = ys @ iA # zs; ys = []\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, ys @ iA # zs);\n        f (Suc n) \\<in> subs (a, ys @ iA # zs); \\<not> considers f iA n;\n        f n = (a, ys @ iA # zs); b = ys @ iA # zs; ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply (simp add: considers_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, aa # list @ iA # zs);\n        f (Suc n) \\<in> subs (a, aa # list @ iA # zs);\n        \\<not> considers f iA n; f n = (a, aa # list @ iA # zs);\n        b = aa # list @ iA # zs; ys = aa # list\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac \"SATAxiom (sequent (f n))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, aa # list @ iA # zs);\n        f (Suc n) \\<in> subs (a, aa # list @ iA # zs);\n        \\<not> considers f iA n; f n = (a, aa # list @ iA # zs);\n        b = aa # list @ iA # zs; ys = aa # list;\n        SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, aa # list @ iA # zs);\n        f (Suc n) \\<in> subs (a, aa # list @ iA # zs);\n        \\<not> considers f iA n; f n = (a, aa # list @ iA # zs);\n        b = aa # list @ iA # zs; ys = aa # list;\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(blast dest: iffD2[OF SATAxiomEq])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, aa # list @ iA # zs);\n        f (Suc n) \\<in> subs (a, aa # list @ iA # zs);\n        \\<not> considers f iA n; f n = (a, aa # list @ iA # zs);\n        b = aa # list @ iA # zs; ys = aa # list;\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subs_def2 nforms_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, aa # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case aa of\n               (n, FAtom xa xb xc) \\<Rightarrow>\n                 subsFAtom (atoms (a, aa # list @ iA # zs)) (list @ iA # zs)\n                  xa xb xc\n               | (n, FConj xa xb xc) \\<Rightarrow>\n                   subsFConj (atoms (a, aa # list @ iA # zs))\n                    (list @ iA # zs) xa xb xc\n               | (n, FAll z A) \\<Rightarrow>\n                   subsFAll (atoms (a, aa # list @ iA # zs))\n                    (list @ iA # zs) n z A\n                    (freeVarsFL (sequent (a, aa # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, aa # list @ iA # zs);\n        b = aa # list @ iA # zs; ys = aa # list;\n        \\<not> SATAxiom (sequent (a, aa # list @ iA # zs))\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply (case_tac aa, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs aa list ab ba.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac ba)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f a b ys zs aa list ab ba x11 x12 x13.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAtom x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list ab ba x21 x22 x23.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FConj x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 3. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subsFAtom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f a b ys zs aa list ab ba x21 x22 x23.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FConj x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(rename_tac signs a b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, baa) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case baa of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, baa) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL\n                      (sequent (aa, (ab, baa) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, baa) # list @ iA # zs);\n        ba = (ab, baa) # list @ iA # zs; ys = (ab, baa) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, baa) # list @ iA # zs));\n        aaa = (ab, baa); baa = FConj signs a b\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac signs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, baa) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case baa of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, baa) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL\n                      (sequent (aa, (ab, baa) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, baa) # list @ iA # zs);\n        ba = (ab, baa) # list @ iA # zs; ys = (ab, baa) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, baa) # list @ iA # zs));\n        aaa = (ab, baa); baa = FConj signs a b; signs = Pos\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, baa) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case baa of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, baa) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL\n                      (sequent (aa, (ab, baa) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, baa) # list @ iA # zs);\n        ba = (ab, baa) # list @ iA # zs; ys = (ab, baa) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, baa) # list @ iA # zs));\n        aaa = (ab, baa); baa = FConj signs a b; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 3. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subsFConj_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, FConj Pos a b) # list @ iA # zs);\n        f (Suc n) =\n        (atoms (aa, (ab, FConj Pos a b) # list @ iA # zs),\n         (0, a) # list @ iA # zs) \\<or>\n        f (Suc n) =\n        (atoms (aa, (ab, FConj Pos a b) # list @ iA # zs),\n         (0, b) # list @ iA # zs);\n        \\<not> considers f iA n;\n        f n = (aa, (ab, FConj Pos a b) # list @ iA # zs);\n        ba = (ab, FConj Pos a b) # list @ iA # zs;\n        ys = (ab, FConj Pos a b) # list;\n        \\<not> SATAxiom\n                (sequent (aa, (ab, FConj Pos a b) # list @ iA # zs));\n        aaa = (ab, FConj Pos a b); baa = FConj Pos a b; signs = Pos\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, baa) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case baa of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, baa) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL\n                      (sequent (aa, (ab, baa) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, baa) # list @ iA # zs);\n        ba = (ab, baa) # list @ iA # zs; ys = (ab, baa) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, baa) # list @ iA # zs));\n        aaa = (ab, baa); baa = FConj signs a b; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 3. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f aa ba ys zs aaa list ab baa signs a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, baa) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case baa of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, baa) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, baa) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL\n                      (sequent (aa, (ab, baa) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, baa) # list @ iA # zs);\n        ba = (ab, baa) # list @ iA # zs; ys = (ab, baa) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, baa) # list @ iA # zs));\n        aaa = (ab, baa); baa = FConj signs a b; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subsFConj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b ys zs aa list ab ba x31 x32.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (a, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (a, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (a, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (a, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (a, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (a, (ab, ba) # list @ iA # zs));\n        aa = (ab, ba); ba = FAll x31 x32\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(rename_tac signs a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f aa b ys zs aaa list ab ba signs a.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (aa, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, ba) # list @ iA # zs));\n        aaa = (ab, ba); ba = FAll signs a\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(case_tac signs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f aa b ys zs aaa list ab ba signs a.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (aa, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, ba) # list @ iA # zs));\n        aaa = (ab, ba); ba = FAll signs a; signs = Pos\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))\n 2. \\<And>f aa b ys zs aaa list ab ba signs a.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (aa, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, ba) # list @ iA # zs));\n        aaa = (ab, ba); ba = FAll signs a; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subsFAll_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f aa b ys zs aaa list ab ba signs a.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> terminal subs (aa, (ab, ba) # list @ iA # zs);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (aa, (ab, ba) # list @ iA # zs))\n                  (list @ iA # zs) x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (aa, (ab, ba) # list @ iA # zs))\n                    (list @ iA # zs) ab z A\n                    (freeVarsFL (sequent (aa, (ab, ba) # list @ iA # zs))));\n        \\<not> considers f iA n; f n = (aa, (ab, ba) # list @ iA # zs);\n        b = (ab, ba) # list @ iA # zs; ys = (ab, ba) # list;\n        \\<not> SATAxiom (sequent (aa, (ab, ba) # list @ iA # zs));\n        aaa = (ab, ba); ba = FAll signs a; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set (snd (f (Suc n)))", "apply(simp add: subsFAll_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"path: no consider lemmas\""], ["", "lemma noConsidersD: \"!!f. ~considers f iA n ==> nforms (f n) = x#xs ==> iA ~= x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<not> considers f iA n; nforms (f n) = x # xs\\<rbrakk>\n       \\<Longrightarrow> iA \\<noteq> x", "by(simp add: considers_def2)"], ["", "lemma considersD: \"!!f. considers f iA n ==> ? xs . nforms (f n) = iA#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       considers f iA n \\<Longrightarrow>\n       \\<exists>xs. nforms (f n) = iA # xs", "by(simp add: considers_def2)"], ["", "subsection \"path: contains initially\""], ["", "lemma contains_initially: \n  \"branch subs (pseq gamma) f \\<Longrightarrow> A : set gamma \\<Longrightarrow> (contains f (0,A) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq gamma) f; A \\<in> set gamma\\<rbrakk>\n    \\<Longrightarrow> contains f (0, A) 0", "apply(drule branch0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set gamma; f 0 = pseq gamma\\<rbrakk>\n    \\<Longrightarrow> contains f (0, A) 0", "apply(simp add: contains_def pseq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma contains_initialEVs: \n  \"branch subs (pseq gamma) f \\<Longrightarrow>  A : set gamma \\<Longrightarrow> EV (contains f (0,A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq gamma) f; A \\<in> set gamma\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A))", "apply(simp add: EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq gamma) f; A \\<in> set gamma\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A) n", "apply(fast dest: contains_initially)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"termination: (for EV contains implies EV considers)\""], ["", "lemmas r = wf_induct[of \"measure msrFn\", OF wf_measure] for msrFn"], ["", "lemmas r' = r[simplified measure_def inv_image_def less_than_def less_eq mem_Collect_eq]"], ["", "lemma r'': \"(\\<forall> x. (\\<forall> y. ( ((msrFn::'a \\<Rightarrow> nat) y) < ((msrFn :: 'a \\<Rightarrow> nat) x)) \\<longrightarrow> P y) \\<longrightarrow> P x) \\<Longrightarrow> P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>y.\n           msrFn y < msrFn x \\<longrightarrow> P y) \\<longrightarrow>\n       P x \\<Longrightarrow>\n    P a", "by (blast intro: r' [of _ P])"], ["", "lemma terminationRule [rule_format]:\n  \"! n. P n --> (~(P (Suc n)) | (P (Suc n) & msrFn (Suc n) < (msrFn::nat => nat) n)) ==> P m --> (? n . P n & ~(P (Suc n)))\"\n  (is \"_ \\<Longrightarrow> ?P m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       P n \\<longrightarrow>\n       \\<not> P (Suc n) \\<or>\n       P (Suc n) \\<and> msrFn (Suc n) < msrFn n \\<Longrightarrow>\n    P m \\<longrightarrow> (\\<exists>n. P n \\<and> \\<not> P (Suc n))", "apply (rule r''[of msrFn \"?P\" m], blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>FIXME ugly\\<close>"], ["", "subsection \"costBarrier: lemmas\""], ["", "subsection \"costBarrier: exp3 lemmas - bit specific...\""], ["", "lemma exp3Min: \"exp 3 a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp 3 a", "by (induct a, simp, simp)"], ["", "lemma exp1: \"exp 3 (A) + exp 3 (B) < 3 * ((exp 3 A) * (exp 3 B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)", "using exp3Min[of A] exp3Min[of B]"], ["proof (prove)\nusing this:\n  0 < exp 3 A\n  0 < exp 3 B\n\ngoal (1 subgoal):\n 1. exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)", "apply(case_tac \"exp 3 A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < exp 3 A; 0 < exp 3 B; exp 3 A = 0\\<rbrakk>\n    \\<Longrightarrow> exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat.\n       \\<lbrakk>0 < exp 3 A; 0 < exp 3 B; exp 3 A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)", "apply(simp add: exp3Min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>0 < exp 3 A; 0 < exp 3 B; exp 3 A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)", "apply(case_tac \"exp 3 B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>0 < exp 3 A; 0 < exp 3 B; exp 3 A = Suc nat;\n        exp 3 B = 0\\<rbrakk>\n       \\<Longrightarrow> exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat nata.\n       \\<lbrakk>0 < exp 3 A; 0 < exp 3 B; exp 3 A = Suc nat;\n        exp 3 B = Suc nata\\<rbrakk>\n       \\<Longrightarrow> exp 3 A + exp 3 B < 3 * (exp 3 A * exp 3 B)", "apply (simp add: exp3Min, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp1': \"exp 3 (A) < 3 * ((exp 3 A) * (exp 3 B)) + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 3 A < 3 * (exp 3 A * exp 3 B) + C", "apply(subgoal_tac \"exp 3 (A) < 3 * ((exp 3 A) * (exp 3 B))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. exp 3 A < 3 * (exp 3 A * exp 3 B) \\<Longrightarrow>\n    exp 3 A < 3 * (exp 3 A * exp 3 B) + C\n 2. exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply(case_tac \"exp 3 A\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. exp 3 A = 0 \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat.\n       exp 3 A = Suc nat \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "using exp3Min[of A]"], ["proof (prove)\nusing this:\n  0 < exp 3 A\n\ngoal (2 subgoals):\n 1. exp 3 A = 0 \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat.\n       exp 3 A = Suc nat \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       exp 3 A = Suc nat \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply(case_tac \"exp 3 B\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>exp 3 A = Suc nat; exp 3 B = 0\\<rbrakk>\n       \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat nata.\n       \\<lbrakk>exp 3 A = Suc nat; exp 3 B = Suc nata\\<rbrakk>\n       \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "using exp3Min[of B]"], ["proof (prove)\nusing this:\n  0 < exp 3 B\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>exp 3 A = Suc nat; exp 3 B = 0\\<rbrakk>\n       \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)\n 2. \\<And>nat nata.\n       \\<lbrakk>exp 3 A = Suc nat; exp 3 B = Suc nata\\<rbrakk>\n       \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>exp 3 A = Suc nat; exp 3 B = Suc nata\\<rbrakk>\n       \\<Longrightarrow> exp 3 A < 3 * (exp 3 A * exp 3 B)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp2: \"Suc 0 < 3 * exp 3 (B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < 3 * exp 3 B", "using exp3Min[of B]"], ["proof (prove)\nusing this:\n  0 < exp 3 B\n\ngoal (1 subgoal):\n 1. Suc 0 < 3 * exp 3 B", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma expSum: \"exp x (a+b) = (exp x a) * (exp x b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp x (a + b) = exp x a * exp x b", "apply(induct a, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"costBarrier: decreases whilst contains and unconsiders\""], ["", "lemma costBarrierDecreases':\n  notes ss = subs_def2 nforms_def Let_def subsFAtom_def subsFConj_def subsFAll_def costBarrier_def atoms_def exp3Min expSum\n  shows \"~SATAxiom (sequent \n(a, (num,fm) # list)) --> iA ~= (num, fm) --> \\<not> proofTree (tree subs (a, (num, fm) # list)) --> fSucn : subs (a, (num, fm) # list) --> iA \\<in> set list --> costBarrier iA (fSucn) < costBarrier iA (a, (num, fm) # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> SATAxiom (sequent (a, (num, fm) # list)) \\<longrightarrow>\n    iA \\<noteq> (num, fm) \\<longrightarrow>\n    \\<not> proofTree (tree subs (a, (num, fm) # list)) \\<longrightarrow>\n    fSucn \\<in> subs (a, (num, fm) # list) \\<longrightarrow>\n    iA \\<in> set list \\<longrightarrow>\n    costBarrier iA fSucn < costBarrier iA (a, (num, fm) # list)", "apply(rule_tac A=fm in formula_signs_cases)\n    \\<comment> \\<open>atoms\\<close>"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAtom Pos p vs) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAtom Pos p vs) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FAtom Pos p vs) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAtom Pos p vs) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FAtom Pos p vs) # list)\n 2. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAtom Neg p vs) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAtom Neg p vs) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FAtom Neg p vs) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAtom Neg p vs) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FAtom Neg p vs) # list)\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Pos f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Pos f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Pos f1 f2) # list)\n 4. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 6. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p vs.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAtom Neg p vs) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAtom Neg p vs) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FAtom Neg p vs) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAtom Neg p vs) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FAtom Neg p vs) # list)\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Pos f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Pos f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Pos f1 f2) # list)\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss)\n        \\<comment> \\<open>conj\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Pos f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Pos f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Pos f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Pos f1 f2) # list)\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Pos f1 f2) # list));\n        iA \\<noteq> (num, FConj Pos f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Pos f1 f2) # list));\n        fSucn \\<in> subs (a, (num, FConj Pos f1 f2) # list);\n        iA \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA fSucn\n                         < costBarrier iA (a, (num, FConj Pos f1 f2) # list)\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Pos f1 f2) # list));\n        iA \\<noteq> (num, FConj Pos f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Pos f1 f2) # list));\n        fSucn = (a, (0, f1) # list) \\<or> fSucn = (a, (0, f2) # list);\n        iA \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> (case fSucn of\n                          (atms, nAs) \\<Rightarrow>\n                            sumList\n                             (map (exp 3 \\<circ> size \\<circ> snd)\n                               (takeWhile ((\\<noteq>) iA) nAs)))\n                         < 3 * (exp 3 (size f1) * exp 3 (size f2)) +\n                           sumList\n                            (map (exp 3 \\<circ> size \\<circ> snd)\n                              (takeWhile ((\\<noteq>) iA) list))\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(erule disjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Pos f1 f2) # list));\n        iA \\<noteq> (num, FConj Pos f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Pos f1 f2) # list));\n        iA \\<in> set list; fSucn = (a, (0, f1) # list)\\<rbrakk>\n       \\<Longrightarrow> (case fSucn of\n                          (atms, nAs) \\<Rightarrow>\n                            sumList\n                             (map (exp 3 \\<circ> size \\<circ> snd)\n                               (takeWhile ((\\<noteq>) iA) nAs)))\n                         < 3 * (exp 3 (size f1) * exp 3 (size f2)) +\n                           sumList\n                            (map (exp 3 \\<circ> size \\<circ> snd)\n                              (takeWhile ((\\<noteq>) iA) list))\n 2. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Pos f1 f2) # list));\n        iA \\<noteq> (num, FConj Pos f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Pos f1 f2) # list));\n        iA \\<in> set list; fSucn = (a, (0, f2) # list)\\<rbrakk>\n       \\<Longrightarrow> (case fSucn of\n                          (atms, nAs) \\<Rightarrow>\n                            sumList\n                             (map (exp 3 \\<circ> size \\<circ> snd)\n                               (takeWhile ((\\<noteq>) iA) nAs)))\n                         < 3 * (exp 3 (size f1) * exp 3 (size f2)) +\n                           sumList\n                            (map (exp 3 \\<circ> size \\<circ> snd)\n                              (takeWhile ((\\<noteq>) iA) list))\n 3. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 5. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss exp2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Pos f1 f2) # list));\n        iA \\<noteq> (num, FConj Pos f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Pos f1 f2) # list));\n        iA \\<in> set list; fSucn = (a, (0, f2) # list)\\<rbrakk>\n       \\<Longrightarrow> (case fSucn of\n                          (atms, nAs) \\<Rightarrow>\n                            sumList\n                             (map (exp 3 \\<circ> size \\<circ> snd)\n                               (takeWhile ((\\<noteq>) iA) nAs)))\n                         < 3 * (exp 3 (size f1) * exp 3 (size f2)) +\n                           sumList\n                            (map (exp 3 \\<circ> size \\<circ> snd)\n                              (takeWhile ((\\<noteq>) iA) list))\n 2. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 4. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss exp2)\n    \\<comment> \\<open>disj\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<not> SATAxiom\n               (sequent\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FConj Neg f1 f2) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs\n                 (a, (num, FConj Neg f1 f2) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn\n       < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 f2.\n       \\<lbrakk>\\<not> SATAxiom\n                        (sequent (a, (num, FConj Neg f1 f2) # list));\n        iA \\<noteq> (num, FConj Neg f1 f2);\n        \\<not> proofTree (tree subs (a, (num, FConj Neg f1 f2) # list));\n        fSucn \\<in> subs (a, (num, FConj Neg f1 f2) # list);\n        iA \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA fSucn\n                         < costBarrier iA (a, (num, FConj Neg f1 f2) # list)\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 3. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss exp1 exp1')\n    \\<comment> \\<open>all\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Pos f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Pos f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Pos f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Pos f1) # list)\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom (sequent (a, (num, FAll Pos f1) # list));\n        iA \\<noteq> (num, FAll Pos f1);\n        \\<not> proofTree (tree subs (a, (num, FAll Pos f1) # list));\n        fSucn \\<in> subs (a, (num, FAll Pos f1) # list);\n        iA \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA fSucn\n                         < costBarrier iA (a, (num, FAll Pos f1) # list)\n 2. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss size_instance)\n  \\<comment> \\<open>ex\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1.\n       \\<not> SATAxiom\n               (sequent (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       iA \\<noteq> (num, FAll Neg f1) \\<longrightarrow>\n       \\<not> proofTree\n               (tree subs (a, (num, FAll Neg f1) # list)) \\<longrightarrow>\n       fSucn \\<in> subs (a, (num, FAll Neg f1) # list) \\<longrightarrow>\n       iA \\<in> set list \\<longrightarrow>\n       costBarrier iA fSucn < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1.\n       \\<lbrakk>\\<not> SATAxiom (sequent (a, (num, FAll Neg f1) # list));\n        iA \\<noteq> (num, FAll Neg f1);\n        \\<not> proofTree (tree subs (a, (num, FAll Neg f1) # list));\n        fSucn \\<in> subs (a, (num, FAll Neg f1) # list);\n        iA \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA fSucn\n                         < costBarrier iA (a, (num, FAll Neg f1) # list)", "apply(simp add: ss size_instance)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma costBarrierDecreases: \n  \"[| branch subs gamma f;\n  !n . ~proofTree (tree subs (f n));\n  contains f iA n;\n  ~(considers f iA) n\n  |] ==> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (f n)", "apply(subgoal_tac \"\\<not> terminal subs (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(subgoal_tac \"\\<not> SATAxiom (sequent (f n))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(subgoal_tac \"f (Suc n) \\<in> subs (f n)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n)); f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(frule_tac x=n in spec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n)); f (Suc n) \\<in> subs (f n);\n     \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(case_tac \"f n\", simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, b);\n        \\<not> SATAxiom (sequent (a, b)); f (Suc n) \\<in> subs (a, b);\n        \\<not> proofTree (tree subs (a, b)); f n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, b)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(case_tac b, simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, []);\n        \\<not> SATAxiom (sequent (a, [])); f (Suc n) \\<in> subs (a, []);\n        \\<not> proofTree (tree subs (a, [])); f n = (a, []); b = []\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, [])\n 2. \\<And>a b aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, b);\n        \\<not> SATAxiom (sequent (a, b)); f (Suc n) \\<in> subs (a, b);\n        \\<not> proofTree (tree subs (a, b)); f n = (a, b);\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, b)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 5. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(simp add: contains_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, b);\n        \\<not> SATAxiom (sequent (a, b)); f (Suc n) \\<in> subs (a, b);\n        \\<not> proofTree (tree subs (a, b)); f n = (a, b);\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, b)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(case_tac aa)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa list ab ba.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, b);\n        \\<not> SATAxiom (sequent (a, b)); f (Suc n) \\<in> subs (a, b);\n        \\<not> proofTree (tree subs (a, b)); f n = (a, b); b = aa # list;\n        aa = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, b)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(rename_tac num fm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, b);\n        \\<not> SATAxiom (sequent (a, b)); f (Suc n) \\<in> subs (a, b);\n        \\<not> proofTree (tree subs (a, b)); f n = (a, b); b = aa # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n)) < costBarrier iA (a, b)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n))\n                         < costBarrier iA (a, (num, fm) # list)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(simp add: contains_def considers_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc n))\n                         < costBarrier iA (a, (num, fm) # list)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(rule costBarrierDecreases'[rule_format])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> \\<not> SATAxiom (sequent (a, (num, fm) # list))\n 2. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> iA \\<noteq> (num, fm)\n 3. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> \\<not> proofTree (tree subs (a, (num, fm) # list))\n 4. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (a, (num, fm) # list)\n 5. \\<And>a b aa list num fm.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); iA \\<in> set list;\n        (num, fm) \\<noteq> iA; \\<not> terminal subs (a, (num, fm) # list);\n        \\<not> SATAxiom (sequent (a, (num, fm) # list));\n        f (Suc n) \\<in> subs (a, (num, fm) # list);\n        \\<not> proofTree (tree subs (a, (num, fm) # list));\n        f n = (a, (num, fm) # list); b = (num, fm) # list;\n        aa = (num, fm)\\<rbrakk>\n       \\<Longrightarrow> iA \\<in> set list\n 6. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 7. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 8. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply force+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> f (Suc n) \\<in> subs (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(rule branchSubs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> branch subs ?Gamma34 f\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 4. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n);\n     \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<not> SATAxiom (sequent (f n))\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(blast dest: SATAxiomTerminal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n     \\<not> considers f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(blast dest: containsNotTerminal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n  \\<comment> \\<open>FIXME boring splitting etc.\\<close>"], ["", "subsection \"path: EV contains implies EV considers\""], ["", "lemma considersContains: \"considers f iA n \\<Longrightarrow> contains f iA n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. considers f iA n \\<Longrightarrow> contains f iA n", "apply(simp add: considers_def contains_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case snd (f n) of [] \\<Rightarrow> False\n    | x # xs \\<Rightarrow> x = iA \\<Longrightarrow>\n    iA \\<in> set (snd (f n))", "apply(cases \"snd (f n)\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma containsConsiders: \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f iA) |]\n  ==> EV (considers f iA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f iA)\\<rbrakk>\n    \\<Longrightarrow> EV (considers f iA)", "apply(simp add: EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n. contains f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. considers f iA n", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n", "apply(case_tac \"considers f iA n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n", "apply(subgoal_tac \"\\<exists>n. (contains f iA n \\<and> \\<not> considers f iA n) \\<and>\n    \\<not> (contains f iA (Suc n) \\<and> \\<not> considers f iA (Suc n))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        \\<exists>n.\n           (contains f iA n \\<and> \\<not> considers f iA n) \\<and>\n           \\<not> (contains f iA (Suc n) \\<and>\n                   \\<not> considers f iA (Suc n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        (contains f iA na \\<and> \\<not> considers f iA na) \\<and>\n        \\<not> (contains f iA (Suc na) \\<and>\n                \\<not> considers f iA (Suc na))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply(simp, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; contains f iA na; \\<not> considers f iA na;\n        contains f iA (Suc na) \\<longrightarrow>\n        considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply(case_tac \"contains f iA (Suc na)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; contains f iA na; \\<not> considers f iA na;\n        contains f iA (Suc na) \\<longrightarrow> considers f iA (Suc na);\n        contains f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; contains f iA na; \\<not> considers f iA na;\n        contains f iA (Suc na) \\<longrightarrow> considers f iA (Suc na);\n        \\<not> contains f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 3. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n; contains f iA na; \\<not> considers f iA na;\n        contains f iA (Suc na) \\<longrightarrow> considers f iA (Suc na);\n        \\<not> contains f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. considers f iA n\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply(force dest!: containsPropagates)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            (contains f iA n \\<and>\n                             \\<not> considers f iA n) \\<and>\n                            \\<not> (contains f iA (Suc n) \\<and>\n                                    \\<not> considers f iA (Suc n))", "apply(rule_tac msrFn = \"%n. costBarrier iA (f n)\" and P = \"%n. contains f iA n & ~ considers f iA n\" in terminationRule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)\n 2. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (?m27 n) \\<and>\n                         \\<not> considers f iA (?m27 n)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n\\<rbrakk>\n       \\<Longrightarrow> contains f iA (?m27 n) \\<and>\n                         \\<not> considers f iA (?m27 n)\n 2. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)", "apply(case_tac \"(contains f iA (Suc na) \\<and> \\<not> considers f iA (Suc na))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        contains f iA (Suc na) \\<and>\n        \\<not> considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)\n 2. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        \\<not> (contains f iA (Suc na) \\<and>\n                \\<not> considers f iA (Suc na))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        contains f iA (Suc na) \\<and>\n        \\<not> considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> costBarrier iA (f (Suc na)) < costBarrier iA (f na)\n 2. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        \\<not> (contains f iA (Suc na) \\<and>\n                \\<not> considers f iA (Suc na))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)", "apply(erule costBarrierDecreases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n; \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        contains f iA (Suc na) \\<and>\n        \\<not> considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>n na.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n; \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        contains f iA (Suc na) \\<and>\n        \\<not> considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> contains f iA na\n 3. \\<And>n na.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f iA n; \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        contains f iA (Suc na) \\<and>\n        \\<not> considers f iA (Suc na)\\<rbrakk>\n       \\<Longrightarrow> \\<not> considers f iA na\n 4. \\<And>n na.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); contains f iA n;\n        \\<not> considers f iA n;\n        contains f iA na \\<and> \\<not> considers f iA na;\n        \\<not> (contains f iA (Suc na) \\<and>\n                \\<not> considers f iA (Suc na))\\<rbrakk>\n       \\<Longrightarrow> \\<not> (contains f iA (Suc na) \\<and>\n                                 \\<not> considers f iA (Suc na)) \\<or>\n                         (contains f iA (Suc na) \\<and>\n                          \\<not> considers f iA (Suc na)) \\<and>\n                         costBarrier iA (f (Suc na)) < costBarrier iA (f na)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: common lemma\""], ["", "lemma lemmA: \n  \"[| branch subs gamma f; ! n. ~ proofTree (tree subs (f n));\n    EV (contains f (i,A)) |]\n ==> ? n nAs. ~SATAxiom (sequent (f n)) & (nforms (f n) = (i,A) # nAs & f (Suc n) : subs (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, A))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n nAs.\n                         \\<not> SATAxiom (sequent (f n)) \\<and>\n                         nforms (f n) = (i, A) # nAs \\<and>\n                         f (Suc n) \\<in> subs (f n)", "apply(frule containsConsiders)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, A))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, A))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f ?iA)\n 3. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); EV (contains f (i, A));\n     EV (considers f ?iA)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n nAs.\n                         \\<not> SATAxiom (sequent (f n)) \\<and>\n                         nforms (f n) = (i, A) # nAs \\<and>\n                         f (Suc n) \\<in> subs (f n)", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); EV (contains f (i, A));\n     EV (considers f (i, A))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n nAs.\n                         \\<not> SATAxiom (sequent (f n)) \\<and>\n                         nforms (f n) = (i, A) # nAs \\<and>\n                         f (Suc n) \\<in> subs (f n)", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n. contains f (i, A) n;\n     \\<exists>n. considers f (i, A) n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n nAs.\n                         \\<not> SATAxiom (sequent (f n)) \\<and>\n                         nforms (f n) = (i, A) # nAs \\<and>\n                         f (Suc n) \\<in> subs (f n)", "apply(erule exE, frule considersContains)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; considers f (i, A) n;\n        contains f (i, A) n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nAs.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            nforms (f n) = (i, A) # nAs \\<and>\n                            f (Suc n) \\<in> subs (f n)", "apply(unfold considers_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n;\n        case snd (f n) of [] \\<Rightarrow> False\n        | x # xs \\<Rightarrow> x = (i, A);\n        contains f (i, A) n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nAs.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            nforms (f n) = (i, A) # nAs \\<and>\n                            f (Suc n) \\<in> subs (f n)", "apply(case_tac \"snd (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n;\n        case snd (f n) of [] \\<Rightarrow> False\n        | x # xs \\<Rightarrow> x = (i, A);\n        contains f (i, A) n; snd (f n) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nAs.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            nforms (f n) = (i, A) # nAs \\<and>\n                            f (Suc n) \\<in> subs (f n)\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n;\n        case snd (f n) of [] \\<Rightarrow> False\n        | x # xs \\<Rightarrow> x = (i, A);\n        contains f (i, A) n; snd (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nAs.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            nforms (f n) = (i, A) # nAs \\<and>\n                            f (Suc n) \\<in> subs (f n)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n;\n        case snd (f n) of [] \\<Rightarrow> False\n        | x # xs \\<Rightarrow> x = (i, A);\n        contains f (i, A) n; snd (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n nAs.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            nforms (f n) = (i, A) # nAs \\<and>\n                            f (Suc n) \\<in> subs (f n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<not> SATAxiom (sequent (f n)) \\<and>\n                            (\\<exists>nAs.\n                                nforms (f n) = (i, A) # nAs) \\<and>\n                            f (Suc n) \\<in> subs (f n)", "apply(rule_tac x=n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> \\<not> SATAxiom (sequent (f n)) \\<and>\n                         (\\<exists>nAs. nforms (f n) = (i, A) # nAs) \\<and>\n                         f (Suc n) \\<in> subs (f n)", "apply (intro conjI, rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list; SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nAs. nforms (f n) = (i, A) # nAs\n 3. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(blast dest!: SATAxiomEq[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(rule_tac x=list in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> nforms (f n) = (i, A) # list\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(simp add: nforms_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(frule containsNotTerminal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> contains f (?iA38 n a list) (?n38 n a list)\n 3. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list;\n        \\<not> terminal subs (f (?n38 n a list))\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list\\<rbrakk>\n       \\<Longrightarrow> contains f (?iA38 n a list) (?n38 n a list)\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list;\n        \\<not> terminal subs (f (?n38 n a list))\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs gamma f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, A) n; a = (i, A); contains f (i, A) n;\n        snd (f n) = (i, A) # list; \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> f (Suc n) \\<in> subs (f n)", "apply(blast dest!: branchSubs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: FConj,FDisj,FAll\""], ["", "lemma EV_disj: \"(EV P | EV Q) = EV (\\<lambda>n. P n | Q n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (EV P \\<or> EV Q) = EV (\\<lambda>n. P n \\<or> Q n)", "apply (unfold EV_def, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsConj: \"[| EV (contains f (i,FConj Pos A0 A1)); \n  branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n  |] ==> EV (contains f (0,A0)) | EV (contains f (0,A1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1)); branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<or> EV (contains f (0, A1))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<or> EV (contains f (0, A1))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Pos A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<or> EV (contains f (0, A1))", "apply(subgoal_tac \"EV (\\<lambda> n. contains f (0,A0) n | contains f (0,A1) n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Pos A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n);\n     EV (\\<lambda>n.\n            contains f (0, A0) n \\<or> contains f (0, A1) n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<or> EV (contains f (0, A1))\n 2. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Pos A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (\\<lambda>n.\n                             contains f (0, A0) n \\<or>\n                             contains f (0, A1) n)", "apply(simp add: EV_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FConj Pos A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Pos A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (\\<lambda>n.\n                             contains f (0, A0) n \\<or>\n                             contains f (0, A1) n)", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>n. contains f (i, FConj Pos A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Pos A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         contains f (0, A0) n \\<or> contains f (0, A1) n", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Pos A0 A1) n; \\<not> SATAxiom (sequent (f na));\n        nforms (f na) = (i, FConj Pos A0 A1) # nAs;\n        f (Suc na) \\<in> subs (f na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            contains f (0, A0) n \\<or> contains f (0, A1) n", "apply(rename_tac n n' nAs, rule_tac x=\"Suc n'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Pos A0 A1) n; \\<not> SATAxiom (sequent (f n'));\n        nforms (f n') = (i, FConj Pos A0 A1) # nAs;\n        f (Suc n') \\<in> subs (f n')\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n') \\<or>\n                         contains f (0, A1) (Suc n')", "apply(simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Pos A0 A1) n; \\<not> SATAxiom (sequent (f n'));\n        nforms (f n') = (i, FConj Pos A0 A1) # nAs;\n        f (Suc n') \\<in> subsFConj (atoms (f n')) nAs Pos A0 A1\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n') \\<or>\n                         contains f (0, A1) (Suc n')", "apply(simp add: subsFConj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n' nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Pos A0 A1) n; \\<not> SATAxiom (sequent (f n'));\n        nforms (f n') = (i, FConj Pos A0 A1) # nAs;\n        f (Suc n') = (atoms (f n'), (0, A0) # nAs) \\<or>\n        f (Suc n') = (atoms (f n'), (0, A1) # nAs)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n') \\<or>\n                         contains f (0, A1) (Suc n')", "apply (simp add: contains_def nforms_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsDisj: \"[| EV (contains f (i,FConj Neg A0 A1)); \n  branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n  |] ==> EV (contains f (0,A0)) & EV (contains f (0,A1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1)); branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<and> EV (contains f (0, A1))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<and> EV (contains f (0, A1))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0)) \\<and> EV (contains f (0, A1))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A0))\n 2. \\<lbrakk>EV (contains f (i, FConj Neg A0 A1));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, A1))", "apply(unfold EV_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A0) n\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n);\n        contains f (i, FConj Neg A0 A1) n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (0, A0) n\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (0, A0) n\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n)\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(clarify, simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Neg A0 A1) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs;\n        f (Suc n) \\<in> subsFConj (atoms (f n)) nAs Neg A0 A1\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n)\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(simp add: subsFConj_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Neg A0 A1) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs;\n        f (Suc n) = (atoms (f n), (0, A0) # (0, A1) # nAs)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A0) (Suc n)\n 2. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n);\n        contains f (i, FConj Neg A0 A1) n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (0, A1) n", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FConj Neg A0 A1) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FConj Neg A0 A1) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A1) (Suc n)", "apply(clarify, simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Neg A0 A1) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs;\n        f (Suc n) \\<in> subsFConj (atoms (f n)) nAs Neg A0 A1\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A1) (Suc n)", "apply(simp add: subsFConj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FConj Neg A0 A1) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FConj Neg A0 A1) # nAs;\n        f (Suc n) = (atoms (f n), (0, A0) # (0, A1) # nAs)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, A1) (Suc n)", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsAll: \n  \"[| EV (contains f (i,FAll Pos body)); branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n     |]\n   ==> ? v . EV (contains f (0,instanceF v body))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FAll Pos body)); branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v. EV (contains f (0, instanceF v body))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FAll Pos body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>EV (contains f (i, FAll Pos body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>EV (contains f (i, FAll Pos body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v. EV (contains f (0, instanceF v body))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FAll Pos body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FAll Pos body) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>v. EV (contains f (0, instanceF v body))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>EV (contains f (i, FAll Pos body));\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Pos body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. EV (contains f (0, instanceF v body))", "apply(rule_tac x=\"freshVar(freeVarsFL (sequent (f n)))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>EV (contains f (i, FAll Pos body));\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Pos body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> EV (contains f\n                              (0, instanceF\n                                   (freshVar (freeVarsFL (sequent (f n))))\n                                   body))", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FAll Pos body) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Pos body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            contains f\n                             (0, instanceF\n                                  (freshVar (freeVarsFL (sequent (f n))))\n                                  body)\n                             na", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FAll Pos body) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Pos body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f\n                          (0, instanceF\n                               (freshVar (freeVarsFL (sequent (f n)))) body)\n                          (Suc n)", "apply(clarify, simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Pos body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Pos body) # nAs;\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) nAs i Pos body\n               (freeVarsFL (sequent (f n)))\\<rbrakk>\n       \\<Longrightarrow> contains f\n                          (0, instanceF\n                               (freshVar (freeVarsFL (sequent (f n)))) body)\n                          (Suc n)", "apply(simp add: subsFAll_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Pos body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Pos body) # nAs;\n        f (Suc n) =\n        (atoms (f n),\n         (0, instanceF (freshVar (freeVarsFL (sequent (f n)))) body) #\n         nAs)\\<rbrakk>\n       \\<Longrightarrow> contains f\n                          (0, instanceF\n                               (freshVar (freeVarsFL (sequent (f n)))) body)\n                          (Suc n)", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsEx_instance: \n  \"[| EV (contains f (i,FAll Neg body)); branch subs gamma f; !n . ~ proofTree (tree subs (f n))\n      |]\n  ==> EV (contains f (0,instanceF (X i) body))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FAll Neg body)); branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, instanceF (X i) body))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>EV (contains f (i, FAll Neg body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>EV (contains f (i, FAll Neg body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>EV (contains f (i, FAll Neg body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, instanceF (X i) body))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FAll Neg body));\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, instanceF (X i) body))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>EV (contains f (i, FAll Neg body));\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (0, instanceF (X i) body))", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FAll Neg body) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (0, instanceF (X i) body) n", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<exists>n. contains f (i, FAll Neg body) n;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f (0, instanceF (X i) body) (Suc n)", "apply(clarify, simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Neg body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Neg body) # nAs;\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) nAs i Neg body\n               (freeVarsFL (sequent (f n)))\\<rbrakk>\n       \\<Longrightarrow> contains f (0, instanceF (X i) body) (Suc n)", "apply(simp add: subsFAll_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Neg body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Neg body) # nAs;\n        f (Suc n) =\n        (atoms (f n),\n         (0, instanceF (X i) body) #\n         nAs @ [(Suc i, FAll Neg body)])\\<rbrakk>\n       \\<Longrightarrow> contains f (0, instanceF (X i) body) (Suc n)", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsEx_repeat: \"\n  [| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (i,FAll Neg body)) |]\n   ==> EV (contains f (Suc i,FAll Neg body))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAll Neg body))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (Suc i, FAll Neg body))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAll Neg body))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAll Neg body))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAll Neg body));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (Suc i, FAll Neg body))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAll Neg body));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (Suc i, FAll Neg body))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAll Neg body));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (Suc i, FAll Neg body))", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, FAll Neg body) n;\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (Suc i, FAll Neg body) n", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>n. contains f (i, FAll Neg body) n;\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAll Neg body) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> contains f (Suc i, FAll Neg body) (Suc n)", "apply(clarify, simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Neg body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Neg body) # nAs;\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) nAs i Neg body\n               (freeVarsFL (sequent (f n)))\\<rbrakk>\n       \\<Longrightarrow> contains f (Suc i, FAll Neg body) (Suc n)", "apply(simp add: subsFAll_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        contains f (i, FAll Neg body) na; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (i, FAll Neg body) # nAs;\n        f (Suc n) =\n        (atoms (f n),\n         (0, instanceF (X i) body) #\n         nAs @ [(Suc i, FAll Neg body)])\\<rbrakk>\n       \\<Longrightarrow> contains f (Suc i, FAll Neg body) (Suc n)", "apply(simp add: contains_def nforms_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: lemmas (temporal related)\""], ["", "(******\n Should have abstracted to have temporal ops:\n    EV   : (nat -> bool) -> nat -> bool\n    AW   : (nat -> bool) -> nat -> bool\n    NEXT : (nat -> bool) -> nat -> bool\n then require:\n    EV P and EV B imp (\\n. A n & B n)\n\n already think have done similar proofs to this one elsewhere,\n Q: where? share proofs?\n ******)"], ["", "lemma lemma1: \"[| P A n ; !A n. P A n --> P A (Suc n) |]\n   ==> P A (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P A n;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P A (n + m)", "apply (induct m, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lemma2: \n  \"[| P A n ; P B m ; ! A n. P A n --> P A (Suc n) |]\n  ==> ? n . P A n & P B n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P A n; P B m;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. P A n \\<and> P B n", "apply (rule exI[of _ \"n+m\"], rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P A n; P B m;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P A (n + m)\n 2. \\<lbrakk>P A n; P B m;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P B (n + m)", "apply(blast intro!: lemma1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P A n; P B m;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P B (n + m)", "apply(rule subst[OF add.commute])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P A n; P B m;\n     \\<forall>A n. P A n \\<longrightarrow> P A (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P B (m + n)", "apply(blast intro!: lemma1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: FAtoms\""], ["", "lemma notTerminalNotSATAxiom: \"\\<not> terminal subs gamma \\<Longrightarrow> \\<not> SATAxiom (sequent gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> terminal subs gamma \\<Longrightarrow>\n    \\<not> SATAxiom (sequent gamma)", "apply(erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SATAxiom (sequent gamma) \\<Longrightarrow> terminal subs gamma", "apply(erule SATAxiomTerminal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma notTerminalNforms: \"\\<not> terminal subs (f n) \\<Longrightarrow> nforms (f n) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> terminal subs (f n) \\<Longrightarrow> nforms (f n) \\<noteq> []", "apply(erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nforms (f n) = [] \\<Longrightarrow> terminal subs (f n)", "apply(erule nformsTerminal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atomsPropagate: \"[| branch subs gamma f |]\n   ==> x : set (atoms (f n)) --> x : set (atoms (f (Suc n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch subs gamma f \\<Longrightarrow>\n    x \\<in> set (atoms (f n)) \\<longrightarrow>\n    x \\<in> set (atoms (f (Suc n)))", "apply(cases \"terminal subs (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs gamma f; terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))\n 2. \\<lbrakk>branch subs gamma f; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply(drule branchStops)"], ["proof (prove)\ngoal (3 subgoals):\n 1. terminal subs (f n) \\<Longrightarrow> terminal subs (f ?n1)\n 2. \\<lbrakk>terminal subs (f n); f (Suc ?n1) = f ?n1\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))\n 3. \\<lbrakk>branch subs gamma f; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>terminal subs (f n); f (Suc n) = f n\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))\n 2. \\<lbrakk>branch subs gamma f; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f; \\<not> terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply(drule branchSubs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> terminal subs (f n) \\<Longrightarrow>\n    \\<not> terminal subs (f ?n4)\n 2. \\<lbrakk>\\<not> terminal subs (f n);\n     f (Suc ?n4) \\<in> subs (f ?n4)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f n)) \\<longrightarrow>\n                      x \\<in> set (atoms (f (Suc n)))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n     x \\<in> set (atoms (f n))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(frule notTerminalNotSATAxiom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n     x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(frule notTerminalNforms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n     x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n     nforms (f n) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(simp add: subs_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f n);\n     f (Suc n)\n     \\<in> (case nforms (f n) of [] \\<Rightarrow> {}\n            | nA # nAs \\<Rightarrow>\n                let (na, A) = nA\n                in case A of\n                   FAtom z P vs \\<Rightarrow>\n                     subsFAtom (atoms (f n)) nAs z P vs\n                   | FConj z A0 A1 \\<Rightarrow>\n                       subsFConj (atoms (f n)) nAs z A0 A1\n                   | FAll z A \\<Rightarrow>\n                       subsFAll (atoms (f n)) nAs na z A\n                        (freeVarsFL (sequent (f n))));\n     x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n     nforms (f n) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(cases \"nforms (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> terminal subs (f n);\n     f (Suc n)\n     \\<in> (case nforms (f n) of [] \\<Rightarrow> {}\n            | nA # nAs \\<Rightarrow>\n                let (na, A) = nA\n                in case A of\n                   FAtom z P vs \\<Rightarrow>\n                     subsFAtom (atoms (f n)) nAs z P vs\n                   | FConj z A0 A1 \\<Rightarrow>\n                       subsFConj (atoms (f n)) nAs z A0 A1\n                   | FAll z A \\<Rightarrow>\n                       subsFAll (atoms (f n)) nAs na z A\n                        (freeVarsFL (sequent (f n))));\n     x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n     nforms (f n) \\<noteq> []; nforms (f n) = []\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case nforms (f n) of [] \\<Rightarrow> {}\n               | nA # nAs \\<Rightarrow>\n                   let (na, A) = nA\n                   in case A of\n                      FAtom z P vs \\<Rightarrow>\n                        subsFAtom (atoms (f n)) nAs z P vs\n                      | FConj z A0 A1 \\<Rightarrow>\n                          subsFConj (atoms (f n)) nAs z A0 A1\n                      | FAll z A \\<Rightarrow>\n                          subsFAll (atoms (f n)) nAs na z A\n                           (freeVarsFL (sequent (f n))));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) \\<noteq> []; nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case nforms (f n) of [] \\<Rightarrow> {}\n               | nA # nAs \\<Rightarrow>\n                   let (na, A) = nA\n                   in case A of\n                      FAtom z P vs \\<Rightarrow>\n                        subsFAtom (atoms (f n)) nAs z P vs\n                      | FConj z A0 A1 \\<Rightarrow>\n                          subsFConj (atoms (f n)) nAs z A0 A1\n                      | FAll z A \\<Rightarrow>\n                          subsFAll (atoms (f n)) nAs na z A\n                           (freeVarsFL (sequent (f n))));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) \\<noteq> []; nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case a of\n               (na, FAtom xa xb xc) \\<Rightarrow>\n                 subsFAtom (atoms (f n)) list xa xb xc\n               | (na, FConj xa xb xc) \\<Rightarrow>\n                   subsFConj (atoms (f n)) list xa xb xc\n               | (na, FAll z A) \\<Rightarrow>\n                   subsFAll (atoms (f n)) list na z A\n                    (freeVarsFL (sequent (f n))));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(case_tac a, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aa ba.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case ba of\n               FAtom x xa xb \\<Rightarrow>\n                 subsFAtom (atoms (f n)) list x xa xb\n               | FConj x xa xb \\<Rightarrow>\n                   subsFConj (atoms (f n)) list x xa xb\n               | FAll z A \\<Rightarrow>\n                   subsFAll (atoms (f n)) list aa z A\n                    (freeVarsFL (sequent (f n))));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, ba) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(case_tac ba, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list aa x11 x12 x13.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n) \\<in> subsFAtom (atoms (f n)) list x11 x12 x13;\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAtom x11 x12 x13) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))\n 2. \\<And>list aa x21 x22 x23.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n) \\<in> subsFConj (atoms (f n)) list x21 x22 x23;\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj x21 x22 x23) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))\n 3. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(simp add: subsFAtom_def atoms_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aa x21 x22 x23.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n) \\<in> subsFConj (atoms (f n)) list x21 x22 x23;\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj x21 x22 x23) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))\n 2. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(simp add: subsFConj_def atoms_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aa x21 x22 x23.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case x21 of\n               Pos \\<Rightarrow>\n                 {(fst (f n), (0, x22) # list),\n                  (fst (f n), (0, x23) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n), (0, x22) # (0, x23) # list)});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj x21 x22 x23) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 2. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(rename_tac signs a b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aa signs a b.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {(fst (f n), (0, a) # list), (fst (f n), (0, b) # list)}\n               | Neg \\<Rightarrow> {(fst (f n), (0, a) # (0, b) # list)});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj signs a b) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 2. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(case_tac signs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>list aa signs a b.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {(fst (f n), (0, a) # list), (fst (f n), (0, b) # list)}\n               | Neg \\<Rightarrow> {(fst (f n), (0, a) # (0, b) # list)});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj signs a b) # list; signs = Pos\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 2. \\<And>list aa signs a b.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {(fst (f n), (0, a) # list), (fst (f n), (0, b) # list)}\n               | Neg \\<Rightarrow> {(fst (f n), (0, a) # (0, b) # list)});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj signs a b) # list; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 3. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aa signs a b.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {(fst (f n), (0, a) # list), (fst (f n), (0, b) # list)}\n               | Neg \\<Rightarrow> {(fst (f n), (0, a) # (0, b) # list)});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FConj signs a b) # list; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 2. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> subsFAll (atoms (f n)) list aa x31 x32\n               (freeVarsFL (sequent (f n)));\n        x \\<in> set (atoms (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (atoms (f (Suc n)))", "apply(simp add: subsFAll_def atoms_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aa x31 x32.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case x31 of\n               Pos \\<Rightarrow>\n                 {let v = freshVar (freeVarsFL (sequent (f n)))\n                  in (fst (f n), (0, instanceF v x32) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n),\n                     (0, instanceF (X aa) x32) #\n                     list @ [(Suc aa, FAll Neg x32)])});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll x31 x32) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))", "apply(rename_tac signs a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aa signs a.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {let v = freshVar (freeVarsFL (sequent (f n)))\n                  in (fst (f n), (0, instanceF v a) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n),\n                     (0, instanceF (X aa) a) #\n                     list @ [(Suc aa, FAll Neg a)])});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll signs a) # list\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))", "apply(case_tac signs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aa signs a.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {let v = freshVar (freeVarsFL (sequent (f n)))\n                  in (fst (f n), (0, instanceF v a) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n),\n                     (0, instanceF (X aa) a) #\n                     list @ [(Suc aa, FAll Neg a)])});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll signs a) # list; signs = Pos\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))\n 2. \\<And>list aa signs a.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {let v = freshVar (freeVarsFL (sequent (f n)))\n                  in (fst (f n), (0, instanceF v a) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n),\n                     (0, instanceF (X aa) a) #\n                     list @ [(Suc aa, FAll Neg a)])});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll signs a) # list; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))", "apply(force simp: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aa signs a.\n       \\<lbrakk>\\<not> terminal subs (f n);\n        f (Suc n)\n        \\<in> (case signs of\n               Pos \\<Rightarrow>\n                 {let v = freshVar (freeVarsFL (sequent (f n)))\n                  in (fst (f n), (0, instanceF v a) # list)}\n               | Neg \\<Rightarrow>\n                   {(fst (f n),\n                     (0, instanceF (X aa) a) #\n                     list @ [(Suc aa, FAll Neg a)])});\n        x \\<in> set (fst (f n)); \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (aa, FAll signs a) # list; signs = Neg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (fst (f (Suc n)))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: FEx cases\""], ["", "lemma evContainsEx0_allRepeats: \n  \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (0,FAll Neg A)) |]\n  ==> EV (contains f (i,FAll Neg A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (0, FAll Neg A))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg A))", "apply (induct i, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>branch subs gamma f;\n                 \\<forall>n. \\<not> proofTree (tree subs (f n));\n                 EV (contains f (0, FAll Neg A))\\<rbrakk>\n                \\<Longrightarrow> EV (contains f (i, FAll Neg A));\n        branch subs gamma f; \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (0, FAll Neg A))\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (Suc i, FAll Neg A))", "apply(blast dest!: evContainsEx_repeat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsEx0_allInstances:\n  \"[| branch subs gamma f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (0,FAll Neg A)) |]\n  ==> EV (contains f (0,instanceF (X i) A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (0, FAll Neg A))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, instanceF (X i) A))", "apply(blast dest!: evContainsEx0_allRepeats intro!: evContainsEx_instance)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"pseq: creates initial pseq\""], ["", "lemma containsPSeq0D: \"branch subs (pseq fs) f \\<Longrightarrow> contains f (i,A) 0 \\<Longrightarrow> i=0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f; contains f (i, A) 0\\<rbrakk>\n    \\<Longrightarrow> i = 0", "apply(drule branch0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>contains f (i, A) 0; f 0 = pseq fs\\<rbrakk>\n    \\<Longrightarrow> i = 0", "apply (simp add: pseq_def contains_def, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: contain any (i,FEx y) means contain all (i,FEx y)\""], ["", "(******\n Now, show (Suc i,FEx v A) present means (i,FEx v A) present (or at start).\n Assumes initial pseq contains only (0,form) pairs.\n ------\n Show that only way of introducing a (Suc i,FEx_) was from (i,FEx_).\n contains n == considers n or contains n+.\n\n Want to find the point where it was introduced.\n Have, P true all n or fails at 0 or for a (first) successor.\n\n     (!n. P n) | (~P 0) | (P n & ~ P (Suc n))\n\n Instance this with P n = ~(contains ..FEx.. n).\n ******)"], ["", "lemma claim: \"(A | B | C) = (~C --> ~B --> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<or> B \\<or> C) =\n    (\\<not> C \\<longrightarrow> \\<not> B \\<longrightarrow> A)", "by auto"], ["", "lemma natPredCases: \"(!n. P n) | (~P 0) | (? n . P n & ~ P (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n. P n) \\<or>\n    \\<not> P 0 \\<or> (\\<exists>n. P n \\<and> \\<not> P (Suc n))", "apply(rule claim[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>n. P n \\<and> \\<not> P (Suc n)) \\<longrightarrow>\n    \\<not> \\<not> P 0 \\<longrightarrow> (\\<forall>n. P n)", "apply(intro impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>n. P n \\<and> \\<not> P (Suc n);\n     \\<not> \\<not> P 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. P n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n. P n \\<longrightarrow> P (Suc n); P 0\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. P n", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. P n \\<longrightarrow> P (Suc n); P 0\\<rbrakk>\n       \\<Longrightarrow> P n", "apply(induct_tac n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. P n \\<longrightarrow> P (Suc n); P 0\\<rbrakk>\n       \\<Longrightarrow> P 0\n 2. \\<And>n na.\n       \\<lbrakk>\\<forall>n. P n \\<longrightarrow> P (Suc n); P 0;\n        P na\\<rbrakk>\n       \\<Longrightarrow> P (Suc na)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma containsNotTerminal': \n  \"\\<lbrakk> branch subs gamma f; !n . ~proofTree (tree subs (f n)); contains f iA n \\<rbrakk> \\<Longrightarrow> ~ (terminal subs (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     contains f iA n\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply (rule containsNotTerminal, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma notTerminalSucNotTerminal: \"\\<lbrakk> \\<not> terminal subs (f (Suc n)); branch subs gamma f \\<rbrakk> \\<Longrightarrow> \\<not> terminal subs (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> terminal subs (f (Suc n)); branch subs gamma f\\<rbrakk>\n    \\<Longrightarrow> \\<not> terminal subs (f n)", "apply(erule contrapos_nn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs gamma f; terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> terminal subs (f (Suc n))", "apply(rule_tac branchTerminalPropagates[of _ _ _ _ 1, simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs gamma f; terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> branch subs ?Gamma2 f\n 2. \\<lbrakk>branch subs gamma f; terminal subs (f n)\\<rbrakk>\n    \\<Longrightarrow> terminal subs (f n)", "apply(assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>FIXME move to Tree?\\<close>"], ["", "lemma evContainsExSuc_containsEx:\n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (Suc i,FAll Neg body)) |]\n  ==> EV (contains f (i,FAll Neg body))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(cut_tac P=\"%n. ~ contains f (Suc i,FAll Neg body) n\" in natPredCases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     (\\<forall>n. \\<not> contains f (Suc i, FAll Neg body) n) \\<or>\n     \\<not> \\<not> contains f (Suc i, FAll Neg body) 0 \\<or>\n     (\\<exists>n.\n         \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n         \\<not> \\<not> contains f (Suc i, FAll Neg body) (Suc n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     (\\<forall>n. \\<not> contains f (Suc i, FAll Neg body) n) \\<or>\n     contains f (Suc i, FAll Neg body) 0 \\<or>\n     (\\<exists>n.\n         \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n         contains f (Suc i, FAll Neg body) (Suc n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     \\<forall>n. \\<not> contains f (Suc i, FAll Neg body) n\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))\n 2. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     contains f (Suc i, FAll Neg body) 0 \\<or>\n     (\\<exists>n.\n         \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n         contains f (Suc i, FAll Neg body) (Suc n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(simp add: EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     contains f (Suc i, FAll Neg body) 0 \\<or>\n     (\\<exists>n.\n         \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n         contains f (Suc i, FAll Neg body) (Suc n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     contains f (Suc i, FAll Neg body) 0\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))\n 2. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     \\<exists>n.\n        \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(blast dest!: containsPSeq0D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (Suc i, FAll Neg body));\n     \\<exists>n.\n        \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(thin_tac \"EV _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     \\<exists>n.\n        \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n \\<and>\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (i, FAll Neg body))", "apply(unfold EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. contains f (i, FAll Neg body) n", "apply(rule_tac x=n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> contains f (i, FAll Neg body) n", "apply(rule considersContains)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(frule containsNotTerminal')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n)\\<rbrakk>\n       \\<Longrightarrow> contains f (?iA26 n) (?n26 n)\n 3. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f (?n26 n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f (Suc n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(frule notTerminalSucNotTerminal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f (Suc n))\\<rbrakk>\n       \\<Longrightarrow> branch subs (?gamma30 n) f\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f (Suc n));\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f (Suc n));\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(thin_tac \"\\<not> terminal x y\" for x y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(frule branchSubs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<not> terminal subs (f (?n38 n))\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n);\n        f (Suc (?n38 n)) \\<in> subs (f (?n38 n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(frule notTerminalNforms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(case_tac \"SATAxiom (sequent (f n))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(drule SATAxiomTerminal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; terminal subs (f n)\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(subgoal_tac \"(\\<exists>i A nAs. nforms (f n) = (i, A) # nAs)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(rule_tac f=f and n=n in cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        terminal subs (f n) \\<or>\n        \\<not> (terminal subs (f n) \\<and>\n                (\\<exists>i A nAs. nforms (f n) = (i, A) # nAs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(case_tac \"nforms (f n)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n a list.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 3. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n a list.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\n 2. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(case_tac a, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        \\<exists>i A nAs. nforms (f n) = (i, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> considers f (i, FAll Neg body) n", "apply(unfold considers_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        nforms (f n) \\<noteq> []; \\<not> SATAxiom (sequent (f n));\n        nforms (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> case snd (f n) of [] \\<Rightarrow> False\n                         | x # xs \\<Rightarrow> x = (i, FAll Neg body)", "apply(simp add: nforms_def)\n  \\<comment> \\<open>shift A into succedent\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n)); snd (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> ia = i \\<and> A = FAll Neg body", "apply(rule_tac P=\"snd (f n) = (ia, A) # nAs\" in rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n)); snd (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> snd (f n) = (ia, A) # nAs\n 2. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n)); snd (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> snd (f n) = (ia, A) # nAs \\<longrightarrow>\n                         ia = i \\<and> A = FAll Neg body", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n)); snd (f n) = (ia, A) # nAs\\<rbrakk>\n       \\<Longrightarrow> snd (f n) = (ia, A) # nAs \\<longrightarrow>\n                         ia = i \\<and> A = FAll Neg body", "apply(thin_tac \"snd (f n) = (ia, A) # nAs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n ia A nAs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) = (ia, A) # nAs \\<longrightarrow>\n                         ia = i \\<and> A = FAll Neg body", "apply(rule_tac A=A in formula_signs_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>n ia A nAs p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FAtom Pos p vs) # nAs \\<longrightarrow>\n                         ia = i \\<and> FAtom Pos p vs = FAll Neg body\n 2. \\<And>n ia A nAs p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FAtom Neg p vs) # nAs \\<longrightarrow>\n                         ia = i \\<and> FAtom Neg p vs = FAll Neg body\n 3. \\<And>n ia A nAs f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FConj Pos f1 f2) # nAs \\<longrightarrow>\n                         ia = i \\<and> FConj Pos f1 f2 = FAll Neg body\n 4. \\<And>n ia A nAs f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FConj Neg f1 f2) # nAs \\<longrightarrow>\n                         ia = i \\<and> FConj Neg f1 f2 = FAll Neg body\n 5. \\<And>n ia A nAs f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FAll Pos f1) # nAs \\<longrightarrow>\n                         ia = i \\<and> FAll Pos f1 = FAll Neg body\n 6. \\<And>n ia A nAs f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<not> contains f (Suc i, FAll Neg body) n;\n        contains f (Suc i, FAll Neg body) (Suc n);\n        \\<not> terminal subs (f n); f (Suc n) \\<in> subs (f n);\n        \\<not> SATAxiom (sequent (f n))\\<rbrakk>\n       \\<Longrightarrow> snd (f n) =\n                         (ia, FAll Neg f1) # nAs \\<longrightarrow>\n                         ia = i \\<and> FAll Neg f1 = FAll Neg body", "apply(auto simp add: subs_def2 nforms_def Let_def subsFAtom_def subsFConj_def subsFAll_def contains_def2 Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \\<comment> \\<open>phew, bit precarious, but not too much going on besides unfolding defns. and computing a bit. Need to set simps up\\<close>"], ["", "subsection \"EV contains: contain any (i,FEx y) means contain all (i,FEx y)\""], ["", "lemma evContainsEx_containsEx0: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n)) |]\n  ==> EV (contains f (i,FAll Neg A)) -->\n      EV (contains f (0,FAll Neg A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (i, FAll Neg A)) \\<longrightarrow>\n                      EV (contains f (0, FAll Neg A))", "apply (induct i, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>branch subs (pseq fs) f;\n                 \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n                \\<Longrightarrow> EV (contains f\n (i, FAll Neg A)) \\<longrightarrow>\n                                  EV (contains f (0, FAll Neg A));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> EV (contains f\n                              (Suc i, FAll Neg A)) \\<longrightarrow>\n                         EV (contains f (0, FAll Neg A))", "apply(blast dest!: evContainsExSuc_containsEx)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsExval: \n  \"[| EV (contains f (i,FAll Neg body)); branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n))\n  |] \n  ==> ! v . EV (contains f (0,instanceF v body))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>EV (contains f (i, FAll Neg body)); branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v. EV (contains f (0, instanceF v body))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>EV (contains f (i, FAll Neg body)); branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (0, instanceF v body))", "apply(induct_tac v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v xa.\n       \\<lbrakk>EV (contains f (i, FAll Neg body)); branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> EV (contains f (0, instanceF (X xa) body))", "apply(blast intro!: evContainsEx0_allInstances dest!: evContainsEx_containsEx0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"EV contains: atoms\""], ["", "lemma atomsInSequentI[rule_format]: \"  (z,P,vs) : set (fst ps) -->\n     FAtom z P vs : set (sequent ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z, P, vs) \\<in> set (fst ps) \\<longrightarrow>\n    FAtom z P vs \\<in> set (sequent ps)", "apply(simp add: sequent_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z, P, vs) \\<in> set (fst ps) \\<longrightarrow>\n    (\\<exists>uu_ uua_.\n        (uua_, uu_) = ps \\<and>\n        (FAtom z P vs \\<in> snd ` set uu_ \\<or>\n         FAtom z P vs\n         \\<in> (\\<lambda>x.\n                   case x of (z, xa, xb) \\<Rightarrow> FAtom z xa xb) `\n               set uua_))", "apply(cases ps, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evContainsAtom1: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n     EV (contains f (i,FAtom z P vs)) |]\n  ==> ? n . (z,P,vs) : set (fst (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. (z, P, vs) \\<in> set (fst (f n))", "apply(drule lemmA)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, ?A))\n 3. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (?i, ?A) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. (z, P, vs) \\<in> set (fst (f n))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs));\n     \\<exists>n nAs.\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        nforms (f n) = (i, FAtom z P vs) # nAs \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. (z, P, vs) \\<in> set (fst (f n))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAtom z P vs) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. (z, P, vs) \\<in> set (fst (f n))", "apply(rule_tac x=\"Suc n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        \\<exists>nAs.\n           \\<not> SATAxiom (sequent (f n)) \\<and>\n           nforms (f n) = (i, FAtom z P vs) # nAs \\<and>\n           f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (Suc n)))", "apply(simp add: subs_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        \\<not> SATAxiom (sequent (f n)) \\<and>\n        (\\<exists>nAs. nforms (f n) = (i, FAtom z P vs) # nAs) \\<and>\n        f (Suc n) \\<in> subs (f n)\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (Suc n)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs)); \\<not> SATAxiom (sequent (f n));\n        f (Suc n) \\<in> subs (f n);\n        nforms (f n) = (i, FAtom z P vs) # nAs\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (Suc n)))", "apply(simp add: subs_def2 Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n nAs.\n       \\<lbrakk>\\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs)); \\<not> SATAxiom (sequent (f n));\n        f (Suc n) \\<in> subsFAtom (atoms (f n)) nAs z P vs;\n        nforms (f n) = (i, FAtom z P vs) # nAs\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (Suc n)))", "apply(simp add: subsFAtom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas atomsPropagate'' = atomsPropagate[rule_format]"], ["", "lemmas atomsPropagate' = atomsPropagate''[simplified atoms_def, simplified]"], ["", "lemma evContainsAtom: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n));\n   EV (contains f (i,FAtom z P vs)) |]\n  ==> ? n . (! m . FAtom z P vs : set (sequent (f (n + m))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>m.\n                            FAtom z P vs \\<in> set (sequent (f (n + m)))", "apply(frule evContainsAtom1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i, FAtom ?z ?P ?vs))\n 3. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs));\n     \\<exists>n. (?z, ?P, ?vs) \\<in> set (fst (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>m.\n                            FAtom z P vs \\<in> set (sequent (f (n + m)))", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (i, FAtom z P vs));\n     \\<exists>n. (z, P, vs) \\<in> set (fst (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         \\<forall>m.\n                            FAtom z P vs \\<in> set (sequent (f (n + m)))", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        (z, P, vs) \\<in> set (fst (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>m.\n                               FAtom z P vs \\<in> set (sequent (f (n + m)))", "apply (rule_tac x=n in exI, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        (z, P, vs) \\<in> set (fst (f n))\\<rbrakk>\n       \\<Longrightarrow> FAtom z P vs \\<in> set (sequent (f (n + m)))", "apply(rule atomsInSequentI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs));\n        (z, P, vs) \\<in> set (fst (f n))\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (n + m)))", "apply (induct_tac m, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs)); (z, P, vs) \\<in> set (fst (f n));\n        (z, P, vs) \\<in> set (fst (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (Suc (n + na))))", "apply(rule atomsPropagate')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs)); (z, P, vs) \\<in> set (fst (f n));\n        (z, P, vs) \\<in> set (fst (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> branch subs (?gamma12 n na) f\n 2. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (i, FAtom z P vs)); (z, P, vs) \\<in> set (fst (f n));\n        (z, P, vs) \\<in> set (fst (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> (z, P, vs) \\<in> set (fst (f (n + na)))", "apply(assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma notEvContainsBothAtoms: \n  \"[| branch subs (pseq fs) f; !n . ~ proofTree (tree subs (f n)) |]\n  ==> ~ EV (contains f (i,FAtom Pos p vs)) |\n      ~ EV (contains f (j,FAtom Neg p vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> \\<not> EV (contains f (i, FAtom Pos p vs)) \\<or>\n                      \\<not> EV (contains f (j, FAtom Neg p vs))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (j, FAtom Neg p vs)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(frule evContainsAtom)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (j, FAtom Neg p vs)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (j, FAtom Neg p vs)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i5, FAtom ?z5 ?P5 ?vs5))\n 3. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (j, FAtom Neg p vs)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n.\n        \\<forall>m.\n           FAtom ?z5 ?P5 ?vs5 \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n));\n     EV (contains f (j, FAtom Neg p vs)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n.\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(thin_tac \"EV (contains f (j, FAtom Neg p vs))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n.\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(frule evContainsAtom)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n.\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n.\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (?i10, FAtom ?z10 ?P10 ?vs10))\n 3. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n. \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)));\n     \\<exists>n.\n        \\<forall>m.\n           FAtom ?z10 ?P10 ?vs10 \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     EV (contains f (i, FAtom Pos p vs));\n     \\<exists>n. \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)));\n     \\<exists>n.\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(thin_tac \"EV (contains f (i, FAtom Pos p vs))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n     \\<exists>n. \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)));\n     \\<exists>n.\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (n + m)))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)));\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (na + m)))\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac x=na in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f; \\<not> False;\n        \\<forall>m. FAtom Neg p vs \\<in> set (sequent (f (n + m)));\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (na + m)));\n        \\<not> proofTree (tree subs (f na))\\<rbrakk>\n       \\<Longrightarrow> False", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (na + m)));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f; \\<not> False;\n        \\<forall>m. FAtom Pos p vs \\<in> set (sequent (f (na + m)));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> False", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); \\<not> False;\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        FAtom Pos p vs \\<in> set (sequent (f (na + n)))\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        FAtom Pos p vs \\<in> set (sequent (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"SATAxiom (sequent (f (n+na)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        FAtom Pos p vs \\<in> set (sequent (f (n + na)));\n        SATAxiom (sequent (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        FAtom Pos p vs \\<in> set (sequent (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> SATAxiom (sequent (f (n + na)))", "apply(force dest: SATAxiomProofTree)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n na.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        FAtom Neg p vs \\<in> set (sequent (f (n + na)));\n        FAtom Pos p vs \\<in> set (sequent (f (n + na)))\\<rbrakk>\n       \\<Longrightarrow> SATAxiom (sequent (f (n + na)))", "apply(force simp add: SATAxiom_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"counterModel: lemmas\""], ["", "lemma counterModelInRepn: \"(counterM f,counterEvalP f) : model\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (counterM f, counterEvalP f) \\<in> model", "apply(simp add: model_def counterM_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas Abs_counterModel_inverse = counterModelInRepn[THEN Abs_model_inverse]"], ["", "lemma inv_obj_obj: \"inv obj (obj n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv obj (obj n) = n", "using inj_obj"], ["proof (prove)\nusing this:\n  inj obj\n\ngoal (1 subgoal):\n 1. inv obj (obj n) = n", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_X_map_counterAssign: \"map X (map (inv obj) (map counterAssign xs)) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map X (map (inv obj) (map counterAssign xs)) = xs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (X \\<circ> (inv obj \\<circ> counterAssign)) xs = xs", "apply(subgoal_tac \"(X \\<circ> (inv obj \\<circ> counterAssign)) = (% x . x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<circ> (inv obj \\<circ> counterAssign) =\n    (\\<lambda>x. x) \\<Longrightarrow>\n    map (X \\<circ> (inv obj \\<circ> counterAssign)) xs = xs\n 2. X \\<circ> (inv obj \\<circ> counterAssign) = (\\<lambda>x. x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<circ> (inv obj \\<circ> counterAssign) = (\\<lambda>x. x)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (X \\<circ> (inv obj \\<circ> counterAssign)) x = x", "apply(case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x = X xa \\<Longrightarrow>\n       (X \\<circ> (inv obj \\<circ> counterAssign)) x = x", "apply(simp add: inv_obj_obj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma objectsCounterModel: \"objects (counterModel f) =  { z . ? i . z = obj i }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. objects (counterModel f) = {z. \\<exists>i. z = obj i}", "apply(simp add: objects_def counterModel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (Rep_model (Abs_model (counterM f, counterEvalP f))) =\n    {z. \\<exists>i. z = obj i}", "apply(simp add: Abs_counterModel_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. counterM f = {z. \\<exists>i. z = obj i}", "apply(simp add: counterM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. range obj = {z. \\<exists>i. z = obj i}", "by force"], ["", "lemma inCounterM: \"counterAssign v : objects (counterModel f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. counterAssign v \\<in> objects (counterModel f)", "apply(induct v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. counterAssign (X xa) \\<in> objects (counterModel f)", "apply(simp add: objectsCounterModel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>i. obj xa = obj i", "by blast"], ["", "lemma counterAssign_eqI[rule_format]: \"x : objects (counterModel f) --> z = X (inv obj x) --> counterAssign z = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> objects (counterModel f) \\<longrightarrow>\n    z = X (inv obj x) \\<longrightarrow> counterAssign z = x", "apply(force simp: objectsCounterModel inj_obj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma evalPCounterModel: \"M = counterModel f ==> evalP M = counterEvalP f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = counterModel f \\<Longrightarrow> evalP M = counterEvalP f", "apply(simp add: evalP_def counterModel_def Abs_counterModel_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"counterModel: all path formula value false - step by step\""], ["", "lemma path_evalF': \n  notes ss = evalPCounterModel counterEvalP_def map_X_map_counterAssign map_map[symmetric]\n  and ss1 = instanceF_def evalF_subF_eq comp_vblcase id_def[symmetric]\n  shows \"[| branch subs (pseq fs) f; \n  !n . ~ proofTree (tree subs (f n))\n  |] ==> (? i . EV (contains f (i,A))) \\<longrightarrow> ~(evalF (counterModel f) counterAssign A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>i. EV (contains f (i, A))) \\<longrightarrow>\n                      \\<not> evalF (counterModel f) counterAssign A", "apply (rule_tac strong_formula_induct, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size A \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f (i, A))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign A", "apply(rule formula_signs_cases)\n       \\<comment> \\<open>atom\\<close>"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>A p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FAtom Pos p vs) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAtom Pos p vs))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAtom Pos p vs)\n 2. \\<And>A p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FAtom Neg p vs) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAtom Neg p vs))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAtom Neg p vs)\n 3. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Pos f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Pos f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Pos f1 f2)\n 4. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 5. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 6. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(simp add: ss del: map_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FAtom Neg p vs) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAtom Neg p vs))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAtom Neg p vs)\n 2. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Pos f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Pos f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Pos f1 f2)\n 3. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 4. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 5. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(rule, rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAtom Neg p vs) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>i. EV (contains f (i, FAtom Neg p vs))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAtom Neg p vs)\n 2. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Pos f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Pos f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Pos f1 f2)\n 3. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 4. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 5. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(simp add: ss del: map_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p vs.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<exists>i. EV (contains f (i, FAtom Neg p vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            \\<not> EV (contains f (i, FAtom Pos p vs))\n 2. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Pos f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Pos f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Pos f1 f2)\n 3. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 4. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 5. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(force dest: notEvContainsBothAtoms)\n     \\<comment> \\<open>conj\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Pos f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Pos f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Pos f1 f2)\n 2. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 3. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 4. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(force dest: evContainsConj)\n     \\<comment> \\<open>disj\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A f1 f2.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B\n                             < size (FConj Neg f1 f2) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FConj Neg f1 f2))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FConj Neg f1 f2)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 3. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(force dest: evContainsDisj)\n   \\<comment> \\<open>all\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Pos f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Pos f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(rule, rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>i. EV (contains f (i, FAll Pos f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        EV (contains f (i, FAll Pos f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(drule_tac evContainsAll)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> branch subs (?gamma77 A f1 i) f\n 2. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 3. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 4. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 3. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Pos f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(drule_tac x=\"(instanceF v f1)\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (0, instanceF v f1));\n        size (instanceF v f1) < size (FAll Pos f1) \\<longrightarrow>\n        (\\<exists>i. EV (contains f (i, instanceF v f1))) \\<longrightarrow>\n        \\<not> evalF (counterModel f) counterAssign\n                (instanceF v f1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(erule impE, force simp: size_instance)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (0, instanceF v f1));\n        \\<not> evalF (counterModel f) counterAssign\n                (instanceF v f1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Pos f1)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1 v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f (0, instanceF v f1));\n        \\<not> evalF (counterModel f) counterAssign\n                (instanceF v f1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>objects (counterModel f).\n                            \\<not> evalF (counterModel f)\n                                    (vblcase x counterAssign) f1\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(simp add: ss1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1 v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f\n             (0, subF\n                  (\\<lambda>va.\n                      case va of zeroX \\<Rightarrow> v\n                      | nextX x \\<Rightarrow> id x)\n                  f1));\n        \\<not> evalF (counterModel f)\n                (vblcase (counterAssign v) counterAssign) f1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>objects (counterModel f).\n                            \\<not> evalF (counterModel f)\n                                    (vblcase x counterAssign) f1\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(rule_tac x=\"counterAssign v\" in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f1 v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f\n             (0, subF\n                  (\\<lambda>va.\n                      case va of zeroX \\<Rightarrow> v\n                      | nextX x \\<Rightarrow> id x)\n                  f1));\n        \\<not> evalF (counterModel f)\n                (vblcase (counterAssign v) counterAssign) f1\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase (counterAssign v) counterAssign)\n                                 f1\n 2. \\<And>f1 v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f\n             (0, subF\n                  (\\<lambda>va.\n                      case va of zeroX \\<Rightarrow> v\n                      | nextX x \\<Rightarrow> id x)\n                  f1));\n        \\<not> evalF (counterModel f)\n                (vblcase (counterAssign v) counterAssign) f1\\<rbrakk>\n       \\<Longrightarrow> counterAssign v \\<in> objects (counterModel f)\n 3. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f1 v.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        EV (contains f\n             (0, subF\n                  (\\<lambda>va.\n                      case va of zeroX \\<Rightarrow> v\n                      | nextX x \\<Rightarrow> id x)\n                  f1));\n        \\<not> evalF (counterModel f)\n                (vblcase (counterAssign v) counterAssign) f1\\<rbrakk>\n       \\<Longrightarrow> counterAssign v \\<in> objects (counterModel f)\n 2. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(simp add: inCounterM) \n  \\<comment> \\<open>ex\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>B.\n                             size B < size (FAll Neg f1) \\<longrightarrow>\n                             (\\<exists>i.\n                                 EV (contains f (i, B))) \\<longrightarrow>\n                             \\<not> evalF (counterModel f) counterAssign\n                                     B) \\<longrightarrow>\n                         (\\<exists>i.\n                             EV (contains f\n                                  (i, FAll Neg f1))) \\<longrightarrow>\n                         \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(rule, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<exists>i. EV (contains f (i, FAll Neg f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        EV (contains f (i, FAll Neg f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply(drule_tac evContainsExval)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> branch subs (pseq (?fs101 A f1 i)) f\n 2. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 3. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n. \\<not> proofTree (tree subs (f n))\n 2. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A f1 i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < size (FAll Neg f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign\n                                 (FAll Neg f1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < Suc (size f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>objects (counterModel f).\n                            \\<not> evalF (counterModel f)\n                                    (vblcase x counterAssign) f1", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < Suc (size f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1));\n        x \\<in> objects (counterModel f)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(simp add: objectsCounterModel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < Suc (size f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1));\n        \\<exists>i. x = obj i\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < Suc (size f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        \\<forall>v. EV (contains f (0, instanceF v f1)); x = obj i\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(drule_tac x=\"X i\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n));\n        \\<forall>B.\n           size B < Suc (size f1) \\<longrightarrow>\n           (\\<exists>i. EV (contains f (i, B))) \\<longrightarrow>\n           \\<not> evalF (counterModel f) counterAssign B;\n        x = obj i; EV (contains f (0, instanceF (X i) f1))\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(drule_tac x=\"(instanceF (X i) f1)\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); x = obj i;\n        EV (contains f (0, instanceF (X i) f1));\n        size (instanceF (X i) f1) < Suc (size f1) \\<longrightarrow>\n        (\\<exists>ia.\n            EV (contains f (ia, instanceF (X i) f1))) \\<longrightarrow>\n        \\<not> evalF (counterModel f) counterAssign\n                (instanceF (X i) f1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(erule impE, force simp: size_instance)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 x i.\n       \\<lbrakk>branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n)); x = obj i;\n        EV (contains f (0, instanceF (X i) f1));\n        \\<not> evalF (counterModel f) counterAssign\n                (instanceF (X i) f1)\\<rbrakk>\n       \\<Longrightarrow> \\<not> evalF (counterModel f)\n                                 (vblcase x counterAssign) f1", "apply(simp add: ss1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas path_evalF'' = mp[OF path_evalF']"], ["", "subsection \"adequacy\""], ["", "lemma counterAssignModelAssign: \"counterAssign : modelAssigns (counterModel gamma)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. counterAssign \\<in> modelAssigns (counterModel gamma)", "apply (simp add: modelAssigns_def, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range counterAssign \\<Longrightarrow>\n       x \\<in> objects (counterModel gamma)", "apply (erule rangeE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       x = counterAssign xa \\<Longrightarrow>\n       counterAssign xa \\<in> objects (counterModel gamma)", "apply(rule inCounterM)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma branch_contains_initially: \"branch subs (pseq fs) f \\<Longrightarrow> x : set fs \\<Longrightarrow> contains f (0,x) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f; x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> contains f (0, x) 0", "apply(simp add: contains_def branch0 pseq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_evalF: \n  \"[| branch subs (pseq fs) f;\n  \\<forall>n. \\<not> proofTree (tree subs (f n)); \n  x \\<in> set fs\n  |] ==> \\<not> evalF (counterModel f) counterAssign x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> \\<not> evalF (counterModel f) counterAssign x", "apply (rule path_evalF'', assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i. EV (contains f (i, x))", "apply(rule_tac x=0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> EV (contains f (0, x))", "apply(simp add: EV_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. contains f (0, x) n", "apply(rule_tac x=0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>branch subs (pseq fs) f;\n     \\<forall>n. \\<not> proofTree (tree subs (f n)); x \\<in> set fs\\<rbrakk>\n    \\<Longrightarrow> contains f (0, x) 0", "apply(simp add: branch_contains_initially)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma validProofTree: \"~proofTree (tree subs (pseq fs)) ==> ~(validS fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<not> validS fs", "apply(simp add: validS_def evalS_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>M.\n       \\<exists>phi\\<in>modelAssigns M.\n          \\<forall>x\\<in>set fs. \\<not> evalF M phi x", "apply(subgoal_tac \"\\<exists>f. branch subs (pseq fs) f \\<and> (\\<forall>n. \\<not> proofTree (tree subs (f n)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n     \\<exists>f.\n        branch subs (pseq fs) f \\<and>\n        (\\<forall>n. \\<not> proofTree (tree subs (f n)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>M.\n                         \\<exists>phi\\<in>modelAssigns M.\n                            \\<forall>x\\<in>set fs. \\<not> evalF M phi x\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(elim exE conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M.\n                            \\<exists>phi\\<in>modelAssigns M.\n                               \\<forall>x\\<in>set fs. \\<not> evalF M phi x\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(rule_tac x=\"counterModel f\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>phi\\<in>modelAssigns (counterModel f).\n                            \\<forall>x\\<in>set fs.\n                               \\<not> evalF (counterModel f) phi x\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(rule_tac x=counterAssign in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set fs.\n                            \\<not> evalF (counterModel f) counterAssign x\n 2. \\<And>f.\n       \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> counterAssign \\<in> modelAssigns (counterModel f)\n 3. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(force dest!: path_evalF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<not> proofTree (tree subs (pseq fs));\n        branch subs (pseq fs) f;\n        \\<forall>n. \\<not> proofTree (tree subs (f n))\\<rbrakk>\n       \\<Longrightarrow> counterAssign \\<in> modelAssigns (counterModel f)\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(rule counterAssignModelAssign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<exists>f.\n       branch subs (pseq fs) f \\<and>\n       (\\<forall>n. \\<not> proofTree (tree subs (f n)))", "apply(rule failingBranchExistence)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    inherited subs proofTree\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow> fans subs\n 3. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<not> proofTree (tree subs (pseq fs))", "apply(rule inheritedProofTree)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow> fans subs\n 2. \\<not> proofTree (tree subs (pseq fs)) \\<Longrightarrow>\n    \\<not> proofTree (tree subs (pseq fs))", "apply (rule fansSubs, assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma adequacy[simplified sequent_pseq]: \"validS fs ==> (sequent (pseq fs)) : deductions CutFreePC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validS fs \\<Longrightarrow> sequent (pseq fs) \\<in> deductions CutFreePC", "apply(rule proofTreeDeductionD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. validS fs \\<Longrightarrow> proofTree (tree subs (pseq fs))", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>validS fs; \\<not> proofTree (tree subs (pseq fs))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(force dest!: validProofTree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}