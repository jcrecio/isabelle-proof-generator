{"file_name": "/home/qj213/afp-2021-10-22/thys/Completeness/PermutationLemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Completeness", "problem_names": ["lemma perm_count: \"A <~~> B \\<Longrightarrow> (\\<forall> x. count x A = count x B)\"", "lemma count_0: \"(\\<forall>x. count x B = 0) = (B = [])\"", "lemma count_Suc: \"count a B = Suc m \\<Longrightarrow> a : set B\"", "lemma count_append: \"count a (xs@ys) = count a xs + count a ys\"", "lemma count_perm: \"!! B. (\\<forall> x. count x A = count x B) \\<Longrightarrow> A <~~> B\"", "lemma perm_count_conv: \"A <~~> B = (\\<forall> x. count x A = count x B)\"", "lemma remdups_append: \"y : set ys --> remdups (ws@y#ys) = remdups (ws@ys)\"", "lemma perm_contr': assumes perm[rule_format]: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr'[rule_format]: \"! x xs. P(x#x#xs) = P (x#xs)\" \n  shows \"! xs. length xs = n --> (P xs = P (remdups xs))\"", "lemma perm_contr: assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr': \"! x xs. P(x#x#xs) = P (x#xs)\" \n  shows \"(P xs = P (remdups xs))\"", "lemma rem: \"x ~: set (rem x xs)\"", "lemma length_rem: \"length (rem x xs) <= length xs\"", "lemma rem_notin: \"x ~: set xs ==> rem x xs = xs\"", "lemma perm_weak_filter': assumes perm[rule_format]: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and weak[rule_format]: \"! x xs. P xs --> P (x#xs)\"\n  shows \"! ys. P (ys@filter Q xs) --> P (ys@xs)\"", "lemma perm_weak_filter: assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and weak: \"! x xs. P xs --> P (x#xs)\"\n  shows \"P (filter Q xs) ==> P xs\"", "lemma perm_weak_contr_mono: \n  assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr: \"! x xs. P (x#x#xs) --> P (x#xs)\"\n  and weak: \"! x xs. P xs --> P (x#xs)\"\n  and xy: \"set x <= set y\"\n  and Px : \"P x\"\n  shows \"P y\""], "translations": [["", "lemma perm_count: \"A <~~> B \\<Longrightarrow> (\\<forall> x. count x A = count x B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A <~~> B \\<Longrightarrow>\n    \\<forall>x. PermutationLemmas.count x A = PermutationLemmas.count x B", "by(induct set: perm) auto"], ["", "lemma count_0: \"(\\<forall>x. count x B = 0) = (B = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. PermutationLemmas.count x B = 0) = (B = [])", "by(induct B) auto"], ["", "lemma count_Suc: \"count a B = Suc m \\<Longrightarrow> a : set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PermutationLemmas.count a B = Suc m \\<Longrightarrow> a \\<in> set B", "apply(induct B)"], ["proof (prove)\ngoal (2 subgoals):\n 1. PermutationLemmas.count a [] = Suc m \\<Longrightarrow> a \\<in> set []\n 2. \\<And>aa B.\n       \\<lbrakk>PermutationLemmas.count a B = Suc m \\<Longrightarrow>\n                a \\<in> set B;\n        PermutationLemmas.count a (aa # B) = Suc m\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set (aa # B)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa B.\n       \\<lbrakk>PermutationLemmas.count a B = Suc m \\<Longrightarrow> False;\n        (if a = aa then 1 else 0) + PermutationLemmas.count a B = Suc m;\n        a \\<notin> set B\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply(case_tac \"a = aa\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa B.\n       \\<lbrakk>PermutationLemmas.count a B = Suc m \\<Longrightarrow> False;\n        (if a = aa then 1 else 0) + PermutationLemmas.count a B = Suc m;\n        a \\<notin> set B; a = aa\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>aa B.\n       \\<lbrakk>PermutationLemmas.count a B = Suc m \\<Longrightarrow> False;\n        (if a = aa then 1 else 0) + PermutationLemmas.count a B = Suc m;\n        a \\<notin> set B; a \\<noteq> aa\\<rbrakk>\n       \\<Longrightarrow> a = aa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma count_append: \"count a (xs@ys) = count a xs + count a ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PermutationLemmas.count a (xs @ ys) =\n    PermutationLemmas.count a xs + PermutationLemmas.count a ys", "by(induct xs) auto"], ["", "lemma count_perm: \"!! B. (\\<forall> x. count x A = count x B) \\<Longrightarrow> A <~~> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<forall>x.\n          PermutationLemmas.count x A =\n          PermutationLemmas.count x B \\<Longrightarrow>\n       A <~~> B", "apply(induct A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<forall>x.\n          PermutationLemmas.count x [] =\n          PermutationLemmas.count x B \\<Longrightarrow>\n       [] <~~> B\n 2. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "apply(simp add: count_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "fix a list B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "assume a: \"\\<And>B. \\<forall>x. count x list = count x B \\<Longrightarrow> list <~~> B\"\n    and b: \"\\<forall>x. count x (a # list) = count x B\""], ["proof (state)\nthis:\n  \\<forall>x.\n     PermutationLemmas.count x list =\n     PermutationLemmas.count x ?B \\<Longrightarrow>\n  list <~~> ?B\n  \\<forall>x.\n     PermutationLemmas.count x (a # list) = PermutationLemmas.count x B\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "from b"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     PermutationLemmas.count x (a # list) = PermutationLemmas.count x B", "have \"a : set B\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     PermutationLemmas.count x (a # list) = PermutationLemmas.count x B\n\ngoal (1 subgoal):\n 1. a \\<in> set B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (if x = a then 1 else 0) + PermutationLemmas.count x list =\n       PermutationLemmas.count x B \\<Longrightarrow>\n    a \\<in> set B", "apply (drule_tac x=a in spec, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (PermutationLemmas.count a list) =\n    PermutationLemmas.count a B \\<Longrightarrow>\n    a \\<in> set B", "apply(metis count_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<in> set B\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "from split_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. B = ys @ a # zs", "obtain xs ys where B: \"B = xs@a#ys\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. B = ys @ a # zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        B = xs @ a # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B = xs @ a # ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "let ?B' = \"xs@ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "from b"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     PermutationLemmas.count x (a # list) = PermutationLemmas.count x B", "have \"\\<forall>x. count x list = count x ?B'\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     PermutationLemmas.count x (a # list) = PermutationLemmas.count x B\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       PermutationLemmas.count x list = PermutationLemmas.count x (xs @ ys)", "by(simp add: count_append B)"], ["proof (state)\nthis:\n  \\<forall>x.\n     PermutationLemmas.count x list = PermutationLemmas.count x (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "from a[OF this]"], ["proof (chain)\npicking this:\n  list <~~> xs @ ys", "have c: \"list <~~> xs@ys\""], ["proof (prove)\nusing this:\n  list <~~> xs @ ys\n\ngoal (1 subgoal):\n 1. list <~~> xs @ ys", "."], ["proof (state)\nthis:\n  list <~~> xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "hence \"a#list <~~> a#(xs@ys)\""], ["proof (prove)\nusing this:\n  list <~~> xs @ ys\n\ngoal (1 subgoal):\n 1. a # list <~~> a # xs @ ys", "by rule"], ["proof (state)\nthis:\n  a # list <~~> a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "also"], ["proof (state)\nthis:\n  a # list <~~> a # xs @ ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "have \"a#(xs@ys) <~~> xs@a#ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # xs @ ys <~~> xs @ a # ys", "by(rule perm_append_Cons)"], ["proof (state)\nthis:\n  a # xs @ ys <~~> xs @ a # ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "also (perm.trans)"], ["proof (state)\nthis:\n  a # xs @ ys <~~> xs @ a # ys\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "note B[symmetric]"], ["proof (state)\nthis:\n  xs @ a # ys = B\n\ngoal (1 subgoal):\n 1. \\<And>a A B.\n       \\<lbrakk>\\<And>B.\n                   \\<forall>x.\n                      PermutationLemmas.count x A =\n                      PermutationLemmas.count x B \\<Longrightarrow>\n                   A <~~> B;\n        \\<forall>x.\n           PermutationLemmas.count x (a # A) =\n           PermutationLemmas.count x B\\<rbrakk>\n       \\<Longrightarrow> a # A <~~> B", "finally"], ["proof (chain)\npicking this:\n  a # list <~~> B", "show \"a # list <~~> B\""], ["proof (prove)\nusing this:\n  a # list <~~> B\n\ngoal (1 subgoal):\n 1. a # list <~~> B", "."], ["proof (state)\nthis:\n  a # list <~~> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_count_conv: \"A <~~> B = (\\<forall> x. count x A = count x B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A <~~> B) =\n    (\\<forall>x. PermutationLemmas.count x A = PermutationLemmas.count x B)", "apply(blast intro!: perm_count count_perm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Properties closed under Perm and Contr hold for x iff hold for remdups x\""], ["", "lemma remdups_append: \"y : set ys --> remdups (ws@y#ys) = remdups (ws@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set ys \\<longrightarrow>\n    remdups (ws @ y # ys) = remdups (ws @ ys)", "apply (induct ws, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ws.\n       y \\<in> set ys \\<longrightarrow>\n       remdups (ws @ y # ys) = remdups (ws @ ys) \\<Longrightarrow>\n       y \\<in> set ys \\<longrightarrow>\n       remdups ((a # ws) @ y # ys) = remdups ((a # ws) @ ys)", "apply (case_tac \"y = a\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma perm_contr': assumes perm[rule_format]: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr'[rule_format]: \"! x xs. P(x#x#xs) = P (x#xs)\" \n  shows \"! xs. length xs = n --> (P xs = P (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. length xs = n \\<longrightarrow> P xs = P (remdups xs)", "apply(induct n rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>m<n.\n          \\<forall>xs.\n             length xs = m \\<longrightarrow>\n             P xs = P (remdups xs) \\<Longrightarrow>\n       \\<forall>xs. length xs = n \\<longrightarrow> P xs = P (remdups xs)", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<forall>m<length xs.\n          \\<forall>xs.\n             length xs = m \\<longrightarrow>\n             P xs = P (remdups xs) \\<Longrightarrow>\n       P xs = P (remdups xs)", "fix xs :: \"'a list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<forall>m<length xs.\n          \\<forall>xs.\n             length xs = m \\<longrightarrow>\n             P xs = P (remdups xs) \\<Longrightarrow>\n       P xs = P (remdups xs)", "assume a[rule_format]: \"\\<forall>m<length xs. \\<forall>ys. length ys = m \\<longrightarrow> P ys = P (remdups ys)\""], ["proof (state)\nthis:\n  \\<lbrakk>?m < length xs; length ?ys = ?m\\<rbrakk>\n  \\<Longrightarrow> P ?ys = P (remdups ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<forall>m<length xs.\n          \\<forall>xs.\n             length xs = m \\<longrightarrow>\n             P xs = P (remdups xs) \\<Longrightarrow>\n       P xs = P (remdups xs)", "show \"P xs = P (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs = P (remdups xs)", "proof (cases \"distinct xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct xs \\<Longrightarrow> P xs = P (remdups xs)\n 2. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "case True"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (2 subgoals):\n 1. distinct xs \\<Longrightarrow> P xs = P (remdups xs)\n 2. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. P xs = P (remdups xs)", "by(simp add:distinct_remdups_id)"], ["proof (state)\nthis:\n  P xs = P (remdups xs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "case False"], ["proof (state)\nthis:\n  \\<not> distinct xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "from not_distinct_decomp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xsa ys zs y. xs = xsa @ [y] @ ys @ [y] @ zs", "obtain ws ys zs y where xs: \"xs = ws@[y]@ys@[y]@zs\""], ["proof (prove)\nusing this:\n  \\<exists>xsa ys zs y. xs = xsa @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>ws y ys zs.\n        xs = ws @ [y] @ ys @ [y] @ zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  xs = ws @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"P xs = P (ws@[y]@ys@[y]@zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs = P (ws @ [y] @ ys @ [y] @ zs)", "by (simp add: xs)"], ["proof (state)\nthis:\n  P xs = P (ws @ [y] @ ys @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "also"], ["proof (state)\nthis:\n  P xs = P (ws @ [y] @ ys @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"... = P ([y,y]@ws@ys@zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ws @ [y] @ ys @ [y] @ zs) = P ([y, y] @ ws @ ys @ zs)", "apply(rule perm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ws @ [y] @ ys @ [y] @ zs <~~> [y, y] @ ws @ ys @ zs", "apply(rule iffD2[OF perm_count_conv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       PermutationLemmas.count x (ws @ [y] @ ys @ [y] @ zs) =\n       PermutationLemmas.count x ([y, y] @ ws @ ys @ zs)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PermutationLemmas.count x (ws @ [y] @ ys @ [y] @ zs) =\n       PermutationLemmas.count x ([y, y] @ ws @ ys @ zs)", "apply(simp add: count_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (ws @ [y] @ ys @ [y] @ zs) = P ([y, y] @ ws @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "also"], ["proof (state)\nthis:\n  P (ws @ [y] @ ys @ [y] @ zs) = P ([y, y] @ ws @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"... = P ([y]@ws@ys@zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ([y, y] @ ws @ ys @ zs) = P ([y] @ ws @ ys @ zs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (y # y # ws @ ys @ zs) = P (y # ws @ ys @ zs)", "apply(rule contr')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P ([y, y] @ ws @ ys @ zs) = P ([y] @ ws @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "also"], ["proof (state)\nthis:\n  P ([y, y] @ ws @ ys @ zs) = P ([y] @ ws @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"... = P (ws@ys@[y]@zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ([y] @ ws @ ys @ zs) = P (ws @ ys @ [y] @ zs)", "apply(rule perm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [y] @ ws @ ys @ zs <~~> ws @ ys @ [y] @ zs", "apply(rule iffD2[OF perm_count_conv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       PermutationLemmas.count x ([y] @ ws @ ys @ zs) =\n       PermutationLemmas.count x (ws @ ys @ [y] @ zs)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PermutationLemmas.count x ([y] @ ws @ ys @ zs) =\n       PermutationLemmas.count x (ws @ ys @ [y] @ zs)", "apply(simp add: count_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P ([y] @ ws @ ys @ zs) = P (ws @ ys @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "also"], ["proof (state)\nthis:\n  P ([y] @ ws @ ys @ zs) = P (ws @ ys @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"... = P (remdups (ws@ys@[y]@zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (ws @ ys @ [y] @ zs) = P (remdups (ws @ ys @ [y] @ zs))", "apply(rule a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?m < length xs\n 2. length (ws @ ys @ [y] @ zs) = ?m", "by(auto simp: xs)"], ["proof (state)\nthis:\n  P (ws @ ys @ [y] @ zs) = P (remdups (ws @ ys @ [y] @ zs))\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "also"], ["proof (state)\nthis:\n  P (ws @ ys @ [y] @ zs) = P (remdups (ws @ ys @ [y] @ zs))\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "have \"(remdups (ws@ys@[y]@zs)) = (remdups xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (ws @ ys @ [y] @ zs) = remdups xs", "apply(simp add: xs remdups_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  remdups (ws @ ys @ [y] @ zs) = remdups xs\n\ngoal (1 subgoal):\n 1. \\<not> distinct xs \\<Longrightarrow> P xs = P (remdups xs)", "finally"], ["proof (chain)\npicking this:\n  P xs = P (remdups xs)", "show \"P xs = P (remdups xs)\""], ["proof (prove)\nusing this:\n  P xs = P (remdups xs)\n\ngoal (1 subgoal):\n 1. P xs = P (remdups xs)", "."], ["proof (state)\nthis:\n  P xs = P (remdups xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P xs = P (remdups xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_contr: assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr': \"! x xs. P(x#x#xs) = P (x#xs)\" \n  shows \"(P xs = P (remdups xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs = P (remdups xs)", "apply(rule perm_contr'[OF perm contr', rule_format])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = ?n", "by force"], ["", "subsection \"List properties closed under Perm, Weak and Contr are monotonic in the set of the list\""], ["", "definition\n  rem :: \"'a => 'a list => 'a list\" where\n  \"rem x xs = filter (%y. y ~= x) xs\""], ["", "lemma rem: \"x ~: set (rem x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (rem x xs)", "by(simp add: rem_def)"], ["", "lemma length_rem: \"length (rem x xs) <= length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem x xs) \\<le> length xs", "by(simp add: rem_def)"], ["", "lemma rem_notin: \"x ~: set xs ==> rem x xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> rem x xs = xs", "apply(simp add: rem_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow>\n    filter (\\<lambda>y. y \\<noteq> x) xs = xs", "apply(rule filter_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow>\n    \\<forall>xa\\<in>set xs. xa \\<noteq> x", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma perm_weak_filter': assumes perm[rule_format]: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and weak[rule_format]: \"! x xs. P xs --> P (x#xs)\"\n  shows \"! ys. P (ys@filter Q xs) --> P (ys@xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ys. P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs)", "apply (induct xs, simp, rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<forall>ys.\n          P (ys @ filter Q xs) \\<longrightarrow>\n          P (ys @ xs) \\<Longrightarrow>\n       P (ys @ filter Q (a # xs)) \\<longrightarrow> P (ys @ a # xs)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ filter Q (a # xs))\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ (if Q a then a # filter Q xs else filter Q xs))\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply (case_tac \"Q a\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ a # filter Q xs); Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ (if Q a then a # filter Q xs else filter Q xs));\n        \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(drule_tac x=\"ys@[a]\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ a # filter Q xs); Q a;\n        P ((ys @ [a]) @ filter Q xs) \\<longrightarrow>\n        P ((ys @ [a]) @ xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ (if Q a then a # filter Q xs else filter Q xs));\n        \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ (if Q a then a # filter Q xs else filter Q xs));\n        \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<forall>ys.\n                   P (ys @ filter Q xs) \\<longrightarrow> P (ys @ xs);\n        P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(drule_tac x=\"ys@[a]\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a;\n        P ((ys @ [a]) @ filter Q xs) \\<longrightarrow>\n        P ((ys @ [a]) @ xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a;\n        P (ys @ a # filter Q xs) \\<longrightarrow> P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # filter Q xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(subgoal_tac \"(ys @ a # filter Q xs) <~~> a#ys@filter Q xs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a;\n        ys @ a # filter Q xs <~~> a # ys @ filter Q xs\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # filter Q xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> ys @ a # filter Q xs <~~> a # ys @ filter Q xs\n 3. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(simp add: perm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a;\n        ys @ a # filter Q xs <~~> a # ys @ filter Q xs\\<rbrakk>\n       \\<Longrightarrow> P (a # ys @ filter Q xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> ys @ a # filter Q xs <~~> a # ys @ filter Q xs\n 3. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(rule weak)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a;\n        ys @ a # filter Q xs <~~> a # ys @ filter Q xs\\<rbrakk>\n       \\<Longrightarrow> P (ys @ filter Q xs)\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> ys @ a # filter Q xs <~~> a # ys @ filter Q xs\n 3. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> ys @ a # filter Q xs <~~> a # ys @ filter Q xs\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(rule perm_sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a\\<rbrakk>\n       \\<Longrightarrow> a # ys @ filter Q xs <~~> ys @ a # filter Q xs\n 2. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "apply(rule perm_append_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>P (ys @ filter Q xs); \\<not> Q a; P (ys @ a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (ys @ a # xs)", "."], ["", "lemma perm_weak_filter: assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and weak: \"! x xs. P xs --> P (x#xs)\"\n  shows \"P (filter Q xs) ==> P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (filter Q xs) \\<Longrightarrow> P xs", "using perm_weak_filter'[OF perm weak, rule_format, of \"[]\", simplified]"], ["proof (prove)\nusing this:\n  P (filter ?Q ?xs) \\<Longrightarrow> P ?xs\n\ngoal (1 subgoal):\n 1. P (filter Q xs) \\<Longrightarrow> P xs", "by blast\n\n  \\<comment> \\<open>right, now in a position to prove that in presence of perm, contr and weak, set x leq set y and x : ded implies y : ded\\<close>"], ["", "lemma perm_weak_contr_mono: \n  assumes perm: \"! xs ys. xs <~~> ys --> (P xs = P ys)\"\n  and contr: \"! x xs. P (x#x#xs) --> P (x#xs)\"\n  and weak: \"! x xs. P xs --> P (x#xs)\"\n  and xy: \"set x <= set y\"\n  and Px : \"P x\"\n  shows \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P y", "from contr weak"], ["proof (chain)\npicking this:\n  \\<forall>x xs. P (x # x # xs) \\<longrightarrow> P (x # xs)\n  \\<forall>x xs. P xs \\<longrightarrow> P (x # xs)", "have contr': \"! x xs. P(x#x#xs) = P (x#xs)\""], ["proof (prove)\nusing this:\n  \\<forall>x xs. P (x # x # xs) \\<longrightarrow> P (x # xs)\n  \\<forall>x xs. P xs \\<longrightarrow> P (x # xs)\n\ngoal (1 subgoal):\n 1. \\<forall>x xs. P (x # x # xs) = P (x # xs)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x xs. P (x # x # xs) = P (x # xs)\n\ngoal (1 subgoal):\n 1. P y", "define y' where \"y' = filter (% z. z : set x) y\""], ["proof (state)\nthis:\n  y' = filter (\\<lambda>z. z \\<in> set x) y\n\ngoal (1 subgoal):\n 1. P y", "from xy"], ["proof (chain)\npicking this:\n  set x \\<subseteq> set y", "have \"set x = set y'\""], ["proof (prove)\nusing this:\n  set x \\<subseteq> set y\n\ngoal (1 subgoal):\n 1. set x = set y'", "apply(simp add: y'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set x \\<subseteq> set y \\<Longrightarrow>\n    set x = {xa \\<in> set y. xa \\<in> set x}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set x = set y'\n\ngoal (1 subgoal):\n 1. P y", "hence rxry': \"remdups x <~~> remdups y'\""], ["proof (prove)\nusing this:\n  set x = set y'\n\ngoal (1 subgoal):\n 1. remdups x <~~> remdups y'", "by(simp add: perm_remdups_iff_eq_set)"], ["proof (state)\nthis:\n  remdups x <~~> remdups y'\n\ngoal (1 subgoal):\n 1. P y", "from Px perm_contr[OF perm contr']"], ["proof (chain)\npicking this:\n  P x\n  P ?xs = P (remdups ?xs)", "have Prx: \"P (remdups x)\""], ["proof (prove)\nusing this:\n  P x\n  P ?xs = P (remdups ?xs)\n\ngoal (1 subgoal):\n 1. P (remdups x)", "by simp"], ["proof (state)\nthis:\n  P (remdups x)\n\ngoal (1 subgoal):\n 1. P y", "with rxry'"], ["proof (chain)\npicking this:\n  remdups x <~~> remdups y'\n  P (remdups x)", "have \"P (remdups y')\""], ["proof (prove)\nusing this:\n  remdups x <~~> remdups y'\n  P (remdups x)\n\ngoal (1 subgoal):\n 1. P (remdups y')", "by(simp add: perm)"], ["proof (state)\nthis:\n  P (remdups y')\n\ngoal (1 subgoal):\n 1. P y", "with perm_contr[OF perm contr']"], ["proof (chain)\npicking this:\n  P ?xs = P (remdups ?xs)\n  P (remdups y')", "have \"P y'\""], ["proof (prove)\nusing this:\n  P ?xs = P (remdups ?xs)\n  P (remdups y')\n\ngoal (1 subgoal):\n 1. P y'", "by simp"], ["proof (state)\nthis:\n  P y'\n\ngoal (1 subgoal):\n 1. P y", "thus \"P y\""], ["proof (prove)\nusing this:\n  P y'\n\ngoal (1 subgoal):\n 1. P y", "apply(simp add: y'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (filter (\\<lambda>z. z \\<in> set x) y) \\<Longrightarrow> P y", "apply(rule perm_weak_filter[OF perm weak])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (filter (\\<lambda>z. z \\<in> set x) y) \\<Longrightarrow>\n    P (filter ?Q1 y)", "."], ["proof (state)\nthis:\n  P y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* No, not used\nsubsection \"Following used in Soundness\"\n\nprimrec multiset_of_list :: \"'a list \\<Rightarrow> 'a multiset\"\nwhere\n  \"multiset_of_list [] = {#}\"\n| \"multiset_of_list (x#xs) = {#x#} + multiset_of_list xs\"\n\nlemma count_count[symmetric]: \"count x A = Multiset.count (multiset_of_list A) x\"\n  by (induct A) simp_all\n\nlemma perm_multiset: \"A <~~> B = (multiset_of_list A = multiset_of_list B)\"\n  apply(simp add: perm_count_conv)\n  apply(simp add: multiset_eq_iff)\n  apply(simp add: count_count)\n  done\n\nlemma set_of_multiset_of_list: \"set_of (multiset_of_list A) = set A\"\n  by (induct A) auto\n*)"], ["", "end"]]}