{"file_name": "/home/qj213/afp-2021-10-22/thys/Huffman/Huffman.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Huffman", "problem_names": ["lemma finite_alphabet[simp]:\n\"finite (alphabet t)\"", "lemma exists_in_alphabet:\n\"\\<exists>a. a \\<in> alphabet t\"", "lemma tree_induct_consistent[consumes 1, case_names base step\\<^sub>1 step\\<^sub>2 step\\<^sub>3]:\n\"\\<lbrakk>consistent t;\n  \\<And>w\\<^sub>b b a. P (Leaf w\\<^sub>b b) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk> \\<Longrightarrow>\n P t a\"", "lemma depth_le_height:\n\"depth t a \\<le> height t\"", "lemma exists_at_height:\n\"consistent t \\<Longrightarrow> \\<exists>a \\<in> alphabet t. depth t a = height t\"", "lemma depth_max_heightE_left[elim!]:\n\"\\<lbrakk>depth t\\<^sub>1 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n  \\<lbrakk>depth t\\<^sub>1 a = height t\\<^sub>1; height t\\<^sub>1 \\<ge> height t\\<^sub>2\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow>\n P\"", "lemma depth_max_heightE_right[elim!]:\n\"\\<lbrakk>depth t\\<^sub>2 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n  \\<lbrakk>depth t\\<^sub>2 a = height t\\<^sub>2; height t\\<^sub>2 \\<ge> height t\\<^sub>1\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow>\n P\"", "lemma height_gt_0_alphabet_eq_imp_height_gt_0:\nassumes \"height t > 0\" \"consistent t\" \"alphabet t = alphabet u\"\nshows \"height u > 0\"", "lemma notin_alphabet_imp_freq_0[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> freq t a = 0\"", "lemma notin_alphabet\\<^sub>F_imp_freq\\<^sub>F_0[simp]:\n\"a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow> freq\\<^sub>F ts a = 0\"", "lemma freq_0_right[simp]:\n\"\\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow> freq t\\<^sub>2 a = 0\"", "lemma freq_0_left[simp]:\n\"\\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}; a \\<in> alphabet t\\<^sub>2\\<rbrakk> \\<Longrightarrow> freq t\\<^sub>1 a = 0\"", "lemma height\\<^sub>F_0_imp_Leaf_freq\\<^sub>F_in_set:\n\"\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0; a \\<in> alphabet\\<^sub>F ts\\<rbrakk> \\<Longrightarrow>\n Leaf (freq\\<^sub>F ts a) a \\<in> set ts\"", "lemma weight_eq_Sum_freq:\n\"consistent t \\<Longrightarrow> weight t = (\\<Sum>a \\<in> alphabet t. freq t a)\"", "theorem cost_eq_Sum_freq_mult_depth:\n\"consistent t \\<Longrightarrow> cost t = (\\<Sum>a \\<in> alphabet t. freq t a * depth t a)\"", "lemma height_0_imp_cost_0[simp]:\n\"height t = 0 \\<Longrightarrow> cost t = 0\"", "lemma height_0_imp_cachedWeight_eq_weight[simp]:\n\"height t = 0 \\<Longrightarrow> cachedWeight t = weight t\"", "lemma alphabet_uniteTrees[simp]:\n\"alphabet (uniteTrees t\\<^sub>1 t\\<^sub>2) = alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2\"", "lemma consistent_uniteTrees[simp]:\n\"\\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\\<rbrakk> \\<Longrightarrow>\n consistent (uniteTrees t\\<^sub>1 t\\<^sub>2)\"", "lemma freq_uniteTrees[simp]:\n\"freq (uniteTrees t\\<^sub>1 t\\<^sub>2) a = freq t\\<^sub>1 a + freq t\\<^sub>2 a\"", "lemma length_insortTree[simp]:\n\"length (insortTree t ts) = length ts + 1\"", "lemma insortTree_ne_Nil[simp]:\n\"insortTree t ts \\<noteq> []\"", "lemma alphabet\\<^sub>F_insortTree[simp]:\n\"alphabet\\<^sub>F (insortTree t ts) = alphabet t \\<union> alphabet\\<^sub>F ts\"", "lemma consistent\\<^sub>F_insortTree[simp]:\n\"consistent\\<^sub>F (insortTree t ts) = consistent\\<^sub>F (t # ts)\"", "lemma freq\\<^sub>F_insortTree[simp]:\n\"freq\\<^sub>F (insortTree t ts) = (\\<lambda>a. freq t a + freq\\<^sub>F ts a)\"", "lemma height\\<^sub>F_insortTree[simp]:\n\"height\\<^sub>F (insortTree t ts) = max (height t) (height\\<^sub>F ts)\"", "theorem alphabet_huffman[simp]:\n\"ts \\<noteq> [] \\<Longrightarrow> alphabet (huffman ts) = alphabet\\<^sub>F ts\"", "theorem consistent_huffman[simp]:\n\"\\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> []\\<rbrakk> \\<Longrightarrow> consistent (huffman ts)\"", "theorem freq_huffman[simp]:\n\"ts \\<noteq> [] \\<Longrightarrow> freq (huffman ts) a = freq\\<^sub>F ts a\"", "lemma notin_alphabet_imp_sibling_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> sibling t a = a\"", "lemma height_0_imp_sibling_id[simp]:\n\"height t = 0 \\<Longrightarrow> sibling t a = a\"", "lemma height_gt_0_in_alphabet_imp_sibling_left[simp]:\n\"\\<lbrakk>height t\\<^sub>1 > 0; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>1 a\"", "lemma height_gt_0_in_alphabet_imp_sibling_right[simp]:\n\"\\<lbrakk>height t\\<^sub>2 > 0; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>1 a\"", "lemma height_gt_0_notin_alphabet_imp_sibling_left[simp]:\n\"\\<lbrakk>height t\\<^sub>1 > 0; a \\<notin> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>2 a\"", "lemma height_gt_0_notin_alphabet_imp_sibling_right[simp]:\n\"\\<lbrakk>height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>2 a\"", "lemma either_height_gt_0_imp_sibling[simp]:\n\"height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0 \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     (if a \\<in> alphabet t\\<^sub>1 then sibling t\\<^sub>1 a else sibling t\\<^sub>2 a)\"", "lemma in_alphabet_imp_sibling_in_alphabet:\n\"a \\<in> alphabet t \\<Longrightarrow> sibling t a \\<in> alphabet t\"", "lemma sibling_ne_imp_sibling_in_alphabet:\n\"sibling t a \\<noteq> a \\<Longrightarrow> sibling t a \\<in> alphabet t\"", "lemma sibling_induct_consistent[consumes 1,\n  case_names base step\\<^sub>1 step\\<^sub>2\\<^sub>1 step\\<^sub>2\\<^sub>2 step\\<^sub>2\\<^sub>3]:\n\"\\<lbrakk>consistent t;\n  \\<And>w b a. P (Leaf w b) a;\n  \\<And>w w\\<^sub>b b w\\<^sub>c c a. b \\<noteq> c \\<Longrightarrow> P (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<in> alphabet t\\<^sub>1;\n      sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n      sibling t\\<^sub>1 a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1;\n      sibling t\\<^sub>2 a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n      sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk> \\<Longrightarrow>\n P t a\"", "lemma sibling_sibling_id[simp]:\n\"consistent t \\<Longrightarrow> sibling t (sibling t a) = a\"", "lemma sibling_reciprocal:\n\"\\<lbrakk>consistent t; sibling t a = b\\<rbrakk> \\<Longrightarrow> sibling t b = a\"", "lemma depth_height_imp_sibling_ne:\n\"\\<lbrakk>consistent t; depth t a = height t; height t > 0; a \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n sibling t a \\<noteq> a\"", "lemma depth_sibling[simp]:\n\"consistent t \\<Longrightarrow> depth t (sibling t a) = depth t a\"", "lemma swapLeaves_id_when_notin_alphabet[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> swapLeaves t w a w' a = t\"", "lemma swapLeaves_id[simp]:\n\"consistent t \\<Longrightarrow> swapLeaves t (freq t a) a (freq t a) a = t\"", "lemma alphabet_swapLeaves:\n\"alphabet (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n     (if a \\<in> alphabet t then\n        if b \\<in> alphabet t then alphabet t else (alphabet t - {a}) \\<union> {b}\n      else\n        if b \\<in> alphabet t then (alphabet t - {b}) \\<union> {a} else alphabet t)\"", "lemma consistent_swapLeaves[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapLeaves t w\\<^sub>a a w\\<^sub>b b)\"", "lemma depth_swapLeaves_neither[simp]:\n\"\\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk> \\<Longrightarrow> depth (swapLeaves t w\\<^sub>a a w\\<^sub>b b) c = depth t c\"", "lemma height_swapLeaves[simp]:\n\"height (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = height t\"", "lemma freq_swapLeaves[simp]:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n freq (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n     (\\<lambda>c. if c = a then if b \\<in> alphabet t then w\\<^sub>a else 0\n          else if c = b then if a \\<in> alphabet t then w\\<^sub>b else 0\n          else freq t c)\"", "lemma weight_swapLeaves:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n if a \\<in> alphabet t then\n   if b \\<in> alphabet t then\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a + freq t b =\n         weight t + w\\<^sub>a + w\\<^sub>b\n   else\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a = weight t + w\\<^sub>b\n else\n   if b \\<in> alphabet t then\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t b = weight t + w\\<^sub>a\n   else\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = weight t\"", "lemma cost_swapLeaves:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n if a \\<in> alphabet t then\n   if b \\<in> alphabet t then\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a * depth t a\n     + freq t b * depth t b =\n         cost t + w\\<^sub>a * depth t b + w\\<^sub>b * depth t a\n   else\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a * depth t a =\n         cost t + w\\<^sub>b * depth t a\n else\n   if b \\<in> alphabet t then\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t b * depth t b =\n         cost t + w\\<^sub>a * depth t b\n   else\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = cost t\"", "lemma sibling_swapLeaves_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapLeaves t w\\<^sub>a a w\\<^sub>s (sibling t b)) a = b\"", "lemma swapSyms_id[simp]:\n\"consistent t \\<Longrightarrow> swapSyms t a a = t\"", "lemma alphabet_swapSyms[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk> \\<Longrightarrow> alphabet (swapSyms t a b) = alphabet t\"", "lemma consistent_swapSyms[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapSyms t a b)\"", "lemma depth_swapSyms_neither[simp]:\n\"\\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n depth (swapSyms t a b) c = depth t c\"", "lemma freq_swapSyms[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (swapSyms t a b) = freq t\"", "lemma cost_swapSyms:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\"\nshows \"cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n           cost t + freq t a * depth t b + freq t b * depth t a\"", "lemma le_le_imp_sum_mult_le_sum_mult:\nassumes \"i \\<le> j\" \"m \\<le> (n::nat)\"\nshows \"i * n + j * m \\<le> i * m + j * n\"", "lemma cost_swapSyms_le:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\" \"freq t a \\<le> freq t b\"\n        \"depth t a \\<le> depth t b\"\nshows \"cost (swapSyms t a b) \\<le> cost t\"", "lemma sibling_swapSyms_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapSyms t a (sibling t b)) a = b\"", "lemma sibling_swapSyms_other_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> a; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapSyms t a b) (sibling t b) = a\"", "lemma alphabet_swapFourSyms[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t; c \\<in> alphabet t; d \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n alphabet (swapFourSyms t a b c d) = alphabet t\"", "lemma consistent_swapFourSyms[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapFourSyms t a b c d)\"", "lemma freq_swapFourSyms[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t; c \\<in> alphabet t;\n  d \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (swapFourSyms t a b c d) = freq t\"", "lemma sibling_swapFourSyms_when_4th_is_sibling:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\" \"c \\<in> alphabet t\"\n        \"a \\<noteq> b\" \"sibling t c \\<noteq> c\"\nshows \"sibling (swapFourSyms t a b c (sibling t c)) a = b\"", "lemmas mergeSibling_induct_consistent = sibling_induct_consistent", "lemma notin_alphabet_imp_mergeSibling_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> mergeSibling t a = t\"", "lemma height_gt_0_imp_mergeSibling_left[simp]:\n\"height t\\<^sub>1 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\"", "lemma height_gt_0_imp_mergeSibling_right[simp]:\n\"height t\\<^sub>2 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\"", "lemma either_height_gt_0_imp_mergeSibling[simp]:\n\"height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\"", "lemma alphabet_mergeSibling[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n alphabet (mergeSibling t a) = (alphabet t - {sibling t a}) \\<union> {a}\"", "lemma consistent_mergeSibling[simp]:\n\"consistent t \\<Longrightarrow> consistent (mergeSibling t a)\"", "lemma freq_mergeSibling:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; sibling t a \\<noteq> a\\<rbrakk> \\<Longrightarrow>\n freq (mergeSibling t a) =\n     (\\<lambda>c. if c = a then freq t a + freq t (sibling t a)\n          else if c = sibling t a then 0\n          else freq t c)\"", "lemma weight_mergeSibling[simp]:\n\"weight (mergeSibling t a) = weight t\"", "lemma cost_mergeSibling:\n\"\\<lbrakk>consistent t; sibling t a \\<noteq> a\\<rbrakk> \\<Longrightarrow>\n cost (mergeSibling t a) + freq t a + freq t (sibling t a) = cost t\"", "lemma notin_alphabet_imp_splitLeaf_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> splitLeaf t w\\<^sub>a a w\\<^sub>b b = t\"", "lemma notin_alphabet\\<^sub>F_imp_splitLeaf\\<^sub>F_id[simp]:\n\"a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow> splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b = ts\"", "lemma alphabet_splitLeaf[simp]:\n\"alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n (if a \\<in> alphabet t then alphabet t \\<union> {b} else alphabet t)\"", "lemma consistent_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk> \\<Longrightarrow> consistent (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\"", "lemma freq_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n (if a \\<in> alphabet t then (\\<lambda>c. if c = a then w\\<^sub>a else if c = b then w\\<^sub>b else freq t c)\n  else freq t)\"", "lemma weight_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n weight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = weight t\"", "lemma cost_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = cost t + w\\<^sub>a + w\\<^sub>b\"", "lemma sortedByWeight_Cons_imp_sortedByWeight:\n\"sortedByWeight (t # ts) \\<Longrightarrow> sortedByWeight ts\"", "lemma sortedByWeight_Cons_imp_forall_weight_ge:\n\"sortedByWeight (t # ts) \\<Longrightarrow> \\<forall>u \\<in> set ts. weight u \\<ge> weight t\"", "lemma sortedByWeight_insortTree:\n\"\\<lbrakk>sortedByWeight ts; height t = 0; height\\<^sub>F ts = 0\\<rbrakk> \\<Longrightarrow>\n sortedByWeight (insortTree t ts)\"", "lemma cost_swapFourSyms_le:\nassumes\n  \"consistent t\" \"minima t a b\" \"c \\<in> alphabet t\" \"d \\<in> alphabet t\"\n  \"depth t c = height t\" \"depth t d = height t\" \"c \\<noteq> d\"\nshows \"cost (swapFourSyms t a b c d) \\<le> cost t\"", "lemma twice_freq_le_imp_minima:\n\"\\<lbrakk>\\<forall>c \\<in> alphabet t. w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c;\n  alphabet u = alphabet t \\<union> {b}; a \\<in> alphabet u; a \\<noteq> b;\n  freq u = (\\<lambda>c. if c = a then w\\<^sub>a else if c = b then w\\<^sub>b else freq t c)\\<rbrakk> \\<Longrightarrow>\n minima u a b\"", "lemma optimum_splitLeaf:\nassumes \"consistent t\" \"optimum t\" \"a \\<in> alphabet t\" \"b \\<notin> alphabet t\"\n        \"freq t a = w\\<^sub>a + w\\<^sub>b\" \"\\<forall>c \\<in> alphabet t. freq t c \\<ge> w\\<^sub>a \\<and> freq t c \\<ge> w\\<^sub>b\"\nshows \"optimum (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\"", "lemma cachedWeight_splitLeaf[simp]:\n\"cachedWeight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = cachedWeight t\"", "lemma splitLeaf\\<^sub>F_insortTree_when_in_alphabet_left[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; consistent t; a \\<notin> alphabet\\<^sub>F ts; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a w\\<^sub>b b = insortTree (splitLeaf t w\\<^sub>a a w\\<^sub>b b) ts\"", "lemma splitLeaf\\<^sub>F_insortTree_when_in_alphabet\\<^sub>F_tail[simp]:\n\"\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts; a \\<notin> alphabet t; freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a w\\<^sub>b b =\n insortTree t (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)\"", "lemma splitLeaf_huffman_commute:\n\"\\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> []; a \\<in> alphabet\\<^sub>F ts; freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf (huffman ts) w\\<^sub>a a w\\<^sub>b b = huffman (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)\"", "lemma max_0_imp_0[simp]:\n\"(max x y = (0::nat)) = (x = 0 \\<and> y = 0)\"", "theorem optimum_huffman:\n\"\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0; sortedByWeight ts; ts \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n optimum (huffman ts)\""], "translations": [["", "lemma finite_alphabet[simp]:\n\"finite (alphabet t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (alphabet t)", "by (induct t) auto"], ["", "lemma exists_in_alphabet:\n\"\\<exists>a. a \\<in> alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> alphabet t", "by (induct t) auto"], ["", "subsection \\<open>Consistency\\<close>"], ["", "text \\<open>\nA tree is {\\sl consistent\\/} if for each inner node the alphabets of the two\nsubtrees are disjoint. Intuitively, this means that every symbol in the\nalphabet occurs in exactly one leaf node. Consistency is a sufficient condition\nfor $\\delta_a$ (the length of the {\\sl unique\\/} code word for $a$) to be\ndefined. Although this well\\-formed\\-ness property is not mentioned in algorithms\ntextbooks \\cite{aho-et-al-1983,cormen-et-al-2001,knuth-1997}, it is essential\nand appears as an assumption in many of our lemmas.\n\\<close>"], ["", "primrec consistent :: \"'a tree \\<Rightarrow> bool\" where\n\"consistent (Leaf w a) = True\" |\n\"consistent (Node w t\\<^sub>1 t\\<^sub>2) =\n (alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {} \\<and> consistent t\\<^sub>1 \\<and> consistent t\\<^sub>2)\""], ["", "primrec consistent\\<^sub>F :: \"'a forest \\<Rightarrow> bool\" where\n\"consistent\\<^sub>F [] = True\" |\n\"consistent\\<^sub>F (t # ts) =\n (alphabet t \\<inter> alphabet\\<^sub>F ts = {} \\<and> consistent t \\<and> consistent\\<^sub>F ts)\""], ["", "text \\<open>\nSeveral of our proofs are by structural induction on consistent trees $t$ and\ninvolve one symbol $a$. These proofs typically distinguish the following cases.\n\n\\begin{myitemize}\n\\item[] {\\sc Base case:}\\enspace $t = @{term \"Leaf w b\"}$.\n\\item[] {\\sc Induction step:}\\enspace $t = @{term \"Node w t\\<^sub>1 t\\<^sub>2\"}$.\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 1:}\\enspace $a$ belongs to\n        @{term t\\<^sub>1} but not to @{term t\\<^sub>2}.\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 2:}\\enspace $a$ belongs to\n        @{term t\\<^sub>2} but not to @{term t\\<^sub>1}.\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 3:}\\enspace $a$ belongs to\n        neither @{term t\\<^sub>1} nor @{term t\\<^sub>2}.\n\\end{myitemize}\n\n\\noindent\nThanks to the consistency assumption, we can rule out the subcase where $a$\nbelongs to both subtrees.\n\nInstead of performing the above case distinction manually, we encode it in a\ncustom induction rule. This saves us from writing repetitive proof scripts and\nhelps Isabelle's automatic proof tactics.\n\\<close>"], ["", "lemma tree_induct_consistent[consumes 1, case_names base step\\<^sub>1 step\\<^sub>2 step\\<^sub>3]:\n\"\\<lbrakk>consistent t;\n  \\<And>w\\<^sub>b b a. P (Leaf w\\<^sub>b b) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk> \\<Longrightarrow>\n P t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; \\<And>w\\<^sub>b b a. P (Leaf w\\<^sub>b b) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk>\n    \\<Longrightarrow> P t a", "txt \\<open>\nThe proof relies on the \\textit{induction\\_schema} and\n\\textit{lexicographic\\_order} tactics, which automate the most tedious\naspects of deriving induction rules. The alternative would have been to perform\na standard structural induction on @{term t} and proceed by cases, which is\nstraightforward but long-winded.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; \\<And>w\\<^sub>b b a. P (Leaf w\\<^sub>b b) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk>\n    \\<Longrightarrow> P t a", "apply rotate_tac"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w\\<^sub>b b a. P (Leaf w\\<^sub>b b) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a; P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     consistent t\\<rbrakk>\n    \\<Longrightarrow> P t a", "apply induction_schema"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>P t a.\n       \\<lbrakk>consistent t;\n        \\<And>w\\<^sub>b__ b__ aa__.\n           \\<lbrakk>t = Leaf w\\<^sub>b__ b__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            aa__ \\<in> alphabet t\\<^sub>1__;\n            aa__ \\<notin> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            aa__ \\<notin> alphabet t\\<^sub>1__;\n            aa__ \\<in> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            aa__ \\<notin> alphabet t\\<^sub>1__;\n            aa__ \\<notin> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 8. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>t a.\n       consistent t \\<Longrightarrow>\n       (\\<exists>w\\<^sub>b__ b__ aa__.\n           t = Leaf w\\<^sub>b__ b__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__)\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 8. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (case_tac t)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>t a x11 x12.\n       \\<lbrakk>consistent t; t = Leaf x11 x12\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>w\\<^sub>b__ b__ aa__.\n                             t = Leaf w\\<^sub>b__ b__ \\<and> a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__)\n 2. \\<And>t a x21 x22 x23.\n       \\<lbrakk>consistent t; t = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>w\\<^sub>b__ b__ aa__.\n                             t = Leaf w\\<^sub>b__ b__ \\<and> a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__)\n 3. wf ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 8. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 9. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply fastforce"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>t a x21 x22 x23.\n       \\<lbrakk>consistent t; t = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>w\\<^sub>b__ b__ aa__.\n                             t = Leaf w\\<^sub>b__ b__ \\<and> a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__)\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 8. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply fastforce"], ["proof (prove)\ngoal (7 subgoals):\n 1. wf ?R2\n 2. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "by lexicographic_order"], ["", "text \\<open>\nThe \\textit{induction\\_schema} tactic reduces the putative induction rule to\nsimpler proof obligations.\nInternally, it reuses the machinery that constructs the default induction\nrules. The resulting proof obligations concern (a)~case completeness,\n(b)~invariant preservation (in our case, tree consistency), and\n(c)~wellfoundedness. For @{thm [source] tree_induct_consistent}, the obligations\n(a)~and (b) can be discharged using\nIsabelle's simplifier and classical reasoner, whereas (c) requires a single\ninvocation of \\textit{lexicographic\\_order}, a tactic that was originally\ndesigned to prove termination of recursive functions\n\\cite{bulwahn-et-al-2007,krauss-2007,krauss-2009}.\n\\<close>"], ["", "subsection \\<open>Symbol Depths\\<close>"], ["", "text \\<open>\nThe {\\sl depth\\/} of a symbol (which we denoted by $\\delta_a$ in\nSection~\\ref{binary-codes}) is the length of the path from the root to the\nleaf node labeled with that symbol, or equivalently the length of the code word\nfor the symbol. Symbols that do not occur in the tree or that occur at the root\nof a one-node tree have depth 0. If a symbol occurs in several leaf nodes (which\nmay happen with inconsistent trees), the depth is arbitrarily defined in terms\nof the leftmost node labeled with that symbol.\n\\<close>"], ["", "primrec depth :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n\"depth (Leaf w b) a = 0\" |\n\"depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n (if a \\<in> alphabet t\\<^sub>1 then depth t\\<^sub>1 a + 1\n  else if a \\<in> alphabet t\\<^sub>2 then depth t\\<^sub>2 a + 1\n  else 0)\""], ["", "text \\<open>\nThe definition may seem very inefficient from a functional programming\npoint of view, but it does not matter, because unlike Huffman's algorithm, the\n@{const depth} function is merely a reasoning tool and is never actually\nexecuted.\n\\<close>"], ["", "subsection \\<open>Height\\<close>"], ["", "text \\<open>\nThe {\\sl height\\/} of a tree is the length of the longest path from the root to\na leaf node, or equivalently the length of the longest code word. This is\nreadily generalized to forests by taking the maximum of the trees' heights. Note\nthat a tree has height 0 if and only if it is a leaf node, and that a forest has\nheight 0 if and only if all its trees are leaf nodes.\n\\<close>"], ["", "primrec height :: \"'a tree \\<Rightarrow> nat\" where\n\"height (Leaf w a) = 0\" |\n\"height (Node w t\\<^sub>1 t\\<^sub>2) = max (height t\\<^sub>1) (height t\\<^sub>2) + 1\""], ["", "primrec height\\<^sub>F :: \"'a forest \\<Rightarrow> nat\" where\n\"height\\<^sub>F [] = 0\" |\n\"height\\<^sub>F (t # ts) = max (height t) (height\\<^sub>F ts)\""], ["", "text \\<open>\nThe depth of any symbol in the tree is bounded by the tree's height, and there\nexists a symbol with a depth equal to the height.\n\\<close>"], ["", "lemma depth_le_height:\n\"depth t a \\<le> height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. depth t a \\<le> height t", "by (induct t) auto"], ["", "lemma exists_at_height:\n\"consistent t \\<Longrightarrow> \\<exists>a \\<in> alphabet t. depth t a = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow>\n    \\<exists>a\\<in>alphabet t. depth t a = height t", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       consistent (Leaf x1 x2) \\<Longrightarrow>\n       \\<exists>a\\<in>alphabet (Leaf x1 x2).\n          depth (Leaf x1 x2) a = height (Leaf x1 x2)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "case Leaf"], ["proof (state)\nthis:\n  consistent (Leaf x1_ x2_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       consistent (Leaf x1 x2) \\<Longrightarrow>\n       \\<exists>a\\<in>alphabet (Leaf x1 x2).\n          depth (Leaf x1 x2) a = height (Leaf x1 x2)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "thus ?case"], ["proof (prove)\nusing this:\n  consistent (Leaf x1_ x2_)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>alphabet (Leaf x1_ x2_).\n       depth (Leaf x1_ x2_) a = height (Leaf x1_ x2_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>a\\<in>alphabet (Leaf x1_ x2_).\n     depth (Leaf x1_ x2_) a = height (Leaf x1_ x2_)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "case (Node w t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "note hyps = Node"], ["proof (state)\nthis:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "let ?t = \"Node w t\\<^sub>1 t\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "from hyps"], ["proof (chain)\npicking this:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)", "obtain b where b: \"b \\<in> alphabet t\\<^sub>1\" \"depth t\\<^sub>1 b = height t\\<^sub>1\""], ["proof (prove)\nusing this:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> alphabet t\\<^sub>1;\n         depth t\\<^sub>1 b = height t\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n  depth t\\<^sub>1 b = height t\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "from hyps"], ["proof (chain)\npicking this:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)", "obtain c where c: \"c \\<in> alphabet t\\<^sub>2\" \"depth t\\<^sub>2 c = height t\\<^sub>2\""], ["proof (prove)\nusing this:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>1. depth t\\<^sub>1 a = height t\\<^sub>1\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  \\<exists>a\\<in>alphabet t\\<^sub>2. depth t\\<^sub>2 a = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> alphabet t\\<^sub>2;\n         depth t\\<^sub>2 c = height t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> alphabet t\\<^sub>2\n  depth t\\<^sub>2 c = height t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "let ?a = \"if height t\\<^sub>1 \\<ge> height t\\<^sub>2 then b else c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "from b c"], ["proof (chain)\npicking this:\n  b \\<in> alphabet t\\<^sub>1\n  depth t\\<^sub>1 b = height t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n  depth t\\<^sub>2 c = height t\\<^sub>2", "have \"?a \\<in> alphabet ?t\" \"depth ?t ?a = height ?t\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  depth t\\<^sub>1 b = height t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n  depth t\\<^sub>2 c = height t\\<^sub>2\n\ngoal (1 subgoal):\n 1. (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c)\n    \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2) &&&\n    depth (Node w t\\<^sub>1 t\\<^sub>2)\n     (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c) =\n    height (Node w t\\<^sub>1 t\\<^sub>2)", "using \\<open>consistent ?t\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  depth t\\<^sub>1 b = height t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n  depth t\\<^sub>2 c = height t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c)\n    \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2) &&&\n    depth (Node w t\\<^sub>1 t\\<^sub>2)\n     (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c) =\n    height (Node w t\\<^sub>1 t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c)\n  \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  depth (Node w t\\<^sub>1 t\\<^sub>2)\n   (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c) =\n  height (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                \\<exists>a\\<in>alphabet t1. depth t1 a = height t1;\n        consistent t2 \\<Longrightarrow>\n        \\<exists>a\\<in>alphabet t2. depth t2 a = height t2;\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a\\<in>alphabet (Node x1 t1 t2).\n                            depth (Node x1 t1 t2) a = height (Node x1 t1 t2)", "thus \"\\<exists>a \\<in> alphabet ?t. depth ?t a = height ?t\""], ["proof (prove)\nusing this:\n  (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c)\n  \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  depth (Node w t\\<^sub>1 t\\<^sub>2)\n   (if height t\\<^sub>2 \\<le> height t\\<^sub>1 then b else c) =\n  height (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n       height (Node w t\\<^sub>1 t\\<^sub>2)", ".."], ["proof (state)\nthis:\n  \\<exists>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n     height (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following elimination rules help Isabelle's classical prover, notably the\n\\textit{auto} tactic. They are easy consequences of the inequation\n@{thm depth_le_height[no_vars]}.\n\\<close>"], ["", "lemma depth_max_heightE_left[elim!]:\n\"\\<lbrakk>depth t\\<^sub>1 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n  \\<lbrakk>depth t\\<^sub>1 a = height t\\<^sub>1; height t\\<^sub>1 \\<ge> height t\\<^sub>2\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow>\n P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>depth t\\<^sub>1 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n     \\<lbrakk>depth t\\<^sub>1 a = height t\\<^sub>1;\n      height t\\<^sub>2 \\<le> height t\\<^sub>1\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cut_tac t = t\\<^sub>1 and a = a in depth_le_height) simp"], ["", "lemma depth_max_heightE_right[elim!]:\n\"\\<lbrakk>depth t\\<^sub>2 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n  \\<lbrakk>depth t\\<^sub>2 a = height t\\<^sub>2; height t\\<^sub>2 \\<ge> height t\\<^sub>1\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow>\n P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>depth t\\<^sub>2 a = max (height t\\<^sub>1) (height t\\<^sub>2);\n     \\<lbrakk>depth t\\<^sub>2 a = height t\\<^sub>2;\n      height t\\<^sub>1 \\<le> height t\\<^sub>2\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cut_tac t = t\\<^sub>2 and a = a in depth_le_height) simp"], ["", "text \\<open>\nWe also need the following lemma.\n\\<close>"], ["", "lemma height_gt_0_alphabet_eq_imp_height_gt_0:\nassumes \"height t > 0\" \"consistent t\" \"alphabet t = alphabet u\"\nshows \"height u > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height u", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12. t = Leaf x11 x12 \\<Longrightarrow> 0 < height u\n 2. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf x11_ x12_\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12. t = Leaf x11 x12 \\<Longrightarrow> 0 < height u\n 2. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = Leaf x11_ x12_\n\ngoal (1 subgoal):\n 1. 0 < height u", "using assms"], ["proof (prove)\nusing this:\n  t = Leaf x11_ x12_\n  0 < height t\n  consistent t\n  alphabet t = alphabet u\n\ngoal (1 subgoal):\n 1. 0 < height u", "by simp"], ["proof (state)\nthis:\n  0 < height u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "case (Node w t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  t = Node w t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "note t = Node"], ["proof (state)\nthis:\n  t = Node w t\\<^sub>1 t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "from exists_in_alphabet"], ["proof (chain)\npicking this:\n  \\<exists>a. a \\<in> alphabet ?t", "obtain b where b: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> alphabet ?t\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "from exists_in_alphabet"], ["proof (chain)\npicking this:\n  \\<exists>a. a \\<in> alphabet ?t", "obtain c where c: \"c \\<in> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> alphabet ?t\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  c \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "from b c"], ["proof (chain)\npicking this:\n  b \\<in> alphabet t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2", "have bc: \"b \\<noteq> c\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. b \\<noteq> c", "using t \\<open>consistent t\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n  t = Node w t\\<^sub>1 t\\<^sub>2\n  consistent t\n\ngoal (1 subgoal):\n 1. b \\<noteq> c", "by fastforce"], ["proof (state)\nthis:\n  b \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. t = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height u", "proof (cases u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12. u = Leaf x11 x12 \\<Longrightarrow> 0 < height u\n 2. \\<And>x21 x22 x23. u = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "case Leaf"], ["proof (state)\nthis:\n  u = Leaf x11_ x12_\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12. u = Leaf x11 x12 \\<Longrightarrow> 0 < height u\n 2. \\<And>x21 x22 x23. u = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = Leaf x11_ x12_\n\ngoal (1 subgoal):\n 1. 0 < height u", "using b c bc t assms"], ["proof (prove)\nusing this:\n  u = Leaf x11_ x12_\n  b \\<in> alphabet t\\<^sub>1\n  c \\<in> alphabet t\\<^sub>2\n  b \\<noteq> c\n  t = Node w t\\<^sub>1 t\\<^sub>2\n  0 < height t\n  consistent t\n  alphabet t = alphabet u\n\ngoal (1 subgoal):\n 1. 0 < height u", "by auto"], ["proof (state)\nthis:\n  0 < height u\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. u = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. u = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "case Node"], ["proof (state)\nthis:\n  u = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23. u = Node x21 x22 x23 \\<Longrightarrow> 0 < height u", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. 0 < height u", "by simp"], ["proof (state)\nthis:\n  0 < height u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < height u\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Symbol Frequencies\\<close>"], ["", "text \\<open>\nThe {\\sl frequency\\/} of a symbol (which we denoted by $w_a$ in\nSection~\\ref{binary-codes}) is the sum of the weights attached to the\nleaf nodes labeled with that symbol. If the tree is consistent, the sum\ncomprises at most one nonzero term. The frequency is then the weight of the leaf\nnode labeled with the symbol, or 0 if there is no such node. The generalization\nto forests is straightforward.\n\\<close>"], ["", "primrec freq :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n\"freq (Leaf w a) b = (if b = a then w else 0)\" |\n\"freq (Node w t\\<^sub>1 t\\<^sub>2) b = freq t\\<^sub>1 b + freq t\\<^sub>2 b\""], ["", "primrec freq\\<^sub>F :: \"'a forest \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n\"freq\\<^sub>F [] b = 0\" |\n\"freq\\<^sub>F (t # ts) b = freq t b + freq\\<^sub>F ts b\""], ["", "text \\<open>\nAlphabet and symbol frequencies are intimately related. Simplification rules\nensure that sums of the form @{term \"freq t\\<^sub>1 a + freq t\\<^sub>2 a\"} collapse to a\nsingle term when we know which tree @{term a} belongs to.\n\\<close>"], ["", "lemma notin_alphabet_imp_freq_0[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> freq t a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t \\<Longrightarrow> freq t a = 0", "by (induct t) simp+"], ["", "lemma notin_alphabet\\<^sub>F_imp_freq\\<^sub>F_0[simp]:\n\"a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow> freq\\<^sub>F ts a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow> freq\\<^sub>F ts a = 0", "by (induct ts) simp+"], ["", "lemma freq_0_right[simp]:\n\"\\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow> freq t\\<^sub>2 a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n     a \\<in> alphabet t\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> freq t\\<^sub>2 a = 0", "by (auto intro: notin_alphabet_imp_freq_0 simp: disjoint_iff_not_equal)"], ["", "lemma freq_0_left[simp]:\n\"\\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}; a \\<in> alphabet t\\<^sub>2\\<rbrakk> \\<Longrightarrow> freq t\\<^sub>1 a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n     a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> freq t\\<^sub>1 a = 0", "by (auto simp: disjoint_iff_not_equal)"], ["", "text \\<open>\nTwo trees are {\\em comparable} if they have the same alphabet and symbol\nfrequencies. This is an important concept, because it allows us to state not\nonly that the tree constructed by Huffman's algorithm is optimal but also that\nit has the expected alphabet and frequencies.\n\nWe close this section with a more technical lemma.\n\\<close>"], ["", "lemma height\\<^sub>F_0_imp_Leaf_freq\\<^sub>F_in_set:\n\"\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0; a \\<in> alphabet\\<^sub>F ts\\<rbrakk> \\<Longrightarrow>\n Leaf (freq\\<^sub>F ts a) a \\<in> set ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n     a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n    \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts", "proof (induct ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>consistent\\<^sub>F []; height\\<^sub>F [] = 0;\n     a \\<in> alphabet\\<^sub>F []\\<rbrakk>\n    \\<Longrightarrow> Leaf (freq\\<^sub>F [] a) a \\<in> set []\n 2. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n                 a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n                \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts;\n        consistent\\<^sub>F (aa # ts); height\\<^sub>F (aa # ts) = 0;\n        a \\<in> alphabet\\<^sub>F (aa # ts)\\<rbrakk>\n       \\<Longrightarrow> Leaf (freq\\<^sub>F (aa # ts) a) a\n                         \\<in> set (aa # ts)", "case Nil"], ["proof (state)\nthis:\n  consistent\\<^sub>F []\n  height\\<^sub>F [] = 0\n  a \\<in> alphabet\\<^sub>F []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>consistent\\<^sub>F []; height\\<^sub>F [] = 0;\n     a \\<in> alphabet\\<^sub>F []\\<rbrakk>\n    \\<Longrightarrow> Leaf (freq\\<^sub>F [] a) a \\<in> set []\n 2. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n                 a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n                \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts;\n        consistent\\<^sub>F (aa # ts); height\\<^sub>F (aa # ts) = 0;\n        a \\<in> alphabet\\<^sub>F (aa # ts)\\<rbrakk>\n       \\<Longrightarrow> Leaf (freq\\<^sub>F (aa # ts) a) a\n                         \\<in> set (aa # ts)", "thus ?case"], ["proof (prove)\nusing this:\n  consistent\\<^sub>F []\n  height\\<^sub>F [] = 0\n  a \\<in> alphabet\\<^sub>F []\n\ngoal (1 subgoal):\n 1. Leaf (freq\\<^sub>F [] a) a \\<in> set []", "by simp"], ["proof (state)\nthis:\n  Leaf (freq\\<^sub>F [] a) a \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n                 a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n                \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts;\n        consistent\\<^sub>F (aa # ts); height\\<^sub>F (aa # ts) = 0;\n        a \\<in> alphabet\\<^sub>F (aa # ts)\\<rbrakk>\n       \\<Longrightarrow> Leaf (freq\\<^sub>F (aa # ts) a) a\n                         \\<in> set (aa # ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n                 a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n                \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts;\n        consistent\\<^sub>F (aa # ts); height\\<^sub>F (aa # ts) = 0;\n        a \\<in> alphabet\\<^sub>F (aa # ts)\\<rbrakk>\n       \\<Longrightarrow> Leaf (freq\\<^sub>F (aa # ts) a) a\n                         \\<in> set (aa # ts)", "case (Cons t ts)"], ["proof (state)\nthis:\n  \\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n   a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n  \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts\n  consistent\\<^sub>F (t # ts)\n  height\\<^sub>F (t # ts) = 0\n  a \\<in> alphabet\\<^sub>F (t # ts)\n\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n                 a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n                \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts;\n        consistent\\<^sub>F (aa # ts); height\\<^sub>F (aa # ts) = 0;\n        a \\<in> alphabet\\<^sub>F (aa # ts)\\<rbrakk>\n       \\<Longrightarrow> Leaf (freq\\<^sub>F (aa # ts) a) a\n                         \\<in> set (aa # ts)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Leaf (freq\\<^sub>F (t # ts) a) a \\<in> set (t # ts)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n   a \\<in> alphabet\\<^sub>F ts\\<rbrakk>\n  \\<Longrightarrow> Leaf (freq\\<^sub>F ts a) a \\<in> set ts\n  consistent\\<^sub>F (t # ts)\n  height\\<^sub>F (t # ts) = 0\n  a \\<in> alphabet\\<^sub>F (t # ts)\n\ngoal (1 subgoal):\n 1. Leaf (freq\\<^sub>F (t # ts) a) a \\<in> set (t # ts)", "by (cases t) auto"], ["proof (state)\nthis:\n  Leaf (freq\\<^sub>F (t # ts) a) a \\<in> set (t # ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Weight\\<close>"], ["", "text \\<open>\nThe @{term weight} function returns the weight of a tree. In the\n@{const Node} case, we ignore the weight cached in the node and instead\ncompute the tree's weight recursively. This makes reasoning simpler because we\ncan then avoid specifying cache correctness as an assumption in our lemmas.\n\\<close>"], ["", "primrec weight :: \"'a tree \\<Rightarrow> nat\" where\n\"weight (Leaf w a) = w\" |\n\"weight (Node w t\\<^sub>1 t\\<^sub>2) = weight t\\<^sub>1 + weight t\\<^sub>2\""], ["", "text \\<open>\nThe weight of a tree is the sum of the frequencies of its symbols.\n\n\\myskip\n\n\\noindent\n\\isacommand{lemma} \\<open>weight_eq_Sum_freq\\<close>: \\\\\n{\\isachardoublequoteopen}$\\displaystyle \\<open>consistent t \\<Longrightarrow> weight t\\<close> =\n\\!\\!\\sum_{a\\in @{term \"alphabet t\"}}^{\\phantom{.}}\\!\\! @{term \"freq t a\"}$%\n{\\isachardoublequoteclose}\n\n\\vskip-\\myskipamount\n\\<close>"], ["", "(*<*)"], ["", "lemma weight_eq_Sum_freq:\n\"consistent t \\<Longrightarrow> weight t = (\\<Sum>a \\<in> alphabet t. freq t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> weight t = sum (freq t) (alphabet t)", "(*>*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> weight t = sum (freq t) (alphabet t)", "by (induct t) (auto simp: sum.union_disjoint)"], ["", "text \\<open>\nThe assumption @{term \"consistent t\"} is not necessary, but it simplifies the\nproof by letting us invoke the lemma @{thm [source] sum.union_disjoint}:\n$$\\<open>\\<lbrakk>finite A; finite B; A \\<inter> B = {}\\<rbrakk> \\<Longrightarrow>\\<close>~\\!\\sum_{x\\in A} @{term \"g x\"}\n\\vthinspace \\mathrel{+} \\sum_{x\\in B} @{term \"g x\"}\\vthinspace = %\n \\!\\!\\sum_{x\\in A \\cup B}\\! @{term \"g x\"}.$$\n\\<close>"], ["", "subsection \\<open>Cost\\<close>"], ["", "text \\<open>\nThe {\\sl cost\\/} of a consistent tree, sometimes called the {\\sl weighted path\nlength}, is given by the sum $\\sum_{a \\in @{term \"alphabet t\"}\\,}\n@{term \"freq t a\"} \\mathbin{\\<open>*\\<close>} @{term \"depth t a\"}$\n(which we denoted by $\\sum_a w_a \\vthinspace\\delta_a$ in\nSection~\\ref{binary-codes}). It obeys a simple recursive law.\n\\<close>"], ["", "primrec cost :: \"'a tree \\<Rightarrow> nat\" where\n\"cost (Leaf w a) = 0\" |\n\"cost (Node w t\\<^sub>1 t\\<^sub>2) = weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2\""], ["", "text \\<open>\nOne interpretation of this recursive law is that the cost of a tree is the sum\nof the weights of its inner nodes \\cite[p.~405]{knuth-1997}. (Recall that\n$@{term \"weight (Node w t\\<^sub>1 t\\<^sub>2)\"} = @{term \"weight t\\<^sub>1 + weight t\\<^sub>2\"}$.) Since\nthe cost of a tree is such a fundamental concept, it seems necessary to prove\nthat the above function definition is correct.\n\n\\myskip\n\n\\noindent\n\\isacommand{theorem} \\<open>cost_eq_Sum_freq_mult_depth\\<close>: \\\\\n{\\isachardoublequoteopen}$\\displaystyle \\<open>consistent t \\<Longrightarrow> cost t\\<close> =\n\\!\\!\\sum_{a\\in @{term \"alphabet t\"}}^{\\phantom{.}}\\!\\!\n@{term \"freq t a * depth t a\"}$%\n{\\isachardoublequoteclose}\n\n\\myskip\n\n\\noindent\nThe proof is by structural induction on $t$. If $t = @{term \"Leaf w b\"}$, both\nsides of the equation simplify to 0. This leaves the case $@{term t} =\n@{term \"Node w t\\<^sub>1 t\\<^sub>2\"}$. Let $A$, $A_1$, and $A_2$ stand for\n@{term \"alphabet t\"}, @{term \"alphabet t\\<^sub>1\"}, and @{term \"alphabet t\\<^sub>2\"},\nrespectively. We have\n%\n$$\\begin{tabularx}{\\textwidth}{@%\n{\\hskip\\leftmargin}cX@%\n{}}\n    & @{term \"cost t\"} \\\\\n\\eq & \\justif{definition of @{const cost}} \\\\\n    & $@{term \"weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2\"}$ \\\\\n\\eq & \\justif{induction hypothesis} \\\\\n    & $@{term \"weight t\\<^sub>1\"} \\mathrel{+}\n       \\sum_{a\\in A_1\\,} @{term \"freq t\\<^sub>1 a * depth t\\<^sub>1 a\"} \\mathrel{+} {}$ \\\\\n    & $@{term \"weight t\\<^sub>2\"} \\mathrel{+}\n       \\sum_{a\\in A_2\\,} @{term \"freq t\\<^sub>2 a * depth t\\<^sub>2 a\"}$ \\\\\n\\eq & \\justif{definition of @{const depth}, consistency} \\\\[\\extrah]\n    & $@{term \"weight t\\<^sub>1\"} \\mathrel{+}\n       \\sum_{a\\in A_1\\,} @{term \"freq t\\<^sub>1 a * (depth t a - 1)\"} \\mathrel{+}\n       {}$ \\\\\n    & $@{term \"weight t\\<^sub>2\"} \\mathrel{+}\n       \\sum_{a\\in A_2\\,} @{term \"freq t\\<^sub>2 a * (depth t a - 1)\"}$ \\\\[\\extrah]\n\\eq & \\justif{distributivity of \\<open>*\\<close> and $\\sum$ over $-$} \\\\[\\extrah]\n    & $@{term \"weight t\\<^sub>1\"} \\mathrel{+}\n       \\sum_{a\\in A_1\\,} @{term \"freq t\\<^sub>1 a * depth t a\"} \\mathrel{-}\n       \\sum_{a\\in A_1\\,} @{term \"freq t\\<^sub>1 a\"} \\mathrel{+} {}$ \\\\\n    & $@{term \"weight t\\<^sub>2\"} \\mathrel{+}\n       \\sum_{a\\in A_2\\,} @{term \"freq t\\<^sub>2 a * depth t a\"} \\mathrel{-}\n       \\sum_{a\\in A_2\\,} @{term \"freq t\\<^sub>2 a\"}$ \\\\[\\extrah]\n\\eq & \\justif{@{thm [source] weight_eq_Sum_freq}} \\\\[\\extrah]\n    & $\\sum_{a\\in A_1\\,} @{term \"freq t\\<^sub>1 a * depth t a\"} \\mathrel{+}\n       \\sum_{a\\in A_2\\,} @{term \"freq t\\<^sub>2 a * depth t a\"}$ \\\\[\\extrah]\n\\eq & \\justif{definition of @{const freq}, consistency} \\\\[\\extrah]\n    & $\\sum_{a\\in A_1\\,} @{term \"freq t a * depth t a\"} \\mathrel{+}\n       \\sum_{a\\in A_2\\,} @{term \"freq t a * depth t a\"}$ \\\\[\\extrah]\n\\eq & \\justif{@{thm [source] sum.union_disjoint}, consistency} \\\\\n    & $\\sum_{a\\in A_1\\cup A_2\\,} @{term \"freq t a * depth t a\"}$ \\\\\n\\eq & \\justif{definition of @{const alphabet}} \\\\\n    & $\\sum_{a\\in A\\,} @{term \"freq t a * depth t a\"}$.\n\\end{tabularx}$$\n\n\\noindent\nThe structured proof closely follows this argument.\n\\<close>"], ["", "(*<*)"], ["", "theorem cost_eq_Sum_freq_mult_depth:\n\"consistent t \\<Longrightarrow> cost t = (\\<Sum>a \\<in> alphabet t. freq t a * depth t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow>\n    cost t = (\\<Sum>a\\<in>alphabet t. freq t a * depth t a)", "(*>*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow>\n    cost t = (\\<Sum>a\\<in>alphabet t. freq t a * depth t a)", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       consistent (Leaf x1 x2) \\<Longrightarrow>\n       cost (Leaf x1 x2) =\n       (\\<Sum>a\\<in>alphabet (Leaf x1 x2).\n          freq (Leaf x1 x2) a * depth (Leaf x1 x2) a)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "case Leaf"], ["proof (state)\nthis:\n  consistent (Leaf x1_ x2_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       consistent (Leaf x1 x2) \\<Longrightarrow>\n       cost (Leaf x1 x2) =\n       (\\<Sum>a\\<in>alphabet (Leaf x1 x2).\n          freq (Leaf x1 x2) a * depth (Leaf x1 x2) a)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "thus ?case"], ["proof (prove)\nusing this:\n  consistent (Leaf x1_ x2_)\n\ngoal (1 subgoal):\n 1. cost (Leaf x1_ x2_) =\n    (\\<Sum>a\\<in>alphabet (Leaf x1_ x2_).\n       freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a)", "by simp"], ["proof (state)\nthis:\n  cost (Leaf x1_ x2_) =\n  (\\<Sum>a\\<in>alphabet (Leaf x1_ x2_).\n     freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "case (Node w t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  cost t\\<^sub>1 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a)\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  cost t\\<^sub>2 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "let ?t = \"Node w t\\<^sub>1 t\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "let ?A = \"alphabet ?t\" and ?A\\<^sub>1 = \"alphabet t\\<^sub>1\" and ?A\\<^sub>2 = \"alphabet t\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "note c = \\<open>consistent ?t\\<close>"], ["proof (state)\nthis:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "note hyps = Node"], ["proof (state)\nthis:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  cost t\\<^sub>1 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a)\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  cost t\\<^sub>2 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have d\\<^sub>2: \"\\<And>a. \\<lbrakk>?A\\<^sub>1 \\<inter> ?A\\<^sub>2 = {}; a \\<in> ?A\\<^sub>2\\<rbrakk> \\<Longrightarrow> depth ?t a = depth t\\<^sub>2 a + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n                         depth t\\<^sub>2 a + 1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n   ?a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> depth (Node w t\\<^sub>1 t\\<^sub>2) ?a =\n                    depth t\\<^sub>2 ?a + 1\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"cost ?t = weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (Node w t\\<^sub>1 t\\<^sub>2) =\n    weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  cost (Node w t\\<^sub>1 t\\<^sub>2) =\n  weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  cost (Node w t\\<^sub>1 t\\<^sub>2) =\n  weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = weight t\\<^sub>1 + (\\<Sum>a \\<in> ?A\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a)\n    + weight t\\<^sub>2 + (\\<Sum>a \\<in> ?A\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2 =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)", "using hyps"], ["proof (prove)\nusing this:\n  consistent t\\<^sub>1 \\<Longrightarrow>\n  cost t\\<^sub>1 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a)\n  consistent t\\<^sub>2 \\<Longrightarrow>\n  cost t\\<^sub>2 =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2 =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)", "by simp"], ["proof (state)\nthis:\n  weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2 =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  weight t\\<^sub>1 + cost t\\<^sub>1 + weight t\\<^sub>2 + cost t\\<^sub>2 =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = weight t\\<^sub>1 + (\\<Sum>a \\<in> ?A\\<^sub>1. freq t\\<^sub>1 a * (depth ?t a - 1))\n    + weight t\\<^sub>2 + (\\<Sum>a \\<in> ?A\\<^sub>2. freq t\\<^sub>2 a * (depth ?t a - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a) =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1))", "using c d\\<^sub>2"], ["proof (prove)\nusing this:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n   ?a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> depth (Node w t\\<^sub>1 t\\<^sub>2) ?a =\n                    depth t\\<^sub>2 ?a + 1\n\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a) =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1))", "by simp"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a) =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1. freq t\\<^sub>1 a * depth t\\<^sub>1 a) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2. freq t\\<^sub>2 a * depth t\\<^sub>2 a) =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = weight t\\<^sub>1 + (\\<Sum>a \\<in> ?A\\<^sub>1. freq t\\<^sub>1 a * depth ?t a)\n    - (\\<Sum>a \\<in> ?A\\<^sub>1. freq t\\<^sub>1 a)\n    + weight t\\<^sub>2 + (\\<Sum>a \\<in> ?A\\<^sub>2. freq t\\<^sub>2 a * depth ?t a)\n    - (\\<Sum>a \\<in> ?A\\<^sub>2. freq t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>2) (alphabet t\\<^sub>2)", "using c d\\<^sub>2"], ["proof (prove)\nusing this:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n   ?a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> depth (Node w t\\<^sub>1 t\\<^sub>2) ?a =\n                    depth t\\<^sub>2 ?a + 1\n\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) =\n    weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>2) (alphabet t\\<^sub>2)", "by (simp add: sum.distrib)"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>2) (alphabet t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * (depth (Node w t\\<^sub>1 t\\<^sub>2) a - 1)) =\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>2) (alphabet t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = (\\<Sum>a \\<in> ?A\\<^sub>1. freq t\\<^sub>1 a * depth ?t a)\n    + (\\<Sum>a \\<in> ?A\\<^sub>2. freq t\\<^sub>2 a * depth ?t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>2) (alphabet t\\<^sub>2) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "using c"], ["proof (prove)\nusing this:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. weight t\\<^sub>1 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n    weight t\\<^sub>2 +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n    sum (freq t\\<^sub>2) (alphabet t\\<^sub>2) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "by (simp add: weight_eq_Sum_freq)"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>2) (alphabet t\\<^sub>2) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  weight t\\<^sub>1 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>1) (alphabet t\\<^sub>1) +\n  weight t\\<^sub>2 +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) -\n  sum (freq t\\<^sub>2) (alphabet t\\<^sub>2) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = (\\<Sum>a \\<in> ?A\\<^sub>1. freq ?t a * depth ?t a)\n    + (\\<Sum>a \\<in> ?A\\<^sub>2. freq ?t a * depth ?t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "using c"], ["proof (prove)\nusing this:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq t\\<^sub>1 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq t\\<^sub>2 a * depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = (\\<Sum>a \\<in> ?A\\<^sub>1 \\<union> ?A\\<^sub>2. freq ?t a * depth ?t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "using c"], ["proof (prove)\nusing this:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n    (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n    (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "by (simp add: sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) +\n  (\\<Sum>a\\<in>alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "have \"\\<dots> = (\\<Sum>a \\<in> ?A. freq ?t a * depth ?t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n    (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2.\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a) =\n  (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>consistent t1 \\<Longrightarrow>\n                cost t1 = (\\<Sum>a\\<in>alphabet t1. freq t1 a * depth t1 a);\n        consistent t2 \\<Longrightarrow>\n        cost t2 = (\\<Sum>a\\<in>alphabet t2. freq t2 a * depth t2 a);\n        consistent (Node x1 t1 t2)\\<rbrakk>\n       \\<Longrightarrow> cost (Node x1 t1 t2) =\n                         (\\<Sum>a\\<in>alphabet (Node x1 t1 t2).\n                            freq (Node x1 t1 t2) a *\n                            depth (Node x1 t1 t2) a)", "finally"], ["proof (chain)\npicking this:\n  cost (Node w t\\<^sub>1 t\\<^sub>2) =\n  (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "show ?case"], ["proof (prove)\nusing this:\n  cost (Node w t\\<^sub>1 t\\<^sub>2) =\n  (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal (1 subgoal):\n 1. cost (Node w t\\<^sub>1 t\\<^sub>2) =\n    (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n       freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n       depth (Node w t\\<^sub>1 t\\<^sub>2) a)", "."], ["proof (state)\nthis:\n  cost (Node w t\\<^sub>1 t\\<^sub>2) =\n  (\\<Sum>a\\<in>alphabet (Node w t\\<^sub>1 t\\<^sub>2).\n     freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n     depth (Node w t\\<^sub>1 t\\<^sub>2) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFinally, it should come as no surprise that trees with height 0 have cost 0.\n\\<close>"], ["", "lemma height_0_imp_cost_0[simp]:\n\"height t = 0 \\<Longrightarrow> cost t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = 0 \\<Longrightarrow> cost t = 0", "by (case_tac t) simp+"], ["", "subsection \\<open>Optimality\\<close>"], ["", "text \\<open>\nA tree is optimum if and only if its cost is not greater than that of any\ncomparable tree. We can ignore inconsistent trees without loss of generality.\n\\<close>"], ["", "definition optimum :: \"'a tree \\<Rightarrow> bool\" where\n\"optimum t =\n (\\<forall>u. consistent u \\<longrightarrow> alphabet t = alphabet u \\<longrightarrow> freq t = freq u \\<longrightarrow>\n  cost t \\<le> cost u)\""], ["", "section \\<open>Functional Implementation of Huffman's Algorithm \\label{implementation}\\<close>"], ["", "subsection \\<open>Cached Weight\\<close>"], ["", "text \\<open>\nThe {\\sl cached weight\\/} of a node is the weight stored directly in the node.\nOur arguments rely on the computed weight (embodied by the @{const weight}\nfunction) rather than the cached weight, but the implementation of Huffman's\nalgorithm uses the cached weight for performance reasons.\n\\<close>"], ["", "primrec cachedWeight :: \"'a tree \\<Rightarrow> nat\" where\n\"cachedWeight (Leaf w a) = w\" |\n\"cachedWeight (Node w t\\<^sub>1 t\\<^sub>2) = w\""], ["", "text \\<open>\nThe cached weight of a leaf node is identical to its computed weight.\n\\<close>"], ["", "lemma height_0_imp_cachedWeight_eq_weight[simp]:\n\"height t = 0 \\<Longrightarrow> cachedWeight t = weight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = 0 \\<Longrightarrow> cachedWeight t = weight t", "by (case_tac t) simp+"], ["", "subsection \\<open>Tree Union\\<close>"], ["", "text \\<open>\nThe implementation of Huffman's algorithm builds on two additional auxiliary\nfunctions. The first one, \\<open>uniteTrees\\<close>, takes two trees\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-w1.pdf}}}\n  \\qquad \\hbox{and} \\qquad\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-w2.pdf}}}$$\n\n\\noindent\nand returns the tree\\strut\n$$\\includegraphics[scale=1.25]{tree-w1-w2.pdf}$$\n\n\\vskip-.5\\myskipamount\n\\<close>"], ["", "definition uniteTrees :: \"'a tree \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"uniteTrees t\\<^sub>1 t\\<^sub>2 = Node (cachedWeight t\\<^sub>1 + cachedWeight t\\<^sub>2) t\\<^sub>1 t\\<^sub>2\""], ["", "text \\<open>\nThe alphabet, consistency, and symbol frequencies of a united tree are easy to\nconnect to the homologous properties of the subtrees.\n\\<close>"], ["", "lemma alphabet_uniteTrees[simp]:\n\"alphabet (uniteTrees t\\<^sub>1 t\\<^sub>2) = alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet (uniteTrees t\\<^sub>1 t\\<^sub>2) =\n    alphabet t\\<^sub>1 \\<union> alphabet t\\<^sub>2", "by (simp add: uniteTrees_def)"], ["", "lemma consistent_uniteTrees[simp]:\n\"\\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\\<rbrakk> \\<Longrightarrow>\n consistent (uniteTrees t\\<^sub>1 t\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n     alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\\<rbrakk>\n    \\<Longrightarrow> consistent (uniteTrees t\\<^sub>1 t\\<^sub>2)", "by (simp add: uniteTrees_def)"], ["", "lemma freq_uniteTrees[simp]:\n\"freq (uniteTrees t\\<^sub>1 t\\<^sub>2) a = freq t\\<^sub>1 a + freq t\\<^sub>2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freq (uniteTrees t\\<^sub>1 t\\<^sub>2) a =\n    freq t\\<^sub>1 a + freq t\\<^sub>2 a", "by (simp add: uniteTrees_def)"], ["", "subsection \\<open>Ordered Tree Insertion\\<close>"], ["", "text \\<open>\nThe auxiliary function \\<open>insortTree\\<close> inserts a tree into a forest sorted\nby cached weight, preserving the sort order.\n\\<close>"], ["", "primrec insortTree :: \"'a tree \\<Rightarrow> 'a forest \\<Rightarrow> 'a forest\" where\n\"insortTree u [] = [u]\" |\n\"insortTree u (t # ts) =\n (if cachedWeight u \\<le> cachedWeight t then u # t # ts else t # insortTree u ts)\""], ["", "text \\<open>\nThe resulting forest contains one more tree than the original forest. Clearly,\nit cannot be empty.\n\\<close>"], ["", "lemma length_insortTree[simp]:\n\"length (insortTree t ts) = length ts + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insortTree t ts) = length ts + 1", "by (induct ts) simp+"], ["", "lemma insortTree_ne_Nil[simp]:\n\"insortTree t ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insortTree t ts \\<noteq> []", "by (case_tac ts) simp+"], ["", "text \\<open>\nThe alphabet, consistency, symbol frequencies, and height of a forest after\ninsertion are easy to relate to the homologous properties of the original\nforest and the inserted tree.\n\\<close>"], ["", "lemma alphabet\\<^sub>F_insortTree[simp]:\n\"alphabet\\<^sub>F (insortTree t ts) = alphabet t \\<union> alphabet\\<^sub>F ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet\\<^sub>F (insortTree t ts) =\n    alphabet t \\<union> alphabet\\<^sub>F ts", "by (induct ts) auto"], ["", "lemma consistent\\<^sub>F_insortTree[simp]:\n\"consistent\\<^sub>F (insortTree t ts) = consistent\\<^sub>F (t # ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent\\<^sub>F (insortTree t ts) = consistent\\<^sub>F (t # ts)", "by (induct ts) auto"], ["", "lemma freq\\<^sub>F_insortTree[simp]:\n\"freq\\<^sub>F (insortTree t ts) = (\\<lambda>a. freq t a + freq\\<^sub>F ts a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freq\\<^sub>F (insortTree t ts) =\n    (\\<lambda>a. freq t a + freq\\<^sub>F ts a)", "by (induct ts) (simp add: ext)+"], ["", "lemma height\\<^sub>F_insortTree[simp]:\n\"height\\<^sub>F (insortTree t ts) = max (height t) (height\\<^sub>F ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height\\<^sub>F (insortTree t ts) = max (height t) (height\\<^sub>F ts)", "by (induct ts) auto"], ["", "subsection \\<open>The Main Algorithm\\<close>"], ["", "text \\<open>\nHuffman's algorithm repeatedly unites the first two trees of the forest it\nreceives as argument until a single tree is left. It should initially be\ninvoked with a list of leaf nodes sorted by weight. Note that it is not defined\nfor the empty list.\n\\<close>"], ["", "fun huffman :: \"'a forest \\<Rightarrow> 'a tree\" where\n\"huffman [t] = t\" |\n\"huffman (t\\<^sub>1 # t\\<^sub>2 # ts) = huffman (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\""], ["", "text \\<open>\nThe time complexity of the algorithm is quadratic in the size of the forest.\nIf we eliminated the inner node's cached weight component, and instead\nrecomputed the weight each time it is needed, the complexity would remain\nquadratic, but with a larger constant. Using a binary search in @{const\ninsortTree}, the corresponding imperative algorithm is $O(n \\log n)$ if we keep\nthe weight cache and $O(n^2)$ if we drop it. An $O(n)$ imperative implementation\nis possible by maintaining two queues, one containing the unprocessed leaf nodes\nand the other containing the combined trees \\cite[p.~404]{knuth-1997}.\n\nThe tree returned by the algorithm preserves the alphabet, consistency, and\nsymbol frequencies of the original forest.\n\\<close>"], ["", "theorem alphabet_huffman[simp]:\n\"ts \\<noteq> [] \\<Longrightarrow> alphabet (huffman ts) = alphabet\\<^sub>F ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> [] \\<Longrightarrow>\n    alphabet (huffman ts) = alphabet\\<^sub>F ts", "by (induct ts rule: huffman.induct) auto"], ["", "theorem consistent_huffman[simp]:\n\"\\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> []\\<rbrakk> \\<Longrightarrow> consistent (huffman ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> consistent (huffman ts)", "by (induct ts rule: huffman.induct) simp+"], ["", "theorem freq_huffman[simp]:\n\"ts \\<noteq> [] \\<Longrightarrow> freq (huffman ts) a = freq\\<^sub>F ts a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> [] \\<Longrightarrow> freq (huffman ts) a = freq\\<^sub>F ts a", "by (induct ts rule: huffman.induct) auto"], ["", "section \\<open>Definition of Auxiliary Functions Used in the Proof \\label{auxiliary}\\<close>"], ["", "subsection \\<open>Sibling of a Symbol\\<close>"], ["", "text \\<open>\nThe {\\sl sibling\\/} of a symbol $a$ in a tree $t$ is the label of the node that\nis the (left or right) sibling of the node labeled with $a$ in $t$. If the\nsymbol $a$ is not in $t$'s alphabet or it occurs in a node with no sibling\nleaf, we define the sibling as being $a$ itself; this gives us the nice property\nthat if $t$ is consistent, then $@{term \"sibling t a\"} \\not= a$ if and only if\n$a$ has a sibling. As an illustration, we have\n$@{term \"sibling t a\"} = b$,\\vthinspace{} $@{term \"sibling t b\"} = a$,\nand $@{term \"sibling t c\"} = c$ for the tree\\strut\n$$t \\,= \\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-sibling.pdf}}}$$\n\\<close>"], ["", "fun sibling :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n\"sibling (Leaf w\\<^sub>b b) a = a\" |\n\"sibling (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a =\n     (if a = b then c else if a = c then b else a)\" |\n\"sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     (if a \\<in> alphabet t\\<^sub>1 then sibling t\\<^sub>1 a\n      else if a \\<in> alphabet t\\<^sub>2 then sibling t\\<^sub>2 a\n      else a)\""], ["", "text \\<open>\nBecause @{const sibling} is defined using sequential pattern matching\n\\cite{krauss-2007,krauss-2009}, reasoning about it can become tedious.\nSimplification rules therefore play an important role.\n\\<close>"], ["", "lemma notin_alphabet_imp_sibling_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> sibling t a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t \\<Longrightarrow> sibling t a = a", "by (cases rule: sibling.cases[where x = \"(t, a)\"]) simp+"], ["", "lemma height_0_imp_sibling_id[simp]:\n\"height t = 0 \\<Longrightarrow> sibling t a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = 0 \\<Longrightarrow> sibling t a = a", "by (case_tac t) simp+"], ["", "lemma height_gt_0_in_alphabet_imp_sibling_left[simp]:\n\"\\<lbrakk>height t\\<^sub>1 > 0; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>1 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < height t\\<^sub>1; a \\<in> alphabet t\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n                      sibling t\\<^sub>1 a", "by (case_tac t\\<^sub>1) simp+"], ["", "lemma height_gt_0_in_alphabet_imp_sibling_right[simp]:\n\"\\<lbrakk>height t\\<^sub>2 > 0; a \\<in> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>1 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < height t\\<^sub>2; a \\<in> alphabet t\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n                      sibling t\\<^sub>1 a", "by (case_tac t\\<^sub>2) simp+"], ["", "lemma height_gt_0_notin_alphabet_imp_sibling_left[simp]:\n\"\\<lbrakk>height t\\<^sub>1 > 0; a \\<notin> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < height t\\<^sub>1; a \\<notin> alphabet t\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n                      sibling t\\<^sub>2 a", "by (case_tac t\\<^sub>1) simp+"], ["", "lemma height_gt_0_notin_alphabet_imp_sibling_right[simp]:\n\"\\<lbrakk>height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a = sibling t\\<^sub>2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < height t\\<^sub>2; a \\<notin> alphabet t\\<^sub>1\\<rbrakk>\n    \\<Longrightarrow> sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n                      sibling t\\<^sub>2 a", "by (case_tac t\\<^sub>2) simp+"], ["", "lemma either_height_gt_0_imp_sibling[simp]:\n\"height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0 \\<Longrightarrow>\n sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     (if a \\<in> alphabet t\\<^sub>1 then sibling t\\<^sub>1 a else sibling t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2 \\<Longrightarrow>\n    sibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n    (if a \\<in> alphabet t\\<^sub>1 then sibling t\\<^sub>1 a\n     else sibling t\\<^sub>2 a)", "by auto"], ["", "text \\<open>\nThe following rules are also useful for reasoning about siblings and alphabets.\n\\<close>"], ["", "lemma in_alphabet_imp_sibling_in_alphabet:\n\"a \\<in> alphabet t \\<Longrightarrow> sibling t a \\<in> alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> alphabet t \\<Longrightarrow> sibling t a \\<in> alphabet t", "by (induct t a rule: sibling.induct) auto"], ["", "lemma sibling_ne_imp_sibling_in_alphabet:\n\"sibling t a \\<noteq> a \\<Longrightarrow> sibling t a \\<in> alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling t a \\<noteq> a \\<Longrightarrow> sibling t a \\<in> alphabet t", "by (metis notin_alphabet_imp_sibling_id in_alphabet_imp_sibling_in_alphabet)"], ["", "text \\<open>\nThe default induction rule for @{const sibling} distinguishes four cases.\n\n\\begin{myitemize}\n\\item[] {\\sc Base case:}\\enskip $t = @{term \"Leaf w b\"}$.\n\\item[] {\\sc Induction step 1:}\\enskip\n        $t = @{term \"Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)\"}$.\n\\item[] {\\sc Induction step 2:}\\enskip\n        $t = @{term \"Node w (Node w\\<^sub>1 t\\<^sub>1\\<^sub>1 t\\<^sub>1\\<^sub>2) t\\<^sub>2\"}$.\n\\item[] {\\sc Induction step 3:}\\enskip\n        $t = @{term \"Node w t\\<^sub>1 (Node w\\<^sub>2 t\\<^sub>2\\<^sub>1 t\\<^sub>2\\<^sub>2)\"}$.\n\\end{myitemize}\n\n\\noindent\nThis rule leaves much to be desired. First, the last two cases overlap and\ncan normally be handled the same way, so they should be combined. Second, the\nnested \\<open>Node\\<close> constructors in the last two cases reduce readability.\nThird, under the assumption that $t$ is consistent, we would like to perform\nthe same case distinction on $a$ as we did for\n@{thm [source] tree_induct_consistent}, with the same benefits for automation.\nThese observations lead us to develop a custom induction rule that\ndistinguishes the following cases.\n\n\\begin{myitemize}\n\\item[] {\\sc Base case:}\\enskip $t = @{term \"Leaf w b\"}$.\n\\item[] {\\sc Induction step 1:}\\enskip\n        $t = @{term \"Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)\"}$ with\n        @{prop \"b \\<noteq> c\"}.\n\\item[] \\begin{flushleft}\n        {\\sc Induction step 2:}\\enskip\n        $t = @{term \"Node w t\\<^sub>1 t\\<^sub>2\"}$ and either @{term t\\<^sub>1} or @{term t\\<^sub>2}\n        has nonzero height.\n        \\end{flushleft}\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 1:}\\enspace $a$ belongs to\n        @{term t\\<^sub>1} but not to @{term t\\<^sub>2}.\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 2:}\\enspace $a$ belongs to\n        @{term t\\<^sub>2} but not to @{term t\\<^sub>1}.\n\\item[] \\noindent\\kern\\leftmargin {\\sc Subcase 3:}\\enspace $a$ belongs to\n        neither @{term t\\<^sub>1} nor @{term t\\<^sub>2}.\n\\end{myitemize}\n\nThe statement of the rule and its proof are similar to what we did for\nconsistent trees, the main difference being that we now have two induction\nsteps instead of one.\n\\<close>"], ["", "lemma sibling_induct_consistent[consumes 1,\n  case_names base step\\<^sub>1 step\\<^sub>2\\<^sub>1 step\\<^sub>2\\<^sub>2 step\\<^sub>2\\<^sub>3]:\n\"\\<lbrakk>consistent t;\n  \\<And>w b a. P (Leaf w b) a;\n  \\<And>w w\\<^sub>b b w\\<^sub>c c a. b \\<noteq> c \\<Longrightarrow> P (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<in> alphabet t\\<^sub>1;\n      sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n      sibling t\\<^sub>1 a \\<notin> alphabet t\\<^sub>2; P t\\<^sub>1 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1;\n      sibling t\\<^sub>2 a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n      sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2; P t\\<^sub>2 a\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a;\n  \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n     \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2; alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n      height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0; a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2\\<rbrakk> \\<Longrightarrow>\n     P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk> \\<Longrightarrow>\n P t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; \\<And>w b a. P (Leaf w b) a;\n     \\<And>w w\\<^sub>b b w\\<^sub>c c a.\n        b \\<noteq> c \\<Longrightarrow>\n        P (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<in> alphabet t\\<^sub>1;\n         sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1;\n         a \\<notin> alphabet t\\<^sub>2;\n         sibling t\\<^sub>1 a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<notin> alphabet t\\<^sub>1;\n         sibling t\\<^sub>2 a \\<notin> alphabet t\\<^sub>1;\n         a \\<in> alphabet t\\<^sub>2;\n         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2;\n         P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<notin> alphabet t\\<^sub>1;\n         a \\<notin> alphabet t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a\\<rbrakk>\n    \\<Longrightarrow> P t a", "apply rotate_tac"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w b a. P (Leaf w b) a;\n     \\<And>w w\\<^sub>b b w\\<^sub>c c a.\n        b \\<noteq> c \\<Longrightarrow>\n        P (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<in> alphabet t\\<^sub>1;\n         sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1;\n         a \\<notin> alphabet t\\<^sub>2;\n         sibling t\\<^sub>1 a \\<notin> alphabet t\\<^sub>2;\n         P t\\<^sub>1 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<notin> alphabet t\\<^sub>1;\n         sibling t\\<^sub>2 a \\<notin> alphabet t\\<^sub>1;\n         a \\<in> alphabet t\\<^sub>2;\n         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2;\n         P t\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n        \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n         alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n         0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2;\n         a \\<notin> alphabet t\\<^sub>1;\n         a \\<notin> alphabet t\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> P (Node w t\\<^sub>1 t\\<^sub>2) a;\n     consistent t\\<rbrakk>\n    \\<Longrightarrow> P t a", "apply induction_schema"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P t a.\n       \\<lbrakk>consistent t;\n        \\<And>w__ b__ aa__.\n           \\<lbrakk>t = Leaf w__ b__; a = aa__\\<rbrakk> \\<Longrightarrow> P;\n        \\<And>w__ w\\<^sub>b__ b__ w\\<^sub>c__ c__ aa__.\n           \\<lbrakk>b__ \\<noteq> c__;\n            t = Node w__ (Leaf w\\<^sub>b__ b__) (Leaf w\\<^sub>c__ c__);\n            a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n            aa__ \\<in> alphabet t\\<^sub>1__;\n            sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n            aa__ \\<notin> alphabet t\\<^sub>2__;\n            sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n            aa__ \\<notin> alphabet t\\<^sub>1__;\n            sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n            aa__ \\<in> alphabet t\\<^sub>2__;\n            sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n            alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n            0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n            aa__ \\<notin> alphabet t\\<^sub>1__;\n            aa__ \\<notin> alphabet t\\<^sub>2__;\n            t = Node w__ t\\<^sub>1__ t\\<^sub>2__; a = aa__\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t a.\n       consistent t \\<Longrightarrow>\n       (\\<exists>w__ b__ aa__. t = Leaf w__ b__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ w\\<^sub>b__ b__ w\\<^sub>c__ c__ aa__.\n           b__ \\<noteq> c__ \\<and>\n           t = Node w__ (Leaf w\\<^sub>b__ b__) (Leaf w\\<^sub>c__ c__) \\<and>\n           a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           (0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__) \\<and>\n           aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n           sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n           sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           (0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__) \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n           sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n           sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__) \\<or>\n       (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n           consistent t\\<^sub>1__ \\<and>\n           consistent t\\<^sub>2__ \\<and>\n           alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {} \\<and>\n           (0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__) \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n           aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n           t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and> a = aa__)\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (case_tac t, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t a x21 x22 x23.\n       \\<lbrakk>consistent t; t = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>w__ b__ aa__.\n                             t = Leaf w__ b__ \\<and> a = aa__) \\<or>\n                         (\\<exists>w__ w\\<^sub>b__ b__ w\\<^sub>c__ c__ aa__.\n                             b__ \\<noteq> c__ \\<and>\n                             t =\n                             Node w__ (Leaf w\\<^sub>b__ b__)\n                              (Leaf w\\<^sub>c__ c__) \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             (0 < height t\\<^sub>1__ \\<or>\n                              0 < height t\\<^sub>2__) \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>1__ \\<and>\n                             sibling t\\<^sub>1__ aa__\n                             \\<in> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             sibling t\\<^sub>1__ aa__\n                             \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             (0 < height t\\<^sub>1__ \\<or>\n                              0 < height t\\<^sub>2__) \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             sibling t\\<^sub>2__ aa__\n                             \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<in> alphabet t\\<^sub>2__ \\<and>\n                             sibling t\\<^sub>2__ aa__\n                             \\<in> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__) \\<or>\n                         (\\<exists>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n                             consistent t\\<^sub>1__ \\<and>\n                             consistent t\\<^sub>2__ \\<and>\n                             alphabet t\\<^sub>1__ \\<inter>\n                             alphabet t\\<^sub>2__ =\n                             {} \\<and>\n                             (0 < height t\\<^sub>1__ \\<or>\n                              0 < height t\\<^sub>2__) \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>1__ \\<and>\n                             aa__ \\<notin> alphabet t\\<^sub>2__ \\<and>\n                             t = Node w__ t\\<^sub>1__ t\\<^sub>2__ \\<and>\n                             a = aa__)\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a x22 x23.\n       \\<lbrakk>alphabet x22 \\<inter> alphabet x23 = {}; consistent x22;\n        consistent x23;\n        \\<forall>w\\<^sub>b__ b__.\n           x22 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> x23 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling x22 a \\<in> alphabet x22 \\<longrightarrow>\n        a \\<in> alphabet x22 \\<longrightarrow>\n        height x22 = 0 \\<and> height x23 = 0 \\<or>\n        a \\<in> alphabet x23 \\<or> sibling x22 a \\<in> alphabet x23;\n        height x22 = 0 \\<and> height x23 = 0 \\<or>\n        a \\<in> alphabet x22 \\<or> a \\<in> alphabet x23\\<rbrakk>\n       \\<Longrightarrow> (0 < height x22 \\<or> 0 < height x23) \\<and>\n                         a \\<notin> alphabet x22 \\<and>\n                         sibling x23 a \\<notin> alphabet x22 \\<and>\n                         a \\<in> alphabet x23 \\<and>\n                         sibling x23 a \\<in> alphabet x23\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (rename_tac a t\\<^sub>1 t\\<^sub>2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (case_tac \"height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 2. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        \\<not> (height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0)\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 3. wf ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        \\<not> (height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0)\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 3. wf ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (case_tac t\\<^sub>1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 x11 x12.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Leaf x11 x12\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 x21 x22 x23.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        \\<not> (height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0)\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 4. wf ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (case_tac t\\<^sub>2)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 x11 x12 x11a x12a.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Leaf x11 x12; t\\<^sub>2 = Leaf x11a x12a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 x11 x12 x21 x22 x23.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Leaf x11 x12; t\\<^sub>2 = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>t\\<^sub>1 t\\<^sub>2 x21 x22 x23.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        \\<not> (height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0)\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 5. wf ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 7. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply fastforce"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 x11 x12 x21 x22 x23.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Leaf x11 x12; t\\<^sub>2 = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 x21 x22 x23.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0;\n        t\\<^sub>1 = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0 \\<or>\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        \\<not> (height t\\<^sub>1 = 0 \\<and> height t\\<^sub>2 = 0)\\<rbrakk>\n       \\<Longrightarrow> (0 < height t\\<^sub>1 \\<or>\n                          0 < height t\\<^sub>2) \\<and>\n                         a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 4. wf ?R2\n 5. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 6. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply simp+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a t\\<^sub>1 t\\<^sub>2.\n       \\<lbrakk>alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        consistent t\\<^sub>1; consistent t\\<^sub>2;\n        \\<forall>w\\<^sub>b__ b__.\n           t\\<^sub>1 = Leaf w\\<^sub>b__ b__ \\<longrightarrow>\n           (\\<forall>w\\<^sub>c__ c__.\n               b__ = c__ \\<or> t\\<^sub>2 \\<noteq> Leaf w\\<^sub>c__ c__);\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>1 \\<longrightarrow>\n        a \\<in> alphabet t\\<^sub>2 \\<or>\n        sibling t\\<^sub>1 a \\<in> alphabet t\\<^sub>2;\n        a \\<in> alphabet t\\<^sub>1 \\<or> a \\<in> alphabet t\\<^sub>2;\n        0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> alphabet t\\<^sub>1 \\<and>\n                         sibling t\\<^sub>2 a\n                         \\<notin> alphabet t\\<^sub>1 \\<and>\n                         a \\<in> alphabet t\\<^sub>2 \\<and>\n                         sibling t\\<^sub>2 a \\<in> alphabet t\\<^sub>2\n 2. wf ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 4. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "apply (auto intro: in_alphabet_imp_sibling_in_alphabet)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?R2\n 2. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<in> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>1__ aa__ \\<in> alphabet t\\<^sub>1__;\n        aa__ \\<notin> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>1__ aa__ \\<notin> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>1__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2\n 3. \\<And>w__ t\\<^sub>1__ t\\<^sub>2__ aa__.\n       \\<lbrakk>consistent t\\<^sub>1__; consistent t\\<^sub>2__;\n        alphabet t\\<^sub>1__ \\<inter> alphabet t\\<^sub>2__ = {};\n        0 < height t\\<^sub>1__ \\<or> 0 < height t\\<^sub>2__;\n        aa__ \\<notin> alphabet t\\<^sub>1__;\n        sibling t\\<^sub>2__ aa__ \\<notin> alphabet t\\<^sub>1__;\n        aa__ \\<in> alphabet t\\<^sub>2__;\n        sibling t\\<^sub>2__ aa__ \\<in> alphabet t\\<^sub>2__\\<rbrakk>\n       \\<Longrightarrow> ((t\\<^sub>2__, aa__),\n                          Node w__ t\\<^sub>1__ t\\<^sub>2__, aa__)\n                         \\<in> ?R2", "by lexicographic_order"], ["", "text \\<open>\nThe custom induction rule allows us to prove new properties of @{const sibling}\nwith little effort.\n\\<close>"], ["", "lemma sibling_sibling_id[simp]:\n\"consistent t \\<Longrightarrow> sibling t (sibling t a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> sibling t (sibling t a) = a", "by (induct t a rule: sibling_induct_consistent) simp+"], ["", "lemma sibling_reciprocal:\n\"\\<lbrakk>consistent t; sibling t a = b\\<rbrakk> \\<Longrightarrow> sibling t b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; sibling t a = b\\<rbrakk>\n    \\<Longrightarrow> sibling t b = a", "by auto"], ["", "lemma depth_height_imp_sibling_ne:\n\"\\<lbrakk>consistent t; depth t a = height t; height t > 0; a \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n sibling t a \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; depth t a = height t; 0 < height t;\n     a \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> sibling t a \\<noteq> a", "by (induct t a rule: sibling_induct_consistent) auto"], ["", "lemma depth_sibling[simp]:\n\"consistent t \\<Longrightarrow> depth t (sibling t a) = depth t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> depth t (sibling t a) = depth t a", "by (induct t a rule: sibling_induct_consistent) simp+"], ["", "subsection \\<open>Leaf Interchange\\<close>"], ["", "text \\<open>\nThe \\<open>swapLeaves\\<close> function takes a tree $t$ together with two symbols\n$a$, $b$ and their frequencies $@{term w\\<^sub>a}$, $@{term w\\<^sub>b}$, and returns the tree\n$t$ in which the leaf nodes labeled with $a$ and $b$ are exchanged. When\ninvoking \\<open>swapLeaves\\<close>, we normally pass @{term \"freq t a\"} and\n@{term \"freq t b\"} for @{term w\\<^sub>a} and @{term w\\<^sub>b}.\n\nNote that we do not bother updating the cached weight of the ancestor nodes\nwhen performing the interchange. The cached weight is used only in the\nimplementation of Huffman's algorithm, which does not invoke \\<open>swapLeaves\\<close>.\n\\<close>"], ["", "primrec swapLeaves :: \"'a tree \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a tree\" where\n\"swapLeaves (Leaf w\\<^sub>c c) w\\<^sub>a a w\\<^sub>b b =\n     (if c = a then Leaf w\\<^sub>b b else if c = b then Leaf w\\<^sub>a a else Leaf w\\<^sub>c c)\" |\n\"swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b b =\n     Node w (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b)\""], ["", "text \\<open>\nSwapping a symbol~$a$ with itself leaves the tree $t$ unchanged if $a$ does not\nbelong to it or if the specified frequencies @{term w\\<^sub>a} and @{term w\\<^sub>b} equal\n@{term \"freq t a\"}.\n\\<close>"], ["", "lemma swapLeaves_id_when_notin_alphabet[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> swapLeaves t w a w' a = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t \\<Longrightarrow> swapLeaves t w a w' a = t", "by (induct t) simp+"], ["", "lemma swapLeaves_id[simp]:\n\"consistent t \\<Longrightarrow> swapLeaves t (freq t a) a (freq t a) a = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow>\n    swapLeaves t (freq t a) a (freq t a) a = t", "by (induct t a rule: tree_induct_consistent) simp+"], ["", "text \\<open>\nThe alphabet, consistency, symbol depths, height, and symbol frequencies of the\ntree @{term \"swapLeaves t w\\<^sub>a a w\\<^sub>b b\"} can be related to the homologous\nproperties of $t$.\n\\<close>"], ["", "lemma alphabet_swapLeaves:\n\"alphabet (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n     (if a \\<in> alphabet t then\n        if b \\<in> alphabet t then alphabet t else (alphabet t - {a}) \\<union> {b}\n      else\n        if b \\<in> alphabet t then (alphabet t - {b}) \\<union> {a} else alphabet t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n    (if a \\<in> alphabet t\n     then if b \\<in> alphabet t then alphabet t\n          else alphabet t - {a} \\<union> {b}\n     else if b \\<in> alphabet t then alphabet t - {b} \\<union> {a}\n          else alphabet t)", "by (induct t) auto"], ["", "lemma consistent_swapLeaves[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapLeaves t w\\<^sub>a a w\\<^sub>b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow>\n    consistent (swapLeaves t w\\<^sub>a a w\\<^sub>b b)", "by (induct t) (auto simp: alphabet_swapLeaves)"], ["", "lemma depth_swapLeaves_neither[simp]:\n\"\\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk> \\<Longrightarrow> depth (swapLeaves t w\\<^sub>a a w\\<^sub>b b) c = depth t c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> depth (swapLeaves t w\\<^sub>a a w\\<^sub>b b) c =\n                      depth t c", "by (induct t a rule: tree_induct_consistent) (auto simp: alphabet_swapLeaves)"], ["", "lemma height_swapLeaves[simp]:\n\"height (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = height t", "by (induct t) simp+"], ["", "lemma freq_swapLeaves[simp]:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n freq (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n     (\\<lambda>c. if c = a then if b \\<in> alphabet t then w\\<^sub>a else 0\n          else if c = b then if a \\<in> alphabet t then w\\<^sub>b else 0\n          else freq t c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> freq (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n                      (\\<lambda>c.\n                          if c = a\n                          then if b \\<in> alphabet t then w\\<^sub>a else 0\n                          else if c = b\n                               then if a \\<in> alphabet t then w\\<^sub>b\n                                    else 0\n                               else freq t c)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> freq (swapLeaves t w\\<^sub>a a w\\<^sub>b b) c =\n                         (if c = a\n                          then if b \\<in> alphabet t then w\\<^sub>a else 0\n                          else if c = b\n                               then if a \\<in> alphabet t then w\\<^sub>b\n                                    else 0\n                               else freq t c)", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 c.\n       \\<lbrakk>consistent (Leaf x1 x2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> freq\n                          (swapLeaves (Leaf x1 x2) w\\<^sub>a a w\\<^sub>b b)\n                          c =\n                         (if c = a\n                          then if b \\<in> alphabet (Leaf x1 x2)\n                               then w\\<^sub>a else 0\n                          else if c = b\n                               then if a \\<in> alphabet (Leaf x1 x2)\n                                    then w\\<^sub>b else 0\n                               else freq (Leaf x1 x2) c)\n 2. \\<And>x1 t1 t2 c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                   \\<Longrightarrow> freq\n(swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) c =\n                                     (if c = a\nthen if b \\<in> alphabet t1 then w\\<^sub>a else 0\nelse if c = b then if a \\<in> alphabet t1 then w\\<^sub>b else 0\n     else freq t1 c);\n        \\<And>c.\n           \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n           \\<Longrightarrow> freq (swapLeaves t2 w\\<^sub>a a w\\<^sub>b b)\n                              c =\n                             (if c = a\n                              then if b \\<in> alphabet t2 then w\\<^sub>a\n                                   else 0\n                              else if c = b\n                                   then if a \\<in> alphabet t2\n  then w\\<^sub>b else 0\n                                   else freq t2 c);\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> freq\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>b\n                            b)\n                          c =\n                         (if c = a\n                          then if b \\<in> alphabet (Node x1 t1 t2)\n                               then w\\<^sub>a else 0\n                          else if c = b\n                               then if a \\<in> alphabet (Node x1 t1 t2)\n                                    then w\\<^sub>b else 0\n                               else freq (Node x1 t1 t2) c)", "by auto"], ["", "text \\<open>\nFor the lemmas concerned with the resulting tree's weight and cost, we avoid\nsubtraction on natural numbers by rearranging terms. For example, we write\n$$@{prop \"weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a = weight t + w\\<^sub>b\"}$$\n\\noindent\nrather than the more conventional\n$$@{prop \"weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = weight t + w\\<^sub>b - freq t a\"}.$$\nIn Isabelle/HOL, these two equations are not equivalent, because by definition\n$m - n = 0$ if $n > m$. We could use the second equation and additionally\nassert that @{prop \"weight t \\<ge> freq t a\"} (an easy consequence of\n@{thm [source] weight_eq_Sum_freq}), and then apply the \\textit{arith}\ntactic, but it is much simpler to use the first equation and stay with\n\\textit{simp} and \\textit{auto}. Another option would be to use\nintegers instead of natural numbers.\n\\<close>"], ["", "lemma weight_swapLeaves:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n if a \\<in> alphabet t then\n   if b \\<in> alphabet t then\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a + freq t b =\n         weight t + w\\<^sub>a + w\\<^sub>b\n   else\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a = weight t + w\\<^sub>b\n else\n   if b \\<in> alphabet t then\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t b = weight t + w\\<^sub>a\n   else\n     weight (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = weight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> if a \\<in> alphabet t\n                      then if b \\<in> alphabet t\n                           then weight\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t a +\n                                freq t b =\n                                weight t + w\\<^sub>a + w\\<^sub>b\n                           else weight\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t a =\n                                weight t + w\\<^sub>b\n                      else if b \\<in> alphabet t\n                           then weight\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t b =\n                                weight t + w\\<^sub>a\n                           else weight\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n                                weight t", "proof (induct t a rule: tree_induct_consistent)\n  \\<comment> \\<open>{\\sc Base case:}\\enspace $t = @{term \"Leaf w b\"}$\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>w\\<^sub>b' ba a.\n       a \\<noteq> b \\<Longrightarrow>\n       if a \\<in> alphabet (Leaf w\\<^sub>b' ba)\n       then if b \\<in> alphabet (Leaf w\\<^sub>b' ba)\n            then weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) a +\n                 freq (Leaf w\\<^sub>b' ba) b =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>a + w\\<^sub>b\n            else weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) a =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>b\n       else if b \\<in> alphabet (Leaf w\\<^sub>b' ba)\n            then weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) b =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>a\n            else weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) =\n                 weight (Leaf w\\<^sub>b' ba)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 3. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 4. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "case base"], ["proof (state)\nthis:\n  a_ \\<noteq> b\n\ngoal (4 subgoals):\n 1. \\<And>w\\<^sub>b' ba a.\n       a \\<noteq> b \\<Longrightarrow>\n       if a \\<in> alphabet (Leaf w\\<^sub>b' ba)\n       then if b \\<in> alphabet (Leaf w\\<^sub>b' ba)\n            then weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) a +\n                 freq (Leaf w\\<^sub>b' ba) b =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>a + w\\<^sub>b\n            else weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) a =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>b\n       else if b \\<in> alphabet (Leaf w\\<^sub>b' ba)\n            then weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) +\n                 freq (Leaf w\\<^sub>b' ba) b =\n                 weight (Leaf w\\<^sub>b' ba) + w\\<^sub>a\n            else weight\n                  (swapLeaves (Leaf w\\<^sub>b' ba) w\\<^sub>a a w\\<^sub>b\n                    b) =\n                 weight (Leaf w\\<^sub>b' ba)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 3. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 4. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  a_ \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a_ \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n    then if b \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n         then weight\n               (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n              freq (Leaf w\\<^sub>b_ b_) a_ +\n              freq (Leaf w\\<^sub>b_ b_) b =\n              weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n              freq (Leaf w\\<^sub>b_ b_) a_ =\n              weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>b\n    else if b \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n         then weight\n               (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n              freq (Leaf w\\<^sub>b_ b_) b =\n              weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>a\n         else weight\n               (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) =\n              weight (Leaf w\\<^sub>b_ b_)", "by clarsimp"], ["proof (state)\nthis:\n  if a_ \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n  then if b \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n       then weight\n             (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n            freq (Leaf w\\<^sub>b_ b_) a_ +\n            freq (Leaf w\\<^sub>b_ b_) b =\n            weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n            freq (Leaf w\\<^sub>b_ b_) a_ =\n            weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>b\n  else if b \\<in> alphabet (Leaf w\\<^sub>b_ b_)\n       then weight\n             (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) +\n            freq (Leaf w\\<^sub>b_ b_) b =\n            weight (Leaf w\\<^sub>b_ b_) + w\\<^sub>a\n       else weight\n             (swapLeaves (Leaf w\\<^sub>b_ b_) w\\<^sub>a a_ w\\<^sub>b b) =\n            weight (Leaf w\\<^sub>b_ b_)\n\ngoal (3 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 3. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "next\n  \\<comment> \\<open>{\\sc Induction step:}\\enspace $t = @{term \"Node w t\\<^sub>1 t\\<^sub>2\"}$\\<close>\n  \\<comment> \\<open>{\\sc Subcase 1:}\\enspace $a$ belongs to @{term t\\<^sub>1} but not to\n        @{term t\\<^sub>2}\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 3. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "case (step\\<^sub>1 w t\\<^sub>1 t\\<^sub>2 a)"], ["proof (state)\nthis:\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (3 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<in> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 3. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume b: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using step\\<^sub>1"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using b step\\<^sub>1"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using step\\<^sub>1"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "next\n  \\<comment> \\<open>{\\sc Subcase 2:}\\enspace $a$ belongs to @{term t\\<^sub>2} but not to\n        @{term t\\<^sub>1}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "case (step\\<^sub>2 w t\\<^sub>1 t\\<^sub>2 a)"], ["proof (state)\nthis:\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<in> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume b: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using step\\<^sub>2"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using b step\\<^sub>2"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using step\\<^sub>2"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "next\n  \\<comment> \\<open>{\\sc Subcase 3:}\\enspace $a$ belongs to neither @{term t\\<^sub>1} nor\n        @{term t\\<^sub>2}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "case (step\\<^sub>3 w t\\<^sub>1 t\\<^sub>2 a)"], ["proof (state)\nthis:\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>w t\\<^sub>1 t\\<^sub>2 a.\n       \\<lbrakk>consistent t\\<^sub>1; consistent t\\<^sub>2;\n        alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {};\n        a \\<notin> alphabet t\\<^sub>1; a \\<notin> alphabet t\\<^sub>2;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>1\n        then if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 a =\n                  weight t\\<^sub>1 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>1\n             then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>1 b =\n                  weight t\\<^sub>1 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>1;\n        a \\<noteq> b \\<Longrightarrow>\n        if a \\<in> alphabet t\\<^sub>2\n        then if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 a =\n                  weight t\\<^sub>2 + w\\<^sub>b\n        else if b \\<in> alphabet t\\<^sub>2\n             then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n                  freq t\\<^sub>2 b =\n                  weight t\\<^sub>2 + w\\<^sub>a\n             else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n                  weight t\\<^sub>2;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n                         then if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a +\n                                   w\\<^sub>b\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>b\n                         else if b \\<in> alphabet\n    (Node w t\\<^sub>1 t\\<^sub>2)\n                              then weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) +\n                                   freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2) +\n                                   w\\<^sub>a\n                              else weight\n                                    (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2)\nw\\<^sub>a a w\\<^sub>b b) =\n                                   weight (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume b: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using step\\<^sub>3"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using b step\\<^sub>3"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "using step\\<^sub>3"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n  consistent t\\<^sub>1\n  consistent t\\<^sub>2\n  alphabet t\\<^sub>1 \\<inter> alphabet t\\<^sub>2 = {}\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  a \\<noteq> b \\<Longrightarrow>\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n              weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n         else weight\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              weight (Node w t\\<^sub>1 t\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a + w\\<^sub>b\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>b\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b =\n            weight (Node w t\\<^sub>1 t\\<^sub>2) + w\\<^sub>a\n       else weight\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            weight (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cost_swapLeaves:\n\"\\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n if a \\<in> alphabet t then\n   if b \\<in> alphabet t then\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a * depth t a\n     + freq t b * depth t b =\n         cost t + w\\<^sub>a * depth t b + w\\<^sub>b * depth t a\n   else\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t a * depth t a =\n         cost t + w\\<^sub>b * depth t a\n else\n   if b \\<in> alphabet t then\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) + freq t b * depth t b =\n         cost t + w\\<^sub>a * depth t b\n   else\n     cost (swapLeaves t w\\<^sub>a a w\\<^sub>b b) = cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> if a \\<in> alphabet t\n                      then if b \\<in> alphabet t\n                           then cost\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t a * depth t a +\n                                freq t b * depth t b =\n                                cost t + w\\<^sub>a * depth t b +\n                                w\\<^sub>b * depth t a\n                           else cost\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t a * depth t a =\n                                cost t + w\\<^sub>b * depth t a\n                      else if b \\<in> alphabet t\n                           then cost\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) +\n                                freq t b * depth t b =\n                                cost t + w\\<^sub>a * depth t b\n                           else cost\n                                 (swapLeaves t w\\<^sub>a a w\\<^sub>b b) =\n                                cost t", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>consistent (Leaf x1 x2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Leaf x1 x2)\n                         then if b \\<in> alphabet (Leaf x1 x2)\n                              then cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) a *\n                                   depth (Leaf x1 x2) a +\n                                   freq (Leaf x1 x2) b *\n                                   depth (Leaf x1 x2) b =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>a * depth (Leaf x1 x2) b +\n                                   w\\<^sub>b * depth (Leaf x1 x2) a\n                              else cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) a *\n                                   depth (Leaf x1 x2) a =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>b * depth (Leaf x1 x2) a\n                         else if b \\<in> alphabet (Leaf x1 x2)\n                              then cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) b *\n                                   depth (Leaf x1 x2) b =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>a * depth (Leaf x1 x2) b\n                              else cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Leaf x1 x2)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "case Leaf"], ["proof (state)\nthis:\n  consistent (Leaf x1_ x2_)\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>consistent (Leaf x1 x2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Leaf x1 x2)\n                         then if b \\<in> alphabet (Leaf x1 x2)\n                              then cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) a *\n                                   depth (Leaf x1 x2) a +\n                                   freq (Leaf x1 x2) b *\n                                   depth (Leaf x1 x2) b =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>a * depth (Leaf x1 x2) b +\n                                   w\\<^sub>b * depth (Leaf x1 x2) a\n                              else cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) a *\n                                   depth (Leaf x1 x2) a =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>b * depth (Leaf x1 x2) a\n                         else if b \\<in> alphabet (Leaf x1 x2)\n                              then cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Leaf x1 x2) b *\n                                   depth (Leaf x1 x2) b =\n                                   cost (Leaf x1 x2) +\n                                   w\\<^sub>a * depth (Leaf x1 x2) b\n                              else cost\n                                    (swapLeaves (Leaf x1 x2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Leaf x1 x2)\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Leaf x1_ x2_)\n    then if b \\<in> alphabet (Leaf x1_ x2_)\n         then cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n              freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a +\n              freq (Leaf x1_ x2_) b * depth (Leaf x1_ x2_) b =\n              cost (Leaf x1_ x2_) + w\\<^sub>a * depth (Leaf x1_ x2_) b +\n              w\\<^sub>b * depth (Leaf x1_ x2_) a\n         else cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n              freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a =\n              cost (Leaf x1_ x2_) + w\\<^sub>b * depth (Leaf x1_ x2_) a\n    else if b \\<in> alphabet (Leaf x1_ x2_)\n         then cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n              freq (Leaf x1_ x2_) b * depth (Leaf x1_ x2_) b =\n              cost (Leaf x1_ x2_) + w\\<^sub>a * depth (Leaf x1_ x2_) b\n         else cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) =\n              cost (Leaf x1_ x2_)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Leaf x1_ x2_)\n  then if b \\<in> alphabet (Leaf x1_ x2_)\n       then cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n            freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a +\n            freq (Leaf x1_ x2_) b * depth (Leaf x1_ x2_) b =\n            cost (Leaf x1_ x2_) + w\\<^sub>a * depth (Leaf x1_ x2_) b +\n            w\\<^sub>b * depth (Leaf x1_ x2_) a\n       else cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n            freq (Leaf x1_ x2_) a * depth (Leaf x1_ x2_) a =\n            cost (Leaf x1_ x2_) + w\\<^sub>b * depth (Leaf x1_ x2_) a\n  else if b \\<in> alphabet (Leaf x1_ x2_)\n       then cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) +\n            freq (Leaf x1_ x2_) b * depth (Leaf x1_ x2_) b =\n            cost (Leaf x1_ x2_) + w\\<^sub>a * depth (Leaf x1_ x2_) b\n       else cost (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>b b) =\n            cost (Leaf x1_ x2_)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "case (Node w t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "note c = \\<open>consistent (Node w t\\<^sub>1 t\\<^sub>2)\\<close>"], ["proof (state)\nthis:\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "note hyps = Node"], ["proof (state)\nthis:\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "have w\\<^sub>1: \"if a \\<in> alphabet t\\<^sub>1 then\n              if b \\<in> alphabet t\\<^sub>1 then\n                weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>1 a + freq t\\<^sub>1 b =\n                    weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n                  else\n                weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>1 a = weight t\\<^sub>1 + w\\<^sub>b\n            else\n              if b \\<in> alphabet t\\<^sub>1 then\n                weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>1 b = weight t\\<^sub>1 + w\\<^sub>a\n              else\n                weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) = weight t\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet t\\<^sub>1\n    then if b \\<in> alphabet t\\<^sub>1\n         then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 a +\n              freq t\\<^sub>1 b =\n              weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n         else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 a =\n              weight t\\<^sub>1 + w\\<^sub>b\n    else if b \\<in> alphabet t\\<^sub>1\n         then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 b =\n              weight t\\<^sub>1 + w\\<^sub>a\n         else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n              weight t\\<^sub>1", "using hyps"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet t\\<^sub>1\n    then if b \\<in> alphabet t\\<^sub>1\n         then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 a +\n              freq t\\<^sub>1 b =\n              weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n         else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 a =\n              weight t\\<^sub>1 + w\\<^sub>b\n    else if b \\<in> alphabet t\\<^sub>1\n         then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>1 b =\n              weight t\\<^sub>1 + w\\<^sub>a\n         else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n              weight t\\<^sub>1", "by (simp add: weight_swapLeaves)"], ["proof (state)\nthis:\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "have w\\<^sub>2: \"if a \\<in> alphabet t\\<^sub>2 then\n              if b \\<in> alphabet t\\<^sub>2 then\n                weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>2 a + freq t\\<^sub>2 b =\n                    weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n              else\n                weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>2 a = weight t\\<^sub>2 + w\\<^sub>b\n            else\n              if b \\<in> alphabet t\\<^sub>2 then\n                weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) + freq t\\<^sub>2 b = weight t\\<^sub>2 + w\\<^sub>a\n              else\n                weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) = weight t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet t\\<^sub>2\n    then if b \\<in> alphabet t\\<^sub>2\n         then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 a +\n              freq t\\<^sub>2 b =\n              weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n         else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 a =\n              weight t\\<^sub>2 + w\\<^sub>b\n    else if b \\<in> alphabet t\\<^sub>2\n         then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 b =\n              weight t\\<^sub>2 + w\\<^sub>a\n         else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n              weight t\\<^sub>2", "using hyps"], ["proof (prove)\nusing this:\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet t\\<^sub>2\n    then if b \\<in> alphabet t\\<^sub>2\n         then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 a +\n              freq t\\<^sub>2 b =\n              weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n         else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 a =\n              weight t\\<^sub>2 + w\\<^sub>b\n    else if b \\<in> alphabet t\\<^sub>2\n         then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n              freq t\\<^sub>2 b =\n              weight t\\<^sub>2 + w\\<^sub>a\n         else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n              weight t\\<^sub>2", "by (simp add: weight_swapLeaves)"], ["proof (state)\nthis:\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> if a \\<in> alphabet t1\n                                  then if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b + w\\<^sub>b * depth t1 a\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 a * depth t1 a =\n      cost t1 + w\\<^sub>b * depth t1 a\n                                  else if b \\<in> alphabet t1\n then cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) +\n      freq t1 b * depth t1 b =\n      cost t1 + w\\<^sub>a * depth t1 b\n else cost (swapLeaves t1 w\\<^sub>a a w\\<^sub>b b) = cost t1;\n        \\<lbrakk>consistent t2; a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> if a \\<in> alphabet t2\n                          then if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b +\n                                    w\\<^sub>b * depth t2 a\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 a * depth t2 a =\n                                    cost t2 + w\\<^sub>b * depth t2 a\n                          else if b \\<in> alphabet t2\n                               then cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) +\n                                    freq t2 b * depth t2 b =\n                                    cost t2 + w\\<^sub>a * depth t2 b\n                               else cost\n                                     (swapLeaves t2 w\\<^sub>a a w\\<^sub>b\n b) =\n                                    cost t2;\n        consistent (Node x1 t1 t2); a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> if a \\<in> alphabet (Node x1 t1 t2)\n                         then if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) a *\n                                   depth (Node x1 t1 t2) a =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>b * depth (Node x1 t1 t2) a\n                         else if b \\<in> alphabet (Node x1 t1 t2)\n                              then cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) +\n                                   freq (Node x1 t1 t2) b *\n                                   depth (Node x1 t1 t2) b =\n                                   cost (Node x1 t1 t2) +\n                                   w\\<^sub>a * depth (Node x1 t1 t2) b\n                              else cost\n                                    (swapLeaves (Node x1 t1 t2) w\\<^sub>a a\nw\\<^sub>b b) =\n                                   cost (Node x1 t1 t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume a\\<^sub>1: \"a \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  a \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "hence a\\<^sub>2: \"a \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2", "using c"], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>1\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using c"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<in> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<in> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume a\\<^sub>1: \"a \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume a\\<^sub>2: \"a \\<in> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  a \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using c"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<in> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<in> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume a\\<^sub>2: \"a \\<notin> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<in> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "hence \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "using c"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<in> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume b\\<^sub>1: \"b \\<notin> alphabet t\\<^sub>1\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<in> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)\n 2. \\<not> ?P \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "assume \"b \\<notin> alphabet t\\<^sub>2\""], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "using a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 w\\<^sub>1 w\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  a \\<notin> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>1\n  then if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 a =\n            weight t\\<^sub>1 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>1\n       then weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>1 b =\n            weight t\\<^sub>1 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>1\n  if a \\<in> alphabet t\\<^sub>2\n  then if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a + w\\<^sub>b\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 a =\n            weight t\\<^sub>2 + w\\<^sub>b\n  else if b \\<in> alphabet t\\<^sub>2\n       then weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) +\n            freq t\\<^sub>2 b =\n            weight t\\<^sub>2 + w\\<^sub>a\n       else weight (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b) =\n            weight t\\<^sub>2\n  \\<lbrakk>consistent t\\<^sub>1; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>1\n                    then if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 +\n                              w\\<^sub>a * depth t\\<^sub>1 b +\n                              w\\<^sub>b * depth t\\<^sub>1 a\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 a * depth t\\<^sub>1 a =\n                              cost t\\<^sub>1 + w\\<^sub>b * depth t\\<^sub>1 a\n                    else if b \\<in> alphabet t\\<^sub>1\n                         then cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>1 b * depth t\\<^sub>1 b =\n                              cost t\\<^sub>1 + w\\<^sub>a * depth t\\<^sub>1 b\n                         else cost\n                               (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>1\n  \\<lbrakk>consistent t\\<^sub>2; a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> if a \\<in> alphabet t\\<^sub>2\n                    then if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 +\n                              w\\<^sub>a * depth t\\<^sub>2 b +\n                              w\\<^sub>b * depth t\\<^sub>2 a\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 a * depth t\\<^sub>2 a =\n                              cost t\\<^sub>2 + w\\<^sub>b * depth t\\<^sub>2 a\n                    else if b \\<in> alphabet t\\<^sub>2\n                         then cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) +\n                              freq t\\<^sub>2 b * depth t\\<^sub>2 b =\n                              cost t\\<^sub>2 + w\\<^sub>a * depth t\\<^sub>2 b\n                         else cost\n                               (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>b\n                                 b) =\n                              cost t\\<^sub>2\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n    then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n    else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n         then cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) +\n              freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n              depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n              cost (Node w t\\<^sub>1 t\\<^sub>2) +\n              w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n         else cost\n               (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a\n                 w\\<^sub>b b) =\n              cost (Node w t\\<^sub>1 t\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if a \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n  then if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) a *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) a =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>b * depth (Node w t\\<^sub>1 t\\<^sub>2) a\n  else if b \\<in> alphabet (Node w t\\<^sub>1 t\\<^sub>2)\n       then cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) +\n            freq (Node w t\\<^sub>1 t\\<^sub>2) b *\n            depth (Node w t\\<^sub>1 t\\<^sub>2) b =\n            cost (Node w t\\<^sub>1 t\\<^sub>2) +\n            w\\<^sub>a * depth (Node w t\\<^sub>1 t\\<^sub>2) b\n       else cost\n             (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b\n               b) =\n            cost (Node w t\\<^sub>1 t\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nCommon sense tells us that the following statement is valid: ``If Astrid\nexchanges her house with Bernard's neighbor, Bernard becomes Astrid's new\nneighbor.'' A similar property holds for binary trees.\n\\<close>"], ["", "lemma sibling_swapLeaves_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapLeaves t w\\<^sub>a a w\\<^sub>s (sibling t b)) a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> sibling\n                       (swapLeaves t w\\<^sub>a a w\\<^sub>s (sibling t b))\n                       a =\n                      b", "proof (induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>consistent (Leaf x1 x2); sibling (Leaf x1 x2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Leaf x1 x2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Leaf x1 x2) b))\n                          a =\n                         b\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "case Leaf"], ["proof (state)\nthis:\n  consistent (Leaf x1_ x2_)\n  sibling (Leaf x1_ x2_) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>consistent (Leaf x1 x2); sibling (Leaf x1 x2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Leaf x1 x2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Leaf x1 x2) b))\n                          a =\n                         b\n 2. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "thus ?case"], ["proof (prove)\nusing this:\n  consistent (Leaf x1_ x2_)\n  sibling (Leaf x1_ x2_) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>s\n       (sibling (Leaf x1_ x2_) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Leaf x1_ x2_) w\\<^sub>a a w\\<^sub>s\n     (sibling (Leaf x1_ x2_) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "case (Node w t\\<^sub>1 t\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "note hyps = Node"], ["proof (state)\nthis:\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x1 t1 t2.\n       \\<lbrakk>\\<lbrakk>consistent t1; sibling t1 b \\<noteq> b;\n                 a \\<noteq> b\\<rbrakk>\n                \\<Longrightarrow> sibling\n                                   (swapLeaves t1 w\\<^sub>a a w\\<^sub>s\n                                     (sibling t1 b))\n                                   a =\n                                  b;\n        \\<lbrakk>consistent t2; sibling t2 b \\<noteq> b;\n         a \\<noteq> b\\<rbrakk>\n        \\<Longrightarrow> sibling\n                           (swapLeaves t2 w\\<^sub>a a w\\<^sub>s\n                             (sibling t2 b))\n                           a =\n                          b;\n        consistent (Node x1 t1 t2); sibling (Node x1 t1 t2) b \\<noteq> b;\n        a \\<noteq> b\\<rbrakk>\n       \\<Longrightarrow> sibling\n                          (swapLeaves (Node x1 t1 t2) w\\<^sub>a a w\\<^sub>s\n                            (sibling (Node x1 t1 t2) b))\n                          a =\n                         b", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"height t\\<^sub>1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height t\\<^sub>1 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  height t\\<^sub>1 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>1 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>1 = True"], ["proof (state)\nthis:\n  height t\\<^sub>1 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>1 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases t\\<^sub>1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>1 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case (Leaf w\\<^sub>c c)"], ["proof (state)\nthis:\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>1 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "note l\\<^sub>1 = Leaf"], ["proof (state)\nthis:\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>1 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"height t\\<^sub>2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  height t\\<^sub>2 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>2 = True"], ["proof (state)\nthis:\n  height t\\<^sub>2 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases t\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>2 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case Leaf"], ["proof (state)\nthis:\n  t\\<^sub>2 = Leaf x11_ x12_\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>2 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Leaf x11_ x12_\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using l\\<^sub>1 hyps"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Leaf x11_ x12_\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by auto metis+"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case Node"], ["proof (state)\nthis:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using h\\<^sub>2"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n  height t\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  height t\\<^sub>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>2 = False"], ["proof (state)\nthis:\n  height t\\<^sub>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. \\<not> ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "assume \"c = b\""], ["proof (state)\nthis:\n  c = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. \\<not> ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using l\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  c = b\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. c \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "assume \"c \\<noteq> b\""], ["proof (state)\nthis:\n  c \\<noteq> b\n\ngoal (1 subgoal):\n 1. c \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "have \"sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2", "using \\<open>c \\<noteq> b\\<close> l\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  c \\<noteq> b\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2", "by (simp add: sibling_ne_imp_sibling_in_alphabet)"], ["proof (state)\nthis:\n  sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. c \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using \\<open>c \\<noteq> b\\<close> l\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  sibling t\\<^sub>2 b \\<in> alphabet t\\<^sub>2\n  c \\<noteq> b\n  t\\<^sub>1 = Leaf w\\<^sub>c c\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by auto"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case Node"], ["proof (state)\nthis:\n  t\\<^sub>1 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>1 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>1 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using h\\<^sub>1"], ["proof (prove)\nusing this:\n  t\\<^sub>1 = Node x21_ x22_ x23_\n  height t\\<^sub>1 = 0\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  height t\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>1 = False"], ["proof (state)\nthis:\n  height t\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>1 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"height t\\<^sub>2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  height t\\<^sub>2 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>2 = True"], ["proof (state)\nthis:\n  height t\\<^sub>2 = 0\n\ngoal (2 subgoals):\n 1. height t\\<^sub>2 = 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases t\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>2 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case (Leaf w\\<^sub>d d)"], ["proof (state)\nthis:\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>2 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "note l\\<^sub>2 = Leaf"], ["proof (state)\nthis:\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>2 = Leaf x11 x12 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. \\<not> ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "assume \"d = b\""], ["proof (state)\nthis:\n  d = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. \\<not> ?P \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  d = b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using h\\<^sub>1 l\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  d = b\n  height t\\<^sub>1 \\<noteq> 0\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. d \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "assume \"d \\<noteq> b\""], ["proof (state)\nthis:\n  d \\<noteq> b\n\ngoal (1 subgoal):\n 1. d \\<noteq> b \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"b \\<in> alphabet t\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "hence \"sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1\""], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1", "using \\<open>d \\<noteq> b\\<close> h\\<^sub>1 l\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  d \\<noteq> b\n  height t\\<^sub>1 \\<noteq> 0\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1", "by (simp add: sibling_ne_imp_sibling_in_alphabet)"], ["proof (state)\nthis:\n  sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using True \\<open>d \\<noteq> b\\<close> h\\<^sub>1 l\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  sibling t\\<^sub>1 b \\<in> alphabet t\\<^sub>1\n  b \\<in> alphabet t\\<^sub>1\n  d \\<noteq> b\n  height t\\<^sub>1 \\<noteq> 0\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by (simp add: alphabet_swapLeaves)"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using \\<open>d \\<noteq> b\\<close> l\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>1\n  d \\<noteq> b\n  t\\<^sub>2 = Leaf w\\<^sub>d d\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "case Node"], ["proof (state)\nthis:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>2 = Node x21 x22 x23 \\<Longrightarrow>\n       sibling\n        (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n          (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n        a =\n       b", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using h\\<^sub>2"], ["proof (prove)\nusing this:\n  t\\<^sub>2 = Node x21_ x22_ x23_\n  height t\\<^sub>2 = 0\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  height t\\<^sub>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note h\\<^sub>2 = False"], ["proof (state)\nthis:\n  height t\\<^sub>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height t\\<^sub>2 \\<noteq> 0 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"b \\<in> alphabet t\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using h\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>1\n  height t\\<^sub>1 \\<noteq> 0\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by auto"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "note b\\<^sub>1 = False"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "proof (cases \"b \\<in> alphabet t\\<^sub>2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case True"], ["proof (state)\nthis:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. b \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b\n 2. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using b\\<^sub>1 h\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<in> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  height t\\<^sub>1 \\<noteq> 0\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by (auto simp: in_alphabet_imp_sibling_in_alphabet\n                           alphabet_swapLeaves)"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "case False"], ["proof (state)\nthis:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. b \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "using b\\<^sub>1 h\\<^sub>1 h\\<^sub>2 hyps"], ["proof (prove)\nusing this:\n  b \\<notin> alphabet t\\<^sub>2\n  b \\<notin> alphabet t\\<^sub>1\n  height t\\<^sub>1 \\<noteq> 0\n  height t\\<^sub>2 \\<noteq> 0\n  \\<lbrakk>consistent t\\<^sub>1; sibling t\\<^sub>1 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>1 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>1 b))\n                     a =\n                    b\n  \\<lbrakk>consistent t\\<^sub>2; sibling t\\<^sub>2 b \\<noteq> b;\n   a \\<noteq> b\\<rbrakk>\n  \\<Longrightarrow> sibling\n                     (swapLeaves t\\<^sub>2 w\\<^sub>a a w\\<^sub>s\n                       (sibling t\\<^sub>2 b))\n                     a =\n                    b\n  consistent (Node w t\\<^sub>1 t\\<^sub>2)\n  sibling (Node w t\\<^sub>1 t\\<^sub>2) b \\<noteq> b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. sibling\n     (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n       (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n     a =\n    b", "by simp"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling\n   (swapLeaves (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>s\n     (sibling (Node w t\\<^sub>1 t\\<^sub>2) b))\n   a =\n  b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Symbol Interchange\\<close>"], ["", "text \\<open>\nThe \\<open>swapSyms\\<close> function provides a simpler interface to\n@{const swapLeaves}, with @{term \"freq t a\"} and @{term \"freq t b\"} in place of\n@{term \"w\\<^sub>a\"} and @{term \"w\\<^sub>b\"}. Most lemmas about \\<open>swapSyms\\<close> are directly\nadapted from the homologous results about @{const swapLeaves}.\n\\<close>"], ["", "definition swapSyms :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a tree\" where\n\"swapSyms t a b = swapLeaves t (freq t a) a (freq t b) b\""], ["", "lemma swapSyms_id[simp]:\n\"consistent t \\<Longrightarrow> swapSyms t a a = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> swapSyms t a a = t", "by (simp add: swapSyms_def)"], ["", "lemma alphabet_swapSyms[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk> \\<Longrightarrow> alphabet (swapSyms t a b) = alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> alphabet (swapSyms t a b) = alphabet t", "by (simp add: swapSyms_def alphabet_swapLeaves)"], ["", "lemma consistent_swapSyms[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapSyms t a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> consistent (swapSyms t a b)", "by (simp add: swapSyms_def)"], ["", "lemma depth_swapSyms_neither[simp]:\n\"\\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n depth (swapSyms t a b) c = depth t c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; c \\<noteq> a; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> depth (swapSyms t a b) c = depth t c", "by (simp add: swapSyms_def)"], ["", "lemma freq_swapSyms[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (swapSyms t a b) = freq t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> freq (swapSyms t a b) = freq t", "by (case_tac \"a = b\") (simp add: swapSyms_def ext)+"], ["", "lemma cost_swapSyms:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\"\nshows \"cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n           cost t + freq t a * depth t b + freq t b * depth t a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a\n 2. \\<not> ?P \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "assume \"a = b\""], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a\n 2. \\<not> ?P \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "using assms"], ["proof (prove)\nusing this:\n  a = b\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "by simp"], ["proof (state)\nthis:\n  cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n  cost t + freq t a * depth t b + freq t b * depth t a\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "assume \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "hence \"cost (swapLeaves t (freq t a) a (freq t b) b)\n    + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. cost (swapLeaves t (freq t a) a (freq t b) b) + freq t a * depth t a +\n    freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n\ngoal (1 subgoal):\n 1. cost (swapLeaves t (freq t a) a (freq t b) b) + freq t a * depth t a +\n    freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "by (simp add: cost_swapLeaves)"], ["proof (state)\nthis:\n  cost (swapLeaves t (freq t a) a (freq t b) b) + freq t a * depth t a +\n  freq t b * depth t b =\n  cost t + freq t a * depth t b + freq t b * depth t a\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "thus ?thesis"], ["proof (prove)\nusing this:\n  cost (swapLeaves t (freq t a) a (freq t b) b) + freq t a * depth t a +\n  freq t b * depth t b =\n  cost t + freq t a * depth t b + freq t b * depth t a\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "using assms"], ["proof (prove)\nusing this:\n  cost (swapLeaves t (freq t a) a (freq t b) b) + freq t a * depth t a +\n  freq t b * depth t b =\n  cost t + freq t a * depth t b + freq t b * depth t a\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n    cost t + freq t a * depth t b + freq t b * depth t a", "by (simp add: swapSyms_def)"], ["proof (state)\nthis:\n  cost (swapSyms t a b) + freq t a * depth t a + freq t b * depth t b =\n  cost t + freq t a * depth t b + freq t b * depth t a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIf $a$'s frequency is lower than or equal to $b$'s, and $a$ is higher up in the\ntree than $b$ or at the same level, then interchanging $a$ and $b$ does not\nincrease the tree's cost.\n\\<close>"], ["", "lemma le_le_imp_sum_mult_le_sum_mult:\nassumes \"i \\<le> j\" \"m \\<le> (n::nat)\"\nshows \"i * n + j * m \\<le> i * m + j * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i * n + j * m \\<le> i * m + j * n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i * n + j * m \\<le> i * m + j * n", "have \"i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)", "by simp"], ["proof (state)\nthis:\n  i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)\n\ngoal (1 subgoal):\n 1. i * n + j * m \\<le> i * m + j * n", "thus ?thesis"], ["proof (prove)\nusing this:\n  i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)\n\ngoal (1 subgoal):\n 1. i * n + j * m \\<le> i * m + j * n", "using assms"], ["proof (prove)\nusing this:\n  i * m + i * (n - m) + j * m \\<le> i * m + j * m + j * (n - m)\n  i \\<le> j\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. i * n + j * m \\<le> i * m + j * n", "by (simp add: diff_mult_distrib2)"], ["proof (state)\nthis:\n  i * n + j * m \\<le> i * m + j * n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cost_swapSyms_le:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\" \"freq t a \\<le> freq t b\"\n        \"depth t a \\<le> depth t b\"\nshows \"cost (swapSyms t a b) \\<le> cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "let ?aabb = \"freq t a * depth t a + freq t b * depth t b\""], ["proof (state)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "let ?abba = \"freq t a * depth t b + freq t b * depth t a\""], ["proof (state)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "have \"?abba \\<le> ?aabb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freq t a * depth t b + freq t b * depth t a\n    \\<le> freq t a * depth t a + freq t b * depth t b", "using assms(4-5)"], ["proof (prove)\nusing this:\n  freq t a \\<le> freq t b\n  depth t a \\<le> depth t b\n\ngoal (1 subgoal):\n 1. freq t a * depth t b + freq t b * depth t a\n    \\<le> freq t a * depth t a + freq t b * depth t b", "by (rule le_le_imp_sum_mult_le_sum_mult)"], ["proof (state)\nthis:\n  freq t a * depth t b + freq t b * depth t a\n  \\<le> freq t a * depth t a + freq t b * depth t b\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "have \"cost (swapSyms t a b) + ?aabb = cost t + ?abba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b) =\n    cost t + (freq t a * depth t b + freq t b * depth t a)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b) =\n    cost t + (freq t a * depth t b + freq t b * depth t a)", "by (simp add: cost_swapSyms add.assoc[THEN sym])"], ["proof (state)\nthis:\n  cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b) =\n  cost t + (freq t a * depth t b + freq t b * depth t a)\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "also"], ["proof (state)\nthis:\n  cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b) =\n  cost t + (freq t a * depth t b + freq t b * depth t a)\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "have \"\\<dots> \\<le> cost t + ?aabb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost t + (freq t a * depth t b + freq t b * depth t a)\n    \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)", "using \\<open>?abba \\<le> ?aabb\\<close>"], ["proof (prove)\nusing this:\n  freq t a * depth t b + freq t b * depth t a\n  \\<le> freq t a * depth t a + freq t b * depth t b\n\ngoal (1 subgoal):\n 1. cost t + (freq t a * depth t b + freq t b * depth t a)\n    \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)", "by simp"], ["proof (state)\nthis:\n  cost t + (freq t a * depth t b + freq t b * depth t a)\n  \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "finally"], ["proof (chain)\npicking this:\n  cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b)\n  \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b)\n  \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "using assms(4-5)"], ["proof (prove)\nusing this:\n  cost (swapSyms t a b) + (freq t a * depth t a + freq t b * depth t b)\n  \\<le> cost t + (freq t a * depth t a + freq t b * depth t b)\n  freq t a \\<le> freq t b\n  depth t a \\<le> depth t b\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a b) \\<le> cost t", "by simp"], ["proof (state)\nthis:\n  cost (swapSyms t a b) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nAs stated earlier, ``If Astrid exchanges her house with Bernard's neighbor,\nBernard becomes Astrid's new neighbor.''\n\\<close>"], ["", "lemma sibling_swapSyms_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapSyms t a (sibling t b)) a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> sibling (swapSyms t a (sibling t b)) a = b", "by (simp add: swapSyms_def)"], ["", "text \\<open>\n``If Astrid exchanges her house with Bernard, Astrid becomes Bernard's old\nneighbor's new neighbor.''\n\\<close>"], ["", "lemma sibling_swapSyms_other_sibling[simp]:\n\"\\<lbrakk>consistent t; sibling t b \\<noteq> a; sibling t b \\<noteq> b; a \\<noteq> b\\<rbrakk> \\<Longrightarrow>\n sibling (swapSyms t a b) (sibling t b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; sibling t b \\<noteq> a; sibling t b \\<noteq> b;\n     a \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> sibling (swapSyms t a b) (sibling t b) = a", "by (metis consistent_swapSyms sibling_swapSyms_sibling sibling_reciprocal)"], ["", "subsection \\<open>Four-Way Symbol Interchange \\label{four-way-symbol-interchange}\\<close>"], ["", "text \\<open>\nThe @{const swapSyms} function exchanges two symbols $a$ and $b$. We use it\nto define the four-way symbol interchange function \\<open>swapFourSyms\\<close>, which\ntakes four symbols $a$, $b$, $c$, $d$ with $a \\ne b$ and $c \\ne d$, and\nexchanges them so that $a$ and $b$ occupy $c$~and~$d$'s positions.\n\nA naive definition of this function would be\n$$@{prop \"swapFourSyms t a b c d = swapSyms (swapSyms t a c) b d\"}.$$\nThis definition fails in the face of aliasing: If $a = d$, but\n$b \\ne c$, then \\<open>swapFourSyms a b c d\\<close> would leave $a$ in $b$'s\nposition.%\n\\footnote{Cormen et al.\\ \\cite[p.~390]{cormen-et-al-2001} forgot to consider\nthis case in their proof. Thomas Cormen indicated in a personal communication\nthat this will be corrected in the next edition of the book.}\n\\<close>"], ["", "definition swapFourSyms :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a tree\" where\n\"swapFourSyms t a b c d =\n (if a = d then swapSyms t b c\n  else if b = c then swapSyms t a d\n  else swapSyms (swapSyms t a c) b d)\""], ["", "text \\<open>\nLemmas about @{const swapFourSyms} are easy to prove by expanding its\ndefinition.\n\\<close>"], ["", "lemma alphabet_swapFourSyms[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t; c \\<in> alphabet t; d \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n alphabet (swapFourSyms t a b c d) = alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> alphabet t; b \\<in> alphabet t; c \\<in> alphabet t;\n     d \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> alphabet (swapFourSyms t a b c d) = alphabet t", "by (simp add: swapFourSyms_def)"], ["", "lemma consistent_swapFourSyms[simp]:\n\"consistent t \\<Longrightarrow> consistent (swapFourSyms t a b c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> consistent (swapFourSyms t a b c d)", "by (simp add: swapFourSyms_def)"], ["", "lemma freq_swapFourSyms[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t; c \\<in> alphabet t;\n  d \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (swapFourSyms t a b c d) = freq t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t; b \\<in> alphabet t;\n     c \\<in> alphabet t; d \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> freq (swapFourSyms t a b c d) = freq t", "by (auto simp: swapFourSyms_def)"], ["", "text \\<open>\n``If Astrid and Bernard exchange their houses with Carmen and her neighbor,\nAstrid and Bernard will now be neighbors.''\n\\<close>"], ["", "lemma sibling_swapFourSyms_when_4th_is_sibling:\nassumes \"consistent t\" \"a \\<in> alphabet t\" \"b \\<in> alphabet t\" \"c \\<in> alphabet t\"\n        \"a \\<noteq> b\" \"sibling t c \\<noteq> c\"\nshows \"sibling (swapFourSyms t a b c (sibling t c)) a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "proof (cases \"a \\<noteq> sibling t c \\<and> b \\<noteq> c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> sibling t c \\<and> b \\<noteq> c \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b\n 2. \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c) \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b", "case True"], ["proof (state)\nthis:\n  a \\<noteq> sibling t c \\<and> b \\<noteq> c\n\ngoal (2 subgoals):\n 1. a \\<noteq> sibling t c \\<and> b \\<noteq> c \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b\n 2. \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c) \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "let ?d = \"sibling t c\""], ["proof (state)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "let ?t\\<^sub>s = \"swapFourSyms t a b c ?d\""], ["proof (state)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "have abba: \"(sibling ?t\\<^sub>s a = b) = (sibling ?t\\<^sub>s b = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sibling (swapFourSyms t a b c (sibling t c)) a = b) =\n    (sibling (swapFourSyms t a b c (sibling t c)) b = a)", "using \\<open>consistent t\\<close>"], ["proof (prove)\nusing this:\n  consistent t\n\ngoal (1 subgoal):\n 1. (sibling (swapFourSyms t a b c (sibling t c)) a = b) =\n    (sibling (swapFourSyms t a b c (sibling t c)) b = a)", "by (metis consistent_swapFourSyms sibling_reciprocal)"], ["proof (state)\nthis:\n  (sibling (swapFourSyms t a b c (sibling t c)) a = b) =\n  (sibling (swapFourSyms t a b c (sibling t c)) b = a)\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "have s: \"sibling t c = sibling (swapSyms t a c) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling t c = sibling (swapSyms t a c) a", "using True assms"], ["proof (prove)\nusing this:\n  a \\<noteq> sibling t c \\<and> b \\<noteq> c\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n  c \\<in> alphabet t\n  a \\<noteq> b\n  sibling t c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling t c = sibling (swapSyms t a c) a", "by (metis sibling_reciprocal sibling_swapSyms_sibling)"], ["proof (state)\nthis:\n  sibling t c = sibling (swapSyms t a c) a\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "have \"sibling ?t\\<^sub>s b = sibling (swapSyms t a c) ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) b =\n    sibling (swapSyms t a c) (sibling t c)", "using s True assms"], ["proof (prove)\nusing this:\n  sibling t c = sibling (swapSyms t a c) a\n  a \\<noteq> sibling t c \\<and> b \\<noteq> c\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n  c \\<in> alphabet t\n  a \\<noteq> b\n  sibling t c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) b =\n    sibling (swapSyms t a c) (sibling t c)", "by (auto simp: swapFourSyms_def)"], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) b =\n  sibling (swapSyms t a c) (sibling t c)\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "also"], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) b =\n  sibling (swapSyms t a c) (sibling t c)\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "have \"\\<dots> = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling (swapSyms t a c) (sibling t c) = a", "using True assms"], ["proof (prove)\nusing this:\n  a \\<noteq> sibling t c \\<and> b \\<noteq> c\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n  c \\<in> alphabet t\n  a \\<noteq> b\n  sibling t c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling (swapSyms t a c) (sibling t c) = a", "by (metis sibling_reciprocal sibling_swapSyms_other_sibling swapLeaves_id swapSyms_def)"], ["proof (state)\nthis:\n  sibling (swapSyms t a c) (sibling t c) = a\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "finally"], ["proof (chain)\npicking this:\n  sibling (swapFourSyms t a b c (sibling t c)) b = a", "have \"sibling ?t\\<^sub>s b = a\""], ["proof (prove)\nusing this:\n  sibling (swapFourSyms t a b c (sibling t c)) b = a\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) b = a", "."], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) b = a\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "with abba"], ["proof (chain)\npicking this:\n  (sibling (swapFourSyms t a b c (sibling t c)) a = b) =\n  (sibling (swapFourSyms t a b c (sibling t c)) b = a)\n  sibling (swapFourSyms t a b c (sibling t c)) b = a", "show ?thesis"], ["proof (prove)\nusing this:\n  (sibling (swapFourSyms t a b c (sibling t c)) a = b) =\n  (sibling (swapFourSyms t a b c (sibling t c)) b = a)\n  sibling (swapFourSyms t a b c (sibling t c)) b = a\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", ".."], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) a = b\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c) \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c) \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b", "case False"], ["proof (state)\nthis:\n  \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c)\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c) \\<Longrightarrow>\n    sibling (swapFourSyms t a b c (sibling t c)) a = b", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c)\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (a \\<noteq> sibling t c \\<and> b \\<noteq> c)\n  consistent t\n  a \\<in> alphabet t\n  b \\<in> alphabet t\n  c \\<in> alphabet t\n  a \\<noteq> b\n  sibling t c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms t a b c (sibling t c)) a = b", "by (auto intro: sibling_reciprocal simp: swapFourSyms_def)"], ["proof (state)\nthis:\n  sibling (swapFourSyms t a b c (sibling t c)) a = b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sibling Merge\\<close>"], ["", "text \\<open>\nGiven a symbol $a$, the \\<open>mergeSibling\\<close> function transforms the tree\n%\n\\setbox\\myboxi=\\hbox{\\includegraphics[scale=1.25]{tree-splitLeaf-a.pdf}}%\n\\setbox\\myboxii=\\hbox{\\includegraphics[scale=1.25]{tree-splitLeaf-ab.pdf}}%\n\\mydimeni=\\ht\\myboxii\n$$\\vcenter{\\box\\myboxii}\n  \\qquad \\hbox{into} \\qquad\n  \\smash{\\lower\\ht\\myboxi\\hbox{\\raise.5\\mydimeni\\box\\myboxi}}$$\nThe frequency of $a$ in the result is the sum of the original frequencies of\n$a$ and $b$, so as not to alter the tree's weight.\n\\<close>"], ["", "fun mergeSibling :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> 'a tree\" where\n\"mergeSibling (Leaf w\\<^sub>b b) a = Leaf w\\<^sub>b b\" |\n\"mergeSibling (Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c)) a =\n     (if a = b \\<or> a = c then Leaf (w\\<^sub>b + w\\<^sub>c) a\n      else Node w (Leaf w\\<^sub>b b) (Leaf w\\<^sub>c c))\" |\n\"mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\""], ["", "text \\<open>\nThe definition of @{const mergeSibling} has essentially the same structure as\nthat of @{const sibling}. As a result, the custom induction rule that we\nderived for @{const sibling} works equally well for reasoning about\n@{const mergeSibling}.\n\\<close>"], ["", "lemmas mergeSibling_induct_consistent = sibling_induct_consistent"], ["", "text \\<open>\nThe properties of @{const mergeSibling} echo those of @{const sibling}. Like\nwith @{const sibling}, simplification rules are crucial.\n\\<close>"], ["", "lemma notin_alphabet_imp_mergeSibling_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> mergeSibling t a = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t \\<Longrightarrow> mergeSibling t a = t", "by (induct t a rule: mergeSibling.induct) simp+"], ["", "lemma height_gt_0_imp_mergeSibling_left[simp]:\n\"height t\\<^sub>1 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height t\\<^sub>1 \\<Longrightarrow>\n    mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n    Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)", "by (case_tac t\\<^sub>1) simp+"], ["", "lemma height_gt_0_imp_mergeSibling_right[simp]:\n\"height t\\<^sub>2 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height t\\<^sub>2 \\<Longrightarrow>\n    mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n    Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)", "by (case_tac t\\<^sub>2) simp+"], ["", "lemma either_height_gt_0_imp_mergeSibling[simp]:\n\"height t\\<^sub>1 > 0 \\<or> height t\\<^sub>2 > 0 \\<Longrightarrow>\n mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n     Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < height t\\<^sub>1 \\<or> 0 < height t\\<^sub>2 \\<Longrightarrow>\n    mergeSibling (Node w t\\<^sub>1 t\\<^sub>2) a =\n    Node w (mergeSibling t\\<^sub>1 a) (mergeSibling t\\<^sub>2 a)", "by auto"], ["", "lemma alphabet_mergeSibling[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t\\<rbrakk> \\<Longrightarrow>\n alphabet (mergeSibling t a) = (alphabet t - {sibling t a}) \\<union> {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t\\<rbrakk>\n    \\<Longrightarrow> alphabet (mergeSibling t a) =\n                      alphabet t - {sibling t a} \\<union> {a}", "by (induct t a rule: mergeSibling_induct_consistent) auto"], ["", "lemma consistent_mergeSibling[simp]:\n\"consistent t \\<Longrightarrow> consistent (mergeSibling t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent t \\<Longrightarrow> consistent (mergeSibling t a)", "by (induct t a rule: mergeSibling_induct_consistent) auto"], ["", "lemma freq_mergeSibling:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; sibling t a \\<noteq> a\\<rbrakk> \\<Longrightarrow>\n freq (mergeSibling t a) =\n     (\\<lambda>c. if c = a then freq t a + freq t (sibling t a)\n          else if c = sibling t a then 0\n          else freq t c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t;\n     sibling t a \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> freq (mergeSibling t a) =\n                      (\\<lambda>c.\n                          if c = a then freq t a + freq t (sibling t a)\n                          else if c = sibling t a then 0 else freq t c)", "by (induct t a rule: mergeSibling_induct_consistent) (auto simp: fun_eq_iff)"], ["", "lemma weight_mergeSibling[simp]:\n\"weight (mergeSibling t a) = weight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight (mergeSibling t a) = weight t", "by (induct t a rule: mergeSibling.induct) simp+"], ["", "text \\<open>\nIf $a$ has a sibling, merging $a$ and its sibling reduces $t$'s cost by\n@{term \"freq t a + freq t (sibling t a)\"}.\n\\<close>"], ["", "lemma cost_mergeSibling:\n\"\\<lbrakk>consistent t; sibling t a \\<noteq> a\\<rbrakk> \\<Longrightarrow>\n cost (mergeSibling t a) + freq t a + freq t (sibling t a) = cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; sibling t a \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> cost (mergeSibling t a) + freq t a +\n                      freq t (sibling t a) =\n                      cost t", "by (induct t a rule: mergeSibling_induct_consistent) auto"], ["", "subsection \\<open>Leaf Split\\<close>"], ["", "text \\<open>\nThe \\<open>splitLeaf\\<close> function undoes the merging performed by\n@{const mergeSibling}: Given two symbols $a$, $b$ and two frequencies\n$@{term w\\<^sub>a}$, $@{term w\\<^sub>b}$, it transforms\n\\setbox\\myboxi=\\hbox{\\includegraphics[scale=1.25]{tree-splitLeaf-a.pdf}}%\n\\setbox\\myboxii=\\hbox{\\includegraphics[scale=1.25]{tree-splitLeaf-ab.pdf}}%\n$$\\smash{\\lower\\ht\\myboxi\\hbox{\\raise.5\\ht\\myboxii\\box\\myboxi}}\n  \\qquad \\hbox{into} \\qquad\n  \\vcenter{\\box\\myboxii}$$\nIn the resulting tree, $a$ has frequency @{term w\\<^sub>a} and $b$ has frequency\n@{term w\\<^sub>b}. We normally invoke it with @{term w\\<^sub>a}~and @{term w\\<^sub>b} such that\n@{prop \"freq t a = w\\<^sub>a + w\\<^sub>b\"}.\n\\<close>"], ["", "primrec splitLeaf :: \"'a tree \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a tree\" where\n\"splitLeaf (Leaf w\\<^sub>c c) w\\<^sub>a a w\\<^sub>b b =\n (if c = a then Node w\\<^sub>c (Leaf w\\<^sub>a a) (Leaf w\\<^sub>b b) else Leaf w\\<^sub>c c)\" |\n\"splitLeaf (Node w t\\<^sub>1 t\\<^sub>2) w\\<^sub>a a w\\<^sub>b b =\n Node w (splitLeaf t\\<^sub>1 w\\<^sub>a a w\\<^sub>b b) (splitLeaf t\\<^sub>2 w\\<^sub>a a w\\<^sub>b b)\""], ["", "primrec splitLeaf\\<^sub>F :: \"'a forest \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a forest\" where\n\"splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b = []\" |\n\"splitLeaf\\<^sub>F (t # ts) w\\<^sub>a a w\\<^sub>b b =\n     splitLeaf t w\\<^sub>a a w\\<^sub>b b # splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b\""], ["", "text \\<open>\nSplitting leaf nodes affects the alphabet, consistency, symbol frequencies,\nweight, and cost in unsurprising ways.\n\\<close>"], ["", "lemma notin_alphabet_imp_splitLeaf_id[simp]:\n\"a \\<notin> alphabet t \\<Longrightarrow> splitLeaf t w\\<^sub>a a w\\<^sub>b b = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t \\<Longrightarrow>\n    splitLeaf t w\\<^sub>a a w\\<^sub>b b = t", "by (induct t) simp+"], ["", "lemma notin_alphabet\\<^sub>F_imp_splitLeaf\\<^sub>F_id[simp]:\n\"a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow> splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F ts \\<Longrightarrow>\n    splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b = ts", "by (induct ts) simp+"], ["", "lemma alphabet_splitLeaf[simp]:\n\"alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n (if a \\<in> alphabet t then alphabet t \\<union> {b} else alphabet t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n    (if a \\<in> alphabet t then alphabet t \\<union> {b} else alphabet t)", "by (induct t) simp+"], ["", "lemma consistent_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk> \\<Longrightarrow> consistent (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk>\n    \\<Longrightarrow> consistent (splitLeaf t w\\<^sub>a a w\\<^sub>b b)", "by (induct t) auto"], ["", "lemma freq_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk> \\<Longrightarrow>\n freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n (if a \\<in> alphabet t then (\\<lambda>c. if c = a then w\\<^sub>a else if c = b then w\\<^sub>b else freq t c)\n  else freq t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; b \\<notin> alphabet t\\<rbrakk>\n    \\<Longrightarrow> freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n                      (if a \\<in> alphabet t\n                       then \\<lambda>c.\n                               if c = a then w\\<^sub>a\n                               else if c = b then w\\<^sub>b else freq t c\n                       else freq t)", "by (induct t b rule: tree_induct_consistent) (rule ext, auto)+"], ["", "lemma weight_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n weight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = weight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t;\n     freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> weight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n                      weight t", "by (induct t a rule: tree_induct_consistent) simp+"], ["", "lemma cost_splitLeaf[simp]:\n\"\\<lbrakk>consistent t; a \\<in> alphabet t; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = cost t + w\\<^sub>a + w\\<^sub>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent t; a \\<in> alphabet t;\n     freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n                      cost t + w\\<^sub>a + w\\<^sub>b", "by (induct t a rule: tree_induct_consistent) simp+"], ["", "subsection \\<open>Weight Sort Order\\<close>"], ["", "text \\<open>\nAn invariant of Huffman's algorithm is that the forest is sorted by weight.\nThis is expressed by the \\<open>sortedByWeight\\<close> function.\n\\<close>"], ["", "fun sortedByWeight :: \"'a forest \\<Rightarrow> bool\" where\n\"sortedByWeight [] = True\" |\n\"sortedByWeight [t] = True\" |\n\"sortedByWeight (t\\<^sub>1 # t\\<^sub>2 # ts) =\n (weight t\\<^sub>1 \\<le> weight t\\<^sub>2 \\<and> sortedByWeight (t\\<^sub>2 # ts))\""], ["", "text \\<open>\nThe function obeys the following fairly obvious laws.\n\\<close>"], ["", "lemma sortedByWeight_Cons_imp_sortedByWeight:\n\"sortedByWeight (t # ts) \\<Longrightarrow> sortedByWeight ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sortedByWeight (t # ts) \\<Longrightarrow> sortedByWeight ts", "by (case_tac ts) simp+"], ["", "lemma sortedByWeight_Cons_imp_forall_weight_ge:\n\"sortedByWeight (t # ts) \\<Longrightarrow> \\<forall>u \\<in> set ts. weight u \\<ge> weight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sortedByWeight (t # ts) \\<Longrightarrow>\n    \\<forall>u\\<in>set ts. weight t \\<le> weight u", "by (induct ts arbitrary: t) force+"], ["", "lemma sortedByWeight_insortTree:\n\"\\<lbrakk>sortedByWeight ts; height t = 0; height\\<^sub>F ts = 0\\<rbrakk> \\<Longrightarrow>\n sortedByWeight (insortTree t ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sortedByWeight ts; height t = 0; height\\<^sub>F ts = 0\\<rbrakk>\n    \\<Longrightarrow> sortedByWeight (insortTree t ts)", "by (induct ts rule: sortedByWeight.induct) auto"], ["", "subsection \\<open>Pair of Minimal Symbols\\<close>"], ["", "text \\<open>\nThe \\<open>minima\\<close> predicate expresses that two symbols\n$a$, $b \\in @{term \"alphabet t\"}$ have the lowest frequencies in the tree $t$.\nMinimal symbols need not be uniquely defined.\n\\<close>"], ["", "definition minima :: \"'a tree \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n\"minima t a b =\n (a \\<in> alphabet t \\<and> b \\<in> alphabet t \\<and> a \\<noteq> b\n  \\<and> (\\<forall>c \\<in> alphabet t. c \\<noteq> a \\<longrightarrow> c \\<noteq> b \\<longrightarrow>\n    freq t c \\<ge> freq t a \\<and> freq t c \\<ge> freq t b))\""], ["", "section \\<open>Formalization of the Textbook Proof \\label{formalization}\\<close>"], ["", "subsection \\<open>Four-Way Symbol Interchange Cost Lemma\\<close>"], ["", "text \\<open>\nIf $a$ and $b$ are minima, and $c$ and $d$ are at the very bottom of the tree,\nthen exchanging $a$ and $b$ with $c$ and $d$ does not increase the cost.\nGraphically, we have\\strut\n%\n$${\\it cost\\/}\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-minima-abcd.pdf}}}\n  \\,\\mathop{\\le}\\;\\;\\;\n  {\\it cost\\/}\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-minima.pdf}}}$$\n\n\\noindent\nThis cost property is part of Knuth's proof:\n\n\\begin{quote}\nLet $V$ be an internal node of maximum distance from the root. If $w_1$ and\n$w_2$ are not the weights already attached to the children of $V$, we can\ninterchange them with the values that are already there; such an interchange\ndoes not increase the weighted path length.\n\\end{quote}\n\n\\noindent\nLemma~16.2 in Cormen et al.~\\cite[p.~389]{cormen-et-al-2001} expresses a\nsimilar property, which turns out to be a corollary of our cost property:\n\n\\begin{quote}\nLet $C$ be an alphabet in which each character $c \\in C$ has frequency $f[c]$.\nLet $x$ and $y$ be two characters in $C$ having the lowest frequencies. Then\nthere exists an optimal prefix code for $C$ in which the codewords for $x$ and\n$y$ have the same length and differ only in the last bit.\n\\end{quote}\n\n\\vskip-.75\\myskipamount\n\\<close>"], ["", "lemma cost_swapFourSyms_le:\nassumes\n  \"consistent t\" \"minima t a b\" \"c \\<in> alphabet t\" \"d \\<in> alphabet t\"\n  \"depth t c = height t\" \"depth t d = height t\" \"c \\<noteq> d\"\nshows \"cost (swapFourSyms t a b c d) \\<le> cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "note lems = swapFourSyms_def minima_def cost_swapSyms_le depth_le_height"], ["proof (state)\nthis:\n  swapFourSyms ?t ?a ?b ?c ?d =\n  (if ?a = ?d then swapSyms ?t ?b ?c\n   else if ?b = ?c then swapSyms ?t ?a ?d\n        else swapSyms (swapSyms ?t ?a ?c) ?b ?d)\n  minima ?t ?a ?b =\n  (?a \\<in> alphabet ?t \\<and>\n   ?b \\<in> alphabet ?t \\<and>\n   ?a \\<noteq> ?b \\<and>\n   (\\<forall>c\\<in>alphabet ?t.\n       c \\<noteq> ?a \\<longrightarrow>\n       c \\<noteq> ?b \\<longrightarrow>\n       freq ?t ?a \\<le> freq ?t c \\<and> freq ?t ?b \\<le> freq ?t c))\n  \\<lbrakk>consistent ?t; ?a \\<in> alphabet ?t; ?b \\<in> alphabet ?t;\n   freq ?t ?a \\<le> freq ?t ?b; depth ?t ?a \\<le> depth ?t ?b\\<rbrakk>\n  \\<Longrightarrow> cost (swapSyms ?t ?a ?b) \\<le> cost ?t\n  depth ?t ?a \\<le> height ?t\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "proof (cases \"a \\<noteq> d \\<and> b \\<noteq> c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> d \\<and> b \\<noteq> c \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> (a \\<noteq> d \\<and> b \\<noteq> c) \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "case True"], ["proof (state)\nthis:\n  a \\<noteq> d \\<and> b \\<noteq> c\n\ngoal (2 subgoals):\n 1. a \\<noteq> d \\<and> b \\<noteq> c \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> (a \\<noteq> d \\<and> b \\<noteq> c) \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"a = c\""], ["proof (state)\nthis:\n  a = c\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"b = d\""], ["proof (state)\nthis:\n  b = d\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "using \\<open>a = c\\<close> True assms"], ["proof (prove)\nusing this:\n  b = d\n  a = c\n  a \\<noteq> d \\<and> b \\<noteq> c\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "by (simp add: lems)"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"b \\<noteq> d\""], ["proof (state)\nthis:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "using \\<open>a = c\\<close> True assms"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n  a = c\n  a \\<noteq> d \\<and> b \\<noteq> c\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "by (simp add: lems)"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"a \\<noteq> c\""], ["proof (state)\nthis:\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. a \\<noteq> c \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"b = d\""], ["proof (state)\nthis:\n  b = d\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t\n 2. \\<not> ?P \\<Longrightarrow> cost (swapFourSyms t a b c d) \\<le> cost t", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "using \\<open>a \\<noteq> c\\<close> True assms"], ["proof (prove)\nusing this:\n  b = d\n  a \\<noteq> c\n  a \\<noteq> d \\<and> b \\<noteq> c\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "by (simp add: lems)"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "assume \"b \\<noteq> d\""], ["proof (state)\nthis:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "have \"cost (swapFourSyms t a b c d) \\<le> cost (swapSyms t a c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost (swapSyms t a c)", "using \\<open>b \\<noteq> d\\<close> \\<open>a \\<noteq> c\\<close> True assms"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n  a \\<noteq> c\n  a \\<noteq> d \\<and> b \\<noteq> c\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost (swapSyms t a c)", "by (clarsimp simp: lems)"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost (swapSyms t a c)\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "also"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost (swapSyms t a c)\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "have \"\\<dots> \\<le> cost t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapSyms t a c) \\<le> cost t", "using \\<open>b \\<noteq> d\\<close> \\<open>a \\<noteq> c\\<close> True assms"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n  a \\<noteq> c\n  a \\<noteq> d \\<and> b \\<noteq> c\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapSyms t a c) \\<le> cost t", "by (clarsimp simp: lems)"], ["proof (state)\nthis:\n  cost (swapSyms t a c) \\<le> cost t\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "finally"], ["proof (chain)\npicking this:\n  cost (swapFourSyms t a b c d) \\<le> cost t", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "."], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> d \\<and> b \\<noteq> c) \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> d \\<and> b \\<noteq> c) \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "case False"], ["proof (state)\nthis:\n  \\<not> (a \\<noteq> d \\<and> b \\<noteq> c)\n\ngoal (1 subgoal):\n 1. \\<not> (a \\<noteq> d \\<and> b \\<noteq> c) \\<Longrightarrow>\n    cost (swapFourSyms t a b c d) \\<le> cost t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (a \\<noteq> d \\<and> b \\<noteq> c)\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (a \\<noteq> d \\<and> b \\<noteq> c)\n  consistent t\n  minima t a b\n  c \\<in> alphabet t\n  d \\<in> alphabet t\n  depth t c = height t\n  depth t d = height t\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms t a b c d) \\<le> cost t", "by (clarsimp simp: lems)"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (swapFourSyms t a b c d) \\<le> cost t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Leaf Split Optimality Lemma \\label{leaf-split-optimality}\\<close>"], ["", "text \\<open>\nThe tree @{term \"splitLeaf t w\\<^sub>a a w\\<^sub>b b\"} is optimum if $t$ is optimum, under a\nfew assumptions, notably that $a$ and $b$ are minima of the new tree and\nthat @{prop \"freq t a = w\\<^sub>a + w\\<^sub>b\"}.\nGraphically:\\strut\n%\n\\setbox\\myboxi=\\hbox{\\includegraphics[scale=1.2]{tree-splitLeaf-a.pdf}}%\n\\setbox\\myboxii=\\hbox{\\includegraphics[scale=1.2]{tree-splitLeaf-ab.pdf}}%\n$${\\it optimum\\/} \\smash{\\lower\\ht\\myboxi\\hbox{\\raise.5\\ht\\myboxii\\box\\myboxi}}\n  \\,\\mathop{\\Longrightarrow}\\;\\;\\;\n  {\\it optimum\\/} \\vcenter{\\box\\myboxii}$$\n%\nThis corresponds to the following fragment of Knuth's proof:\n\n\\begin{quote}\nNow it is easy to prove that the weighted path length of such a tree is\nminimized if and only if the tree with\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-w1-w2-leaves.pdf}}}\n  \\qquad \\hbox{replaced by} \\qquad\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{tree-w1-plus-w2.pdf}}}$$\nhas minimum path length for the weights $w_1 + w_2$, $w_3$, $\\ldots\\,$, $w_m$.\n\\end{quote}\n\n\\noindent\nWe only need the ``if'' direction of Knuth's equivalence. Lemma~16.3 in\nCormen et al.~\\cite[p.~391]{cormen-et-al-2001} expresses essentially the same\nproperty:\n\n\\begin{quote}\nLet $C$ be a given alphabet with frequency $f[c]$ defined for each character\n$c \\in C$. Let $x$ and $y$ be two characters in $C$ with minimum frequency. Let\n$C'$ be the alphabet $C$ with characters $x$, $y$ removed and (new) character\n$z$ added, so that $C' = C - \\{x, y\\} \\cup {\\{z\\}}$; define $f$ for $C'$ as for\n$C$, except that $f[z] = f[x] + f[y]$. Let $T'$ be any tree representing an\noptimal prefix code for the alphabet $C'$. Then the tree $T$, obtained from\n$T'$ by replacing the leaf node for $z$ with an internal node having $x$ and\n$y$ as children, represents an optimal prefix code for the alphabet $C$.\n\\end{quote}\n\n\\noindent\nThe proof is as follows: We assume that $t$ has a cost less than or equal to\nthat of any other comparable tree~$v$ and show that\n@{term \"splitLeaf t w\\<^sub>a a w\\<^sub>b b\"} has a cost less than or equal to that of any\nother comparable tree $u$. By @{thm [source] exists_at_height} and\n@{thm [source] depth_height_imp_sibling_ne}, we know that some symbols $c$ and\n$d$ appear in sibling nodes at the very bottom of~$u$:\n$$\\includegraphics[scale=1.25]{tree-splitLeaf-cd.pdf}$$\n(The question mark is there to remind us that we know nothing specific about\n$u$'s structure.) From $u$ we construct a new tree\n@{term \"swapFourSyms u a b c d\"} in which the minima $a$ and $b$ are siblings:\n$$\\includegraphics[scale=1.25]{tree-splitLeaf-abcd.pdf}$$\nMerging $a$ and $b$ gives a tree comparable with $t$, which we can use to\ninstantiate $v$ in the assumption:\n$$\\includegraphics[scale=1.25]{tree-splitLeaf-abcd-aba.pdf}$$\nWith this instantiation, the proof is easy:\n$$\\begin{tabularx}{\\textwidth}{@%\n{\\hskip\\leftmargin}cX@%\n{}}\n    & @{term \"cost (splitLeaf t a w\\<^sub>a b w\\<^sub>b)\"} \\\\\n\\eq & \\justif{@{thm [source] cost_splitLeaf}} \\\\\n    & @{term \"cost t + w\\<^sub>a + w\\<^sub>b\"} \\\\\n\\kern-1em$\\leq$\\kern-1em & \\justif{assumption} \\\\[-2ex]\n    & $\\<open>cost (\\<close>\n       \\overbrace{\\strut\\!@{term \"mergeSibling (swapFourSyms u a b c d) a\"}\\!}\n       ^{\\smash{\\hbox{$v$}}}\\<open>) + w\\<^sub>a + w\\<^sub>b\\<close>$ \\\\[\\extrah]\n\\eq & \\justif{@{thm [source] cost_mergeSibling}} \\\\\n    & @{term \"cost (swapFourSyms u a b c d)\"} \\\\\n\\kern-1em$\\leq$\\kern-1em & \\justif{@{thm [source] cost_swapFourSyms_le}} \\\\\n    & @{term \"cost u\"}. \\\\\n\\end{tabularx}$$\n\n\\noindent\nIn contrast, the proof in Cormen et al.\\ is by contradiction: Essentially, they\nassume that there exists a tree $u$ with a lower cost than\n@{term \"splitLeaf t a w\\<^sub>a b w\\<^sub>b\"} and show that there exists a tree~$v$\nwith a lower cost than~$t$, contradicting the hypothesis that $t$ is optimum. In\nplace of @{thm [source] cost_swapFourSyms_le}, they invoke their lemma~16.2,\nwhich is questionable since $u$ is not necessarily optimum.%\n\\footnote{Thomas Cormen commented that this step will be clarified in the\nnext edition of the book.}\n\nOur proof relies on the following lemma, which asserts that $a$ and $b$ are\nminima of $u$.\n\\<close>"], ["", "lemma twice_freq_le_imp_minima:\n\"\\<lbrakk>\\<forall>c \\<in> alphabet t. w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c;\n  alphabet u = alphabet t \\<union> {b}; a \\<in> alphabet u; a \\<noteq> b;\n  freq u = (\\<lambda>c. if c = a then w\\<^sub>a else if c = b then w\\<^sub>b else freq t c)\\<rbrakk> \\<Longrightarrow>\n minima u a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c\\<in>alphabet t.\n                w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c;\n     alphabet u = alphabet t \\<union> {b}; a \\<in> alphabet u; a \\<noteq> b;\n     freq u =\n     (\\<lambda>c.\n         if c = a then w\\<^sub>a\n         else if c = b then w\\<^sub>b else freq t c)\\<rbrakk>\n    \\<Longrightarrow> minima u a b", "by (simp add: minima_def)"], ["", "text \\<open>\nNow comes the key lemma.\n\\<close>"], ["", "lemma optimum_splitLeaf:\nassumes \"consistent t\" \"optimum t\" \"a \\<in> alphabet t\" \"b \\<notin> alphabet t\"\n        \"freq t a = w\\<^sub>a + w\\<^sub>b\" \"\\<forall>c \\<in> alphabet t. freq t c \\<ge> w\\<^sub>a \\<and> freq t c \\<ge> w\\<^sub>b\"\nshows \"optimum (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (splitLeaf t w\\<^sub>a a w\\<^sub>b b)", "proof (unfold optimum_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>consistent u;\n        alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u;\n        freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\\<rbrakk>\n       \\<Longrightarrow> cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n                         \\<le> cost u", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>consistent u;\n        alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u;\n        freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\\<rbrakk>\n       \\<Longrightarrow> cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n                         \\<le> cost u", "let ?t' = \"splitLeaf t w\\<^sub>a a w\\<^sub>b b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>consistent u;\n        alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u;\n        freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\\<rbrakk>\n       \\<Longrightarrow> cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n                         \\<le> cost u", "assume c\\<^sub>u: \"consistent u\" and a\\<^sub>u: \"alphabet ?t' = alphabet u\" and\n    f\\<^sub>u: \"freq ?t' = freq u\""], ["proof (state)\nthis:\n  consistent u\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>consistent u;\n        alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u;\n        freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\\<rbrakk>\n       \\<Longrightarrow> cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n                         \\<le> cost u", "show \"cost ?t' \\<le> cost u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "proof (cases \"height ?t' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = 0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n 2. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "case True"], ["proof (state)\nthis:\n  height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = 0\n\ngoal (2 subgoals):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = 0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n 2. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "thus ?thesis"], ["proof (prove)\nusing this:\n  height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = 0\n\ngoal (1 subgoal):\n 1. cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "by simp"], ["proof (state)\nthis:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "case False"], ["proof (state)\nthis:\n  height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "hence h\\<^sub>u: \"height u > 0\""], ["proof (prove)\nusing this:\n  height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < height u", "using a\\<^sub>u assms"], ["proof (prove)\nusing this:\n  height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq> 0\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. 0 < height u", "by (auto intro: height_gt_0_alphabet_eq_imp_height_gt_0)"], ["proof (state)\nthis:\n  0 < height u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have a\\<^sub>a: \"a \\<in> alphabet u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> alphabet u", "using a\\<^sub>u assms"], ["proof (prove)\nusing this:\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. a \\<in> alphabet u", "by fastforce"], ["proof (state)\nthis:\n  a \\<in> alphabet u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have a\\<^sub>b: \"b \\<in> alphabet u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> alphabet u", "using a\\<^sub>u assms"], ["proof (prove)\nusing this:\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. b \\<in> alphabet u", "by fastforce"], ["proof (state)\nthis:\n  b \\<in> alphabet u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have ab: \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "using assms"], ["proof (prove)\nusing this:\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by blast"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "from exists_at_height[OF c\\<^sub>u]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>alphabet u. depth u a = height u", "obtain c where a\\<^sub>c: \"c \\<in> alphabet u\" and d\\<^sub>c: \"depth u c = height u\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>alphabet u. depth u a = height u\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> alphabet u; depth u c = height u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  c \\<in> alphabet u\n  depth u c = height u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "let ?d = \"sibling u c\""], ["proof (state)\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have dc: \"?d \\<noteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling u c \\<noteq> c", "using d\\<^sub>c c\\<^sub>u h\\<^sub>u a\\<^sub>c"], ["proof (prove)\nusing this:\n  depth u c = height u\n  consistent u\n  0 < height u\n  c \\<in> alphabet u\n\ngoal (1 subgoal):\n 1. sibling u c \\<noteq> c", "by (metis depth_height_imp_sibling_ne)"], ["proof (state)\nthis:\n  sibling u c \\<noteq> c\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have a\\<^sub>d: \"?d \\<in> alphabet u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling u c \\<in> alphabet u", "using dc"], ["proof (prove)\nusing this:\n  sibling u c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling u c \\<in> alphabet u", "by (rule sibling_ne_imp_sibling_in_alphabet)"], ["proof (state)\nthis:\n  sibling u c \\<in> alphabet u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have d\\<^sub>d: \"depth u ?d = height u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. depth u (sibling u c) = height u", "using d\\<^sub>c c\\<^sub>u"], ["proof (prove)\nusing this:\n  depth u c = height u\n  consistent u\n\ngoal (1 subgoal):\n 1. depth u (sibling u c) = height u", "by simp"], ["proof (state)\nthis:\n  depth u (sibling u c) = height u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "let ?u' = \"swapFourSyms u a b c ?d\""], ["proof (state)\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have c\\<^sub>u\\<^sub>': \"consistent ?u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (swapFourSyms u a b c (sibling u c))", "using c\\<^sub>u"], ["proof (prove)\nusing this:\n  consistent u\n\ngoal (1 subgoal):\n 1. consistent (swapFourSyms u a b c (sibling u c))", "by simp"], ["proof (state)\nthis:\n  consistent (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have a\\<^sub>u\\<^sub>': \"alphabet ?u' = alphabet u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet (swapFourSyms u a b c (sibling u c)) = alphabet u", "using a\\<^sub>a a\\<^sub>b a\\<^sub>c a\\<^sub>d a\\<^sub>u"], ["proof (prove)\nusing this:\n  a \\<in> alphabet u\n  b \\<in> alphabet u\n  c \\<in> alphabet u\n  sibling u c \\<in> alphabet u\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n\ngoal (1 subgoal):\n 1. alphabet (swapFourSyms u a b c (sibling u c)) = alphabet u", "by simp"], ["proof (state)\nthis:\n  alphabet (swapFourSyms u a b c (sibling u c)) = alphabet u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have f\\<^sub>u\\<^sub>': \"freq ?u' = freq u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freq (swapFourSyms u a b c (sibling u c)) = freq u", "using a\\<^sub>a a\\<^sub>b a\\<^sub>c a\\<^sub>d c\\<^sub>u f\\<^sub>u"], ["proof (prove)\nusing this:\n  a \\<in> alphabet u\n  b \\<in> alphabet u\n  c \\<in> alphabet u\n  sibling u c \\<in> alphabet u\n  consistent u\n  freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\n\ngoal (1 subgoal):\n 1. freq (swapFourSyms u a b c (sibling u c)) = freq u", "by simp"], ["proof (state)\nthis:\n  freq (swapFourSyms u a b c (sibling u c)) = freq u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have s\\<^sub>a: \"sibling ?u' a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sibling (swapFourSyms u a b c (sibling u c)) a = b", "using c\\<^sub>u a\\<^sub>a a\\<^sub>b a\\<^sub>c ab dc"], ["proof (prove)\nusing this:\n  consistent u\n  a \\<in> alphabet u\n  b \\<in> alphabet u\n  c \\<in> alphabet u\n  a \\<noteq> b\n  sibling u c \\<noteq> c\n\ngoal (1 subgoal):\n 1. sibling (swapFourSyms u a b c (sibling u c)) a = b", "by (rule sibling_swapFourSyms_when_4th_is_sibling)"], ["proof (state)\nthis:\n  sibling (swapFourSyms u a b c (sibling u c)) a = b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "let ?v = \"mergeSibling ?u' a\""], ["proof (state)\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have c\\<^sub>v: \"consistent ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent (mergeSibling (swapFourSyms u a b c (sibling u c)) a)", "using c\\<^sub>u\\<^sub>'"], ["proof (prove)\nusing this:\n  consistent (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. consistent (mergeSibling (swapFourSyms u a b c (sibling u c)) a)", "by simp"], ["proof (state)\nthis:\n  consistent (mergeSibling (swapFourSyms u a b c (sibling u c)) a)\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have a\\<^sub>v: \"alphabet ?v = alphabet t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alphabet (mergeSibling (swapFourSyms u a b c (sibling u c)) a) =\n    alphabet t", "using s\\<^sub>a c\\<^sub>u\\<^sub>' a\\<^sub>u\\<^sub>' a\\<^sub>a a\\<^sub>u assms"], ["proof (prove)\nusing this:\n  sibling (swapFourSyms u a b c (sibling u c)) a = b\n  consistent (swapFourSyms u a b c (sibling u c))\n  alphabet (swapFourSyms u a b c (sibling u c)) = alphabet u\n  a \\<in> alphabet u\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. alphabet (mergeSibling (swapFourSyms u a b c (sibling u c)) a) =\n    alphabet t", "by auto"], ["proof (state)\nthis:\n  alphabet (mergeSibling (swapFourSyms u a b c (sibling u c)) a) =\n  alphabet t\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have f\\<^sub>v: \"freq ?v = freq t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. freq (mergeSibling (swapFourSyms u a b c (sibling u c)) a) = freq t", "using s\\<^sub>a c\\<^sub>u\\<^sub>' a\\<^sub>u\\<^sub>' f\\<^sub>u\\<^sub>' f\\<^sub>u[THEN sym] ab a\\<^sub>u[THEN sym] assms"], ["proof (prove)\nusing this:\n  sibling (swapFourSyms u a b c (sibling u c)) a = b\n  consistent (swapFourSyms u a b c (sibling u c))\n  alphabet (swapFourSyms u a b c (sibling u c)) = alphabet u\n  freq (swapFourSyms u a b c (sibling u c)) = freq u\n  freq u = freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n  a \\<noteq> b\n  alphabet u = alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. freq (mergeSibling (swapFourSyms u a b c (sibling u c)) a) = freq t", "by (simp add: freq_mergeSibling ext)"], ["proof (state)\nthis:\n  freq (mergeSibling (swapFourSyms u a b c (sibling u c)) a) = freq t\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have \"cost ?t' = cost t + w\\<^sub>a + w\\<^sub>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n    cost t + w\\<^sub>a + w\\<^sub>b", "using assms"], ["proof (prove)\nusing this:\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n    cost t + w\\<^sub>a + w\\<^sub>b", "by simp"], ["proof (state)\nthis:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n  cost t + w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "also"], ["proof (state)\nthis:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) =\n  cost t + w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have \"\\<dots> \\<le> cost ?v + w\\<^sub>a + w\\<^sub>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost t + w\\<^sub>a + w\\<^sub>b\n    \\<le> cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n          w\\<^sub>a +\n          w\\<^sub>b", "using c\\<^sub>v a\\<^sub>v f\\<^sub>v \\<open>optimum t\\<close>"], ["proof (prove)\nusing this:\n  consistent (mergeSibling (swapFourSyms u a b c (sibling u c)) a)\n  alphabet (mergeSibling (swapFourSyms u a b c (sibling u c)) a) =\n  alphabet t\n  freq (mergeSibling (swapFourSyms u a b c (sibling u c)) a) = freq t\n  optimum t\n\ngoal (1 subgoal):\n 1. cost t + w\\<^sub>a + w\\<^sub>b\n    \\<le> cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n          w\\<^sub>a +\n          w\\<^sub>b", "by (simp add: optimum_def)"], ["proof (state)\nthis:\n  cost t + w\\<^sub>a + w\\<^sub>b\n  \\<le> cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n        w\\<^sub>a +\n        w\\<^sub>b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "also"], ["proof (state)\nthis:\n  cost t + w\\<^sub>a + w\\<^sub>b\n  \\<le> cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n        w\\<^sub>a +\n        w\\<^sub>b\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have \"\\<dots> = cost ?u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "have \"cost ?v + freq ?u' a + freq ?u' (sibling ?u' a) = cost ?u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n    freq (swapFourSyms u a b c (sibling u c)) a +\n    freq (swapFourSyms u a b c (sibling u c))\n     (sibling (swapFourSyms u a b c (sibling u c)) a) =\n    cost (swapFourSyms u a b c (sibling u c))", "using c\\<^sub>u\\<^sub>' s\\<^sub>a assms"], ["proof (prove)\nusing this:\n  consistent (swapFourSyms u a b c (sibling u c))\n  sibling (swapFourSyms u a b c (sibling u c)) a = b\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n    freq (swapFourSyms u a b c (sibling u c)) a +\n    freq (swapFourSyms u a b c (sibling u c))\n     (sibling (swapFourSyms u a b c (sibling u c)) a) =\n    cost (swapFourSyms u a b c (sibling u c))", "by (subst cost_mergeSibling) auto"], ["proof (state)\nthis:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n  freq (swapFourSyms u a b c (sibling u c)) a +\n  freq (swapFourSyms u a b c (sibling u c))\n   (sibling (swapFourSyms u a b c (sibling u c)) a) =\n  cost (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "moreover"], ["proof (state)\nthis:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n  freq (swapFourSyms u a b c (sibling u c)) a +\n  freq (swapFourSyms u a b c (sibling u c))\n   (sibling (swapFourSyms u a b c (sibling u c)) a) =\n  cost (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "have \"w\\<^sub>a = freq ?u' a\" \"w\\<^sub>b = freq ?u' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a &&&\n    w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b", "using f\\<^sub>u\\<^sub>' f\\<^sub>u[THEN sym] assms"], ["proof (prove)\nusing this:\n  freq (swapFourSyms u a b c (sibling u c)) = freq u\n  freq u = freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b)\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a &&&\n    w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b", "by clarsimp+"], ["proof (state)\nthis:\n  w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a\n  w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "ultimately"], ["proof (chain)\npicking this:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n  freq (swapFourSyms u a b c (sibling u c)) a +\n  freq (swapFourSyms u a b c (sibling u c))\n   (sibling (swapFourSyms u a b c (sibling u c)) a) =\n  cost (swapFourSyms u a b c (sibling u c))\n  w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a\n  w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n  freq (swapFourSyms u a b c (sibling u c)) a +\n  freq (swapFourSyms u a b c (sibling u c))\n   (sibling (swapFourSyms u a b c (sibling u c)) a) =\n  cost (swapFourSyms u a b c (sibling u c))\n  w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a\n  w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "using s\\<^sub>a"], ["proof (prove)\nusing this:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) +\n  freq (swapFourSyms u a b c (sibling u c)) a +\n  freq (swapFourSyms u a b c (sibling u c))\n   (sibling (swapFourSyms u a b c (sibling u c)) a) =\n  cost (swapFourSyms u a b c (sibling u c))\n  w\\<^sub>a = freq (swapFourSyms u a b c (sibling u c)) a\n  w\\<^sub>b = freq (swapFourSyms u a b c (sibling u c)) b\n  sibling (swapFourSyms u a b c (sibling u c)) a = b\n\ngoal (1 subgoal):\n 1. cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n    w\\<^sub>b =\n    cost (swapFourSyms u a b c (sibling u c))", "by simp"], ["proof (state)\nthis:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n  w\\<^sub>b =\n  cost (swapFourSyms u a b c (sibling u c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n  w\\<^sub>b =\n  cost (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "also"], ["proof (state)\nthis:\n  cost (mergeSibling (swapFourSyms u a b c (sibling u c)) a) + w\\<^sub>a +\n  w\\<^sub>b =\n  cost (swapFourSyms u a b c (sibling u c))\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "have \"\\<dots> \\<le> cost u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u", "have \"minima u a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minima u a b", "using a\\<^sub>u f\\<^sub>u assms"], ["proof (prove)\nusing this:\n  alphabet (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = alphabet u\n  freq (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = freq u\n  consistent t\n  optimum t\n  a \\<in> alphabet t\n  b \\<notin> alphabet t\n  freq t a = w\\<^sub>a + w\\<^sub>b\n  \\<forall>c\\<in>alphabet t.\n     w\\<^sub>a \\<le> freq t c \\<and> w\\<^sub>b \\<le> freq t c\n\ngoal (1 subgoal):\n 1. minima u a b", "by (subst twice_freq_le_imp_minima) auto"], ["proof (state)\nthis:\n  minima u a b\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u", "with c\\<^sub>u"], ["proof (chain)\npicking this:\n  consistent u\n  minima u a b", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent u\n  minima u a b\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u", "using a\\<^sub>c a\\<^sub>d d\\<^sub>c d\\<^sub>d dc[THEN not_sym]"], ["proof (prove)\nusing this:\n  consistent u\n  minima u a b\n  c \\<in> alphabet u\n  sibling u c \\<in> alphabet u\n  depth u c = height u\n  depth u (sibling u c) = height u\n  c \\<noteq> sibling u c\n\ngoal (1 subgoal):\n 1. cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u", "by (rule cost_swapFourSyms_le)"], ["proof (state)\nthis:\n  cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (swapFourSyms u a b c (sibling u c)) \\<le> cost u\n\ngoal (1 subgoal):\n 1. height (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<noteq>\n    0 \\<Longrightarrow>\n    cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "finally"], ["proof (chain)\npicking this:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "show ?thesis"], ["proof (prove)\nusing this:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n\ngoal (1 subgoal):\n 1. cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u", "."], ["proof (state)\nthis:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cost (splitLeaf t w\\<^sub>a a w\\<^sub>b b) \\<le> cost u\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Leaf Split Commutativity Lemma \\label{leaf-split-commutativity}\\<close>"], ["", "text \\<open>\nA key property of Huffman's algorithm is that once it has combined two\nlowest-weight trees using @{const uniteTrees}, it does not visit these trees\never again. This suggests that splitting a leaf node before applying the\nalgorithm should give the same result as applying the algorithm first and\nsplitting the leaf node afterward. The diagram below illustrates the\nsituation:\\strut\n\n\\def\\myscale{1.05}%\n\\setbox\\myboxi=\\hbox{(9)\\strut}%\n\\setbox\\myboxii=\\hbox{\\includegraphics[scale=\\myscale]{forest-a.pdf}}%\n$$(1)\\,\\lower\\ht\\myboxii\\hbox{\\raise\\ht\\myboxi\\box\\myboxii}$$\n\n\\smallskip\n\n\\setbox\\myboxii=\\hbox{\\includegraphics[scale=\\myscale]{tree-splitLeaf-a.pdf}}%\n\\setbox\\myboxiii=\\hbox{\\includegraphics[scale=\\myscale]%\n  {forest-splitLeaf-ab.pdf}}%\n\\mydimeni=\\wd\\myboxii\n\n\\noindent\n(2a)\\,\\lower\\ht\\myboxii\\hbox{\\raise\\ht\\myboxi\\box\\myboxii}%\n  \\qquad\\qquad\\quad\n  (2b)\\,\\lower\\ht\\myboxiii\\hbox{\\raise\\ht\\myboxi\\box\\myboxiii}\\quad{}\n\n\\setbox\\myboxiii=\\hbox{\\includegraphics[scale=\\myscale]%\n  {tree-splitLeaf-ab.pdf}}%\n\\setbox\\myboxiv=\\hbox{\\includegraphics[scale=\\myscale]%\n  {tree-huffman-splitLeaf-ab.pdf}}%\n\\mydimenii=\\wd\\myboxiii\n\\vskip1.5\\smallskipamount\n\\noindent\n(3a)\\,\\lower\\ht\\myboxiii\\hbox{\\raise\\ht\\myboxi\\box\\myboxiii}%\n  \\qquad\\qquad\\quad\n  (3b)\\,\\hfill\\lower\\ht\\myboxiv\\hbox{\\raise\\ht\\myboxi\\box\\myboxiv}%\n  \\quad\\hfill{}\n\n\\noindent\nFrom the original forest (1), we can either run the algorithm (2a) and then\nsplit $a$ (3a) or split $a$ (2b) and then run the algorithm (3b). Our goal is\nto show that trees (3a) and (3b) are identical. Formally, we prove that\n$$@{term \"splitLeaf (huffman ts) w\\<^sub>a a w\\<^sub>b b\"} =\n  @{term \"huffman (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)\"}$$\nwhen @{term ts} is consistent, @{term \"a \\<in> alphabet\\<^sub>F ts\"}, @{term\n\"b \\<notin> alphabet\\<^sub>F ts\"}, and $@{term \"freq\\<^sub>F ts a\"} = @{term w\\<^sub>a}\n\\mathbin{\\<open>+\\<close>} @{term \"w\\<^sub>b\"}$. But before we can prove this\ncommutativity lemma, we need to introduce a few simple lemmas.\n\\<close>"], ["", "lemma cachedWeight_splitLeaf[simp]:\n\"cachedWeight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = cachedWeight t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cachedWeight (splitLeaf t w\\<^sub>a a w\\<^sub>b b) = cachedWeight t", "by (case_tac t) simp+"], ["", "lemma splitLeaf\\<^sub>F_insortTree_when_in_alphabet_left[simp]:\n\"\\<lbrakk>a \\<in> alphabet t; consistent t; a \\<notin> alphabet\\<^sub>F ts; freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a w\\<^sub>b b = insortTree (splitLeaf t w\\<^sub>a a w\\<^sub>b b) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> alphabet t; consistent t;\n     a \\<notin> alphabet\\<^sub>F ts;\n     freq t a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a\n                       w\\<^sub>b b =\n                      insortTree (splitLeaf t w\\<^sub>a a w\\<^sub>b b) ts", "by (induct ts) simp+"], ["", "lemma splitLeaf\\<^sub>F_insortTree_when_in_alphabet\\<^sub>F_tail[simp]:\n\"\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts; a \\<notin> alphabet t; freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a w\\<^sub>b b =\n insortTree t (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n     a \\<notin> alphabet t;\n     freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts) w\\<^sub>a a\n                       w\\<^sub>b b =\n                      insortTree t\n                       (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)", "proof (induct ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> alphabet\\<^sub>F []; consistent\\<^sub>F [];\n     a \\<notin> alphabet t;\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t []) w\\<^sub>a a\n                       w\\<^sub>b b =\n                      insortTree t\n                       (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)\n 2. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n                 a \\<notin> alphabet t;\n                 freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts)\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  insortTree t\n                                   (splitLeaf\\<^sub>F ts w\\<^sub>a a\n                                     w\\<^sub>b b);\n        a \\<in> alphabet\\<^sub>F (aa # ts); consistent\\<^sub>F (aa # ts);\n        a \\<notin> alphabet t;\n        freq\\<^sub>F (aa # ts) a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t (aa # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         insortTree t\n                          (splitLeaf\\<^sub>F (aa # ts) w\\<^sub>a a w\\<^sub>b\n                            b)", "case Nil"], ["proof (state)\nthis:\n  a \\<in> alphabet\\<^sub>F []\n  consistent\\<^sub>F []\n  a \\<notin> alphabet t\n  freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> alphabet\\<^sub>F []; consistent\\<^sub>F [];\n     a \\<notin> alphabet t;\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t []) w\\<^sub>a a\n                       w\\<^sub>b b =\n                      insortTree t\n                       (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)\n 2. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n                 a \\<notin> alphabet t;\n                 freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts)\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  insortTree t\n                                   (splitLeaf\\<^sub>F ts w\\<^sub>a a\n                                     w\\<^sub>b b);\n        a \\<in> alphabet\\<^sub>F (aa # ts); consistent\\<^sub>F (aa # ts);\n        a \\<notin> alphabet t;\n        freq\\<^sub>F (aa # ts) a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t (aa # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         insortTree t\n                          (splitLeaf\\<^sub>F (aa # ts) w\\<^sub>a a w\\<^sub>b\n                            b)", "thus ?case"], ["proof (prove)\nusing this:\n  a \\<in> alphabet\\<^sub>F []\n  consistent\\<^sub>F []\n  a \\<notin> alphabet t\n  freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t []) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "by simp"], ["proof (state)\nthis:\n  splitLeaf\\<^sub>F (insortTree t []) w\\<^sub>a a w\\<^sub>b b =\n  insortTree t (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n                 a \\<notin> alphabet t;\n                 freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts)\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  insortTree t\n                                   (splitLeaf\\<^sub>F ts w\\<^sub>a a\n                                     w\\<^sub>b b);\n        a \\<in> alphabet\\<^sub>F (aa # ts); consistent\\<^sub>F (aa # ts);\n        a \\<notin> alphabet t;\n        freq\\<^sub>F (aa # ts) a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t (aa # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         insortTree t\n                          (splitLeaf\\<^sub>F (aa # ts) w\\<^sub>a a w\\<^sub>b\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n                 a \\<notin> alphabet t;\n                 freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts)\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  insortTree t\n                                   (splitLeaf\\<^sub>F ts w\\<^sub>a a\n                                     w\\<^sub>b b);\n        a \\<in> alphabet\\<^sub>F (aa # ts); consistent\\<^sub>F (aa # ts);\n        a \\<notin> alphabet t;\n        freq\\<^sub>F (aa # ts) a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t (aa # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         insortTree t\n                          (splitLeaf\\<^sub>F (aa # ts) w\\<^sub>a a w\\<^sub>b\n                            b)", "case (Cons u us)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> alphabet\\<^sub>F us; consistent\\<^sub>F us;\n   a \\<notin> alphabet t; freq\\<^sub>F us a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t us) w\\<^sub>a a\n                     w\\<^sub>b b =\n                    insortTree t\n                     (splitLeaf\\<^sub>F us w\\<^sub>a a w\\<^sub>b b)\n  a \\<in> alphabet\\<^sub>F (u # us)\n  consistent\\<^sub>F (u # us)\n  a \\<notin> alphabet t\n  freq\\<^sub>F (u # us) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. \\<And>aa ts.\n       \\<lbrakk>\\<lbrakk>a \\<in> alphabet\\<^sub>F ts; consistent\\<^sub>F ts;\n                 a \\<notin> alphabet t;\n                 freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t ts)\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  insortTree t\n                                   (splitLeaf\\<^sub>F ts w\\<^sub>a a\n                                     w\\<^sub>b b);\n        a \\<in> alphabet\\<^sub>F (aa # ts); consistent\\<^sub>F (aa # ts);\n        a \\<notin> alphabet t;\n        freq\\<^sub>F (aa # ts) a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t (aa # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         insortTree t\n                          (splitLeaf\\<^sub>F (aa # ts) w\\<^sub>a a w\\<^sub>b\n                            b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "proof (cases \"a \\<in> alphabet u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n 2. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "case True"], ["proof (state)\nthis:\n  a \\<in> alphabet u\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n 2. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "hence \"a \\<notin> alphabet\\<^sub>F us\""], ["proof (prove)\nusing this:\n  a \\<in> alphabet u\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F us", "using Cons"], ["proof (prove)\nusing this:\n  a \\<in> alphabet u\n  \\<lbrakk>a \\<in> alphabet\\<^sub>F us; consistent\\<^sub>F us;\n   a \\<notin> alphabet t; freq\\<^sub>F us a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t us) w\\<^sub>a a\n                     w\\<^sub>b b =\n                    insortTree t\n                     (splitLeaf\\<^sub>F us w\\<^sub>a a w\\<^sub>b b)\n  a \\<in> alphabet\\<^sub>F (u # us)\n  consistent\\<^sub>F (u # us)\n  a \\<notin> alphabet t\n  freq\\<^sub>F (u # us) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F us", "by auto"], ["proof (state)\nthis:\n  a \\<notin> alphabet\\<^sub>F us\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n 2. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet\\<^sub>F us\n\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "using Cons"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet\\<^sub>F us\n  \\<lbrakk>a \\<in> alphabet\\<^sub>F us; consistent\\<^sub>F us;\n   a \\<notin> alphabet t; freq\\<^sub>F us a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t us) w\\<^sub>a a\n                     w\\<^sub>b b =\n                    insortTree t\n                     (splitLeaf\\<^sub>F us w\\<^sub>a a w\\<^sub>b b)\n  a \\<in> alphabet\\<^sub>F (u # us)\n  consistent\\<^sub>F (u # us)\n  a \\<notin> alphabet t\n  freq\\<^sub>F (u # us) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "by auto"], ["proof (state)\nthis:\n  splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n  insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "case False"], ["proof (state)\nthis:\n  a \\<notin> alphabet u\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet u \\<Longrightarrow>\n    splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet u\n\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "using Cons"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet u\n  \\<lbrakk>a \\<in> alphabet\\<^sub>F us; consistent\\<^sub>F us;\n   a \\<notin> alphabet t; freq\\<^sub>F us a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\\<^sub>F (insortTree t us) w\\<^sub>a a\n                     w\\<^sub>b b =\n                    insortTree t\n                     (splitLeaf\\<^sub>F us w\\<^sub>a a w\\<^sub>b b)\n  a \\<in> alphabet\\<^sub>F (u # us)\n  consistent\\<^sub>F (u # us)\n  a \\<notin> alphabet t\n  freq\\<^sub>F (u # us) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n    insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)", "by simp"], ["proof (state)\nthis:\n  splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n  insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  splitLeaf\\<^sub>F (insortTree t (u # us)) w\\<^sub>a a w\\<^sub>b b =\n  insortTree t (splitLeaf\\<^sub>F (u # us) w\\<^sub>a a w\\<^sub>b b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWe are now ready to prove the commutativity lemma.\n\\<close>"], ["", "lemma splitLeaf_huffman_commute:\n\"\\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> []; a \\<in> alphabet\\<^sub>F ts; freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk> \\<Longrightarrow>\n splitLeaf (huffman ts) w\\<^sub>a a w\\<^sub>b b = huffman (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F ts; ts \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F ts;\n     freq\\<^sub>F ts a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman ts) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F ts w\\<^sub>a a w\\<^sub>b b)", "proof (induct ts rule: huffman.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>consistent\\<^sub>F [t]; [t] \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F [t];\n        freq\\<^sub>F [t] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman [t]) w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F [t] w\\<^sub>a a w\\<^sub>b b)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 3. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "case (1 t)"], ["proof (state)\nthis:\n  consistent\\<^sub>F [t]\n  [t] \\<noteq> []\n  a \\<in> alphabet\\<^sub>F [t]\n  freq\\<^sub>F [t] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>consistent\\<^sub>F [t]; [t] \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F [t];\n        freq\\<^sub>F [t] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman [t]) w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F [t] w\\<^sub>a a w\\<^sub>b b)\n 2. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 3. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "thus ?case"], ["proof (prove)\nusing this:\n  consistent\\<^sub>F [t]\n  [t] \\<noteq> []\n  a \\<in> alphabet\\<^sub>F [t]\n  freq\\<^sub>F [t] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman [t]) w\\<^sub>a a w\\<^sub>b b =\n    huffman (splitLeaf\\<^sub>F [t] w\\<^sub>a a w\\<^sub>b b)", "by simp"], ["proof (state)\nthis:\n  splitLeaf (huffman [t]) w\\<^sub>a a w\\<^sub>b b =\n  huffman (splitLeaf\\<^sub>F [t] w\\<^sub>a a w\\<^sub>b b)\n\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 2. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 2. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "case (2 t\\<^sub>1 t\\<^sub>2 ts)"], ["proof (state)\nthis:\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 2. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "note hyps = 2"], ["proof (state)\nthis:\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (2 subgoals):\n 1. \\<And>t\\<^sub>1 t\\<^sub>2 ts.\n       \\<lbrakk>\\<lbrakk>consistent\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n                 a \\<in> alphabet\\<^sub>F\n                          (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n                 freq\\<^sub>F\n                  (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n                 w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n                \\<Longrightarrow> splitLeaf\n                                   (huffman\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                                   w\\<^sub>a a w\\<^sub>b b =\n                                  huffman\n                                   (splitLeaf\\<^sub>F\n                                     (insortTree\n (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                                     w\\<^sub>a a w\\<^sub>b b);\n        consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> [];\n        a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts);\n        freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a =\n        w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n       \\<Longrightarrow> splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts))\n                          w\\<^sub>a a w\\<^sub>b b =\n                         huffman\n                          (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n                            w\\<^sub>a a w\\<^sub>b b)\n 2. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "proof (cases \"a \\<in> alphabet t\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "case True"], ["proof (state)\nthis:\n  a \\<in> alphabet t\\<^sub>1\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "hence \"a \\<notin> alphabet t\\<^sub>2\" \"a \\<notin> alphabet\\<^sub>F ts\""], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 &&& a \\<notin> alphabet\\<^sub>F ts", "using hyps"], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>1\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 &&& a \\<notin> alphabet\\<^sub>F ts", "by auto"], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet\\<^sub>F ts\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet\\<^sub>F ts\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "using hyps"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet\\<^sub>F ts\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "by (simp add: uniteTrees_def)"], ["proof (state)\nthis:\n  splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b b =\n  huffman\n   (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "case False"], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "note a\\<^sub>1 = False"], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>1\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>1 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "proof (cases \"a \\<in> alphabet t\\<^sub>2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "case True"], ["proof (state)\nthis:\n  a \\<in> alphabet t\\<^sub>2\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "hence \"a \\<notin> alphabet\\<^sub>F ts\""], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F ts", "using hyps"], ["proof (prove)\nusing this:\n  a \\<in> alphabet t\\<^sub>2\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet\\<^sub>F ts", "by auto"], ["proof (state)\nthis:\n  a \\<notin> alphabet\\<^sub>F ts\n\ngoal (2 subgoals):\n 1. a \\<in> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)\n 2. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet\\<^sub>F ts\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "using a\\<^sub>1 hyps"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet\\<^sub>F ts\n  a \\<notin> alphabet t\\<^sub>1\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "by (simp add: uniteTrees_def)"], ["proof (state)\nthis:\n  splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b b =\n  huffman\n   (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "case False"], ["proof (state)\nthis:\n  a \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. a \\<notin> alphabet t\\<^sub>2 \\<Longrightarrow>\n    splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet t\\<^sub>2\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "using a\\<^sub>1 hyps"], ["proof (prove)\nusing this:\n  a \\<notin> alphabet t\\<^sub>2\n  a \\<notin> alphabet t\\<^sub>1\n  \\<lbrakk>consistent\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts \\<noteq> [];\n   a \\<in> alphabet\\<^sub>F\n            (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts);\n   freq\\<^sub>F (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts) a =\n   w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n  \\<Longrightarrow> splitLeaf\n                     (huffman\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts))\n                     w\\<^sub>a a w\\<^sub>b b =\n                    huffman\n                     (splitLeaf\\<^sub>F\n                       (insortTree (uniteTrees t\\<^sub>1 t\\<^sub>2) ts)\n                       w\\<^sub>a a w\\<^sub>b b)\n  consistent\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  t\\<^sub>1 # t\\<^sub>2 # ts \\<noteq> []\n  a \\<in> alphabet\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts)\n  freq\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b\n     b =\n    huffman\n     (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b\n       b)", "by simp"], ["proof (state)\nthis:\n  splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b b =\n  huffman\n   (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b b =\n  huffman\n   (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  splitLeaf (huffman (t\\<^sub>1 # t\\<^sub>2 # ts)) w\\<^sub>a a w\\<^sub>b b =\n  huffman\n   (splitLeaf\\<^sub>F (t\\<^sub>1 # t\\<^sub>2 # ts) w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "case 3"], ["proof (state)\nthis:\n  consistent\\<^sub>F []\n  [] \\<noteq> []\n  a \\<in> alphabet\\<^sub>F []\n  freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F []; [] \\<noteq> [];\n     a \\<in> alphabet\\<^sub>F [];\n     freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\\<rbrakk>\n    \\<Longrightarrow> splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n                      huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "thus ?case"], ["proof (prove)\nusing this:\n  consistent\\<^sub>F []\n  [] \\<noteq> []\n  a \\<in> alphabet\\<^sub>F []\n  freq\\<^sub>F [] a = w\\<^sub>a + w\\<^sub>b\n\ngoal (1 subgoal):\n 1. splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n    huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)", "by simp"], ["proof (state)\nthis:\n  splitLeaf (huffman []) w\\<^sub>a a w\\<^sub>b b =\n  huffman (splitLeaf\\<^sub>F [] w\\<^sub>a a w\\<^sub>b b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nAn important consequence of the commutativity lemma is that applying Huffman's\nalgorithm on a forest of the form\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-uniteTrees.pdf}}}$$\ngives the same result as applying the algorithm on the ``flat'' forest\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}$$\nfollowed by splitting the leaf node $a$ into two nodes $a$, $b$ with\nfrequencies $@{term w\\<^sub>a}$, $@{term w\\<^sub>b}$. The lemma effectively\nprovides a way to flatten the forest at each step of the algorithm. Its\ninvocation is implicit in the textbook proof.\n\\<close>"], ["", "subsection \\<open>Optimality Theorem\\<close>"], ["", "text \\<open>\nWe are one lemma away from our main result.\n\\<close>"], ["", "lemma max_0_imp_0[simp]:\n\"(max x y = (0::nat)) = (x = 0 \\<and> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max x y = 0) = (x = 0 \\<and> y = 0)", "by auto"], ["", "theorem optimum_huffman:\n\"\\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0; sortedByWeight ts; ts \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n optimum (huffman ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n     sortedByWeight ts; ts \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> optimum (huffman ts)", "txt \\<open>\nThe input @{term ts} is assumed to be a nonempty consistent list of leaf nodes\nsorted by weight. The proof is by induction on the length of the forest\n@{term ts}. Let @{term ts} be\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-flat.pdf}}}$$\nwith $w_a \\le w_b \\le w_c \\le w_d \\le \\cdots \\le w_z$. If @{term ts} consists\nof a single leaf node, the node has cost 0 and is therefore optimum. If\n@{term ts} has length 2 or more, the first step of the algorithm leaves us with\nthe term\n$${\\it huffman\\/}\\enskip\\; \\vcenter{\\hbox{\\includegraphics[scale=1.25]%\n    {forest-uniteTrees.pdf}}}$$\nIn the diagram, we put the newly created tree at position 2 in the forest; in\ngeneral, it could be anywhere. By @{thm [source] splitLeaf_huffman_commute},\nthe above tree equals\\strut\n$${\\it splitLeaf\\/}\\;\\left({\\it huffman\\/}\\enskip\\;\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}\n  \\;\\right)\\,\\<open>w\\<^sub>a a w\\<^sub>b b\\<close>.$$\nTo prove that this tree is optimum, it suffices by\n@{thm [source] optimum_splitLeaf} to show that\\strut\n$${\\it huffman\\/}\\enskip\\;\n  \\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-uniteTrees-flat.pdf}}}$$\nis optimum, which follows from the induction hypothesis.\\strut\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>consistent\\<^sub>F ts; height\\<^sub>F ts = 0;\n     sortedByWeight ts; ts \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> optimum (huffman ts)", "proof (induct ts rule: length_induct)\n  \\<comment> \\<open>\\sc Complete induction step\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   consistent\\<^sub>F ys \\<longrightarrow>\n                   height\\<^sub>F ys = 0 \\<longrightarrow>\n                   sortedByWeight ys \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n        consistent\\<^sub>F xs; height\\<^sub>F xs = 0; sortedByWeight xs;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> optimum (huffman xs)", "case (1 ts)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   consistent\\<^sub>F ys \\<longrightarrow>\n                   height\\<^sub>F ys = 0 \\<longrightarrow>\n                   sortedByWeight ys \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n        consistent\\<^sub>F xs; height\\<^sub>F xs = 0; sortedByWeight xs;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> optimum (huffman xs)", "note hyps = 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   consistent\\<^sub>F ys \\<longrightarrow>\n                   height\\<^sub>F ys = 0 \\<longrightarrow>\n                   sortedByWeight ys \\<longrightarrow>\n                   ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n        consistent\\<^sub>F xs; height\\<^sub>F xs = 0; sortedByWeight xs;\n        xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> optimum (huffman xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "proof (cases ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. ts = [] \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "case Nil"], ["proof (state)\nthis:\n  ts = []\n\ngoal (2 subgoals):\n 1. ts = [] \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts = []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "using \\<open>ts \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  ts = []\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "by fast"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "case (Cons t\\<^sub>a ts')"], ["proof (state)\nthis:\n  ts = t\\<^sub>a # ts'\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "note ts = Cons"], ["proof (state)\nthis:\n  ts = t\\<^sub>a # ts'\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts = a # list \\<Longrightarrow> optimum (huffman ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "proof (cases ts')"], ["proof (state)\ngoal (2 subgoals):\n 1. ts' = [] \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "case Nil"], ["proof (state)\nthis:\n  ts' = []\n\ngoal (2 subgoals):\n 1. ts' = [] \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ts' = []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "using ts hyps"], ["proof (prove)\nusing this:\n  ts' = []\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "by (simp add: optimum_def)"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "case (Cons t\\<^sub>b ts'')"], ["proof (state)\nthis:\n  ts' = t\\<^sub>b # ts''\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "note ts' = Cons"], ["proof (state)\nthis:\n  ts' = t\\<^sub>b # ts''\n\ngoal (1 subgoal):\n 1. \\<And>a list. ts' = a # list \\<Longrightarrow> optimum (huffman ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "proof (cases t\\<^sub>a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>a = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "case (Leaf w\\<^sub>a a)"], ["proof (state)\nthis:\n  t\\<^sub>a = Leaf w\\<^sub>a a\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>a = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "note l\\<^sub>a = Leaf"], ["proof (state)\nthis:\n  t\\<^sub>a = Leaf w\\<^sub>a a\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>a = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "proof (cases t\\<^sub>b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>b = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "case (Leaf w\\<^sub>b b)"], ["proof (state)\nthis:\n  t\\<^sub>b = Leaf w\\<^sub>b b\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>b = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "note l\\<^sub>b = Leaf"], ["proof (state)\nthis:\n  t\\<^sub>b = Leaf w\\<^sub>b b\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       t\\<^sub>b = Leaf x11 x12 \\<Longrightarrow> optimum (huffman ts)\n 2. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "let ?us = \"insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts''\""], ["proof (state)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "let ?us' = \"insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''\""], ["proof (state)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "let ?t\\<^sub>s = \"splitLeaf (huffman ?us') w\\<^sub>a a w\\<^sub>b b\""], ["proof (state)\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "have e\\<^sub>1: \"huffman ts = huffman ?us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. huffman ts = huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'')", "using ts' ts"], ["proof (prove)\nusing this:\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n\ngoal (1 subgoal):\n 1. huffman ts = huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'')", "by simp"], ["proof (state)\nthis:\n  huffman ts = huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'')\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "have e\\<^sub>2: \"huffman ?us = ?t\\<^sub>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'') =\n    splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n     w\\<^sub>a a w\\<^sub>b b", "using l\\<^sub>a l\\<^sub>b ts' ts hyps"], ["proof (prove)\nusing this:\n  t\\<^sub>a = Leaf w\\<^sub>a a\n  t\\<^sub>b = Leaf w\\<^sub>b b\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'') =\n    splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n     w\\<^sub>a a w\\<^sub>b b", "by (auto simp: splitLeaf_huffman_commute uniteTrees_def)"], ["proof (state)\nthis:\n  huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'') =\n  splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n   w\\<^sub>a a w\\<^sub>b b\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "have \"optimum (huffman ?us')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. optimum (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))", "using l\\<^sub>a ts' ts hyps"], ["proof (prove)\nusing this:\n  t\\<^sub>a = Leaf w\\<^sub>a a\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))", "by (drule_tac x = ?us' in spec)\n                 (auto dest: sortedByWeight_Cons_imp_sortedByWeight\n                  simp: sortedByWeight_insortTree)"], ["proof (state)\nthis:\n  optimum (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "hence \"optimum ?t\\<^sub>s\""], ["proof (prove)\nusing this:\n  optimum (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n\ngoal (1 subgoal):\n 1. optimum\n     (splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n       w\\<^sub>a a w\\<^sub>b b)", "using l\\<^sub>a l\\<^sub>b ts' ts hyps"], ["proof (prove)\nusing this:\n  optimum (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n  t\\<^sub>a = Leaf w\\<^sub>a a\n  t\\<^sub>b = Leaf w\\<^sub>b b\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum\n     (splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n       w\\<^sub>a a w\\<^sub>b b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> optimum\n                       (splitLeaf\n                         (huffman\n                           (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a)\n                             ts''))\n                         w\\<^sub>a a w\\<^sub>b b)", "apply (rule optimum_splitLeaf)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> consistent\n                       (huffman\n                         (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n 2. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> optimum\n                       (huffman\n                         (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n 3. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> a \\<in> alphabet\n                               (huffman\n                                 (insortTree\n                                   (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n 4. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> alphabet\n                                  (huffman\n                                    (insortTree\n(Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n 5. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> freq\n                       (huffman\n                         (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n                       a =\n                      w\\<^sub>a + w\\<^sub>b\n 6. \\<lbrakk>optimum\n              (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''));\n     t\\<^sub>a = Leaf w\\<^sub>a a; t\\<^sub>b = Leaf w\\<^sub>b b;\n     ts' = Leaf w\\<^sub>b b # ts'';\n     ts = Leaf w\\<^sub>a a # Leaf w\\<^sub>b b # ts'';\n     \\<forall>ys.\n        length ys < Suc (Suc (length ts'')) \\<longrightarrow>\n        consistent\\<^sub>F ys \\<longrightarrow>\n        height\\<^sub>F ys = 0 \\<longrightarrow>\n        sortedByWeight ys \\<longrightarrow>\n        ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys);\n     b \\<noteq> a \\<and>\n     a \\<notin> alphabet\\<^sub>F ts'' \\<and>\n     b \\<notin> alphabet\\<^sub>F ts'' \\<and> consistent\\<^sub>F ts'';\n     height\\<^sub>F ts'' = 0;\n     w\\<^sub>a \\<le> w\\<^sub>b \\<and>\n     sortedByWeight (Leaf w\\<^sub>b b # ts'')\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c\\<in>alphabet\n(huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts'')).\n                         w\\<^sub>a\n                         \\<le> freq\n                                (huffman\n                                  (insortTree\n                                    (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n                                c \\<and>\n                         w\\<^sub>b\n                         \\<le> freq\n                                (huffman\n                                  (insortTree\n                                    (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n                                c", "by (auto dest!: height\\<^sub>F_0_imp_Leaf_freq\\<^sub>F_in_set\n                  sortedByWeight_Cons_imp_forall_weight_ge)"], ["proof (state)\nthis:\n  optimum\n   (splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n     w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "thus \"optimum (huffman ts)\""], ["proof (prove)\nusing this:\n  optimum\n   (splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n     w\\<^sub>a a w\\<^sub>b b)\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "using e\\<^sub>1 e\\<^sub>2"], ["proof (prove)\nusing this:\n  optimum\n   (splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n     w\\<^sub>a a w\\<^sub>b b)\n  huffman ts = huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'')\n  huffman (insortTree (uniteTrees t\\<^sub>a t\\<^sub>b) ts'') =\n  splitLeaf (huffman (insortTree (Leaf (w\\<^sub>a + w\\<^sub>b) a) ts''))\n   w\\<^sub>a a w\\<^sub>b b\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "by simp"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "case Node"], ["proof (state)\nthis:\n  t\\<^sub>b = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>b = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>b = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "using ts' ts hyps"], ["proof (prove)\nusing this:\n  t\\<^sub>b = Node x21_ x22_ x23_\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "by simp"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "case Node"], ["proof (state)\nthis:\n  t\\<^sub>a = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t\\<^sub>a = Node x21 x22 x23 \\<Longrightarrow> optimum (huffman ts)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t\\<^sub>a = Node x21_ x22_ x23_\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "using ts' ts hyps"], ["proof (prove)\nusing this:\n  t\\<^sub>a = Node x21_ x22_ x23_\n  ts' = t\\<^sub>b # ts''\n  ts = t\\<^sub>a # ts'\n  \\<forall>ys.\n     length ys < length ts \\<longrightarrow>\n     consistent\\<^sub>F ys \\<longrightarrow>\n     height\\<^sub>F ys = 0 \\<longrightarrow>\n     sortedByWeight ys \\<longrightarrow>\n     ys \\<noteq> [] \\<longrightarrow> optimum (huffman ys)\n  consistent\\<^sub>F ts\n  height\\<^sub>F ts = 0\n  sortedByWeight ts\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. optimum (huffman ts)", "by simp"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  optimum (huffman ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\isakeyword{end}\n\n\\myskip\n\n\\noindent\nSo what have we achieved? Assuming that our definitions really mean what we\nintend them to mean, we established that our functional implementation of\nHuffman's algorithm, when invoked properly, constructs a binary tree that\nrepresents an optimal prefix code for the specified alphabet and frequencies.\nUsing Isabelle's code generator \\cite{haftmann-nipkow-2007}, we can convert the\nIsabelle code into Standard ML, OCaml, or Haskell and use it in a real\napplication.\n\nAs a side note, the @{thm [source] optimum_huffman} theorem assumes that the\nforest @{term ts} passed to @{const huffman} consists exclusively of leaf nodes.\nIt is tempting to relax this restriction, by requiring instead that the forest\n@{term ts} has the lowest cost among forests of the same size. We would define\noptimality of a forest as follows:\n$$\\begin{aligned}[t]\n  @{prop \"optimum\\<^sub>F ts\"}\\,\\;\\<open>=\\<close>\\;\\,\n  (\\<open>\\<forall>us.\\<close>\\\n    & \\<open>length ts = length us \\<longrightarrow> consistent\\<^sub>F us \\<longrightarrow>\\<close> \\\\[-2.5pt]\n    & \\<open>alphabet\\<^sub>F ts = alphabet\\<^sub>F us \\<longrightarrow> freq\\<^sub>F ts = freq\\<^sub>F us \\<longrightarrow>\\<close>\n\\\\[-2.5pt]\n    & @{prop \"cost\\<^sub>F ts \\<le> cost\\<^sub>F us\"})\\end{aligned}$$\nwith $\\<open>cost\\<^sub>F [] = 0\\<close>$ and\n$@{prop \"cost\\<^sub>F (t # ts) = cost t + cost\\<^sub>F ts\"}$. However, the modified\nproposition does not hold. A counterexample is the optimum forest\n$$\\includegraphics{forest-optimal.pdf}$$\nfor which the algorithm constructs the tree\n$$\\vcenter{\\hbox{\\includegraphics{tree-suboptimal.pdf}}}\n  \\qquad \\hbox{of greater cost than} \\qquad\n  \\vcenter{\\hbox{\\includegraphics{tree-optimal.pdf}}}$$\n\\<close>"], ["", "section \\<open>Related Work \\label{related-work}\\<close>"], ["", "text \\<open>\nLaurent Th\\'ery's Coq formalization of Huffman's algorithm \\cite{thery-2003,%\nthery-2004} is an obvious yardstick for our work. It has a somewhat wider\nscope, proving among others the isomorphism between prefix codes and full binary\ntrees. With 291 theorems, it is also much larger.\n\nTh\\'ery identified the following difficulties in formalizing the textbook\nproof:\n\n\\begin{enumerate}\n\\item The leaf interchange process that brings the two minimal symbols together\n      is tedious to formalize.\n\n\\item The sibling merging process requires introducing a new symbol for the\n      merged node, which complicates the formalization.\n\n\\item The algorithm constructs the tree in a bottom-up fashion. While top-down\n      procedures can usually be proved by structural induction, bottom-up\n      procedures often require more sophisticated induction principles and\n      larger invariants.\n\n\\item The informal proof relies on the notion of depth of a node. Defining this\n      notion formally is problematic, because the depth can only be seen as a\n      function if the tree is composed of distinct nodes.\n\\end{enumerate}\n\nTo circumvent these difficulties, Th\\'ery introduced the ingenious concept of\ncover. A forest @{term ts} is a {\\em cover\\/} of a tree~$t$ if $t$ can be built\nfrom @{term ts} by adding inner nodes on top of the trees in @{term ts}. The\nterm ``cover'' is easier to understand if the binary trees are drawn with the\nroot at the bottom of the page, like natural trees. Huffman's algorithm is\na refinement of the cover concept. The main proof consists in showing that\nthe cost of @{term \"huffman ts\"} is less than or equal to that of any other\ntree for which @{term ts} is a cover. It relies on a few auxiliary definitions,\nnotably an ``ordered cover'' concept that facilitates structural induction\nand a four-argument depth predicate (confusingly called @{term height}).\nPermutations also play a central role.\n\nIncidentally, our experience suggests that the potential problems identified\nby Th\\'ery can be overcome more directly without too much work, leading to a\nsimpler proof:\n\n\\begin{enumerate}\n\\item Formalizing the leaf interchange did not prove overly tedious. Among our\n      95~lemmas and theorems, 24 concern @{const swapLeaves},\n      @{const swapSyms}, and @{const swapFourSyms}.\n\n\\item The generation of a new symbol for the resulting node when merging two\n      sibling nodes in @{const mergeSibling} was trivially solved by reusing\n      one of the two merged symbols.\n\n\\item The bottom-up nature of the tree construction process was addressed by\n      using the length of the forest as the induction measure and by merging\n      the two minimal symbols, as in Knuth's proof.\n\n\\item By restricting our attention to consistent trees, we were able to define\n      the @{const depth} function simply and meaningfully.\n\\end{enumerate}\n\\<close>"], ["", "section \\<open>Conclusion \\label{conclusion}\\<close>"], ["", "text \\<open>\nThe goal of most formal proofs is to increase our confidence in a result. In\nthe case of Huffman's algorithm, however, the chances that a bug would have\ngone unnoticed for the 56 years since its publication, under the scrutiny of\nleading computer scientists, seem extremely low; and the existence of a Coq\nproof should be sufficient to remove any remaining doubts.\n\nThe main contribution of this document has been to demonstrate that the\ntextbook proof of Huffman's algorithm can be elegantly formalized using\na state-of-the-art theorem prover such as Isabelle/HOL. In the process, we\nuncovered a few minor snags in the proof given in Cormen et\nal.~\\cite{cormen-et-al-2001}.\n\nWe also found that custom induction rules, in combination with suitable\nsimplification rules, greatly help the automatic proof tactics, sometimes\nreducing 30-line proof scripts to one-liners. We successfully applied this\napproach for handling both the ubiquitous ``datatype + well\\-formed\\-ness\npredicate'' combination (@{typ \"'a tree\"} + @{const consistent}) and functions\ndefined by sequential pattern matching (@{const sibling} and\n@{const mergeSibling}). Our experience suggests that such rules, which are\nuncommon in formalizations, are highly valuable and versatile. Moreover,\nIsabelle's \\textit{induction\\_schema} and \\textit{lexicographic\\_order} tactics\nmake these easy to prove.\n\nFormalizing the proof of Huffman's algorithm also led to a deeper\nunderstanding of this classic algorithm. Many of the lemmas, notably the leaf\nsplit commutativity lemma of Section~\\ref{leaf-split-commutativity}, have not\nbeen found in the literature and express fundamental properties of the\nalgorithm. Other discoveries did not find their way into the final proof. In\nparticular, each step of the algorithm appears to preserve the invariant that\nthe nodes in a forest are ordered by weight from left to right, bottom to top,\nas in the example below:\\strut\n$$\\vcenter{\\hbox{\\includegraphics[scale=1.25]{forest-zigzag.pdf}}}$$\nIt is not hard to prove formally that a tree exhibiting this property is\noptimum. On the other hand, proving that the algorithm preserves this invariant\nseems difficult---more difficult than formalizing the textbook proof---and\nremains a suggestion for future work.\n\nA few other directions for future work suggest themselves. First, we could\nformalize some of our hypotheses, notably our restriction to full and\nconsistent binary trees. The current formalization says nothing about the\nalgorithm's application for data compression, so the next step could be to\nextend the proof's scope to cover @{term encode}/@{term decode} functions\nand show that full binary trees are isomorphic to prefix codes, as done in the\nCoq development. Independently, we could generalize the development to $n$-ary\ntrees.\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}