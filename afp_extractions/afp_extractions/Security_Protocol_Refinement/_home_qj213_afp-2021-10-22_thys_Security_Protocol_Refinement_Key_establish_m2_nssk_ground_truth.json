{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m2_nssk.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m2_loc_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_step4_def m2_step5_def \n  m2_step6_def m2_step7_def m2_leak_def m2_fake_def", "lemmas m2_defs = m2_loc_defs m1_defs", "lemmas m2_inv1_keysI = m2_inv1_keys_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv1_keysE [elim] = m2_inv1_keys_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv1_keysD = m2_inv1_keys_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv1_keys_init [iff]:\n  \"init m2 \\<subseteq> m2_inv1_keys\"", "lemma PO_m2_inv1_keys_trans [iff]:\n  \"{m2_inv1_keys} trans m2 {> m2_inv1_keys}\"", "lemma PO_m2_inv1_keys [iff]: \"reach m2 \\<subseteq> m2_inv1_keys\"", "lemmas m2_inv2_keys_forI = m2_inv2_keys_for_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv2_keys_forE [elim] = m2_inv2_keys_for_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv2_keys_forD = m2_inv2_keys_for_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv2_keys_for_init [iff]:\n  \"init m2 \\<subseteq> m2_inv2_keys_for\"", "lemma PO_m2_inv2_keys_for_trans [iff]:\n  \"{m2_inv2_keys_for \\<inter> m2_inv1_keys} trans m2 {> m2_inv2_keys_for}\"", "lemma PO_m2_inv2_keys_for [iff]: \"reach m2 \\<subseteq> m2_inv2_keys_for\"", "lemma m2_inv2_keys_for__extr_insert_key:\n  \"\\<lbrakk> R \\<notin> dom (runs s); s \\<in> m2_inv2_keys_for \\<rbrakk>\n \\<Longrightarrow> extr (insert (aKey (sesK (R$sk))) T) (chan s) = insert (aKey (sesK (R$sk))) (extr T (chan s))\"", "lemmas m2_inv2b_corrKey_leakedI = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv2b_corrKey_leakedE [elim] = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv2b_corrKey_leakedD = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv2b_corrKey_leaked_init [iff]:\n  \"init m2 \\<subseteq> m2_inv2b_corrKey_leaked\"", "lemma PO_m2_inv2b_corrKey_leaked_trans [iff]:\n  \"{m2_inv2b_corrKey_leaked \\<inter> m2_inv1_keys} trans m2 {> m2_inv2b_corrKey_leaked}\"", "lemma PO_m2_inv2b_corrKey_leaked [iff]: \"reach m2 \\<subseteq> m2_inv2b_corrKey_leaked\"", "lemmas m2_inv3a_sesK_comprI = m2_inv3a_sesK_compr_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv3a_sesK_comprE [elim] = m2_inv3a_sesK_compr_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv3a_sesK_comprD = m2_inv3a_sesK_compr_def [THEN setc_def_to_dest, rule_format]", "lemmas insert_commute_aKey = insert_commute [where x=\"aKey K\" for K]", "lemmas m2_inv3a_sesK_compr_simps = \n  m2_inv3a_sesK_comprD\n  m2_inv3a_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  m2_inv3a_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  insert_commute_aKey", "lemma PO_m2_inv3a_sesK_compr_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3a_sesK_compr\"", "lemma PO_m2_inv3a_sesK_compr_trans [iff]:\n  \"{m2_inv3a_sesK_compr} trans m2 {> m2_inv3a_sesK_compr}\"", "lemma PO_m2_inv3a_sesK_compr [iff]: \"reach m2 \\<subseteq> m2_inv3a_sesK_compr\"", "lemmas m2_inv3b_sesK_compr_nonI = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv3b_sesK_compr_nonE [elim] = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv3b_sesK_compr_nonD = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_dest, rule_format]", "lemmas m2_inv3b_sesK_compr_non_simps = \n  m2_inv3b_sesK_compr_nonD\n  m2_inv3b_sesK_compr_nonD [where KK=\"{Kab}\" for Kab, simplified] \n  m2_inv3b_sesK_compr_nonD [where KK=\"insert Kab KK\" for Kab KK, simplified] \n  insert_commute_aKey    \\<comment> \\<open>to get the keys to the front\\<close>", "lemma PO_m2_inv3b_sesK_compr_non_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3b_sesK_compr_non\"", "lemma PO_m2_inv3b_sesK_compr_non_trans [iff]:\n  \"{m2_inv3b_sesK_compr_non} trans m2 {> m2_inv3b_sesK_compr_non}\"", "lemma PO_m2_inv3b_sesK_compr_non [iff]: \"reach m2 \\<subseteq> m2_inv3b_sesK_compr_non\"", "lemmas m2_inv3_extrKeyI = m2_inv3_extrKey_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv3_extrKeyE [elim] = m2_inv3_extrKey_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv3_extrKeyD = m2_inv3_extrKey_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv3_extrKey_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3_extrKey\"", "lemma PO_m2_inv3_extrKey_trans [iff]:\n  \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} trans m2 {> m2_inv3_extrKey}\"", "lemma PO_m2_inv3_extrKey [iff]: \"reach m2 \\<subseteq> m2_inv3_extrKey\"", "lemmas m2_inv4_M2I = m2_inv4_M2_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv4_M2E [elim] = m2_inv4_M2_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv4_M2D = m2_inv4_M2_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv4_M2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2\"", "lemma PO_m2_inv4_M2_trans [iff]:\n  \"{m2_inv4_M2} trans m2 {> m2_inv4_M2}\"", "lemma PO_m2_inv4_M2 [iff]: \"reach m2 \\<subseteq> m2_inv4_M2\"", "lemmas m2_inv4_M3I = m2_inv4_M3_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv4_M3E [elim] = m2_inv4_M3_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv4_M3D = m2_inv4_M3_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv4_M3_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M3\"", "lemma PO_m2_inv4_M3_trans [iff]:\n  \"{m2_inv4_M3} trans m2 {> m2_inv4_M3}\"", "lemma PO_m2_inv4_M3 [iff]: \"reach m2 \\<subseteq> m2_inv4_M3\"", "lemma m2_inv4_M2_M3_unique_names:\nassumes \n  \"Secure Sv A' (Msg [aNon Na, aAgt B', aKey Kab]) \\<in> chan s\" \n  \"Secure Sv B  (Msg [aKey Kab, aAgt A]) \\<in> chan s\" \"aKey Kab \\<notin> extr ik0 (chan s)\" \n  \"s \\<in> m2_inv4_M2\" \"s \\<in> m2_inv4_M3\"\nshows \n  \"A = A' \\<and> B = B'\"", "lemma m2_inv34_M2_authorized:\n  assumes \"Secure Sv A (Msg [aNon N, aAgt B, aKey K]) \\<in> chan s\" \n          \"s \\<in> m2_inv4_M2\" \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv2b_corrKey_leaked\" \n          \"K \\<notin> Domain (leak s)\" \n  shows   \"(K, A) \\<in> azC (runs s)\"", "lemma m2_inv34_M3_authorized:\n  assumes \"Secure Sv B (Msg [aKey K, aAgt A]) \\<in> chan s\" \n          \"s \\<in> m2_inv4_M3\" \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv2b_corrKey_leaked\" \n          \"K \\<notin> Domain (leak s)\" \n  shows  \"(K, B) \\<in> azC (runs s)\"", "lemmas m2_inv5_ikk_svI = m2_inv5_ikk_sv_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv5_ikk_svE [elim] = m2_inv5_ikk_sv_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv5_ikk_svD = m2_inv5_ikk_sv_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma m2_inv5_ikk_sv_derived: \n  \"s \\<in> m2_inv3_extrKey \\<Longrightarrow> s \\<in> m2_inv5_ikk_sv\"", "lemma PO_m2_inv5_ikk_sv [iff]: \"reach m2 \\<subseteq> m2_inv5_ikk_sv\"", "lemmas m2_inv6_ikk_initI = m2_inv6_ikk_init_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv6_ikk_initE [elim] = m2_inv6_ikk_init_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv6_ikk_initD = m2_inv6_ikk_init_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemmas m2_inv7_ikk_respI = m2_inv7_ikk_resp_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv7_ikk_respE [elim] = m2_inv7_ikk_resp_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv7_ikk_respD = m2_inv7_ikk_resp_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemmas m2_inv8_M4I = m2_inv8_M4_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv8_M4E [elim] = m2_inv8_M4_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv8_M4D = m2_inv8_M4_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv8_M4_step1:\n  \"{m2_inv8_M4} m2_step1 Ra A B Na {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step2:\n  \"{m2_inv8_M4} m2_step2 Rb A B {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step3:\n  \"{m2_inv8_M4 \\<inter> m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step4:\n  \"{m2_inv8_M4} m2_step4 Ra A B Na Kab {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step5:\n  \"{m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter> m2_inv4_M2} \n      m2_step5 Rb A B Nb Kab \n   {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step6:\n  \"{m2_inv8_M4} m2_step6 Ra A B Na Nb Kab {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_step7:\n  \"{m2_inv8_M4} m2_step7 Rb A B Nb Kab {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_leak:\n  \"{m2_inv8_M4 \\<inter> m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4_fake:\n  \"{m2_inv8_M4} m2_fake {> m2_inv8_M4}\"", "lemmas PO_m2_inv8_M4_lemmas = \n  PO_m2_inv8_M4_step1 PO_m2_inv8_M4_step2 PO_m2_inv8_M4_step3\n  PO_m2_inv8_M4_step4 PO_m2_inv8_M4_step5 PO_m2_inv8_M4_step6\n  PO_m2_inv8_M4_step7 PO_m2_inv8_M4_leak PO_m2_inv8_M4_fake", "lemma PO_m2_inv8_M4_init [iff]:\n  \"init m2 \\<subseteq> m2_inv8_M4\"", "lemma PO_m2_inv8_M4_trans [iff]:\n  \"{m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for} \n      trans m2 \n   {> m2_inv8_M4}\"", "lemma PO_m2_inv8_M4 [iff]: \"reach m2 \\<subseteq> m2_inv8_M4\"", "lemmas m2_inv8a_init_M2I = m2_inv8a_init_M2_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv8a_init_M2E [elim] = m2_inv8a_init_M2_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv8a_init_M2D = m2_inv8a_init_M2_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv8a_init_M2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv8a_init_M2\"", "lemma PO_m2_inv8a_init_M2_trans [iff]:\n  \"{m2_inv8a_init_M2}  \n      trans m2 \n   {> m2_inv8a_init_M2}\"", "lemma PO_m2_inv8a_init_M2 [iff]: \"reach m2 \\<subseteq> m2_inv8a_init_M2\"", "lemmas m2_inv9a_resp_M3I = m2_inv9a_resp_M3_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv9a_resp_M3E [elim] = m2_inv9a_resp_M3_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv9a_resp_M3D = m2_inv9a_resp_M3_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv9a_resp_M3_init [iff]:\n  \"init m2 \\<subseteq> m2_inv9a_resp_M3\"", "lemma PO_m2_inv9a_resp_M3_trans [iff]:\n  \"{m2_inv9a_resp_M3}  \n      trans m2 \n   {> m2_inv9a_resp_M3}\"", "lemma PO_m2_inv9a_resp_M3 [iff]: \"reach m2 \\<subseteq> m2_inv9a_resp_M3\"", "lemmas m2_inv9_M5I = m2_inv9_M5_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv9_M5E [elim] = m2_inv9_M5_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv9_M5D = m2_inv9_M5_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv9_M5_step1:\n  \"{m2_inv9_M5} m2_step1 Ra A B Na {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step2:\n  \"{m2_inv9_M5} m2_step2 Rb A B {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step3:\n  \"{m2_inv9_M5 \\<inter> m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step4:\n  \"{m2_inv9_M5} m2_step4 Ra A B Na Kab {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step5:\n  \"{m2_inv9_M5} m2_step5 Rb A B Nb Kab {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step6:\n  \"{m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv4_M3}\n     m2_step6 Ra A B Na Nb Kab \n   {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_step7:\n  \"{m2_inv9_M5} m2_step7 Rb A B Nb Kab {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_leak:\n  \"{m2_inv9_M5 \\<inter> m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5_fake:\n  \"{m2_inv9_M5} m2_fake {> m2_inv9_M5}\"", "lemmas PO_m2_inv9_M5_lemmas = \n  PO_m2_inv9_M5_step1 PO_m2_inv9_M5_step2 PO_m2_inv9_M5_step3\n  PO_m2_inv9_M5_step4 PO_m2_inv9_M5_step5 PO_m2_inv9_M5_step6\n  PO_m2_inv9_M5_step7 PO_m2_inv9_M5_leak PO_m2_inv9_M5_fake", "lemma PO_m2_inv9_M5_init [iff]:\n  \"init m2 \\<subseteq> m2_inv9_M5\"", "lemma PO_m2_inv9_M5_trans [iff]:\n  \"{m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> \n    m2_inv4_M2 \\<inter> m2_inv4_M3 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for} \n      trans m2 \n   {> m2_inv9_M5}\"", "lemma PO_m2_inv9_M5 [iff]: \"reach m2 \\<subseteq> m2_inv9_M5\"", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B Na), (m2_step1 Ra A B Na) \n   {> R12}\"", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Rb A B), (m2_step2 Rb A B)\n   {> R12}\"", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12} \n     (m1_step3 Rs A B Na Kab), (m2_step3 Rs A B Na Kab)\n   {> R12}\"", "lemma PO_m2_step4_refines_m1_step4:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2 \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked)} \n     (m1_step4 Ra A B Na Kab), (m2_step4 Ra A B Na Kab)  \n   {> R12}\"", "lemma PO_m2_step5_refines_m1_step5:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M3 \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked)} \n     (m1_step5 Rb A B Nb Kab), (m2_step5 Rb A B Nb Kab) \n   {> R12}\"", "lemma PO_m2_step6_refines_m1_step6:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv8a_init_M2 \\<inter> m2_inv8_M4 \\<inter> m2_inv6_ikk_init)} \n     (m1_step6 Ra A B Na Nb Kab), (m2_step6 Ra A B Na Nb Kab) \n   {> R12}\"", "lemma PO_m2_step7_refines_m1_step7:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv9_M5 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv7_ikk_resp)} \n     (m1_step7 Rb A B Nb Kab), (m2_step7 Rb A B Nb Kab) \n   {> R12}\"", "lemma PO_m2_leak_refines_leak:\n  \"{R12} \n     m1_leak Rs Ra Rb A B, m2_leak Rs Ra Rb A B\n   {> R12}\"", "lemma PO_m2_fake_refines_skip:\n  \"{R12} \n     Id, m2_fake\n   {> R12}\"", "lemma m2_inv6_ikk_init_derived:\nassumes \"(s, t) \\<in> R12\" \"s \\<in> m1_inv2i_serv\" \"t \\<in> m2_inv5_ikk_sv\" \nshows \"t \\<in> m2_inv6_ikk_init\"", "lemma m2_inv7_ikk_resp_derived:\nassumes \"(s, t) \\<in> R12\" \"s \\<in> m1_inv2r_serv\" \"t \\<in> m2_inv5_ikk_sv\" \nshows \"t \\<in> m2_inv7_ikk_resp\"", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_step4_refines_m1_step4\n  PO_m2_step5_refines_m1_step5 PO_m2_step6_refines_m1_step6 \n  PO_m2_step7_refines_m1_step7 PO_m2_leak_refines_leak \n  PO_m2_fake_refines_skip", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\"", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> \n    (reach m1 \\<times> \n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv8_M4 \\<inter> \n      m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked))} \n     (trans m1), (trans m2) \n   {> R12}\"", "lemma PO_obs_consistent_R12 [iff]: \n  \"obs_consistent R12 med21 m1 m2\"", "lemma m2_refines_m1 [iff]:\n  \"refines \n     (R12 \\<inter> \n      (reach m1 \\<times> \n       (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv8_M4 \\<inter> \n        m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey \\<inter> \n        m2_inv2b_corrKey_leaked \\<inter> m2_inv2_keys_for \\<inter> m2_inv1_keys)))\n     med21 m1 m2\"", "lemma m2_implements_m1 [iff]:\n  \"implements med21 m1 m2\"", "lemma PO_m2_sat_m1_inv2i_serv [iff]: \"reach m2 \\<subseteq> m1_inv2i_serv\"", "lemma PO_m2_sat_m1_inv2r_serv [iff]: \"reach m2 \\<subseteq> m1_inv2r_serv\"", "lemma PO_m2_inv6_init_ikk [iff]: \"reach m2 \\<subseteq> m2_inv6_ikk_init\"", "lemma PO_m2_inv6_resp_ikk [iff]: \"reach m2 \\<subseteq> m2_inv7_ikk_resp\""], "translations": [["", "lemmas m2_loc_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_step4_def m2_step5_def \n  m2_step6_def m2_step7_def m2_leak_def m2_fake_def"], ["", "lemmas m2_defs = m2_loc_defs m1_defs"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>inv1: Key definedness\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>All session keys in channel messages stem from existing runs.\\<close>"], ["", "definition \n  m2_inv1_keys :: \"m2_pred\"\nwhere \n  \"m2_inv1_keys \\<equiv> {s. \\<forall>R.\n     aKey (sesK (R$sk)) \\<in> atoms (chan s) \\<or> sesK (R$sk) \\<in> Domain (leak s) \\<longrightarrow> \n       R \\<in> dom (runs s)\n  }\""], ["", "lemmas m2_inv1_keysI = m2_inv1_keys_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv1_keysE [elim] = m2_inv1_keys_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv1_keysD = m2_inv1_keys_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv1_keys_init [iff]:\n  \"init m2 \\<subseteq> m2_inv1_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv1_keys", "by (auto simp add: m2_defs intro!: m2_inv1_keysI)"], ["", "lemma PO_m2_inv1_keys_trans [iff]:\n  \"{m2_inv1_keys} trans m2 {> m2_inv1_keys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv1_keys} TS.trans m2 {> m2_inv1_keys}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv1_keysI)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>R xa xb xc xf xg.\n       \\<lbrakk>xa \\<in> m2_inv1_keys; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; R \\<notin> dom (runs xa);\n        aKey (sesK (R $ sk)) \\<in> atoms (chan xa)\\<rbrakk>\n       \\<Longrightarrow> R = xf\n 2. \\<And>xa xb xc xd xe xf.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe =\n        Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END])\\<rbrakk>\n       \\<Longrightarrow> xf \\<in> dom (runs xa)\n 3. \\<And>R xa xb xc xd xe xf.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey (sesK (R $ sk)) \\<in> atoms (chan xa)\\<rbrakk>\n       \\<Longrightarrow> R \\<in> dom (runs xa)\n 4. \\<And>R xa a b xd.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        xd \\<notin> dom (runs xa); R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xd\n 5. \\<And>R xa a b xe.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        xe \\<notin> dom (runs xa); R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 6. \\<And>R xa a b xb xc xf xg.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xf\n 7. \\<And>R xa a b xb xc xd xi.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xd\n 8. \\<And>R xa a b xb xc xe xi.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 9. \\<And>R xa a b xb xc xd xh xi.\n       \\<lbrakk>xa \\<in> m2_inv1_keys;\n        (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xd\n 10. \\<And>R xa a b xb xc xe xi.\n        \\<lbrakk>xa \\<in> m2_inv1_keys;\n         (sesK (R $ sk), a, b) \\<in> m1_state.leak xa;\n         runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n         dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n         R \\<notin> dom (runs xa)\\<rbrakk>\n        \\<Longrightarrow> R = xe\nA total of 13 subgoals...", "apply (auto dest!: m2_inv1_keysD dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv1_keys [iff]: \"reach m2 \\<subseteq> m2_inv1_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv1_keys", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2: Definedness of used keys\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition \n  m2_inv2_keys_for :: \"m2_pred\"\nwhere \n  \"m2_inv2_keys_for \\<equiv> {s. \\<forall>R.\n     sesK (R$sk) \\<in> keys_for (chan s) \\<longrightarrow> R \\<in> dom (runs s)\n  }\""], ["", "lemmas m2_inv2_keys_forI = m2_inv2_keys_for_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv2_keys_forE [elim] = m2_inv2_keys_for_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv2_keys_forD = m2_inv2_keys_for_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv2_keys_for_init [iff]:\n  \"init m2 \\<subseteq> m2_inv2_keys_for\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv2_keys_for", "by (auto simp add: m2_defs intro!: m2_inv2_keys_forI)"], ["", "lemma PO_m2_inv2_keys_for_trans [iff]:\n  \"{m2_inv2_keys_for \\<inter> m2_inv1_keys} trans m2 {> m2_inv2_keys_for}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv2_keys_for \\<inter>\n     m2_inv1_keys} TS.trans m2 {> m2_inv2_keys_for}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv2_keys_forI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>R xa xb xc xe.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey (sesK (R $ sk)), aAgt xb])\n        \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 2. \\<And>R xa xb xc xe xi.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa;\n        R \\<notin> dom (runs xa);\n        sesK (R $ sk) \\<in> keys_for (chan xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 3. \\<And>R xa xb xc xd xh.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xd = Some (Init, [xb, xc], [aKey (sesK (R $ sk))]);\n        dAuth (sesK (R $ sk)) (Msg [aNon xh]) \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xd\n 4. \\<And>R xa xb xc xd xh xi.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa; R \\<notin> dom (runs xa);\n        sesK (R $ sk) \\<in> keys_for (chan xa)\\<rbrakk>\n       \\<Longrightarrow> R = xd\n 5. \\<And>R xa.\n       \\<lbrakk>sesK (R $ sk)\n                \\<in> keys_for (fake ik0 (dom (runs xa)) (chan xa));\n        xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys\\<rbrakk>\n       \\<Longrightarrow> R \\<in> dom (runs xa)", "apply (auto dest!: m2_inv2_keys_forD dest: m2_inv1_keysD dest: dom_lemmas)\n\\<comment> \\<open>2 subgoals, from step 4 and fake\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R xa xb xc xe.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey (sesK (R $ sk)), aAgt xb])\n        \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 2. \\<And>R xa.\n       \\<lbrakk>sesK (R $ sk)\n                \\<in> keys_for (fake ik0 (dom (runs xa)) (chan xa));\n        xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys\\<rbrakk>\n       \\<Longrightarrow> R \\<in> dom (runs xa)", "apply (rename_tac R xa xb xc xe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>R xa xb xc xe.\n       \\<lbrakk>xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey (sesK (R $ sk)), aAgt xb])\n        \\<in> chan xa;\n        R \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> R = xe\n 2. \\<And>R xa.\n       \\<lbrakk>sesK (R $ sk)\n                \\<in> keys_for (fake ik0 (dom (runs xa)) (chan xa));\n        xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys\\<rbrakk>\n       \\<Longrightarrow> R \\<in> dom (runs xa)", "apply (subgoal_tac \"aKey (sesK (R$sk)) \\<in> atoms (chan xa)\", \n       auto dest!: m2_inv1_keysD dest: dom_lemmas)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R xa.\n       \\<lbrakk>sesK (R $ sk)\n                \\<in> keys_for (fake ik0 (dom (runs xa)) (chan xa));\n        xa \\<in> m2_inv2_keys_for; xa \\<in> m2_inv1_keys\\<rbrakk>\n       \\<Longrightarrow> R \\<in> dom (runs xa)", "apply (auto simp add: keys_for_def, erule fake.cases, fastforce+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv2_keys_for [iff]: \"reach m2 \\<subseteq> m2_inv2_keys_for\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv2_keys_for", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "text \\<open>Useful application of invariant.\\<close>"], ["", "lemma m2_inv2_keys_for__extr_insert_key:\n  \"\\<lbrakk> R \\<notin> dom (runs s); s \\<in> m2_inv2_keys_for \\<rbrakk>\n \\<Longrightarrow> extr (insert (aKey (sesK (R$sk))) T) (chan s) = insert (aKey (sesK (R$sk))) (extr T (chan s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<notin> dom (runs s); s \\<in> m2_inv2_keys_for\\<rbrakk>\n    \\<Longrightarrow> extr (insert (aKey (sesK (R $ sk))) T) (chan s) =\n                      insert (aKey (sesK (R $ sk))) (extr T (chan s))", "by (subgoal_tac \"sesK (R$sk) \\<notin> keys_for (chan s)\") (auto)"], ["", "subsubsection \\<open>inv2b: leaked keys include corrupted ones\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition \n  m2_inv2b_corrKey_leaked :: \"m2_pred\"\nwhere \n  \"m2_inv2b_corrKey_leaked \\<equiv> {s. \\<forall>K.\n     K \\<in> corrKey \\<longrightarrow> K \\<in> Domain (leak s)\n  }\""], ["", "lemmas m2_inv2b_corrKey_leakedI = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv2b_corrKey_leakedE [elim] = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv2b_corrKey_leakedD = m2_inv2b_corrKey_leaked_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv2b_corrKey_leaked_init [iff]:\n  \"init m2 \\<subseteq> m2_inv2b_corrKey_leaked\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv2b_corrKey_leaked", "by (auto simp add: m2_defs intro!: m2_inv2b_corrKey_leakedI)"], ["", "lemma PO_m2_inv2b_corrKey_leaked_trans [iff]:\n  \"{m2_inv2b_corrKey_leaked \\<inter> m2_inv1_keys} trans m2 {> m2_inv2b_corrKey_leaked}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv2b_corrKey_leaked \\<inter>\n     m2_inv1_keys} TS.trans m2 {> m2_inv2b_corrKey_leaked}", "by (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv2b_corrKey_leakedI)"], ["", "lemma PO_m2_inv2b_corrKey_leaked [iff]: \"reach m2 \\<subseteq> m2_inv2b_corrKey_leaked\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv2b_corrKey_leaked", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "subsubsection \\<open>inv3a: Session key compromise\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>A L2 version of a session key comprise invariant. Roughly, it states\nthat adding a set of keys @{term KK} to the parameter \\<open>T\\<close> of @{term extr} \ndoes not help the intruder to extract keys other than those in @{term KK} or\nextractable without adding @{term KK}. \n\\<close>"], ["", "definition \n  m2_inv3a_sesK_compr :: \"m2_state set\"\nwhere \n  \"m2_inv3a_sesK_compr \\<equiv> {s. \\<forall>K KK.\n     \\<^cancel>\\<open>KK \\<subseteq> range sesK \\<longrightarrow>\\<close>\n     aKey K \\<in> extr (aKey`KK \\<union> ik0) (chan s) \\<longleftrightarrow> (K \\<in> KK \\<or> aKey K \\<in> extr ik0 (chan s)) \n  }\""], ["", "lemmas m2_inv3a_sesK_comprI = m2_inv3a_sesK_compr_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv3a_sesK_comprE [elim] = m2_inv3a_sesK_compr_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv3a_sesK_comprD = m2_inv3a_sesK_compr_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Additional lemma to get the keys in front\\<close>"], ["", "lemmas insert_commute_aKey = insert_commute [where x=\"aKey K\" for K]"], ["", "lemmas m2_inv3a_sesK_compr_simps = \n  m2_inv3a_sesK_comprD\n  m2_inv3a_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  m2_inv3a_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  insert_commute_aKey"], ["", "lemma PO_m2_inv3a_sesK_compr_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3a_sesK_compr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv3a_sesK_compr", "by (auto simp add: m2_defs intro!: m2_inv3a_sesK_comprI)"], ["", "lemma PO_m2_inv3a_sesK_compr_trans [iff]:\n  \"{m2_inv3a_sesK_compr} trans m2 {> m2_inv3a_sesK_compr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3a_sesK_compr} TS.trans m2 {> m2_inv3a_sesK_compr}", "by (auto simp add: PO_hoare_defs m2_defs m2_inv3a_sesK_compr_simps intro!: m2_inv3a_sesK_comprI)"], ["", "lemma PO_m2_inv3a_sesK_compr [iff]: \"reach m2 \\<subseteq> m2_inv3a_sesK_compr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3a_sesK_compr", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3b: Session key compromise for nonces\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>A variant of the above for nonces. Roughly, it states that adding \na set of keys @{term KK} to the parameter \\<open>T\\<close> of @{term extr} \ndoes not help the intruder to extract more nonces than those extractable \nwithout adding @{term KK}.\n\nNOTE: This lemma is only needed at the next refinement level.\n\\<close>"], ["", "definition \n  m2_inv3b_sesK_compr_non :: \"m2_state set\"\nwhere \n  \"m2_inv3b_sesK_compr_non \\<equiv> {s. \\<forall>N KK.\n     \\<^cancel>\\<open>KK \\<subseteq> range sesK \\<longrightarrow>\\<close>\n     aNon N \\<in> extr (aKey`KK \\<union> ik0) (chan s) \\<longleftrightarrow> aNon N \\<in> extr ik0 (chan s)\n  }\""], ["", "lemmas m2_inv3b_sesK_compr_nonI = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv3b_sesK_compr_nonE [elim] = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv3b_sesK_compr_nonD = m2_inv3b_sesK_compr_non_def [THEN setc_def_to_dest, rule_format]"], ["", "lemmas m2_inv3b_sesK_compr_non_simps = \n  m2_inv3b_sesK_compr_nonD\n  m2_inv3b_sesK_compr_nonD [where KK=\"{Kab}\" for Kab, simplified] \n  m2_inv3b_sesK_compr_nonD [where KK=\"insert Kab KK\" for Kab KK, simplified] \n  insert_commute_aKey    \\<comment> \\<open>to get the keys to the front\\<close>"], ["", "lemma PO_m2_inv3b_sesK_compr_non_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3b_sesK_compr_non\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv3b_sesK_compr_non", "by (auto simp add: m2_defs intro!: m2_inv3b_sesK_compr_nonI)"], ["", "(* with dSecure instead of dAuth in step5:\n\nlemma PO_m2_inv3b_sesK_compr_non_trans [iff]:\n  \"{m2_inv3b_sesK_compr_non \\<inter> m2_inv3a_sesK_compr} \n     m2_step5 Rb A B Nb Kab \n   {> m2_inv3b_sesK_compr_non}\"\napply (auto simp add: PO_hoare_defs m2_defs m2_inv3b_sesK_compr_non_simps \n                      m2_inv3a_sesK_compr_simps\n         intro!: m2_inv3b_sesK_compr_nonI)\n(* 1 subgoal, unsolvable! *)\noops\n*)"], ["", "lemma PO_m2_inv3b_sesK_compr_non_trans [iff]:\n  \"{m2_inv3b_sesK_compr_non} trans m2 {> m2_inv3b_sesK_compr_non}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3b_sesK_compr_non} TS.trans m2 {> m2_inv3b_sesK_compr_non}", "by (auto simp add: PO_hoare_defs m2_defs m2_inv3b_sesK_compr_non_simps \n         intro!: m2_inv3b_sesK_compr_nonI)"], ["", "lemma PO_m2_inv3b_sesK_compr_non [iff]: \"reach m2 \\<subseteq> m2_inv3b_sesK_compr_non\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3b_sesK_compr_non", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3: Lost session keys\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>inv3: Lost session keys were generated by the server for at least one\nbad agent. This invariant is needed in the proof of the strengthening of the \nauthorization guards in steps 4 and 5 (e.g., @{term \"(Kab, A) \\<in> azC (runs s)\"} \nfor the initiator's step4).\\<close>"], ["", "definition \n  m2_inv3_extrKey :: \"m2_state set\"\nwhere\n  \"m2_inv3_extrKey \\<equiv> {s. \\<forall>K.\n     aKey K \\<in> extr ik0 (chan s) \\<longrightarrow> K \\<notin> corrKey \\<longrightarrow> \n       (\\<exists>R A' B' Na'. K = sesK (R$sk) \\<and>\n          runs s R = Some (Serv, [A', B'], [aNon Na']) \\<and> \n          (A' \\<in> bad \\<or> B' \\<in> bad \\<or> (\\<exists>Nb'. (K, Na', Nb') \\<in> leak s))) \n  }\""], ["", "lemmas m2_inv3_extrKeyI = m2_inv3_extrKey_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv3_extrKeyE [elim] = m2_inv3_extrKey_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv3_extrKeyD = m2_inv3_extrKey_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m2_inv3_extrKey_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3_extrKey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv3_extrKey", "by (auto simp add: m2_defs intro!: m2_inv3_extrKeyI)"], ["", "lemma PO_m2_inv3_extrKey_trans [iff]:\n  \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} trans m2 {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} TS.trans m2 {> m2_inv3_extrKey}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>K xa xd.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xe.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<in> bad;\n        aKey K\n        \\<in> extr (insert (aKey (sesK (xf $ sk))) (insert (aAgt xb) ik0))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<notin> bad;\n        aKey K\n        \\<in> extr (insert (aKey (sesK (xf $ sk))) ik0) (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad;\n        aKey K\n        \\<in> extr (insert (aKey (sesK (xf $ sk))) (insert (aAgt xb) ik0))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 8. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 9. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 10. \\<And>K xa xb xc xe xi.\n        \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n         xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n         runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n         dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n         \\<in> chan xa\\<rbrakk>\n        \\<Longrightarrow> \\<exists>R.\n                             R \\<noteq> xe \\<and>\n                             (R \\<noteq> xe \\<longrightarrow>\n                              K = sesK (R $ sk) \\<and>\n                              (\\<exists>A' B' Na'.\n                                  runs xa R =\n                                  Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                  (A' \\<in> bad \\<or>\n                                   B' \\<in> bad \\<or>\n                                   (\\<exists>Nb'.\n (K, Na', Nb') \\<in> m1_state.leak xa))))\nA total of 11 subgoals...", "apply (auto simp add: m2_inv3a_sesK_compr_simps dest: dom_lemmas)\n\\<comment> \\<open>11 subgoals, sledgehammer\\<close>"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>K xa xd.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xe.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 8. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 9. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 10. \\<And>K xa xb xc xe xi.\n        \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n         xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n         runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n         dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n         \\<in> chan xa\\<rbrakk>\n        \\<Longrightarrow> \\<exists>R.\n                             R \\<noteq> xe \\<and>\n                             (R \\<noteq> xe \\<longrightarrow>\n                              K = sesK (R $ sk) \\<and>\n                              (\\<exists>A' B' Na'.\n                                  runs xa R =\n                                  Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                  (A' \\<in> bad \\<or>\n                                   B' \\<in> bad \\<or>\n                                   (\\<exists>Nb'.\n (K, Na', Nb') \\<in> m1_state.leak xa))))\nA total of 11 subgoals...", "apply (metis m2_inv3_extrKeyD map_definedness_contra)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>K xa xe.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 8. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 9. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 10. \\<And>K xa xb xc xd xe xf.\n        \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n         xa \\<in> m2_inv3a_sesK_compr;\n         runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n         runs xa xd =\n         Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n         runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n         aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>R.\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\nK = sesK (xf $ sk) \\<and> Na' = xd $ na \\<and> Nb' = xe $ nb \\<or>\n(K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD map_definedness_contra)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 8. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 9. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<in> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 8. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<in> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 7. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>K xa xb xc xf xg.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa; xb \\<notin> bad;\n        xc \\<notin> bad; aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = xf \\<longrightarrow>\n                             K = sesK (xf $ sk) \\<and>\n                             (\\<exists>Nb'.\n                                 (K, xg, Nb')\n                                 \\<in> m1_state.leak xa)) \\<and>\n                            (R \\<noteq> xf \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 6. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD map_definedness_contra)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>K xa xb xc xd xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 5. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD not_Cons_self2 prod.inject option.inject)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 4. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD not_Cons_self2 prod.inject option.inject)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>K xa xb xc xd xh xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xd \\<and>\n                            (R \\<noteq> xd \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 3. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD atom.distinct(7) list.inject option.inject prod.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>K xa xb xc xe xi.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> corrKey;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> xe \\<and>\n                            (R \\<noteq> xe \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B' Na'.\n                                 runs xa R =\n                                 Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                 (A' \\<in> bad \\<or>\n                                  B' \\<in> bad \\<or>\n                                  (\\<exists>Nb'.\n(K, Na', Nb') \\<in> m1_state.leak xa))))\n 2. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD atom.distinct(7) list.inject option.inject prod.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K xa xb xc xd xe xf.\n       \\<lbrakk>K \\<notin> corrKey; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr;\n        runs xa xf = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        runs xa xd =\n        Some (Init, [xb, xc], [aKey (sesK (xf $ sk)), aNon (xe $ nb)]);\n        runs xa xe = Some (Resp, [xb, xc], [aKey (sesK (xf $ sk)), END]);\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B' Na'.\n                                runs xa R =\n                                Some (Serv, [A', B'], [aNon Na']) \\<and>\n                                (A' \\<in> bad \\<or>\n                                 B' \\<in> bad \\<or>\n                                 (\\<exists>Nb'.\n                                     K = sesK (xf $ sk) \\<and>\n                                     Na' = xd $ na \\<and>\n                                     Nb' = xe $ nb \\<or>\n                                     (K, Na', Nb') \\<in> m1_state.leak xa)))", "apply (metis m2_inv3_extrKeyD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\napply (aut dest!: m2_inv3_extrKeyD dest: dom_lemmas)        -- {*SLOW*}\n-- {* 18 subgoals; go agressive*}\napply (aut intro!: exI dest: dom_lemmas)\ndone\n*)"], ["", "lemma PO_m2_inv3_extrKey [iff]: \"reach m2 \\<subseteq> m2_inv3_extrKey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3_extrKey", "by (rule_tac J=\"m2_inv3a_sesK_compr\" in inv_rule_incr) (auto)"], ["", "subsubsection \\<open>inv4: Secure channel and message 2\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>inv4: Secure messages to honest agents and server state; one variant \nfor each of M2 and M3. Note that the one for M2 is stronger than the \none for M3.\\<close>"], ["", "definition \n  m2_inv4_M2 :: \"m2_pred\"\nwhere\n  \"m2_inv4_M2 \\<equiv> {s. \\<forall>A B Na Kab.\n     Secure Sv A (Msg [aNon Na, aAgt B, aKey Kab]) \\<in> chan s \\<longrightarrow> A \\<in> good \\<longrightarrow>\n       (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and> runs s Rs = Some (Serv, [A, B], [aNon Na]))\n  }\""], ["", "lemmas m2_inv4_M2I = m2_inv4_M2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv4_M2E [elim] = m2_inv4_M2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv4_M2D = m2_inv4_M2_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv4_M2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv4_M2", "by (auto simp add: m2_defs intro!: m2_inv4_M2I)"], ["", "lemma PO_m2_inv4_M2_trans [iff]:\n  \"{m2_inv4_M2} trans m2 {> m2_inv4_M2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv4_M2} TS.trans m2 {> m2_inv4_M2}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv4_M2I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>A B Na Kab xa xd.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 2. \\<And>A B Na Kab xa xe.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 3. \\<And>A B Na Kab xa xb xc xf xg.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa;\n        StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            (Rs = xf \\<longrightarrow>\n                             Kab = sesK (xf $ sk) \\<and>\n                             xb = A \\<and> xc = B \\<and> xg = Na) \\<and>\n                            (Rs \\<noteq> xf \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 4. \\<And>A B Na Kab xa xb xc xd xi.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 5. \\<And>A B Na Kab xa xb xc xe xi.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 6. \\<And>A B Na Kab xa xb xc xd xh xi.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 7. \\<And>A B Na Kab xa xb xc xe xi.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNon Na]))\n 8. \\<And>A B Na Kab xa.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        A \\<notin> bad; xa \\<in> m2_inv4_M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs xa Rs = Some (Serv, [A, B], [aNon Na])", "apply (auto dest!: m2_inv4_M2D dest: dom_lemmas)\n\\<comment> \\<open>5 subgoals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A B Na xa xb xc xd Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], []);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        \\<forall>Rsa.\n           Rsa = xd \\<or>\n           Rsa \\<noteq> xd \\<and>\n           (Rs = Rsa \\<longrightarrow>\n            runs xa Rsa \\<noteq> Some (Serv, [A, B], [aNon Na]));\n        xb \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A B Na xa xb xc xd Rs Rsa.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], []);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        runs xa Rsa = Some (Serv, [xb, xc], [aNon (xd $ na)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 3. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 4. \\<And>A B Na xa xb xc xd xh xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 5. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))", "apply (force dest!: spec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A B Na xa xb xc xd Rs Rsa.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], []);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        runs xa Rsa = Some (Serv, [xb, xc], [aNon (xd $ na)])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 2. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 3. \\<And>A B Na xa xb xc xd xh xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 4. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))", "apply (force dest!: spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 2. \\<And>A B Na xa xb xc xd xh xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 3. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))", "apply (force dest!: spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A B Na xa xb xc xd xh xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))\n 2. \\<And>A B Na xa xb xc xe xi Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNon Na]))", "apply (rule exI, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv4_M2 [iff]: \"reach m2 \\<subseteq> m2_inv4_M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv4_M2", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv4b: Secure channel and message 3\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition \n  m2_inv4_M3 :: \"m2_pred\"\nwhere\n  \"m2_inv4_M3 \\<equiv> {s. \\<forall>A B Kab.\n     Secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan s \\<longrightarrow> B \\<in> good \\<longrightarrow>\n       (\\<exists>Rs Na. Kab = sesK (Rs$sk) \\<and> runs s Rs = Some (Serv, [A, B], [aNon Na]))\n  }\""], ["", "lemmas m2_inv4_M3I = m2_inv4_M3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv4_M3E [elim] = m2_inv4_M3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv4_M3D = m2_inv4_M3_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv4_M3_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv4_M3", "by (auto simp add: m2_defs intro!: m2_inv4_M3I)"], ["", "lemma PO_m2_inv4_M3_trans [iff]:\n  \"{m2_inv4_M3} trans m2 {> m2_inv4_M3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv4_M3} TS.trans m2 {> m2_inv4_M3}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv4_M3I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>A B Kab xa xd.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 2. \\<And>A B Kab xa xe.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 3. \\<And>A B Kab xa xb xc xf xg.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        xf \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xg]) \\<in> chan xa;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            (Rs = xf \\<longrightarrow>\n                             Kab = sesK (xf $ sk) \\<and>\n                             xb = A \\<and> xc = B) \\<and>\n                            (Rs \\<noteq> xf \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 4. \\<And>A B Kab xa xb xc xd xi.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 5. \\<And>A B Kab xa xb xc xe xi.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xi, aAgt xb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 6. \\<And>A B Kab xa xb xc xd xh xi.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 7. \\<And>A B Kab xa xb xc xe xi.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rs =\n                                 Some (Serv, [A, B], [aNon Na])))\n 8. \\<And>A B Kab xa.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        B \\<notin> bad; xa \\<in> m2_inv4_M3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs xa Rs = Some (Serv, [A, B], [aNon Na]))", "apply (auto dest!: m2_inv4_M3D dest: dom_lemmas)\n\\<comment> \\<open>5 subgoals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A B xa xb xc xd xi Rs Na.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aNon (xd $ na), aAgt xc, aKey xi])\n        \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rsa =\n                                 Some (Serv, [A, B], [aNon Na])))\n 2. \\<And>A B xa xb xc xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        \\<forall>Rsa.\n           Rsa = xe \\<or>\n           Rsa \\<noteq> xe \\<and>\n           (Rs = Rsa \\<longrightarrow>\n            (\\<forall>Na.\n                runs xa Rsa \\<noteq> Some (Serv, [A, B], [aNon Na])));\n        xc \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>A B xa xb xc xe Rs Na Rsa Naa.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        runs xa Rsa = Some (Serv, [xb, xc], [aNon Naa])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rsa =\n                                 Some (Serv, [A, B], [aNon Na])))\n 4. \\<And>A B xa xb xc xd xh xi Rs Na.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xd = Some (Init, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon xh]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rsa =\n                                 Some (Serv, [A, B], [aNon Na])))\n 5. \\<And>A B xa xb xc xe xi Rs Na.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M3;\n        runs xa xe = Some (Resp, [xb, xc], [aKey xi]);\n        dAuth xi (Msg [aNon (xe $ nb), aNon (xe $ nb)]) \\<in> chan xa;\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             (\\<exists>Na.\n                                 runs xa Rsa =\n                                 Some (Serv, [A, B], [aNon Na])))", "apply (force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv4_M3 [iff]: \"reach m2 \\<subseteq> m2_inv4_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv4_M3", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "text \\<open>Consequence needed in proof of inv8/step5\\<close>"], ["", "lemma m2_inv4_M2_M3_unique_names:\nassumes \n  \"Secure Sv A' (Msg [aNon Na, aAgt B', aKey Kab]) \\<in> chan s\" \n  \"Secure Sv B  (Msg [aKey Kab, aAgt A]) \\<in> chan s\" \"aKey Kab \\<notin> extr ik0 (chan s)\" \n  \"s \\<in> m2_inv4_M2\" \"s \\<in> m2_inv4_M3\"\nshows \n  \"A = A' \\<and> B = B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A' \\<and> B = B'", "proof (cases \"A' \\<in> bad \\<or> B \\<in> bad\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A' \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow> A = A' \\<and> B = B'\n 2. \\<not> (A' \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    A = A' \\<and> B = B'", "case True"], ["proof (state)\nthis:\n  A' \\<in> bad \\<or> B \\<in> bad\n\ngoal (2 subgoals):\n 1. A' \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow> A = A' \\<and> B = B'\n 2. \\<not> (A' \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    A = A' \\<and> B = B'", "thus ?thesis"], ["proof (prove)\nusing this:\n  A' \\<in> bad \\<or> B \\<in> bad\n\ngoal (1 subgoal):\n 1. A = A' \\<and> B = B'", "using assms(1-3)"], ["proof (prove)\nusing this:\n  A' \\<in> bad \\<or> B \\<in> bad\n  StatCh secure Sv A' (Msg [aNon Na, aAgt B', aKey Kab]) \\<in> chan s\n  StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan s\n  aKey Kab \\<notin> extr ik0 (chan s)\n\ngoal (1 subgoal):\n 1. A = A' \\<and> B = B'", "by auto"], ["proof (state)\nthis:\n  A = A' \\<and> B = B'\n\ngoal (1 subgoal):\n 1. \\<not> (A' \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    A = A' \\<and> B = B'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A' \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    A = A' \\<and> B = B'", "case False"], ["proof (state)\nthis:\n  \\<not> (A' \\<in> bad \\<or> B \\<in> bad)\n\ngoal (1 subgoal):\n 1. \\<not> (A' \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    A = A' \\<and> B = B'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (A' \\<in> bad \\<or> B \\<in> bad)\n\ngoal (1 subgoal):\n 1. A = A' \\<and> B = B'", "using assms(1,2,4,5)"], ["proof (prove)\nusing this:\n  \\<not> (A' \\<in> bad \\<or> B \\<in> bad)\n  StatCh secure Sv A' (Msg [aNon Na, aAgt B', aKey Kab]) \\<in> chan s\n  StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan s\n  s \\<in> m2_inv4_M2\n  s \\<in> m2_inv4_M3\n\ngoal (1 subgoal):\n 1. A = A' \\<and> B = B'", "by (auto dest!: m2_inv4_M2D m2_inv4_M3D)"], ["proof (state)\nthis:\n  A = A' \\<and> B = B'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>More consequences of invariants. Needed in ref/step4 and ref/step5 \nrespectively to show the strengthening of the authorization guards.\\<close>"], ["", "lemma m2_inv34_M2_authorized:\n  assumes \"Secure Sv A (Msg [aNon N, aAgt B, aKey K]) \\<in> chan s\" \n          \"s \\<in> m2_inv4_M2\" \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv2b_corrKey_leaked\" \n          \"K \\<notin> Domain (leak s)\" \n  shows   \"(K, A) \\<in> azC (runs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "assume \"A \\<in> bad\""], ["proof (state)\nthis:\n  A \\<in> bad\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "hence \"aKey K \\<in> extr ik0 (chan s)\""], ["proof (prove)\nusing this:\n  A \\<in> bad\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "using assms(1)"], ["proof (prove)\nusing this:\n  A \\<in> bad\n  StatCh secure Sv A (Msg [aNon N, aAgt B, aKey K]) \\<in> chan s\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "by auto"], ["proof (state)\nthis:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "using assms(3-)"], ["proof (prove)\nusing this:\n  aKey K \\<in> extr ik0 (chan s)\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv2b_corrKey_leaked\n  K \\<notin> Domain (m1_state.leak s)\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "by auto"], ["proof (state)\nthis:\n  (K, A) \\<in> azC (runs s)\n\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "assume \"A \\<notin> bad\""], ["proof (state)\nthis:\n  A \\<notin> bad\n\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  A \\<notin> bad\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "using assms(1-2)"], ["proof (prove)\nusing this:\n  A \\<notin> bad\n  StatCh secure Sv A (Msg [aNon N, aAgt B, aKey K]) \\<in> chan s\n  s \\<in> m2_inv4_M2\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "by (auto dest: m2_inv4_M2D)"], ["proof (state)\nthis:\n  (K, A) \\<in> azC (runs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m2_inv34_M3_authorized:\n  assumes \"Secure Sv B (Msg [aKey K, aAgt A]) \\<in> chan s\" \n          \"s \\<in> m2_inv4_M3\" \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv2b_corrKey_leaked\" \n          \"K \\<notin> Domain (leak s)\" \n  shows  \"(K, B) \\<in> azC (runs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "assume \"B \\<in> bad\""], ["proof (state)\nthis:\n  B \\<in> bad\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "hence \"aKey K \\<in> extr ik0 (chan s)\""], ["proof (prove)\nusing this:\n  B \\<in> bad\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "using assms(1)"], ["proof (prove)\nusing this:\n  B \\<in> bad\n  StatCh secure Sv B (Msg [aKey K, aAgt A]) \\<in> chan s\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "by auto"], ["proof (state)\nthis:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. \\<not> ?P \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "using assms(3-)"], ["proof (prove)\nusing this:\n  aKey K \\<in> extr ik0 (chan s)\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv2b_corrKey_leaked\n  K \\<notin> Domain (m1_state.leak s)\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "by auto"], ["proof (state)\nthis:\n  (K, B) \\<in> azC (runs s)\n\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "assume \"B \\<notin> bad\""], ["proof (state)\nthis:\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "using assms(1-2)"], ["proof (prove)\nusing this:\n  B \\<notin> bad\n  StatCh secure Sv B (Msg [aKey K, aAgt A]) \\<in> chan s\n  s \\<in> m2_inv4_M3\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "by (auto dest: m2_inv4_M3D)"], ["proof (state)\nthis:\n  (K, B) \\<in> azC (runs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>inv5 (derived): Key secrecy for server\\<close>"], ["", "(*invd*************************************************************************)"], ["", "text \\<open>inv5: Key secrecy from server perspective. This invariant links the \nabstract notion of key secrecy to the intruder key knowledge.\\<close>"], ["", "definition \n  m2_inv5_ikk_sv :: \"m2_pred\"\nwhere\n  \"m2_inv5_ikk_sv \\<equiv> {s. \\<forall>Rs A B Na al.\n     runs s Rs = Some (Serv, [A, B], aNon Na # al) \\<longrightarrow> A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow>\n     aKey (sesK (Rs$sk)) \\<in> extr ik0 (chan s) \\<longrightarrow>\n       (\\<exists>Nb'. (sesK (Rs$sk), Na, Nb') \\<in> leak s)\n  }\""], ["", "lemmas m2_inv5_ikk_svI = m2_inv5_ikk_sv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv5_ikk_svE [elim] = m2_inv5_ikk_sv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv5_ikk_svD = m2_inv5_ikk_sv_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof. This invariant follows from \\<open>m2_inv3_extrKey\\<close>.\\<close>"], ["", "lemma m2_inv5_ikk_sv_derived: \n  \"s \\<in> m2_inv3_extrKey \\<Longrightarrow> s \\<in> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> m2_inv3_extrKey \\<Longrightarrow> s \\<in> m2_inv5_ikk_sv", "by (auto simp add: m2_inv3_extrKey_def m2_inv5_ikk_sv_def) (force)"], ["", "lemma PO_m2_inv5_ikk_sv [iff]: \"reach m2 \\<subseteq> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "have \"reach m2 \\<subseteq> m2_inv3_extrKey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3_extrKey", "by blast"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m2_inv3_extrKey\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "also"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m2_inv3_extrKey\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "have \"... \\<subseteq> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2_inv3_extrKey \\<subseteq> m2_inv5_ikk_sv", "by (blast intro: m2_inv5_ikk_sv_derived)"], ["proof (state)\nthis:\n  m2_inv3_extrKey \\<subseteq> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "finally"], ["proof (chain)\npicking this:\n  reach m2 \\<subseteq> m2_inv5_ikk_sv", "show ?thesis"], ["proof (prove)\nusing this:\n  reach m2 \\<subseteq> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "."], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m2_inv5_ikk_sv\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma PO_m2_inv5_ikk_sv_init [iff]:\n  \"init m2 \\<subseteq> m2_inv5_ikk_sv\"\nby (auto simp add: m2_defs intro!: m2_inv5_ikk_svI)\n\nlemma PO_m2_inv5_ikk_sv_trans [iff]:\n  \"{m2_inv5_ikk_sv \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey} \n     trans m2 \n   {> m2_inv5_ikk_sv}\"\napply (simp add: PO_hoare_defs m2_defs, safe intro!: m2_inv5_ikk_svI)\napply (auto simp add: m2_inv3a_sesK_compr_simps dest: dom_lemmas)\ndone\n\nlemma PO_m2_inv5_ikk_sv [iff]: \"reach m2 \\<subseteq> m2_inv5_ikk_sv\"\nby (rule_tac J=\"m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey\" in inv_rule_incr) (auto)\n*)"], ["", "subsubsection \\<open>inv6 (derived): Key secrecy for initiator\\<close>"], ["", "(*invd**************************************************************************)"], ["", "text \\<open>This invariant is derivable (see below).\\<close>"], ["", "definition \n  m2_inv6_ikk_init :: \"m2_pred\"\nwhere\n  \"m2_inv6_ikk_init \\<equiv> {s. \\<forall>Ra K A B al.\n     runs s Ra = Some (Init, [A, B], aKey K # al) \\<longrightarrow> A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow>\n     aKey K \\<in> extr ik0 (chan s) \\<longrightarrow>\n       (\\<exists>Nb'. (K, Ra $ na, Nb') \\<in> leak s)     \n  }\""], ["", "lemmas m2_inv6_ikk_initI = m2_inv6_ikk_init_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv6_ikk_initE [elim] = m2_inv6_ikk_init_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv6_ikk_initD = m2_inv6_ikk_init_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "subsubsection \\<open>inv7 (derived): Key secrecy for responder\\<close>"], ["", "(*invd**************************************************************************)"], ["", "text \\<open>This invariant is derivable (see below).\\<close>"], ["", "definition \n  m2_inv7_ikk_resp :: \"m2_pred\"\nwhere\n  \"m2_inv7_ikk_resp \\<equiv> {s. \\<forall>Rb K A B al.\n     runs s Rb = Some (Resp, [A, B], aKey K # al) \\<longrightarrow> A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow>\n     aKey K \\<in> extr ik0 (chan s) \\<longrightarrow>\n       K \\<in> Domain (leak s) \n  }\""], ["", "lemmas m2_inv7_ikk_respI = m2_inv7_ikk_resp_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv7_ikk_respE [elim] = m2_inv7_ikk_resp_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv7_ikk_respD = m2_inv7_ikk_resp_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "subsubsection \\<open>inv8: Relating M2 and M4 to the responder state\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>This invariant relates messages M2 and M4 to the responder's state. \nIt is required in the refinement of step 6 to prove that the initiator \nagrees with the responder on (A, B, Nb, Kab).\\<close>"], ["", "definition\n  m2_inv8_M4 :: \"m2_pred\"\nwhere\n  \"m2_inv8_M4 \\<equiv> {s. \\<forall>Kab A B Na Nb.\n     Secure Sv A (Msg [aNon Na, aAgt B, aKey Kab]) \\<in> chan s \\<longrightarrow>\n     dAuth Kab (Msg [aNon Nb]) \\<in> chan s \\<longrightarrow>  \n     aKey Kab \\<notin> extr ik0 (chan s) \\<longrightarrow>\n       (\\<exists>Rb. Nb = Rb$nb \\<and> (\\<exists>al. runs s Rb = Some (Resp, [A, B], aKey Kab # al)))\n  }\""], ["", "(* original open subgoal in refinement proof for step6:\n\n1. \\<And>s t. \\<lbrakk>runs s = runs t; runs t Ra = Some (Init, [A, B], [aKey Kab]);\n           dAuth Kab (Msg [aNon Nb]) \\<in> chan t; A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n          \\<Longrightarrow> \\<exists>Rb nl. Nb = Rb $ nb \\<and> runs t Rb = Some (Resp, [A, B], aKey Kab # nl)\n*)"], ["", "lemmas m2_inv8_M4I = m2_inv8_M4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv8_M4E [elim] = m2_inv8_M4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv8_M4D = m2_inv8_M4_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv8_M4_step1:\n  \"{m2_inv8_M4} m2_step1 Ra A B Na {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_step1 Ra A B Na {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab A B Naa Nb xa.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Naa, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        Ra \\<notin> dom (runs xa); Na = Ra $ na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Ra \\<and>\n                            (Rb \\<noteq> Ra \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [A, B], aKey Kab # al)))", "apply (auto dest!: m2_inv8_M4D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step2:\n  \"{m2_inv8_M4} m2_step2 Rb A B {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_step2 Rb A B {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab A B Na Nb xa.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> chan xa;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        Rb \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            Rba \\<noteq> Rb \\<and>\n                            (Rba \\<noteq> Rb \\<longrightarrow>\n                             Nb = Rba $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [A, B], aKey Kab # al)))", "apply (auto dest!: m2_inv8_M4D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step3:\n  \"{m2_inv8_M4 \\<inter> m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4 \\<inter>\n     m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb]) \\<in> chan xa; A \\<in> bad;\n        B \\<in> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some\n                                  (Resp, [A, B],\n                                   aKey (sesK (Rs $ sk)) # al)))\n 2. \\<And>Kaba Aa Ba Naa Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb]) \\<in> chan xa; A \\<in> bad; B \\<in> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa);\n        StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))\n 3. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb]) \\<in> chan xa; A \\<in> bad;\n        B \\<notin> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) ik0)\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some\n                                  (Resp, [A, B],\n                                   aKey (sesK (Rs $ sk)) # al)))\n 4. \\<And>Kaba Aa Ba Naa Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb]) \\<in> chan xa; A \\<in> bad;\n        B \\<notin> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) ik0) (chan xa);\n        StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))\n 5. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb]) \\<in> chan xa;\n        A \\<notin> bad; B \\<in> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some\n                                  (Resp, [A, B],\n                                   aKey (sesK (Rs $ sk)) # al)))\n 6. \\<And>Kaba Aa Ba Naa Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb]) \\<in> chan xa; A \\<notin> bad;\n        B \\<in> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa);\n        StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))\n 7. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb]) \\<in> chan xa;\n        A \\<notin> bad; B \\<notin> bad;\n        aKey (sesK (Rs $ sk)) \\<notin> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some\n                                  (Resp, [A, B],\n                                   aKey (sesK (Rs $ sk)) # al)))\n 8. \\<And>Kaba Aa Ba Naa Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv8_M4; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb]) \\<in> chan xa; A \\<notin> bad;\n        B \\<notin> bad; aKey Kaba \\<notin> extr ik0 (chan xa);\n        StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Rs \\<and>\n                            (Rb \\<noteq> Rs \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (auto simp add: m2_inv2_keys_for__extr_insert_key dest!: m2_inv8_M4D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step4:\n  \"{m2_inv8_M4} m2_step4 Ra A B Na Kab {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_step4 Ra A B Na Kab {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Naa Nb xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        StatCh secure Sv A (Msg [aNon (Ra $ na), aAgt B, aKey Kab])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Ra \\<and>\n                            (Rb \\<noteq> Ra \\<longrightarrow>\n                             Nb = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (drule m2_inv8_M4D, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba xa Rb al.\n       \\<lbrakk>dAuth Kaba (Msg [aNon (Rb $ nb)]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        StatCh secure Sv A (Msg [aNon (Ra $ na), aAgt B, aKey Kab])\n        \\<in> chan xa;\n        runs xa Rb = Some (Resp, [Aa, Ba], aKey Kaba # al)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            Rba \\<noteq> Ra \\<and>\n                            (Rba \\<noteq> Ra \\<longrightarrow>\n                             Rb = Rba \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (rule exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step5:\n  \"{m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter> m2_inv4_M2} \n      m2_step5 Rb A B Nb Kab \n   {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter>\n     m2_inv4_M2} m2_step5 Rb A B Nb Kab {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa Ba Na xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kab])\n                \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M2;\n        xa \\<in> m2_inv8_M4; xa \\<in> m2_inv4_M3;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> A = Aa\n 2. \\<And>Aa Ba Na xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kab])\n                \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M2;\n        xa \\<in> m2_inv8_M4; xa \\<in> m2_inv4_M3;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> B = Ba\n 3. \\<And>Kaba Aa Ba Na Nba xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kaba])\n                \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M2;\n        xa \\<in> m2_inv8_M4; xa \\<in> m2_inv4_M3;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            (Rba = Rb \\<longrightarrow>\n                             Nba = Rb $ nb \\<and>\n                             A = Aa \\<and> B = Ba \\<and> Kab = Kaba) \\<and>\n                            (Rba \\<noteq> Rb \\<longrightarrow>\n                             Nba = Rba $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (auto dest: m2_inv4_M2_M3_unique_names)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Na Nba xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kaba])\n                \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M2;\n        xa \\<in> m2_inv8_M4; xa \\<in> m2_inv4_M3;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            (Rba = Rb \\<longrightarrow>\n                             Nba = Rb $ nb \\<and>\n                             A = Aa \\<and> B = Ba \\<and> Kab = Kaba) \\<and>\n                            (Rba \\<noteq> Rb \\<longrightarrow>\n                             Nba = Rba $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (auto dest!: m2_inv8_M4D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step6:\n  \"{m2_inv8_M4} m2_step6 Ra A B Na Nb Kab {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_step6 Ra A B Na Nb Kab {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Naa Nba xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Naa, aAgt Ba, aKey Kaba])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Ra \\<and>\n                            (Rb \\<noteq> Ra \\<longrightarrow>\n                             Nba = Rb $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rb =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (auto dest!: m2_inv8_M4D)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba xa Rb al.\n       \\<lbrakk>dAuth Kaba (Msg [aNon (Rb $ nb)]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        runs xa Rb = Some (Resp, [Aa, Ba], aKey Kaba # al)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            Rba \\<noteq> Ra \\<and>\n                            (Rba \\<noteq> Ra \\<longrightarrow>\n                             Rb = Rba \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (rule exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_step7:\n  \"{m2_inv8_M4} m2_step7 Rb A B Nb Kab {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_step7 Rb A B Nb Kab {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Na Nba xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kaba])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab]); Nb = Rb $ nb;\n        dAuth Kab (Msg [aNon (Rb $ nb), aNon (Rb $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rba.\n                            (Rba = Rb \\<longrightarrow>\n                             Nba = Rb $ nb \\<and>\n                             A = Aa \\<and> B = Ba \\<and> Kab = Kaba) \\<and>\n                            (Rba \\<noteq> Rb \\<longrightarrow>\n                             Nba = Rba $ nb \\<and>\n                             (\\<exists>al.\n                                 runs xa Rba =\n                                 Some (Resp, [Aa, Ba], aKey Kaba # al)))", "apply (auto dest!: m2_inv8_M4D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_leak:\n  \"{m2_inv8_M4 \\<inter> m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4 \\<inter>\n     m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab Aa Ba Na Nb xa.\n       \\<lbrakk>StatCh secure Sv Aa (Msg [aNon Na, aAgt Ba, aKey Kab])\n                \\<in> chan xa;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        aKey Kab\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) ik0) (chan xa);\n        xa \\<in> m2_inv8_M4; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa Rs = Some (Serv, [A, B], [aNon (Ra $ na)]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (Rb $ nb)]);\n        runs xa Rb =\n        Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Nb = Rb $ nb \\<and>\n                            (\\<exists>al.\n                                runs xa Rb =\n                                Some (Resp, [Aa, Ba], aKey Kab # al))", "apply (auto simp add: m2_inv3a_sesK_compr_simps dest!: m2_inv8_M4D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8_M4_fake:\n  \"{m2_inv8_M4} m2_fake {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4} m2_fake {> m2_inv8_M4}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8_M4I)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab A B Na Nb xa.\n       \\<lbrakk>StatCh secure Sv A (Msg [aNon Na, aAgt B, aKey Kab])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        dAuth Kab (Msg [aNon Nb]) \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv8_M4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Nb = Rb $ nb \\<and>\n                            (\\<exists>al.\n                                runs xa Rb =\n                                Some (Resp, [A, B], aKey Kab # al))", "apply (erule fake.cases, auto dest!: m2_inv8_M4D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>All together now..\\<close>"], ["", "lemmas PO_m2_inv8_M4_lemmas = \n  PO_m2_inv8_M4_step1 PO_m2_inv8_M4_step2 PO_m2_inv8_M4_step3\n  PO_m2_inv8_M4_step4 PO_m2_inv8_M4_step5 PO_m2_inv8_M4_step6\n  PO_m2_inv8_M4_step7 PO_m2_inv8_M4_leak PO_m2_inv8_M4_fake"], ["", "lemma PO_m2_inv8_M4_init [iff]:\n  \"init m2 \\<subseteq> m2_inv8_M4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv8_M4", "by (auto simp add: m2_defs intro!: m2_inv8_M4I)"], ["", "lemma PO_m2_inv8_M4_trans [iff]:\n  \"{m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for} \n      trans m2 \n   {> m2_inv8_M4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8_M4 \\<inter> m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter>\n     m2_inv3a_sesK_compr \\<inter>\n     m2_inv2_keys_for} TS.trans m2 {> m2_inv8_M4}", "by (auto simp add: m2_def m2_trans_def intro!: PO_m2_inv8_M4_lemmas)"], ["", "lemma PO_m2_inv8_M4 [iff]: \"reach m2 \\<subseteq> m2_inv8_M4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv8_M4", "by (rule_tac J=\"m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter>  m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for\" in inv_rule_incr) \n   (auto)"], ["", "subsubsection \\<open>inv8a: Relating the initiator state to M2\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition\n  m2_inv8a_init_M2 :: \"m2_pred\"\nwhere\n  \"m2_inv8a_init_M2 \\<equiv> {s. \\<forall>Ra A B Kab al.\n     runs s Ra = Some (Init, [A, B], aKey Kab # al) \\<longrightarrow>\n       Secure Sv A (Msg [aNon (Ra$na), aAgt B, aKey Kab]) \\<in> chan s\n  }\""], ["", "lemmas m2_inv8a_init_M2I = m2_inv8a_init_M2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv8a_init_M2E [elim] = m2_inv8a_init_M2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv8a_init_M2D = m2_inv8a_init_M2_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv8a_init_M2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv8a_init_M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv8a_init_M2", "by (auto simp add: m2_defs intro!: m2_inv8a_init_M2I)"], ["", "lemma PO_m2_inv8a_init_M2_trans [iff]:\n  \"{m2_inv8a_init_M2}  \n      trans m2 \n   {> m2_inv8a_init_M2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv8a_init_M2} TS.trans m2 {> m2_inv8a_init_M2}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv8a_init_M2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ra A B Kab al xa.\n       \\<lbrakk>runs xa Ra = Some (Init, [A, B], aKey Kab # al);\n        xa \\<in> m2_inv8a_init_M2\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv A\n                          (Msg [aNon (Ra $ na), aAgt B, aKey Kab])\n                         \\<in> fake ik0 (dom (runs xa)) (chan xa)", "apply (blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv8a_init_M2 [iff]: \"reach m2 \\<subseteq> m2_inv8a_init_M2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv8a_init_M2", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "subsubsection \\<open>inv9a: Relating the responder state to M3\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition\n  m2_inv9a_resp_M3 :: \"m2_pred\"\nwhere\n  \"m2_inv9a_resp_M3 \\<equiv> {s. \\<forall>Rb A B Kab al.\n     runs s Rb = Some (Resp, [A, B], aKey Kab # al) \\<longrightarrow>\n       Secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan s\n  }\""], ["", "lemmas m2_inv9a_resp_M3I = m2_inv9a_resp_M3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv9a_resp_M3E [elim] = m2_inv9a_resp_M3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv9a_resp_M3D = m2_inv9a_resp_M3_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv9a_resp_M3_init [iff]:\n  \"init m2 \\<subseteq> m2_inv9a_resp_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv9a_resp_M3", "by (auto simp add: m2_defs intro!: m2_inv9a_resp_M3I)"], ["", "lemma PO_m2_inv9a_resp_M3_trans [iff]:\n  \"{m2_inv9a_resp_M3}  \n      trans m2 \n   {> m2_inv9a_resp_M3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9a_resp_M3} TS.trans m2 {> m2_inv9a_resp_M3}", "by (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9a_resp_M3I dest: m2_inv9a_resp_M3D) \n   (blast)"], ["", "lemma PO_m2_inv9a_resp_M3 [iff]: \"reach m2 \\<subseteq> m2_inv9a_resp_M3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv9a_resp_M3", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "subsubsection \\<open>inv9: Relating M3 and M5 to the initiator state\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>This invariant relates message M5 to the initiator's state. It is \nrequired in step 7 of the refinement to prove that the initiator agrees with \nthe responder on (A, B, Nb, Kab).\\<close>"], ["", "definition\n  m2_inv9_M5 :: \"m2_pred\"\nwhere\n  \"m2_inv9_M5 \\<equiv> {s. \\<forall>Kab A B Nb.\n     Secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan s \\<longrightarrow>\n     dAuth Kab (Msg [aNon Nb, aNon Nb]) \\<in> chan s \\<longrightarrow> \n     aKey Kab \\<notin> extr ik0 (chan s) \\<longrightarrow>\n       (\\<exists>Ra. runs s Ra = Some (Init, [A, B], [aKey Kab, aNon Nb]))\n  }\""], ["", "(* \n original subgoal in refinement of step 7:\n\n 1. \\<And>s t. \\<lbrakk>runs s = runs t; runs t Rb = Some (Resp, [A, B], [aKey Kab]);\n           dAuth Kab (Msg [Rb$nb, Rb$nb]) \\<in> chan t; A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n          \\<Longrightarrow> \\<exists>Ra. runs t Ra = Some (Init, [A, B], [aKey Kab, aNon Nb])\n*)"], ["", "lemmas m2_inv9_M5I = m2_inv9_M5_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv9_M5E [elim] = m2_inv9_M5_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv9_M5D = m2_inv9_M5_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv9_M5_step1:\n  \"{m2_inv9_M5} m2_step1 Ra A B Na {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_step1 Ra A B Na {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab A B Nb xa.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        dAuth Kab (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        Ra \\<notin> dom (runs xa); Na = Ra $ na\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            Raa \\<noteq> Ra \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [A, B], [aKey Kab, aNon Nb]))", "apply (auto dest!: m2_inv9_M5D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step2:\n  \"{m2_inv9_M5} m2_step2 Rb A B {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_step2 Rb A B {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kab A B Nb xa.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        dAuth Kab (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        Rb \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [A, B], [aKey Kab, aNon Nb]))", "apply (auto dest!: m2_inv9_M5D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step3:\n  \"{m2_inv9_M5 \\<inter> m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5 \\<inter>\n     m2_inv2_keys_for} m2_step3 Rs A B Na Kab {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        A \\<in> bad; B \\<in> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some\n                              (Init, [A, B],\n                               [aKey (sesK (Rs $ sk)), aNon Nb]))\n 2. \\<And>Kaba Aa Ba Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa; A \\<in> bad;\n        B \\<in> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa);\n        StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))\n 3. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        A \\<in> bad; B \\<notin> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) ik0)\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some\n                              (Init, [A, B],\n                               [aKey (sesK (Rs $ sk)), aNon Nb]))\n 4. \\<And>Kaba Aa Ba Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa; A \\<in> bad;\n        B \\<notin> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) ik0) (chan xa);\n        StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))\n 5. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        A \\<notin> bad; B \\<in> bad;\n        aKey (sesK (Rs $ sk))\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some\n                              (Init, [A, B],\n                               [aKey (sesK (Rs $ sk)), aNon Nb]))\n 6. \\<And>Kaba Aa Ba Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa; A \\<notin> bad;\n        B \\<in> bad;\n        aKey Kaba\n        \\<notin> extr (insert (aKey (sesK (Rs $ sk))) (insert (aAgt A) ik0))\n                  (chan xa);\n        StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))\n 7. \\<And>Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth (sesK (Rs $ sk)) (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        A \\<notin> bad; B \\<notin> bad;\n        aKey (sesK (Rs $ sk)) \\<notin> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some\n                              (Init, [A, B],\n                               [aKey (sesK (Rs $ sk)), aNon Nb]))\n 8. \\<And>Kaba Aa Ba Nb xa.\n       \\<lbrakk>xa \\<in> m2_inv9_M5; xa \\<in> m2_inv2_keys_for;\n        Rs \\<notin> dom (runs xa); Kab = sesK (Rs $ sk);\n        Insec A B (Msg [aNon Na]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa; A \\<notin> bad;\n        B \\<notin> bad; aKey Kaba \\<notin> extr ik0 (chan xa);\n        StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rs \\<and>\n                            (Ra \\<noteq> Rs \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))", "apply (auto simp add: m2_inv2_keys_for__extr_insert_key dest!: m2_inv9_M5D dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step4:\n  \"{m2_inv9_M5} m2_step4 Ra A B Na Kab {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_step4 Ra A B Na Kab {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nb xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        StatCh secure Sv A (Msg [aNon (Ra $ na), aAgt B, aKey Kab])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            Raa \\<noteq> Ra \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))", "apply (auto dest!: m2_inv9_M5D dest: dom_lemmas)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nb xa Raa.\n       \\<lbrakk>dAuth Kaba (Msg [aNon Nb, aNon Nb]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        StatCh secure Sv A (Msg [aNon (Ra $ na), aAgt B, aKey Kab])\n        \\<in> chan xa;\n        runs xa Raa = Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            Raa \\<noteq> Ra \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nb]))", "apply (rule exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step5:\n  \"{m2_inv9_M5} m2_step5 Rb A B Nb Kab {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_step5 Rb A B Nb Kab {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))", "apply (drule m2_inv9_M5D, fast, fast, fast, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nba xa Ra.\n       \\<lbrakk>dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Rb = Some (Resp, [A, B], []); Nb = Rb $ nb;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A]) \\<in> chan xa;\n        runs xa Ra = Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))", "apply (rule exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step6:\n  \"{m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv4_M3}\n     m2_step6 Ra A B Na Nb Kab \n   {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n     m2_inv4_M2 \\<inter>\n     m2_inv4_M3} m2_step6 Ra A B Na Nb Kab {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)\n\\<comment> \\<open>2 subgoals\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa Ba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kab, aAgt Aa]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and> B = Ba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kab, aNon Nb]))\n 2. \\<And>Kaba Aa Ba Nba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n                \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and>\n                             B = Ba \\<and>\n                             Kab = Kaba \\<and> Nb = Nba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))", "defer 1"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Kaba Aa Ba Nba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n                \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and>\n                             B = Ba \\<and>\n                             Kab = Kaba \\<and> Nb = Nba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))\n 2. \\<And>Aa Ba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kab, aAgt Aa]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and> B = Ba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kab, aNon Nb]))", "apply (drule m2_inv9_M5D, fast, fast, fast, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Kaba Aa Ba Nba xa Raa.\n       \\<lbrakk>aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa;\n        runs xa Raa = Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and>\n                             B = Ba \\<and>\n                             Kab = Kaba \\<and> Nb = Nba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))\n 2. \\<And>Aa Ba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kab, aAgt Aa]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and> B = Ba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kab, aNon Nb]))", "apply (rename_tac Raa, rule_tac x=Raa in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kab, aAgt Aa]) \\<in> chan xa;\n        aKey Kab \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv4_M3;\n        xa \\<in> m2_inv4_M2; xa \\<in> m2_inv9a_resp_M3; xa \\<in> m2_inv9_M5;\n        xa \\<in> m2_inv8a_init_M2;\n        runs xa Ra = Some (Init, [A, B], [aKey Kab]); Na = Ra $ na;\n        dAuth Kab (Msg [aNon Nb]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Raa.\n                            (Raa = Ra \\<longrightarrow>\n                             A = Aa \\<and> B = Ba) \\<and>\n                            (Raa \\<noteq> Ra \\<longrightarrow>\n                             runs xa Raa =\n                             Some (Init, [Aa, Ba], [aKey Kab, aNon Nb]))", "apply (auto dest!: m2_inv8a_init_M2D m2_inv9a_resp_M3D m2_inv4_M2_M3_unique_names)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_step7:\n  \"{m2_inv9_M5} m2_step7 Rb A B Nb Kab {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_step7 Rb A B Nb Kab {> m2_inv9_M5}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nba xa.\n       \\<lbrakk>StatCh secure Sv Ba (Msg [aKey Kaba, aAgt Aa])\n                \\<in> chan xa;\n        dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab]); Nb = Rb $ nb;\n        dAuth Kab (Msg [aNon (Rb $ nb), aNon (Rb $ nb)])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))", "apply (drule m2_inv9_M5D, fast, fast, fast, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Kaba Aa Ba Nba xa Ra.\n       \\<lbrakk>dAuth Kaba (Msg [aNon Nba, aNon Nba]) \\<in> chan xa;\n        aKey Kaba \\<notin> extr ik0 (chan xa); xa \\<in> m2_inv9_M5;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab]); Nb = Rb $ nb;\n        dAuth Kab (Msg [aNon (Rb $ nb), aNon (Rb $ nb)]) \\<in> chan xa;\n        runs xa Ra = Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             runs xa Ra =\n                             Some (Init, [Aa, Ba], [aKey Kaba, aNon Nba]))", "apply (rule exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv9_M5_leak:\n  \"{m2_inv9_M5 \\<inter> m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5 \\<inter>\n     m2_inv3a_sesK_compr} m2_leak Rs Ra Rb A B {> m2_inv9_M5}", "by (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)\n   (auto simp add: m2_inv3a_sesK_compr_simps dest!: m2_inv9_M5D)"], ["", "lemma PO_m2_inv9_M5_fake:\n  \"{m2_inv9_M5} m2_fake {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5} m2_fake {> m2_inv9_M5}", "by (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv9_M5I)\n   (auto dest!: m2_inv9_M5D)"], ["", "text \\<open>All together now.\\<close>"], ["", "lemmas PO_m2_inv9_M5_lemmas = \n  PO_m2_inv9_M5_step1 PO_m2_inv9_M5_step2 PO_m2_inv9_M5_step3\n  PO_m2_inv9_M5_step4 PO_m2_inv9_M5_step5 PO_m2_inv9_M5_step6\n  PO_m2_inv9_M5_step7 PO_m2_inv9_M5_leak PO_m2_inv9_M5_fake"], ["", "lemma PO_m2_inv9_M5_init [iff]:\n  \"init m2 \\<subseteq> m2_inv9_M5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv9_M5", "by (auto simp add: m2_defs intro!: m2_inv9_M5I)"], ["", "lemma PO_m2_inv9_M5_trans [iff]:\n  \"{m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> \n    m2_inv4_M2 \\<inter> m2_inv4_M3 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for} \n      trans m2 \n   {> m2_inv9_M5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n     m2_inv4_M2 \\<inter>\n     m2_inv4_M3 \\<inter>\n     m2_inv3a_sesK_compr \\<inter>\n     m2_inv2_keys_for} TS.trans m2 {> m2_inv9_M5}", "by (auto simp add: m2_def m2_trans_def intro!: PO_m2_inv9_M5_lemmas)"], ["", "lemma PO_m2_inv9_M5 [iff]: \"reach m2 \\<subseteq> m2_inv9_M5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv9_M5", "by (rule_tac J=\"m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> \n                m2_inv4_M2 \\<inter> m2_inv4_M3 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv2_keys_for\" \n    in inv_rule_incr) \n   (auto simp add: Int_assoc del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The simulation relation. This is a pure superposition refinement.\\<close>"], ["", "definition\n  R12 :: \"(m1_state \\<times> m2_state) set\" where\n  \"R12 \\<equiv> {(s, t). runs s = runs t \\<and> leak s = leak t}\""], ["", "text \\<open>The mediator function projects on the local states.\\<close>"], ["", "definition \n  med21 :: \"m2_obs \\<Rightarrow> m1_obs\" where\n  \"med21 o2 = \\<lparr> runs = runs o2, leak = leak o2 \\<rparr>\""], ["", "text \\<open>Refinement proof.\\<close>"], ["", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B Na), (m2_step1 Ra A B Na) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step1 Ra A B Na, m2_step1 Ra A B Na {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Rb A B), (m2_step2 Rb A B)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step2 Rb A B, m2_step2 Rb A B {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12} \n     (m1_step3 Rs A B Na Kab), (m2_step3 Rs A B Na Kab)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step3 Rs A B Na Kab, m2_step3 Rs A B Na Kab {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step4_refines_m1_step4:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2 \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked)} \n     (m1_step4 Ra A B Na Kab), (m2_step4 Ra A B Na Kab)  \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv4_M2 \\<inter> m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} m1_step4 Ra A B Na\n                                 Kab, m2_step4 Ra A B Na Kab {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, simp_all)     \n   (auto dest: m2_inv34_M2_authorized)"], ["", "lemma PO_m2_step5_refines_m1_step5:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M3 \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked)} \n     (m1_step5 Rb A B Nb Kab), (m2_step5 Rb A B Nb Kab) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv4_M3 \\<inter> m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} m1_step5 Rb A B Nb\n                                 Kab, m2_step5 Rb A B Nb Kab {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, simp_all)\n   (auto dest: m2_inv34_M3_authorized)"], ["", "lemma PO_m2_step6_refines_m1_step6:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv8a_init_M2 \\<inter> m2_inv8_M4 \\<inter> m2_inv6_ikk_init)} \n     (m1_step6 Ra A B Na Nb Kab), (m2_step6 Ra A B Na Nb Kab) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv8a_init_M2 \\<inter> m2_inv8_M4 \\<inter>\n      m2_inv6_ikk_init)} m1_step6 Ra A B Na Nb\n                          Kab, m2_step6 Ra A B Na Nb Kab {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)\n   (auto intro!: m2_inv8_M4D [OF m2_inv8a_init_M2D] dest: m2_inv6_ikk_initD)"], ["", "lemma PO_m2_step7_refines_m1_step7:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv9_M5 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv7_ikk_resp)} \n     (m1_step7 Rb A B Nb Kab), (m2_step7 Rb A B Nb Kab) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv9a_resp_M3 \\<inter>\n      m2_inv7_ikk_resp)} m1_step7 Rb A B Nb\n                          Kab, m2_step7 Rb A B Nb Kab {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)\n   (auto intro!: m2_inv9_M5D [OF m2_inv9a_resp_M3D] dest: m2_inv7_ikk_respD)"], ["", "lemma PO_m2_leak_refines_leak:\n  \"{R12} \n     m1_leak Rs Ra Rb A B, m2_leak Rs Ra Rb A B\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_leak Rs Ra Rb A B, m2_leak Rs Ra Rb A B {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_fake_refines_skip:\n  \"{R12} \n     Id, m2_fake\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} Id, m2_fake {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "text \\<open>Consequences of simulation relation and invariants.\\<close>"], ["", "lemma m2_inv6_ikk_init_derived:\nassumes \"(s, t) \\<in> R12\" \"s \\<in> m1_inv2i_serv\" \"t \\<in> m2_inv5_ikk_sv\" \nshows \"t \\<in> m2_inv6_ikk_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> m2_inv6_ikk_init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> m2_inv6_ikk_init", "have \"t \\<in> m1_inv2i_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> m1_inv2i_serv", "using assms(1,2)"], ["proof (prove)\nusing this:\n  (s, t) \\<in> R12\n  s \\<in> m1_inv2i_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m1_inv2i_serv", "by (simp add: R12_def m1_inv2i_serv_def)"], ["proof (state)\nthis:\n  t \\<in> m1_inv2i_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv6_ikk_init", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> m1_inv2i_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv6_ikk_init", "using assms(3)"], ["proof (prove)\nusing this:\n  t \\<in> m1_inv2i_serv\n  t \\<in> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv6_ikk_init", "by (auto simp add: m2_inv6_ikk_init_def dest: m1_inv2i_servD m2_inv5_ikk_svD)"], ["proof (state)\nthis:\n  t \\<in> m2_inv6_ikk_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m2_inv7_ikk_resp_derived:\nassumes \"(s, t) \\<in> R12\" \"s \\<in> m1_inv2r_serv\" \"t \\<in> m2_inv5_ikk_sv\" \nshows \"t \\<in> m2_inv7_ikk_resp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> m2_inv7_ikk_resp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> m2_inv7_ikk_resp", "have \"t \\<in> m1_inv2r_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> m1_inv2r_serv", "using assms(1,2)"], ["proof (prove)\nusing this:\n  (s, t) \\<in> R12\n  s \\<in> m1_inv2r_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m1_inv2r_serv", "by (simp add: R12_def m1_inv2r_serv_def)"], ["proof (state)\nthis:\n  t \\<in> m1_inv2r_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv7_ikk_resp", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> m1_inv2r_serv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv7_ikk_resp", "using assms(3)"], ["proof (prove)\nusing this:\n  t \\<in> m1_inv2r_serv\n  t \\<in> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. t \\<in> m2_inv7_ikk_resp", "by (auto simp add: m2_inv7_ikk_resp_def dest!: m1_inv2r_servD m2_inv5_ikk_svD)"], ["proof (state)\nthis:\n  t \\<in> m2_inv7_ikk_resp\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_step4_refines_m1_step4\n  PO_m2_step5_refines_m1_step5 PO_m2_step6_refines_m1_step6 \n  PO_m2_step7_refines_m1_step7 PO_m2_leak_refines_leak \n  PO_m2_fake_refines_skip"], ["", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> R12 `` init m1", "by (auto simp add: R12_def m2_defs)"], ["", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> \n    (reach m1 \\<times> \n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv8_M4 \\<inter> \n      m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey \\<inter> m2_inv2b_corrKey_leaked))} \n     (trans m1), (trans m2) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     reach m1 \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "proof -\n  \\<comment> \\<open>derive the key secrecy invariants from simulation relation and the other invariants\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     reach m1 \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "let ?pre' = \"R12 \\<inter> (UNIV \\<times> (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> \n               m2_inv8_M4 \\<inter> m2_inv7_ikk_resp \\<inter> m2_inv6_ikk_init \\<inter> m2_inv5_ikk_sv \\<inter> \n               m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey \\<inter> \n               m2_inv2b_corrKey_leaked))\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     reach m1 \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "show ?thesis (is \"{?pre} ?t1, ?t2 {>?post}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     reach m1 \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "proof (rule relhoare_conseq_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. {?pre'} TS.trans m1, TS.trans m2 {> R12}\n 2. R12 \\<inter>\n    reach m1 \\<times>\n    (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n     m2_inv8_M4 \\<inter>\n     m2_inv4_M3 \\<inter>\n     m2_inv4_M2 \\<inter>\n     m2_inv3a_sesK_compr \\<inter>\n     m2_inv3_extrKey \\<inter>\n     m2_inv2b_corrKey_leaked)\n    \\<subseteq> ?pre'", "show \"?pre \\<subseteq> ?pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R12 \\<inter>\n    reach m1 \\<times>\n    (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n     m2_inv8_M4 \\<inter>\n     m2_inv4_M3 \\<inter>\n     m2_inv4_M2 \\<inter>\n     m2_inv3a_sesK_compr \\<inter>\n     m2_inv3_extrKey \\<inter>\n     m2_inv2b_corrKey_leaked)\n    \\<subseteq> R12 \\<inter>\n                UNIV \\<times>\n                (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n                 m2_inv9a_resp_M3 \\<inter>\n                 m2_inv8_M4 \\<inter>\n                 m2_inv7_ikk_resp \\<inter>\n                 m2_inv6_ikk_init \\<inter>\n                 m2_inv5_ikk_sv \\<inter>\n                 m2_inv4_M3 \\<inter>\n                 m2_inv4_M2 \\<inter>\n                 m2_inv3a_sesK_compr \\<inter>\n                 m2_inv3_extrKey \\<inter>\n                 m2_inv2b_corrKey_leaked)", "by (auto intro: m2_inv6_ikk_init_derived m2_inv7_ikk_resp_derived m2_inv5_ikk_sv_derived)"], ["proof (state)\nthis:\n  R12 \\<inter>\n  reach m1 \\<times>\n  (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n   m2_inv8_M4 \\<inter>\n   m2_inv4_M3 \\<inter>\n   m2_inv4_M2 \\<inter>\n   m2_inv3a_sesK_compr \\<inter>\n   m2_inv3_extrKey \\<inter>\n   m2_inv2b_corrKey_leaked)\n  \\<subseteq> R12 \\<inter>\n              UNIV \\<times>\n              (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n               m2_inv9a_resp_M3 \\<inter>\n               m2_inv8_M4 \\<inter>\n               m2_inv7_ikk_resp \\<inter>\n               m2_inv6_ikk_init \\<inter>\n               m2_inv5_ikk_sv \\<inter>\n               m2_inv4_M3 \\<inter>\n               m2_inv4_M2 \\<inter>\n               m2_inv3a_sesK_compr \\<inter>\n               m2_inv3_extrKey \\<inter>\n               m2_inv2b_corrKey_leaked)\n\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv7_ikk_resp \\<inter>\n      m2_inv6_ikk_init \\<inter>\n      m2_inv5_ikk_sv \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv7_ikk_resp \\<inter>\n      m2_inv6_ikk_init \\<inter>\n      m2_inv5_ikk_sv \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "show \"{?pre'} ?t1, ?t2 {> ?post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n      m2_inv9a_resp_M3 \\<inter>\n      m2_inv8_M4 \\<inter>\n      m2_inv7_ikk_resp \\<inter>\n      m2_inv6_ikk_init \\<inter>\n      m2_inv5_ikk_sv \\<inter>\n      m2_inv4_M3 \\<inter>\n      m2_inv4_M2 \\<inter>\n      m2_inv3a_sesK_compr \\<inter>\n      m2_inv3_extrKey \\<inter>\n      m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}", "by (auto simp add: m2_def m2_trans_def m1_def m1_trans_def)\n         (blast intro!: PO_m2_trans_refines_m1_trans)+"], ["proof (state)\nthis:\n  {R12 \\<inter>\n   UNIV \\<times>\n   (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n    m2_inv8_M4 \\<inter>\n    m2_inv7_ikk_resp \\<inter>\n    m2_inv6_ikk_init \\<inter>\n    m2_inv5_ikk_sv \\<inter>\n    m2_inv4_M3 \\<inter>\n    m2_inv4_M2 \\<inter>\n    m2_inv3a_sesK_compr \\<inter>\n    m2_inv3_extrKey \\<inter>\n    m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {R12 \\<inter>\n   reach m1 \\<times>\n   (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter>\n    m2_inv8_M4 \\<inter>\n    m2_inv4_M3 \\<inter>\n    m2_inv4_M2 \\<inter>\n    m2_inv3a_sesK_compr \\<inter>\n    m2_inv3_extrKey \\<inter>\n    m2_inv2b_corrKey_leaked)} TS.trans m1, TS.trans m2 {> R12}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_obs_consistent_R12 [iff]: \n  \"obs_consistent R12 med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R12 med21 m1 m2", "by (auto simp add: obs_consistent_def R12_def med21_def m2_defs)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma m2_refines_m1 [iff]:\n  \"refines \n     (R12 \\<inter> \n      (reach m1 \\<times> \n       (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter> m2_inv9a_resp_M3 \\<inter> m2_inv8_M4 \\<inter> \n        m2_inv4_M3 \\<inter> m2_inv4_M2 \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey \\<inter> \n        m2_inv2b_corrKey_leaked \\<inter> m2_inv2_keys_for \\<inter> m2_inv1_keys)))\n     med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R12 \\<inter>\n      reach m1 \\<times>\n      (m2_inv9_M5 \\<inter> m2_inv8a_init_M2 \\<inter>\n       m2_inv9a_resp_M3 \\<inter>\n       m2_inv8_M4 \\<inter>\n       m2_inv4_M3 \\<inter>\n       m2_inv4_M2 \\<inter>\n       m2_inv3a_sesK_compr \\<inter>\n       m2_inv3_extrKey \\<inter>\n       m2_inv2b_corrKey_leaked \\<inter>\n       m2_inv2_keys_for \\<inter>\n       m2_inv1_keys))\n     med21 m1 m2", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma m2_implements_m1 [iff]:\n  \"implements med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med21 m1 m2", "by (rule refinement_soundness) (auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Inherited and derived invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Show preservation of invariants @{term \"m1_inv2i_serv\"} and\n@{term \"m1_inv2r_serv\"} from \\<open>m1\\<close>.\\<close>"], ["", "(*invh*************************************************************************)"], ["", "lemma PO_m2_sat_m1_inv2i_serv [iff]: \"reach m2 \\<subseteq> m1_inv2i_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m1_inv2i_serv", "apply (rule_tac Pa=m1_inv2i_serv and Qa=m1_inv2i_serv and Q=m1_inv2i_serv \n       in m2_implements_m1 [THEN [5] internal_invariant_translation])"], ["proof (prove)\ngoal (4 subgoals):\n 1. reach m1 \\<subseteq> m1_inv2i_serv\n 2. m1_inv2i_serv \\<subseteq> obs m1 -` m1_inv2i_serv\n 3. med21 -` m1_inv2i_serv \\<subseteq> m1_inv2i_serv\n 4. obs m2 -` m1_inv2i_serv \\<subseteq> m1_inv2i_serv", "apply (auto simp add: m2_loc_defs med21_def intro!: m1_inv2i_servI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*invh*************************************************************************)"], ["", "lemma PO_m2_sat_m1_inv2r_serv [iff]: \"reach m2 \\<subseteq> m1_inv2r_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m1_inv2r_serv", "by (rule_tac Pa=m1_inv2r_serv and Qa=m1_inv2r_serv and Q=m1_inv2r_serv\n    in m2_implements_m1 [THEN [5] internal_invariant_translation])\n   (fastforce simp add: m2_defs med21_def intro!: m1_inv2r_servI)+"], ["", "text \\<open>Now we derive the additional invariants for the initiator and the responder \n(see above for the definitions).\\<close>"], ["", "lemma PO_m2_inv6_init_ikk [iff]: \"reach m2 \\<subseteq> m2_inv6_ikk_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "have \"reach m2 \\<subseteq> m1_inv2i_serv \\<inter> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m1_inv2i_serv \\<inter> m2_inv5_ikk_sv", "by simp"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m1_inv2i_serv \\<inter> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "also"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m1_inv2i_serv \\<inter> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "have \"... \\<subseteq> m2_inv6_ikk_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1_inv2i_serv \\<inter> m2_inv5_ikk_sv \\<subseteq> m2_inv6_ikk_init", "by (blast intro!: m2_inv6_ikk_initI dest: m2_inv5_ikk_svD)"], ["proof (state)\nthis:\n  m1_inv2i_serv \\<inter> m2_inv5_ikk_sv \\<subseteq> m2_inv6_ikk_init\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "finally"], ["proof (chain)\npicking this:\n  reach m2 \\<subseteq> m2_inv6_ikk_init", "show ?thesis"], ["proof (prove)\nusing this:\n  reach m2 \\<subseteq> m2_inv6_ikk_init\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv6_ikk_init", "."], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m2_inv6_ikk_init\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_m2_inv6_resp_ikk [iff]: \"reach m2 \\<subseteq> m2_inv7_ikk_resp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "have \"reach m2 \\<subseteq> m1_inv2r_serv \\<inter> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m1_inv2r_serv \\<inter> m2_inv5_ikk_sv", "by simp"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m1_inv2r_serv \\<inter> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "also"], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m1_inv2r_serv \\<inter> m2_inv5_ikk_sv\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "have \"... \\<subseteq> m2_inv7_ikk_resp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1_inv2r_serv \\<inter> m2_inv5_ikk_sv \\<subseteq> m2_inv7_ikk_resp", "by (blast intro!: m2_inv7_ikk_respI dest: m2_inv5_ikk_svD)"], ["proof (state)\nthis:\n  m1_inv2r_serv \\<inter> m2_inv5_ikk_sv \\<subseteq> m2_inv7_ikk_resp\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "finally"], ["proof (chain)\npicking this:\n  reach m2 \\<subseteq> m2_inv7_ikk_resp", "show ?thesis"], ["proof (prove)\nusing this:\n  reach m2 \\<subseteq> m2_inv7_ikk_resp\n\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv7_ikk_resp", "."], ["proof (state)\nthis:\n  reach m2 \\<subseteq> m2_inv7_ikk_resp\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}