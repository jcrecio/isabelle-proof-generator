{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Auth_simple/m2_auth_chan.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m2_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_fake_def", "lemmas m2_inv1_authI = \n  m2_inv1_auth_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv1_authE [elim] = \n  m2_inv1_auth_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv1_authD [dest] = \n  m2_inv1_auth_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv1_auth\"", "lemma PO_m2_inv2_trans [iff]:\n  \"{m2_inv1_auth} trans m2 {> m2_inv1_auth}\"", "lemma PO_m2_inv2 [iff]: \"reach m2 \\<subseteq> m2_inv1_auth\"", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B Na), (m2_step1 Ra A B Na) \n   {> R12}\"", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Ra A B Na Nb), (m2_step2 Ra A B Na Nb) \n   {> R12}\"", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12 \\<inter> UNIV \\<times> m2_inv1_auth} \n     (m1_step3 Ra A B Na Nb), (m2_step3 Ra A B Na Nb) \n   {> R12}\"", "lemma PO_m2_fake_refines_m1_skip:\n  \"{R12} Id, m2_fake {> R12}\"", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_fake_refines_m1_skip", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\"", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> UNIV \\<times> m2_inv1_auth} \n     (trans m1), (trans m2) \n   {> R12}\"", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R12 med21 m1 m2\"", "lemma m2_refines_m1:\n  \"refines \n     (R12 \\<inter> UNIV \\<times> m2_inv1_auth)\n     med21 m1 m2\""], "translations": [["", "lemmas m2_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_fake_def"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Authentic channel and responder\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>This property relates the messages in the authentic channel to the \nresponder run frame.\\<close>"], ["", "definition \n  m2_inv1_auth :: \"m2_state set\" where\n  \"m2_inv1_auth \\<equiv> {s. \\<forall>A B Na Nb. \n     Auth B A (Msg [aNon Nb, aNon Na]) \\<in> chan s \\<longrightarrow> B \\<notin> bad \\<longrightarrow> A \\<notin> bad \\<longrightarrow> \n       (\\<exists>Rb. runs s Rb = Some (Resp, [A, B], [aNon Na]) \\<and> Nb = Rb$0)\n  }\""], ["", "lemmas m2_inv1_authI = \n  m2_inv1_auth_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv1_authE [elim] = \n  m2_inv1_auth_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv1_authD [dest] = \n  m2_inv1_auth_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv2_init [iff]:\n  \"init m2 \\<subseteq> m2_inv1_auth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv1_auth", "by (auto simp add: PO_hoare_def m2_defs intro!: m2_inv1_authI)"], ["", "lemma PO_m2_inv2_trans [iff]:\n  \"{m2_inv1_auth} trans m2 {> m2_inv1_auth}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv1_auth} TS.trans m2 {> m2_inv1_auth}", "apply (auto simp add: PO_hoare_def m2_defs intro!: m2_inv1_authI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A B Na Nb xa xd.\n       \\<lbrakk>Auth B A (Msg [aNon Nb, aNon Na]) \\<in> chan xa;\n        B \\<notin> bad; A \\<notin> bad; xa \\<in> m2_inv1_auth;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xd \\<and>\n                            (Rb \\<noteq> xd \\<longrightarrow>\n                             runs xa Rb =\n                             Some (Resp, [A, B], [aNon Na]) \\<and>\n                             Nb = Rb $ 0)\n 2. \\<And>A B Na Nb xa xb xc xe xf.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad; xa \\<in> m2_inv1_auth;\n        xe \\<notin> dom (runs xa);\n        Insec xb xc (Msg [aNon xf]) \\<in> chan xa;\n        Auth B A (Msg [aNon Nb, aNon Na]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            (Rb = xe \\<longrightarrow>\n                             xb = A \\<and>\n                             xc = B \\<and>\n                             xf = Na \\<and> Nb = xe $ 0) \\<and>\n                            (Rb \\<noteq> xe \\<longrightarrow>\n                             runs xa Rb =\n                             Some (Resp, [A, B], [aNon Na]) \\<and>\n                             Nb = Rb $ 0)\n 3. \\<And>A B Na Nb xa xb xc xd xg.\n       \\<lbrakk>Auth B A (Msg [aNon Nb, aNon Na]) \\<in> chan xa;\n        B \\<notin> bad; A \\<notin> bad; xa \\<in> m2_inv1_auth;\n        runs xa xd = Some (Init, [xb, xc], []);\n        Auth xc xb (Msg [aNon xg, aNon (xd $ 0)]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xd \\<and>\n                            (Rb \\<noteq> xd \\<longrightarrow>\n                             runs xa Rb =\n                             Some (Resp, [A, B], [aNon Na]) \\<and>\n                             Nb = Rb $ 0)\n 4. \\<And>A B Na Nb xa.\n       \\<lbrakk>Auth B A (Msg [aNon Nb, aNon Na])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        B \\<notin> bad; A \\<notin> bad; xa \\<in> m2_inv1_auth\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            runs xa Rb =\n                            Some (Resp, [A, B], [aNon Na]) \\<and>\n                            Nb = Rb $ 0", "apply (auto dest: dom_lemmas)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B Na Nb xa xb xc xd xg.\n       \\<lbrakk>Auth B A (Msg [aNon Nb, aNon Na]) \\<in> chan xa;\n        B \\<notin> bad; A \\<notin> bad; xa \\<in> m2_inv1_auth;\n        runs xa xd = Some (Init, [xb, xc], []);\n        Auth xc xb (Msg [aNon xg, aNon (xd $ 0)]) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xd \\<and>\n                            (Rb \\<noteq> xd \\<longrightarrow>\n                             runs xa Rb =\n                             Some (Resp, [A, B], [aNon Na]) \\<and>\n                             Nb = Rb $ 0)", "apply (force)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* SLOW *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv2 [iff]: \"reach m2 \\<subseteq> m2_inv1_auth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv1_auth", "by (rule_tac inv_rule_incr) (auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Simulation relation and mediator function. This is a pure superposition \nrefinement.\\<close>"], ["", "definition\n  R12 :: \"(m1_state \\<times> m2_state) set\" where\n  \"R12 \\<equiv> {(s, t). runs s = runs t}\"           \\<comment> \\<open>That's it!\\<close>"], ["", "definition \n  med21 :: \"m2_obs \\<Rightarrow> m1_obs\" where\n  \"med21 \\<equiv> id\""], ["", "text \\<open>Refinement proof\\<close>"], ["", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B Na), (m2_step1 Ra A B Na) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step1 Ra A B Na, m2_step1 Ra A B Na {> R12}", "by (auto simp add: PO_rhoare_defs R12_def m1_defs m2_defs)"], ["", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Ra A B Na Nb), (m2_step2 Ra A B Na Nb) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step2 Ra A B Na Nb, m2_step2 Ra A B Na Nb {> R12}", "by (auto simp add: PO_rhoare_defs R12_def m1_defs m2_defs)"], ["", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12 \\<inter> UNIV \\<times> m2_inv1_auth} \n     (m1_step3 Ra A B Na Nb), (m2_step3 Ra A B Na Nb) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     m2_inv1_auth} m1_step3 Ra A B Na Nb, m2_step3 Ra A B Na Nb {> R12}", "by (auto simp add: PO_rhoare_defs R12_def m1_defs m2_defs)"], ["", "text \\<open>New fake event refines skip.\\<close>"], ["", "lemma PO_m2_fake_refines_m1_skip:\n  \"{R12} Id, m2_fake {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} Id, m2_fake {> R12}", "by (auto simp add: PO_rhoare_defs R12_def m1_defs m2_defs)"], ["", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_fake_refines_m1_skip"], ["", "text \\<open>All together now...\\<close>"], ["", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> R12 `` init m1", "by (auto simp add: R12_def m1_defs m2_defs)"], ["", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> UNIV \\<times> m2_inv1_auth} \n     (trans m1), (trans m2) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times> m2_inv1_auth} TS.trans m1, TS.trans m2 {> R12}", "apply (auto simp add: m2_def m2_trans_def m1_def m1_trans_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xd.\n       {R12 \\<inter>\n        UNIV \\<times>\n        m2_inv1_auth} (\\<Union>x xa xb xc xd Nb.\n                          m1_step1 xb x xa xd \\<union>\n                          m1_step2 xc x xa xd Nb \\<union>\n                          m1_step3 xb x xa xd\n                           Nb)\\<^sup>=, m2_step1 xb x xa xd {> R12}\n 2. \\<And>x xa xc xd Nb.\n       {R12 \\<inter>\n        UNIV \\<times>\n        m2_inv1_auth} (\\<Union>x xa xb xc xd Nb.\n                          m1_step1 xb x xa xd \\<union>\n                          m1_step2 xc x xa xd Nb \\<union>\n                          m1_step3 xb x xa xd\n                           Nb)\\<^sup>=, m2_step2 xc x xa xd Nb {> R12}\n 3. \\<And>x xa xb xd Nb.\n       {R12 \\<inter>\n        UNIV \\<times>\n        m2_inv1_auth} (\\<Union>x xa xb xc xd Nb.\n                          m1_step1 xb x xa xd \\<union>\n                          m1_step2 xc x xa xd Nb \\<union>\n                          m1_step3 xb x xa xd\n                           Nb)\\<^sup>=, m2_step3 xb x xa xd Nb {> R12}\n 4. {R12 \\<inter>\n     UNIV \\<times>\n     m2_inv1_auth} (\\<Union>x xa xb xc xd Nb.\n                       m1_step1 xb x xa xd \\<union>\n                       m1_step2 xc x xa xd Nb \\<union>\n                       m1_step3 xb x xa xd Nb)\\<^sup>=, m2_fake {> R12}", "apply (blast intro!: PO_m2_trans_refines_m1_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R12 med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R12 med21 m1 m2", "by (auto simp add: obs_consistent_def R12_def med21_def m1_defs m2_defs)"], ["", "lemma m2_refines_m1:\n  \"refines \n     (R12 \\<inter> UNIV \\<times> m2_inv1_auth)\n     med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R12 \\<inter> UNIV \\<times> m2_inv1_auth) med21 m1 m2", "by (rule Refinement_using_invariants) (auto)"], ["", "end"]]}