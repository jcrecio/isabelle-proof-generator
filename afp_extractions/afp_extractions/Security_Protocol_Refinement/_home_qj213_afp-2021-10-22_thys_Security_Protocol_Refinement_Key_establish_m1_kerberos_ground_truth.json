{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m1_kerberos.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m1_loc_defs = \n  m1_def m1_init_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def m1_step4_def m1_step5_def \n  m1_step6_def m1_leak_def m1_purge_def m1_tick_def", "lemmas m1_defs = m1_loc_defs m1a_defs", "lemma m1_obs_id [simp]: \"obs m1 = id\"", "lemmas m1_inv0_finI = m1_inv0_fin_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv0_finE [elim] = m1_inv0_fin_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv0_finD = m1_inv0_fin_def [THEN setc_def_to_dest, rule_format]", "lemma PO_m1_inv0_fin_init [iff]:\n  \"init m1 \\<subseteq> m1_inv0_fin\"", "lemma PO_m1_inv0_fin_trans [iff]:\n  \"{m1_inv0_fin} trans m1 {> m1_inv0_fin}\"", "lemma PO_m1_inv0_fin [iff]: \"reach m1 \\<subseteq> m1_inv0_fin\"", "lemmas m1_inv1r_cacheI = m1_inv1r_cache_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv1r_cacheE [elim] = m1_inv1r_cache_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv1r_cacheD = m1_inv1r_cache_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1_inv1r_cache_init [iff]:\n  \"init m1 \\<subseteq> m1_inv1r_cache\"", "lemma PO_m1_inv1r_cache_trans [iff]:\n  \"{m1_inv1r_cache} trans m1 {> m1_inv1r_cache}\"", "lemma PO_m1_inv1r_cache [iff]: \"reach m1 \\<subseteq> m1_inv1r_cache\"", "lemma knC_runs1a1 [simp]:\n  \"knC (runs1a1 runz) = knC runz\"", "lemmas R1a1_defs = R1a1_def med1a1_def", "lemma PO_m1_step1_refines_m1a_step1:\n  \"{R1a1} \n     (m1a_step1 Ra A B Na), (m1_step1 Ra A B Na) \n   {> R1a1}\"", "lemma PO_m1_step2_refines_m1a_step2:\n  \"{R1a1} \n     (m1a_step2 Rb A B), (m1_step2 Rb A B) \n   {> R1a1}\"", "lemma PO_m1_step3_refines_m1a_step3:\n  \"{R1a1} \n     (m1a_step3 Rs A B Kab Na [aNum Ts]), (m1_step3 Rs A B Kab Na Ts)\n   {> R1a1}\"", "lemma PO_m1_step4_refines_m1a_step4:\n  \"{R1a1} \n     (m1a_step4 Ra A B Na Kab [aNum Ts]), (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R1a1}\"", "lemma PO_m1_step5_refines_m1a_step5:\n  \"{R1a1} \n     (m1a_step5 Rb A B Kab [aNum Ts]), (m1_step5 Rb A B Kab Ts Ta) \n   {> R1a1}\"", "lemma PO_m1_step6_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step6 Ra A B Na Kab Ts Ta)\n   {> R1a1}\"", "lemma PO_m1_leak_refines_m1a_leak:\n  \"{R1a1} \n     (m1a_leak Rs), (m1_leak Rs A B Na Ts)\n   {> R1a1}\"", "lemma PO_m1_tick_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_tick T) \n   {> R1a1}\"", "lemma PO_m1_purge_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_purge A) \n   {> R1a1}\"", "lemmas PO_m1_trans_refines_m1a_trans = \n  PO_m1_step1_refines_m1a_step1 PO_m1_step2_refines_m1a_step2\n  PO_m1_step3_refines_m1a_step3 PO_m1_step4_refines_m1a_step4\n  PO_m1_step5_refines_m1a_step5 PO_m1_step6_refines_m1a_skip \n  PO_m1_leak_refines_m1a_leak PO_m1_tick_refines_m1a_skip \n  PO_m1_purge_refines_m1a_skip", "lemma PO_m1_refines_init_m1a [iff]:\n  \"init m1 \\<subseteq>  R1a1``(init m1a)\"", "lemma PO_m1_refines_trans_m1a [iff]:\n  \"{R1a1} \n     (trans m1a), (trans m1) \n   {> R1a1}\"", "lemma obs_consistent_med1a1 [iff]: \n  \"obs_consistent R1a1 med1a1 m1a m1\"", "lemma PO_m1_refines_m1a [iff]: \n  \"refines R1a1 med1a1 m1a m1\"", "lemma  m1_implements_m1a [iff]: \"implements med1a1 m1a m1\"", "lemmas m1_secrecyI = m1_secrecy_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_secrecyE [elim] = m1_secrecy_def [THEN setc_def_to_elim, rule_format]", "lemma PO_m1_obs_secrecy [iff]: \"oreach m1 \\<subseteq> m1_secrecy\"", "lemma PO_m1_secrecy [iff]: \"reach m1 \\<subseteq> m1_secrecy\"", "lemmas m1_inv2r_servI = m1_inv2r_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv2r_servE [elim] = m1_inv2r_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv2r_servD = m1_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1_inv2r_serv [iff]: \"reach m1 \\<subseteq> m1_inv2r_serv\"", "lemmas m1_inv2i_servI = m1_inv2i_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv2i_servE [elim] = m1_inv2i_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv2i_servD = m1_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1_inv2i_serv [iff]: \"reach m1 \\<subseteq> m1_inv2i_serv\"", "lemmas m1_inv1_ifreshI = m1_inv1_ifresh_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv1_ifreshE [elim] = m1_inv1_ifresh_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv1_ifreshD = m1_inv1_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1_ifresh [iff]: \"reach m1 \\<subseteq> m1_inv1_ifresh\"", "lemmas R_a0iim1_ri_defs = R_a0iim1_ri_def med_a0iim1_ri_def", "lemma ri_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma finite_ri_running [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ri_running runz A B Kab Ts Ta)\"", "lemma finite_ri_commit [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ri_commit runz A B Kab Ts Ta)\"", "lemma ri_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Na \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) \n      = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ri_runs2sigs runz)(\n       Running [B, A] (Kab, Ts, Ta) := \n         Suc (card (ri_running runz A B Kab Ts Ta)))\"", "lemma ri_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ri_runs2sigs runz)(\n        Commit [B, A] (Kab, Ts, Ta) := \n          Suc (card (ri_commit runz A B Kab Ts Ta)))\"", "lemma ri_runs2sigs_upd_init_some2 [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) =\n     ri_runs2sigs runz\"", "lemma PO_m1_step1_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_step2_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step2 Rb A B) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_step3_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step3 Rs A B Kab Na Ts) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_step4_refines_a0_ri_running:\n  \"{R_a0iim1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [B, A] (Kab, Ts, Ta)), (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_step5_refines_a0_ri_commit:\n  \"{R_a0iim1_ri \\<inter> UNIV \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin)} \n     (a0i_commit [B, A] (Kab, Ts, Ta)), (m1_step5 Rb A B Kab Ts Ta) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_step6_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step6 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_leak_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_leak Rs A B Na Ts) \n   {> R_a0iim1_ri}\"", "lemma PO_m1_tick_refines_a0_ri_skip:\n  \"{R_a0iim1_ri}\n     Id, (m1_tick T)\n   {> R_a0iim1_ri}\"", "lemma PO_m1_purge_refines_a0_ri_skip:\n  \"{R_a0iim1_ri}\n     Id, (m1_purge A)\n   {> R_a0iim1_ri}\"", "lemmas PO_m1_trans_refines_a0_ri_trans = \n  PO_m1_step1_refines_a0_ri_skip  PO_m1_step2_refines_a0_ri_skip\n  PO_m1_step3_refines_a0_ri_skip  PO_m1_step4_refines_a0_ri_running\n  PO_m1_step5_refines_a0_ri_commit PO_m1_step6_refines_a0_ri_skip \n  PO_m1_leak_refines_a0_ri_skip PO_m1_tick_refines_a0_ri_skip \n  PO_m1_purge_refines_a0_ri_skip", "lemma PO_m1_refines_init_a0_ri [iff]:\n  \"init m1 \\<subseteq>  R_a0iim1_ri``(init a0i)\"", "lemma PO_m1_refines_trans_a0_ri [iff]:\n  \"{R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin)} \n     (trans a0i), (trans m1) \n   {> R_a0iim1_ri}\"", "lemma obs_consistent_med_a0iim1_ri [iff]: \n  \"obs_consistent \n     (R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1\"", "lemma PO_m1_refines_a0ii_ri [iff]: \n  \"refines \n     (R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1\"", "lemma  m1_implements_a0ii_ri: \"implements med_a0iim1_ri a0i m1\"", "lemmas m1_inv3r_initI = m1_inv3r_init_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv3r_initE [elim] = m1_inv3r_init_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv3r_initD = m1_inv3r_init_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1_inv3r_init [iff]: \"reach m1 \\<subseteq> m1_inv3r_init\"", "lemmas m1_inv4_rfreshI = m1_inv4_rfresh_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv4_rfreshE [elim] = m1_inv4_rfresh_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv4_rfreshD = m1_inv4_rfresh_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1_inv4_rfresh_step5:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter>\n    m1_secrecy \\<inter> m1_inv1_ifresh} \n     (m1_step5 Rb A B Kab Ts Ta)\n   {> m1_inv4_rfresh}\"", "lemmas PO_m1_inv4_rfresh_step5_lemmas = \n  PO_m1_inv4_rfresh_step5", "lemma PO_m1_inv4_rfresh_init [iff]:\n  \"init m1 \\<subseteq> m1_inv4_rfresh\"", "lemma PO_m1_inv4_rfresh_trans [iff]:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter>\n    m1_secrecy \\<inter> m1_inv1_ifresh} \n      trans m1 \n   {> m1_inv4_rfresh}\"", "lemma PO_m1_inv4_rfresh [iff]: \"reach m1 \\<subseteq> m1_inv4_rfresh\"", "lemma PO_m1_obs_inv4_rfresh [iff]: \"oreach m1 \\<subseteq> m1_inv4_rfresh\"", "lemmas R_a0iim1_ir_defs = R_a0iim1_ir_def med_a0iim1_ir_def", "lemma ir_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma ir_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ir_commit runz A B Kab Ts Ta)\"", "lemma ir_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom (runs y) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runs y(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) \n      = ir_runs2sigs (runs y)\"", "lemma ir_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_resp_some_raw:\n  assumes\n    \"runz Rb = Some (Resp, [A, B], [])\" \n    \"finite (dom runz)\"\n  shows\n    \"ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) s =\n     ((ir_runs2sigs runz)(\n       Running [A, B] (Kab, Ts, Ta) := \n         Suc (card (ir_running runz A B Kab Ts Ta)))) s\"", "lemma ir_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ir_runs2sigs runz)(\n       Running [A, B] (Kab, Ts, Ta) := \n         Suc (card (ir_running runz A B Kab Ts Ta)))\"", "lemma ir_runs2sigs_upd_init_some2_raw:\n  assumes \n    \"runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\" \n    \"finite (dom runz)\" \n  shows\n    \"ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) s =\n     ((ir_runs2sigs runz)(\n        Commit [A, B] (Kab, Ts, Ta) := \n          Suc (card (ir_commit runz A B Kab Ts Ta)))) s\"", "lemma ir_runs2sigs_upd_init_some2 [simp]:\n  \"\\<lbrakk> runz Na = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) =\n     (ir_runs2sigs runz)(\n        Commit [A, B] (Kab, Ts, Ta) := \n          Suc (card (ir_commit runz A B Kab Ts Ta)))\"", "lemma PO_m1_step1_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_step2_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step2 Rb A B) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_step3_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step3 Rs A B Kab Na Ts) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_step4_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_step5_refines_ir_a0ii_running:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [A, B] (Kab, Ts, Ta)), (m1_step5 Rb A B Kab Ts Ta) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_step6_refines_ir_a0ii_commit:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0n_commit [A, B] (Kab, Ts, Ta)), (m1_step6 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ir}\"", "lemma PO_m1_leak_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_leak Rs A B Na Ts)\n   {> R_a0iim1_ir}\"", "lemma PO_m1_tick_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_tick T)\n   {> R_a0iim1_ir}\"", "lemma PO_m1_purge_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_purge A)\n   {> R_a0iim1_ir}\"", "lemmas PO_m1_trans_refines_ir_a0ii_trans = \n  PO_m1_step1_refines_ir_a0ii_skip  PO_m1_step2_refines_ir_a0ii_skip\n  PO_m1_step3_refines_ir_a0ii_skip  PO_m1_step4_refines_ir_a0ii_skip\n  PO_m1_step5_refines_ir_a0ii_running PO_m1_step6_refines_ir_a0ii_commit\n  PO_m1_leak_refines_ir_a0ii_skip PO_m1_tick_refines_ir_a0ii_skip \n  PO_m1_purge_refines_ir_a0ii_skip", "lemma PO_m1_refines_init_ir_a0ii [iff]:\n  \"init m1 \\<subseteq>  R_a0iim1_ir``(init a0n)\"", "lemma PO_m1_refines_trans_ir_a0ii [iff]:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (trans a0n), (trans m1) \n   {> R_a0iim1_ir}\"", "lemma obs_consistent_med_a0iim1_ir [iff]: \n  \"obs_consistent \n     (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin) \n     med_a0iim1_ir a0n m1\"", "lemma PO_m1_refines_a0ii_ir [iff]: \n  \"refines (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin) \n     med_a0iim1_ir a0n m1\"", "lemma  m1_implements_a0ii_ir: \"implements med_a0iim1_ir a0n m1\""], "translations": [["", "lemmas m1_loc_defs = \n  m1_def m1_init_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def m1_step4_def m1_step5_def \n  m1_step6_def m1_leak_def m1_purge_def m1_tick_def"], ["", "lemmas m1_defs = m1_loc_defs m1a_defs"], ["", "lemma m1_obs_id [simp]: \"obs m1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs m1 = id", "by (simp add: m1_def)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>inv0: Finite domain\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>There are only finitely many runs. This is needed to establish\nthe responder/initiator agreement.\\<close>"], ["", "definition \n  m1_inv0_fin :: \"'x m1_pred\"\nwhere\n  \"m1_inv0_fin \\<equiv> {s. finite (dom (runs s))}\""], ["", "lemmas m1_inv0_finI = m1_inv0_fin_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv0_finE [elim] = m1_inv0_fin_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv0_finD = m1_inv0_fin_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Invariance proofs.\\<close>"], ["", "lemma PO_m1_inv0_fin_init [iff]:\n  \"init m1 \\<subseteq> m1_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> m1_inv0_fin", "by (auto simp add: m1_defs intro!: m1_inv0_finI)"], ["", "lemma PO_m1_inv0_fin_trans [iff]:\n  \"{m1_inv0_fin} trans m1 {> m1_inv0_fin}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv0_fin} TS.trans m1 {> m1_inv0_fin}", "by (auto simp add: PO_hoare_defs m1_defs intro!: m1_inv0_finI)"], ["", "lemma PO_m1_inv0_fin [iff]: \"reach m1 \\<subseteq> m1_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv0_fin", "by (rule inv_rule_incr, auto del: subsetI)"], ["", "subsubsection \\<open>inv1: Caching invariant for responder\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition \n  m1_inv1r_cache :: \"'x m1_pred\"\nwhere\n  \"m1_inv1r_cache \\<equiv> {s. \\<forall>Rb A B Kab Ts Ta nl.\n     runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nl) \\<longrightarrow> \n     clk s < Ta + La \\<longrightarrow>\n       (B, Kab, Ta) \\<in> cache s\n  }\""], ["", "lemmas m1_inv1r_cacheI = m1_inv1r_cache_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv1r_cacheE [elim] = m1_inv1r_cache_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv1r_cacheD = m1_inv1r_cache_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof\\<close>"], ["", "lemma PO_m1_inv1r_cache_init [iff]:\n  \"init m1 \\<subseteq> m1_inv1r_cache\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> m1_inv1r_cache", "by (auto simp add: m1_defs intro!: m1_inv1r_cacheI)"], ["", "lemma PO_m1_inv1r_cache_trans [iff]:\n  \"{m1_inv1r_cache} trans m1 {> m1_inv1r_cache}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv1r_cache} TS.trans m1 {> m1_inv1r_cache}", "apply (auto simp add: PO_hoare_defs m1_defs intro!: m1_inv1r_cacheI\n            dest: m1_inv1r_cacheD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb A B Kab Ts Ta nl xa xb.\n       \\<lbrakk>runs xa Rb =\n                Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        clk xa + xb < Ta + La; xa \\<in> m1_inv1r_cache\\<rbrakk>\n       \\<Longrightarrow> (B, Kab, Ta) \\<in> cache xa", "apply (auto dest: m1_inv1r_cacheD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_inv1r_cache [iff]: \"reach m1 \\<subseteq> m1_inv1r_cache\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv1r_cache", "by (rule inv_rule_basic) (auto del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>m1a\\<close>\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The abstraction removes all but the first freshness\nidentifiers (corresponding to \\<open>Kab\\<close> and \\<open>Ts\\<close>) from the \ninitiator and responder frames and leaves the server's freshness ids untouched.\n\\<close>"], ["", "overloading is_len' \\<equiv> \"is_len\" rs_len' \\<equiv> \"rs_len\" begin"], ["", "definition is_len_def [simp]: \"is_len' \\<equiv> 1::nat\""], ["", "definition rs_len_def [simp]: \"rs_len' \\<equiv> 1::nat\""], ["", "end"], ["", "fun \n  rm1a1 :: \"role_t \\<Rightarrow> atom list \\<Rightarrow> atom list\"\nwhere\n  \"rm1a1 Init = take (Suc is_len)\"       \\<comment> \\<open>take \\<open>Kab\\<close>, \\<open>Ts\\<close>; drop \\<open>Ta\\<close>\\<close>\n| \"rm1a1 Resp = take (Suc rs_len)\"       \\<comment> \\<open>take \\<open>Kab\\<close>, \\<open>Ts\\<close>; drop \\<open>Ta\\<close>\\<close>\n| \"rm1a1 Serv = id\"                      \\<comment> \\<open>take \\<open>Na\\<close>, \\<open>Ts\\<close>\\<close>"], ["", "abbreviation \n  runs1a1 :: \"runs_t \\<Rightarrow> runs_t\" where\n  \"runs1a1 \\<equiv> map_runs rm1a1\""], ["", "lemma knC_runs1a1 [simp]:\n  \"knC (runs1a1 runz) = knC runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knC (runs1a1 runz) = knC runz", "apply (auto simp add: map_runs_def elim!: knC.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>Ra A B K al b.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], b);\n        take (Suc (Suc 0)) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, A) \\<in> knC runz\n 2. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc (Suc 0)) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 3. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; runz Rs = None;\n        fst (the None) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC runz\n 4. \\<And>Rs aa b.\n       \\<lbrakk>Rs \\<in> dom runz; runz Rs = Some (Serv, aa, b)\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC runz\n 5. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 6. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 7. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc (Suc 0)) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 2. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 3. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 4. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 2. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 3. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule knC_init, auto simp add: map_runs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 2. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule knC_resp, auto simp add: map_runs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule_tac knC_serv, auto simp add: map_runs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>med1a1: The mediator function maps a concrete observation (i.e., run) \nto an abstract one.\\<close>"], ["", "text \\<open>R1a1: The simulation relation is defined in terms of the mediator\nfunction.\\<close>"], ["", "definition\n  med1a1 :: \"m1_obs \\<Rightarrow> m1a_obs\" where\n  \"med1a1 s \\<equiv> \\<lparr> runs = runs1a1 (runs s), m1x_state.leak = Domain (leak s) \\<rparr>\""], ["", "definition\n  R1a1 :: \"(m1a_state \\<times> m1_state) set\" where\n  \"R1a1 \\<equiv> {(s, t). s = med1a1 t}\""], ["", "lemmas R1a1_defs = R1a1_def med1a1_def"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_m1a_step1:\n  \"{R1a1} \n     (m1a_step1 Ra A B Na), (m1_step1 Ra A B Na) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step1 Ra A B Na, m1_step1 Ra A B Na {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step2_refines_m1a_step2:\n  \"{R1a1} \n     (m1a_step2 Rb A B), (m1_step2 Rb A B) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step2 Rb A B, m1_step2 Rb A B {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step3_refines_m1a_step3:\n  \"{R1a1} \n     (m1a_step3 Rs A B Kab Na [aNum Ts]), (m1_step3 Rs A B Kab Na Ts)\n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step3 Rs A B Kab Na\n            [aNum Ts], m1_step3 Rs A B Kab Na Ts {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step4_refines_m1a_step4:\n  \"{R1a1} \n     (m1a_step4 Ra A B Na Kab [aNum Ts]), (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step4 Ra A B Na Kab\n            [aNum Ts], m1_step4 Ra A B Na Kab Ts Ta {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def)"], ["", "lemma PO_m1_step5_refines_m1a_step5:\n  \"{R1a1} \n     (m1a_step5 Rb A B Kab [aNum Ts]), (m1_step5 Rb A B Kab Ts Ta) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step5 Rb A B Kab\n            [aNum Ts], m1_step5 Rb A B Kab Ts Ta {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def)"], ["", "lemma PO_m1_step6_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step6 Ra A B Na Kab Ts Ta)\n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} Id, m1_step6 Ra A B Na Kab Ts Ta {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def)"], ["", "lemma PO_m1_leak_refines_m1a_leak:\n  \"{R1a1} \n     (m1a_leak Rs), (m1_leak Rs A B Na Ts)\n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_leak Rs, m1_leak Rs A B Na Ts {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def dest: dom_lemmas)"], ["", "lemma PO_m1_tick_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_tick T) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} Id, m1_tick T {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def)"], ["", "lemma PO_m1_purge_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_purge A) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} Id, m1_purge A {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_m1a_trans = \n  PO_m1_step1_refines_m1a_step1 PO_m1_step2_refines_m1a_step2\n  PO_m1_step3_refines_m1a_step3 PO_m1_step4_refines_m1a_step4\n  PO_m1_step5_refines_m1a_step5 PO_m1_step6_refines_m1a_skip \n  PO_m1_leak_refines_m1a_leak PO_m1_tick_refines_m1a_skip \n  PO_m1_purge_refines_m1a_skip"], ["", "lemma PO_m1_refines_init_m1a [iff]:\n  \"init m1 \\<subseteq>  R1a1``(init m1a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R1a1 `` init m1a", "by (auto simp add: R1a1_defs m1_defs intro!: s0g_secrecyI)"], ["", "lemma PO_m1_refines_trans_m1a [iff]:\n  \"{R1a1} \n     (trans m1a), (trans m1) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} TS.trans m1a, TS.trans m1 {> R1a1}", "apply (auto simp add: m1_def m1_trans_def m1a_def m1a_trans_def\n         intro!: PO_m1_trans_refines_m1a_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xe.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step1 xb x xa xe {> R1a1}\n 2. \\<And>x xa xc.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step2 xc x xa {> R1a1}\n 3. \\<And>x xa xd xe xf xg.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step3 xd x xa xf xe xg {> R1a1}", "apply (force intro!: PO_m1_trans_refines_m1a_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med1a1 [iff]: \n  \"obs_consistent R1a1 med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R1a1 med1a1 m1a m1", "by (auto simp add: obs_consistent_def R1a1_def m1a_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_m1a [iff]: \n  \"refines R1a1 med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R1a1 med1a1 m1a m1", "by (rule Refinement_basic) (auto del: subsetI)"], ["", "lemma  m1_implements_m1a [iff]: \"implements med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med1a1 m1a m1", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv (inherited): Secrecy\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>Secrecy, as external and internal invariant\\<close>"], ["", "definition \n  m1_secrecy :: \"'x m1_pred\" where\n  \"m1_secrecy \\<equiv> {s. knC (runs s) \\<subseteq> azC (runs s) \\<union> Domain (leak s) \\<times> UNIV}\""], ["", "lemmas m1_secrecyI = m1_secrecy_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_secrecyE [elim] = m1_secrecy_def [THEN setc_def_to_elim, rule_format]"], ["", "lemma PO_m1_obs_secrecy [iff]: \"oreach m1 \\<subseteq> m1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach m1 \\<subseteq> m1_secrecy", "apply (rule_tac Q=m1x_secrecy in external_invariant_translation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. oreach ?Sa \\<subseteq> m1x_secrecy\n 2. ?pi -` m1x_secrecy \\<subseteq> m1_secrecy\n 3. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1x_secrecy \\<subseteq> m1_secrecy", "apply (fastforce simp add: med1a1_def intro!: m1_secrecyI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_secrecy [iff]: \"reach m1 \\<subseteq> m1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_secrecy", "by (rule external_to_internal_invariant) (auto del: subsetI)"], ["", "subsubsection \\<open>inv (inherited): Responder auth server.\\<close>"], ["", "(*invh*************************************************************************)"], ["", "definition \n  m1_inv2r_serv :: \"'x m1r_pred\"\nwhere\n  \"m1_inv2r_serv \\<equiv> {s. \\<forall>A B Rb Kab Ts nlb.\n     B \\<notin> bad \\<longrightarrow> \n     runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb) \\<longrightarrow>\n       (\\<exists>Rs Na. Kab = sesK (Rs$sk) \\<and> \n          runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]))\n  }\""], ["", "lemmas m1_inv2r_servI = m1_inv2r_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv2r_servE [elim] = m1_inv2r_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv2r_servD = m1_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Proof of invariance.\\<close>"], ["", "lemma PO_m1_inv2r_serv [iff]: \"reach m1 \\<subseteq> m1_inv2r_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv2r_serv", "apply (rule_tac Sa=m1a and Pa=m1a_inv2r_serv \n       and Qa=m1a_inv2r_serv and Q=m1_inv2r_serv \n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach m1a \\<subseteq> m1a_inv2r_serv\n 2. m1a_inv2r_serv \\<subseteq> obs m1a -` m1a_inv2r_serv\n 3. ?pi -` m1a_inv2r_serv \\<subseteq> m1_inv2r_serv\n 4. obs m1 -` m1_inv2r_serv \\<subseteq> m1_inv2r_serv\n 5. implements ?pi m1a m1", "apply (auto del: subsetI)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv2r_serv \\<subseteq> m1_inv2r_serv", "apply (auto simp add: vimage_def intro!: m1_inv2r_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        med1a1 x \\<in> m1a_inv2r_serv\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (simp add: m1a_inv2r_serv_def med1a1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>A B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab nlb.\n               runs1a1 (runs x) Rb =\n               Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs x) Rs =\n                       Some\n                        (Serv, [A, B],\n                         aNon Na # take (Suc 0) nlb))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (rename_tac x A B Rb Kab Ts nlb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>A B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab nlb.\n               runs1a1 (runs x) Rb =\n               Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs x) Rs =\n                       Some\n                        (Serv, [A, B],\n                         aNon Na # take (Suc 0) nlb))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (drule_tac x=A in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab nlb.\n               runs1a1 (runs x) Rb =\n               Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs x) Rs =\n                       Some\n                        (Serv, [A, B],\n                         aNon Na # take (Suc 0) nlb))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (drule_tac x=B in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>Rb Kab nlb.\n           runs1a1 (runs x) Rb =\n           Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               (\\<exists>Na.\n                   runs1a1 (runs x) Rs =\n                   Some\n                    (Serv, [A, B], aNon Na # take (Suc 0) nlb)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (drule_tac x=Rb in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>Kab nlb.\n           runs1a1 (runs x) Rb =\n           Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               (\\<exists>Na.\n                   runs1a1 (runs x) Rs =\n                   Some\n                    (Serv, [A, B], aNon Na # take (Suc 0) nlb)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (drule_tac x=Kab in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        \\<forall>nlb.\n           runs1a1 (runs x) Rb =\n           Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               (\\<exists>Na.\n                   runs1a1 (runs x) Rs =\n                   Some\n                    (Serv, [A, B], aNon Na # take (Suc 0) nlb)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (drule_tac x=\"[aNum Ts]\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # nlb);\n        runs1a1 (runs x) Rb =\n        Some (Resp, [A, B], [aKey Kab, aNum Ts]) \\<longrightarrow>\n        (\\<exists>Rs.\n            Kab = sesK (Rs $ sk) \\<and>\n            (\\<exists>Na.\n                runs1a1 (runs x) Rs =\n                Some\n                 (Serv, [A, B], aNon Na # take (Suc 0) [aNum Ts])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some (Serv, [A, B], [aNon Na, aNum Ts]))", "apply (auto simp add: map_runs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>inv (inherited): Initiator auth server.\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>Simplified version of invariant \\<open>m1a_inv2i_serv\\<close>.\\<close>"], ["", "definition \n  m1_inv2i_serv :: \"'x m1r_pred\"\nwhere\n  \"m1_inv2i_serv \\<equiv> {s. \\<forall>A B Ra Kab Ts nla.\n     A \\<notin> bad \\<longrightarrow> \n     runs s Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla) \\<longrightarrow>\n       (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and>\n         runs s Rs = Some (Serv, [A, B],  [aNon (Ra$na), aNum Ts]))\n  }\""], ["", "lemmas m1_inv2i_servI = m1_inv2i_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv2i_servE [elim] = m1_inv2i_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv2i_servD = m1_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Proof of invariance.\\<close>"], ["", "lemma PO_m1_inv2i_serv [iff]: \"reach m1 \\<subseteq> m1_inv2i_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv2i_serv", "apply (rule_tac Pa=m1a_inv2i_serv and Qa=m1a_inv2i_serv and Q=m1_inv2i_serv\n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach ?Sa \\<subseteq> m1a_inv2i_serv\n 2. m1a_inv2i_serv \\<subseteq> obs ?Sa -` m1a_inv2i_serv\n 3. ?pi -` m1a_inv2i_serv \\<subseteq> m1_inv2i_serv\n 4. obs m1 -` m1_inv2i_serv \\<subseteq> m1_inv2i_serv\n 5. implements ?pi ?Sa m1", "apply (auto del: subsetI)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv2i_serv \\<subseteq> m1_inv2i_serv", "apply (auto simp add: m1a_inv2i_serv_def med1a1_def vimage_def intro!: m1_inv2i_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>A.\n           A \\<notin> bad \\<longrightarrow>\n           (\\<forall>B Ra Kab nla.\n               runs1a1 (runs x) Ra =\n               Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   runs1a1 (runs x) Rs =\n                   Some\n                    (Serv, [A, B],\n                     aNon (Ra $ na) # take (Suc 0) nla)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (rename_tac x A B Ra Kab Ts nla)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>A.\n           A \\<notin> bad \\<longrightarrow>\n           (\\<forall>B Ra Kab nla.\n               runs1a1 (runs x) Ra =\n               Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   runs1a1 (runs x) Rs =\n                   Some\n                    (Serv, [A, B],\n                     aNon (Ra $ na) # take (Suc 0) nla)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (drule_tac x=A in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>B Ra Kab nla.\n           runs1a1 (runs x) Ra =\n           Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs x) Rs =\n               Some\n                (Serv, [A, B], aNon (Ra $ na) # take (Suc 0) nla))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (drule_tac x=B in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>Ra Kab nla.\n           runs1a1 (runs x) Ra =\n           Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs x) Rs =\n               Some\n                (Serv, [A, B], aNon (Ra $ na) # take (Suc 0) nla))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (drule_tac x=Ra in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>Kab nla.\n           runs1a1 (runs x) Ra =\n           Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs x) Rs =\n               Some\n                (Serv, [A, B], aNon (Ra $ na) # take (Suc 0) nla))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (drule_tac x=Kab in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        \\<forall>nla.\n           runs1a1 (runs x) Ra =\n           Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs x) Rs =\n               Some\n                (Serv, [A, B], aNon (Ra $ na) # take (Suc 0) nla))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (drule_tac x=\"[aNum Ts]\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab Ts nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # aNum Ts # nla);\n        runs1a1 (runs x) Ra =\n        Some (Init, [A, B], [aKey Kab, aNum Ts]) \\<longrightarrow>\n        (\\<exists>Rs.\n            Kab = sesK (Rs $ sk) \\<and>\n            runs1a1 (runs x) Rs =\n            Some\n             (Serv, [A, B],\n              aNon (Ra $ na) # take (Suc 0) [aNum Ts]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na), aNum Ts])", "apply (auto simp add: map_runs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare PO_m1_inv2i_serv [THEN subsetD, intro]"], ["", "subsubsection \\<open>inv (inherited): Initiator key freshness\\<close>"], ["", "(*invh*************************************************************************)"], ["", "definition \n  m1_inv1_ifresh :: \"'x m1_pred\"\nwhere\n  \"m1_inv1_ifresh \\<equiv> {s. \\<forall>A A' B B' Ra Ra' Kab nl nl'.\n     runs s Ra  = Some (Init, [A,  B],  aKey Kab # nl) \\<longrightarrow>\n     runs s Ra' = Some (Init, [A', B'], aKey Kab # nl') \\<longrightarrow>\n     A \\<notin> bad \\<longrightarrow> B \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n       Ra = Ra'\n  }\""], ["", "lemmas m1_inv1_ifreshI = m1_inv1_ifresh_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv1_ifreshE [elim] = m1_inv1_ifresh_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv1_ifreshD = m1_inv1_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m1_ifresh [iff]: \"reach m1 \\<subseteq> m1_inv1_ifresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv1_ifresh", "apply (rule_tac Pa=m1a_inv1_ifresh and Qa=m1a_inv1_ifresh and Q=m1_inv1_ifresh\n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach ?Sa \\<subseteq> m1a_inv1_ifresh\n 2. m1a_inv1_ifresh \\<subseteq> obs ?Sa -` m1a_inv1_ifresh\n 3. ?pi -` m1a_inv1_ifresh \\<subseteq> m1_inv1_ifresh\n 4. obs m1 -` m1_inv1_ifresh \\<subseteq> m1_inv1_ifresh\n 5. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv1_ifresh \\<subseteq> m1_inv1_ifresh", "apply (auto simp add: med1a1_def map_runs_def vimage_def m1_inv1_ifresh_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0i\\<close> for responder/initiator\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The responder injectively agrees with the initiator on @{term \"Kab\"},\n@{term \"Ts\"}, and @{term \"Ta\"}.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and responder runs.\\<close>"], ["", "type_synonym\n  risig = \"key \\<times> time \\<times> time\""], ["", "abbreviation\n  ri_running :: \"[runs_t, agent, agent, key, time, time] \\<Rightarrow> rid_t set\" \nwhere\n  \"ri_running runz A B Kab Ts Ta \\<equiv> {Ra. \\<exists>nl. \n     runz Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl)\n  }\""], ["", "abbreviation\n  ri_commit :: \"[runs_t, agent, agent, key, time, time] \\<Rightarrow> rid_t set\" \nwhere\n  \"ri_commit runz A B Kab Ts Ta \\<equiv> {Rb. \\<exists>nl. \n     runz Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nl)\n  }\""], ["", "fun\n  ri_runs2sigs :: \"runs_t \\<Rightarrow> risig signal \\<Rightarrow> nat\"\nwhere\n  \"ri_runs2sigs runz (Running [B, A] (Kab, Ts, Ta)) = \n     card (ri_running runz A B Kab Ts Ta)\"\n\n| \"ri_runs2sigs runz (Commit [B, A] (Kab, Ts, Ta)) = \n     card (ri_commit runz A B Kab Ts Ta)\"\n\n| \"ri_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0iim1_ri :: \"m1_obs \\<Rightarrow> risig a0i_obs\" where\n  \"med_a0iim1_ri o1 \\<equiv> \\<lparr> signals = ri_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0iim1_ri :: \"(risig a0i_state \\<times> m1_state) set\" where\n  \"R_a0iim1_ri \\<equiv> {(s, t). signals s = ri_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0iim1_ri_defs = R_a0iim1_ri_def med_a0iim1_ri_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Other lemmas\\<close>"], ["", "lemma ri_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule ri_runs2sigs.induct, auto)"], ["", "lemma finite_ri_running [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ri_running runz A B Kab Ts Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow>\n    finite (ri_running runz A B Kab Ts Ta)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "lemma finite_ri_commit [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ri_commit runz A B Kab Ts Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow>\n    finite (ri_commit runz A B Kab Ts Ta)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma ri_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Na \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Na \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz", "by (rule ext, erule rev_mp, rule ri_runs2sigs.induct) \n   (auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz", "by (rule ext, erule rev_mp, rule ri_runs2sigs.induct)\n   (auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) \n      = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) =\n    ri_runs2sigs runz", "by (rule ext, erule rev_mp, rule ri_runs2sigs.induct)\n   (auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ri_runs2sigs runz)(\n       Running [B, A] (Kab, Ts, Ta) := \n         Suc (card (ri_running runz A B Kab Ts Ta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Ra = Some (Init, [A, B], []); finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ri_runs2sigs\n                       (runz(Ra \\<mapsto>\n                        (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n                      (ri_runs2sigs runz)\n                      (Running [B, A] (Kab, Ts, Ta) :=\n                         Suc (card (ri_running runz A B Kab Ts Ta)))", "apply (rule ext, (erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       finite (dom runz) \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       ri_runs2sigs\n        (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n        x =\n       ((ri_runs2sigs runz)\n        (Running [B, A] (Kab, Ts, Ta) :=\n           Suc (card (ri_running runz A B Kab Ts Ta))))\n        x", "apply (rule ri_runs2sigs.induct, auto) \n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           (\\<exists>nl.\n                               runz Raa =\n                               Some\n                                (Init, [A, B],\n                                 aKey Kab # aNum Ts # aNum Ta # nl))} =\n                         Suc (card (ri_running runz A B Kab Ts Ta))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           (\\<exists>nl.\n                               runz Raa =\n                               Some\n                                (Init, [A, B],\n                                 aKey Kab # aNum Ts # aNum Ta # nl))} =\n                         Suc (card (ri_running runz A B Kab Ts Ta))", "apply (rule_tac s=\"card (insert Ra (ri_running runz A B Kab Ts Ta))\"\n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ri_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ri_runs2sigs runz)(\n        Commit [B, A] (Kab, Ts, Ta) := \n          Suc (card (ri_commit runz A B Kab Ts Ta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Rb = Some (Resp, [A, B], []); finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ri_runs2sigs\n                       (runz(Rb \\<mapsto>\n                        (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n                      (ri_runs2sigs runz)\n                      (Commit [B, A] (Kab, Ts, Ta) :=\n                         Suc (card (ri_commit runz A B Kab Ts Ta)))", "apply (rule ext, (erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       finite (dom runz) \\<longrightarrow>\n       runz Rb = Some (Resp, [A, B], []) \\<longrightarrow>\n       ri_runs2sigs\n        (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n        x =\n       ((ri_runs2sigs runz)\n        (Commit [B, A] (Kab, Ts, Ta) :=\n           Suc (card (ri_commit runz A B Kab Ts Ta))))\n        x", "apply (rule ri_runs2sigs.induct, auto)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Rba.\n                           Rba \\<noteq> Rb \\<longrightarrow>\n                           (\\<exists>nl.\n                               runz Rba =\n                               Some\n                                (Resp, [A, B],\n                                 aKey Kab # aNum Ts # aNum Ta # nl))} =\n                         Suc (card (ri_commit runz A B Kab Ts Ta))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Rba.\n                           Rba \\<noteq> Rb \\<longrightarrow>\n                           (\\<exists>nl.\n                               runz Rba =\n                               Some\n                                (Resp, [A, B],\n                                 aKey Kab # aNum Ts # aNum Ta # nl))} =\n                         Suc (card (ri_commit runz A B Kab Ts Ta))", "apply (rule_tac s=\"card (insert Rb (ri_commit runz A B Kab Ts Ta))\"\n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ri_runs2sigs_upd_init_some2 [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) =\n     ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra =\n    Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]) \\<Longrightarrow>\n    ri_runs2sigs\n     (runz(Ra \\<mapsto>\n      (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) =\n    ri_runs2sigs runz", "by (rule ext, erule rev_mp, rule ri_runs2sigs.induct)\n   (auto dest: dom_lemmas)"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_step1 Ra A B Na {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "lemma PO_m1_step2_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step2 Rb A B) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_step2 Rb A B {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "lemma PO_m1_step3_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step3 Rs A B Kab Na Ts) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_step3 Rs A B Kab Na Ts {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "lemma PO_m1_step4_refines_a0_ri_running:\n  \"{R_a0iim1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [B, A] (Kab, Ts, Ta)), (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri \\<inter>\n     UNIV \\<times>\n     m1_inv0_fin} a0i_running [B, A]\n                   (Kab, Ts,\n                    Ta), m1_step4 Ra A B Na Kab Ts Ta {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs a0i_defs m1_defs)"], ["", "lemma PO_m1_step5_refines_a0_ri_commit:\n  \"{R_a0iim1_ri \\<inter> UNIV \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin)} \n     (a0i_commit [B, A] (Kab, Ts, Ta)), (m1_step5 Rb A B Kab Ts Ta) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri \\<inter>\n     UNIV \\<times>\n     (m1_inv1r_cache \\<inter>\n      m1_inv0_fin)} a0i_commit [B, A]\n                     (Kab, Ts,\n                      Ta), m1_step5 Rb A B Kab Ts Ta {> R_a0iim1_ri}", "apply (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs a0i_defs m1_defs)\n\\<comment> \\<open>2 subgoals\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y aa ab ac ba Rs Na Ra nl.\n       \\<lbrakk>signals a = ri_runs2sigs (runs y); corrupted a = {};\n        y \\<in> m1_inv1r_cache; y \\<in> m1_inv0_fin;\n        runs y Rb = Some (Resp, [A, B], []); clk y < Ts + Ls;\n        clk y < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache y;\n        (sesK (Rs $ sk), aa, ab, ac, ba) \\<in> m1_state.leak y;\n        Kab = sesK (Rs $ sk);\n        runs y Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs y Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        B \\<notin> bad; A \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> card\n                          (ri_commit (runs y) A B (sesK (Rs $ sk)) Ts Ta)\n                         < card\n                            (ri_running (runs y) A B (sesK (Rs $ sk)) Ts Ta)\n 2. \\<And>a y Rs Na Ra nl.\n       \\<lbrakk>signals a = ri_runs2sigs (runs y); corrupted a = {};\n        y \\<in> m1_inv1r_cache; y \\<in> m1_inv0_fin;\n        runs y Rb = Some (Resp, [A, B], []); clk y < Ts + Ls;\n        clk y < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache y;\n        (sesK (Rs $ sk), B) \\<in> azC (runs y); Kab = sesK (Rs $ sk);\n        runs y Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs y Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        B \\<notin> bad; A \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> card\n                          (ri_commit (runs y) A B (sesK (Rs $ sk)) Ts Ta)\n                         < card\n                            (ri_running (runs y) A B (sesK (Rs $ sk)) Ts Ta)", "apply (rename_tac s t aa ab ac ba Rs Na Ra nl,\n       subgoal_tac \n         \"card (ri_commit (runs t) A B (sesK (Rs$sk)) Ts Ta) = 0 \\<and>\n          card (ri_running (runs t) A B (sesK (Rs$sk)) Ts Ta) > 0\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y Rs Na Ra nl.\n       \\<lbrakk>signals a = ri_runs2sigs (runs y); corrupted a = {};\n        y \\<in> m1_inv1r_cache; y \\<in> m1_inv0_fin;\n        runs y Rb = Some (Resp, [A, B], []); clk y < Ts + Ls;\n        clk y < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache y;\n        (sesK (Rs $ sk), B) \\<in> azC (runs y); Kab = sesK (Rs $ sk);\n        runs y Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs y Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        B \\<notin> bad; A \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> card\n                          (ri_commit (runs y) A B (sesK (Rs $ sk)) Ts Ta)\n                         < card\n                            (ri_running (runs y) A B (sesK (Rs $ sk)) Ts Ta)", "apply (rename_tac s t Rs Na Ra nl,\n       subgoal_tac \n         \"card (ri_commit (runs t) A B (sesK (Rs$sk)) Ts Ta) = 0 \\<and>\n          card (ri_running (runs t) A B (sesK (Rs$sk)) Ts Ta) > 0\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_step6_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_step6 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_step6 Ra A B Na Kab Ts Ta {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "lemma PO_m1_leak_refines_a0_ri_skip:\n  \"{R_a0iim1_ri} \n     Id, (m1_leak Rs A B Na Ts) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_leak Rs A B Na Ts {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs a0i_defs m1_defs)"], ["", "lemma PO_m1_tick_refines_a0_ri_skip:\n  \"{R_a0iim1_ri}\n     Id, (m1_tick T)\n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_tick T {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "lemma PO_m1_purge_refines_a0_ri_skip:\n  \"{R_a0iim1_ri}\n     Id, (m1_purge A)\n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri} Id, m1_purge A {> R_a0iim1_ri}", "by (auto simp add: PO_rhoare_defs R_a0iim1_ri_defs m1_defs)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_a0_ri_trans = \n  PO_m1_step1_refines_a0_ri_skip  PO_m1_step2_refines_a0_ri_skip\n  PO_m1_step3_refines_a0_ri_skip  PO_m1_step4_refines_a0_ri_running\n  PO_m1_step5_refines_a0_ri_commit PO_m1_step6_refines_a0_ri_skip \n  PO_m1_leak_refines_a0_ri_skip PO_m1_tick_refines_a0_ri_skip \n  PO_m1_purge_refines_a0_ri_skip"], ["", "lemma PO_m1_refines_init_a0_ri [iff]:\n  \"init m1 \\<subseteq>  R_a0iim1_ri``(init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R_a0iim1_ri `` init a0i", "by (auto simp add: R_a0iim1_ri_defs a0i_defs m1_defs\n         intro!: exI [where x=\"\\<lparr>signals = \\<lambda>s. 0, corrupted = {} \\<rparr>\"])"], ["", "lemma PO_m1_refines_trans_a0_ri [iff]:\n  \"{R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin)} \n     (trans a0i), (trans m1) \n   {> R_a0iim1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ri \\<inter>\n     a0i_inv1_iagree \\<times>\n     (m1_inv1r_cache \\<inter>\n      m1_inv0_fin)} TS.trans a0i, TS.trans m1 {> R_a0iim1_ri}", "by (force simp add: m1_def m1_trans_def a0i_def a0i_trans_def\n          intro!: PO_m1_trans_refines_a0_ri_trans)"], ["", "lemma obs_consistent_med_a0iim1_ri [iff]: \n  \"obs_consistent \n     (R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent\n     (R_a0iim1_ri \\<inter>\n      a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1", "by (auto simp add: obs_consistent_def R_a0iim1_ri_def med_a0iim1_ri_def \n                   a0i_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_a0ii_ri [iff]: \n  \"refines \n     (R_a0iim1_ri \\<inter> a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R_a0iim1_ri \\<inter>\n      a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n     med_a0iim1_ri a0i m1", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma  m1_implements_a0ii_ri: \"implements med_a0iim1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0iim1_ri a0i m1", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv3 (inherited): Responder and initiator\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>This is a translation of the agreement property to Level 1. It\nfollows from the refinement and is needed to prove inv4 below.\\<close>"], ["", "definition \n  m1_inv3r_init :: \"'x m1_pred\"\nwhere\n  \"m1_inv3r_init \\<equiv> {s. \\<forall>A B Rb Kab Ts Ta nlb.\n     B \\<notin> bad \\<longrightarrow> A \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n     runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb) \\<longrightarrow>\n       (\\<exists>Ra nla. \n        runs s Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nla))\n  }\""], ["", "lemmas m1_inv3r_initI = m1_inv3r_init_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv3r_initE [elim] = m1_inv3r_init_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv3r_initD = m1_inv3r_init_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m1_inv3r_init [iff]: \"reach m1 \\<subseteq> m1_inv3r_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv3r_init", "apply (rule INV_from_Refinement_basic [OF PO_m1_refines_a0ii_ri])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range\n     (R_a0iim1_ri \\<inter>\n      a0i_inv1_iagree \\<times> (m1_inv1r_cache \\<inter> m1_inv0_fin))\n    \\<subseteq> m1_inv3r_init", "apply (auto simp add: R_a0iim1_ri_def a0i_inv1_iagree_def\n            intro!:  m1_inv3r_initI)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak x);\n        runs x Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        x \\<in> m1_inv1r_cache; x \\<in> m1_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a aa b.\n               ri_runs2sigs (runs x) (Commit h (a, aa, b))\n               \\<le> ri_runs2sigs (runs x) (Running h (a, aa, b)));\n        signals a = ri_runs2sigs (runs x); corrupted a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs x Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (rename_tac s A B Rb Kab Ts Ta nlb a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        s \\<in> m1_inv1r_cache; s \\<in> m1_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a aa b.\n               ri_runs2sigs (runs s) (Commit h (a, aa, b))\n               \\<le> ri_runs2sigs (runs s) (Running h (a, aa, b)));\n        signals a = ri_runs2sigs (runs s); corrupted a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (drule_tac x=\"[B, A]\" in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        s \\<in> m1_inv1r_cache; s \\<in> m1_inv0_fin;\n        signals a = ri_runs2sigs (runs s); corrupted a = {};\n        \\<forall>a aa b.\n           card (ri_commit (runs s) A B a aa b)\n           \\<le> card (ri_running (runs s) A B a aa b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (drule_tac x=\"Kab\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        s \\<in> m1_inv1r_cache; s \\<in> m1_inv0_fin;\n        signals a = ri_runs2sigs (runs s); corrupted a = {};\n        \\<forall>a b.\n           card (ri_commit (runs s) A B Kab a b)\n           \\<le> card (ri_running (runs s) A B Kab a b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (drule_tac x=\"Ts\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        s \\<in> m1_inv1r_cache; s \\<in> m1_inv0_fin;\n        signals a = ri_runs2sigs (runs s); corrupted a = {};\n        \\<forall>b.\n           card (ri_commit (runs s) A B Kab Ts b)\n           \\<le> card (ri_running (runs s) A B Kab Ts b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (drule_tac x=\"Ta\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab Ts Ta nlb a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nlb);\n        s \\<in> m1_inv1r_cache; s \\<in> m1_inv0_fin;\n        signals a = ri_runs2sigs (runs s); corrupted a = {};\n        card (ri_commit (runs s) A B Kab Ts Ta)\n        \\<le> card (ri_running (runs s) A B Kab Ts Ta)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B],\n                              aKey Kab # aNum Ts # aNum Ta # nla)", "apply (subgoal_tac \"card (ri_commit (runs s) A B Kab Ts Ta) > 0\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>inv4: Key freshness for responder\\<close>"], ["", "(*inv*************************************************************************)"], ["", "definition \n  m1_inv4_rfresh :: \"'x m1_pred\"\nwhere\n  \"m1_inv4_rfresh \\<equiv> {s. \\<forall>Rb1 Rb2 A1 A2 B1 B2 Kab Ts1 Ts2 Ta1 Ta2.\n     runs s Rb1 = Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1]) \\<longrightarrow> \n     runs s Rb2 = Some (Resp, [A2, B2], [aKey Kab, aNum Ts2, aNum Ta2]) \\<longrightarrow> \n     B1 \\<notin> bad \\<longrightarrow> A1 \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n       Rb1 = Rb2\n  }\""], ["", "lemmas m1_inv4_rfreshI = m1_inv4_rfresh_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv4_rfreshE [elim] = m1_inv4_rfresh_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv4_rfreshD = m1_inv4_rfresh_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Proof of key freshness for responder. All cases except step5 are straightforward.\\<close>"], ["", "lemma PO_m1_inv4_rfresh_step5:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter>\n    m1_secrecy \\<inter> m1_inv1_ifresh} \n     (m1_step5 Rb A B Kab Ts Ta)\n   {> m1_inv4_rfresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter>\n     m1_inv1r_cache \\<inter>\n     m1_secrecy \\<inter>\n     m1_inv1_ifresh} m1_step5 Rb A B Kab Ts Ta {> m1_inv4_rfresh}", "apply (auto simp add: PO_hoare_defs m1_defs intro!: m1_inv4_rfreshI)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa a aa ab b.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, a, aa, ab, b) \\<in> m1_state.leak xa; B \\<in> bad;\n        A \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 Rb2 A1 A2 B1 B2 Kaba Ts1 Ts2 Ta1 Ta2 xa a aa ab b.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kaba \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        Rb1 \\<noteq> Rb2; (Kab, a, aa, ab, b) \\<in> m1_state.leak xa;\n        B \\<in> bad; A \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kaba, aNum Ts1, aNum Ta1]);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some (Resp, [A2, B2], [aKey Kaba, aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa a aa ab b.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, a, aa, ab, b) \\<in> m1_state.leak xa; B \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb1 Rb2 A1 A2 B1 B2 Kaba Ts1 Ts2 Ta1 Ta2 xa a aa ab b.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kaba \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        Rb1 \\<noteq> Rb2; (Kab, a, aa, ab, b) \\<in> m1_state.leak xa;\n        B \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kaba, aNum Ts1, aNum Ta1]);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some (Resp, [A2, B2], [aKey Kaba, aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb1 A1 B1 Ts1 Ta1 xa a aa ab b Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, a, aa, ab, b) \\<in> m1_state.leak xa; B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>Rb1 Rb2 A1 A2 B1 B2 Kaba Ts1 Ts2 Ta1 Ta2 xa a aa ab b Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kaba \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        Rb1 \\<noteq> Rb2; (Kab, a, aa, ab, b) \\<in> m1_state.leak xa;\n        B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kaba, aNum Ts1, aNum Ta1]);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some (Resp, [A2, B2], [aKey Kaba, aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>Rb1 A1 B1 Ts1 Ta1 xa a aa ab b Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), a, aa, ab, b) \\<in> m1_state.leak xa;\n        Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); A \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>Rb1 Rb2 A1 A2 B1 B2 Kaba Ts1 Ts2 Ta1 Ta2 xa a aa ab b Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kaba \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache xa; Rb1 \\<noteq> Rb2;\n        (sesK (Rs $ sk), a, aa, ab, b) \\<in> m1_state.leak xa;\n        Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); A \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kaba, aNum Ts1, aNum Ta1]);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some (Resp, [A2, B2], [aKey Kaba, aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>Rb1 A1 B1 Ts1 Ta1 xa a aa ab b Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), a, aa, ab, b) \\<in> m1_state.leak xa;\n        Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); B \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>Rb1 Rb2 A1 A2 B1 B2 Kaba Ts1 Ts2 Ta1 Ta2 xa a aa ab b Rs Na.\n        \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n         Kaba \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n         xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n         xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n         xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n         clk xa < Ts + Ls; clk xa < Ta + La;\n         (B, sesK (Rs $ sk), Ta) \\<notin> cache xa; Rb1 \\<noteq> Rb2;\n         (sesK (Rs $ sk), a, aa, ab, b) \\<in> m1_state.leak xa;\n         Kab = sesK (Rs $ sk);\n         runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); B \\<in> bad;\n         Rb1 \\<noteq> Rb;\n         runs xa Rb1 =\n         Some (Resp, [A1, B1], [aKey Kaba, aNum Ts1, aNum Ta1]);\n         Rb2 \\<noteq> Rb;\n         runs xa Rb2 =\n         Some (Resp, [A2, B2], [aKey Kaba, aNum Ts2, aNum Ta2])\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 26 subgoals...", "apply (auto dest: m1_inv4_rfreshD)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; A \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); A \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]); B \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest: m1_inv2r_servD) \n\n\\<comment> \\<open>5 subgoals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; A \\<in> bad;\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule m1_inv2r_servD, auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 xa Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); B \\<in> bad; A \\<in> bad;\n        Rb1 \\<noteq> Rb; Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A1, B1], [aNon Na, aNum Ts1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (elim azC.cases, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad; Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule m1_inv2r_servD, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 xa Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); B \\<in> bad;\n        Rb1 \\<noteq> Rb; Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A1, B1], [aNon Na, aNum Ts1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (elim azC.cases, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_inv1_ifresh;\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv1r_cache;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init; runs xa Rb = Some (Resp, [A, B], []);\n        clk xa < Ts + Ls; clk xa < Ta + La; (B, Kab, Ta) \\<notin> cache xa;\n        (Kab, B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey Kab, aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule m1_inv2r_servD, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb1 A1 B1 Ts1 xa Ra nl Rs Na.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); B \\<in> bad;\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb; Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A1, B1], [aNon Na, aNum Ts1])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (elim azC.cases, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 xa Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs xa Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some\n         (Resp, [A2, B2],\n          [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"B2 \\<in> bad\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (thin_tac \"(sesK (Rs$sk), B) \\<in> azC (runs s)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s; Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(sesK (Rs$sk), B2) \\<in> azC (runs s)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s; Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<in> bad; (sesK (Rs $ sk), B2) \\<in> azC (runs s)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s; Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B2) \\<in> azC (runs s)\n 3. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule azC.cases, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s; Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B2) \\<in> azC (runs s)\n 2. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule m1_secrecyE, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"A2 \\<in> bad\", auto dest: m1_inv2r_servD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad; A2 \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule m1_inv3r_initD, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb2 A2 B2 Ts2 Ta2 s Rs Na Ra nl Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak s);\n        s \\<in> m1_inv1_ifresh; s \\<in> m1_secrecy; s \\<in> m1_inv1r_cache;\n        s \\<in> m1_inv2r_serv; s \\<in> m1_inv4_rfresh;\n        s \\<in> m1_inv3r_init; runs s Rb = Some (Resp, [A, B], []);\n        clk s < Ts + Ls; clk s < Ta + La;\n        (B, sesK (Rs $ sk), Ta) \\<notin> cache s;\n        (sesK (Rs $ sk), B) \\<in> azC (runs s); Kab = sesK (Rs $ sk);\n        runs s Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs s Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb2 \\<noteq> Rb;\n        runs s Rb2 =\n        Some (Resp, [A2, B2], [aKey (sesK (Rs $ sk)), aNum Ts2, aNum Ta2]);\n        B2 \\<notin> bad; A2 \\<notin> bad;\n        runs s Raa =\n        Some\n         (Init, [A2, B2],\n          aKey (sesK (Rs $ sk)) # aNum Ts2 # aNum Ta2 # nla)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Raa nla, subgoal_tac \"Raa = Ra\", auto)    \\<comment> \\<open>uses cache invariant\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some\n         (Resp, [A1, B1],\n          [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule m1_inv3r_initD, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb1 A1 B1 Ts1 Ta1 xa Rs Na Ra nl Raa nla.\n       \\<lbrakk>B1 \\<notin> bad; A1 \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_inv1_ifresh; xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv1r_cache; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa Rb = Some (Resp, [A, B], []); clk xa < Ts + Ls;\n        clk xa < Ta + La; (B, sesK (Rs $ sk), Ta) \\<notin> cache xa;\n        (sesK (Rs $ sk), B) \\<in> azC (runs xa); Kab = sesK (Rs $ sk);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na, aNum Ts]);\n        runs xa Ra =\n        Some (Init, [A, B], aKey (sesK (Rs $ sk)) # aNum Ts # aNum Ta # nl);\n        Rb1 \\<noteq> Rb;\n        runs xa Rb1 =\n        Some (Resp, [A1, B1], [aKey (sesK (Rs $ sk)), aNum Ts1, aNum Ta1]);\n        runs xa Raa =\n        Some\n         (Init, [A1, B1],\n          aKey (sesK (Rs $ sk)) # aNum Ts1 # aNum Ta1 # nla)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Raa nla, subgoal_tac \"Raa = Ra\", auto)      \\<comment> \\<open>uses cache invariant\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas PO_m1_inv4_rfresh_step5_lemmas = \n  PO_m1_inv4_rfresh_step5"], ["", "lemma PO_m1_inv4_rfresh_init [iff]:\n  \"init m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> m1_inv4_rfresh", "by (auto simp add: m1_defs intro!: m1_inv4_rfreshI)"], ["", "lemma PO_m1_inv4_rfresh_trans [iff]:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter>\n    m1_secrecy \\<inter> m1_inv1_ifresh} \n      trans m1 \n   {> m1_inv4_rfresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter>\n     m1_inv1r_cache \\<inter>\n     m1_secrecy \\<inter>\n     m1_inv1_ifresh} TS.trans m1 {> m1_inv4_rfresh}", "by (auto simp add: m1_def m1_trans_def intro!: PO_m1_inv4_rfresh_step5_lemmas)\n   (auto simp add: PO_hoare_defs m1_defs intro!: m1_inv4_rfreshI dest: m1_inv4_rfreshD)"], ["", "lemma PO_m1_inv4_rfresh [iff]: \"reach m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv4_rfresh", "apply (rule_tac \n         J=\"m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter> m1_secrecy \\<inter> m1_inv1_ifresh\" \n       in inv_rule_incr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. init m1 \\<subseteq> m1_inv4_rfresh\n 2. {m1_inv4_rfresh \\<inter>\n     (m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv1r_cache \\<inter>\n      m1_secrecy \\<inter>\n      m1_inv1_ifresh)} TS.trans m1 {> m1_inv4_rfresh}\n 3. reach m1\n    \\<subseteq> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter>\n                m1_inv1r_cache \\<inter>\n                m1_secrecy \\<inter>\n                m1_inv1_ifresh", "apply (auto simp add: Int_assoc del: subsetI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_obs_inv4_rfresh [iff]: \"oreach m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach m1 \\<subseteq> m1_inv4_rfresh", "by (rule external_from_internal_invariant)\n   (auto del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0i\\<close> for initiator/responder\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The initiator injectively agrees with the responder on \\<open>Kab\\<close>,\n\\<open>Ts\\<close>, and \\<open>Ta\\<close>.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and responder runs.\\<close>"], ["", "type_synonym\n  irsig = \"key \\<times> time \\<times> time\""], ["", "abbreviation\n  ir_running :: \"[runs_t, agent, agent, key, time, time] \\<Rightarrow> rid_t set\" \nwhere\n  \"ir_running runz A B Kab Ts Ta \\<equiv> {Rb. \\<exists>nl. \n     runz Rb = Some (Resp, [A, B], aKey Kab # aNum Ts # aNum Ta # nl)\n  }\""], ["", "abbreviation\n  ir_commit :: \"[runs_t, agent, agent, key, time, time] \\<Rightarrow> rid_t set\" \nwhere\n  \"ir_commit runz A B Kab Ts Ta \\<equiv> {Ra. \\<exists>nl. \n     runz Ra = Some (Init, [A, B], aKey Kab # aNum Ts # aNum Ta # END # nl)\n  }\""], ["", "fun\n  ir_runs2sigs :: \"runs_t \\<Rightarrow> risig signal \\<Rightarrow> nat\"\nwhere\n \"ir_runs2sigs runz (Running [A, B] (Kab, Ts, Ta)) = \n     card (ir_running runz A B Kab Ts Ta)\"\n\n| \"ir_runs2sigs runz (Commit [A, B] (Kab, Ts, Ta)) = \n     card (ir_commit runz A B Kab Ts Ta)\"\n\n| \"ir_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0iim1_ir :: \"m1_obs \\<Rightarrow> irsig a0i_obs\" where\n  \"med_a0iim1_ir o1 \\<equiv> \\<lparr> signals = ir_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0iim1_ir :: \"(irsig a0i_state \\<times> m1_state) set\" where\n  \"R_a0iim1_ir \\<equiv> {(s, t). signals s = ir_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0iim1_ir_defs = R_a0iim1_ir_def med_a0iim1_ir_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "lemma ir_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto)"], ["", "(* already proven higher up:\nlemma ir_running_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ir_running runz A B Kab Ts Ta)\"\nby (auto intro: finite_subset dest: dom_lemmas) \n*)"], ["", "lemma ir_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (ir_commit runz A B Kab Ts Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow>\n    finite (ir_commit runz A B Kab Ts Ta)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma ir_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom (runs y) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runs y(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) \n      = ir_runs2sigs (runs y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom (runs y) \\<Longrightarrow>\n    ir_runs2sigs (runs y(Rs \\<mapsto> (Serv, [A, B], [aNon Na, aNum Ts]))) =\n    ir_runs2sigs (runs y)", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    ir_runs2sigs\n     (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n    ir_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_resp_some_raw:\n  assumes\n    \"runz Rb = Some (Resp, [A, B], [])\" \n    \"finite (dom runz)\"\n  shows\n    \"ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) s =\n     ((ir_runs2sigs runz)(\n       Running [A, B] (Kab, Ts, Ta) := \n         Suc (card (ir_running runz A B Kab Ts Ta)))) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) s =\n    ((ir_runs2sigs runz)\n     (Running [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_running runz A B Kab Ts Ta))))\n     s", "using assms"], ["proof (prove)\nusing this:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) s =\n    ((ir_runs2sigs runz)\n     (Running [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_running runz A B Kab Ts Ta))))\n     s", "proof (induct rule: ir_runs2sigs.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "case (1 runz A B Kab Ts Ta)"], ["proof (state)\nthis:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "note H = this"], ["proof (state)\nthis:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "hence \"Rb \\<notin> ir_running runz A B Kab Ts Ta\""], ["proof (prove)\nusing this:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n\ngoal (1 subgoal):\n 1. Rb \\<notin> ir_running runz A B Kab Ts Ta", "by auto"], ["proof (state)\nthis:\n  Rb \\<notin> ir_running runz A B Kab Ts Ta\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "moreover"], ["proof (state)\nthis:\n  Rb \\<notin> ir_running runz A B Kab Ts Ta\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "with H"], ["proof (chain)\npicking this:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n  Rb \\<notin> ir_running runz A B Kab Ts Ta", "have\n      \"card (insert Rb (ir_running runz A B Kab Ts Ta)) \n       = Suc (card (ir_running runz A B Kab Ts Ta))\""], ["proof (prove)\nusing this:\n  runz Rb = Some (Resp, [A, B], [])\n  finite (dom runz)\n  Rb \\<notin> ir_running runz A B Kab Ts Ta\n\ngoal (1 subgoal):\n 1. card (insert Rb (ir_running runz A B Kab Ts Ta)) =\n    Suc (card (ir_running runz A B Kab Ts Ta))", "by auto"], ["proof (state)\nthis:\n  card (insert Rb (ir_running runz A B Kab Ts Ta)) =\n  Suc (card (ir_running runz A B Kab Ts Ta))\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "ultimately"], ["proof (chain)\npicking this:\n  Rb \\<notin> ir_running runz A B Kab Ts Ta\n  card (insert Rb (ir_running runz A B Kab Ts Ta)) =\n  Suc (card (ir_running runz A B Kab Ts Ta))", "show ?case"], ["proof (prove)\nusing this:\n  Rb \\<notin> ir_running runz A B Kab Ts Ta\n  card (insert Rb (ir_running runz A B Kab Ts Ta)) =\n  Suc (card (ir_running runz A B Kab Ts Ta))\n\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n     (Running [A, B] (Kab, Ts, Ta)) =\n    ((ir_runs2sigs runz)\n     (Running [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_running runz A B Kab Ts Ta))))\n     (Running [A, B] (Kab, Ts, Ta))", "by (auto elim: subst)"], ["proof (state)\nthis:\n  ir_runs2sigs\n   (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n   (Running [A, B] (Kab, Ts, Ta)) =\n  ((ir_runs2sigs runz)\n   (Running [A, B] (Kab, Ts, Ta) :=\n      Suc (card (ir_running runz A B Kab Ts Ta))))\n   (Running [A, B] (Kab, Ts, Ta))\n\ngoal (7 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [] va)\n 3. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 4. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 5. \\<And>runz va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 6. \\<And>runz vb va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 7. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], []);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Rb \\<mapsto>\n                           (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Running [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_running runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "qed (auto)"], ["", "lemma ir_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n     (ir_runs2sigs runz)(\n       Running [A, B] (Kab, Ts, Ta) := \n         Suc (card (ir_running runz A B Kab Ts Ta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Rb = Some (Resp, [A, B], []); finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ir_runs2sigs\n                       (runz(Rb \\<mapsto>\n                        (Resp, [A, B], [aKey Kab, aNum Ts, aNum Ta]))) =\n                      (ir_runs2sigs runz)\n                      (Running [A, B] (Kab, Ts, Ta) :=\n                         Suc (card (ir_running runz A B Kab Ts Ta)))", "by (intro ext ir_runs2sigs_upd_resp_some_raw)"], ["", "lemma ir_runs2sigs_upd_init_some2_raw:\n  assumes \n    \"runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\" \n    \"finite (dom runz)\" \n  shows\n    \"ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) s =\n     ((ir_runs2sigs runz)(\n        Commit [A, B] (Kab, Ts, Ta) := \n          Suc (card (ir_commit runz A B Kab Ts Ta)))) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END])))\n     s =\n    ((ir_runs2sigs runz)\n     (Commit [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_commit runz A B Kab Ts Ta))))\n     s", "using assms"], ["proof (prove)\nusing this:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END])))\n     s =\n    ((ir_runs2sigs runz)\n     (Commit [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_commit runz A B Kab Ts Ta))))\n     s", "proof (induct runz s rule: ir_runs2sigs.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "case (2 runz A B Kab Ts Ta)"], ["proof (state)\nthis:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "note H = this"], ["proof (state)\nthis:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "from H"], ["proof (chain)\npicking this:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)", "have \"Ra \\<notin> ir_commit runz A B Kab Ts Ta\""], ["proof (prove)\nusing this:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n\ngoal (1 subgoal):\n 1. Ra \\<notin> ir_commit runz A B Kab Ts Ta", "by auto"], ["proof (state)\nthis:\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "moreover"], ["proof (state)\nthis:\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "with H"], ["proof (chain)\npicking this:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta", "have \n      \"card (insert Ra (ir_commit runz A B Kab Ts Ta)) \n       = Suc (card (ir_commit runz A B Kab Ts Ta))\""], ["proof (prove)\nusing this:\n  runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta])\n  finite (dom runz)\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta\n\ngoal (1 subgoal):\n 1. card (insert Ra (ir_commit runz A B Kab Ts Ta)) =\n    Suc (card (ir_commit runz A B Kab Ts Ta))", "by (auto)"], ["proof (state)\nthis:\n  card (insert Ra (ir_commit runz A B Kab Ts Ta)) =\n  Suc (card (ir_commit runz A B Kab Ts Ta))\n\ngoal (8 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [Aa, Ba] (Kaba, Tsa, Taa))\n 3. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 4. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 5. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 6. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 7. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 8. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "ultimately"], ["proof (chain)\npicking this:\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta\n  card (insert Ra (ir_commit runz A B Kab Ts Ta)) =\n  Suc (card (ir_commit runz A B Kab Ts Ta))", "show ?case"], ["proof (prove)\nusing this:\n  Ra \\<notin> ir_commit runz A B Kab Ts Ta\n  card (insert Ra (ir_commit runz A B Kab Ts Ta)) =\n  Suc (card (ir_commit runz A B Kab Ts Ta))\n\ngoal (1 subgoal):\n 1. ir_runs2sigs\n     (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END])))\n     (Commit [A, B] (Kab, Ts, Ta)) =\n    ((ir_runs2sigs runz)\n     (Commit [A, B] (Kab, Ts, Ta) :=\n        Suc (card (ir_commit runz A B Kab Ts Ta))))\n     (Commit [A, B] (Kab, Ts, Ta))", "by (auto elim: subst)"], ["proof (state)\nthis:\n  ir_runs2sigs\n   (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END])))\n   (Commit [A, B] (Kab, Ts, Ta)) =\n  ((ir_runs2sigs runz)\n   (Commit [A, B] (Kab, Ts, Ta) :=\n      Suc (card (ir_commit runz A B Kab Ts Ta))))\n   (Commit [A, B] (Kab, Ts, Ta))\n\ngoal (7 subgoals):\n 1. \\<And>runz Aa Ba Kaba Tsa Taa.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa)) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [Aa, Ba] (Kaba, Tsa, Taa))\n 2. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [] va)\n 3. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running [vb] va)\n 4. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Running (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Running (vb # vd # vf # vg) va)\n 5. \\<And>runz va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [] va)\n 6. \\<And>runz vb va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit [vb] va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit [vb] va)\n 7. \\<And>runz vb vd vf vg va.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n        finite (dom runz)\\<rbrakk>\n       \\<Longrightarrow> ir_runs2sigs\n                          (runz(Ra \\<mapsto>\n                           (Init, [A, B],\n                            [aKey Kab, aNum Ts, aNum Ta, END])))\n                          (Commit (vb # vd # vf # vg) va) =\n                         ((ir_runs2sigs runz)\n                          (Commit [A, B] (Kab, Ts, Ta) :=\n                             Suc (card (ir_commit runz A B Kab Ts Ta))))\n                          (Commit (vb # vd # vf # vg) va)", "qed (auto)"], ["", "lemma ir_runs2sigs_upd_init_some2 [simp]:\n  \"\\<lbrakk> runz Na = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta, END]))) =\n     (ir_runs2sigs runz)(\n        Commit [A, B] (Kab, Ts, Ta) := \n          Suc (card (ir_commit runz A B Kab Ts Ta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Na = Some (Init, [A, B], [aKey Kab, aNum Ts, aNum Ta]);\n     finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ir_runs2sigs\n                       (runz(Na \\<mapsto>\n                        (Init, [A, B],\n                         [aKey Kab, aNum Ts, aNum Ta, END]))) =\n                      (ir_runs2sigs runz)\n                      (Commit [A, B] (Kab, Ts, Ta) :=\n                         Suc (card (ir_commit runz A B Kab Ts Ta)))", "by (intro ir_runs2sigs_upd_init_some2_raw ext)"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_step1 Ra A B Na {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step2_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step2 Rb A B) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_step2 Rb A B {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step3_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step3 Rs A B Kab Na Ts) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_step3 Rs A B Kab Na Ts {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step4_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir} \n     Id, (m1_step4 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_step4 Ra A B Na Kab Ts Ta {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step5_refines_ir_a0ii_running:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [A, B] (Kab, Ts, Ta)), (m1_step5 Rb A B Kab Ts Ta) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir \\<inter>\n     UNIV \\<times>\n     m1_inv0_fin} a0i_running [A, B]\n                   (Kab, Ts, Ta), m1_step5 Rb A B Kab Ts Ta {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step6_refines_ir_a0ii_commit:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0n_commit [A, B] (Kab, Ts, Ta)), (m1_step6 Ra A B Na Kab Ts Ta) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir \\<inter>\n     UNIV \\<times>\n     m1_inv0_fin} a0n_commit [A, B]\n                   (Kab, Ts,\n                    Ta), m1_step6 Ra A B Na Kab Ts Ta {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs a0n_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_leak_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_leak Rs A B Na Ts)\n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_leak Rs A B Na Ts {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs a0n_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_tick_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_tick T)\n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_tick T {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_purge_refines_ir_a0ii_skip:\n  \"{R_a0iim1_ir}\n     Id, (m1_purge A)\n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir} Id, m1_purge A {> R_a0iim1_ir}", "by (simp add: PO_rhoare_defs R_a0iim1_ir_defs m1_defs, safe, auto)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_ir_a0ii_trans = \n  PO_m1_step1_refines_ir_a0ii_skip  PO_m1_step2_refines_ir_a0ii_skip\n  PO_m1_step3_refines_ir_a0ii_skip  PO_m1_step4_refines_ir_a0ii_skip\n  PO_m1_step5_refines_ir_a0ii_running PO_m1_step6_refines_ir_a0ii_commit\n  PO_m1_leak_refines_ir_a0ii_skip PO_m1_tick_refines_ir_a0ii_skip \n  PO_m1_purge_refines_ir_a0ii_skip"], ["", "lemma PO_m1_refines_init_ir_a0ii [iff]:\n  \"init m1 \\<subseteq>  R_a0iim1_ir``(init a0n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R_a0iim1_ir `` init a0n", "by (auto simp add: R_a0iim1_ir_defs a0n_defs m1_defs\n         intro!: exI [where x=\"\\<lparr>signals = \\<lambda>s. 0, corrupted = {}\\<rparr>\"])"], ["", "lemma PO_m1_refines_trans_ir_a0ii [iff]:\n  \"{R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin} \n     (trans a0n), (trans m1) \n   {> R_a0iim1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0iim1_ir \\<inter>\n     UNIV \\<times> m1_inv0_fin} TS.trans a0n, TS.trans m1 {> R_a0iim1_ir}", "by (auto simp add: m1_def m1_trans_def a0n_def a0n_trans_def\n         intro!: PO_m1_trans_refines_ir_a0ii_trans)"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med_a0iim1_ir [iff]: \n  \"obs_consistent \n     (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin) \n     med_a0iim1_ir a0n m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin)\n     med_a0iim1_ir a0n m1", "by (auto simp add: obs_consistent_def R_a0iim1_ir_def med_a0iim1_ir_def \n                   a0n_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_a0ii_ir [iff]: \n  \"refines (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin) \n     med_a0iim1_ir a0n m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0iim1_ir \\<inter> UNIV \\<times> m1_inv0_fin) med_a0iim1_ir\n     a0n m1", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma  m1_implements_a0ii_ir: \"implements med_a0iim1_ir a0n m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0iim1_ir a0n m1", "by (rule refinement_soundness) (fast)"], ["", "end"]]}