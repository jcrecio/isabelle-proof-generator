{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m2_ds.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m2_loc_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_step4_def m2_step5_def \n  m2_tick_def m2_leak_def m2_fake_def", "lemmas m2_defs = m2_loc_defs m1_defs", "lemmas m2_inv3a_sesK_comprI = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv3a_sesK_comprE [elim] = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv3a_sesK_comprD = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_dest, rule_format]", "lemmas insert_commute_aKey = insert_commute [where x=\"aKey K\" for K]", "lemmas m2_inv3a_sesK_compr_simps = \n  m2_inv3a_sesK_comprD\n  m2_inv3a_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  m2_inv3a_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  insert_commute_aKey   \\<comment> \\<open>to get the keys to the front\\<close>", "lemma PO_m2_inv3a_sesK_compr_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3a_sesK_compr\"", "lemma PO_m2_inv3a_sesK_compr_trans [iff]:\n  \"{m2_inv3a_sesK_compr} trans m2 {> m2_inv3a_sesK_compr}\"", "lemma PO_m2_inv3a_sesK_compr [iff]: \"reach m2 \\<subseteq> m2_inv3a_sesK_compr\"", "lemmas m2_inv3_extrKeyI = \n  m2_inv3_extrKey_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv3_extrKeyE [elim] = \n  m2_inv3_extrKey_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv3_extrKeyD = \n  m2_inv3_extrKey_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv3_extrKey_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3_extrKey\"", "lemma PO_m2_inv3_extrKey_trans [iff]:\n  \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} \n      trans m2 \n   {> m2_inv3_extrKey}\"", "lemma PO_m2_inv3_extrKey [iff]: \"reach m2 \\<subseteq> m2_inv3_extrKey\"", "lemmas m2_inv4_M2aI = \n  m2_inv4_M2a_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv4_M2aE [elim] = \n  m2_inv4_M2a_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv4_M2aD = \n  m2_inv4_M2a_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemmas m2_inv4_M2bI = m2_inv4_M2b_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv4_M2bE [elim] = \n  m2_inv4_M2b_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv4_M2bD = \n  m2_inv4_M2b_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv4_M2a_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2a\"", "lemma PO_m2_inv4_M2a_trans [iff]:\n  \"{m2_inv4_M2a} trans m2 {> m2_inv4_M2a}\"", "lemma PO_m2_inv4_M2a [iff]: \"reach m2 \\<subseteq> m2_inv4_M2a\"", "lemma PO_m2_inv4_M2b_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2b\"", "lemma PO_m2_inv4_M2b_trans [iff]:\n  \"{m2_inv4_M2b} trans m2 {> m2_inv4_M2b}\"", "lemma PO_m2_inv4_M2b [iff]: \"reach m2 \\<subseteq> m2_inv4_M2b\"", "lemma m2_inv4_M2a_M2b_match:\n  \"\\<lbrakk> Secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts']) \\<in> chan s; \n     Secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s; \n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a; s \\<in> m2_inv4_M2b \\<rbrakk>\n  \\<Longrightarrow> A = A' \\<and> B = B' \\<and> Ts = Ts'\"", "lemma m2_inv34_M2a_authorized:\n  assumes \"Secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\" \n          \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv4_M2a\" \"K \\<notin> leak s\"  \n  shows   \"(K, A) \\<in> azC (runs s)\"", "lemma m2_inv34_M2b_authorized:\n  assumes \"Secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\" \n          \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv4_M2b\" \"K \\<notin> leak s\"  \n  shows  \"(K, B) \\<in> azC (runs s)\"", "lemmas m2_inv5_ikk_svI = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv5_ikk_svE [elim] = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv5_ikk_svD = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_inv5_ikk_sv_init [iff]:\n  \"init m2 \\<subseteq> m2_inv5_ikk_sv\"", "lemma PO_m2_inv5_ikk_sv_trans [iff]:\n  \"{m2_inv5_ikk_sv \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey} \n     trans m2 \n   {> m2_inv5_ikk_sv}\"", "lemma PO_m2_inv5_ikk_sv [iff]: \"reach m2 \\<subseteq> m2_inv5_ikk_sv\"", "lemmas m2_inv6_ikk_initI = m2_inv6_ikk_init_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv6_ikk_initE [elim] = m2_inv6_ikk_init_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv6_ikk_initD = m2_inv6_ikk_init_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemmas m2_inv7_ikk_respI = m2_inv7_ikk_resp_def [THEN setc_def_to_intro, rule_format]", "lemmas m2_inv7_ikk_respE [elim] = m2_inv7_ikk_resp_def [THEN setc_def_to_elim, rule_format]", "lemmas m2_inv7_ikk_respD = m2_inv7_ikk_resp_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B), (m2_step1 Ra A B) \n   {> R12}\"", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Rb A B), (m2_step2 Rb A B)\n   {> R12}\"", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12} \n     (m1_step3 Rs A B Kab Ts), (m2_step3 Rs A B Kab Ts)\n   {> R12}\"", "lemma PO_m2_step4_refines_m1_step4:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2a \\<inter> m2_inv3_extrKey)} \n     (m1_step4 Ra A B Kab Ts), (m2_step4 Ra A B Kab Ts)  \n   {> R12}\"", "lemma PO_m2_step5_refines_m1_step5:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv3_extrKey)}          \\<comment> \\<open>REMOVED!: \\<open>m2_inv5_ikk_sv\\<close>\\<close>\n     (m1_step5 Rb A B Kab Ts), (m2_step5 Rb A B Kab Ts) \n   {> R12}\"", "lemma PO_m2_tick_refines_m1_tick:\n  \"{R12}\n    (m1_tick T), (m2_tick T)\n   {> R12}\"", "lemma PO_m2_leak_refines_m1_leak:\n  \"{R12} \n     (m1_leak Rs), (m2_leak Rs)\n   {> R12}\"", "lemma PO_m2_fake_refines_skip:\n  \"{R12} \n     Id, m2_fake\n   {> R12}\"", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_step4_refines_m1_step4\n  PO_m2_step5_refines_m1_step5 PO_m2_tick_refines_m1_tick \n  PO_m2_leak_refines_m1_leak PO_m2_fake_refines_skip", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\"", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> \n    UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter> m2_inv3_extrKey)} \n     (trans m1), (trans m2) \n   {> R12}\"", "lemma PO_obs_consistent_R12 [iff]: \n  \"obs_consistent R12 med21 m1 m2\"", "lemma m2_refines_m1 [iff]:\n  \"refines \n     (R12 \\<inter> \n      (UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter> m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr)))\n     med21 m1 m2\"", "lemma m2_implements_m1 [iff]:\n  \"implements med21 m1 m2\""], "translations": [["", "lemmas m2_loc_defs = \n  m2_def m2_init_def m2_trans_def m2_obs_def\n  m2_step1_def m2_step2_def m2_step3_def m2_step4_def m2_step5_def \n  m2_tick_def m2_leak_def m2_fake_def"], ["", "lemmas m2_defs = m2_loc_defs m1_defs"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants and simulation relation\\<close>"], ["", "(******************************************************************************)\n\n(*\nsubsubsection {* inv1: Key definedness [UNUSED] *}\n(******************************************************************************)\n\ntext {* All session keys in channel messages stem from existing runs. *}\n\ndefinition \n  m2_inv1_keys :: \"m2_state set\"\nwhere \n  \"m2_inv1_keys \\<equiv> {s. \\<forall>R.\n     aKey (sesK (R$sk)) \\<in> atoms (chan s) (* \\<or> sesK (R$sk) \\<in> leak s *) \\<longrightarrow> \n       R \\<in> dom (runs s)\n  }\"\n\nlemmas m2_inv1_keysI = \n  m2_inv1_keys_def [THEN setc_def_to_intro, rule_format]\nlemmas m2_inv1_keysE [elim] = \n  m2_inv1_keys_def [THEN setc_def_to_elim, rule_format]\nlemmas m2_inv1_keysD = \n  m2_inv1_keys_def [THEN setc_def_to_dest, rule_format]\n\n\ntext {* Invariance proof. *}\n\nlemma PO_m2_inv1_keys_init [iff]:\n  \"init m2 \\<subseteq> m2_inv1_keys\"\nby (auto simp add: m2_defs intro!: m2_inv1_keysI)\n\nlemma PO_m2_inv1_keys_trans [iff]:\n  \"{m2_inv1_keys} trans m2 {> m2_inv1_keys}\"\nby (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv1_keysI)\n   (auto simp add: ik0_def dest: m2_inv1_keysD dom_lemmas)\n\nlemma PO_m2_inv1_keys [iff]: \"reach m2 \\<subseteq> m2_inv1_keys\"\nby (rule inv_rule_basic) (auto)\n\n\nsubsubsection {* inv2: Definedness of used keys [UNUSED] *}\n(******************************************************************************)\n\ndefinition \n  m2_inv2_keys_for :: \"m2_state set\"\nwhere \n  \"m2_inv2_keys_for \\<equiv> {s. \\<forall>R.\n     sesK (R$sk) \\<in> keys_for (chan s) \\<longrightarrow> R \\<in> dom (runs s)\n  }\"\n\nlemmas m2_inv2_keys_forI = \n  m2_inv2_keys_for_def [THEN setc_def_to_intro, rule_format]\nlemmas m2_inv2_keys_forE [elim] = \n  m2_inv2_keys_for_def [THEN setc_def_to_elim, rule_format]\nlemmas m2_inv2_keys_forD = \n  m2_inv2_keys_for_def [THEN setc_def_to_dest, rule_format, rotated 1]\n\n\ntext {* Invariance proof. *}\n\nlemma PO_m2_inv2_keys_for_init [iff]:\n  \"init m2 \\<subseteq> m2_inv2_keys_for\"\nby (auto simp add: m2_defs intro!: m2_inv2_keys_forI)\n\nlemma PO_m2_inv2_keys_for_trans [iff]:\n  \"{m2_inv2_keys_for \\<inter> m2_inv1_keys} trans m2 {> m2_inv2_keys_for}\"\napply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv2_keys_forI) \n-- {* 1 subgoal, from fake *}\napply (auto simp add: keys_for_def ik0_def, erule fake.cases, fastforce+)\ndone\n\nlemma PO_m2_inv2_keys_for [iff]: \"reach m2 \\<subseteq> m2_inv2_keys_for\"\nby (rule inv_rule_incr) (auto del: subsetI)\n\n\ntext {* Useful application of invariant. *}\n\nlemma m2_inv2_keys_for__extr_insert_key:                   (* OBSOLETE?! *)\n  \"\\<lbrakk> R \\<notin> dom (runs s); s \\<in> m2_inv2_keys_for \\<rbrakk>\n \\<Longrightarrow> extr (insert (aKey (sesK (R$sk))) T) (chan s) \n     = insert (aKey (sesK (R$sk))) (extr T (chan s))\"\nby (subgoal_tac \"sesK (R$sk) \\<notin> keys_for (chan s)\") \n   (auto)\n*)"], ["", "subsubsection \\<open>inv3a: Session key compromise\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>A L2 version of a session key comprise invariant. Roughly, it states\nthat adding a set of keys @{term KK} to the parameter \\<open>T\\<close> of @{term extr} \ndoes not help the intruder to extract keys other than those in @{term KK} or\nextractable without adding @{term KK}.\n\\<close>"], ["", "definition \n  m2_inv3a_sesK_compr :: \"m2_state set\"\nwhere \n  \"m2_inv3a_sesK_compr \\<equiv> {s. \\<forall>K KK.\n     aKey K \\<in> extr (aKey`KK \\<union> ik0) (chan s) \\<longleftrightarrow> (K \\<in> KK \\<or> aKey K \\<in> extr ik0 (chan s)) \n  }\""], ["", "lemmas m2_inv3a_sesK_comprI = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv3a_sesK_comprE [elim] = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv3a_sesK_comprD = \n  m2_inv3a_sesK_compr_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Additional lemma\\<close>"], ["", "lemmas insert_commute_aKey = insert_commute [where x=\"aKey K\" for K]"], ["", "lemmas m2_inv3a_sesK_compr_simps = \n  m2_inv3a_sesK_comprD\n  m2_inv3a_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  m2_inv3a_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  insert_commute_aKey   \\<comment> \\<open>to get the keys to the front\\<close>"], ["", "lemma PO_m2_inv3a_sesK_compr_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3a_sesK_compr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv3a_sesK_compr", "by (auto simp add: m2_defs intro!: m2_inv3a_sesK_comprI)"], ["", "lemma PO_m2_inv3a_sesK_compr_trans [iff]:\n  \"{m2_inv3a_sesK_compr} trans m2 {> m2_inv3a_sesK_compr}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3a_sesK_compr} TS.trans m2 {> m2_inv3a_sesK_compr}", "by (auto simp add: PO_hoare_defs m2_defs m2_inv3a_sesK_compr_simps intro!: m2_inv3a_sesK_comprI)"], ["", "lemma PO_m2_inv3a_sesK_compr [iff]: \"reach m2 \\<subseteq> m2_inv3a_sesK_compr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3a_sesK_compr", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3: Extracted session keys\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>inv3: Extracted non-leaked session keys were generated by the server \nfor at least one bad agent. This invariant is needed in the proof of the \nstrengthening of the authorization guards in steps 4 and 5 \n(e.g., @{term \"(Kab, A) \\<in> azC (runs s)\"} for the initiator's step4).\\<close>"], ["", "definition \n  m2_inv3_extrKey :: \"m2_state set\"\nwhere\n  \"m2_inv3_extrKey \\<equiv> {s. \\<forall>K.\n     aKey K \\<in> extr ik0 (chan s) \\<longrightarrow>  K \\<notin> leak s \\<longrightarrow> \\<comment> \\<open>was: \\<open>K \\<notin> corrKey \\<longrightarrow>\\<close>\\<close>\n       (\\<exists>R A' B' Ts'. K = sesK (R$sk) \\<and>\n          runs s R = Some (Serv, [A', B'], [aNum Ts']) \\<and> \n                    (A' \\<in> bad \\<or> B' \\<in> bad))\n  }\""], ["", "lemmas m2_inv3_extrKeyI = \n  m2_inv3_extrKey_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv3_extrKeyE [elim] = \n  m2_inv3_extrKey_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv3_extrKeyD = \n  m2_inv3_extrKey_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m2_inv3_extrKey_init [iff]:\n  \"init m2 \\<subseteq> m2_inv3_extrKey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv3_extrKey", "by (auto simp add: m2_defs ik0_def intro!: m2_inv3_extrKeyI)"], ["", "lemma PO_m2_inv3_extrKey_trans [iff]:\n  \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} \n      trans m2 \n   {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} TS.trans m2 {> m2_inv3_extrKey}", "proof (simp add: m2_def m2_trans_def, safe)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step3 xd x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step4 xb x xa xe xf {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 6. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 7. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 8. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "fix Rs A B Kab Ts"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step3 xd x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step4 xb x xa xe xf {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 6. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 7. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 8. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "show\n    \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} m2_step3 Rs A B Kab Ts {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_step3 Rs A B Kab Ts {> m2_inv3_extrKey}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>K xa.\n       \\<lbrakk>K \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; Rs \\<notin> dom (runs xa);\n        Kab = sesK (Rs $ sk); Ts = clk xa; Insec A B (Msg []) \\<in> chan xa;\n        A \\<in> bad; B \\<in> bad;\n        aKey K\n        \\<in> extr\n               (insert (aKey (sesK (Rs $ sk)))\n                 (insert (aNum (clk xa))\n                   (insert (aKey (sesK (Rs $ sk)))\n                     (insert (aAgt A) (insert (aNum (clk xa)) ik0)))))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = Rs \\<longrightarrow>\n                             K = sesK (Rs $ sk)) \\<and>\n                            (R \\<noteq> Rs \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))\n 2. \\<And>K xa.\n       \\<lbrakk>K \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; Rs \\<notin> dom (runs xa);\n        Kab = sesK (Rs $ sk); Ts = clk xa; Insec A B (Msg []) \\<in> chan xa;\n        A \\<in> bad; B \\<notin> bad;\n        aKey K\n        \\<in> extr\n               (insert (aKey (sesK (Rs $ sk))) (insert (aNum (clk xa)) ik0))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = Rs \\<longrightarrow>\n                             K = sesK (Rs $ sk)) \\<and>\n                            (R \\<noteq> Rs \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))\n 3. \\<And>K xa.\n       \\<lbrakk>K \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; Rs \\<notin> dom (runs xa);\n        Kab = sesK (Rs $ sk); Ts = clk xa; Insec A B (Msg []) \\<in> chan xa;\n        A \\<notin> bad; B \\<in> bad;\n        aKey K\n        \\<in> extr\n               (insert (aKey (sesK (Rs $ sk)))\n                 (insert (aAgt A) (insert (aNum (clk xa)) ik0)))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            (R = Rs \\<longrightarrow>\n                             K = sesK (Rs $ sk)) \\<and>\n                            (R \\<noteq> Rs \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))\n 4. \\<And>K xa.\n       \\<lbrakk>K \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; Rs \\<notin> dom (runs xa);\n        Kab = sesK (Rs $ sk); Ts = clk xa; Insec A B (Msg []) \\<in> chan xa;\n        A \\<notin> bad; B \\<notin> bad;\n        aKey K \\<in> extr ik0 (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> Rs \\<and>\n                            (R \\<noteq> Rs \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))", "apply (auto simp add: m2_inv3a_sesK_compr_simps \n              dest!: m2_inv3_extrKeyD dest: dom_lemmas)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {m2_inv3_extrKey \\<inter>\n   m2_inv3a_sesK_compr} m2_step3 Rs A B Kab Ts {> m2_inv3_extrKey}\n\ngoal (7 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step4 xb x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 6. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 7. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step4 xb x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 6. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 7. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "fix Ra A B Kab Ts"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step4 xb x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 6. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 7. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "show \n    \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} m2_step4 Ra A B Kab Ts {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_step4 Ra A B Kab Ts {> m2_inv3_extrKey}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K xa.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> leak xa;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa Ra = Some (Init, [A, B], []);\n        StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> Ra \\<and>\n                            (R \\<noteq> Ra \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))", "apply (auto simp add: dest!: m2_inv3_extrKeyD dest: dom_lemmas)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa R A' B' Ts'.\n       \\<lbrakk>sesK (R $ sk) \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; runs xa Ra = Some (Init, [A, B], []);\n        StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls; runs xa R = Some (Serv, [A', B'], [aNum Ts']);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Ra \\<and>\n                            (Rb \\<noteq> Ra \\<longrightarrow>\n                             R = Rb \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa Rb =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))\n 2. \\<And>xa R A' B' Ts'.\n       \\<lbrakk>sesK (R $ sk) \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; runs xa Ra = Some (Init, [A, B], []);\n        StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls; runs xa R = Some (Serv, [A', B'], [aNum Ts']);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> Ra \\<and>\n                            (Rb \\<noteq> Ra \\<longrightarrow>\n                             R = Rb \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa Rb =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))", "apply (auto intro!: exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {m2_inv3_extrKey \\<inter>\n   m2_inv3a_sesK_compr} m2_step4 Ra A B Kab Ts {> m2_inv3_extrKey}\n\ngoal (6 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 6. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 6. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "fix Rb A B Kab Ts"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe xf.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step5 xc x xa xe xf {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 5. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 6. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "show \n    \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} m2_step5 Rb A B Kab Ts {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_step5 Rb A B Kab Ts {> m2_inv3_extrKey}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K xa.\n       \\<lbrakk>aKey K \\<in> extr ik0 (chan xa); K \\<notin> leak xa;\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        runs xa Rb = Some (Resp, [A, B], []);\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            R \\<noteq> Rb \\<and>\n                            (R \\<noteq> Rb \\<longrightarrow>\n                             K = sesK (R $ sk) \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa R =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))", "apply (auto dest!: m2_inv3_extrKeyD dest: dom_lemmas)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa R A' B' Ts'.\n       \\<lbrakk>sesK (R $ sk) \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; runs xa Rb = Some (Resp, [A, B], []);\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls; runs xa R = Some (Serv, [A', B'], [aNum Ts']);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             R = Ra \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa Ra =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))\n 2. \\<And>xa R A' B' Ts'.\n       \\<lbrakk>sesK (R $ sk) \\<notin> leak xa; xa \\<in> m2_inv3_extrKey;\n        xa \\<in> m2_inv3a_sesK_compr; runs xa Rb = Some (Resp, [A, B], []);\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan xa;\n        clk xa < Ts + Ls; runs xa R = Some (Serv, [A', B'], [aNum Ts']);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> Rb \\<and>\n                            (Ra \\<noteq> Rb \\<longrightarrow>\n                             R = Ra \\<and>\n                             (\\<exists>A' B'.\n                                 (\\<exists>Ts'.\n                                     runs xa Ra =\n                                     Some\n(Serv, [A', B'], [aNum Ts'])) \\<and>\n                                 (A' \\<in> bad \\<or> B' \\<in> bad)))", "apply (auto intro!: exI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {m2_inv3_extrKey \\<inter>\n   m2_inv3a_sesK_compr} m2_step5 Rb A B Kab Ts {> m2_inv3_extrKey}\n\ngoal (5 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 5. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 5. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "fix Rs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 4. \\<And>x xa xb xc xd.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_leak xd {> m2_inv3_extrKey}\n 5. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "show\n    \"{m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr} m2_leak Rs {> m2_inv3_extrKey}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_leak Rs {> m2_inv3_extrKey}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K xa.\n       \\<lbrakk>aKey K\n                \\<in> extr (insert (aKey (sesK (Rs $ sk))) ik0) (chan xa);\n        xa \\<in> m2_inv3_extrKey; xa \\<in> m2_inv3a_sesK_compr;\n        Rs \\<in> dom (runs xa); fst (the (runs xa Rs)) = Serv;\n        K \\<noteq> sesK (Rs $ sk); K \\<notin> leak xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            K = sesK (R $ sk) \\<and>\n                            (\\<exists>A' B'.\n                                (\\<exists>Ts'.\n                                    runs xa R =\n                                    Some\n                                     (Serv, [A', B'], [aNum Ts'])) \\<and>\n                                (A' \\<in> bad \\<or> B' \\<in> bad))", "apply (auto simp add: m2_inv3a_sesK_compr_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {m2_inv3_extrKey \\<inter>\n   m2_inv3a_sesK_compr} m2_leak Rs {> m2_inv3_extrKey}\n\ngoal (4 subgoals):\n 1. \\<And>x xa xb.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step1 xb x xa {> m2_inv3_extrKey}\n 2. \\<And>x xa xb xc.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_step2 xc x xa {> m2_inv3_extrKey}\n 3. \\<And>x xa xb xc xd xe.\n       {m2_inv3_extrKey \\<inter>\n        m2_inv3a_sesK_compr} m2_tick xe {> m2_inv3_extrKey}\n 4. {m2_inv3_extrKey \\<inter>\n     m2_inv3a_sesK_compr} m2_fake {> m2_inv3_extrKey}", "qed (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv3_extrKeyI,\n     auto dest!: m2_inv3_extrKeyD dest: dom_lemmas)"], ["", "lemma PO_m2_inv3_extrKey [iff]: \"reach m2 \\<subseteq> m2_inv3_extrKey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv3_extrKey", "by (rule_tac J=\"m2_inv3a_sesK_compr\" in inv_rule_incr) (auto)"], ["", "subsubsection \\<open>inv4: Messages M2a/M2b for good agents and server state\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>inv4: Secure messages to honest agents and server state; one variant \nfor each of M2a and M2b. These invariants establish guard strengthening for\nserver authentication by the initiator and the responder.\\<close>"], ["", "definition \n  m2_inv4_M2a :: \"m2_state set\"\nwhere\n  \"m2_inv4_M2a \\<equiv> {s. \\<forall>A B Kab Ts.\n     Secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts]) \\<in> chan s \\<longrightarrow> A \\<in> good \\<longrightarrow>\n       (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and>\n          runs s Rs = Some (Serv, [A, B], [aNum Ts]))\n  }\""], ["", "definition \n  m2_inv4_M2b :: \"m2_state set\"\nwhere\n  \"m2_inv4_M2b \\<equiv> {s. \\<forall>A B Kab Ts.\n     Secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s \\<longrightarrow> B \\<in> good \\<longrightarrow>\n        (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and>\n           runs s Rs = Some (Serv, [A, B], [aNum Ts]))\n  }\""], ["", "lemmas m2_inv4_M2aI = \n  m2_inv4_M2a_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv4_M2aE [elim] = \n  m2_inv4_M2a_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv4_M2aD = \n  m2_inv4_M2a_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemmas m2_inv4_M2bI = m2_inv4_M2b_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv4_M2bE [elim] = \n  m2_inv4_M2b_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv4_M2bD = \n  m2_inv4_M2b_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proofs.\\<close>"], ["", "lemma PO_m2_inv4_M2a_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv4_M2a", "by (auto simp add: m2_defs intro!: m2_inv4_M2aI)"], ["", "lemma PO_m2_inv4_M2a_trans [iff]:\n  \"{m2_inv4_M2a} trans m2 {> m2_inv4_M2a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv4_M2a} TS.trans m2 {> m2_inv4_M2a}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv4_M2aI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>A B Kab Ts xa xd.\n       \\<lbrakk>StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 2. \\<And>A B Kab Ts xa xe.\n       \\<lbrakk>StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 3. \\<And>A B Kab Ts xa xb xc xf.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        xf \\<notin> dom (runs xa); Insec xb xc (Msg []) \\<in> chan xa;\n        StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            (Rs = xf \\<longrightarrow>\n                             Kab = sesK (xf $ sk) \\<and>\n                             xb = A \\<and> xc = B \\<and> clk xa = Ts) \\<and>\n                            (Rs \\<noteq> xf \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 4. \\<And>A B Kab Ts xa xb xc xd xg xh.\n       \\<lbrakk>StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aAgt xc, aKey xg, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 5. \\<And>A B Kab Ts xa xb xc xe xg xh.\n       \\<lbrakk>StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n                \\<in> chan xa;\n        A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xg, aAgt xb, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 6. \\<And>A B Kab Ts xa.\n       \\<lbrakk>StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum Ts])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        A \\<notin> bad; xa \\<in> m2_inv4_M2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs xa Rs = Some (Serv, [A, B], [aNum Ts])", "apply (auto dest!: m2_inv4_M2aD dest: dom_lemmas)\n\\<comment> \\<open>3 subgoals\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A B Ts xa xb xc xd xh Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        runs xa xd = Some (Init, [xb, xc], []); clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts]);\n        \\<forall>Rsa.\n           Rsa = xd \\<or>\n           Rsa \\<noteq> xd \\<and>\n           (Rs = Rsa \\<longrightarrow>\n            runs xa Rsa \\<noteq> Some (Serv, [A, B], [aNum Ts]));\n        xb \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A B Ts xa xb xc xd xh Rs Rsa.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        runs xa xd = Some (Init, [xb, xc], []); clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts]);\n        runs xa Rsa = Some (Serv, [xb, xc], [aNum xh])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNum Ts]))\n 3. \\<And>A B Ts xa xb xc xe xg xh Rs.\n       \\<lbrakk>A \\<notin> bad; xa \\<in> m2_inv4_M2a;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xg, aAgt xb, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNum Ts]))", "apply (force dest!: spec)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv4_M2a [iff]: \"reach m2 \\<subseteq> m2_inv4_M2a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv4_M2a", "by (rule inv_rule_basic) (auto)"], ["", "lemma PO_m2_inv4_M2b_init [iff]:\n  \"init m2 \\<subseteq> m2_inv4_M2b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv4_M2b", "by (auto simp add: m2_defs intro!: m2_inv4_M2bI)"], ["", "lemma PO_m2_inv4_M2b_trans [iff]:\n  \"{m2_inv4_M2b} trans m2 {> m2_inv4_M2b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv4_M2b} TS.trans m2 {> m2_inv4_M2b}", "apply (auto simp add: PO_hoare_defs m2_defs intro!: m2_inv4_M2bI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>A B Kab Ts xa xd.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n                \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        xd \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 2. \\<And>A B Kab Ts xa xe.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n                \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        xe \\<notin> dom (runs xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 3. \\<And>A B Kab Ts xa xb xc xf.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        xf \\<notin> dom (runs xa); Insec xb xc (Msg []) \\<in> chan xa;\n        StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            (Rs = xf \\<longrightarrow>\n                             Kab = sesK (xf $ sk) \\<and>\n                             xb = A \\<and> xc = B \\<and> clk xa = Ts) \\<and>\n                            (Rs \\<noteq> xf \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 4. \\<And>A B Kab Ts xa xb xc xd xg xh.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n                \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aAgt xc, aKey xg, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xd \\<and>\n                            (Rs \\<noteq> xd \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 5. \\<And>A B Kab Ts xa xb xc xe xg xh.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n                \\<in> chan xa;\n        B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        runs xa xe = Some (Resp, [xb, xc], []);\n        StatCh secure Sv xc (Msg [aKey xg, aAgt xb, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Rs \\<noteq> xe \\<and>\n                            (Rs \\<noteq> xe \\<longrightarrow>\n                             Kab = sesK (Rs $ sk) \\<and>\n                             runs xa Rs = Some (Serv, [A, B], [aNum Ts]))\n 6. \\<And>A B Kab Ts xa.\n       \\<lbrakk>StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts])\n                \\<in> fake ik0 (dom (runs xa)) (chan xa);\n        B \\<notin> bad; xa \\<in> m2_inv4_M2b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs xa Rs = Some (Serv, [A, B], [aNum Ts])", "apply (auto dest!: m2_inv4_M2bD dest: dom_lemmas)\n\\<comment> \\<open>3 subgoals\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A B Ts xa xb xc xd xg xh Rs.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        runs xa xd = Some (Init, [xb, xc], []);\n        StatCh secure Sv xb (Msg [aAgt xc, aKey xg, aNum xh]) \\<in> chan xa;\n        clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xd \\<and>\n                            (Rsa \\<noteq> xd \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNum Ts]))\n 2. \\<And>A B Ts xa xb xc xe xh Rs.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        runs xa xe = Some (Resp, [xb, xc], []); clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts]);\n        \\<forall>Rsa.\n           Rsa = xe \\<or>\n           Rsa \\<noteq> xe \\<and>\n           (Rs = Rsa \\<longrightarrow>\n            runs xa Rsa \\<noteq> Some (Serv, [A, B], [aNum Ts]));\n        xc \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>A B Ts xa xb xc xe xh Rs Rsa.\n       \\<lbrakk>B \\<notin> bad; xa \\<in> m2_inv4_M2b;\n        runs xa xe = Some (Resp, [xb, xc], []); clk xa < xh + Ls;\n        runs xa Rs = Some (Serv, [A, B], [aNum Ts]);\n        runs xa Rsa = Some (Serv, [xb, xc], [aNum xh])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rsa.\n                            Rsa \\<noteq> xe \\<and>\n                            (Rsa \\<noteq> xe \\<longrightarrow>\n                             Rs = Rsa \\<and>\n                             runs xa Rsa = Some (Serv, [A, B], [aNum Ts]))", "apply (force dest!: spec)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m2_inv4_M2b [iff]: \"reach m2 \\<subseteq> m2_inv4_M2b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv4_M2b", "by (rule inv_rule_incr) (auto del: subsetI)"], ["", "text \\<open>Consequence needed in proof of inv8/step5 and inv9/step4: The \nsession key uniquely identifies other fields in M2a and M2b, provided it \nis secret.\\<close>"], ["", "lemma m2_inv4_M2a_M2b_match:\n  \"\\<lbrakk> Secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts']) \\<in> chan s; \n     Secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s; \n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a; s \\<in> m2_inv4_M2b \\<rbrakk>\n  \\<Longrightarrow> A = A' \\<and> B = B' \\<and> Ts = Ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>StatCh secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts'])\n             \\<in> chan s;\n     StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s;\n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a;\n     s \\<in> m2_inv4_M2b\\<rbrakk>\n    \\<Longrightarrow> A = A' \\<and> B = B' \\<and> Ts = Ts'", "apply (subgoal_tac \"A' \\<notin> bad \\<and> B \\<notin> bad\", auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>StatCh secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts'])\n             \\<in> chan s;\n     StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s;\n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a;\n     s \\<in> m2_inv4_M2b; A' \\<notin> bad; B \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> A = A'\n 2. \\<lbrakk>StatCh secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts'])\n             \\<in> chan s;\n     StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s;\n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a;\n     s \\<in> m2_inv4_M2b; A' \\<notin> bad; B \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> B = B'\n 3. \\<lbrakk>StatCh secure Sv A' (Msg [aAgt B', aKey Kab, aNum Ts'])\n             \\<in> chan s;\n     StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum Ts]) \\<in> chan s;\n     aKey Kab \\<notin> extr ik0 (chan s); s \\<in> m2_inv4_M2a;\n     s \\<in> m2_inv4_M2b; A' \\<notin> bad; B \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> Ts = Ts'", "apply (auto dest!: m2_inv4_M2aD m2_inv4_M2bD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>More consequences of invariants. Needed in ref/step4 and ref/step5 \nrespectively to show the strengthening of the authorization guards.\\<close>"], ["", "lemma m2_inv34_M2a_authorized:\n  assumes \"Secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\" \n          \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv4_M2a\" \"K \\<notin> leak s\"  \n  shows   \"(K, A) \\<in> azC (runs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "proof (cases \"A \\<in> bad\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<in> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "case True"], ["proof (state)\nthis:\n  A \\<in> bad\n\ngoal (2 subgoals):\n 1. A \\<in> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "from assms(1) \\<open>A \\<in> bad\\<close>"], ["proof (chain)\npicking this:\n  StatCh secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\n  A \\<in> bad", "have \"aKey K \\<in> extr ik0 (chan s)\""], ["proof (prove)\nusing this:\n  StatCh secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\n  A \\<in> bad\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "by auto"], ["proof (state)\nthis:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (2 subgoals):\n 1. A \\<in> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)\n 2. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "with \\<open>s \\<in> m2_inv3_extrKey\\<close> \\<open>K \\<notin> leak s\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> m2_inv3_extrKey\n  K \\<notin> leak s\n  aKey K \\<in> extr ik0 (chan s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> m2_inv3_extrKey\n  K \\<notin> leak s\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "by auto"], ["proof (state)\nthis:\n  (K, A) \\<in> azC (runs s)\n\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "case False"], ["proof (state)\nthis:\n  A \\<notin> bad\n\ngoal (1 subgoal):\n 1. A \\<notin> bad \\<Longrightarrow> (K, A) \\<in> azC (runs s)", "with assms"], ["proof (chain)\npicking this:\n  StatCh secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv4_M2a\n  K \\<notin> leak s\n  A \\<notin> bad", "show ?thesis"], ["proof (prove)\nusing this:\n  StatCh secure Sv A (Msg [aAgt B, aKey K, aNum T]) \\<in> chan s\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv4_M2a\n  K \\<notin> leak s\n  A \\<notin> bad\n\ngoal (1 subgoal):\n 1. (K, A) \\<in> azC (runs s)", "by (auto dest: m2_inv4_M2aD)"], ["proof (state)\nthis:\n  (K, A) \\<in> azC (runs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m2_inv34_M2b_authorized:\n  assumes \"Secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\" \n          \"s \\<in> m2_inv3_extrKey\" \"s \\<in> m2_inv4_M2b\" \"K \\<notin> leak s\"  \n  shows  \"(K, B) \\<in> azC (runs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "proof (cases \"B \\<in> bad\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<in> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "case True"], ["proof (state)\nthis:\n  B \\<in> bad\n\ngoal (2 subgoals):\n 1. B \\<in> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "from assms(1) \\<open>B \\<in> bad\\<close>"], ["proof (chain)\npicking this:\n  StatCh secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\n  B \\<in> bad", "have \"aKey K \\<in> extr ik0 (chan s)\""], ["proof (prove)\nusing this:\n  StatCh secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\n  B \\<in> bad\n\ngoal (1 subgoal):\n 1. aKey K \\<in> extr ik0 (chan s)", "by auto"], ["proof (state)\nthis:\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (2 subgoals):\n 1. B \\<in> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)\n 2. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "with \\<open>s \\<in> m2_inv3_extrKey\\<close> \\<open>K \\<notin> leak s\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> m2_inv3_extrKey\n  K \\<notin> leak s\n  aKey K \\<in> extr ik0 (chan s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> m2_inv3_extrKey\n  K \\<notin> leak s\n  aKey K \\<in> extr ik0 (chan s)\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "by auto"], ["proof (state)\nthis:\n  (K, B) \\<in> azC (runs s)\n\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "case False"], ["proof (state)\nthis:\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. B \\<notin> bad \\<Longrightarrow> (K, B) \\<in> azC (runs s)", "with assms"], ["proof (chain)\npicking this:\n  StatCh secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv4_M2b\n  K \\<notin> leak s\n  B \\<notin> bad", "show ?thesis"], ["proof (prove)\nusing this:\n  StatCh secure Sv B (Msg [aKey K, aAgt A, aNum T]) \\<in> chan s\n  s \\<in> m2_inv3_extrKey\n  s \\<in> m2_inv4_M2b\n  K \\<notin> leak s\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. (K, B) \\<in> azC (runs s)", "by (auto dest: m2_inv4_M2bD)"], ["proof (state)\nthis:\n  (K, B) \\<in> azC (runs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>inv5: Key secrecy for server\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>inv5: Key secrecy from server perspective. This invariant links the \nabstract notion of key secrecy to the intruder key knowledge.\\<close>"], ["", "definition \n  m2_inv5_ikk_sv :: \"m2_state set\"\nwhere\n  \"m2_inv5_ikk_sv \\<equiv> {s. \\<forall>R A B al.\n     runs s R = Some (Serv, [A, B], al) \\<longrightarrow> A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow>\n     aKey (sesK (R$sk)) \\<in> extr ik0 (chan s) \\<longrightarrow>\n       sesK (R$sk) \\<in> leak s\n  }\""], ["", "lemmas m2_inv5_ikk_svI = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv5_ikk_svE [elim] = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv5_ikk_svD = \n  m2_inv5_ikk_sv_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m2_inv5_ikk_sv_init [iff]:\n  \"init m2 \\<subseteq> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> m2_inv5_ikk_sv", "by (auto simp add: m2_defs intro!: m2_inv5_ikk_svI)"], ["", "lemma PO_m2_inv5_ikk_sv_trans [iff]:\n  \"{m2_inv5_ikk_sv \\<inter> m2_inv3a_sesK_compr \\<inter> m2_inv3_extrKey} \n     trans m2 \n   {> m2_inv5_ikk_sv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m2_inv5_ikk_sv \\<inter> m2_inv3a_sesK_compr \\<inter>\n     m2_inv3_extrKey} TS.trans m2 {> m2_inv5_ikk_sv}", "by (simp add: PO_hoare_defs m2_defs, safe intro!: m2_inv5_ikk_svI)\n   (auto simp add: m2_inv3a_sesK_compr_simps dest: dom_lemmas)"], ["", "lemma PO_m2_inv5_ikk_sv [iff]: \"reach m2 \\<subseteq> m2_inv5_ikk_sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m2 \\<subseteq> m2_inv5_ikk_sv", "by (rule_tac J=\"m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr\" in inv_rule_incr) (auto)"], ["", "subsubsection \\<open>inv6/7: Key secrecy for initiator and responder\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>These invariants are derivable.\\<close>"], ["", "definition \n  m2_inv6_ikk_init :: \"m2_state set\"\nwhere\n  \"m2_inv6_ikk_init \\<equiv> {s. \\<forall>A B Ra K Ts nl.\n     runs s Ra = Some (Init, [A, B], aKey K # aNum Ts # nl) \\<longrightarrow> \n     A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow> aKey K \\<in> extr ik0 (chan s) \\<longrightarrow> \n       K \\<in> leak s\n  }\""], ["", "lemmas m2_inv6_ikk_initI = m2_inv6_ikk_init_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv6_ikk_initE [elim] = m2_inv6_ikk_init_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv6_ikk_initD = m2_inv6_ikk_init_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "definition \n  m2_inv7_ikk_resp :: \"m2_state set\"\nwhere\n  \"m2_inv7_ikk_resp \\<equiv> {s. \\<forall>A B Rb K Ts nl.\n     runs s Rb = Some (Resp, [A, B], aKey K # aNum Ts # nl) \\<longrightarrow> \n     A \\<in> good \\<longrightarrow> B \\<in> good \\<longrightarrow> aKey K \\<in> extr ik0 (chan s) \\<longrightarrow>\n       K \\<in> leak s\n  }\""], ["", "lemmas m2_inv7_ikk_respI = m2_inv7_ikk_resp_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m2_inv7_ikk_respE [elim] = m2_inv7_ikk_resp_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m2_inv7_ikk_respD = m2_inv7_ikk_resp_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The simulation relation. This is a pure superposition refinement.\\<close>"], ["", "definition\n  R12 :: \"(m1_state \\<times> m2_state) set\" where\n  \"R12 \\<equiv> {(s, t). runs s = runs t \\<and> leak s = leak t \\<and> clk s = clk t}\""], ["", "text \\<open>The mediator function is the identity.\\<close>"], ["", "definition \n  med21 :: \"m2_obs \\<Rightarrow> m1_obs\" where\n  \"med21 = id\""], ["", "text \\<open>Refinement proof.\\<close>"], ["", "lemma PO_m2_step1_refines_m1_step1:\n  \"{R12} \n     (m1_step1 Ra A B), (m2_step1 Ra A B) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step1 Ra A B, m2_step1 Ra A B {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step2_refines_m1_step2:\n  \"{R12} \n     (m1_step2 Rb A B), (m2_step2 Rb A B)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step2 Rb A B, m2_step2 Rb A B {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step3_refines_m1_step3:\n  \"{R12} \n     (m1_step3 Rs A B Kab Ts), (m2_step3 Rs A B Kab Ts)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_step3 Rs A B Kab Ts, m2_step3 Rs A B Kab Ts {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_step4_refines_m1_step4:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2a \\<inter> m2_inv3_extrKey)} \n     (m1_step4 Ra A B Kab Ts), (m2_step4 Ra A B Kab Ts)  \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv4_M2a \\<inter>\n      m2_inv3_extrKey)} m1_step4 Ra A B Kab\n                         Ts, m2_step4 Ra A B Kab Ts {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, simp_all)\n   (auto dest: m2_inv34_M2a_authorized)"], ["", "lemma PO_m2_step5_refines_m1_step5:\n  \"{R12 \\<inter> UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv3_extrKey)}          \\<comment> \\<open>REMOVED!: \\<open>m2_inv5_ikk_sv\\<close>\\<close>\n     (m1_step5 Rb A B Kab Ts), (m2_step5 Rb A B Kab Ts) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv4_M2b \\<inter>\n      m2_inv3_extrKey)} m1_step5 Rb A B Kab\n                         Ts, m2_step5 Rb A B Kab Ts {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, simp_all)\n   (auto dest: m2_inv34_M2b_authorized)"], ["", "lemma PO_m2_tick_refines_m1_tick:\n  \"{R12}\n    (m1_tick T), (m2_tick T)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_tick T, m2_tick T {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, simp_all)"], ["", "lemma PO_m2_leak_refines_m1_leak:\n  \"{R12} \n     (m1_leak Rs), (m2_leak Rs)\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} m1_leak Rs, m2_leak Rs {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "lemma PO_m2_fake_refines_skip:\n  \"{R12} \n     Id, m2_fake\n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12} Id, m2_fake {> R12}", "by (simp add: PO_rhoare_defs R12_def m2_defs, safe, auto)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m2_trans_refines_m1_trans = \n  PO_m2_step1_refines_m1_step1 PO_m2_step2_refines_m1_step2\n  PO_m2_step3_refines_m1_step3 PO_m2_step4_refines_m1_step4\n  PO_m2_step5_refines_m1_step5 PO_m2_tick_refines_m1_tick \n  PO_m2_leak_refines_m1_leak PO_m2_fake_refines_skip"], ["", "lemma PO_m2_refines_init_m1 [iff]:\n  \"init m2 \\<subseteq> R12``(init m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m2 \\<subseteq> R12 `` init m1", "by (auto simp add: R12_def m1_defs m2_loc_defs)"], ["", "lemma PO_m2_refines_trans_m1 [iff]:\n  \"{R12 \\<inter> \n    UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter> m2_inv3_extrKey)} \n     (trans m1), (trans m2) \n   {> R12}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12 \\<inter>\n     UNIV \\<times>\n     (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter>\n      m2_inv3_extrKey)} TS.trans m1, TS.trans m2 {> R12}", "by (auto simp add: m2_def m2_trans_def m1_def m1_trans_def)\n   (blast intro!: PO_m2_trans_refines_m1_trans)+"], ["", "lemma PO_obs_consistent_R12 [iff]: \n  \"obs_consistent R12 med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R12 med21 m1 m2", "by (auto simp add: obs_consistent_def R12_def med21_def m2_defs)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma m2_refines_m1 [iff]:\n  \"refines \n     (R12 \\<inter> \n      (UNIV \\<times> (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter> m2_inv3_extrKey \\<inter> m2_inv3a_sesK_compr)))\n     med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R12 \\<inter>\n      UNIV \\<times>\n      (m2_inv4_M2b \\<inter> m2_inv4_M2a \\<inter> m2_inv3_extrKey \\<inter>\n       m2_inv3a_sesK_compr))\n     med21 m1 m2", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma m2_implements_m1 [iff]:\n  \"implements med21 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med21 m1 m2", "by (rule refinement_soundness) (auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Inherited and derived invariants\\<close>"], ["", "(******************************************************************************)\n(*\ntext {* Show preservation of invariants @{term \"m1_inv2i_serv\"} and\n@{term \"m1_inv2r_serv\"} from @{text \"m1\"}. *}\n\nlemma PO_m2_sat_m1_inv2i_serv [iff]: \"reach m2 \\<subseteq> m1_inv2i_serv\"\nby (rule_tac Pa=m1_inv2i_serv and Qa=m1_inv2i_serv and Q=m1_inv2i_serv \n       in m2_implements_m1 [THEN [5] internal_invariant_translation])\n   (auto simp add: m2_loc_defs med21_def intro!: m1_inv2i_servI)\n\nlemma PO_m2_sat_m1_inv2r_serv [iff]: \"reach m2 \\<subseteq> m1_inv2r_serv\"\nby (rule_tac Pa=m1_inv2r_serv and Qa=m1_inv2r_serv and Q=m1_inv2r_serv\n       in m2_implements_m1 [THEN [5] internal_invariant_translation])\n   (fastforce simp add: m2_loc_defs med21_def intro!: m1_inv2r_servI)+\n\n\ntext {* Now we derive the L2 key secrecy invariants for the initiator \nand the responder (for definition, see above). *}\n\nlemma PO_m2_inv6_init_ikk [iff]: \"reach m2 \\<subseteq> m2_inv6_ikk_init\"\napply (rule_tac B=\" m1_inv2i_serv \\<inter> m2_inv5_ikk_sv\" in subset_trans, auto)\napply (rule m2_inv6_ikk_initI, auto)\napply (blast dest!: m1_inv2i_servD) \ndone\n\nlemma PO_m2_inv6_resp_ikk [iff]: \"reach m2 \\<subseteq> m2_inv7_ikk_resp\"\napply (rule_tac B=\" m1_inv2r_serv \\<inter> m2_inv5_ikk_sv\" in subset_trans, auto)\napply (rule m2_inv7_ikk_respI, auto)\napply (blast dest!: m1_inv2r_servD) \ndone\n*)"], ["", "end"]]}