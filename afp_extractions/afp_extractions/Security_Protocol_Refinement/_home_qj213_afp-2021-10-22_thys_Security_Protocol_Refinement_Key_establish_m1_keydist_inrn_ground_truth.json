{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m1_keydist_inrn.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemma init_m1a: \"init m1a = m1a_init\"", "lemma trans_m1a: \"trans m1a = m1a_trans\"", "lemma obs_m1a [simp]: \"obs m1a = id\"", "lemmas m1a_loc_defs = \n  m1a_def m1a_init_def m1a_trans_def\n  m1a_step1_def m1a_step2_def m1a_step3_def m1a_step4_def m1a_step5_def \n  m1a_leak_def", "lemmas m1a_defs = m1a_loc_defs m1x_defs", "lemmas m1a_inv0_finI = m1a_inv0_fin_def [THEN setc_def_to_intro, rule_format]", "lemmas m1a_inv0_finE [elim] = m1a_inv0_fin_def [THEN setc_def_to_elim, rule_format]", "lemmas m1a_inv0_finD = m1a_inv0_fin_def [THEN setc_def_to_dest, rule_format]", "lemma PO_m1a_inv0_fin_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv0_fin\"", "lemma PO_m1a_inv0_fin_trans [iff]:\n  \"{m1a_inv0_fin} trans m1a {> m1a_inv0_fin}\"", "lemma PO_m1a_inv0_fin [iff]: \"reach m1a \\<subseteq> m1a_inv0_fin\"", "lemmas R1x1a_defs = \n  R1x1a_def med1x1a_def", "lemma PO_m1a_step1_refines_m1x_step1:\n  \"{R1x1a} \n     (m1x_step1 Ra A B), (m1a_step1 Ra A B) \n   {> R1x1a}\"", "lemma PO_m1a_step2_refines_m1x_step2:\n  \"{R1x1a} \n     (m1x_step2 Rb A B), (m1a_step2 Rb A B) \n   {> R1x1a}\"", "lemma PO_m1a_step3_refines_m1x_step3:\n  \"{R1x1a} \n     (m1x_step3 Rs A B Kab), (m1a_step3 Rs A B Kab nls)\n   {> R1x1a}\"", "lemma PO_m1a_step4_refines_m1x_step4:\n  \"{R1x1a} \n     (m1x_step4 Ra A B Kab), (m1a_step4 Ra A B Kab nla) \n   {> R1x1a}\"", "lemma PO_m1a_step5_refines_m1x_step5:\n  \"{R1x1a} \n     (m1x_step5 Rb A B Kab), (m1a_step5 Rb A B Kab nlb) \n   {> R1x1a}\"", "lemma PO_m1a_leak_refines_m1x_leak:\n  \"{R1x1a} \n     (m1x_leak Rs), (m1a_leak Rs) \n   {> R1x1a}\"", "lemmas PO_m1a_trans_refines_m1x_trans = \n  PO_m1a_step1_refines_m1x_step1 PO_m1a_step2_refines_m1x_step2\n  PO_m1a_step3_refines_m1x_step3 PO_m1a_step4_refines_m1x_step4\n  PO_m1a_step5_refines_m1x_step5 PO_m1a_leak_refines_m1x_leak", "lemma PO_m1a_refines_init_m1x [iff]:\n  \"init m1a \\<subseteq>  R1x1a``(init m1x)\"", "lemma PO_m1a_refines_trans_m1x [iff]:\n  \"{R1x1a} \n     (trans m1x), (trans m1a) \n   {> R1x1a}\"", "lemma obs_consistent_med1x1a [iff]: \n  \"obs_consistent R1x1a med1x1a m1x m1a\"", "lemma PO_m1a_refines_m1x [iff]: \n  \"refines R1x1a med1x1a m1x m1a\"", "lemma  m1a_implements_m1x [iff]: \"implements med1x1a m1x m1a\"", "lemmas R_a0m1a_is_defs = R_a0m1a_is_def med_a0m1a_is_def", "lemma is_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma is_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (is_commit runz A B Kab nls)\"", "lemma is_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz\"", "lemma is_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz\"", "lemma is_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) = \n     (is_runs2sigs runz)(Running [A, Sv] (sesK (Rs$sk), B, take is_len nls) := 1)\"", "lemma is_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); finite (dom runz); \n     ils = take is_len nla \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n     (is_runs2sigs runz)(\n        Commit [A, Sv] (Kab, B, ils) := \n          Suc (card (is_commit runz A B Kab ils)))\"", "lemma is_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n     is_runs2sigs runz\"", "lemma PO_m1a_step1_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step1 Ra A B) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step2_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step3_refines_a0_is_running:\n  \"{R_a0m1a_is} \n     (a0n_running [A, Sv] (Kab, B, take is_len nls)), \n     (m1a_step3 Rs A B Kab nls) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step4_refines_a0_is_commit:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [A, Sv] (Kab, B, take is_len nla)), \n     (m1a_step4 Ra A B Kab nla) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step5_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_leak_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_is}\"", "lemmas PO_m1a_trans_refines_a0_is_trans = \n  PO_m1a_step1_refines_a0_is_skip PO_m1a_step2_refines_a0_is_skip\n  PO_m1a_step3_refines_a0_is_running PO_m1a_step4_refines_a0_is_commit\n  PO_m1a_step5_refines_a0_is_skip PO_m1a_leak_refines_a0_is_skip", "lemma PO_m1a_refines_init_a0_is [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_is``(init a0n)\"", "lemma PO_m1a_refines_trans_a0_is [iff]:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_is}\"", "lemma obs_consistent_med_a0m1a_is [iff]: \n  \"obs_consistent R_a0m1a_is med_a0m1a_is a0n m1a\"", "lemma PO_m1a_refines_a0_is [iff]: \n  \"refines (R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_is a0n m1a\"", "lemma  m1a_implements_a0_is: \"implements med_a0m1a_is a0n m1a\"", "lemmas R_a0m1a_rs_defs = R_a0m1a_rs_def med_a0m1a_rs_def", "lemma rs_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma rs_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)\"", "lemma rs_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) = \n     (rs_runs2sigs runz)(Running [B, Sv] (sesK (Rs$sk), A, take rs_len nls) := 1)\"", "lemma rs_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n     rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb \\<rbrakk>\n \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n   (rs_runs2sigs runz)(\n      Commit [B, Sv] (Kab, A, rsl) := Suc (card (rs_commit runz A B Kab rsl)))\"", "lemma PO_m1a_step1_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step1 Ra A B) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step2_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step3_refines_a0_rs_running:\n  \"{R_a0m1a_rs} \n     (a0n_running [B, Sv] (Kab, A, take rs_len nls)), \n     (m1a_step3 Rs A B Kab nls) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step4_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step4 Ra A B Kab nla) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step5_refines_a0_rs_commit:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [B, Sv] (Kab, A, take rs_len nlb)), \n     (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_leak_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_rs}\"", "lemmas PO_m1a_trans_refines_a0_rs_trans = \n  PO_m1a_step1_refines_a0_rs_skip PO_m1a_step2_refines_a0_rs_skip\n  PO_m1a_step3_refines_a0_rs_running PO_m1a_step4_refines_a0_rs_skip\n  PO_m1a_step5_refines_a0_rs_commit PO_m1a_leak_refines_a0_rs_skip", "lemma PO_m1a_refines_init_ra0n [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_rs``(init a0n)\"", "lemma PO_m1a_refines_trans_ra0n [iff]:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_rs}\"", "lemma obs_consistent_med_a0m1a_rs [iff]: \n  \"obs_consistent (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\"", "lemma PO_m1a_refines_a0_rs [iff]: \n  \"refines (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\"", "lemma  m1a_implements_ra0n: \"implements med_a0m1a_rs a0n m1a\""], "translations": [["", "lemma init_m1a: \"init m1a = m1a_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a = m1a_init", "by (simp add: m1a_def)"], ["", "lemma trans_m1a: \"trans m1a = m1a_trans\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS.trans m1a = m1a_trans", "by (simp add: m1a_def)"], ["", "lemma obs_m1a [simp]: \"obs m1a = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs m1a = id", "by (simp add: m1a_def)"], ["", "lemmas m1a_loc_defs = \n  m1a_def m1a_init_def m1a_trans_def\n  m1a_step1_def m1a_step2_def m1a_step3_def m1a_step4_def m1a_step5_def \n  m1a_leak_def"], ["", "lemmas m1a_defs = m1a_loc_defs m1x_defs"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>inv0: Finite domain\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>There are only finitely many runs. This is needed to establish\nthe responder/initiator agreement.\\<close>"], ["", "definition \n  m1a_inv0_fin :: \"'x m1r_pred\"\nwhere\n  \"m1a_inv0_fin \\<equiv> {s. finite (dom (runs s))}\""], ["", "lemmas m1a_inv0_finI = m1a_inv0_fin_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1a_inv0_finE [elim] = m1a_inv0_fin_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1a_inv0_finD = m1a_inv0_fin_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m1a_inv0_fin_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> m1a_inv0_fin", "by (auto simp add: m1a_defs intro!: m1a_inv0_finI)"], ["", "lemma PO_m1a_inv0_fin_trans [iff]:\n  \"{m1a_inv0_fin} trans m1a {> m1a_inv0_fin}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1a_inv0_fin} TS.trans m1a {> m1a_inv0_fin}", "by (auto simp add: PO_hoare_defs m1a_defs intro!: m1a_inv0_finI)"], ["", "lemma PO_m1a_inv0_fin [iff]: \"reach m1a \\<subseteq> m1a_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1a_inv0_fin", "by (rule inv_rule_incr, auto del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>m1x\\<close>\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Define run abstraction.\\<close>"], ["", "fun \n  rm1x1a :: \"role_t \\<Rightarrow> atom list \\<Rightarrow> atom list\"\nwhere\n  \"rm1x1a Init = take 1\"         \\<comment> \\<open>take \\<open>Kab\\<close> from \\<open>Kab # nla\\<close>\\<close>\n| \"rm1x1a Resp = take 1\"         \\<comment> \\<open>take \\<open>Kab\\<close> from \\<open>Kab # nlb\\<close>\\<close>\n| \"rm1x1a Serv = take 0\"         \\<comment> \\<open>drop all from \\<open>nls\\<close>\\<close>"], ["", "abbreviation\n  runs1x1a :: \"runs_t \\<Rightarrow> runs_t\" where \n  \"runs1x1a \\<equiv> map_runs rm1x1a\""], ["", "text \\<open>med1x1: The mediator function maps a concrete observation to an \nabstract one.\\<close>"], ["", "definition\n  med1x1a :: \"m1a_obs \\<Rightarrow> m1x_obs\" where\n  \"med1x1a t \\<equiv> \\<lparr> runs = runs1x1a (runs t), leak = leak t \\<rparr>\""], ["", "text \\<open>R1x1a: The simulation relation is defined in terms of the mediator\nfunction.\\<close>"], ["", "definition\n  R1x1a :: \"(m1x_state \\<times> m1a_state) set\" where\n  \"R1x1a \\<equiv> {(s, t). s = med1x1a t}\""], ["", "lemmas R1x1a_defs = \n  R1x1a_def med1x1a_def"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_m1x_step1:\n  \"{R1x1a} \n     (m1x_step1 Ra A B), (m1a_step1 Ra A B) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step1 Ra A B, m1a_step1 Ra A B {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_m1x_step2:\n  \"{R1x1a} \n     (m1x_step2 Rb A B), (m1a_step2 Rb A B) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step2 Rb A B, m1a_step2 Rb A B {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_m1x_step3:\n  \"{R1x1a} \n     (m1x_step3 Rs A B Kab), (m1a_step3 Rs A B Kab nls)\n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step3 Rs A B Kab, m1a_step3 Rs A B Kab nls {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step4_refines_m1x_step4:\n  \"{R1x1a} \n     (m1x_step4 Ra A B Kab), (m1a_step4 Ra A B Kab nla) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step4 Ra A B Kab, m1a_step4 Ra A B Kab nla {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "lemma PO_m1a_step5_refines_m1x_step5:\n  \"{R1x1a} \n     (m1x_step5 Rb A B Kab), (m1a_step5 Rb A B Kab nlb) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step5 Rb A B Kab, m1a_step5 Rb A B Kab nlb {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "lemma PO_m1a_leak_refines_m1x_leak:\n  \"{R1x1a} \n     (m1x_leak Rs), (m1a_leak Rs) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_leak Rs, m1a_leak Rs {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_m1x_trans = \n  PO_m1a_step1_refines_m1x_step1 PO_m1a_step2_refines_m1x_step2\n  PO_m1a_step3_refines_m1x_step3 PO_m1a_step4_refines_m1x_step4\n  PO_m1a_step5_refines_m1x_step5 PO_m1a_leak_refines_m1x_leak"], ["", "lemma PO_m1a_refines_init_m1x [iff]:\n  \"init m1a \\<subseteq>  R1x1a``(init m1x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R1x1a `` init m1x", "by (auto simp add: R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_m1x [iff]:\n  \"{R1x1a} \n     (trans m1x), (trans m1a) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} TS.trans m1x, TS.trans m1a {> R1x1a}", "apply (auto simp add: m1a_def m1a_trans_def m1x_def m1x_trans_def\n         intro!: PO_m1a_trans_refines_m1x_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak xd)\\<^sup>=, m1a_step1 xb x xa {> R1x1a}\n 2. \\<And>x xa xc.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak xd)\\<^sup>=, m1a_step2 xc x xa {> R1x1a}\n 3. \\<And>x xa xd xe xf.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak xd)\\<^sup>=, m1a_step3 xd x xa xe xf {> R1x1a}", "apply (force intro!: PO_m1a_trans_refines_m1x_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med1x1a [iff]: \n  \"obs_consistent R1x1a med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R1x1a med1x1a m1x m1a", "by (auto simp add: obs_consistent_def R1x1a_def m1a_defs)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_m1x [iff]: \n  \"refines R1x1a med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R1x1a med1x1a m1x m1a", "by (rule Refinement_basic) (auto del: subsetI)"], ["", "lemma  m1a_implements_m1x [iff]: \"implements med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med1x1a m1x m1a", "by (rule refinement_soundness) (fast)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0n\\<close> for initiator/server\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>For the initiator, we get an non-injective agreement with the server on \nthe session key, the responder name, and the atom list @{term \"isl\"}.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and server runs.\\<close>"], ["", "type_synonym\n  issig = \"key \\<times> agent \\<times> atom list\""], ["", "abbreviation\n  is_commit :: \"[runs_t, agent, agent, key, atom list] \\<Rightarrow> rid_t set\" \nwhere\n  \"is_commit runz A B Kab sl \\<equiv> {Ra. \\<exists>nla. \n     runz Ra = Some (Init, [A, B], aKey Kab # nla) \\<and> take is_len nla = sl\n  }\""], ["", "fun\n  is_runs2sigs :: \"runs_t \\<Rightarrow> issig signal \\<Rightarrow> nat\"\nwhere\n  \"is_runs2sigs runz (Running [A, Sv] (Kab, B, sl)) = \n     (if \\<exists>Rs nls. Kab = sesK (Rs$sk) \\<and> \n         runz Rs = Some (Serv, [A, B], nls) \\<and> take is_len nls = sl\n      then 1 else 0)\"\n\n| \"is_runs2sigs runz (Commit [A, Sv] (Kab, B, sl)) = \n     card (is_commit runz A B Kab sl)\"\n\n| \"is_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0m1a_is :: \"m1a_obs \\<Rightarrow> issig a0i_obs\" where\n  \"med_a0m1a_is o1 \\<equiv> \\<lparr> signals = is_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0m1a_is :: \"(issig a0i_state \\<times> m1a_state) set\" where\n  \"R_a0m1a_is \\<equiv> {(s, t). signals s = is_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0m1a_is_defs = R_a0m1a_is_def med_a0m1a_is_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "lemma is_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto)"], ["", "lemma is_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (is_commit runz A B Kab nls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow> finite (is_commit runz A B Kab nls)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma is_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma is_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma is_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) = \n     (is_runs2sigs runz)(Running [A, Sv] (sesK (Rs$sk), B, take is_len nls) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) =\n    (is_runs2sigs runz)\n    (Running [A, Sv] (sesK (Rs $ sk), B, take is_len nls) := 1)", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma is_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); finite (dom runz); \n     ils = take is_len nla \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n     (is_runs2sigs runz)(\n        Commit [A, Sv] (Kab, B, ils) := \n          Suc (card (is_commit runz A B Kab ils)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Ra = Some (Init, [A, B], []); finite (dom runz);\n     ils = take is_len nla\\<rbrakk>\n    \\<Longrightarrow> is_runs2sigs\n                       (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n                      (is_runs2sigs runz)\n                      (Commit [A, Sv] (Kab, B, ils) :=\n                         Suc (card (is_commit runz A B Kab ils)))", "apply (rule ext, erule rev_mp, erule rev_mp, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ils = take is_len nla \\<longrightarrow>\n       finite (dom runz) \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) x =\n       ((is_runs2sigs runz)\n        (Commit [A, Sv] (Kab, B, ils) :=\n           Suc (card (is_commit runz A B Kab ils))))\n        x", "apply (rename_tac s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       ils = take is_len nla \\<longrightarrow>\n       finite (dom runz) \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) s =\n       ((is_runs2sigs runz)\n        (Commit [A, Sv] (Kab, B, ils) :=\n           Suc (card (is_commit runz A B Kab ils))))\n        s", "apply (rule_tac ?a0.0=runz and ?a1.0=s in is_runs2sigs.induct, auto)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>ils = take is_len nla; finite (dom runz);\n        runz Ra = Some (Init, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           (\\<exists>nlaa.\n                               runz Raa =\n                               Some (Init, [A, B], aKey Kab # nlaa) \\<and>\n                               take is_len nlaa = take is_len nla)} =\n                         Suc (card\n                               (is_commit runz A B Kab (take is_len nla)))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>ils = take is_len nla; finite (dom runz);\n        runz Ra = Some (Init, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           (\\<exists>nlaa.\n                               runz Raa =\n                               Some (Init, [A, B], aKey Kab # nlaa) \\<and>\n                               take is_len nlaa = take is_len nla)} =\n                         Suc (card\n                               (is_commit runz A B Kab (take is_len nla)))", "apply (rule_tac s=\"card (insert Ra (is_commit runz A B Kab (take is_len nla)))\" \n      in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n     is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], []) \\<Longrightarrow>\n    is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n    is_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step1 Ra A B) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step1 Ra A B {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step2 Rb A B {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_a0_is_running:\n  \"{R_a0m1a_is} \n     (a0n_running [A, Sv] (Kab, B, take is_len nls)), \n     (m1a_step3 Rs A B Kab nls) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} a0i_running [A, Sv]\n                  (Kab, B,\n                   take is_len nls), m1a_step3 Rs A B Kab nls {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs a0i_defs m1a_defs\n         dest: dom_lemmas)"], ["", "lemma PO_m1a_step4_refines_a0_is_commit:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [A, Sv] (Kab, B, take is_len nla)), \n     (m1a_step4 Ra A B Kab nla) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is \\<inter>\n     UNIV \\<times>\n     m1a_inv0_fin} a0n_commit [A, Sv]\n                    (Kab, B,\n                     take is_len\n                      nla), m1a_step4 Ra A B Kab nla {> R_a0m1a_is}", "by (simp add: PO_rhoare_defs R_a0m1a_is_defs a0i_defs m1a_defs, safe, auto)"], ["", "lemma PO_m1a_step5_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step5 Rb A B Kab nlb {> R_a0m1a_is}", "by (simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs, safe, auto)"], ["", "lemma PO_m1a_leak_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_leak Rs {> R_a0m1a_is}", "by (simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs, safe, auto)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_a0_is_trans = \n  PO_m1a_step1_refines_a0_is_skip PO_m1a_step2_refines_a0_is_skip\n  PO_m1a_step3_refines_a0_is_running PO_m1a_step4_refines_a0_is_commit\n  PO_m1a_step5_refines_a0_is_skip PO_m1a_leak_refines_a0_is_skip"], ["", "lemma PO_m1a_refines_init_a0_is [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_is``(init a0n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R_a0m1a_is `` init a0n", "by (auto simp add: R_a0m1a_is_defs a0n_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_a0_is [iff]:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is \\<inter>\n     UNIV \\<times> m1a_inv0_fin} TS.trans a0n, TS.trans m1a {> R_a0m1a_is}", "by (auto simp add: m1a_def m1a_trans_def a0n_def a0n_trans_def\n         intro!: PO_m1a_trans_refines_a0_is_trans)"], ["", "lemma obs_consistent_med_a0m1a_is [iff]: \n  \"obs_consistent R_a0m1a_is med_a0m1a_is a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R_a0m1a_is med_a0m1a_is a0n m1a", "by (auto simp add: obs_consistent_def R_a0m1a_is_def med_a0m1a_is_def \n                   a0n_def m1a_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_a0_is [iff]: \n  \"refines (R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_is a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_is\n     a0n m1a", "by (rule Refinement_using_invariants) (auto del: subsetI)"], ["", "lemma  m1a_implements_a0_is: \"implements med_a0m1a_is a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0m1a_is a0n m1a", "by (rule refinement_soundness) (fast)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0n\\<close> for responder/server\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>For the responder, we get a non-injective agreement with the server on \nthe session key, the initiator's name, and additional data.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed responder and server runs.\\<close>"], ["", "type_synonym\n  rssig = \"key \\<times> agent \\<times> atom list\""], ["", "abbreviation\n  rs_commit :: \"[runs_t, agent, agent, key, atom list] \\<Rightarrow> rid_t set\" \nwhere\n  \"rs_commit runz A B Kab rsl \\<equiv> {Rb. \\<exists>nlb. \n     runz Rb = Some (Resp, [A, B], aKey Kab # nlb) \\<and> take rs_len nlb = rsl \n  }\""], ["", "fun\n  rs_runs2sigs :: \"runs_t \\<Rightarrow> rssig signal \\<Rightarrow> nat\"\nwhere\n  \"rs_runs2sigs runz (Running [B, Sv] (Kab, A, rsl)) = \n     (if \\<exists>Rs nls. Kab = sesK (Rs$sk) \\<and>\n         runz Rs = Some (Serv, [A, B], nls) \\<and> take rs_len nls = rsl\n      then 1 else 0)\"\n\n| \"rs_runs2sigs runz (Commit [B, Sv] (Kab, A, rsl)) = \n     card (rs_commit runz A B Kab rsl)\"\n\n| \"rs_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0m1a_rs :: \"m1a_obs \\<Rightarrow> rssig a0n_obs\" where\n  \"med_a0m1a_rs o1 \\<equiv> \\<lparr> signals = rs_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0m1a_rs :: \"(rssig a0n_state \\<times> m1a_state) set\" where\n  \"R_a0m1a_rs \\<equiv> {(s, t). signals s = rs_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0m1a_rs_defs = R_a0m1a_rs_def med_a0m1a_rs_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Other lemmas\\<close>"], ["", "lemma rs_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto)"], ["", "lemma rs_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma rs_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) = \n     (rs_runs2sigs runz)(Running [B, Sv] (sesK (Rs$sk), A, take rs_len nls) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nls))) =\n    (rs_runs2sigs runz)\n    (Running [B, Sv] (sesK (Rs $ sk), A, take rs_len nls) := 1)", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n     rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n    rs_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb \\<rbrakk>\n \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n   (rs_runs2sigs runz)(\n      Commit [B, Sv] (Kab, A, rsl) := Suc (card (rs_commit runz A B Kab rsl)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb\\<rbrakk>\n    \\<Longrightarrow> rs_runs2sigs\n                       (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n                      (rs_runs2sigs runz)\n                      (Commit [B, Sv] (Kab, A, rsl) :=\n                         Suc (card (rs_commit runz A B Kab rsl)))", "apply (rule ext, erule rev_mp, erule rev_mp, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rsl = take rs_len nlb \\<longrightarrow>\n       finite (dom runz) \\<longrightarrow>\n       runz Rb = Some (Resp, [A, B], []) \\<longrightarrow>\n       rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) x =\n       ((rs_runs2sigs runz)\n        (Commit [B, Sv] (Kab, A, rsl) :=\n           Suc (card (rs_commit runz A B Kab rsl))))\n        x", "apply (rule rs_runs2sigs.induct, auto dest: dom_lemmas)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>rsl = take rs_len nlb; finite (dom runz);\n        runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Rba.\n                           Rba \\<noteq> Rb \\<longrightarrow>\n                           (\\<exists>nlba.\n                               runz Rba =\n                               Some (Resp, [A, B], aKey Kab # nlba) \\<and>\n                               take rs_len nlba = take rs_len nlb)} =\n                         Suc (card\n                               (rs_commit runz A B Kab (take rs_len nlb)))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>rsl = take rs_len nlb; finite (dom runz);\n        runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Rba.\n                           Rba \\<noteq> Rb \\<longrightarrow>\n                           (\\<exists>nlba.\n                               runz Rba =\n                               Some (Resp, [A, B], aKey Kab # nlba) \\<and>\n                               take rs_len nlba = take rs_len nlb)} =\n                         Suc (card\n                               (rs_commit runz A B Kab (take rs_len nlb)))", "apply (rule_tac s=\"card (insert Rb (rs_commit runz A B Kab (take rs_len nlb)))\" \n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step1 Ra A B) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step1 Ra A B {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step2 Rb A B {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_a0_rs_running:\n  \"{R_a0m1a_rs} \n     (a0n_running [B, Sv] (Kab, A, take rs_len nls)), \n     (m1a_step3 Rs A B Kab nls) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} a0i_running [B, Sv]\n                  (Kab, A,\n                   take rs_len nls), m1a_step3 Rs A B Kab nls {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0n_defs m1a_defs\n         dest: dom_lemmas)"], ["", "lemma PO_m1a_step4_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step4 Ra A B Kab nla) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step4 Ra A B Kab nla {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs m1a_defs)"], ["", "lemma PO_m1a_step5_refines_a0_rs_commit:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [B, Sv] (Kab, A, take rs_len nlb)), \n     (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs \\<inter>\n     UNIV \\<times>\n     m1a_inv0_fin} a0n_commit [B, Sv]\n                    (Kab, A,\n                     take rs_len\n                      nlb), m1a_step5 Rb A B Kab nlb {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0n_defs m1a_defs)"], ["", "lemma PO_m1a_leak_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_leak Rs {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0i_defs m1a_defs)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_a0_rs_trans = \n  PO_m1a_step1_refines_a0_rs_skip PO_m1a_step2_refines_a0_rs_skip\n  PO_m1a_step3_refines_a0_rs_running PO_m1a_step4_refines_a0_rs_skip\n  PO_m1a_step5_refines_a0_rs_commit PO_m1a_leak_refines_a0_rs_skip"], ["", "lemma PO_m1a_refines_init_ra0n [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_rs``(init a0n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R_a0m1a_rs `` init a0n", "by (auto simp add: R_a0m1a_rs_defs a0n_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_ra0n [iff]:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs \\<inter>\n     UNIV \\<times> m1a_inv0_fin} TS.trans a0n, TS.trans m1a {> R_a0m1a_rs}", "by (auto simp add: m1a_def m1a_trans_def a0n_def a0n_trans_def\n         intro!: PO_m1a_trans_refines_a0_rs_trans)"], ["", "lemma obs_consistent_med_a0m1a_rs [iff]: \n  \"obs_consistent (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin)\n     med_a0m1a_rs a0n m1a", "by (auto simp add: obs_consistent_def R_a0m1a_rs_def med_a0m1a_rs_def \n                   a0n_def m1a_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_a0_rs [iff]: \n  \"refines (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin) med_a0m1a_rs\n     a0n m1a", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma  m1a_implements_ra0n: \"implements med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0m1a_rs a0n m1a", "by (rule refinement_soundness) (fast)"], ["", "end"]]}