{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Refinement/Message.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemma Un_idem_collapse [simp]: \"A \\<union> (B \\<union> A) = B \\<union> A\"", "lemma parts_mono: \"G \\<subseteq> H ==> parts(G) \\<subseteq> parts(H)\"", "lemma Other_image_eq [simp]: \"(Agent x \\<in> Agent`A) = (x:A)\"", "lemma Key_image_eq [simp]: \"(Key x \\<in> Key`A) = (x\\<in>A)\"", "lemma Nonce_Key_image_eq [simp]: \"(Nonce x \\<notin> Key`A)\"", "lemma keysFor_empty [simp]: \"keysFor {} = {}\"", "lemma keysFor_Un [simp]: \"keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'\"", "lemma keysFor_UN [simp]: \"keysFor (\\<Union>i\\<in>A. H i) = (\\<Union>i\\<in>A. keysFor (H i))\"", "lemma keysFor_mono: \"G \\<subseteq> H ==> keysFor(G) \\<subseteq> keysFor(H)\"", "lemma keysFor_insert_Agent [simp]: \"keysFor (insert (Agent A) H) = keysFor H\"", "lemma keysFor_insert_Nonce [simp]: \"keysFor (insert (Nonce N) H) = keysFor H\"", "lemma keysFor_insert_Number [simp]: \"keysFor (insert (Number N) H) = keysFor H\"", "lemma keysFor_insert_Key [simp]: \"keysFor (insert (Key K) H) = keysFor H\"", "lemma keysFor_insert_Hash [simp]: \"keysFor (insert (Hash X) H) = keysFor H\"", "lemma keysFor_insert_MPair [simp]: \"keysFor (insert \\<lbrace>X,Y\\<rbrace> H) = keysFor H\"", "lemma keysFor_insert_Crypt [simp]:\n    \"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)\"", "lemma keysFor_image_Key [simp]: \"keysFor (Key`E) = {}\"", "lemma Crypt_imp_invKey_keysFor: \"Crypt K X \\<in> H ==> invKey K \\<in> keysFor H\"", "lemma MPair_parts:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> parts H;\n         [| X \\<in> parts H; Y \\<in> parts H |] ==> P |] ==> P\"", "lemma parts_increasing: \"H \\<subseteq> parts(H)\"", "lemmas parts_insertI = subset_insertI [THEN parts_mono, THEN subsetD]", "lemma parts_empty [simp]: \"parts{} = {}\"", "lemma parts_emptyE [elim!]: \"X\\<in> parts{} ==> P\"", "lemma parts_singleton: \"X\\<in> parts H ==> \\<exists>Y\\<in>H. X\\<in> parts {Y}\"", "lemma parts_Un_subset1: \"parts(G) \\<union> parts(H) \\<subseteq> parts(G \\<union> H)\"", "lemma parts_Un_subset2: \"parts(G \\<union> H) \\<subseteq> parts(G) \\<union> parts(H)\"", "lemma parts_Un [simp]: \"parts(G \\<union> H) = parts(G) \\<union> parts(H)\"", "lemma parts_insert: \"parts (insert X H) = parts {X} \\<union> parts H\"", "lemma parts_insert2:\n     \"parts (insert X (insert Y H)) = parts {X} \\<union> parts {Y} \\<union> parts H\"", "lemma parts_UN_subset1: \"(\\<Union>x\\<in>A. parts(H x)) \\<subseteq> parts(\\<Union>x\\<in>A. H x)\"", "lemma parts_UN_subset2: \"parts(\\<Union>x\\<in>A. H x) \\<subseteq> (\\<Union>x\\<in>A. parts(H x))\"", "lemma parts_UN [simp]: \"parts(\\<Union>x\\<in>A. H x) = (\\<Union>x\\<in>A. parts(H x))\"", "lemmas in_parts_UnE = parts_Un [THEN equalityD1, THEN subsetD, THEN UnE]", "lemma parts_insert_subset: \"insert X (parts H) \\<subseteq> parts(insert X H)\"", "lemma parts_partsD [dest!]: \"X\\<in> parts (parts H) ==> X\\<in> parts H\"", "lemma parts_idem [simp]: \"parts (parts H) = parts H\"", "lemma parts_subset_iff [simp]: \"(parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)\"", "lemma parts_trans: \"[| X\\<in> parts G;  G \\<subseteq> parts H |] ==> X\\<in> parts H\"", "lemma parts_cut:\n     \"[| Y\\<in> parts (insert X G);  X\\<in> parts H |] ==> Y\\<in> parts (G \\<union> H)\"", "lemma parts_cut_eq [simp]: \"X\\<in> parts H ==> parts (insert X H) = parts H\"", "lemmas parts_insert_eq_I = equalityI [OF subsetI parts_insert_subset]", "lemma parts_insert_Agent [simp]:\n     \"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)\"", "lemma parts_insert_Nonce [simp]:\n     \"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)\"", "lemma parts_insert_Number [simp]:\n     \"parts (insert (Number N) H) = insert (Number N) (parts H)\"", "lemma parts_insert_Key [simp]:\n     \"parts (insert (Key K) H) = insert (Key K) (parts H)\"", "lemma parts_insert_Hash [simp]:\n     \"parts (insert (Hash X) H) = insert (Hash X) (parts H)\"", "lemma parts_insert_Crypt [simp]:\n     \"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))\"", "lemma parts_insert_MPair [simp]:\n     \"parts (insert \\<lbrace>X,Y\\<rbrace> H) =\n          insert \\<lbrace>X,Y\\<rbrace> (parts (insert X (insert Y H)))\"", "lemma parts_image_Key [simp]: \"parts (Key`N) = Key`N\"", "lemma analz_mono: \"G\\<subseteq>H ==> analz(G) \\<subseteq> analz(H)\"", "lemmas analz_monotonic = analz_mono [THEN [2] rev_subsetD]", "lemma MPair_analz [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> analz H;\n             [| X \\<in> analz H; Y \\<in> analz H |] ==> P\n          |] ==> P\"", "lemma analz_increasing: \"H \\<subseteq> analz(H)\"", "lemma analz_subset_parts: \"analz H \\<subseteq> parts H\"", "lemmas analz_into_parts = analz_subset_parts [THEN subsetD]", "lemmas not_parts_not_analz = analz_subset_parts [THEN contra_subsetD]", "lemma parts_analz [simp]: \"parts (analz H) = parts H\"", "lemma analz_parts [simp]: \"analz (parts H) = parts H\"", "lemmas analz_insertI = subset_insertI [THEN analz_mono, THEN [2] rev_subsetD]", "lemma analz_empty [simp]: \"analz{} = {}\"", "lemma analz_Un: \"analz(G) \\<union> analz(H) \\<subseteq> analz(G \\<union> H)\"", "lemma analz_insert: \"insert X (analz H) \\<subseteq> analz(insert X H)\"", "lemmas analz_insert_eq_I = equalityI [OF subsetI analz_insert]", "lemma analz_insert_Agent [simp]:\n     \"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)\"", "lemma analz_insert_Nonce [simp]:\n     \"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)\"", "lemma analz_insert_Number [simp]:\n     \"analz (insert (Number N) H) = insert (Number N) (analz H)\"", "lemma analz_insert_Hash [simp]:\n     \"analz (insert (Hash X) H) = insert (Hash X) (analz H)\"", "lemma analz_insert_Key [simp]:\n    \"K \\<notin> keysFor (analz H) ==>\n          analz (insert (Key K) H) = insert (Key K) (analz H)\"", "lemma analz_insert_MPair [simp]:\n     \"analz (insert \\<lbrace>X,Y\\<rbrace> H) =\n          insert \\<lbrace>X,Y\\<rbrace> (analz (insert X (insert Y H)))\"", "lemma analz_insert_Crypt:\n     \"Key (invKey K) \\<notin> analz H\n      ==> analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)\"", "lemma lemma1: \"Key (invKey K) \\<in> analz H ==>\n               analz (insert (Crypt K X) H) \\<subseteq>\n               insert (Crypt K X) (analz (insert X H))\"", "lemma lemma2: \"Key (invKey K) \\<in> analz H ==>\n               insert (Crypt K X) (analz (insert X H)) \\<subseteq>\n               analz (insert (Crypt K X) H)\"", "lemma analz_insert_Decrypt:\n     \"Key (invKey K) \\<in> analz H ==>\n               analz (insert (Crypt K X) H) =\n               insert (Crypt K X) (analz (insert X H))\"", "lemma analz_Crypt_if [simp]:\n     \"analz (insert (Crypt K X) H) =\n          (if (Key (invKey K) \\<in> analz H)\n           then insert (Crypt K X) (analz (insert X H))\n           else insert (Crypt K X) (analz H))\"", "lemma analz_insert_Crypt_subset:\n     \"analz (insert (Crypt K X) H) \\<subseteq>\n           insert (Crypt K X) (analz (insert X H))\"", "lemma analz_image_Key [simp]: \"analz (Key`N) = Key`N\"", "lemma analz_analzD [dest!]: \"X\\<in> analz (analz H) ==> X\\<in> analz H\"", "lemma analz_idem [simp]: \"analz (analz H) = analz H\"", "lemma analz_subset_iff [simp]: \"(analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)\"", "lemma analz_trans: \"[| X\\<in> analz G;  G \\<subseteq> analz H |] ==> X\\<in> analz H\"", "lemma analz_cut: \"[| Y\\<in> analz (insert X H);  X\\<in> analz H |] ==> Y\\<in> analz H\"", "lemma analz_insert_eq: \"X\\<in> analz H ==> analz (insert X H) = analz H\"", "lemma analz_subset_cong:\n     \"[| analz G \\<subseteq> analz G'; analz H \\<subseteq> analz H' |]\n      ==> analz (G \\<union> H) \\<subseteq> analz (G' \\<union> H')\"", "lemma analz_cong:\n     \"[| analz G = analz G'; analz H = analz H' |]\n      ==> analz (G \\<union> H) = analz (G' \\<union> H')\"", "lemma analz_insert_cong:\n     \"analz H = analz H' ==> analz(insert X H) = analz(insert X H')\"", "lemma analz_trivial:\n     \"[| \\<forall>X Y. \\<lbrace>X,Y\\<rbrace> \\<notin> H;  \\<forall>X K. Crypt K X \\<notin> H |] ==> analz H = H\"", "lemma analz_UN_analz_lemma:\n     \"X\\<in> analz (\\<Union>i\\<in>A. analz (H i)) ==> X\\<in> analz (\\<Union>i\\<in>A. H i)\"", "lemma analz_UN_analz [simp]: \"analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union>i\\<in>A. H i)\"", "lemma synth_mono: \"G\\<subseteq>H ==> synth(G) \\<subseteq> synth(H)\"", "lemma synth_increasing: \"H \\<subseteq> synth(H)\"", "lemma synth_Un: \"synth(G) \\<union> synth(H) \\<subseteq> synth(G \\<union> H)\"", "lemma synth_insert: \"insert X (synth H) \\<subseteq> synth(insert X H)\"", "lemma synth_synthD [dest!]: \"X\\<in> synth (synth H) ==> X\\<in> synth H\"", "lemma synth_idem: \"synth (synth H) = synth H\"", "lemma synth_subset_iff [simp]: \"(synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)\"", "lemma synth_trans: \"[| X\\<in> synth G;  G \\<subseteq> synth H |] ==> X\\<in> synth H\"", "lemma synth_cut: \"[| Y\\<in> synth (insert X H);  X\\<in> synth H |] ==> Y\\<in> synth H\"", "lemma Agent_synth [simp]: \"Agent A \\<in> synth H\"", "lemma Number_synth [simp]: \"Number n \\<in> synth H\"", "lemma Nonce_synth_eq [simp]: \"(Nonce N \\<in> synth H) = (Nonce N \\<in> H)\"", "lemma Key_synth_eq [simp]: \"(Key K \\<in> synth H) = (Key K \\<in> H)\"", "lemma Crypt_synth_eq [simp]:\n     \"Key K \\<notin> H ==> (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)\"", "lemma keysFor_synth [simp]:\n    \"keysFor (synth H) = keysFor H \\<union> invKey`{K. Key K \\<in> H}\"", "lemma parts_synth [simp]: \"parts (synth H) = parts H \\<union> synth H\"", "lemma analz_analz_Un [simp]: \"analz (analz G \\<union> H) = analz (G \\<union> H)\"", "lemma analz_synth_Un [simp]: \"analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G\"", "lemma analz_synth [simp]: \"analz (synth H) = analz H \\<union> synth H\"", "lemma analz_Un_analz [simp]: \"analz (G \\<union> analz H) = analz (G \\<union> H)\"", "lemma analz_synth_Un2 [simp]: \"analz (G \\<union> synth H) = analz (G \\<union> H) \\<union> synth H\"", "lemma parts_insert_subset_Un: \"X\\<in> G ==> parts(insert X H) \\<subseteq> parts G \\<union> parts H\"", "lemma Fake_parts_insert:\n     \"X \\<in> synth (analz H) ==>\n      parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H\"", "lemma Fake_parts_insert_in_Un:\n     \"[|Z \\<in> parts (insert X H);  X \\<in> synth (analz H)|]\n      ==> Z \\<in>  synth (analz H) \\<union> parts H\"", "lemma Fake_analz_insert:\n     \"X\\<in> synth (analz G) ==>\n      analz (insert X H) \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)\"", "lemma analz_conj_parts [simp]:\n     \"(X \\<in> analz H & X \\<in> parts H) = (X \\<in> analz H)\"", "lemma analz_disj_parts [simp]:\n     \"(X \\<in> analz H | X \\<in> parts H) = (X \\<in> parts H)\"", "lemma MPair_synth_analz [iff]:\n     \"(\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) =\n      (X \\<in> synth (analz H) & Y \\<in> synth (analz H))\"", "lemma Crypt_synth_analz:\n     \"[| Key K \\<in> analz H;  Key (invKey K) \\<in> analz H |]\n       ==> (Crypt K X \\<in> synth (analz H)) = (X \\<in> synth (analz H))\"", "lemma Hash_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)\n      ==> (Hash\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) = (Hash\\<lbrace>X,Y\\<rbrace> \\<in> analz H)\"", "lemma Agent_neq_HPair: \"Agent A ~= Hash[X] Y\"", "lemma Nonce_neq_HPair: \"Nonce N ~= Hash[X] Y\"", "lemma Number_neq_HPair: \"Number N ~= Hash[X] Y\"", "lemma Key_neq_HPair: \"Key K ~= Hash[X] Y\"", "lemma Hash_neq_HPair: \"Hash Z ~= Hash[X] Y\"", "lemma Crypt_neq_HPair: \"Crypt K X' ~= Hash[X] Y\"", "lemmas HPair_neqs = Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair\n                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair", "lemma HPair_eq [iff]: \"(Hash[X'] Y' = Hash[X] Y) = (X' = X & Y'=Y)\"", "lemma MPair_eq_HPair [iff]:\n     \"(\\<lbrace>X',Y'\\<rbrace> = Hash[X] Y) = (X' = Hash\\<lbrace>X,Y\\<rbrace> & Y'=Y)\"", "lemma HPair_eq_MPair [iff]:\n     \"(Hash[X] Y = \\<lbrace>X',Y'\\<rbrace>) = (X' = Hash\\<lbrace>X,Y\\<rbrace> & Y'=Y)\"", "lemma keysFor_insert_HPair [simp]: \"keysFor (insert (Hash[X] Y) H) = keysFor H\"", "lemma parts_insert_HPair [simp]:\n    \"parts (insert (Hash[X] Y) H) =\n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (parts (insert Y H)))\"", "lemma analz_insert_HPair [simp]:\n    \"analz (insert (Hash[X] Y) H) =\n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (analz (insert Y H)))\"", "lemma HPair_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)\n    ==> (Hash[X] Y \\<in> synth (analz H)) =\n        (Hash\\<lbrace>X, Y\\<rbrace> \\<in> analz H & Y \\<in> synth (analz H))\"", "lemmas pushKeys =\n  insert_commute [of \"Key K\" \"Agent C\" for K C]\n  insert_commute [of \"Key K\" \"Nonce N\" for K N]\n  insert_commute [of \"Key K\" \"Number N\" for K N]\n  insert_commute [of \"Key K\" \"Hash X\" for K X]\n  insert_commute [of \"Key K\" \"MPair X Y\" for K X Y]\n  insert_commute [of \"Key K\" \"Crypt X K'\" for K K' X]", "lemmas pushCrypts =\n  insert_commute [of \"Crypt X K\" \"Agent C\" for X K C]\n  insert_commute [of \"Crypt X K\" \"Agent C\" for X K C]\n  insert_commute [of \"Crypt X K\" \"Nonce N\" for X K N]\n  insert_commute [of \"Crypt X K\" \"Number N\"  for X K N]\n  insert_commute [of \"Crypt X K\" \"Hash X'\"  for X K X']\n  insert_commute [of \"Crypt X K\" \"MPair X' Y\"  for X K X' Y]", "lemmas pushes = pushKeys pushCrypts", "lemma Crypt_notin_image_Key [simp]: \"Crypt K X \\<notin> Key ` A\"", "lemma Hash_notin_image_Key [simp] :\"Hash X \\<notin> Key ` A\"", "lemma synth_analz_mono: \"G\\<subseteq>H ==> synth (analz(G)) \\<subseteq> synth (analz(H))\"", "lemma Fake_analz_eq [simp]:\n     \"X \\<in> synth(analz H) ==> synth (analz (insert X H)) = synth (analz H)\"", "lemma gen_analz_insert_eq [rule_format]:\n     \"X \\<in> analz H ==> ALL G. H \\<subseteq> G --> analz (insert X G) = analz G\"", "lemma synth_analz_insert_eq [rule_format]:\n     \"X \\<in> synth (analz H)\n      ==> ALL G. H \\<subseteq> G --> (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\"", "lemma Fake_parts_sing:\n     \"X \\<in> synth (analz H) ==> parts{X} \\<subseteq> synth (analz H) \\<union> parts H\"", "lemmas Fake_parts_sing_imp_Un = Fake_parts_sing [THEN [2] rev_subsetD]"], "translations": [["", "lemma Un_idem_collapse [simp]: \"A \\<union> (B \\<union> A) = B \\<union> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> (B \\<union> A) = B \\<union> A", "by blast"], ["", "datatype\n     msg = Agent  agent     \\<comment> \\<open>Agent names\\<close>\n         | Number nat       \\<comment> \\<open>Ordinary integers, timestamps, ...\\<close>\n         | Nonce  nonce     \\<comment> \\<open>Unguessable nonces\\<close>\n         | Key    key       \\<comment> \\<open>Crypto keys\\<close>\n         | Hash   msg       \\<comment> \\<open>Hashing\\<close>\n         | MPair  msg msg   \\<comment> \\<open>Compound messages\\<close>\n         | Crypt  key msg   \\<comment> \\<open>Encryption, public- or shared-key\\<close>"], ["", "text\\<open>Concrete syntax: messages appear as \\<open>\\<lbrace>A,B,NA\\<rbrace>\\<close>, etc...\\<close>"], ["", "syntax\n  \"_MTuple\"      :: \"['a, args] => 'a * 'b\"       (\"(2\\<lbrace>_,/ _\\<rbrace>)\")"], ["", "translations\n  \"\\<lbrace>x, y, z\\<rbrace>\"   == \"\\<lbrace>x, \\<lbrace>y, z\\<rbrace>\\<rbrace>\"\n  \"\\<lbrace>x, y\\<rbrace>\"      == \"CONST MPair x y\""], ["", "definition\n  HPair :: \"[msg,msg] \\<Rightarrow> msg\"                       (\"(4Hash[_] /_)\" [0, 1000])\nwhere\n  \\<comment> \\<open>Message Y paired with a MAC computed with the help of X\\<close>\n  \"Hash[X] Y \\<equiv> \\<lbrace>Hash\\<lbrace>X,Y\\<rbrace>, Y\\<rbrace>\""], ["", "definition\n  keysFor :: \"msg set \\<Rightarrow> key set\"\nwhere\n    \\<comment> \\<open>Keys useful to decrypt elements of a message set\\<close>\n  \"keysFor H \\<equiv> invKey ` {K. \\<exists>X. Crypt K X \\<in> H}\""], ["", "subsubsection\\<open>Inductive Definition of All Parts\" of a Message\\<close>"], ["", "inductive_set\n  parts :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj [intro]:               \"X \\<in> H ==> X \\<in> parts H\"\n  | Fst:         \"\\<lbrace>X,Y\\<rbrace>   \\<in> parts H ==> X \\<in> parts H\"\n  | Snd:         \"\\<lbrace>X,Y\\<rbrace>   \\<in> parts H ==> Y \\<in> parts H\"\n  | Body:        \"Crypt K X \\<in> parts H ==> X \\<in> parts H\""], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma parts_mono: \"G \\<subseteq> H ==> parts(G) \\<subseteq> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> parts G \\<subseteq> parts H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H; x \\<in> parts G\\<rbrakk>\n       \\<Longrightarrow> x \\<in> parts H", "apply (erule parts.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>G \\<subseteq> H; X \\<in> G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H\n 2. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> parts G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H\n 3. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> parts G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> parts H\n 4. \\<And>x K X.\n       \\<lbrakk>G \\<subseteq> H; Crypt K X \\<in> parts G;\n        Crypt K X \\<in> parts H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H", "apply (blast dest: parts.Fst parts.Snd parts.Body)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Equations hold because constructors are injective.\\<close>"], ["", "lemma Other_image_eq [simp]: \"(Agent x \\<in> Agent`A) = (x:A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (msg.Agent x \\<in> msg.Agent ` A) = (x \\<in> A)", "by auto"], ["", "lemma Key_image_eq [simp]: \"(Key x \\<in> Key`A) = (x\\<in>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Key x \\<in> Key ` A) = (x \\<in> A)", "by auto"], ["", "lemma Nonce_Key_image_eq [simp]: \"(Nonce x \\<notin> Key`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce x \\<notin> Key ` A", "by auto"], ["", "subsection\\<open>keysFor operator\\<close>"], ["", "lemma keysFor_empty [simp]: \"keysFor {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor {} = {}", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_Un [simp]: \"keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (H \\<union> H') = keysFor H \\<union> keysFor H'", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_UN [simp]: \"keysFor (\\<Union>i\\<in>A. H i) = (\\<Union>i\\<in>A. keysFor (H i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (\\<Union> (H ` A)) = (\\<Union>i\\<in>A. keysFor (H i))", "by (unfold keysFor_def, blast)"], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma keysFor_mono: \"G \\<subseteq> H ==> keysFor(G) \\<subseteq> keysFor(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> keysFor G \\<subseteq> keysFor H", "by (unfold keysFor_def, blast)"], ["", "lemma keysFor_insert_Agent [simp]: \"keysFor (insert (Agent A) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (msg.Agent A) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Nonce [simp]: \"keysFor (insert (Nonce N) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Nonce N) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Number [simp]: \"keysFor (insert (Number N) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Number N) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Key [simp]: \"keysFor (insert (Key K) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Key K) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Hash [simp]: \"keysFor (insert (Hash X) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Hash X) H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_MPair [simp]: \"keysFor (insert \\<lbrace>X,Y\\<rbrace> H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert \\<lbrace>X, Y\\<rbrace> H) = keysFor H", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_insert_Crypt [simp]:\n    \"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)", "by (unfold keysFor_def, auto)"], ["", "lemma keysFor_image_Key [simp]: \"keysFor (Key`E) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (Key ` E) = {}", "by (unfold keysFor_def, auto)"], ["", "lemma Crypt_imp_invKey_keysFor: \"Crypt K X \\<in> H ==> invKey K \\<in> keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<in> H \\<Longrightarrow> invKey K \\<in> keysFor H", "by (unfold keysFor_def, blast)"], ["", "subsection\\<open>Inductive relation \"parts\"\\<close>"], ["", "lemma MPair_parts:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> parts H;\n         [| X \\<in> parts H; Y \\<in> parts H |] ==> P |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts H;\n     \\<lbrakk>X \\<in> parts H; Y \\<in> parts H\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (blast dest: parts.Fst parts.Snd)"], ["", "declare MPair_parts [elim!]  parts.Body [dest!]"], ["", "text\\<open>NB These two rules are UNSAFE in the formal sense, as they discard the\n     compound message.  They work well on THIS FILE.\n  \\<open>MPair_parts\\<close> is left as SAFE because it speeds up proofs.\n  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.\\<close>"], ["", "lemma parts_increasing: \"H \\<subseteq> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> parts H", "by blast"], ["", "lemmas parts_insertI = subset_insertI [THEN parts_mono, THEN subsetD]"], ["", "lemma parts_empty [simp]: \"parts{} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts {} = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> parts {} \\<Longrightarrow> x \\<in> {}", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_emptyE [elim!]: \"X\\<in> parts{} ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts {} \\<Longrightarrow> P", "by simp"], ["", "text\\<open>WARNING: loops if H = {Y}, therefore must not be repeated!\\<close>"], ["", "lemma parts_singleton: \"X\\<in> parts H ==> \\<exists>Y\\<in>H. X\\<in> parts {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts H \\<Longrightarrow> \\<exists>Y\\<in>H. X \\<in> parts {Y}", "by (erule parts.induct, fast+)"], ["", "subsubsection\\<open>Unions\\<close>"], ["", "lemma parts_Un_subset1: \"parts(G) \\<union> parts(H) \\<subseteq> parts(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts G \\<union> parts H \\<subseteq> parts (G \\<union> H)", "by (intro Un_least parts_mono Un_upper1 Un_upper2)"], ["", "lemma parts_Un_subset2: \"parts(G \\<union> H) \\<subseteq> parts(G) \\<union> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (G \\<union> H) \\<subseteq> parts G \\<union> parts H", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (G \\<union> H) \\<Longrightarrow>\n       x \\<in> parts G \\<union> parts H", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_Un [simp]: \"parts(G \\<union> H) = parts(G) \\<union> parts(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (G \\<union> H) = parts G \\<union> parts H", "by (intro equalityI parts_Un_subset1 parts_Un_subset2)"], ["", "lemma parts_insert: \"parts (insert X H) = parts {X} \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X H) = parts {X} \\<union> parts H", "apply (subst insert_is_Un [of _ H])"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts ({X} \\<union> H) = parts {X} \\<union> parts H", "apply (simp only: parts_Un)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>TWO inserts to avoid looping.  This rewrite is better than nothing.\n  Not suitable for Addsimps: its behaviour can be strange.\\<close>"], ["", "lemma parts_insert2:\n     \"parts (insert X (insert Y H)) = parts {X} \\<union> parts {Y} \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X (insert Y H)) =\n    parts {X} \\<union> parts {Y} \\<union> parts H", "apply (simp add: Un_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X (insert Y H)) =\n    parts {X} \\<union> (parts {Y} \\<union> parts H)", "apply (simp add: parts_insert [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_UN_subset1: \"(\\<Union>x\\<in>A. parts(H x)) \\<subseteq> parts(\\<Union>x\\<in>A. H x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. parts (H x)) \\<subseteq> parts (\\<Union> (H ` A))", "by (intro UN_least parts_mono UN_upper)"], ["", "lemma parts_UN_subset2: \"parts(\\<Union>x\\<in>A. H x) \\<subseteq> (\\<Union>x\\<in>A. parts(H x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (\\<Union> (H ` A)) \\<subseteq> (\\<Union>x\\<in>A. parts (H x))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (\\<Union> (H ` A)) \\<Longrightarrow>\n       x \\<in> (\\<Union>x\\<in>A. parts (H x))", "apply (erule parts.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_UN [simp]: \"parts(\\<Union>x\\<in>A. H x) = (\\<Union>x\\<in>A. parts(H x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (\\<Union> (H ` A)) = (\\<Union>x\\<in>A. parts (H x))", "by (intro equalityI parts_UN_subset1 parts_UN_subset2)"], ["", "text\\<open>Added to simplify arguments to parts, analz and synth.\n  NOTE: the UN versions are no longer used!\\<close>"], ["", "text\\<open>This allows \\<open>blast\\<close> to simplify occurrences of\n  @{term \"parts(G\\<union>H)\"} in the assumption.\\<close>"], ["", "lemmas in_parts_UnE = parts_Un [THEN equalityD1, THEN subsetD, THEN UnE]"], ["", "declare in_parts_UnE [elim!]"], ["", "lemma parts_insert_subset: \"insert X (parts H) \\<subseteq> parts(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (parts H) \\<subseteq> parts (insert X H)", "by (blast intro: parts_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma parts_partsD [dest!]: \"X\\<in> parts (parts H) ==> X\\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (parts H) \\<Longrightarrow> X \\<in> parts H", "by (erule parts.induct, blast+)"], ["", "lemma parts_idem [simp]: \"parts (parts H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (parts H) = parts H", "by blast"], ["", "lemma parts_subset_iff [simp]: \"(parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (parts G \\<subseteq> parts H) = (G \\<subseteq> parts H)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts G \\<subseteq> parts H \\<Longrightarrow> G \\<subseteq> parts H\n 2. G \\<subseteq> parts H \\<Longrightarrow> parts G \\<subseteq> parts H", "apply (iprover intro: subset_trans parts_increasing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> parts H \\<Longrightarrow> parts G \\<subseteq> parts H", "apply (frule parts_mono, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_trans: \"[| X\\<in> parts G;  G \\<subseteq> parts H |] ==> X\\<in> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> parts G; G \\<subseteq> parts H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> parts H", "by (drule parts_mono, blast)"], ["", "text\\<open>Cut\\<close>"], ["", "lemma parts_cut:\n     \"[| Y\\<in> parts (insert X G);  X\\<in> parts H |] ==> Y\\<in> parts (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> parts (insert X G); X \\<in> parts H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> parts (G \\<union> H)", "by (blast intro: parts_trans)"], ["", "lemma parts_cut_eq [simp]: \"X\\<in> parts H ==> parts (insert X H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts H \\<Longrightarrow> parts (insert X H) = parts H", "by (force dest!: parts_cut intro: parts_insertI)"], ["", "subsubsection\\<open>Rewrite rules for pulling out atomic messages\\<close>"], ["", "lemmas parts_insert_eq_I = equalityI [OF subsetI parts_insert_subset]"], ["", "lemma parts_insert_Agent [simp]:\n     \"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (msg.Agent agt) H) = insert (msg.Agent agt) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (msg.Agent agt) H) \\<Longrightarrow>\n       x \\<in> insert (msg.Agent agt) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Nonce [simp]:\n     \"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Nonce N) H) = insert (Nonce N) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Nonce N) H) \\<Longrightarrow>\n       x \\<in> insert (Nonce N) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Number [simp]:\n     \"parts (insert (Number N) H) = insert (Number N) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Number N) H) = insert (Number N) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Number N) H) \\<Longrightarrow>\n       x \\<in> insert (Number N) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Key [simp]:\n     \"parts (insert (Key K) H) = insert (Key K) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Key K) H) = insert (Key K) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Key K) H) \\<Longrightarrow>\n       x \\<in> insert (Key K) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Hash [simp]:\n     \"parts (insert (Hash X) H) = insert (Hash X) (parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Hash X) H) = insert (Hash X) (parts H)", "apply (rule parts_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> parts (insert (Hash X) H) \\<Longrightarrow>\n       x \\<in> insert (Hash X) (parts H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_Crypt [simp]:\n     \"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (parts (insert X H))\n 2. insert (Crypt K X) (parts (insert X H))\n    \\<subseteq> parts (insert (Crypt K X) H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (insert (Crypt K X) H) \\<Longrightarrow>\n       x \\<in> insert (Crypt K X) (parts (insert X H))\n 2. insert (Crypt K X) (parts (insert X H))\n    \\<subseteq> parts (insert (Crypt K X) H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> parts (insert (Crypt K X) H)", "apply (blast intro: parts.Body)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_insert_MPair [simp]:\n     \"parts (insert \\<lbrace>X,Y\\<rbrace> H) =\n          insert \\<lbrace>X,Y\\<rbrace> (parts (insert X (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert \\<lbrace>X, Y\\<rbrace> H) =\n    insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (insert \\<lbrace>X, Y\\<rbrace> H)\n    \\<subseteq> insert \\<lbrace>X, Y\\<rbrace>\n                 (parts (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n    \\<subseteq> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H) \\<Longrightarrow>\n       x \\<in> insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (parts (insert X (insert Y H)))\n    \\<subseteq> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H)\n 2. Y \\<in> parts (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (blast intro: parts.Fst parts.Snd)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_image_Key [simp]: \"parts (Key`N) = Key`N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (Key ` N) = Key ` N", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> parts (Key ` N) \\<Longrightarrow> x \\<in> Key ` N", "apply (erule parts.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>In any message, there is an upper bound N on its greatest nonce.\\<close>"], ["", "(*\nlemma msg_Nonce_supply: \"\\<exists>N. \\<forall>n. N\\<le>n --> Nonce n \\<notin> parts {msg}\"\napply (induct msg)\napply (simp_all (no_asm_simp) add: exI parts_insert2)\n txt{*MPair case: blast works out the necessary sum itself!*}\n prefer 2 apply auto apply (blast elim!: add_leE)\ntxt{*Nonce case*}\napply (rule_tac x = \"N + Suc nat\" in exI, auto)\ndone\n*)"], ["", "subsection\\<open>Inductive relation \"analz\"\\<close>"], ["", "text\\<open>Inductive definition of \"analz\" -- what can be broken down from a set of\n    messages, including keys.  A form of downward closure.  Pairs can\n    be taken apart; messages decrypted with known keys.\\<close>"], ["", "inductive_set\n  analz :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj [intro,simp] :    \"X \\<in> H ==> X \\<in> analz H\"\n  | Fst:     \"\\<lbrace>X,Y\\<rbrace> \\<in> analz H ==> X \\<in> analz H\"\n  | Snd:     \"\\<lbrace>X,Y\\<rbrace> \\<in> analz H ==> Y \\<in> analz H\"\n  | Decrypt [dest]:\n             \"[|Crypt K X \\<in> analz H; Key(invKey K): analz H|] ==> X \\<in> analz H\""], ["", "text\\<open>Monotonicity; Lemma 1 of Lowe's paper\\<close>"], ["", "lemma analz_mono: \"G\\<subseteq>H ==> analz(G) \\<subseteq> analz(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> analz G \\<subseteq> analz H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>G \\<subseteq> H; x \\<in> analz G\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz H", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>G \\<subseteq> H; X \\<in> G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H\n 2. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> analz G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H\n 3. \\<And>x X Y.\n       \\<lbrakk>G \\<subseteq> H; \\<lbrace>X, Y\\<rbrace> \\<in> analz G;\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz H\n 4. \\<And>x K X.\n       \\<lbrakk>G \\<subseteq> H; Crypt K X \\<in> analz G;\n        Crypt K X \\<in> analz H; Key (invKey K) \\<in> analz G;\n        Key (invKey K) \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz H", "apply (auto dest: analz.Fst analz.Snd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_monotonic = analz_mono [THEN [2] rev_subsetD]"], ["", "text\\<open>Making it safe speeds up proofs\\<close>"], ["", "lemma MPair_analz [elim!]:\n     \"[| \\<lbrace>X,Y\\<rbrace> \\<in> analz H;\n             [| X \\<in> analz H; Y \\<in> analz H |] ==> P\n          |] ==> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz H;\n     \\<lbrakk>X \\<in> analz H; Y \\<in> analz H\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (blast dest: analz.Fst analz.Snd)"], ["", "lemma analz_increasing: \"H \\<subseteq> analz(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> analz H", "by blast"], ["", "lemma analz_subset_parts: \"analz H \\<subseteq> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz H \\<subseteq> parts H", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz H \\<Longrightarrow> x \\<in> parts H", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_into_parts = analz_subset_parts [THEN subsetD]"], ["", "lemmas not_parts_not_analz = analz_subset_parts [THEN contra_subsetD]"], ["", "lemma parts_analz [simp]: \"parts (analz H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (analz H) = parts H", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (analz H) \\<subseteq> parts H\n 2. parts H \\<subseteq> parts (analz H)", "apply (rule analz_subset_parts [THEN parts_mono, THEN subset_trans], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts H \\<subseteq> parts (analz H)", "apply (blast intro: analz_increasing [THEN parts_mono, THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_parts [simp]: \"analz (parts H) = parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (parts H) = parts H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz (parts H) \\<Longrightarrow> x \\<in> parts H", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas analz_insertI = subset_insertI [THEN analz_mono, THEN [2] rev_subsetD]"], ["", "subsubsection\\<open>General equational properties\\<close>"], ["", "lemma analz_empty [simp]: \"analz{} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz {} = {}", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz {} \\<Longrightarrow> x \\<in> {}", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Converse fails: we can analz more from the union than from the\n  separate parts, as a key in one might decrypt a message in the other\\<close>"], ["", "lemma analz_Un: \"analz(G) \\<union> analz(H) \\<subseteq> analz(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz G \\<union> analz H \\<subseteq> analz (G \\<union> H)", "by (intro Un_least analz_mono Un_upper1 Un_upper2)"], ["", "lemma analz_insert: \"insert X (analz H) \\<subseteq> analz(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (analz H) \\<subseteq> analz (insert X H)", "by (blast intro: analz_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Rewrite rules for pulling out atomic messages\\<close>"], ["", "lemmas analz_insert_eq_I = equalityI [OF subsetI analz_insert]"], ["", "lemma analz_insert_Agent [simp]:\n     \"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (msg.Agent agt) H) = insert (msg.Agent agt) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (msg.Agent agt) H) \\<Longrightarrow>\n       x \\<in> insert (msg.Agent agt) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Nonce [simp]:\n     \"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Nonce N) H) = insert (Nonce N) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Nonce N) H) \\<Longrightarrow>\n       x \\<in> insert (Nonce N) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Number [simp]:\n     \"analz (insert (Number N) H) = insert (Number N) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Number N) H) = insert (Number N) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Number N) H) \\<Longrightarrow>\n       x \\<in> insert (Number N) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Hash [simp]:\n     \"analz (insert (Hash X) H) = insert (Hash X) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Hash X) H) = insert (Hash X) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Hash X) H) \\<Longrightarrow>\n       x \\<in> insert (Hash X) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Can only pull out Keys if they are not needed to decrypt the rest\\<close>"], ["", "lemma analz_insert_Key [simp]:\n    \"K \\<notin> keysFor (analz H) ==>\n          analz (insert (Key K) H) = insert (Key K) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<notin> keysFor (analz H) \\<Longrightarrow>\n    analz (insert (Key K) H) = insert (Key K) (analz H)", "apply (unfold keysFor_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<notin> invKey `\n               {K. \\<exists>X. Crypt K X \\<in> analz H} \\<Longrightarrow>\n    analz (insert (Key K) H) = insert (Key K) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>K \\<notin> invKey `\n                           {K. \\<exists>X. Crypt K X \\<in> analz H};\n        x \\<in> analz (insert (Key K) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Key K) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_MPair [simp]:\n     \"analz (insert \\<lbrace>X,Y\\<rbrace> H) =\n          insert \\<lbrace>X,Y\\<rbrace> (analz (insert X (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert \\<lbrace>X, Y\\<rbrace> H) =\n    insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz (insert \\<lbrace>X, Y\\<rbrace> H)\n    \\<subseteq> insert \\<lbrace>X, Y\\<rbrace>\n                 (analz (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n    \\<subseteq> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H) \\<Longrightarrow>\n       x \\<in> insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n 2. insert \\<lbrace>X, Y\\<rbrace> (analz (insert X (insert Y H)))\n    \\<subseteq> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert X (insert Y H)) \\<Longrightarrow>\n       x \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x Xa.\n       Xa \\<in> insert X (insert Y H) \\<Longrightarrow>\n       Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 2. \\<And>x Xa Ya.\n       \\<lbrakk>\\<lbrace>Xa, Ya\\<rbrace>\n                \\<in> analz (insert X (insert Y H));\n        \\<lbrace>Xa, Ya\\<rbrace>\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 3. \\<And>x Xa Ya.\n       \\<lbrakk>\\<lbrace>Xa, Ya\\<rbrace>\n                \\<in> analz (insert X (insert Y H));\n        \\<lbrace>Xa, Ya\\<rbrace>\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Ya \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\n 4. \\<And>x K Xa.\n       \\<lbrakk>Crypt K Xa \\<in> analz (insert X (insert Y H));\n        Crypt K Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H);\n        Key (invKey K) \\<in> analz (insert X (insert Y H));\n        Key (invKey K)\n        \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)\\<rbrakk>\n       \\<Longrightarrow> Xa \\<in> analz (insert \\<lbrace>X, Y\\<rbrace> H)", "apply (blast intro: analz.Fst analz.Snd)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Can pull out enCrypted message if the Key is not known\\<close>"], ["", "lemma analz_insert_Crypt:\n     \"Key (invKey K) \\<notin> analz H\n      ==> analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<notin> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)", "apply (rule analz_insert_eq_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<notin> analz H;\n        x \\<in> analz (insert (Crypt K X) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Crypt K X) (analz H)", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lemma1: \"Key (invKey K) \\<in> analz H ==>\n               analz (insert (Crypt K X) H) \\<subseteq>\n               insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (analz (insert X H))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<in> analz H;\n        x \\<in> analz (insert (Crypt K X) H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> insert (Crypt K X) (analz (insert X H))", "apply (erule_tac x = x in analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lemma2: \"Key (invKey K) \\<in> analz H ==>\n               insert (Crypt K X) (analz (insert X H)) \\<subseteq>\n               analz (insert (Crypt K X) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    insert (Crypt K X) (analz (insert X H))\n    \\<subseteq> analz (insert (Crypt K X) H)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Key (invKey K) \\<in> analz H;\n        x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz (insert (Crypt K X) H)", "apply (erule_tac x = x in analz.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    X \\<in> analz (insert (Crypt K X) H)", "apply (blast intro: analz_insertI analz.Decrypt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_insert_Decrypt:\n     \"Key (invKey K) \\<in> analz H ==>\n               analz (insert (Crypt K X) H) =\n               insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (invKey K) \\<in> analz H \\<Longrightarrow>\n    analz (insert (Crypt K X) H) = insert (Crypt K X) (analz (insert X H))", "by (intro equalityI lemma1 lemma2)"], ["", "text\\<open>Case analysis: either the message is secure, or it is not! Effective,\nbut can cause subgoals to blow up! Use with \\<open>split_if\\<close>; apparently\n\\<open>split_tac\\<close> does not cope with patterns such as @{term\"analz (insert\n(Crypt K X) H)\"}\\<close>"], ["", "lemma analz_Crypt_if [simp]:\n     \"analz (insert (Crypt K X) H) =\n          (if (Key (invKey K) \\<in> analz H)\n           then insert (Crypt K X) (analz (insert X H))\n           else insert (Crypt K X) (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Crypt K X) H) =\n    (if Key (invKey K) \\<in> analz H\n     then insert (Crypt K X) (analz (insert X H))\n     else insert (Crypt K X) (analz H))", "by (simp add: analz_insert_Crypt analz_insert_Decrypt)"], ["", "text\\<open>This rule supposes \"for the sake of argument\" that we have the key.\\<close>"], ["", "lemma analz_insert_Crypt_subset:\n     \"analz (insert (Crypt K X) H) \\<subseteq>\n           insert (Crypt K X) (analz (insert X H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert (Crypt K X) H)\n    \\<subseteq> insert (Crypt K X) (analz (insert X H))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (insert (Crypt K X) H) \\<Longrightarrow>\n       x \\<in> insert (Crypt K X) (analz (insert X H))", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_image_Key [simp]: \"analz (Key`N) = Key`N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (Key ` N) = Key ` N", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> analz (Key ` N) \\<Longrightarrow> x \\<in> Key ` N", "apply (erule analz.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma analz_analzD [dest!]: \"X\\<in> analz (analz H) ==> X\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz (analz H) \\<Longrightarrow> X \\<in> analz H", "by (erule analz.induct, blast+)"], ["", "lemma analz_idem [simp]: \"analz (analz H) = analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (analz H) = analz H", "by blast"], ["", "lemma analz_subset_iff [simp]: \"(analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (analz G \\<subseteq> analz H) = (G \\<subseteq> analz H)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz G \\<subseteq> analz H \\<Longrightarrow> G \\<subseteq> analz H\n 2. G \\<subseteq> analz H \\<Longrightarrow> analz G \\<subseteq> analz H", "apply (iprover intro: subset_trans analz_increasing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> analz H \\<Longrightarrow> analz G \\<subseteq> analz H", "apply (frule analz_mono, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_trans: \"[| X\\<in> analz G;  G \\<subseteq> analz H |] ==> X\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> analz G; G \\<subseteq> analz H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> analz H", "by (drule analz_mono, blast)"], ["", "text\\<open>Cut; Lemma 2 of Lowe\\<close>"], ["", "lemma analz_cut: \"[| Y\\<in> analz (insert X H);  X\\<in> analz H |] ==> Y\\<in> analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> analz (insert X H); X \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> analz H", "by (erule analz_trans, blast)"], ["", "(*Cut can be proved easily by induction on\n   \"Y: analz (insert X H) ==> X: analz H --> Y: analz H\"\n*)"], ["", "text\\<open>This rewrite rule helps in the simplification of messages that involve\n  the forwarding of unknown components (X).  Without it, removing occurrences\n  of X can be very complicated.\\<close>"], ["", "lemma analz_insert_eq: \"X\\<in> analz H ==> analz (insert X H) = analz H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz H \\<Longrightarrow> analz (insert X H) = analz H", "by (blast intro: analz_cut analz_insertI)"], ["", "text\\<open>A congruence rule for \"analz\"\\<close>"], ["", "lemma analz_subset_cong:\n     \"[| analz G \\<subseteq> analz G'; analz H \\<subseteq> analz H' |]\n      ==> analz (G \\<union> H) \\<subseteq> analz (G' \\<union> H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz G \\<subseteq> analz G';\n     analz H \\<subseteq> analz H'\\<rbrakk>\n    \\<Longrightarrow> analz (G \\<union> H)\n                      \\<subseteq> analz (G' \\<union> H')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<subseteq> analz G'; H \\<subseteq> analz H'\\<rbrakk>\n    \\<Longrightarrow> G \\<subseteq> analz (G' \\<union> H') \\<and>\n                      H \\<subseteq> analz (G' \\<union> H')", "apply (iprover intro: conjI subset_trans analz_mono Un_upper1 Un_upper2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_cong:\n     \"[| analz G = analz G'; analz H = analz H' |]\n      ==> analz (G \\<union> H) = analz (G' \\<union> H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz G = analz G'; analz H = analz H'\\<rbrakk>\n    \\<Longrightarrow> analz (G \\<union> H) = analz (G' \\<union> H')", "by (intro equalityI analz_subset_cong, simp_all)"], ["", "lemma analz_insert_cong:\n     \"analz H = analz H' ==> analz(insert X H) = analz(insert X H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz H = analz H' \\<Longrightarrow>\n    analz (insert X H) = analz (insert X H')", "by (force simp only: insert_def intro!: analz_cong)"], ["", "text\\<open>If there are no pairs or encryptions then analz does nothing\\<close>"], ["", "lemma analz_trivial:\n     \"[| \\<forall>X Y. \\<lbrace>X,Y\\<rbrace> \\<notin> H;  \\<forall>X K. Crypt K X \\<notin> H |] ==> analz H = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n     \\<forall>X K. Crypt K X \\<notin> H\\<rbrakk>\n    \\<Longrightarrow> analz H = H", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n        \\<forall>X K. Crypt K X \\<notin> H; x \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> x \\<in> H\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>X Y. \\<lbrace>X, Y\\<rbrace> \\<notin> H;\n        \\<forall>X K. Crypt K X \\<notin> H; x \\<in> H\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz H", "apply (erule analz.induct, blast+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>These two are obsolete (with a single Spy) but cost little to prove...\\<close>"], ["", "lemma analz_UN_analz_lemma:\n     \"X\\<in> analz (\\<Union>i\\<in>A. analz (H i)) ==> X\\<in> analz (\\<Union>i\\<in>A. H i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz (\\<Union>i\\<in>A. analz (H i)) \\<Longrightarrow>\n    X \\<in> analz (\\<Union> (H ` A))", "apply (erule analz.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X.\n       X \\<in> (\\<Union>i\\<in>A. analz (H i)) \\<Longrightarrow>\n       X \\<in> analz (\\<Union> (H ` A))\n 2. \\<And>X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace>\n                \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (\\<Union> (H ` A))\n 3. \\<And>X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace>\n                \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        \\<lbrace>X, Y\\<rbrace> \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (\\<Union> (H ` A))\n 4. \\<And>K X.\n       \\<lbrakk>Crypt K X \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        Crypt K X \\<in> analz (\\<Union> (H ` A));\n        Key (invKey K) \\<in> analz (\\<Union>i\\<in>A. analz (H i));\n        Key (invKey K) \\<in> analz (\\<Union> (H ` A))\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (\\<Union> (H ` A))", "apply (blast intro: analz_mono [THEN [2] rev_subsetD])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_UN_analz [simp]: \"analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union>i\\<in>A. H i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (\\<Union>i\\<in>A. analz (H i)) = analz (\\<Union> (H ` A))", "by (blast intro: analz_UN_analz_lemma analz_mono [THEN [2] rev_subsetD])"], ["", "subsection\\<open>Inductive relation \"synth\"\\<close>"], ["", "text\\<open>Inductive definition of \"synth\" -- what can be built up from a set of\n    messages.  A form of upward closure.  Pairs can be built, messages\n    encrypted with known keys.  Agent names are public domain.\n    Numbers can be guessed, but Nonces cannot be.\\<close>"], ["", "inductive_set\n  synth :: \"msg set => msg set\"\n  for H :: \"msg set\"\n  where\n    Inj    [intro]:   \"X \\<in> H ==> X \\<in> synth H\"\n  | Agent  [intro]:   \"Agent agt \\<in> synth H\"\n  | Number [intro]:   \"Number n  \\<in> synth H\"\n  | Hash   [intro]:   \"X \\<in> synth H ==> Hash X \\<in> synth H\"\n  | MPair  [intro]:   \"[|X \\<in> synth H;  Y \\<in> synth H|] ==> \\<lbrace>X,Y\\<rbrace> \\<in> synth H\"\n  | Crypt  [intro]:   \"[|X \\<in> synth H;  Key(K) \\<in> H|] ==> Crypt K X \\<in> synth H\""], ["", "text\\<open>Monotonicity\\<close>"], ["", "lemma synth_mono: \"G\\<subseteq>H ==> synth(G) \\<subseteq> synth(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> synth G \\<subseteq> synth H", "by (auto, erule synth.induct, auto)"], ["", "text\\<open>NO \\<open>Agent_synth\\<close>, as any Agent name can be synthesized.\n  The same holds for @{term Number}\\<close>"], ["", "inductive_cases Nonce_synth [elim!]: \"Nonce n \\<in> synth H\""], ["", "inductive_cases Key_synth   [elim!]: \"Key K \\<in> synth H\""], ["", "inductive_cases Hash_synth  [elim!]: \"Hash X \\<in> synth H\""], ["", "inductive_cases MPair_synth [elim!]: \"\\<lbrace>X,Y\\<rbrace> \\<in> synth H\""], ["", "inductive_cases Crypt_synth [elim!]: \"Crypt K X \\<in> synth H\""], ["", "lemma synth_increasing: \"H \\<subseteq> synth(H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> synth H", "by blast"], ["", "subsubsection\\<open>Unions\\<close>"], ["", "text\\<open>Converse fails: we can synth more from the union than from the\n  separate parts, building a compound message using elements of each.\\<close>"], ["", "lemma synth_Un: \"synth(G) \\<union> synth(H) \\<subseteq> synth(G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth G \\<union> synth H \\<subseteq> synth (G \\<union> H)", "by (intro Un_least synth_mono Un_upper1 Un_upper2)"], ["", "lemma synth_insert: \"insert X (synth H) \\<subseteq> synth(insert X H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert X (synth H) \\<subseteq> synth (insert X H)", "by (blast intro: synth_mono [THEN [2] rev_subsetD])"], ["", "subsubsection\\<open>Idempotence and transitivity\\<close>"], ["", "lemma synth_synthD [dest!]: \"X\\<in> synth (synth H) ==> X\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (synth H) \\<Longrightarrow> X \\<in> synth H", "by (erule synth.induct, blast+)"], ["", "lemma synth_idem: \"synth (synth H) = synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (synth H) = synth H", "by blast"], ["", "lemma synth_subset_iff [simp]: \"(synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (synth G \\<subseteq> synth H) = (G \\<subseteq> synth H)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. synth G \\<subseteq> synth H \\<Longrightarrow> G \\<subseteq> synth H\n 2. G \\<subseteq> synth H \\<Longrightarrow> synth G \\<subseteq> synth H", "apply (iprover intro: subset_trans synth_increasing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> synth H \\<Longrightarrow> synth G \\<subseteq> synth H", "apply (frule synth_mono, simp add: synth_idem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma synth_trans: \"[| X\\<in> synth G;  G \\<subseteq> synth H |] ==> X\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> synth G; G \\<subseteq> synth H\\<rbrakk>\n    \\<Longrightarrow> X \\<in> synth H", "by (drule synth_mono, blast)"], ["", "text\\<open>Cut; Lemma 2 of Lowe\\<close>"], ["", "lemma synth_cut: \"[| Y\\<in> synth (insert X H);  X\\<in> synth H |] ==> Y\\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Y \\<in> synth (insert X H); X \\<in> synth H\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> synth H", "by (erule synth_trans, blast)"], ["", "lemma Agent_synth [simp]: \"Agent A \\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg.Agent A \\<in> synth H", "by blast"], ["", "lemma Number_synth [simp]: \"Number n \\<in> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Number n \\<in> synth H", "by blast"], ["", "lemma Nonce_synth_eq [simp]: \"(Nonce N \\<in> synth H) = (Nonce N \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Nonce N \\<in> synth H) = (Nonce N \\<in> H)", "by blast"], ["", "lemma Key_synth_eq [simp]: \"(Key K \\<in> synth H) = (Key K \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Key K \\<in> synth H) = (Key K \\<in> H)", "by blast"], ["", "lemma Crypt_synth_eq [simp]:\n     \"Key K \\<notin> H ==> (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<notin> H \\<Longrightarrow>\n    (Crypt K X \\<in> synth H) = (Crypt K X \\<in> H)", "by blast"], ["", "lemma keysFor_synth [simp]:\n    \"keysFor (synth H) = keysFor H \\<union> invKey`{K. Key K \\<in> H}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (synth H) = keysFor H \\<union> invKey ` {K. Key K \\<in> H}", "by (unfold keysFor_def, blast)"], ["", "subsubsection\\<open>Combinations of parts, analz and synth\\<close>"], ["", "lemma parts_synth [simp]: \"parts (synth H) = parts H \\<union> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (synth H) = parts H \\<union> synth H", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. parts (synth H) \\<subseteq> parts H \\<union> synth H\n 2. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> parts (synth H) \\<Longrightarrow>\n       x \\<in> parts H \\<union> synth H\n 2. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (erule parts.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth H \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts (synth H);\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> parts (synth H);\n        \\<lbrace>X, Y\\<rbrace> \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> parts H \\<union> synth H\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> parts (synth H);\n        Crypt K X \\<in> parts H \\<union> synth H\\<rbrakk>\n       \\<Longrightarrow> X \\<in> parts H \\<union> synth H\n 5. parts H \\<union> synth H \\<subseteq> parts (synth H)", "apply (blast intro: synth_increasing [THEN parts_mono, THEN subsetD]\n                    parts.Fst parts.Snd parts.Body)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_analz_Un [simp]: \"analz (analz G \\<union> H) = analz (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (analz G \\<union> H) = analz (G \\<union> H)", "apply (intro equalityI analz_subset_cong)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. analz (analz G) \\<subseteq> analz G\n 2. analz H \\<subseteq> analz H\n 3. analz G \\<subseteq> analz (analz G)\n 4. analz H \\<subseteq> analz H", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_synth_Un [simp]: \"analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (synth G \\<union> H) = analz (G \\<union> H) \\<union> synth G", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz (synth G \\<union> H)\n    \\<subseteq> analz (G \\<union> H) \\<union> synth G\n 2. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> analz (synth G \\<union> H) \\<Longrightarrow>\n       x \\<in> analz (G \\<union> H) \\<union> synth G\n 2. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "apply (erule analz.induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 5. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. analz (G \\<union> H) \\<union> synth G\n    \\<subseteq> analz (synth G \\<union> H)\n 2. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 5. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G", "apply (blast intro: analz_mono [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x X.\n       X \\<in> synth G \\<union> H \\<Longrightarrow>\n       X \\<in> analz (G \\<union> H) \\<union> synth G\n 2. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G\n 3. \\<And>x X Y.\n       \\<lbrakk>\\<lbrace>X, Y\\<rbrace> \\<in> analz (synth G \\<union> H);\n        \\<lbrace>X, Y\\<rbrace>\n        \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz (G \\<union> H) \\<union> synth G\n 4. \\<And>x K X.\n       \\<lbrakk>Crypt K X \\<in> analz (synth G \\<union> H);\n        Crypt K X \\<in> analz (G \\<union> H) \\<union> synth G;\n        Key (invKey K) \\<in> analz (synth G \\<union> H);\n        Key (invKey K) \\<in> analz (G \\<union> H) \\<union> synth G\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz (G \\<union> H) \\<union> synth G", "apply (blast intro: analz.Fst analz.Snd analz.Decrypt)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_synth [simp]: \"analz (synth H) = analz H \\<union> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (synth H) = analz H \\<union> synth H", "apply (cut_tac H = \"{}\" in analz_synth_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (synth ?G \\<union> {}) =\n    analz (?G \\<union> {}) \\<union> synth ?G \\<Longrightarrow>\n    analz (synth H) = analz H \\<union> synth H", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>chsp: added\\<close>"], ["", "lemma analz_Un_analz [simp]: \"analz (G \\<union> analz H) = analz (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (G \\<union> analz H) = analz (G \\<union> H)", "by (subst Un_commute, auto)+"], ["", "lemma analz_synth_Un2 [simp]: \"analz (G \\<union> synth H) = analz (G \\<union> H) \\<union> synth H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (G \\<union> synth H) = analz (G \\<union> H) \\<union> synth H", "by (subst Un_commute, auto)+"], ["", "subsubsection\\<open>For reasoning about the Fake rule in traces\\<close>"], ["", "lemma parts_insert_subset_Un: \"X\\<in> G ==> parts(insert X H) \\<subseteq> parts G \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> G \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> parts G \\<union> parts H", "by (rule subset_trans [OF parts_mono parts_Un_subset2], blast)"], ["", "text\\<open>More specifically for Fake.  Very occasionally we could do with a version\n  of the form  @{term\"parts{X} \\<subseteq> synth (analz H) \\<union> parts H\"}\\<close>"], ["", "lemma Fake_parts_insert:\n     \"X \\<in> synth (analz H) ==>\n      parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H", "apply (drule parts_insert_subset_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X ?H)\n    \\<subseteq> parts (synth (analz H)) \\<union> parts ?H \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert X ?H)\n    \\<subseteq> parts H \\<union> synth (analz H) \\<union>\n                parts ?H \\<Longrightarrow>\n    parts (insert X H) \\<subseteq> synth (analz H) \\<union> parts H", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fake_parts_insert_in_Un:\n     \"[|Z \\<in> parts (insert X H);  X \\<in> synth (analz H)|]\n      ==> Z \\<in>  synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z \\<in> parts (insert X H); X \\<in> synth (analz H)\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> synth (analz H) \\<union> parts H", "by (blast dest: Fake_parts_insert  [THEN subsetD, dest])"], ["", "text\\<open>@{term H} is sometimes @{term\"Key ` KK \\<union> spies evs\"}, so can't put\n  @{term \"G=H\"}.\\<close>"], ["", "lemma Fake_analz_insert:\n     \"X\\<in> synth (analz G) ==>\n      analz (insert X H) \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz G) \\<Longrightarrow>\n    analz (insert X H)\n    \\<subseteq> synth (analz G) \\<union> analz (G \\<union> H)", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<union>\n                                 analz (G \\<union> H)", "apply (subgoal_tac \"x \\<in> analz (synth (analz G) \\<union> H) \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H);\n        x \\<in> analz (synth (analz G) \\<union> H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<union>\n                                 analz (G \\<union> H)\n 2. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz (synth (analz G) \\<union> H)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> analz (synth (analz G) \\<union> H)\n 2. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H);\n        x \\<in> analz (synth (analz G) \\<union> H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<union>\n                                 analz (G \\<union> H)", "apply (blast intro: analz_mono [THEN [2] rev_subsetD]\n                      analz_mono [THEN synth_mono, THEN [2] rev_subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H);\n        x \\<in> analz (synth (analz G) \\<union> H)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<union>\n                                 analz (G \\<union> H)", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<in> synth (analz G); x \\<in> analz (insert X H);\n        x \\<in> analz (G \\<union> H) \\<or> x \\<in> synth (analz G)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> synth (analz G) \\<or>\n                         x \\<in> analz (G \\<union> H)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_conj_parts [simp]:\n     \"(X \\<in> analz H & X \\<in> parts H) = (X \\<in> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> analz H \\<and> X \\<in> parts H) = (X \\<in> analz H)", "by (blast intro: analz_subset_parts [THEN subsetD])"], ["", "lemma analz_disj_parts [simp]:\n     \"(X \\<in> analz H | X \\<in> parts H) = (X \\<in> parts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> analz H \\<or> X \\<in> parts H) = (X \\<in> parts H)", "by (blast intro: analz_subset_parts [THEN subsetD])"], ["", "text\\<open>Without this equation, other rules for synth and analz would yield\n  redundant cases\\<close>"], ["", "lemma MPair_synth_analz [iff]:\n     \"(\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) =\n      (X \\<in> synth (analz H) & Y \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrace>X, Y\\<rbrace> \\<in> synth (analz H)) =\n    (X \\<in> synth (analz H) \\<and> Y \\<in> synth (analz H))", "by blast"], ["", "lemma Crypt_synth_analz:\n     \"[| Key K \\<in> analz H;  Key (invKey K) \\<in> analz H |]\n       ==> (Crypt K X \\<in> synth (analz H)) = (X \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Key K \\<in> analz H; Key (invKey K) \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> (Crypt K X \\<in> synth (analz H)) =\n                      (X \\<in> synth (analz H))", "by blast"], ["", "lemma Hash_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)\n      ==> (Hash\\<lbrace>X,Y\\<rbrace> \\<in> synth (analz H)) = (Hash\\<lbrace>X,Y\\<rbrace> \\<in> analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> synth (analz H) \\<Longrightarrow>\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> synth (analz H)) =\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H)", "by blast"], ["", "subsection\\<open>HPair: a combination of Hash and MPair\\<close>"], ["", "subsubsection\\<open>Freeness\\<close>"], ["", "lemma Agent_neq_HPair: \"Agent A ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg.Agent A \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Nonce_neq_HPair: \"Nonce N ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nonce N \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Number_neq_HPair: \"Number N ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Number N \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Key_neq_HPair: \"Key K ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key K \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Hash_neq_HPair: \"Hash Z ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hash Z \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemma Crypt_neq_HPair: \"Crypt K X' ~= Hash[X] Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X' \\<noteq> Hash[X] Y", "by (unfold HPair_def, simp)"], ["", "lemmas HPair_neqs = Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair\n                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair"], ["", "declare HPair_neqs [iff]"], ["", "declare HPair_neqs [symmetric, iff]"], ["", "lemma HPair_eq [iff]: \"(Hash[X'] Y' = Hash[X] Y) = (X' = X & Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Hash[X'] Y' = Hash[X] Y) = (X' = X \\<and> Y' = Y)", "by (simp add: HPair_def)"], ["", "lemma MPair_eq_HPair [iff]:\n     \"(\\<lbrace>X',Y'\\<rbrace> = Hash[X] Y) = (X' = Hash\\<lbrace>X,Y\\<rbrace> & Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrace>X', Y'\\<rbrace> = Hash[X] Y) =\n    (X' = Hash \\<lbrace>X, Y\\<rbrace> \\<and> Y' = Y)", "by (simp add: HPair_def)"], ["", "lemma HPair_eq_MPair [iff]:\n     \"(Hash[X] Y = \\<lbrace>X',Y'\\<rbrace>) = (X' = Hash\\<lbrace>X,Y\\<rbrace> & Y'=Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Hash[X] Y = \\<lbrace>X', Y'\\<rbrace>) =\n    (X' = Hash \\<lbrace>X, Y\\<rbrace> \\<and> Y' = Y)", "by (auto simp add: HPair_def)"], ["", "subsubsection\\<open>Specialized laws, proved in terms of those for Hash and MPair\\<close>"], ["", "lemma keysFor_insert_HPair [simp]: \"keysFor (insert (Hash[X] Y) H) = keysFor H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keysFor (insert Hash[X] Y H) = keysFor H", "by (simp add: HPair_def)"], ["", "lemma parts_insert_HPair [simp]:\n    \"parts (insert (Hash[X] Y) H) =\n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (parts (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (insert Hash[X] Y H) =\n    insert Hash[X] Y\n     (insert (Hash \\<lbrace>X, Y\\<rbrace>) (parts (insert Y H)))", "by (simp add: HPair_def)"], ["", "lemma analz_insert_HPair [simp]:\n    \"analz (insert (Hash[X] Y) H) =\n     insert (Hash[X] Y) (insert (Hash\\<lbrace>X,Y\\<rbrace>) (analz (insert Y H)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert Hash[X] Y H) =\n    insert Hash[X] Y\n     (insert (Hash \\<lbrace>X, Y\\<rbrace>) (analz (insert Y H)))", "by (simp add: HPair_def)"], ["", "lemma HPair_synth_analz [simp]:\n     \"X \\<notin> synth (analz H)\n    ==> (Hash[X] Y \\<in> synth (analz H)) =\n        (Hash\\<lbrace>X, Y\\<rbrace> \\<in> analz H & Y \\<in> synth (analz H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<notin> synth (analz H) \\<Longrightarrow>\n    (Hash[X] Y \\<in> synth (analz H)) =\n    (Hash \\<lbrace>X, Y\\<rbrace> \\<in> analz H \\<and>\n     Y \\<in> synth (analz H))", "by (simp add: HPair_def)"], ["", "text\\<open>We do NOT want Crypt... messages broken up in protocols!!\\<close>"], ["", "declare parts.Body [rule del]"], ["", "text\\<open>Rewrites to push in Key and Crypt messages, so that other messages can\n    be pulled out using the \\<open>analz_insert\\<close> rules\\<close>"], ["", "lemmas pushKeys =\n  insert_commute [of \"Key K\" \"Agent C\" for K C]\n  insert_commute [of \"Key K\" \"Nonce N\" for K N]\n  insert_commute [of \"Key K\" \"Number N\" for K N]\n  insert_commute [of \"Key K\" \"Hash X\" for K X]\n  insert_commute [of \"Key K\" \"MPair X Y\" for K X Y]\n  insert_commute [of \"Key K\" \"Crypt X K'\" for K K' X]"], ["", "lemmas pushCrypts =\n  insert_commute [of \"Crypt X K\" \"Agent C\" for X K C]\n  insert_commute [of \"Crypt X K\" \"Agent C\" for X K C]\n  insert_commute [of \"Crypt X K\" \"Nonce N\" for X K N]\n  insert_commute [of \"Crypt X K\" \"Number N\"  for X K N]\n  insert_commute [of \"Crypt X K\" \"Hash X'\"  for X K X']\n  insert_commute [of \"Crypt X K\" \"MPair X' Y\"  for X K X' Y]"], ["", "text\\<open>Cannot be added with \\<open>[simp]\\<close> -- messages should not always be\n  re-ordered.\\<close>"], ["", "lemmas pushes = pushKeys pushCrypts"], ["", "text\\<open>By default only \\<open>o_apply\\<close> is built-in.  But in the presence of\neta-expansion this means that some terms displayed as @{term \"f o g\"} will be\nrewritten, and others will not!\\<close>"], ["", "declare o_def [simp]"], ["", "lemma Crypt_notin_image_Key [simp]: \"Crypt K X \\<notin> Key ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K X \\<notin> Key ` A", "by auto"], ["", "lemma Hash_notin_image_Key [simp] :\"Hash X \\<notin> Key ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hash X \\<notin> Key ` A", "by auto"], ["", "lemma synth_analz_mono: \"G\\<subseteq>H ==> synth (analz(G)) \\<subseteq> synth (analz(H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    synth (analz G) \\<subseteq> synth (analz H)", "by (iprover intro: synth_mono analz_mono)"], ["", "lemma Fake_analz_eq [simp]:\n     \"X \\<in> synth(analz H) ==> synth (analz (insert X H)) = synth (analz H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "apply (drule Fake_analz_insert[of _ _ \"H\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert X H)\n    \\<subseteq> synth (analz H) \\<union>\n                analz (H \\<union> H) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "apply (simp add: synth_increasing[THEN Un_absorb2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert X H) \\<subseteq> synth (analz H) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "apply (drule synth_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (insert X H))\n    \\<subseteq> synth (synth (analz H)) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "apply (simp add: synth_idem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert X H) \\<subseteq> synth (analz H) \\<Longrightarrow>\n    synth (analz (insert X H)) = synth (analz H)", "apply (rule equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. analz (insert X H) \\<subseteq> synth (analz H) \\<Longrightarrow>\n    synth (analz (insert X H)) \\<subseteq> synth (analz H)\n 2. analz (insert X H) \\<subseteq> synth (analz H) \\<Longrightarrow>\n    synth (analz H) \\<subseteq> synth (analz (insert X H))", "apply (simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (insert X H) \\<subseteq> synth (analz H) \\<Longrightarrow>\n    synth (analz H) \\<subseteq> synth (analz (insert X H))", "apply (rule synth_analz_mono, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Two generalizations of \\<open>analz_insert_eq\\<close>\\<close>"], ["", "lemma gen_analz_insert_eq [rule_format]:\n     \"X \\<in> analz H ==> ALL G. H \\<subseteq> G --> analz (insert X G) = analz G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> analz H \\<Longrightarrow>\n    \\<forall>G.\n       H \\<subseteq> G \\<longrightarrow> analz (insert X G) = analz G", "by (blast intro: analz_cut analz_insertI analz_mono [THEN [2] rev_subsetD])"], ["", "lemma synth_analz_insert_eq [rule_format]:\n     \"X \\<in> synth (analz H)\n      ==> ALL G. H \\<subseteq> G --> (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    \\<forall>G.\n       H \\<subseteq> G \\<longrightarrow>\n       (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)", "apply (erule synth.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> analz H \\<Longrightarrow>\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\n 2. \\<And>agt.\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert (msg.Agent agt) G)) =\n          (Key K \\<in> analz G)\n 3. \\<And>n.\n       \\<forall>G.\n          H \\<subseteq> G \\<longrightarrow>\n          (Key K \\<in> analz (insert (Number n) G)) = (Key K \\<in> analz G)\n 4. \\<And>X.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K \\<in> analz (insert (Hash X) G)) =\n                            (Key K \\<in> analz G)\n 5. \\<And>X Y.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G);\n        Y \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert Y G)) = (Key K \\<in> analz G)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K\n                             \\<in> analz\n                                    (insert \\<lbrace>X, Y\\<rbrace> G)) =\n                            (Key K \\<in> analz G)\n 6. \\<And>X Ka.\n       \\<lbrakk>X \\<in> synth (analz H);\n        \\<forall>G.\n           H \\<subseteq> G \\<longrightarrow>\n           (Key K \\<in> analz (insert X G)) = (Key K \\<in> analz G);\n        Key Ka \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> \\<forall>G.\n                            H \\<subseteq> G \\<longrightarrow>\n                            (Key K \\<in> analz (insert (Crypt Ka X) G)) =\n                            (Key K \\<in> analz G)", "apply (simp_all add: gen_analz_insert_eq subset_trans [OF _ subset_insertI])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Fake_parts_sing:\n     \"X \\<in> synth (analz H) ==> parts{X} \\<subseteq> synth (analz H) \\<union> parts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    parts {X} \\<subseteq> synth (analz H) \\<union> parts H", "apply (rule subset_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> synth (analz H) \\<Longrightarrow> parts {X} \\<subseteq> ?B\n 2. X \\<in> synth (analz H) \\<Longrightarrow>\n    ?B \\<subseteq> synth (analz H) \\<union> parts H", "apply (erule_tac [2] Fake_parts_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> synth (analz H) \\<Longrightarrow>\n    parts {X} \\<subseteq> parts (insert X H)", "apply (rule parts_mono, blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas Fake_parts_sing_imp_Un = Fake_parts_sing [THEN [2] rev_subsetD]"], ["", "text\\<open>For some reason, moving this up can make some proofs loop!\\<close>"], ["", "declare invKey_K [simp]"], ["", "end"]]}