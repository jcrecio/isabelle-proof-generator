{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Auth_simple/m1_auth.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m1_defs = \n  m1_def m1_init_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def", "lemmas R01_defs = R01_def med10_def", "lemma runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> runs2sigs runz = (\\<lambda>x. 0)\"", "lemma runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = runs2sigs runz\"", "lemma runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aNon Nb]))) = \n     (runs2sigs runz)(Commit [A, B] (Ra$0, Nb) := 1)\"", "lemma runs2sigs_upd_resp [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aNon Na]))) = \n     (runs2sigs runz)(Running [A, B] (Na, Rb$0) := 1)\"", "lemma PO_m1_step1_refines_skip:\n  \"{R01} \n     Id, (m1_step1 Ra A B Na) \n   {> R01}\"", "lemma PO_m1_step2_refines_a0i_running:\n  \"{R01} \n     (a0i_running [A, B] (Na, Nb)), (m1_step2 Rb A B Na Nb) \n   {> R01}\"", "lemma PO_m1_step3_refines_a0i_commit:\n  \"{R01} \n     (a0i_commit [A, B] (Na, Nb)), (m1_step3 Ra A B Na Nb) \n   {> R01}\"", "lemmas PO_m1_trans_refines_a0i_trans = \n  PO_m1_step1_refines_skip PO_m1_step2_refines_a0i_running\n  PO_m1_step3_refines_a0i_commit", "lemma PO_m1_refines_init_a0i [iff]:\n  \"init m1 \\<subseteq> R01``(init a0i)\"", "lemma PO_m1_refines_trans_a0i [iff]:\n  \"{R01} \n     (trans a0i), (trans m1) \n   {> R01}\"", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R01 med10 a0i m1\"", "lemma PO_m1_refines_a0i:\n  \"refines R01 med10 a0i m1\""], "translations": [["", "lemmas m1_defs = \n  m1_def m1_init_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and responder runs of the current one.\\<close>"], ["", "type_synonym \n  irsig = \"nonce \\<times> nonce\""], ["", "fun\n  runs2sigs :: \"runs_t \\<Rightarrow> irsig signal \\<Rightarrow> nat\"\nwhere\n  \"runs2sigs runz (Commit [A, B] (Ra$0, Nb)) = \n    (if runz Ra = Some (Init, [A, B], [aNon Nb]) then 1 else 0)\"\n\n| \"runs2sigs runz (Running [A, B] (Na, Rb$0)) = \n    (if runz Rb = Some (Resp, [A, B], [aNon Na]) then 1 else 0)\"\n\n| \"runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med10 :: \"m1_obs \\<Rightarrow> irsig a0i_obs\" where\n  \"med10 o1 \\<equiv> \\<lparr> signals = runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R01 :: \"(irsig a0i_state \\<times> m1_state) set\" where\n  \"R01 \\<equiv> {(s, t). signals s = runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R01_defs = R01_def med10_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Basic lemmas\\<close>"], ["", "lemma runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> runs2sigs runz = (\\<lambda>x. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> runs2sigs runz = (\\<lambda>x. 0)", "by (rule ext, erule rev_mp) \n   (rule runs2sigs.induct, auto)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aNon Nb]))) = \n     (runs2sigs runz)(Commit [A, B] (Ra$0, Nb) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aNon Nb]))) =\n    (runs2sigs runz)(Commit [A, B] (Ra $ 0, Nb) := 1)", "by (rule ext, erule rev_mp) \n   (rule runs2sigs.induct, auto)"], ["", "lemma runs2sigs_upd_resp [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aNon Na]))) = \n     (runs2sigs runz)(Running [A, B] (Na, Rb$0) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aNon Na]))) =\n    (runs2sigs runz)(Running [A, B] (Na, Rb $ 0) := 1)", "by (rule ext, (erule rev_mp)+) \n   (rule runs2sigs.induct, auto dest: dom_lemmas)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_skip:\n  \"{R01} \n     Id, (m1_step1 Ra A B Na) \n   {> R01}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01} Id, m1_step1 Ra A B Na {> R01}", "by (auto simp add: PO_rhoare_def R01_defs a0i_defs m1_defs)"], ["", "lemma PO_m1_step2_refines_a0i_running:\n  \"{R01} \n     (a0i_running [A, B] (Na, Nb)), (m1_step2 Rb A B Na Nb) \n   {> R01}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01} a0i_running [A, B] (Na, Nb), m1_step2 Rb A B Na Nb {> R01}", "by (auto simp add: PO_rhoare_defs R01_defs a0i_defs m1_defs dest: dom_lemmas)"], ["", "lemma PO_m1_step3_refines_a0i_commit:\n  \"{R01} \n     (a0i_commit [A, B] (Na, Nb)), (m1_step3 Ra A B Na Nb) \n   {> R01}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01} a0i_commit [A, B] (Na, Nb), m1_step3 Ra A B Na Nb {> R01}", "by (auto simp add: PO_rhoare_defs R01_defs a0i_defs m1_defs)"], ["", "lemmas PO_m1_trans_refines_a0i_trans = \n  PO_m1_step1_refines_skip PO_m1_step2_refines_a0i_running\n  PO_m1_step3_refines_a0i_commit"], ["", "text \\<open>All together now...\\<close>"], ["", "lemma PO_m1_refines_init_a0i [iff]:\n  \"init m1 \\<subseteq> R01``(init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R01 `` init a0i", "by (auto simp add: R01_defs a0i_defs m1_defs)"], ["", "lemma PO_m1_refines_trans_a0i [iff]:\n  \"{R01} \n     (trans a0i), (trans m1) \n   {> R01}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01} TS.trans a0i, TS.trans m1 {> R01}", "by (auto simp add: m1_def m1_trans_def a0i_def a0i_trans_def\n         intro!: PO_m1_trans_refines_a0i_trans)"], ["", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R01 med10 a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01 med10 a0i m1", "by (auto simp add: obs_consistent_def R01_defs a0i_def m1_def)"], ["", "lemma PO_m1_refines_a0i:\n  \"refines R01 med10 a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R01 med10 a0i m1", "by (rule Refinement_basic) (auto)"], ["", "end"]]}