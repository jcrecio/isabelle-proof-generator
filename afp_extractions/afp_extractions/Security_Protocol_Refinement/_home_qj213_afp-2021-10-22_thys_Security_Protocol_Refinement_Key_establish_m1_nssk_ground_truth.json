{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m1_nssk.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m1_loc_defs = \n  m1_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def m1_step4_def m1_step5_def \n  m1_step6_def m1_step7_def m1_leak_def", "lemmas m1_defs = m1_loc_defs m1a_defs", "lemma m1_obs_id [simp]: \"obs m1 = id\"", "lemmas m1_inv0_finI = m1a_inv0_finI", "lemmas m1_inv0_finE = m1a_inv0_finE", "lemmas m1_inv0_finD = m1a_inv0_finD", "lemma PO_m1_inv0_fin_init [iff]:\n  \"init m1 \\<subseteq> m1_inv0_fin\"", "lemma PO_m1_inv0_fin_trans [iff]:\n  \"{m1_inv0_fin} trans m1 {> m1_inv0_fin}\"", "lemma PO_m1_inv0_fin [iff]: \"reach m1 \\<subseteq> m1_inv0_fin\"", "lemmas runs1a1_def = map_runs_def", "lemma knC_runs1a1 [simp]:\n  \"knC (runs1a1 runz) = knC runz\"", "lemmas R1a1_defs = R1a1_def med1a1_def", "lemma PO_m1_step1_refines_m1a_step1:\n  \"{R1a1} \n     (m1a_step1 Ra A B Na), (m1_step1 Ra A B Na) \n   {> R1a1}\"", "lemma PO_m1_step2_refines_m1a_step2:\n  \"{R1a1} \n     (m1a_step2 Rb A B), (m1_step2 Rb A B) \n   {> R1a1}\"", "lemma PO_m1_step3_refines_m1a_step3:\n  \"{R1a1} \n     (m1a_step3 Rs A B Kab Na []), (m1_step3 Rs A B Na Kab)\n   {> R1a1}\"", "lemma PO_m1_step4_refines_m1a_step4:\n  \"{R1a1} \n     (m1a_step4 Ra A B Na Kab []), (m1_step4 Ra A B Na Kab) \n   {> R1a1}\"", "lemma PO_m1_step5_refines_m1a_step5:\n  \"{R1a1} \n     (m1a_step5 Rb A B Kab []), (m1_step5 Rb A B Nb Kab) \n   {> R1a1}\"", "lemma PO_m1_step6_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step6 Ra A B Na Nb Kab) \n   {> R1a1}\"", "lemma PO_m1_step7_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step7 Rb A B Nb Kab) \n   {> R1a1}\"", "lemma PO_m1_leak_refines_m1a_leak:\n  \"{R1a1} \n     (m1a_leak Rs), (m1_leak Rs Ra Rb A B)\n   {> R1a1}\"", "lemmas PO_m1_trans_refines_m1a_trans = \n  PO_m1_step1_refines_m1a_step1 PO_m1_step2_refines_m1a_step2\n  PO_m1_step3_refines_m1a_step3 PO_m1_step4_refines_m1a_step4\n  PO_m1_step5_refines_m1a_step5 PO_m1_step6_refines_m1a_skip \n  PO_m1_step7_refines_m1a_skip PO_m1_leak_refines_m1a_leak", "lemma PO_m1_refines_init_m1a [iff]:\n  \"init m1 \\<subseteq>  R1a1``(init m1a)\"", "lemma PO_m1_refines_trans_m1a [iff]:\n  \"{R1a1} \n     (trans m1a), (trans m1) \n   {> R1a1}\"", "lemma obs_consistent_med1a1 [iff]: \n  \"obs_consistent R1a1 med1a1 m1a m1\"", "lemma PO_m1_refines_m1a [iff]: \n  \"refines R1a1 med1a1 m1a m1\"", "lemma  m1_implements_m1a [iff]: \"implements med1a1 m1a m1\"", "lemmas m1_secrecyI = m1_secrecy_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_secrecyE [elim] = m1_secrecy_def [THEN setc_def_to_elim, rule_format]", "lemma PO_m1_obs_secrecy [iff]: \"oreach m1 \\<subseteq> m1_secrecy\"", "lemma PO_m1_secrecy [iff]: \"reach m1 \\<subseteq> m1_secrecy\"", "lemmas m1_inv2i_servI = m1_inv2i_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv2i_servE [elim] = m1_inv2i_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv2i_servD = m1_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated 2]", "lemma PO_m1_inv2i_serv [iff]: \"reach m1 \\<subseteq> m1_inv2i_serv\"", "lemmas m1_inv2r_servI = m1_inv2r_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv2r_servE [elim] = m1_inv2r_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv2r_servD = m1_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1_inv2r_serv [iff]: \"reach m1 \\<subseteq> m1_inv2r_serv\"", "lemmas m1_inv3_ifreshI = m1_inv3_ifresh_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv3_ifreshE [elim] = m1_inv3_ifresh_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv3_ifreshD = m1_inv3_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1_inv3_ifresh [iff]: \"reach m1 \\<subseteq> m1_inv3_ifresh\"", "lemmas R_a0im1_ir_defs = R_a0im1_ir_def med_a0im1_ir_def", "lemma ir_runs2sigs_empty [simp]: \n   \"runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma finite_ir_commit [simp, intro!]: \n   \"finite (dom runz) \\<Longrightarrow> finite (ir_commit runz A B Kab Nb)\"", "lemma ir_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_serv_none [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) = ir_runs2sigs runz\"", "lemma ir_runs2sigs_upd_resp [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab]))) =\n     (ir_runs2sigs runz)(Running [A, B] (Kab, Rb$nb) := 1)\"", "lemma ir_runs2sigs_upd_init [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb]))) = \n     (ir_runs2sigs runz)\n       (Commit [A, B] (Kab, Nb) := Suc (card (ir_commit runz A B Kab Nb)))\"", "lemma ir_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [aKey K]) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K, END]))) = ir_runs2sigs runz\"", "lemma m1_inv2i_serv_lemma:\n  \"\\<lbrakk> runs t Ra  = Some (Init, [A, B], [aKey Kab, aNon Nb]);\n     runs t Ra' = Some (Init, [A, B], [aKey Kab]); \n     A \\<notin> bad; t \\<in> m1_inv2i_serv \\<rbrakk>\n  \\<Longrightarrow> P\"", "lemma PO_m1_step1_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step2_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step2 Rb A B) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step3_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step3 Rs A B Na Kab) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step4_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step4 Ra A B Na Kab) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step5_refines_ir_a0i_running:\n  \"{R_a0im1_ir} \n     (a0i_running [A, B] (Kab, Nb)), (m1_step5 Rb A B Nb Kab) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step6_refines_ir_a0i_commit:\n  \"{R_a0im1_ir \\<inter> UNIV \\<times> (m1_inv2i_serv \\<inter> m1_inv0_fin)} \n     (a0i_commit [A, B] (Kab, Nb)), (m1_step6 Ra A B Na Nb Kab) \n   {> R_a0im1_ir}\"", "lemma PO_m1_step7_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step7 Rb A B Nb Kab) \n   {> R_a0im1_ir}\"", "lemma PO_m1_leak_refines_ir_a0i_corrupt:\n  \"{R_a0im1_ir} \n     (a0i_corrupt ({sesK (Rs$sk)} \\<times> UNIV)), (m1_leak Rs Ra Rb A B) \n   {> R_a0im1_ir}\"", "lemmas PO_m1_trans_refines_ir_a0i_trans = \n  PO_m1_step1_refines_ir_a0i_skip PO_m1_step2_refines_ir_a0i_skip\n  PO_m1_step3_refines_ir_a0i_skip PO_m1_step4_refines_ir_a0i_skip\n  PO_m1_step5_refines_ir_a0i_running PO_m1_step6_refines_ir_a0i_commit\n  PO_m1_step7_refines_ir_a0i_skip PO_m1_leak_refines_ir_a0i_corrupt", "lemma PO_m1_refines_ir_init_a0i [iff]:\n  \"init m1 \\<subseteq>  R_a0im1_ir``(init a0i)\"", "lemma PO_m1_refines_ir_trans_a0i [iff]:\n  \"{R_a0im1_ir \\<inter> reach a0i \\<times> reach m1} \n     (trans a0i), (trans m1) \n   {> R_a0im1_ir}\"", "lemma obs_consistent_med_a0im1_ir [iff]: \n  \"obs_consistent R_a0im1_ir med_a0im1_ir a0i m1\"", "lemma PO_m1_refines_ir_a0i [iff]: \n  \"refines \n     (R_a0im1_ir \\<inter> reach a0i \\<times> reach m1)\n     med_a0im1_ir a0i m1\"", "lemma  m1_implements_ir_a0i: \"implements med_a0im1_ir a0i m1\"", "lemmas R_a0im1_ri_defs = R_a0im1_ri_def med_a0im1_ri_def", "lemma ri_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma finite_inv_ri_running [simp, intro!]: \n   \"finite (dom runz) \\<Longrightarrow> finite (ri_running runz A B Kab Nb)\"", "lemma ri_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Na \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_serv_none [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_init [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb]))) =\n     (ri_runs2sigs runz)\n       (Running [B, A] (Kab, Nb) := Suc (card (ri_running runz A B Kab Nb)))\"", "lemma ri_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K]))) = ri_runs2sigs runz\"", "lemma ri_runs2sigs_upd_resp_some2 [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [aKey Kab]) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, END]))) = \n     (ri_runs2sigs runz)(Commit [B, A] (Kab, Rb$nb) := 1)\"", "lemma PO_m1_step1_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step2_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step2 Rb A B) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step3_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step3 Rs A B Na Kab) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step4_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step4 Ra A B Nb Kab) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step5_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step5 Rb A B Nb Kab) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step6_refines_ri_a0i_running:\n  \"{R_a0im1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [B, A] (Kab, Nb)), (m1_step6 Ra A B Na Nb Kab) \n   {> R_a0im1_ri}\"", "lemma PO_m1_step7_refines_ri_a0i_commit:\n  \"{R_a0im1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_commit [B, A] (Kab, Nb)), (m1_step7 Rb A B Nb Kab) \n   {> R_a0im1_ri}\"", "lemma PO_m1_leak_refines_ri_a0i_corrupt:\n  \"{R_a0im1_ri} \n     (a0i_corrupt ({sesK (Rs$sk)} \\<times> UNIV)), (m1_leak Rs Ra Rb A B) \n   {> R_a0im1_ri}\"", "lemmas PO_m1_trans_refines_ri_a0i_trans = \n  PO_m1_step1_refines_ri_a0i_skip PO_m1_step2_refines_ri_a0i_skip\n  PO_m1_step3_refines_ri_a0i_skip PO_m1_step4_refines_ri_a0i_skip\n  PO_m1_step5_refines_ri_a0i_skip PO_m1_step6_refines_ri_a0i_running\n  PO_m1_step7_refines_ri_a0i_commit PO_m1_leak_refines_ri_a0i_corrupt", "lemma PO_m1_refines_ri_init_a0i [iff]:\n  \"init m1 \\<subseteq>  R_a0im1_ri``(init a0i)\"", "lemma PO_m1_refines_ri_trans_a0i [iff]:\n  \"{R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin} \n     (trans a0i), (trans m1) \n   {> R_a0im1_ri}\"", "lemma obs_consistent_med_a0im1_ri [iff]: \n  \"obs_consistent R_a0im1_ri med_a0im1_ri a0i m1\"", "lemma PO_m1_refines_ri_a0i [iff]: \n  \"refines (R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin) med_a0im1_ri a0i m1\"", "lemma  m1_implements_ri_a0i: \"implements med_a0im1_ri a0i m1\"", "lemmas m1_inv3r_initI = \n  m1_inv3r_init_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv3r_initE [elim] = \n  m1_inv3r_init_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv3r_initD = \n  m1_inv3r_init_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1_inv3r_init [iff]: \"reach m1 \\<subseteq> m1_inv3r_init\"", "lemmas m1_inv4_rfreshI = m1_inv4_rfresh_def [THEN setc_def_to_intro, rule_format]", "lemmas m1_inv4_rfreshE [elim] = m1_inv4_rfresh_def [THEN setc_def_to_elim, rule_format]", "lemmas m1_inv4_rfreshD = m1_inv4_rfresh_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1_inv4_rfresh_init [iff]:\n  \"init m1 \\<subseteq> m1_inv4_rfresh\"", "lemma PO_m1_inv4_rfresh_trans [iff]:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv3_ifresh \\<inter> m1_secrecy} \n      trans m1 \n   {> m1_inv4_rfresh}\"", "lemma PO_m1_inv4_rfresh [iff]: \"reach m1 \\<subseteq> m1_inv4_rfresh\"", "lemma PO_m1_obs_inv4_rfresh [iff]: \"oreach m1 \\<subseteq> m1_inv4_rfresh\""], "translations": [["", "lemmas m1_loc_defs = \n  m1_def m1_trans_def\n  m1_step1_def m1_step2_def m1_step3_def m1_step4_def m1_step5_def \n  m1_step6_def m1_step7_def m1_leak_def"], ["", "lemmas m1_defs = m1_loc_defs m1a_defs"], ["", "lemma m1_obs_id [simp]: \"obs m1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs m1 = id", "by (simp add: m1_def)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>inv0: Finite domain\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>There are only finitely many runs. This is needed to establish the \nresponder/initiator agreements. This is already defined in the previous model,\nwe just need to show that it still holds in the current model.\\<close>"], ["", "abbreviation\n  m1_inv0_fin :: \"'x m1_pred\" where\n  \"m1_inv0_fin \\<equiv> m1a_inv0_fin\""], ["", "lemmas m1_inv0_finI = m1a_inv0_finI"], ["", "lemmas m1_inv0_finE = m1a_inv0_finE"], ["", "lemmas m1_inv0_finD = m1a_inv0_finD"], ["", "text \\<open>Invariance proofs.\\<close>"], ["", "lemma PO_m1_inv0_fin_init [iff]:\n  \"init m1 \\<subseteq> m1_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> m1_inv0_fin", "by (auto simp add: m1_defs intro!: m1_inv0_finI)"], ["", "lemma PO_m1_inv0_fin_trans [iff]:\n  \"{m1_inv0_fin} trans m1 {> m1_inv0_fin}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv0_fin} TS.trans m1 {> m1_inv0_fin}", "by (auto simp add: PO_hoare_defs m1_defs intro!: m1_inv0_finI)"], ["", "lemma PO_m1_inv0_fin [iff]: \"reach m1 \\<subseteq> m1_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv0_fin", "by (rule inv_rule_incr, auto del: subsetI)"], ["", "declare PO_m1_inv0_fin [THEN subsetD, intro]"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>m1a\\<close>\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>med1a1: The mediator function maps a concrete observation (i.e., run) \nto an abstract one.\\<close>"], ["", "text \\<open>Instantiate parameters regarding list of freshness identifiers stored\nat server.\\<close>"], ["", "overloading is_len' \\<equiv> \"is_len\" rs_len' \\<equiv> \"rs_len\" begin"], ["", "definition is_len_def [simp]: \"is_len' \\<equiv> 0::nat\""], ["", "definition rs_len_def [simp]: \"rs_len' \\<equiv> 0::nat\""], ["", "end"], ["", "fun \n  rm1a1 :: \"role_t \\<Rightarrow> atom list \\<Rightarrow> atom list\"\nwhere\n  \"rm1a1 Init = take (Suc is_len)\"       \\<comment> \\<open>take \\<open>Kab\\<close>\\<close>\n| \"rm1a1 Resp = take (Suc rs_len)\"       \\<comment> \\<open>take \\<open>Kab\\<close>\\<close>\n| \"rm1a1 Serv = id\"                      \\<comment> \\<open>take all\\<close>"], ["", "abbreviation \n  runs1a1 :: \"runs_t \\<Rightarrow> runs_t\" where\n  \"runs1a1 \\<equiv> map_runs rm1a1\""], ["", "lemmas runs1a1_def = map_runs_def"], ["", "lemma knC_runs1a1 [simp]:\n  \"knC (runs1a1 runz) = knC runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knC (runs1a1 runz) = knC runz", "apply (auto simp add: map_runs_def elim!: knC.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>Ra A B K al b.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, A) \\<in> knC runz\n 2. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 3. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; runz Rs = None;\n        fst (the None) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC runz\n 4. \\<And>Rs aa b.\n       \\<lbrakk>Rs \\<in> dom runz; runz Rs = Some (Serv, aa, b)\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC runz\n 5. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 6. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 7. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 2. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 3. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 4. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1a1 runz)\n 2. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 3. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule knC_init, auto simp add: runs1a1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1a1 runz)\n 2. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule knC_resp, auto simp add: runs1a1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1a1 runz)", "apply (rule_tac knC_serv, auto simp add: runs1a1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>R1a1: The simulation relation is defined in terms of the mediator\nfunction.\\<close>"], ["", "definition\n  med1a1 :: \"m1_obs \\<Rightarrow> m1a_obs\" where\n  \"med1a1 s \\<equiv> \\<lparr> runs = runs1a1 (runs s), m1x_state.leak = Domain (leak s) \\<rparr>\""], ["", "definition\n  R1a1 :: \"(m1a_state \\<times> m1_state) set\" where\n  \"R1a1 \\<equiv> {(s, t). s = med1a1 t}\""], ["", "lemmas R1a1_defs = R1a1_def med1a1_def"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_m1a_step1:\n  \"{R1a1} \n     (m1a_step1 Ra A B Na), (m1_step1 Ra A B Na) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step1 Ra A B Na, m1_step1 Ra A B Na {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step2_refines_m1a_step2:\n  \"{R1a1} \n     (m1a_step2 Rb A B), (m1_step2 Rb A B) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step2 Rb A B, m1_step2 Rb A B {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step3_refines_m1a_step3:\n  \"{R1a1} \n     (m1a_step3 Rs A B Kab Na []), (m1_step3 Rs A B Na Kab)\n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step3 Rs A B Kab Na [], m1_step3 Rs A B Na Kab {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs)"], ["", "lemma PO_m1_step4_refines_m1a_step4:\n  \"{R1a1} \n     (m1a_step4 Ra A B Na Kab []), (m1_step4 Ra A B Na Kab) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step4 Ra A B Na Kab [], m1_step4 Ra A B Na Kab {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs runs1a1_def)"], ["", "lemma PO_m1_step5_refines_m1a_step5:\n  \"{R1a1} \n     (m1a_step5 Rb A B Kab []), (m1_step5 Rb A B Nb Kab) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_step5 Rb A B Kab [], m1_step5 Rb A B Nb Kab {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs runs1a1_def)"], ["", "lemma PO_m1_step6_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step6 Ra A B Na Nb Kab) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} Id, m1_step6 Ra A B Na Nb Kab {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs runs1a1_def)"], ["", "lemma PO_m1_step7_refines_m1a_skip:\n  \"{R1a1} \n     Id, (m1_step7 Rb A B Nb Kab) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} Id, m1_step7 Rb A B Nb Kab {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs runs1a1_def)"], ["", "lemma PO_m1_leak_refines_m1a_leak:\n  \"{R1a1} \n     (m1a_leak Rs), (m1_leak Rs Ra Rb A B)\n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} m1a_leak Rs, m1_leak Rs Ra Rb A B {> R1a1}", "by (auto simp add: PO_rhoare_defs R1a1_defs m1_defs map_runs_def dest: dom_lemmas)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_m1a_trans = \n  PO_m1_step1_refines_m1a_step1 PO_m1_step2_refines_m1a_step2\n  PO_m1_step3_refines_m1a_step3 PO_m1_step4_refines_m1a_step4\n  PO_m1_step5_refines_m1a_step5 PO_m1_step6_refines_m1a_skip \n  PO_m1_step7_refines_m1a_skip PO_m1_leak_refines_m1a_leak"], ["", "lemma PO_m1_refines_init_m1a [iff]:\n  \"init m1 \\<subseteq>  R1a1``(init m1a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R1a1 `` init m1a", "by (auto simp add: R1a1_defs m1a_defs m1_loc_defs)"], ["", "lemma PO_m1_refines_trans_m1a [iff]:\n  \"{R1a1} \n     (trans m1a), (trans m1) \n   {> R1a1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1a1} TS.trans m1a, TS.trans m1 {> R1a1}", "apply (auto simp add: m1_def m1_trans_def m1a_def m1a_trans_def\n         intro!: PO_m1_trans_refines_m1a_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xe.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step1 xb x xa xe {> R1a1}\n 2. \\<And>x xa xc.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step2 xc x xa {> R1a1}\n 3. \\<And>x xa xd xe Kab.\n       {R1a1} (\\<Union>x xa xb xc xd.\n                  (\\<Union>xe xf.\n                      m1a_step1 xb x xa xe \\<union>\n                      m1a_step2 xc x xa \\<union>\n                      \\<Union> (range (m1a_step3 xd x xa xf xe)) \\<union>\n                      \\<Union> (range (m1a_step4 xb x xa xe xf)) \\<union>\n                      \\<Union> (range (m1a_step5 xc x xa xf))) \\<union>\n                  m1a_leak xd)\\<^sup>=, m1_step3 xd x xa xe Kab {> R1a1}", "apply (force intro!: PO_m1_trans_refines_m1a_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med1a1 [iff]: \n  \"obs_consistent R1a1 med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R1a1 med1a1 m1a m1", "by (auto simp add: obs_consistent_def R1a1_def med1a1_def m1a_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_m1a [iff]: \n  \"refines R1a1 med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R1a1 med1a1 m1a m1", "by (rule Refinement_basic) (auto del: subsetI)"], ["", "lemma  m1_implements_m1a [iff]: \"implements med1a1 m1a m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med1a1 m1a m1", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv (inherited): Key secrecy\\<close>"], ["", "(*invh**************************************************************************)"], ["", "text \\<open>Secrecy, as external and internal invariant\\<close>"], ["", "definition \n  m1_secrecy :: \"'x m1_pred\" where\n  \"m1_secrecy \\<equiv> {s. knC (runs s) \\<subseteq> azC (runs s) \\<union> Domain (leak s) \\<times> UNIV}\""], ["", "lemmas m1_secrecyI = m1_secrecy_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_secrecyE [elim] = m1_secrecy_def [THEN setc_def_to_elim, rule_format]"], ["", "lemma PO_m1_obs_secrecy [iff]: \"oreach m1 \\<subseteq> m1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach m1 \\<subseteq> m1_secrecy", "apply (rule_tac Q=m1x_secrecy in external_invariant_translation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. oreach ?Sa \\<subseteq> m1x_secrecy\n 2. ?pi -` m1x_secrecy \\<subseteq> m1_secrecy\n 3. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1x_secrecy \\<subseteq> m1_secrecy", "apply (fastforce simp add: med1a1_def intro!: m1_secrecyI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_secrecy [iff]: \"reach m1 \\<subseteq> m1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_secrecy", "by (rule external_to_internal_invariant) (auto del: subsetI)"], ["", "(*\nsubsubsection {* inv (inherited): Disjointness of session and static keys *}\n(******************************************************************************)\n\nlemma PO_m1_inv0b_key [iff]: \"reach m1 \\<subseteq> m1a_inv0b_key\"\napply (rule_tac Pa=m1a_inv0b_key and Qa=m1a_inv0b_key and Q=m1a_inv0b_key\n       in internal_invariant_translation)\napply (auto del: subsetI)\napply (force simp add: med1a1_def runs1a1_def vimage_def m1a_inv0b_key_def)\ndone\n*)"], ["", "subsubsection \\<open>inv (inherited): Initiator auth server.\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>Simplified version of invariant \\<open>m1a_inv2i_serv\\<close>.\\<close>"], ["", "definition \n  m1_inv2i_serv :: \"'x m1r_pred\" \nwhere\n  \"m1_inv2i_serv \\<equiv> {s. \\<forall>A B Ra Na Kab nla.\n     A \\<notin> bad \\<longrightarrow> \n     runs s Ra = Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n     Na = Ra$na \\<longrightarrow>\n       (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and> runs s Rs = Some (Serv, [A, B], [aNon Na]))\n  }\""], ["", "lemmas m1_inv2i_servI = m1_inv2i_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv2i_servE [elim] = m1_inv2i_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv2i_servD = m1_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated 2]"], ["", "text \\<open>Proof of invariance.\\<close>"], ["", "lemma PO_m1_inv2i_serv [iff]: \"reach m1 \\<subseteq> m1_inv2i_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv2i_serv", "apply (rule_tac Pa=m1a_inv2i_serv and Qa=m1a_inv2i_serv and Q=m1_inv2i_serv\n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach ?Sa \\<subseteq> m1a_inv2i_serv\n 2. m1a_inv2i_serv \\<subseteq> obs ?Sa -` m1a_inv2i_serv\n 3. ?pi -` m1a_inv2i_serv \\<subseteq> m1_inv2i_serv\n 4. obs m1 -` m1_inv2i_serv \\<subseteq> m1_inv2i_serv\n 5. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv2i_serv \\<subseteq> m1_inv2i_serv", "apply (auto simp add: m1a_inv2i_serv_def med1a1_def vimage_def \n            intro!: m1_inv2i_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # nla);\n        \\<forall>A.\n           A \\<notin> bad \\<longrightarrow>\n           (\\<forall>B Ra Kab.\n               (\\<exists>nla.\n                   runs1a1 (runs x) Ra =\n                   Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   runs1a1 (runs x) Rs =\n                   Some (Serv, [A, B], [aNon (Ra $ na)])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (rename_tac s A B Ra Kab nla)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs s Ra = Some (Init, [A, B], aKey Kab # nla);\n        \\<forall>A.\n           A \\<notin> bad \\<longrightarrow>\n           (\\<forall>B Ra Kab.\n               (\\<exists>nla.\n                   runs1a1 (runs s) Ra =\n                   Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   runs1a1 (runs s) Rs =\n                   Some (Serv, [A, B], [aNon (Ra $ na)])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs s Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (drule_tac x=A in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs s Ra = Some (Init, [A, B], aKey Kab # nla);\n        \\<forall>B Ra Kab.\n           (\\<exists>nla.\n               runs1a1 (runs s) Ra =\n               Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs s) Rs =\n               Some (Serv, [A, B], [aNon (Ra $ na)]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs s Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (drule_tac x=B in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs s Ra = Some (Init, [A, B], aKey Kab # nla);\n        \\<forall>Ra Kab.\n           (\\<exists>nla.\n               runs1a1 (runs s) Ra =\n               Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs s) Rs =\n               Some (Serv, [A, B], [aNon (Ra $ na)]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs s Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (drule_tac x=Ra in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs s Ra = Some (Init, [A, B], aKey Kab # nla);\n        \\<forall>Kab.\n           (\\<exists>nla.\n               runs1a1 (runs s) Ra =\n               Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               runs1a1 (runs s) Rs =\n               Some (Serv, [A, B], [aNon (Ra $ na)]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs s Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (drule_tac x=Kab in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Ra Kab nla.\n       \\<lbrakk>A \\<notin> bad;\n        runs s Ra = Some (Init, [A, B], aKey Kab # nla);\n        (\\<exists>nla.\n            runs1a1 (runs s) Ra =\n            Some (Init, [A, B], aKey Kab # nla)) \\<longrightarrow>\n        (\\<exists>Rs.\n            Kab = sesK (Rs $ sk) \\<and>\n            runs1a1 (runs s) Rs =\n            Some (Serv, [A, B], [aNon (Ra $ na)]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs s Rs =\n                            Some (Serv, [A, B], [aNon (Ra $ na)])", "apply (clarsimp simp add: runs1a1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare PO_m1_inv2i_serv [THEN subsetD, intro]"], ["", "subsubsection \\<open>inv (inherited): Responder auth server.\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>Simplified version of invarant \\<open>m1a_inv2r_serv\\<close>.\\<close>"], ["", "definition \n  m1_inv2r_serv :: \"'x m1r_pred\"\nwhere\n  \"m1_inv2r_serv \\<equiv> {s. \\<forall>A B Rb Kab nlb.\n     B \\<notin> bad \\<longrightarrow> \n     runs s Rb = Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n       (\\<exists>Rs Na. Kab = sesK (Rs$sk) \\<and> runs s Rs = Some (Serv, [A, B], [aNon Na]))\n  }\""], ["", "lemmas m1_inv2r_servI = m1_inv2r_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv2r_servE [elim] = m1_inv2r_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv2r_servD = m1_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Proof of invariance.\\<close>"], ["", "lemma PO_m1_inv2r_serv [iff]: \"reach m1 \\<subseteq> m1_inv2r_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv2r_serv", "apply (rule_tac Pa=m1a_inv2r_serv and Qa=m1a_inv2r_serv and Q=m1_inv2r_serv\n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach ?Sa \\<subseteq> m1a_inv2r_serv\n 2. m1a_inv2r_serv \\<subseteq> obs ?Sa -` m1a_inv2r_serv\n 3. ?pi -` m1a_inv2r_serv \\<subseteq> m1_inv2r_serv\n 4. obs m1 -` m1_inv2r_serv \\<subseteq> m1_inv2r_serv\n 5. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv2r_serv \\<subseteq> m1_inv2r_serv", "apply (auto simp add: simp add: m1a_inv2r_serv_def med1a1_def vimage_def \n            intro!: m1_inv2r_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        \\<forall>A B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab.\n               (\\<exists>nlb.\n                   runs1a1 (runs x) Rb =\n                   Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs x) Rs =\n                       Some (Serv, [A, B], [aNon Na]))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs = Some (Serv, [A, B], [aNon Na]))", "apply (rename_tac s A B Rb Kab nlb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs s Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        \\<forall>A B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab.\n               (\\<exists>nlb.\n                   runs1a1 (runs s) Rb =\n                   Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs s) Rs =\n                       Some (Serv, [A, B], [aNon Na]))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs s Rs = Some (Serv, [A, B], [aNon Na]))", "apply (drule_tac x=A in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs s Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        \\<forall>B.\n           B \\<notin> bad \\<longrightarrow>\n           (\\<forall>Rb Kab.\n               (\\<exists>nlb.\n                   runs1a1 (runs s) Rb =\n                   Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n               (\\<exists>Rs.\n                   Kab = sesK (Rs $ sk) \\<and>\n                   (\\<exists>Na.\n                       runs1a1 (runs s) Rs =\n                       Some (Serv, [A, B], [aNon Na]))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs s Rs = Some (Serv, [A, B], [aNon Na]))", "apply (drule_tac x=B in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs s Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        \\<forall>Rb Kab.\n           (\\<exists>nlb.\n               runs1a1 (runs s) Rb =\n               Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               (\\<exists>Na.\n                   runs1a1 (runs s) Rs =\n                   Some (Serv, [A, B], [aNon Na])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs s Rs = Some (Serv, [A, B], [aNon Na]))", "apply (drule_tac x=Rb in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs s Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        \\<forall>Kab.\n           (\\<exists>nlb.\n               runs1a1 (runs s) Rb =\n               Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n           (\\<exists>Rs.\n               Kab = sesK (Rs $ sk) \\<and>\n               (\\<exists>Na.\n                   runs1a1 (runs s) Rs =\n                   Some (Serv, [A, B], [aNon Na])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs s Rs = Some (Serv, [A, B], [aNon Na]))", "apply (drule_tac x=Kab in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab nlb.\n       \\<lbrakk>B \\<notin> bad;\n        runs s Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        (\\<exists>nlb.\n            runs1a1 (runs s) Rb =\n            Some (Resp, [A, B], aKey Kab # nlb)) \\<longrightarrow>\n        (\\<exists>Rs.\n            Kab = sesK (Rs $ sk) \\<and>\n            (\\<exists>Na.\n                runs1a1 (runs s) Rs =\n                Some (Serv, [A, B], [aNon Na])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs s Rs = Some (Serv, [A, B], [aNon Na]))", "apply (clarsimp simp add: runs1a1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare PO_m1_inv2r_serv [THEN subsetD, intro]"], ["", "subsubsection \\<open>inv (inherited): Initiator key freshness\\<close>"], ["", "(*invh*************************************************************************)"], ["", "definition \n  m1_inv3_ifresh :: \"'x m1_pred\"\nwhere\n  \"m1_inv3_ifresh \\<equiv> {s. \\<forall>A A' B B' Ra Ra' Kab nl nl'.\n     runs s Ra  = Some (Init, [A,  B],  aKey Kab # nl) \\<longrightarrow>\n     runs s Ra' = Some (Init, [A', B'], aKey Kab # nl') \\<longrightarrow>\n     A \\<notin> bad \\<longrightarrow> B \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n       Ra = Ra'\n  }\""], ["", "lemmas m1_inv3_ifreshI = m1_inv3_ifresh_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv3_ifreshE [elim] = m1_inv3_ifresh_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv3_ifreshD = m1_inv3_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m1_inv3_ifresh [iff]: \"reach m1 \\<subseteq> m1_inv3_ifresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv3_ifresh", "apply (rule_tac Pa=m1a_inv1_ifresh and Qa=m1a_inv1_ifresh and Q=m1_inv3_ifresh \n       in internal_invariant_translation)"], ["proof (prove)\ngoal (5 subgoals):\n 1. reach ?Sa \\<subseteq> m1a_inv1_ifresh\n 2. m1a_inv1_ifresh \\<subseteq> obs ?Sa -` m1a_inv1_ifresh\n 3. ?pi -` m1a_inv1_ifresh \\<subseteq> m1_inv3_ifresh\n 4. obs m1 -` m1_inv3_ifresh \\<subseteq> m1_inv3_ifresh\n 5. implements ?pi ?Sa m1", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1a1 -` m1a_inv1_ifresh \\<subseteq> m1_inv3_ifresh", "apply (auto simp add: med1a1_def runs1a1_def vimage_def m1_inv3_ifresh_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0i\\<close> for initiator/responder\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and responder runs. For the initiator, \nwe get an injective agreement with the responder on Kab and Nb.\\<close>"], ["", "type_synonym\n  irsig = \"key \\<times> nonce\""], ["", "abbreviation\n  ir_commit :: \"[runs_t, agent, agent, key, nonce] \\<Rightarrow> rid_t set\" \nwhere\n  \"ir_commit runz A B Kab Nb \\<equiv> {Ra. \n     runz Ra = Some (Init, [A, B], [aKey Kab, aNon Nb])\n  }\""], ["", "fun\n  ir_runs2sigs :: \"runs_t \\<Rightarrow> irsig signal \\<Rightarrow> nat\"\nwhere\n  \"ir_runs2sigs runz (Commit [A, B] (Kab, Nb)) =\n     card (ir_commit runz A B Kab Nb)\"\n\n| \"ir_runs2sigs runz (Running [A, B] (Kab, Nb)) =\n     (if \\<exists>Rb nl. Nb = Rb$nb \\<and> runz Rb = Some (Resp, [A, B], aKey Kab # nl) \n      then 1 else 0)\"\n\n| \"ir_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0im1_ir :: \"m1_obs \\<Rightarrow> irsig a0i_obs\" where\n  \"med_a0im1_ir o1 \\<equiv> \\<lparr> signals = ir_runs2sigs (runs o1), corrupted = Domain (leak o1) \\<times> UNIV \\<rparr>\""], ["", "definition\n  R_a0im1_ir :: \"(irsig a0i_state \\<times> m1_state) set\" where\n  \"R_a0im1_ir \\<equiv> {(s, t). signals s = ir_runs2sigs (runs t) \\<and> corrupted s = Domain (leak t) \\<times> UNIV}\""], ["", "lemmas R_a0im1_ir_defs = R_a0im1_ir_def med_a0im1_ir_def"], ["", "subsubsection \\<open>Lemmas about the abstraction function\\<close>"], ["", "(******************************************************************************)"], ["", "lemma ir_runs2sigs_empty [simp]: \n   \"runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> ir_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, auto)"], ["", "lemma finite_ir_commit [simp, intro!]: \n   \"finite (dom runz) \\<Longrightarrow> finite (ir_commit runz A B Kab Nb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow> finite (ir_commit runz A B Kab Nb)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma ir_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = ir_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ir_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_serv_none [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    ir_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ir_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ir_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ir_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) =\n    ir_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ir_runs2sigs.induct, auto)"], ["", "lemma ir_runs2sigs_upd_resp [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab]))) =\n     (ir_runs2sigs runz)(Running [A, B] (Kab, Rb$nb) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], []) \\<Longrightarrow>\n    ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab]))) =\n    (ir_runs2sigs runz)(Running [A, B] (Kab, Rb $ nb) := 1)", "apply (rule ext, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       runz Rb = Some (Resp, [A, B], []) \\<longrightarrow>\n       ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab]))) x =\n       ((ir_runs2sigs runz)(Running [A, B] (Kab, Rb $ nb) := 1)) x", "apply (rule ir_runs2sigs.induct, fastforce+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ir_runs2sigs_upd_init [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb]))) = \n     (ir_runs2sigs runz)\n       (Commit [A, B] (Kab, Nb) := Suc (card (ir_commit runz A B Kab Nb)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab]);\n     finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ir_runs2sigs\n                       (runz(Ra \\<mapsto>\n                        (Init, [A, B], [aKey Kab, aNon Nb]))) =\n                      (ir_runs2sigs runz)\n                      (Commit [A, B] (Kab, Nb) :=\n                         Suc (card (ir_commit runz A B Kab Nb)))", "apply (rule ext, erule rev_mp, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       finite (dom runz) \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], [aKey Kab]) \\<longrightarrow>\n       ir_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb])))\n        x =\n       ((ir_runs2sigs runz)\n        (Commit [A, B] (Kab, Nb) := Suc (card (ir_commit runz A B Kab Nb))))\n        x", "apply (rule_tac ?a0.0=runz in ir_runs2sigs.induct, auto)\n\\<comment> \\<open>1 subgoal, solved using @{thm \"card_insert_disjoint\"}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [aKey Kab])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           runz Raa =\n                           Some (Init, [A, B], [aKey Kab, aNon Nb])} =\n                         Suc (card (ir_commit runz A B Kab Nb))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [aKey Kab])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           runz Raa =\n                           Some (Init, [A, B], [aKey Kab, aNon Nb])} =\n                         Suc (card (ir_commit runz A B Kab Nb))", "apply (rule_tac \n         s=\"card (insert Ra (ir_commit runz A B Kab Nb))\" \n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ir_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [aKey K]) \\<rbrakk>\n  \\<Longrightarrow> ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K, END]))) = ir_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], [aKey K]) \\<Longrightarrow>\n    ir_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K, END]))) =\n    ir_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule ir_runs2sigs.induct, fastforce+)"], ["", "text \\<open>Needed for injectiveness of agreement.\\<close>"], ["", "lemma m1_inv2i_serv_lemma:\n  \"\\<lbrakk> runs t Ra  = Some (Init, [A, B], [aKey Kab, aNon Nb]);\n     runs t Ra' = Some (Init, [A, B], [aKey Kab]); \n     A \\<notin> bad; t \\<in> m1_inv2i_serv \\<rbrakk>\n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runs t Ra = Some (Init, [A, B], [aKey Kab, aNon Nb]);\n     runs t Ra' = Some (Init, [A, B], [aKey Kab]); A \\<notin> bad;\n     t \\<in> m1_inv2i_serv\\<rbrakk>\n    \\<Longrightarrow> P", "apply (frule m1_inv2i_servD, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rs.\n       \\<lbrakk>runs t Ra =\n                Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon Nb]);\n        runs t Ra' = Some (Init, [A, B], [aKey (sesK (Rs $ sk))]);\n        A \\<notin> bad; t \\<in> m1_inv2i_serv;\n        runs t Rs = Some (Serv, [A, B], [aNon (Ra $ na)]);\n        Kab = sesK (Rs $ sk)\\<rbrakk>\n       \\<Longrightarrow> P", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rs.\n       \\<lbrakk>runs t Ra' = Some (Init, [A, B], [aKey (sesK (Rs $ sk))]);\n        A \\<notin> bad; t \\<in> m1_inv2i_serv;\n        runs t Rs = Some (Serv, [A, B], [aNon (Ra $ na)]);\n        Kab = sesK (Rs $ sk);\n        runs t Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon Nb])\\<rbrakk>\n       \\<Longrightarrow> P", "apply (frule m1_inv2i_servD, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} Id, m1_step1 Ra A B Na {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step2_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step2 Rb A B) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} Id, m1_step2 Rb A B {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step3_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step3 Rs A B Na Kab) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} Id, m1_step3 Rs A B Na Kab {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step4_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step4 Ra A B Na Kab) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} Id, m1_step4 Ra A B Na Kab {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step5_refines_ir_a0i_running:\n  \"{R_a0im1_ir} \n     (a0i_running [A, B] (Kab, Nb)), (m1_step5 Rb A B Nb Kab) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} a0i_running [A, B]\n                  (Kab, Nb), m1_step5 Rb A B Nb Kab {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step6_refines_ir_a0i_commit:\n  \"{R_a0im1_ir \\<inter> UNIV \\<times> (m1_inv2i_serv \\<inter> m1_inv0_fin)} \n     (a0i_commit [A, B] (Kab, Nb)), (m1_step6 Ra A B Na Nb Kab) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir \\<inter>\n     UNIV \\<times>\n     (m1_inv2i_serv \\<inter>\n      m1_inv0_fin)} a0i_commit [A, B]\n                     (Kab, Nb), m1_step6 Ra A B Na Nb Kab {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs a0i_defs m1_defs, safe, auto)\n   (auto dest: m1_inv2i_serv_lemma)"], ["", "lemma PO_m1_step7_refines_ir_a0i_skip:\n  \"{R_a0im1_ir} \n     Id, (m1_step7 Rb A B Nb Kab) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} Id, m1_step7 Rb A B Nb Kab {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_leak_refines_ir_a0i_corrupt:\n  \"{R_a0im1_ir} \n     (a0i_corrupt ({sesK (Rs$sk)} \\<times> UNIV)), (m1_leak Rs Ra Rb A B) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir} a0i_corrupt\n                  ({sesK (Rs $ sk)} \\<times>\n                   UNIV), m1_leak Rs Ra Rb A B {> R_a0im1_ir}", "by (simp add: PO_rhoare_defs R_a0im1_ir_defs a0i_defs m1_defs, safe, auto)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_ir_a0i_trans = \n  PO_m1_step1_refines_ir_a0i_skip PO_m1_step2_refines_ir_a0i_skip\n  PO_m1_step3_refines_ir_a0i_skip PO_m1_step4_refines_ir_a0i_skip\n  PO_m1_step5_refines_ir_a0i_running PO_m1_step6_refines_ir_a0i_commit\n  PO_m1_step7_refines_ir_a0i_skip PO_m1_leak_refines_ir_a0i_corrupt"], ["", "lemma PO_m1_refines_ir_init_a0i [iff]:\n  \"init m1 \\<subseteq>  R_a0im1_ir``(init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R_a0im1_ir `` init a0i", "by (auto simp add: R_a0im1_ir_defs a0i_defs m1_defs\n         intro!: exI [where x=\"\\<lparr>signals = \\<lambda>s. 0, corrupted = corrKey \\<times> UNIV \\<rparr>\"])"], ["", "lemma PO_m1_refines_ir_trans_a0i [iff]:\n  \"{R_a0im1_ir \\<inter> reach a0i \\<times> reach m1} \n     (trans a0i), (trans m1) \n   {> R_a0im1_ir}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir \\<inter>\n     reach a0i \\<times> reach m1} TS.trans a0i, TS.trans m1 {> R_a0im1_ir}", "apply (rule_tac pre'=\"R_a0im1_ir \\<inter> UNIV \\<times> (m1_inv2i_serv \\<inter> m1_inv0_fin)\" \n       in relhoare_conseq_left, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ir \\<inter>\n     UNIV \\<times>\n     (m1_inv2i_serv \\<inter>\n      m1_inv0_fin)} TS.trans a0i, TS.trans m1 {> R_a0im1_ir}", "apply (auto simp add: m1_def m1_trans_def a0i_def a0i_trans_def\n            intro!: PO_m1_trans_refines_ir_a0i_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med_a0im1_ir [iff]: \n  \"obs_consistent R_a0im1_ir med_a0im1_ir a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R_a0im1_ir med_a0im1_ir a0i m1", "by (auto simp add: obs_consistent_def R_a0im1_ir_def med_a0im1_ir_def \n         a0i_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_ir_a0i [iff]: \n  \"refines \n     (R_a0im1_ir \\<inter> reach a0i \\<times> reach m1)\n     med_a0im1_ir a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0im1_ir \\<inter> reach a0i \\<times> reach m1) med_a0im1_ir\n     a0i m1", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma  m1_implements_ir_a0i: \"implements med_a0im1_ir a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0im1_ir a0i m1", "by (rule refinement_soundness) (fast)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0i\\<close> for responder/initiator\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from initiator and responder runs. For the responder, we get an \ninjective agreement with the initiator on Kab and Nb.\\<close>"], ["", "type_synonym\n  risig = \"key \\<times> nonce\""], ["", "abbreviation\n  ri_running :: \"[runs_t, agent, agent, key, nonce] \\<Rightarrow> rid_t set\"\nwhere\n  \"ri_running runz A B Kab Nb \\<equiv> {Ra. \n     runz Ra = Some (Init, [A, B], [aKey Kab, aNon Nb])\n  }\""], ["", "fun\n  ri_runs2sigs :: \"runs_t \\<Rightarrow> risig signal \\<Rightarrow> nat\"\nwhere\n  \"ri_runs2sigs runz (Commit [B, A] (Kab, Nb)) = \n     (if \\<exists>Rb. Nb = Rb$nb \\<and> runz Rb = Some (Resp, [A, B], [aKey Kab, END]) \n      then 1 else 0)\"\n\n| \"ri_runs2sigs runz (Running [B, A] (Kab, Nb)) = \n     card (ri_running runz A B Kab Nb)\"\n\n| \"ri_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0im1_ri :: \"m1_obs \\<Rightarrow> risig a0i_obs\" where\n  \"med_a0im1_ri o1 \\<equiv> \\<lparr> signals = ri_runs2sigs (runs o1), corrupted = Domain (leak o1) \\<times> UNIV \\<rparr>\""], ["", "definition\n  R_a0im1_ri :: \"(risig a0i_state \\<times> m1_state) set\" where\n  \"R_a0im1_ri \\<equiv> {(s, t). signals s = ri_runs2sigs (runs t) \\<and> corrupted s = Domain (leak t) \\<times> UNIV}\""], ["", "lemmas R_a0im1_ri_defs = R_a0im1_ri_def med_a0im1_ri_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "lemma ri_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> ri_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule ri_runs2sigs.induct, auto)"], ["", "lemma finite_inv_ri_running [simp, intro!]: \n   \"finite (dom runz) \\<Longrightarrow> finite (ri_running runz A B Kab Nb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow> finite (ri_running runz A B Kab Nb)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma ri_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Na \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Na \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Na \\<mapsto> (Init, [A, B], []))) = ri_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ri_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = ri_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ri_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_serv_none [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    ri_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], nl))) = ri_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ri_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma ri_runs2sigs_upd_init [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], [aKey Kab]); finite (dom runz) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb]))) =\n     (ri_runs2sigs runz)\n       (Running [B, A] (Kab, Nb) := Suc (card (ri_running runz A B Kab Nb)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Ra = Some (Init, [A, B], [aKey Kab]);\n     finite (dom runz)\\<rbrakk>\n    \\<Longrightarrow> ri_runs2sigs\n                       (runz(Ra \\<mapsto>\n                        (Init, [A, B], [aKey Kab, aNon Nb]))) =\n                      (ri_runs2sigs runz)\n                      (Running [B, A] (Kab, Nb) :=\n                         Suc (card (ri_running runz A B Kab Nb)))", "apply (rule ext, erule rev_mp, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       finite (dom runz) \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], [aKey Kab]) \\<longrightarrow>\n       ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNon Nb])))\n        x =\n       ((ri_runs2sigs runz)\n        (Running [B, A] (Kab, Nb) :=\n           Suc (card (ri_running runz A B Kab Nb))))\n        x", "apply (rule_tac ?a0.0=runz in ri_runs2sigs.induct, auto)\n\\<comment> \\<open>1 subgoal, solved using @{thm \"card_insert_disjoint\"}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [aKey Kab])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           runz Raa =\n                           Some (Init, [A, B], [aKey Kab, aNon Nb])} =\n                         Suc (card (ri_running runz A B Kab Nb))", "apply (rename_tac runz)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>finite (dom runz);\n        runz Ra = Some (Init, [A, B], [aKey Kab])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Raa.\n                           Raa \\<noteq> Ra \\<longrightarrow>\n                           runz Raa =\n                           Some (Init, [A, B], [aKey Kab, aNon Nb])} =\n                         Suc (card (ri_running runz A B Kab Nb))", "apply (rule_tac \n         s=\"card (insert Ra (ri_running runz A B Kab Nb))\" \n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ri_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    ri_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], [aKey Kab]))) =\n    ri_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ri_runs2sigs.induct, auto)"], ["", "lemma ri_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K]))) = ri_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], []) \\<Longrightarrow>\n    ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey K]))) =\n    ri_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule ri_runs2sigs.induct, auto)"], ["", "lemma ri_runs2sigs_upd_resp_some2 [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], [aKey Kab]) \\<rbrakk>\n  \\<Longrightarrow> ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, END]))) = \n     (ri_runs2sigs runz)(Commit [B, A] (Kab, Rb$nb) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], [aKey Kab]) \\<Longrightarrow>\n    ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, END]))) =\n    (ri_runs2sigs runz)(Commit [B, A] (Kab, Rb $ nb) := 1)", "apply (rule ext, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       runz Rb = Some (Resp, [A, B], [aKey Kab]) \\<longrightarrow>\n       ri_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, END]))) x =\n       ((ri_runs2sigs runz)(Commit [B, A] (Kab, Rb $ nb) := 1)) x", "apply (rule ri_runs2sigs.induct, fastforce+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1_step1_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step1 Ra A B Na) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} Id, m1_step1 Ra A B Na {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step2_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step2 Rb A B) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} Id, m1_step2 Rb A B {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step3_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step3 Rs A B Na Kab) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} Id, m1_step3 Rs A B Na Kab {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step4_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step4 Ra A B Nb Kab) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} Id, m1_step4 Ra A B Nb Kab {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step5_refines_ri_a0i_skip:\n  \"{R_a0im1_ri} \n     Id, (m1_step5 Rb A B Nb Kab) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} Id, m1_step5 Rb A B Nb Kab {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step6_refines_ri_a0i_running:\n  \"{R_a0im1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_running [B, A] (Kab, Nb)), (m1_step6 Ra A B Na Nb Kab) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri \\<inter>\n     UNIV \\<times>\n     m1_inv0_fin} a0i_running [B, A]\n                   (Kab, Nb), m1_step6 Ra A B Na Nb Kab {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_step7_refines_ri_a0i_commit:\n  \"{R_a0im1_ri \\<inter> UNIV \\<times> m1_inv0_fin} \n     (a0i_commit [B, A] (Kab, Nb)), (m1_step7 Rb A B Nb Kab) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri \\<inter>\n     UNIV \\<times>\n     m1_inv0_fin} a0i_commit [B, A]\n                   (Kab, Nb), m1_step7 Rb A B Nb Kab {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "lemma PO_m1_leak_refines_ri_a0i_corrupt:\n  \"{R_a0im1_ri} \n     (a0i_corrupt ({sesK (Rs$sk)} \\<times> UNIV)), (m1_leak Rs Ra Rb A B) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri} a0i_corrupt\n                  ({sesK (Rs $ sk)} \\<times>\n                   UNIV), m1_leak Rs Ra Rb A B {> R_a0im1_ri}", "by (simp add: PO_rhoare_defs R_a0im1_ri_defs a0i_defs m1_defs, safe, auto)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1_trans_refines_ri_a0i_trans = \n  PO_m1_step1_refines_ri_a0i_skip PO_m1_step2_refines_ri_a0i_skip\n  PO_m1_step3_refines_ri_a0i_skip PO_m1_step4_refines_ri_a0i_skip\n  PO_m1_step5_refines_ri_a0i_skip PO_m1_step6_refines_ri_a0i_running\n  PO_m1_step7_refines_ri_a0i_commit PO_m1_leak_refines_ri_a0i_corrupt"], ["", "lemma PO_m1_refines_ri_init_a0i [iff]:\n  \"init m1 \\<subseteq>  R_a0im1_ri``(init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> R_a0im1_ri `` init a0i", "by (auto simp add: R_a0im1_ri_defs a0i_defs m1_defs\n         intro!: exI [where x=\"\\<lparr>signals = \\<lambda>s. 0, corrupted = corrKey \\<times> UNIV \\<rparr>\"])"], ["", "lemma PO_m1_refines_ri_trans_a0i [iff]:\n  \"{R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin} \n     (trans a0i), (trans m1) \n   {> R_a0im1_ri}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0im1_ri \\<inter>\n     a0i_inv1_iagree \\<times>\n     m1_inv0_fin} TS.trans a0i, TS.trans m1 {> R_a0im1_ri}", "by (auto simp add: m1_def m1_trans_def a0i_def a0i_trans_def)\n   (blast intro!: PO_m1_trans_refines_ri_a0i_trans)+"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med_a0im1_ri [iff]: \n  \"obs_consistent R_a0im1_ri med_a0im1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R_a0im1_ri med_a0im1_ri a0i m1", "by (auto simp add: obs_consistent_def R_a0im1_ri_def med_a0im1_ri_def a0i_def m1_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1_refines_ri_a0i [iff]: \n  \"refines (R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin) med_a0im1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin)\n     med_a0im1_ri a0i m1", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma  m1_implements_ri_a0i: \"implements med_a0im1_ri a0i m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0im1_ri a0i m1", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv3 (inherited): Responder and initiator\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>This is a translation of the agreement property to Level 1. It\nfollows from the refinement and is needed to prove inv4.\\<close>"], ["", "definition \n  m1_inv3r_init :: \"'x m1_pred\"\nwhere\n  \"m1_inv3r_init \\<equiv> {s. \\<forall>A B Rb Kab.\n     B \\<notin> bad \\<longrightarrow> A \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n     runs s Rb = Some (Resp, [A, B], [aKey Kab, END]) \\<longrightarrow>\n       (\\<exists>Ra nla. runs s Ra = Some (Init, [A, B], aKey Kab # aNon (Rb$nb) # nla))\n  }\""], ["", "lemmas m1_inv3r_initI = \n  m1_inv3r_init_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv3r_initE [elim] = \n  m1_inv3r_init_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv3r_initD = \n  m1_inv3r_init_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m1_inv3r_init [iff]: \"reach m1 \\<subseteq> m1_inv3r_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv3r_init", "apply (rule INV_from_Refinement_basic [OF PO_m1_refines_ri_a0i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R_a0im1_ri \\<inter> a0i_inv1_iagree \\<times> m1_inv0_fin)\n    \\<subseteq> m1_inv3r_init", "apply (auto simp add: R_a0im1_ri_def a0i_inv1_iagree_def\n            intro!:  m1_inv3r_initI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak x);\n        runs x Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        x \\<in> m1_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a.\n               a \\<notin> Domain (m1_state.leak x) \\<longrightarrow>\n               (\\<forall>b.\n                   ri_runs2sigs (runs x) (Commit h (a, b))\n                   \\<le> ri_runs2sigs (runs x) (Running h (a, b))));\n        signals a = ri_runs2sigs (runs x);\n        corrupted a = Domain (m1_state.leak x) \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs x Ra =\n                            Some\n                             (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)", "apply (rename_tac s A B Rb Kab a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        s \\<in> m1_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a.\n               a \\<notin> Domain (m1_state.leak s) \\<longrightarrow>\n               (\\<forall>b.\n                   ri_runs2sigs (runs s) (Commit h (a, b))\n                   \\<le> ri_runs2sigs (runs s) (Running h (a, b))));\n        signals a = ri_runs2sigs (runs s);\n        corrupted a = Domain (m1_state.leak s) \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)", "apply (drule_tac x=\"[B, A]\" in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab a.\n       \\<lbrakk>\\<forall>a.\n                   a \\<notin> Domain (m1_state.leak s) \\<longrightarrow>\n                   (\\<forall>b.\n                       (\\<forall>Rb.\n                           b = Rb $ nb \\<longrightarrow>\n                           runs s Rb \\<noteq>\n                           Some (Resp, [A, B], [aKey a, END])) \\<or>\n                       Suc 0 \\<le> card (ri_running (runs s) A B a b));\n        B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        s \\<in> m1_inv0_fin; signals a = ri_runs2sigs (runs s);\n        corrupted a = Domain (m1_state.leak s) \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)", "apply (drule_tac x=\"Kab\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        s \\<in> m1_inv0_fin; signals a = ri_runs2sigs (runs s);\n        corrupted a = Domain (m1_state.leak s) \\<times> UNIV;\n        Kab \\<notin> Domain (m1_state.leak s) \\<longrightarrow>\n        (\\<forall>b.\n            (\\<forall>Rb.\n                b = Rb $ nb \\<longrightarrow>\n                runs s Rb \\<noteq>\n                Some (Resp, [A, B], [aKey Kab, END])) \\<or>\n            Suc 0 \\<le> card (ri_running (runs s) A B Kab b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)", "(* apply (drule_tac x=\"Rb$nb\" in spec, auto) *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s A B Rb Kab a.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak s);\n        runs s Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        s \\<in> m1_inv0_fin; signals a = ri_runs2sigs (runs s);\n        corrupted a = Domain (m1_state.leak s) \\<times> UNIV;\n        Kab \\<notin> Domain (m1_state.leak s) \\<longrightarrow>\n        (\\<forall>b.\n            (\\<forall>Rb.\n                b = Rb $ nb \\<longrightarrow>\n                runs s Rb \\<noteq>\n                Some (Resp, [A, B], [aKey Kab, END])) \\<or>\n            Suc 0 \\<le> card (ri_running (runs s) A B Kab b))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra nla.\n                            runs s Ra =\n                            Some\n                             (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)", "apply (subgoal_tac \"card (ri_running (runs s) A B Kab (Rb$nb)) > 0\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>inv4: Key freshness for responder\\<close>"], ["", "(*inv**************************************************************************)"], ["", "definition \n  m1_inv4_rfresh :: \"'x m1_pred\"\nwhere\n  \"m1_inv4_rfresh \\<equiv> {s. \\<forall>Rb Rb' A A' B B' Kab.\n     runs s Rb  = Some (Resp, [A,  B ], [aKey Kab, END]) \\<longrightarrow> \n     runs s Rb' = Some (Resp, [A', B'], [aKey Kab, END]) \\<longrightarrow> \n     B \\<notin> bad \\<longrightarrow> A \\<notin> bad \\<longrightarrow> Kab \\<notin> Domain (leak s) \\<longrightarrow>\n       Rb = Rb'\n  }\""], ["", "lemmas m1_inv4_rfreshI = m1_inv4_rfresh_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1_inv4_rfreshE [elim] = m1_inv4_rfresh_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1_inv4_rfreshD = m1_inv4_rfresh_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Proof of key freshness for responder\\<close>"], ["", "lemma PO_m1_inv4_rfresh_init [iff]:\n  \"init m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1 \\<subseteq> m1_inv4_rfresh", "by (auto simp add: m1_defs intro!: m1_inv4_rfreshI)"], ["", "lemma PO_m1_inv4_rfresh_trans [iff]:\n  \"{m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv3_ifresh \\<inter> m1_secrecy} \n      trans m1 \n   {> m1_inv4_rfresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1_inv4_rfresh \\<inter> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter>\n     m1_inv3_ifresh \\<inter>\n     m1_secrecy} TS.trans m1 {> m1_inv4_rfresh}", "apply (simp add: PO_hoare_defs m1_defs, safe intro!: m1_inv4_rfreshI, simp_all)"], ["proof (prove)\ngoal (27 subgoals):\n 1. \\<And>Rb Rb' A A' B B' Kab xa xd.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        xd \\<notin> dom (runs xa); Rb \\<noteq> xd;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xd;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> Rb = Rb'\n 2. \\<And>Rb Rb' A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        xe \\<notin> dom (runs xa); Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> Rb = Rb'\n 3. \\<And>Rb Rb' A A' B B' Kab xa xf.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        xf \\<notin> dom (runs xa); Rb \\<noteq> xf;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xf;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> Rb = Rb'\n 4. \\<And>Rb Rb' A A' B B' Kab xa xb xc xd xi a b.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xd = Some (Init, [xb, xc], []); Rb \\<noteq> Rb';\n        (xi, a, b) \\<in> m1_state.leak xa; xb \\<in> bad; Rb \\<noteq> xd;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xd;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb Rb' A A' B B' Kab xa xb xc xd a b Rs.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xd = Some (Init, [xb, xc], []); Rb \\<noteq> Rb';\n        (sesK (Rs $ sk), a, b) \\<in> m1_state.leak xa;\n        runs xa Rs = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        Rb \\<noteq> xd; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        Rb' \\<noteq> xd;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>Rb Rb' A A' B B' Kab xa xb xc xd xi.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xd = Some (Init, [xb, xc], []);\n        (xi, xb) \\<in> azC (runs xa); Rb \\<noteq> Rb'; xb \\<in> bad;\n        Rb \\<noteq> xd; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        Rb' \\<noteq> xd;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>Rb Rb' A A' B B' Kab xa xb xc xd Rs.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xd = Some (Init, [xb, xc], []);\n        (sesK (Rs $ sk), xb) \\<in> azC (runs xa);\n        runs xa Rs = Some (Serv, [xb, xc], [aNon (xd $ na)]);\n        Rb \\<noteq> xd; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        Rb' \\<noteq> xd;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> Rb = Rb'\n 8. \\<And>Rb Rb' A A' B B' Kab xa xb xc xe xi a b.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [xb, xc], []); Rb \\<noteq> Rb';\n        (xi, a, b) \\<in> m1_state.leak xa; xc \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>Rb Rb' A A' B B' Kab xa xb xc xe a b Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [xb, xc], []); Rb \\<noteq> Rb';\n        (sesK (Rs $ sk), a, b) \\<in> m1_state.leak xa;\n        runs xa Rs = Some (Serv, [xb, xc], [aNon Na]); Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]); Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>Rb Rb' A A' B B' Kab xa xb xc xe xi.\n        \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n         Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n         xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n         xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n         runs xa xe = Some (Resp, [xb, xc], []);\n         (xi, xc) \\<in> azC (runs xa); Rb \\<noteq> Rb'; xc \\<in> bad;\n         Rb \\<noteq> xe; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n         Rb' \\<noteq> xe;\n         runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 27 subgoals...", "apply (auto dest: m1_inv4_rfreshD) \n\n\\<comment> \\<open>4 subgoals, from responder's final step 7\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); A' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rb A A' B B' Kab xa xe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); A' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac B=B in m1_inv2r_servD, fast, fast, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"B' \\<notin> bad\", auto dest: m1_inv2r_servD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(sesK (Rs$sk), B') \\<in> azC (runs xa)\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad;\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 3. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "prefer 2"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 2. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad;\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule m1_secrecyE, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        A' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]); B' \\<in> bad;\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule azC.cases, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rb A A' B B' Kab xa xe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]); B' \\<in> bad;\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac B=B in m1_inv2r_servD, fast, fast, clarify)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(sesK (Rs$sk), B') \\<in> azC (runs xa)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A A' B B' Kab xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 2. \\<And>Rb A A' B B' Kab xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule m1_secrecyE, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb A A' B B' xa xe Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk))]);\n        B' \\<in> bad; Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey (sesK (Rs $ sk)), END]);\n        runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule azC.cases, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rb' A A' B B' Kab xa xe Ra)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"A' \\<notin> bad \\<and> B' \\<notin> bad\", auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<notin> bad; B' \\<notin> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule m1_inv3r_initD, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<notin> bad; B' \\<notin> bad;\n        runs xa Raa =\n        Some (Init, [A', B'], aKey Kab # aNon (Rb' $ nb) # nla)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Raa nla)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<notin> bad; B' \\<notin> bad;\n        runs xa Raa =\n        Some (Init, [A', B'], aKey Kab # aNon (Rb' $ nb) # nla)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac Ra=Ra in m1_inv3_ifreshD, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<notin> bad; B' \\<notin> bad;\n        runs xa Raa =\n        Some (Init, [A', B'], aKey Kab # aNon (Rb' $ nb) # nla)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"Ra = Raa\", auto)\n\n    \\<comment> \\<open>@{text \"A' \\<in> bad\"}\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        A' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac B=B in m1_inv2r_servD, fast, fast, clarify)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rs Na)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"B' \\<notin> bad\", auto dest: m1_inv2r_servD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(sesK (Rs$sk), B') \\<in> azC (runs xa)\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad; (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 2. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad; (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule m1_secrecyE, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        A' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        B' \\<in> bad; (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule azC.cases, auto)\n\n    \\<comment> \\<open>@{text \"B' \\<in> bad\"}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey Kab]);\n        runs xa Ra = Some (Init, [A, B], [aKey Kab, aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey Kab, END]);\n        B' \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule_tac B=B in m1_inv2r_servD, fast, fast, clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Rs Na)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(sesK (Rs$sk), B') \\<in> azC (runs xa)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na])\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), B') \\<in> azC (runs xa)\n 2. \\<And>Rb' A A' B B' Kab xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule m1_secrecyE, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb' A A' B B' xa xe Ra Rs Na.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> Domain (m1_state.leak xa);\n        xa \\<in> m1_secrecy; xa \\<in> m1_inv3_ifresh;\n        xa \\<in> m1_inv2r_serv; xa \\<in> m1_inv4_rfresh;\n        xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A, B], [aKey (sesK (Rs $ sk))]);\n        runs xa Ra =\n        Some (Init, [A, B], [aKey (sesK (Rs $ sk)), aNon (xe $ nb)]);\n        Rb' \\<noteq> xe;\n        runs xa Rb' = Some (Resp, [A', B'], [aKey (sesK (Rs $ sk)), END]);\n        B' \\<in> bad; runs xa Rs = Some (Serv, [A, B], [aNon Na]);\n        (sesK (Rs $ sk), B') \\<in> azC (runs xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule azC.cases, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb A A' B B' Kab xa xe Ra.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe;\n        runs xa Rb = Some (Resp, [A, B], [aKey Kab, END])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule m1_inv3r_initD, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb A A' B B' Kab xa xe Ra Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        runs xa Raa =\n        Some (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rename_tac Raa nla)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rb A A' B B' Kab xa xe Ra Raa nla.\n       \\<lbrakk>B \\<notin> bad; A \\<notin> bad;\n        Kab \\<notin> Domain (m1_state.leak xa); xa \\<in> m1_secrecy;\n        xa \\<in> m1_inv3_ifresh; xa \\<in> m1_inv2r_serv;\n        xa \\<in> m1_inv4_rfresh; xa \\<in> m1_inv3r_init;\n        runs xa xe = Some (Resp, [A', B'], [aKey Kab]);\n        runs xa Ra = Some (Init, [A', B'], [aKey Kab, aNon (xe $ nb)]);\n        Rb \\<noteq> xe; runs xa Rb = Some (Resp, [A, B], [aKey Kab, END]);\n        runs xa Raa =\n        Some (Init, [A, B], aKey Kab # aNon (Rb $ nb) # nla)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"Raa = Ra\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_inv4_rfresh [iff]: \"reach m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1 \\<subseteq> m1_inv4_rfresh", "apply (rule_tac \n         J=\"m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv3_ifresh \\<inter> m1_secrecy\" \n       in inv_rule_incr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. init m1 \\<subseteq> m1_inv4_rfresh\n 2. {m1_inv4_rfresh \\<inter>\n     (m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter> m1_inv3_ifresh \\<inter>\n      m1_secrecy)} TS.trans m1 {> m1_inv4_rfresh}\n 3. reach m1\n    \\<subseteq> m1_inv3r_init \\<inter> m1_inv2r_serv \\<inter>\n                m1_inv3_ifresh \\<inter>\n                m1_secrecy", "apply (auto simp add: Int_assoc del: subsetI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1_obs_inv4_rfresh [iff]: \"oreach m1 \\<subseteq> m1_inv4_rfresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach m1 \\<subseteq> m1_inv4_rfresh", "by (rule external_from_internal_invariant)\n   (auto del: subsetI)"], ["", "end"]]}