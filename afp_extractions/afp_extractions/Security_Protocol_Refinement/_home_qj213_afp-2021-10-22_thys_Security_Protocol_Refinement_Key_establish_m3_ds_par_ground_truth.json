{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m3_ds_par.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemma corrKey_shrK_bad [simp]: \"corrKey = shrK`bad\"", "lemmas m3_loc_defs =\n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def m3_step4_def m3_step5_def\n  m3_tick_def m3_leak_def m3_DY_fake_def", "lemmas m3_defs = m3_loc_defs m2_defs", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]", "lemmas m3_inv1_lkeysecI = m3_inv1_lkeysec_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv1_lkeysecE [elim] = m3_inv1_lkeysec_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv1_lkeysecD = m3_inv1_lkeysec_def [THEN setc_def_to_dest, rule_format]", "lemma PO_m3_inv1_lkeysec_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_lkeysec\"", "lemma PO_m3_inv1_lkeysec_trans [iff]:\n  \"{m3_inv1_lkeysec} trans m3 {> m3_inv1_lkeysec}\"", "lemma PO_m3_inv1_lkeysec [iff]: \"reach m3 \\<subseteq> m3_inv1_lkeysec\"", "lemma m3_inv1_lkeysec_for_parts [simp]:\n  \"\\<lbrakk> s \\<in> m3_inv1_lkeysec \\<rbrakk> \\<Longrightarrow> Key (shrK C) \\<in> parts (IK s) \\<longleftrightarrow> C \\<in> bad\"", "lemma m3_inv1_lkeysec_for_analz [simp]:\n  \"\\<lbrakk> s \\<in> m3_inv1_lkeysec \\<rbrakk> \\<Longrightarrow> Key (shrK C) \\<in> analz (IK s) \\<longleftrightarrow> C \\<in> bad\"", "lemmas m3_inv3_sesK_comprI = m3_inv3_sesK_compr_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv3_sesK_comprE = m3_inv3_sesK_compr_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv3_sesK_comprD = m3_inv3_sesK_compr_def [THEN setc_def_to_dest, rule_format]", "lemmas insert_commute_Key = insert_commute [where x=\"Key K\" for K]", "lemmas m3_inv3_sesK_compr_simps =\n  m3_inv3_sesK_comprD\n  m3_inv3_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  m3_inv3_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  insert_commute_Key", "lemmas R23_defs =\n  R23_def R23_msgs_def R23_keys_def R23_pres_def", "lemmas R23_msgsI = R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_msgsE [elim] = R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_keysI = R23_keys_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_keysE [elim] = R23_keys_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_presI = R23_pres_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_presE [elim] = R23_pres_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_intros = R23_msgsI R23_keysI R23_presI", "lemmas R23_keys_simp = R23_keys_def [THEN rel_def_to_dest, simplified, rule_format]", "lemmas R23_keys_simps =\n  R23_keys_simp\n  R23_keys_simp [where KK=\"{}\", simplified]\n  R23_keys_simp [where KK=\"{K'}\" for K', simplified]\n  R23_keys_simp [where KK=\"insert K' KK\" for K' KK, simplified, OF _ conjI]", "lemma abs_msg_empty: \"abs_msg {} = {}\"", "lemma abs_msg_Un [simp]:\n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\"", "lemma abs_msg_mono [elim]:\n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\"", "lemma abs_msg_insert_mono [intro]:\n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\"", "lemma abs_msg_DY_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys; t \\<in> m3_inv1_lkeysec \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\"", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23}\n     (m2_step1 Ra A B), (m3_step1 Ra A B)\n   {> R23}\"", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23}\n     (m2_step2 Rb A B), (m3_step2 Rb A B)\n   {> R23}\"", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv3_sesK_compr \\<inter> m3_inv1_lkeysec)}\n     (m2_step3 Rs A B Kab Ts), (m3_step3 Rs A B Kab Ts)\n   {> R23}\"", "lemma PO_m3_step4_refines_m2_step4:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec)}\n     (m2_step4 Ra A B Kab Ts), (m3_step4 Ra A B Kab Ts)\n   {> R23}\"", "lemma PO_m3_step5_refines_m2_step5:\n  \"{R23}\n     (m2_step5 Rb A B Kab Ts), (m3_step5 Rb A B Kab Ts)\n   {> R23}\"", "lemma PO_m3_tick_refines_m2_tick:\n  \"{R23}\n     (m2_tick T), (m3_tick T)\n   {>R23}\"", "lemma PO_m3_leak_refines_m2_leak:\n  \"{R23}\n     (m2_leak Rs), (m3_leak Rs)\n   {>R23}\"", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec)}\n     m2_fake, m3_DY_fake\n   {> R23}\"", "lemmas PO_m3_trans_refines_m2_trans =\n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2\n  PO_m3_step3_refines_m2_step3 PO_m3_step4_refines_m2_step4\n  PO_m3_step5_refines_m2_step5 PO_m3_tick_refines_m2_tick\n  PO_m3_leak_refines_m2_leak PO_m3_DY_fake_refines_m2_fake", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\"", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv3_sesK_compr \\<inter> m3_inv1_lkeysec)}\n     (trans m2), (trans m3)\n   {> R23}\"", "lemma PO_m3_observation_consistent [iff]:\n  \"obs_consistent R23 med32 m2 m3\"", "lemma m3_refines_m2 [iff]:\n  \"refines\n     (R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv1_lkeysec))\n     med32 m2 m3\"", "lemma m3_implements_m2 [iff]:\n  \"implements med32 m2 m3\""], "translations": [["", "lemma corrKey_shrK_bad [simp]: \"corrKey = shrK`bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corrKey = shrK ` bad", "by (auto simp add: keySetup_def ltkeySetup_def corrKey_def)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>State\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The secure channels are star-shaped to/from the server.  Therefore,\nwe have only one agent in the relation.\\<close>"], ["", "record m3_state = \"m1_state\" +\n  IK :: \"msg set\"                                \\<comment> \\<open>intruder knowledge\\<close>"], ["", "text \\<open>Observable state:\n@{term \"runs\"}, @{term \"leak\"}, @{term \"clk\"}, and @{term \"cache\"}.\\<close>"], ["", "type_synonym\n  m3_obs = \"m2_obs\""], ["", "definition\n  m3_obs :: \"m3_state \\<Rightarrow> m3_obs\" where\n  \"m3_obs s \\<equiv> \\<lparr> runs = runs s, leak = leak s, clk = clk s \\<rparr>\""], ["", "type_synonym\n  m3_pred = \"m3_state set\""], ["", "type_synonym\n  m3_trans = \"(m3_state \\<times> m3_state) set\""], ["", "(******************************************************************************)"], ["", "subsection \\<open>Events\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Protocol events.\\<close>"], ["", "definition     \\<comment> \\<open>by @{term \"A\"}, refines @{term \"m2_step1\"}\\<close>\n  m3_step1 :: \"[rid_t, agent, agent] \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_step1 Ra A B \\<equiv> {(s, s1).\n    \\<comment> \\<open>guards:\\<close>\n    Ra \\<notin> dom (runs s) \\<and>                                \\<comment> \\<open>\\<open>Ra\\<close> is fresh\\<close>\n\n    \\<comment> \\<open>actions:\\<close>\n    s1 = s\\<lparr>\n      runs := (runs s)(Ra \\<mapsto> (Init, [A, B], [])),\n      IK := insert \\<lbrace>Agent A, Agent B\\<rbrace> (IK s)        \\<comment> \\<open>send \\<open>M1\\<close>\\<close>\n    \\<rparr>\n  }\""], ["", "definition     \\<comment> \\<open>by @{term \"B\"}, refines @{term \"m2_step2\"}\\<close>\n  m3_step2 :: \"[rid_t, agent, agent] \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_step2 \\<equiv> m1_step2\""], ["", "definition     \\<comment> \\<open>by @{text \"Server\"}, refines @{term m2_step3}\\<close>\n  m3_step3 :: \"[rid_t, agent, agent, key, time] \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_step3 Rs A B Kab Ts \\<equiv> {(s, s1).\n    \\<comment> \\<open>guards:\\<close>\n    Rs \\<notin> dom (runs s) \\<and>                           \\<comment> \\<open>fresh server run\\<close>\n    Kab = sesK (Rs$sk) \\<and>                          \\<comment> \\<open>fresh session key\\<close>\n\n     \\<lbrace>Agent A, Agent B\\<rbrace> \\<in> IK s \\<and>                   \\<comment> \\<open>recv \\<open>M1\\<close>\\<close>\n     Ts = clk s \\<and>                                   \\<comment> \\<open>fresh timestamp\\<close>\n\n     \\<comment> \\<open>actions:\\<close>\n     \\<comment> \\<open>record session key and send \\<open>M2\\<close>\\<close>\n     s1 = s\\<lparr>\n       runs := (runs s)(Rs \\<mapsto> (Serv, [A, B], [aNum Ts])),   \\<comment> \\<open>send \\<open>M2a\\<close>, \\<open>M2b\\<close>\\<close>\n       IK := insert (Crypt (shrK A) \\<lbrace>Agent B, Key Kab, Number Ts\\<rbrace>)\n             (insert (Crypt (shrK B) \\<lbrace>Key Kab, Agent A, Number Ts\\<rbrace>) (IK s))\n     \\<rparr>\n  }\""], ["", "definition     \\<comment> \\<open>by @{term \"A\"}, refines @{term m2_step4}\\<close>\n  m3_step4 :: \"[rid_t, agent, agent, key, time] \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_step4 Ra A B Kab Ts \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>guards:\\<close>\n     runs s Ra = Some (Init, [A, B], []) \\<and>           \\<comment> \\<open>key not yet recv'd\\<close>\n\n     Crypt (shrK A)                                  \\<comment> \\<open>recv \\<open>M2\\<close>\\<close>\n       \\<lbrace>Agent B, Key Kab, Number Ts\\<rbrace> \\<in> IK s \\<and>\n\n     \\<comment> \\<open>check freshness of session key\\<close>\n     clk s < Ts + Ls \\<and>\n\n     \\<comment> \\<open>actions:\\<close>\n     \\<comment> \\<open>record session key\\<close>\n     s1 = s\\<lparr>\n       runs := (runs s)(Ra \\<mapsto> (Init, [A, B], [aKey Kab, aNum Ts]))\n     \\<rparr>\n  }\""], ["", "definition     \\<comment> \\<open>by @{term \"B\"}, refines @{term m2_step5}\\<close>\n  m3_step5 :: \"[rid_t, agent, agent, key, time] \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_step5 Rb A B Kab Ts \\<equiv> {(s, s1).\n     \\<comment> \\<open>guards:\\<close>\n     runs s Rb = Some (Resp, [A, B], []) \\<and>             \\<comment> \\<open>key not yet recv'd\\<close>\n\n     Crypt (shrK B) \\<lbrace>Key Kab, Agent A, Number Ts\\<rbrace> \\<in> IK s \\<and>    \\<comment> \\<open>recv \\<open>M3\\<close>\\<close>\n\n     \\<comment> \\<open>ensure freshness of session key; replays with fresh authenticator ok!\\<close>\n     clk s < Ts + Ls \\<and>\n\n     \\<comment> \\<open>actions:\\<close>\n     \\<comment> \\<open>record session key\\<close>\n     s1 = s\\<lparr>\n       runs := (runs s)(Rb \\<mapsto> (Resp, [A, B], [aKey Kab, aNum Ts]))\n     \\<rparr>\n  }\""], ["", "text \\<open>Clock tick event\\<close>"], ["", "definition   \\<comment> \\<open>refines @{term \"m2_tick\"}\\<close>\n  m3_tick :: \"time \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_tick \\<equiv> m1_tick\""], ["", "text \\<open>Session key compromise.\\<close>"], ["", "definition     \\<comment> \\<open>refines @{term m2_leak}\\<close>\n  m3_leak :: \"rid_t \\<Rightarrow> m3_trans\"\nwhere\n  \"m3_leak Rs \\<equiv> {(s, s1).\n    \\<comment> \\<open>guards:\\<close>\n    Rs \\<in> dom (runs s) \\<and>\n    fst (the (runs s Rs)) = Serv \\<and>         \\<comment> \\<open>compromise server run \\<open>Rs\\<close>\\<close>\n\n    \\<comment> \\<open>actions:\\<close>\n    \\<comment> \\<open>record session key as leaked and add it to intruder knowledge\\<close>\n    s1 = s\\<lparr> leak := insert (sesK (Rs$sk)) (leak s),\n            IK := insert (Key (sesK (Rs$sk))) (IK s) \\<rparr>\n  }\""], ["", "text \\<open>Intruder fake event. The following \"Dolev-Yao\" event generates all\nintruder-derivable messages.\\<close>"], ["", "definition     \\<comment> \\<open>refines @{term \"m2_fake\"}\\<close>\n  m3_DY_fake :: \"m3_trans\"\nwhere\n  \"m3_DY_fake \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>actions:\\<close>\n     s1 = s\\<lparr> IK := synth (analz (IK s)) \\<rparr>       \\<comment> \\<open>take DY closure\\<close>\n  }\""], ["", "(******************************************************************************)"], ["", "subsection \\<open>Transition system\\<close>"], ["", "(******************************************************************************)"], ["", "definition\n  m3_init :: \"m3_pred\"\nwhere\n  \"m3_init \\<equiv> { \\<lparr>\n     runs = Map.empty,\n     leak = shrK`bad,\n     clk = 0,\n     IK = Key`shrK`bad\n  \\<rparr> }\""], ["", "definition\n  m3_trans :: \"m3_trans\" where\n  \"m3_trans \\<equiv> (\\<Union>A B Ra Rb Rs Kab Ts T.\n     m3_step1 Ra A B \\<union>\n     m3_step2 Rb A B \\<union>\n     m3_step3 Rs A B Kab Ts \\<union>\n     m3_step4 Ra A B Kab Ts \\<union>\n     m3_step5 Rb A B Kab Ts \\<union>\n     m3_tick T \\<union>\n     m3_leak Rs \\<union>\n     m3_DY_fake \\<union>\n     Id\n  )\""], ["", "definition\n  m3 :: \"(m3_state, m3_obs) spec\" where\n  \"m3 \\<equiv> \\<lparr>\n    init = m3_init,\n    trans = m3_trans,\n    obs = m3_obs\n  \\<rparr>\""], ["", "lemmas m3_loc_defs =\n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def m3_step4_def m3_step5_def\n  m3_tick_def m3_leak_def m3_DY_fake_def"], ["", "lemmas m3_defs = m3_loc_defs m2_defs"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Specialized injection that we can apply more aggressively.\\<close>"], ["", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]"], ["", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]"], ["", "declare parts_Inj_IK [dest!]"], ["", "declare analz_into_parts [dest]"], ["", "subsubsection \\<open>inv1: Secrecy of pre-distributed shared keys\\<close>"], ["", "(******************************************************************************)"], ["", "definition\n  m3_inv1_lkeysec :: \"m3_pred\"\nwhere\n  \"m3_inv1_lkeysec \\<equiv> {s. \\<forall>C.\n     (Key (shrK C) \\<in> parts (IK s) \\<longrightarrow> C \\<in> bad) \\<and>\n     (C \\<in> bad \\<longrightarrow> Key (shrK C) \\<in> IK s)\n  }\""], ["", "lemmas m3_inv1_lkeysecI = m3_inv1_lkeysec_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv1_lkeysecE [elim] = m3_inv1_lkeysec_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv1_lkeysecD = m3_inv1_lkeysec_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m3_inv1_lkeysec_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_lkeysec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> m3_inv1_lkeysec", "by (auto simp add: m3_defs intro!: m3_inv1_lkeysecI)"], ["", "lemma PO_m3_inv1_lkeysec_trans [iff]:\n  \"{m3_inv1_lkeysec} trans m3 {> m3_inv1_lkeysec}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m3_inv1_lkeysec} TS.trans m3 {> m3_inv1_lkeysec}", "by (fastforce simp add: PO_hoare_defs m3_defs intro!: m3_inv1_lkeysecI)"], ["", "lemma PO_m3_inv1_lkeysec [iff]: \"reach m3 \\<subseteq> m3_inv1_lkeysec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m3 \\<subseteq> m3_inv1_lkeysec", "by (rule inv_rule_incr) (fast+)"], ["", "text \\<open>Useful simplifier lemmas\\<close>"], ["", "lemma m3_inv1_lkeysec_for_parts [simp]:\n  \"\\<lbrakk> s \\<in> m3_inv1_lkeysec \\<rbrakk> \\<Longrightarrow> Key (shrK C) \\<in> parts (IK s) \\<longleftrightarrow> C \\<in> bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> m3_inv1_lkeysec \\<Longrightarrow>\n    (Key (shrK C) \\<in> parts (IK s)) = (C \\<in> bad)", "by auto"], ["", "lemma m3_inv1_lkeysec_for_analz [simp]:\n  \"\\<lbrakk> s \\<in> m3_inv1_lkeysec \\<rbrakk> \\<Longrightarrow> Key (shrK C) \\<in> analz (IK s) \\<longleftrightarrow> C \\<in> bad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> m3_inv1_lkeysec \\<Longrightarrow>\n    (Key (shrK C) \\<in> analz (IK s)) = (C \\<in> bad)", "by auto"], ["", "subsubsection \\<open>inv3: Session keys not used to encrypt other session keys\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Session keys are not used to encrypt other keys. Proof requires\ngeneralization to sets of session keys.\n\nNOTE: This invariant will be derived from the corresponding L2 invariant\nusing the simulation relation.\n\\<close>"], ["", "definition\n  m3_inv3_sesK_compr :: \"m3_pred\"\nwhere\n  \"m3_inv3_sesK_compr \\<equiv> {s. \\<forall>K KK.\n     KK \\<subseteq> range sesK \\<longrightarrow>\n     (Key K \\<in> analz (Key`KK \\<union> (IK s))) = (K \\<in> KK \\<or> Key K \\<in> analz (IK s))\n  }\""], ["", "lemmas m3_inv3_sesK_comprI = m3_inv3_sesK_compr_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv3_sesK_comprE = m3_inv3_sesK_compr_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv3_sesK_comprD = m3_inv3_sesK_compr_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Additional lemma\\<close>"], ["", "lemmas insert_commute_Key = insert_commute [where x=\"Key K\" for K]"], ["", "lemmas m3_inv3_sesK_compr_simps =\n  m3_inv3_sesK_comprD\n  m3_inv3_sesK_comprD [where KK=\"insert Kab KK\" for Kab KK, simplified]\n  m3_inv3_sesK_comprD [where KK=\"{Kab}\" for Kab, simplified]\n  insert_commute_Key"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Message abstraction and simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Abstraction function on sets of messages.\\<close>"], ["", "inductive_set\n  abs_msg :: \"msg set \\<Rightarrow> chmsg set\"\n  for H :: \"msg set\"\nwhere\n  am_M1:\n    \"\\<lbrace>Agent A, Agent B\\<rbrace> \\<in> H\n  \\<Longrightarrow> Insec A B (Msg []) \\<in> abs_msg H\"\n| am_M2a:\n    \"Crypt (shrK C) \\<lbrace>Agent B, Key K, Number T\\<rbrace> \\<in> H\n  \\<Longrightarrow> Secure Sv C (Msg [aAgt B, aKey K, aNum T]) \\<in> abs_msg H\"\n| am_M2b:\n    \"Crypt (shrK C) \\<lbrace>Key K, Agent A, Number T\\<rbrace> \\<in> H\n  \\<Longrightarrow> Secure Sv C (Msg [aKey K, aAgt A, aNum T]) \\<in> abs_msg H\""], ["", "text \\<open>R23: The simulation relation. This is a data refinement of\nthe insecure and secure channels of refinement 2.\\<close>"], ["", "definition\n  R23_msgs :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_msgs \\<equiv> {(s, t). abs_msg (parts (IK t)) \\<subseteq> chan s }\""], ["", "definition\n  R23_keys :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_keys \\<equiv> {(s, t). \\<forall>KK K. KK \\<subseteq> range sesK \\<longrightarrow>\n     Key K \\<in> analz (Key`KK \\<union> (IK t)) \\<longleftrightarrow> aKey K \\<in> extr (aKey`KK \\<union> ik0) (chan s)\n  }\""], ["", "definition\n  R23_pres :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_pres \\<equiv> {(s, t). runs s = runs t \\<and> leak s = leak t \\<and> clk s = clk t}\""], ["", "definition\n  R23 :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23 \\<equiv> R23_msgs \\<inter> R23_keys \\<inter> R23_pres\""], ["", "lemmas R23_defs =\n  R23_def R23_msgs_def R23_keys_def R23_pres_def"], ["", "text \\<open>The mediator function is the identity here.\\<close>"], ["", "definition\n  med32 :: \"m3_obs \\<Rightarrow> m2_obs\" where\n  \"med32 \\<equiv> id\""], ["", "lemmas R23_msgsI = R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_msgsE [elim] = R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_keysI = R23_keys_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_keysE [elim] = R23_keys_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_presI = R23_pres_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_presE [elim] = R23_pres_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_intros = R23_msgsI R23_keysI R23_presI"], ["", "text \\<open>Simplifier lemmas for various instantiations (for keys).\\<close>"], ["", "lemmas R23_keys_simp = R23_keys_def [THEN rel_def_to_dest, simplified, rule_format]"], ["", "lemmas R23_keys_simps =\n  R23_keys_simp\n  R23_keys_simp [where KK=\"{}\", simplified]\n  R23_keys_simp [where KK=\"{K'}\" for K', simplified]\n  R23_keys_simp [where KK=\"insert K' KK\" for K' KK, simplified, OF _ conjI]"], ["", "subsubsection \\<open>General lemmas\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>General facts about @{term \"abs_msg\"}\\<close>"], ["", "declare abs_msg.intros [intro!]"], ["", "declare abs_msg.cases [elim!]"], ["", "lemma abs_msg_empty: \"abs_msg {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg {} = {}", "by (auto)"], ["", "lemma abs_msg_Un [simp]:\n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H", "by (auto)"], ["", "lemma abs_msg_mono [elim]:\n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> abs_msg G; G \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> m \\<in> abs_msg H", "by (auto)"], ["", "lemma abs_msg_insert_mono [intro]:\n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> abs_msg H \\<Longrightarrow> m \\<in> abs_msg (insert m' H)", "by (auto)"], ["", "text \\<open>Facts about @{term \"abs_msg\"} concerning abstraction of fakeable\nmessages. This is crucial for proving the refinement of the intruder event.\\<close>"], ["", "lemma abs_msg_DY_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys; t \\<in> m3_inv1_lkeysec \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n     t \\<in> m3_inv1_lkeysec\\<rbrakk>\n    \\<Longrightarrow> abs_msg (synth (analz (IK t)))\n                      \\<subseteq> fake ik0 (dom (runs s)) (chan s)", "apply (auto)\n\\<comment> \\<open>4 subgoals, deal with replays first\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>C B K T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (shrK C) \\<lbrace>msg.Agent B, Key K, Number T\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aAgt B, aKey K, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>C B K T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aAgt B, aKey K, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (shrK C) \\<lbrace>Key K, msg.Agent A, Number T\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 4. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C B K T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aAgt B, aKey K, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (shrK C) \\<lbrace>Key K, msg.Agent A, Number T\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "defer 1"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (shrK C) \\<lbrace>Key K, msg.Agent A, Number T\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>C B K T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aAgt B, aKey K, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (blast)\n\\<comment> \\<open>remaining 2 subgoals are real fakes\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C K A T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aKey K, aAgt A, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>C B K T.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_keys;\n        t \\<in> m3_inv1_lkeysec; C \\<in> bad;\n        Key K \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> StatCh secure Sv C (Msg [aAgt B, aKey K, aNum T])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_StatCh, auto simp add: R23_keys_simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Pair decomposition. These were set to \\texttt{elim!}, which is too\nagressive here.\\<close>"], ["", "declare MPair_analz [rule del, elim]"], ["", "declare MPair_parts [rule del, elim]"], ["", "text \\<open>Protocol events.\\<close>"], ["", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23}\n     (m2_step1 Ra A B), (m3_step1 Ra A B)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step1 Ra A B, m3_step1 Ra A B {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23}\n     (m2_step2 Rb A B), (m3_step2 Rb A B)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step2 Rb A B, m3_step2 Rb A B {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv3_sesK_compr \\<inter> m3_inv1_lkeysec)}\n     (m2_step3 Rs A B Kab Ts), (m3_step3 Rs A B Kab Ts)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "assume H:\n      \"(s, t) \\<in> R23_msgs\" \"(s, t) \\<in> R23_keys\" \"(s, t) \\<in> R23_pres\"\n      \"s \\<in> m2_inv3a_sesK_compr\" \"t \\<in> m3_inv3_sesK_compr\" \"t \\<in> m3_inv1_lkeysec\"\n      \"Kab = sesK (Rs$sk)\" \"Rs \\<notin> dom (runs t)\"\n      \"\\<lbrace> Agent A, Agent B \\<rbrace> \\<in> parts (IK t)\""], ["proof (state)\nthis:\n  (s, t) \\<in> R23_msgs\n  (s, t) \\<in> R23_keys\n  (s, t) \\<in> R23_pres\n  s \\<in> m2_inv3a_sesK_compr\n  t \\<in> m3_inv3_sesK_compr\n  t \\<in> m3_inv1_lkeysec\n  Kab = sesK (Rs $ sk)\n  Rs \\<notin> dom (runs t)\n  \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK t)\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "let ?s'=\n      \"s\\<lparr> runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n          chan := insert (Secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n                 (insert (Secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)])) (chan s)) \\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "let ?t'=\n      \"t\\<lparr> runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n          IK := insert\n                  (Crypt (shrK A) \\<lbrace> Agent B, Key Kab, Number (clk t) \\<rbrace>)\n                (insert\n                  (Crypt (shrK B) \\<lbrace> Key Kab, Agent A, Number (clk t) \\<rbrace>)\n                (IK t)) \\<rparr>\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "have \"(?s', ?t') \\<in> R23_msgs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_msgs", "using H"], ["proof (prove)\nusing this:\n  (s, t) \\<in> R23_msgs\n  (s, t) \\<in> R23_keys\n  (s, t) \\<in> R23_pres\n  s \\<in> m2_inv3a_sesK_compr\n  t \\<in> m3_inv3_sesK_compr\n  t \\<in> m3_inv1_lkeysec\n  Kab = sesK (Rs $ sk)\n  Rs \\<notin> dom (runs t)\n  \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK t)\n\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_msgs", "by (-) (rule R23_intros, auto)"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_msgs\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "moreover"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_msgs\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "have \"(?s', ?t') \\<in> R23_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_keys", "using H"], ["proof (prove)\nusing this:\n  (s, t) \\<in> R23_msgs\n  (s, t) \\<in> R23_keys\n  (s, t) \\<in> R23_pres\n  s \\<in> m2_inv3a_sesK_compr\n  t \\<in> m3_inv3_sesK_compr\n  t \\<in> m3_inv1_lkeysec\n  Kab = sesK (Rs $ sk)\n  Rs \\<notin> dom (runs t)\n  \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK t)\n\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_keys", "by (-) (rule R23_intros,\n            auto simp add: m2_inv3a_sesK_compr_simps m3_inv3_sesK_compr_simps,\n            auto simp add: R23_keys_simps)"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_keys\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "moreover"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_keys\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "have \"(?s', ?t') \\<in> R23_pres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_pres", "using H"], ["proof (prove)\nusing this:\n  (s, t) \\<in> R23_msgs\n  (s, t) \\<in> R23_keys\n  (s, t) \\<in> R23_pres\n  s \\<in> m2_inv3a_sesK_compr\n  t \\<in> m3_inv3_sesK_compr\n  t \\<in> m3_inv1_lkeysec\n  Kab = sesK (Rs $ sk)\n  Rs \\<notin> dom (runs t)\n  \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK t)\n\ngoal (1 subgoal):\n 1. (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         chan :=\n           insert\n            (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n            (insert\n              (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n              (chan s))\\<rparr>,\n     t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n         IK :=\n           insert\n            (Crypt (shrK A)\n              \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n            (insert\n              (Crypt (shrK B)\n                \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n              (IK t))\\<rparr>)\n    \\<in> R23_pres", "by (-) (rule R23_intros, auto)"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_pres\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "moreover"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_pres\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "note calculation"], ["proof (state)\nthis:\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_msgs\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_keys\n  (s\\<lparr>runs := runs s(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       chan :=\n         insert (StatCh secure Sv A (Msg [aAgt B, aKey Kab, aNum (clk t)]))\n          (insert\n            (StatCh secure Sv B (Msg [aKey Kab, aAgt A, aNum (clk t)]))\n            (chan s))\\<rparr>,\n   t\\<lparr>runs := runs t(Rs \\<mapsto> (Serv, [A, B], [aNum (clk t)])),\n       IK :=\n         insert\n          (Crypt (shrK A)\n            \\<lbrace>msg.Agent B, Key Kab, Number (clk t)\\<rbrace>)\n          (insert\n            (Crypt (shrK B)\n              \\<lbrace>Key Kab, msg.Agent A, Number (clk t)\\<rbrace>)\n            (IK t))\\<rparr>)\n  \\<in> R23_pres\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_msgs\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_keys\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_pres\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_msgs\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_keys\n  \\<lbrakk>(?s2, ?t2) \\<in> R23_msgs; (?s2, ?t2) \\<in> R23_keys;\n   (?s2, ?t2) \\<in> R23_pres; ?s2 \\<in> m2_inv3a_sesK_compr;\n   ?t2 \\<in> m3_inv3_sesK_compr; ?t2 \\<in> m3_inv1_lkeysec;\n   Kab = sesK (Rs $ sk); Rs \\<notin> dom (runs ?t2);\n   \\<lbrace>msg.Agent A, msg.Agent B\\<rbrace> \\<in> parts (IK ?t2)\\<rbrakk>\n  \\<Longrightarrow> (?s2\\<lparr>runs := runs ?s2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           chan :=\n                             insert\n                              (StatCh secure Sv A\n                                (Msg [aAgt B, aKey Kab, aNum (clk ?t2)]))\n                              (insert\n                                (StatCh secure Sv B\n                                  (Msg [aKey Kab, aAgt A, aNum (clk ?t2)]))\n                                (chan ?s2))\\<rparr>,\n                     ?t2\\<lparr>runs := runs ?t2(Rs \\<mapsto>\n                                  (Serv, [A, B], [aNum (clk ?t2)])),\n                           IK :=\n                             insert\n                              (Crypt (shrK A)\n                                \\<lbrace>msg.Agent B, Key Kab,\n                                  Number (clk ?t2)\\<rbrace>)\n                              (insert\n                                (Crypt (shrK B)\n                                  \\<lbrace>Key Kab, msg.Agent A,\n                                    Number (clk ?t2)\\<rbrace>)\n                                (IK ?t2))\\<rparr>)\n                    \\<in> R23_pres\n\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} m2_step3 Rs A B Kab\n                         Ts, m3_step3 Rs A B Kab Ts {> R23}", "by  (auto simp add: PO_rhoare_defs R23_def m3_defs)"], ["proof (state)\nthis:\n  {R23 \\<inter>\n   m2_inv3a_sesK_compr \\<times>\n   (m3_inv3_sesK_compr \\<inter>\n    m3_inv1_lkeysec)} m2_step3 Rs A B Kab Ts, m3_step3 Rs A B Kab Ts {> R23}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_m3_step4_refines_m2_step4:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec)}\n     (m2_step4 Ra A B Kab Ts), (m3_step4 Ra A B Kab Ts)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times>\n     m3_inv1_lkeysec} m2_step4 Ra A B Kab Ts, m3_step4 Ra A B Kab Ts {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step5_refines_m2_step5:\n  \"{R23}\n     (m2_step5 Rb A B Kab Ts), (m3_step5 Rb A B Kab Ts)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step5 Rb A B Kab Ts, m3_step5 Rb A B Kab Ts {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_tick_refines_m2_tick:\n  \"{R23}\n     (m2_tick T), (m3_tick T)\n   {>R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_tick T, m3_tick T {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros)\n   (auto)"], ["", "text \\<open>Intruder events.\\<close>"], ["", "lemma PO_m3_leak_refines_m2_leak:\n  \"{R23}\n     (m2_leak Rs), (m3_leak Rs)\n   {>R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_leak Rs, m3_leak Rs {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m3_defs  intro!: R23_intros)\n   (auto simp add: R23_keys_simps)"], ["", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec)}\n     m2_fake, m3_DY_fake\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter> UNIV \\<times> m3_inv1_lkeysec} m2_fake, m3_DY_fake {> R23}", "apply (auto simp add: PO_rhoare_defs R23_def m3_defs intro!: R23_intros\n            del: abs_msg.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a y x.\n       \\<lbrakk>(a, y) \\<in> R23_msgs; (a, y) \\<in> R23_keys;\n        (a, y) \\<in> R23_pres; y \\<in> m3_inv1_lkeysec;\n        x \\<in> abs_msg (parts (IK y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fake ik0 (dom (runs a)) (chan a)\n 2. \\<And>a y x.\n       \\<lbrakk>(a, y) \\<in> R23_msgs; (a, y) \\<in> R23_keys;\n        (a, y) \\<in> R23_pres; y \\<in> m3_inv1_lkeysec;\n        x \\<in> abs_msg (synth (analz (IK y)))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fake ik0 (dom (runs a)) (chan a)\n 3. \\<And>a y KK K.\n       \\<lbrakk>(a, y) \\<in> R23_msgs; (a, y) \\<in> R23_keys;\n        (a, y) \\<in> R23_pres; y \\<in> m3_inv1_lkeysec;\n        KK \\<subseteq> range sesK;\n        Key K \\<in> analz (Key ` KK \\<union> IK y)\\<rbrakk>\n       \\<Longrightarrow> aKey K \\<in> extr (aKey ` KK \\<union> ik0) (chan a)\n 4. \\<And>a y KK K.\n       \\<lbrakk>(a, y) \\<in> R23_msgs; (a, y) \\<in> R23_keys;\n        (a, y) \\<in> R23_pres; y \\<in> m3_inv1_lkeysec;\n        KK \\<subseteq> range sesK; Key K \\<in> analz (IK y)\\<rbrakk>\n       \\<Longrightarrow> aKey K \\<in> extr (aKey ` KK \\<union> ik0) (chan a)", "apply (auto intro: abs_msg_DY_subset_fakeable [THEN subsetD]\n            del: abs_msg.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y KK K.\n       \\<lbrakk>(a, y) \\<in> R23_msgs; (a, y) \\<in> R23_keys;\n        (a, y) \\<in> R23_pres; y \\<in> m3_inv1_lkeysec;\n        KK \\<subseteq> range sesK; Key K \\<in> analz (IK y)\\<rbrakk>\n       \\<Longrightarrow> aKey K \\<in> extr (aKey ` KK \\<union> ik0) (chan a)", "apply (auto simp add: R23_keys_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m3_trans_refines_m2_trans =\n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2\n  PO_m3_step3_refines_m2_step3 PO_m3_step4_refines_m2_step4\n  PO_m3_step5_refines_m2_step5 PO_m3_tick_refines_m2_tick\n  PO_m3_leak_refines_m2_leak PO_m3_DY_fake_refines_m2_fake"], ["", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> R23 `` init m2", "by (auto simp add: R23_def m3_defs intro!: R23_intros)"], ["", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv3_sesK_compr \\<inter> m3_inv1_lkeysec)}\n     (trans m2), (trans m3)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     m2_inv3a_sesK_compr \\<times>\n     (m3_inv3_sesK_compr \\<inter>\n      m3_inv1_lkeysec)} TS.trans m2, TS.trans m3 {> R23}", "by (auto simp add: m3_def m3_trans_def m2_def m2_trans_def)\n   (blast intro!: PO_m3_trans_refines_m2_trans)+"], ["", "lemma PO_m3_observation_consistent [iff]:\n  \"obs_consistent R23 med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R23 med32 m2 m3", "by (auto simp add: obs_consistent_def R23_def med32_def m3_defs)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma m3_refines_m2 [iff]:\n  \"refines\n     (R23 \\<inter> (m2_inv3a_sesK_compr) \\<times> (m3_inv1_lkeysec))\n     med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R23 \\<inter> m2_inv3a_sesK_compr \\<times> m3_inv1_lkeysec)\n     med32 m2 m3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. refines (R23 \\<inter> m2_inv3a_sesK_compr \\<times> m3_inv1_lkeysec)\n     med32 m2 m3", "have \"R23 \\<inter> m2_inv3a_sesK_compr \\<times> UNIV \\<subseteq> UNIV \\<times> m3_inv3_sesK_compr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R23 \\<inter> m2_inv3a_sesK_compr \\<times> UNIV\n    \\<subseteq> UNIV \\<times> m3_inv3_sesK_compr", "by (auto simp add: R23_def R23_keys_simps intro!: m3_inv3_sesK_comprI)"], ["proof (state)\nthis:\n  R23 \\<inter> m2_inv3a_sesK_compr \\<times> UNIV\n  \\<subseteq> UNIV \\<times> m3_inv3_sesK_compr\n\ngoal (1 subgoal):\n 1. refines (R23 \\<inter> m2_inv3a_sesK_compr \\<times> m3_inv1_lkeysec)\n     med32 m2 m3", "thus ?thesis"], ["proof (prove)\nusing this:\n  R23 \\<inter> m2_inv3a_sesK_compr \\<times> UNIV\n  \\<subseteq> UNIV \\<times> m3_inv3_sesK_compr\n\ngoal (1 subgoal):\n 1. refines (R23 \\<inter> m2_inv3a_sesK_compr \\<times> m3_inv1_lkeysec)\n     med32 m2 m3", "by (-) (rule Refinement_using_invariants, auto)"], ["proof (state)\nthis:\n  refines (R23 \\<inter> m2_inv3a_sesK_compr \\<times> m3_inv1_lkeysec) med32\n   m2 m3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m3_implements_m2 [iff]:\n  \"implements med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med32 m2 m3", "by (rule refinement_soundness) (auto)"], ["", "end"]]}