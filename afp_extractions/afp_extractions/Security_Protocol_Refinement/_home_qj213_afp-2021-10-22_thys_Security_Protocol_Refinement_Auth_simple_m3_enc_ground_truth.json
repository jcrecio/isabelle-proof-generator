{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Auth_simple/m3_enc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas parts_insertD = parts_insert [THEN equalityD1, THEN subsetD]", "lemmas m3_defs = \n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def \n  m3_DY_fake_def", "lemmas MPair_parts [rule del, elim]", "lemmas MPair_analz [rule del, elim]", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]", "lemmas m3_inv1_keysI = m3_inv1_keys_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv1_keysE [elim] = \n  m3_inv1_keys_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv1_keysD [dest] = \n  m3_inv1_keys_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m3_inv1_keys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_keys\"", "lemma PO_m3_inv1_keys_trans [iff]:\n  \"{m3_inv1_keys} trans m3 {> m3_inv1_keys}\"", "lemma PO_m3_inv1_keys [iff]: \"reach m3 \\<subseteq> m3_inv1_keys\"", "lemmas R23_defs =\n  R23_def R23_msgs_def R23_non_def R23_pres_def", "lemmas R23_msgsI = \n  R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_msgsE [elim] = \n  R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_msgsE' [elim] = \n  R23_msgs_def [THEN rel_def_to_dest, simplified, rule_format, THEN subsetD]", "lemmas R23_nonI = \n  R23_non_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_nonE [elim] = \n  R23_non_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_presI = \n  R23_pres_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_presE [elim] = \n  R23_pres_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_intros = R23_msgsI R23_nonI R23_presI", "lemma abs_msg_empty: \"abs_msg {} = {}\"", "lemma abs_msg_Un [simp]: \n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\"", "lemma abs_msg_mono [elim]: \n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\"", "lemma abs_msg_insert_mono [intro]: \n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\"", "lemma abs_msg_DY_subset_fake:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non; t \\<in> m3_inv1_keys \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\"", "lemma abs_msg_parts_subset_fake:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs \\<rbrakk>\n  \\<Longrightarrow> abs_msg (parts (IK t)) \\<subseteq> fake ik0 (-dom (runs s)) (chan s)\"", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_step1 Ra A B Na), (m3_step1 Ra A B Na) \n   {> R23}\"", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_step2 Rb A B Na Nb), (m3_step2 Rb A B Na Nb) \n   {> R23}\"", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23} \n     (m2_step3 Ra A B Na Nb), (m3_step3 Ra A B Na Nb) \n   {> R23}\"", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_fake), (m3_DY_fake) \n   {> R23}\"", "lemmas PO_m3_trans_refines_m2_trans = \n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2 \n  PO_m3_step3_refines_m2_step3 PO_m3_DY_fake_refines_m2_fake", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\"", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (trans m2), (trans m3) \n   {> R23}\"", "lemma PO_R23_obs_consistent [iff]: \n  \"obs_consistent R23 med32 m2 m3\"", "lemma PO_m3_refines_m2 [iff]:\n  \"refines \n     (R23 \\<inter> UNIV \\<times> m3_inv1_keys)\n     med32 m2 m3\""], "translations": [["", "lemmas parts_insertD = parts_insert [THEN equalityD1, THEN subsetD]"], ["", "(******************************************************************************)"], ["", "subsection \\<open>State and observations\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We extend the state of @{term m1} with two confidential channels\nbetween each pair of agents, one channel for each protocol message.\\<close>"], ["", "record m3_state = m1_state +\n  IK :: \"msg set\"                                 \\<comment> \\<open>intruder knowledge\\<close>"], ["", "text \\<open>Observations: local agent states.\\<close>"], ["", "type_synonym \n  m3_obs = m1_obs"], ["", "definition \n  m3_obs :: \"m3_state \\<Rightarrow> m3_obs\" where\n  \"m3_obs s \\<equiv> \\<lparr> \n     runs = runs s\n  \\<rparr>\""], ["", "(******************************************************************************)"], ["", "subsection \\<open>Events\\<close>"], ["", "(******************************************************************************)"], ["", "definition\n  m3_step1 :: \"[rid_t, agent, agent, nonce] \\<Rightarrow> (m3_state \\<times> m3_state) set\"\nwhere\n  \"m3_step1 Ra A B Na \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>guards:\\<close>\n     Ra \\<notin> dom (runs s) \\<and>\n     Na = Ra$0 \\<and>\n\n     \\<comment> \\<open>actions:\\<close>\n     s1 = s\\<lparr>\n       runs := (runs s)(Ra \\<mapsto> (Init, [A, B], [])), \n       IK := insert (Crypt (pubK B) \\<lbrace>Nonce Na, Agent A\\<rbrace>)  (IK s)\n     \\<rparr>\n  }\""], ["", "definition\n  m3_step2 :: \n    \"[rid_t, agent, agent, nonce, nonce] \\<Rightarrow> (m3_state \\<times> m3_state) set\"\nwhere\n  \"m3_step2 Rb A B Na Nb \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>guards\\<close>\n     Rb \\<notin> dom (runs s) \\<and>\n     Nb = Rb$0 \\<and>\n\n     Crypt (pubK B) \\<lbrace>Nonce Na, Agent A\\<rbrace> \\<in> IK s \\<and>      \\<comment> \\<open>receive msg 1\\<close>\n\n     \\<comment> \\<open>actions\\<close>\n     s1 = s\\<lparr> \n       runs := (runs s)(Rb \\<mapsto> (Resp, [A, B], [aNon Na])), \n       IK := insert (Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, Agent B\\<rbrace>) (IK s) \n     \\<rparr>  \n  }\""], ["", "definition\n  m3_step3 :: \"[rid_t, agent, agent, nonce, nonce] \\<Rightarrow> (m3_state \\<times> m3_state) set\"\nwhere\n  \"m3_step3 Ra A B Na Nb \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>guards\\<close>\n     runs s Ra = Some (Init, [A, B], []) \\<and>\n     Na = Ra$0 \\<and>\n\n     Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, Agent B\\<rbrace> \\<in> IK s \\<and>   \\<comment> \\<open>recv msg2\\<close>\n\n     \\<comment> \\<open>actions\\<close>\n     s1 = s\\<lparr> \n       runs := (runs s)(Ra \\<mapsto> (Init, [A, B], [aNon Nb]))\n     \\<rparr>  \n  }\""], ["", "text \\<open>Standard Dolev-Yao intruder.\\<close>"], ["", "definition \n  m3_DY_fake :: \"(m3_state \\<times> m3_state) set\"\nwhere\n  \"m3_DY_fake \\<equiv> {(s, s1).\n\n     \\<comment> \\<open>actions:\\<close>\n     s1 = s\\<lparr> IK := synth (analz (IK s)) \\<rparr>  \n  }\""], ["", "text \\<open>Transition system.\\<close>"], ["", "definition \n  m3_init :: \"m3_state set\" \nwhere\n  \"m3_init \\<equiv> { \\<lparr> \n     runs = Map.empty, \n     IK = (Key`priK`bad) \\<union> (Key`range pubK) \\<union> (Key`shrK`bad) \n  \\<rparr> }\""], ["", "definition \n  m3_trans :: \"(m3_state \\<times> m3_state) set\" where\n  \"m3_trans \\<equiv> (\\<Union> A B Ra Rb Na Nb.\n     m3_step1 Ra A B Na    \\<union>\n     m3_step2 Rb A B Na Nb \\<union>\n     m3_step3 Ra A B Na Nb \\<union>\n     m3_DY_fake \\<union>\n     Id\n  )\""], ["", "definition\n  m3 :: \"(m3_state, m3_obs) spec\" where\n  \"m3 \\<equiv> \\<lparr>\n    init = m3_init,\n    trans = m3_trans, \n    obs = m3_obs\n  \\<rparr>\""], ["", "lemmas m3_defs = \n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def \n  m3_DY_fake_def"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Automatic tool tuning. Tame too-agressive pair decomposition, which is\ndeclared as a safe elim rule ([elim!]).\\<close>"], ["", "lemmas MPair_parts [rule del, elim]"], ["", "lemmas MPair_analz [rule del, elim]"], ["", "text \\<open>Specialize injectiveness of @{term \"parts\"} and @{term \"analz\"} to \nenable aggressive application.\\<close>"], ["", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]"], ["", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]"], ["", "declare analz_into_parts [dest]"], ["", "subsubsection \\<open>inv1: Key secrecy\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Decryption keys are secret, that is, the intruder only knows private \nkeys of corrupted agents.\\<close>"], ["", "definition\n  m3_inv1_keys :: \"m3_state set\" where\n  \"m3_inv1_keys \\<equiv> {s. \\<forall> A. \n     Key (priK A) \\<in> parts (IK s) \\<longrightarrow> A \\<in> bad\n  }\""], ["", "lemmas m3_inv1_keysI = m3_inv1_keys_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv1_keysE [elim] = \n  m3_inv1_keys_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv1_keysD [dest] = \n  m3_inv1_keys_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m3_inv1_keys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> m3_inv1_keys", "by (auto simp add: PO_hoare_def m3_defs intro!: m3_inv1_keysI)"], ["", "lemma PO_m3_inv1_keys_trans [iff]:\n  \"{m3_inv1_keys} trans m3 {> m3_inv1_keys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m3_inv1_keys} TS.trans m3 {> m3_inv1_keys}", "by (auto simp add: PO_hoare_def m3_defs intro!: m3_inv1_keysI) \n   (auto)"], ["", "lemma PO_m3_inv1_keys [iff]: \"reach m3 \\<subseteq> m3_inv1_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m3 \\<subseteq> m3_inv1_keys", "by (rule inv_rule_basic, auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Simulation relation is canonical. It states that the protocol messages\nappearing in the intruder knowledge refine those occurring on the abstract\nconfidential channels. Moreover, if the concrete intruder knows a nonce then so \ndoes the abstract one (as defined by \\<open>ink\\<close>).\\<close>"], ["", "text \\<open>Abstraction function on sets of messages.\\<close>"], ["", "inductive_set \n  abs_msg :: \"msg set \\<Rightarrow> chmsg set\"\n  for H :: \"msg set\"\nwhere \n  am_msg1: \n    \"Crypt (pubK B) \\<lbrace>Nonce Na, Agent A\\<rbrace> \\<in> H\n  \\<Longrightarrow> Confid A B (Msg [aNon Na]) \\<in> abs_msg H\"\n\n| am_msg2:\n    \"Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, Agent B\\<rbrace> \\<in> H \n  \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb]) \\<in> abs_msg H\""], ["", "declare abs_msg.intros [intro!]"], ["", "declare abs_msg.cases [elim!]"], ["", "text \\<open>The simulation relation is canonical. It states that the protocol \nmessages in the intruder knowledge refine the abstract messages appearing on\nthe confidential channels.\\<close>"], ["", "definition\n  R23_msgs :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_msgs \\<equiv> {(s, t). abs_msg (parts (IK t)) \\<subseteq> chan s}\"   \\<comment> \\<open>with \\<open>parts\\<close>!\\<close>"], ["", "definition \n  R23_non :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_non \\<equiv> {(s, t). \\<forall>N. Nonce N \\<in> analz (IK t) \\<longrightarrow> aNon N \\<in> extr ik0 (chan s)}\""], ["", "definition \n  R23_pres :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_pres \\<equiv> {(s, t). runs s = runs t}\""], ["", "definition \n  R23 :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23 \\<equiv> R23_msgs \\<inter> R23_non \\<inter> R23_pres\""], ["", "lemmas R23_defs =\n  R23_def R23_msgs_def R23_non_def R23_pres_def"], ["", "lemmas R23_msgsI = \n  R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_msgsE [elim] = \n  R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_msgsE' [elim] = \n  R23_msgs_def [THEN rel_def_to_dest, simplified, rule_format, THEN subsetD]"], ["", "lemmas R23_nonI = \n  R23_non_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_nonE [elim] = \n  R23_non_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_presI = \n  R23_pres_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_presE [elim] = \n  R23_pres_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_intros = R23_msgsI R23_nonI R23_presI"], ["", "text \\<open>Mediator function.\\<close>"], ["", "abbreviation\n  med32 :: \"m3_obs \\<Rightarrow> m2_obs\" where\n  \"med32 \\<equiv> id\""], ["", "(******************************************************************************)"], ["", "subsection \\<open>Misc lemmas\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>General facts about @{term \"abs_msg\"}\\<close>"], ["", "lemma abs_msg_empty: \"abs_msg {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg {} = {}", "by (auto)"], ["", "lemma abs_msg_Un [simp]: \n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H", "by (auto)"], ["", "lemma abs_msg_mono [elim]: \n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> abs_msg G; G \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> m \\<in> abs_msg H", "by (auto)"], ["", "lemma abs_msg_insert_mono [intro]: \n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> abs_msg H \\<Longrightarrow> m \\<in> abs_msg (insert m' H)", "by (auto)"], ["", "text \\<open>Abstraction of concretely fakeable message yields abstractly fakeable \nmessages. This is the key lemma for the refinement of the intruder.\\<close>"], ["", "lemma abs_msg_DY_subset_fake:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non; t \\<in> m3_inv1_keys \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n     t \\<in> m3_inv1_keys\\<rbrakk>\n    \\<Longrightarrow> abs_msg (synth (analz (IK t)))\n                      \\<subseteq> fake ik0 (dom (runs s)) (chan s)", "apply (auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>B Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys;\n        Crypt (pubK B) \\<lbrace>Nonce Na, msg.Agent A\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid A B (Msg [aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>B Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK B) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid A B (Msg [aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys;\n        Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, msg.Agent B\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 4. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK A) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t); Nonce Nb \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_Inj, fastforce)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK B) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid A B (Msg [aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys;\n        Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, msg.Agent B\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK A) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t); Nonce Nb \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_intros, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys;\n        Crypt (pubK A) \\<lbrace>Nonce Na, Nonce Nb, msg.Agent B\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK A) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t); Nonce Nb \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_Inj, fastforce)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A Na Nb B.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_non;\n        t \\<in> m3_inv1_keys; Key (pubK A) \\<in> analz (IK t);\n        Nonce Na \\<in> analz (IK t); Nonce Nb \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Confid B A (Msg [aNon Na, aNon Nb])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_intros, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma abs_msg_parts_subset_fake:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs \\<rbrakk>\n  \\<Longrightarrow> abs_msg (parts (IK t)) \\<subseteq> fake ik0 (-dom (runs s)) (chan s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> R23_msgs \\<Longrightarrow>\n    abs_msg (parts (IK t)) \\<subseteq> fake ik0 (- dom (runs s)) (chan s)", "by (rule_tac B=\"chan s\" in subset_trans) (auto)"], ["", "declare abs_msg_DY_subset_fake [simp, intro!]"], ["", "declare abs_msg_parts_subset_fake [simp, intro!]"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Proofs obligations.\\<close>"], ["", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_step1 Ra A B Na), (m3_step1 Ra A B Na) \n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times>\n     m3_inv1_keys} m2_step1 Ra A B Na, m3_step1 Ra A B Na {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_step2 Rb A B Na Nb), (m3_step2 Rb A B Na Nb) \n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times>\n     m3_inv1_keys} m2_step2 Rb A B Na Nb, m3_step2 Rb A B Na Nb {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23} \n     (m2_step3 Ra A B Na Nb), (m3_step3 Ra A B Na Nb) \n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step3 Ra A B Na Nb, m3_step3 Ra A B Na Nb {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)"], ["", "text \\<open>Dolev-Yao fake event refines abstract fake event.\\<close>"], ["", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (m2_fake), (m3_DY_fake) \n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter> UNIV \\<times> m3_inv1_keys} m2_fake, m3_DY_fake {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs) \n   (rule R23_intros, auto)+"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m3_trans_refines_m2_trans = \n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2 \n  PO_m3_step3_refines_m2_step3 PO_m3_DY_fake_refines_m2_fake"], ["", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> R23 `` init m2", "by (auto simp add: R23_defs m2_defs m3_defs)"], ["", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> UNIV \\<times> m3_inv1_keys} \n     (trans m2), (trans m3) \n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times> m3_inv1_keys} TS.trans m2, TS.trans m3 {> R23}", "apply (auto simp add: m3_def m3_trans_def m2_def m2_trans_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xd.\n       {R23 \\<inter>\n        UNIV \\<times>\n        m3_inv1_keys} ((\\<Union>x xa xb xc xd Nb.\n                           m2_step1 xb x xa xd \\<union>\n                           m2_step2 xc x xa xd Nb \\<union>\n                           m2_step3 xb x xa xd Nb) \\<union>\n                       m2_fake)\\<^sup>=, m3_step1 xb x xa xd {> R23}\n 2. \\<And>x xa xc xd Nb.\n       {R23 \\<inter>\n        UNIV \\<times>\n        m3_inv1_keys} ((\\<Union>x xa xb xc xd Nb.\n                           m2_step1 xb x xa xd \\<union>\n                           m2_step2 xc x xa xd Nb \\<union>\n                           m2_step3 xb x xa xd Nb) \\<union>\n                       m2_fake)\\<^sup>=, m3_step2 xc x xa xd Nb {> R23}\n 3. \\<And>x xa xb xd Nb.\n       {R23 \\<inter>\n        UNIV \\<times>\n        m3_inv1_keys} ((\\<Union>x xa xb xc xd Nb.\n                           m2_step1 xb x xa xd \\<union>\n                           m2_step2 xc x xa xd Nb \\<union>\n                           m2_step3 xb x xa xd Nb) \\<union>\n                       m2_fake)\\<^sup>=, m3_step3 xb x xa xd Nb {> R23}\n 4. {R23 \\<inter>\n     UNIV \\<times>\n     m3_inv1_keys} ((\\<Union>x xa xb xc xd Nb.\n                        m2_step1 xb x xa xd \\<union>\n                        m2_step2 xc x xa xd Nb \\<union>\n                        m2_step3 xb x xa xd Nb) \\<union>\n                    m2_fake)\\<^sup>=, m3_DY_fake {> R23}", "apply (blast intro!: PO_m3_trans_refines_m2_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_R23_obs_consistent [iff]: \n  \"obs_consistent R23 med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R23 med32 m2 m3", "by (auto simp add: obs_consistent_def R23_def m2_defs m3_defs)"], ["", "lemma PO_m3_refines_m2 [iff]:\n  \"refines \n     (R23 \\<inter> UNIV \\<times> m3_inv1_keys)\n     med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R23 \\<inter> UNIV \\<times> m3_inv1_keys) med32 m2 m3", "by (rule Refinement_using_invariants) (auto)"], ["", "end"]]}