{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Key_establish/m1_keydist_iirn.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemma init_m1a: \"init m1a = m1a_init\"", "lemma trans_m1a: \"trans m1a = m1a_trans\"", "lemma obs_m1a [simp]: \"obs m1a = id\"", "lemmas m1a_loc_defs = \n  m1a_def m1a_init_def m1a_trans_def\n  m1a_step1_def m1a_step2_def m1a_step3_def m1a_step4_def m1a_step5_def \n  m1a_leak_def", "lemmas m1a_defs = m1a_loc_defs m1x_defs", "lemmas m1a_inv0_finI = m1a_inv0_fin_def [THEN setc_def_to_intro, rule_format]", "lemmas m1a_inv0_finE [elim] = m1a_inv0_fin_def [THEN setc_def_to_elim, rule_format]", "lemmas m1a_inv0_finD = m1a_inv0_fin_def [THEN setc_def_to_dest, rule_format]", "lemma PO_m1a_inv0_fin_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv0_fin\"", "lemma PO_m1a_inv0_fin_trans [iff]:\n  \"{m1a_inv0_fin} trans m1a {> m1a_inv0_fin}\"", "lemma PO_m1a_inv0_fin [iff]: \"reach m1a \\<subseteq> m1a_inv0_fin\"", "lemmas R1x1a_defs = \n  R1x1a_def med1x1a_def", "lemma PO_m1a_step1_refines_m1x_step1:\n  \"{R1x1a} \n     (m1x_step1 Ra A B), (m1a_step1 Ra A B Na) \n   {> R1x1a}\"", "lemma PO_m1a_step2_refines_m1x_step2:\n  \"{R1x1a} \n     (m1x_step2 Rb A B), (m1a_step2 Rb A B) \n   {> R1x1a}\"", "lemma PO_m1a_step3_refines_m1x_step3:\n  \"{R1x1a} \n     (m1x_step3 Rs A B Kab), (m1a_step3 Rs A B Kab Na nls)\n   {> R1x1a}\"", "lemma PO_m1a_step4_refines_m1x_step4:\n  \"{R1x1a} \n     (m1x_step4 Ra A B Kab), (m1a_step4 Ra A B Na Kab nla) \n   {> R1x1a}\"", "lemma PO_m1a_step5_refines_m1x_step5:\n  \"{R1x1a} \n     (m1x_step5 A B Rb Kab), (m1a_step5 A B Rb Kab nlb) \n   {> R1x1a}\"", "lemma PO_m1a_leak_refines_m1x_leak:\n  \"{R1x1a} \n     (m1x_leak Rs), (m1a_leak Rs) \n   {> R1x1a}\"", "lemmas PO_m1a_trans_refines_m1x_trans = \n  PO_m1a_step1_refines_m1x_step1 PO_m1a_step2_refines_m1x_step2\n  PO_m1a_step3_refines_m1x_step3 PO_m1a_step4_refines_m1x_step4\n  PO_m1a_step5_refines_m1x_step5 PO_m1a_leak_refines_m1x_leak", "lemma PO_m1a_refines_init_m1x [iff]:\n  \"init m1a \\<subseteq>  R1x1a``(init m1x)\"", "lemma PO_m1a_refines_trans_m1x [iff]:\n  \"{R1x1a} \n     (trans m1x), (trans m1a) \n   {> R1x1a}\"", "lemma obs_consistent_med1x1a [iff]: \n  \"obs_consistent R1x1a med1x1a m1x m1a\"", "lemma PO_m1a_refines_m1x [iff]: \n  \"refines R1x1a med1x1a m1x m1a\"", "lemma  m1a_implements_m1x [iff]: \"implements med1x1a m1x m1a\"", "lemma m1a_implements_s0g [iff]: \"implements (med01x o med1x1a) s0g m1a\"", "lemma knC_runs1x1a [simp]: \"knC (runs1x1a runz) = knC runz\"", "lemma PO_m1a_obs_secrecy [iff]: \"oreach m1a \\<subseteq> m1x_secrecy\"", "lemma PO_m1a_secrecy [iff]: \"reach m1a \\<subseteq> m1x_secrecy\"", "lemmas R_a0m1a_is_defs = R_a0m1a_is_def med_a0m1a_is_def", "lemma is_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma is_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz\"", "lemma is_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz\"", "lemma is_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils))) = \n     (is_runs2sigs runz)(Running [A, Sv] (sesK (Rs$sk), B, Na, ils) := 1)\"", "lemma is_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); ils = take is_len nla \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n     (is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra$na, ils) := 1)\"", "lemma is_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n     is_runs2sigs runz\"", "lemma PO_m1a_step1_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step1 Ra A B Na) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step2_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step3_refines_a0_is_running:\n  \"{R_a0m1a_is} \n     (a0i_running [A, Sv] (Kab, B, Na, nls)), \n     (m1a_step3 Rs A B Kab Na nls) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step4_refines_a0_is_commit:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0i_commit [A, Sv] (Kab, B, Na, take is_len nla)), \n     (m1a_step4 Ra A B Na Kab nla) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_step5_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step5 A B Rb Kab nlb) \n   {> R_a0m1a_is}\"", "lemma PO_m1a_leak_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_is}\"", "lemmas PO_m1a_trans_refines_a0_is_trans = \n  PO_m1a_step1_refines_a0_is_skip PO_m1a_step2_refines_a0_is_skip\n  PO_m1a_step3_refines_a0_is_running PO_m1a_step4_refines_a0_is_commit\n  PO_m1a_step5_refines_a0_is_skip PO_m1a_leak_refines_a0_is_skip", "lemma PO_m1a_refines_init_a0_is [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_is``(init a0i)\"", "lemma PO_m1a_refines_trans_a0_is [iff]:\n  \"{R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin} \n     (trans a0i), (trans m1a) \n   {> R_a0m1a_is}\"", "lemma obs_consistent_med_a0m1a_is [iff]: \n  \"obs_consistent R_a0m1a_is med_a0m1a_is a0i m1a\"", "lemma PO_m1a_refines_a0_is [iff]: \n  \"refines (R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin) med_a0m1a_is a0i m1a\"", "lemma  m1a_implements_a0_is: \"implements med_a0m1a_is a0i m1a\"", "lemmas m1a_inv2i_servI = \n  m1a_inv2i_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1a_inv2i_servE =     (* DO NOT declare elim: leads to slow proofs! *)\n  m1a_inv2i_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1a_inv2i_servD =     (* DO NOT declare dest: leads to slow proofs! *)\n  m1a_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1a_inv2i_serv [iff]:\n  \"reach m1a \\<subseteq> m1a_inv2i_serv\"", "lemmas m1a_inv1_ifreshI = m1a_inv1_ifresh_def [THEN setc_def_to_intro, rule_format]", "lemmas m1a_inv1_ifreshE [elim] = m1a_inv1_ifresh_def [THEN setc_def_to_elim, rule_format]", "lemmas m1a_inv1_ifreshD = m1a_inv1_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m1a_inv1_ifresh_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv1_ifresh\"", "lemma PO_m1a_inv1_ifresh_step4:\n  \"{m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter> m1x_secrecy} \n      m1a_step4 Ra A B Na Kab nla\n   {> m1a_inv1_ifresh}\"", "lemma PO_m1a_inv1_ifresh_trans [iff]:\n  \"{m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter> m1x_secrecy} trans m1a {> m1a_inv1_ifresh}\"", "lemma PO_m1a_inv1_ifresh [iff]: \"reach m1a \\<subseteq> m1a_inv1_ifresh\"", "lemmas R_a0m1a_rs_defs = R_a0m1a_rs_def med_a0m1a_rs_def", "lemma rs_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)\"", "lemma rs_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)\"", "lemma rs_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # nls))) = \n     (rs_runs2sigs runz)(Running [B, Sv] (sesK (Rs$sk), A, nls) := 1)\"", "lemma rs_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n     rs_runs2sigs runz\"", "lemma rs_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb \\<rbrakk>\n \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n   (rs_runs2sigs runz)(\n      Commit [B, Sv] (Kab, A, rsl) := Suc (card (rs_commit runz A B Kab rsl)))\"", "lemma PO_m1a_step1_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step1 Ra A B Na) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step2_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step3_refines_a0_rs_running:\n  \"{R_a0m1a_rs} \n     (a0n_running [B, Sv] (Kab, A, nls)), \n     (m1a_step3 Rs A B Kab Na nls) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step4_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step4 Ra A B Na Kab nla) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_step5_refines_a0_rs_commit:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [B, Sv] (Kab, A, take rs_len nlb)), \n     (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_rs}\"", "lemma PO_m1a_leak_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_rs}\"", "lemmas PO_m1a_trans_refines_a0_rs_trans = \n  PO_m1a_step1_refines_a0_rs_skip PO_m1a_step2_refines_a0_rs_skip\n  PO_m1a_step3_refines_a0_rs_running PO_m1a_step4_refines_a0_rs_skip\n  PO_m1a_step5_refines_a0_rs_commit PO_m1a_leak_refines_a0_rs_skip", "lemma PO_m1a_refines_init_ra0n [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_rs``(init a0n)\"", "lemma PO_m1a_refines_trans_ra0n [iff]:\n  \"{R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_rs}\"", "lemma obs_consistent_med_a0m1a_rs [iff]: \n  \"obs_consistent \n     (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin) \n     med_a0m1a_rs a0n m1a\"", "lemma PO_m1a_refines_a0_rs [iff]: \n  \"refines (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\"", "lemma m1a_implements_ra0n: \"implements med_a0m1a_rs a0n m1a\"", "lemmas m1a_inv2r_servI = \n  m1a_inv2r_serv_def [THEN setc_def_to_intro, rule_format]", "lemmas m1a_inv2r_servE [elim] = \n  m1a_inv2r_serv_def [THEN setc_def_to_elim, rule_format]", "lemmas m1a_inv2r_servD = \n  m1a_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]", "lemma PO_m1a_inv2r_serv [iff]:\n  \"reach m1a \\<subseteq> m1a_inv2r_serv\""], "translations": [["", "lemma init_m1a: \"init m1a = m1a_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a = m1a_init", "by (simp add: m1a_def)"], ["", "lemma trans_m1a: \"trans m1a = m1a_trans\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TS.trans m1a = m1a_trans", "by (simp add: m1a_def)"], ["", "lemma obs_m1a [simp]: \"obs m1a = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs m1a = id", "by (simp add: m1a_def)"], ["", "lemmas m1a_loc_defs = \n  m1a_def m1a_init_def m1a_trans_def\n  m1a_step1_def m1a_step2_def m1a_step3_def m1a_step4_def m1a_step5_def \n  m1a_leak_def"], ["", "lemmas m1a_defs = m1a_loc_defs m1x_defs"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>inv0: Finite domain\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>There are only finitely many runs. This is needed to establish\nthe responder/initiator agreement.\\<close>"], ["", "definition \n  m1a_inv0_fin :: \"'x m1r_pred\"\nwhere\n  \"m1a_inv0_fin \\<equiv> {s. finite (dom (runs s))}\""], ["", "lemmas m1a_inv0_finI = m1a_inv0_fin_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1a_inv0_finE [elim] = m1a_inv0_fin_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1a_inv0_finD = m1a_inv0_fin_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m1a_inv0_fin_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> m1a_inv0_fin", "by (auto simp add: m1a_defs intro!: m1a_inv0_finI)"], ["", "lemma PO_m1a_inv0_fin_trans [iff]:\n  \"{m1a_inv0_fin} trans m1a {> m1a_inv0_fin}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1a_inv0_fin} TS.trans m1a {> m1a_inv0_fin}", "by (auto simp add: PO_hoare_defs m1a_defs intro!: m1a_inv0_finI)"], ["", "lemma PO_m1a_inv0_fin [iff]: \"reach m1a \\<subseteq> m1a_inv0_fin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1a_inv0_fin", "by (rule inv_rule_incr, auto del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>m1x\\<close>\\<close>"], ["", "(******************************************************************************)"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Define run abstraction.\\<close>"], ["", "fun \n  rm1x1a :: \"role_t \\<Rightarrow> atom list \\<Rightarrow> atom list\"\nwhere\n  \"rm1x1a Init = take 1\"         \\<comment> \\<open>take \\<open>Kab\\<close> from \\<open>Kab # nla\\<close>\\<close>\n| \"rm1x1a Resp = take 1\"         \\<comment> \\<open>take \\<open>Kab\\<close> from \\<open>Kab # nlb\\<close>\\<close>\n| \"rm1x1a Serv = take 0\"         \\<comment> \\<open>drop all from \\<open>[Na]\\<close>\\<close>"], ["", "abbreviation \n  runs1x1a :: \"runs_t \\<Rightarrow> runs_t\" where \n  \"runs1x1a \\<equiv> map_runs rm1x1a\""], ["", "text \\<open>med1x1: The mediator function maps a concrete observation to an \nabstract one.\\<close>"], ["", "definition\n  med1x1a :: \"m1a_obs \\<Rightarrow> m1x_obs\" where\n  \"med1x1a t \\<equiv> \\<lparr> runs = runs1x1a (runs t), leak = leak t \\<rparr>\""], ["", "text \\<open>R1x1a: The simulation relation is defined in terms of the mediator\nfunction.\\<close>"], ["", "definition\n  R1x1a :: \"(m1x_state \\<times> m1a_state) set\" where\n  \"R1x1a \\<equiv> {(s, t). s = med1x1a t}\""], ["", "lemmas R1x1a_defs = \n  R1x1a_def med1x1a_def"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_m1x_step1:\n  \"{R1x1a} \n     (m1x_step1 Ra A B), (m1a_step1 Ra A B Na) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step1 Ra A B, m1a_step1 Ra A B Na {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_m1x_step2:\n  \"{R1x1a} \n     (m1x_step2 Rb A B), (m1a_step2 Rb A B) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step2 Rb A B, m1a_step2 Rb A B {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_m1x_step3:\n  \"{R1x1a} \n     (m1x_step3 Rs A B Kab), (m1a_step3 Rs A B Kab Na nls)\n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step3 Rs A B Kab, m1a_step3 Rs A B Kab Na nls {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_step4_refines_m1x_step4:\n  \"{R1x1a} \n     (m1x_step4 Ra A B Kab), (m1a_step4 Ra A B Na Kab nla) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step4 Ra A B Kab, m1a_step4 Ra A B Na Kab nla {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "lemma PO_m1a_step5_refines_m1x_step5:\n  \"{R1x1a} \n     (m1x_step5 A B Rb Kab), (m1a_step5 A B Rb Kab nlb) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_step5 A B Rb Kab, m1a_step5 A B Rb Kab nlb {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "lemma PO_m1a_leak_refines_m1x_leak:\n  \"{R1x1a} \n     (m1x_leak Rs), (m1a_leak Rs) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} m1x_leak Rs, m1a_leak Rs {> R1x1a}", "by (auto simp add: PO_rhoare_defs R1x1a_defs m1a_defs map_runs_def)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_m1x_trans = \n  PO_m1a_step1_refines_m1x_step1 PO_m1a_step2_refines_m1x_step2\n  PO_m1a_step3_refines_m1x_step3 PO_m1a_step4_refines_m1x_step4\n  PO_m1a_step5_refines_m1x_step5 PO_m1a_leak_refines_m1x_leak"], ["", "lemma PO_m1a_refines_init_m1x [iff]:\n  \"init m1a \\<subseteq>  R1x1a``(init m1x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R1x1a `` init m1x", "by (auto simp add: R1x1a_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_m1x [iff]:\n  \"{R1x1a} \n     (trans m1x), (trans m1a) \n   {> R1x1a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R1x1a} TS.trans m1x, TS.trans m1a {> R1x1a}", "apply (auto simp add: m1a_def m1a_trans_def m1x_def m1x_trans_def\n            intro!: PO_m1a_trans_refines_m1x_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xe.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak xd)\\<^sup>=, m1a_step1 xb x xa xe {> R1x1a}\n 2. \\<And>x xa xc.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak xd)\\<^sup>=, m1a_step2 xc x xa {> R1x1a}\n 3. \\<And>x xa xd xe xf xg.\n       {R1x1a} (\\<Union>x xa xb xc xd.\n                   (\\<Union>Kab.\n                       m1x_step1 xb x xa \\<union> m1x_step2 xc x xa \\<union>\n                       m1x_step3 xd x xa Kab \\<union>\n                       m1x_step4 xb x xa Kab \\<union>\n                       m1x_step5 xc x xa Kab) \\<union>\n                   m1x_leak\n                    xd)\\<^sup>=, m1a_step3 xd x xa xf xe xg {> R1x1a}", "apply (force intro!: PO_m1a_trans_refines_m1x_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency.\\<close>"], ["", "lemma obs_consistent_med1x1a [iff]: \n  \"obs_consistent R1x1a med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R1x1a med1x1a m1x m1a", "by (auto simp add: obs_consistent_def R1x1a_def m1a_defs)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_m1x [iff]: \n  \"refines R1x1a med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R1x1a med1x1a m1x m1a", "by (rule Refinement_basic) (auto del: subsetI)"], ["", "lemma  m1a_implements_m1x [iff]: \"implements med1x1a m1x m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med1x1a m1x m1a", "by (rule refinement_soundness) (fast)"], ["", "text \\<open>By transitivity:\\<close>"], ["", "lemma m1a_implements_s0g [iff]: \"implements (med01x o med1x1a) s0g m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements (med01x \\<circ> med1x1a) s0g m1a", "by (rule implements_trans, auto)"], ["", "subsubsection \\<open>inv (inherited): Secrecy\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>Secrecy preserved from \\<open>m1x\\<close>.\\<close>"], ["", "lemma knC_runs1x1a [simp]: \"knC (runs1x1a runz) = knC runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. knC (runs1x1a runz) = knC runz", "apply (auto simp add: map_runs_def elim!: knC.cases, auto)\n\\<comment> \\<open>5 subgoals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Ra A B K al b.\n       \\<lbrakk>runz Ra = Some (Init, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, A) \\<in> knC runz\n 2. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 3. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1x1a runz)\n 4. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1x1a runz)\n 5. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1x1a runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Rb A B K al b.\n       \\<lbrakk>runz Rb = Some (Resp, [A, B], b);\n        take (Suc 0) b = aKey K # al\\<rbrakk>\n       \\<Longrightarrow> (K, B) \\<in> knC runz\n 2. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1x1a runz)\n 3. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1x1a runz)\n 4. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1x1a runz)", "apply (rename_tac b, case_tac b, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ra A B K al.\n       runz Ra = Some (Init, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, A) \\<in> knC (runs1x1a runz)\n 2. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1x1a runz)\n 3. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1x1a runz)", "apply (rule knC_init, auto simp add: map_runs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Rb A B K al.\n       runz Rb = Some (Resp, [A, B], aKey K # al) \\<Longrightarrow>\n       (K, B) \\<in> knC (runs1x1a runz)\n 2. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1x1a runz)", "apply (rule knC_resp, auto simp add: map_runs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rs.\n       \\<lbrakk>Rs \\<in> dom runz; fst (the (runz Rs)) = Serv\\<rbrakk>\n       \\<Longrightarrow> (sesK (Rs $ sk), Sv) \\<in> knC (runs1x1a runz)", "apply (rule knC_serv, auto simp add: map_runs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1a_obs_secrecy [iff]: \"oreach m1a \\<subseteq> m1x_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach m1a \\<subseteq> m1x_secrecy", "apply (rule_tac Q=m1x_secrecy in external_invariant_translation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. oreach ?Sa \\<subseteq> m1x_secrecy\n 2. ?pi -` m1x_secrecy \\<subseteq> m1x_secrecy\n 3. implements ?pi ?Sa m1a", "apply (auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. med1x1a -` m1x_secrecy \\<subseteq> m1x_secrecy", "apply (auto simp add: med1x1a_def m1x_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_m1a_secrecy [iff]: \"reach m1a \\<subseteq> m1x_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1x_secrecy", "by (rule external_to_internal_invariant) (auto del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0i\\<close> for initiator/server\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>For the initiator, we get an injective agreement with the server on \nthe session key, the responder name, the initiator's nonce and the list of \nfreshness values @{term \"isl\"}.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed initiator and server runs.\\<close>"], ["", "type_synonym \n  issig = \"key \\<times> agent \\<times> nonce \\<times> atom list\""], ["", "fun\n  is_runs2sigs :: \"runs_t \\<Rightarrow> issig signal \\<Rightarrow> nat\"\nwhere\n  \"is_runs2sigs runz (Running [A, Sv] (Kab, B, Na, nl)) = \n     (if \\<exists>Rs. Kab = sesK (Rs$sk) \\<and> \n         runz Rs = Some (Serv, [A, B], aNon Na # nl) \n      then 1 else 0)\"\n\n| \"is_runs2sigs runz (Commit [A, Sv] (Kab, B, Na, nl)) = \n     (if \\<exists>Ra nla. Na = Ra$na \\<and> \n         runz Ra = Some (Init, [A, B], aKey Kab # nla) \\<and> \n         take is_len nla = nl\n      then 1 else 0)\"\n\n| \"is_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0m1a_is :: \"m1a_obs \\<Rightarrow> issig a0i_obs\" where\n  \"med_a0m1a_is o1 \\<equiv> \\<lparr> signals = is_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0m1a_is :: \"(issig a0i_state \\<times> m1a_state) set\" where\n  \"R_a0m1a_is \\<equiv> {(s, t). signals s = is_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0m1a_is_defs = R_a0m1a_is_def med_a0m1a_is_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "lemma is_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> is_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma is_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = is_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma is_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = is_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule is_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma is_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils))) = \n     (is_runs2sigs runz)(Running [A, Sv] (sesK (Rs$sk), B, Na, ils) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils))) =\n    (is_runs2sigs runz)(Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1)", "apply (rule ext, (erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils))) x =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        x", "apply (rule is_runs2sigs.induct)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x runz Aa Kab Ba Naa nl.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Running [Aa, Sv] (Kab, Ba, Naa, nl)) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Running [Aa, Sv] (Kab, Ba, Naa, nl))\n 2. \\<And>x runz Aa Kab Ba Naa nl.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Commit [Aa, Sv] (Kab, Ba, Naa, nl)) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Commit [Aa, Sv] (Kab, Ba, Naa, nl))\n 3. \\<And>x runz va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Running [] va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Running [] va)\n 4. \\<And>x runz vb va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Running [vb] va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Running [vb] va)\n 5. \\<And>x runz vb vf ve va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Running (vb # Agent vf # ve) va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Running (vb # Agent vf # ve) va)\n 6. \\<And>x runz vb vd vf vg va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Running (vb # vd # vf # vg) va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Running (vb # vd # vf # vg) va)\n 7. \\<And>x runz va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Commit [] va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Commit [] va)\n 8. \\<And>x runz vb va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Commit [vb] va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Commit [vb] va)\n 9. \\<And>x runz vb vf ve va.\n       Rs \\<notin> dom runz \\<longrightarrow>\n       is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n        (Commit (vb # Agent vf # ve) va) =\n       ((is_runs2sigs runz)\n        (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n        (Commit (vb # Agent vf # ve) va)\n 10. \\<And>x runz vb vd vf vg va.\n        Rs \\<notin> dom runz \\<longrightarrow>\n        is_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # ils)))\n         (Commit (vb # vd # vf # vg) va) =\n        ((is_runs2sigs runz)\n         (Running [A, Sv] (sesK (Rs $ sk), B, Na, ils) := 1))\n         (Commit (vb # vd # vf # vg) va)", "apply (safe, simp_all)+"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>runz Aa Ba Naa nl Rsa.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        \\<forall>Rsb.\n           (Rsb = Rs \\<longrightarrow>\n            Rsa = Rs \\<longrightarrow>\n            Na = Naa \\<longrightarrow>\n            B = Ba \\<longrightarrow>\n            A = Aa \\<longrightarrow> ils \\<noteq> nl) \\<and>\n           (Rsb \\<noteq> Rs \\<longrightarrow>\n            Rsa = Rsb \\<longrightarrow>\n            runz Rsb \\<noteq> Some (Serv, [Aa, Ba], aNon Naa # nl));\n        runz Rsa = Some (Serv, [Aa, Ba], aNon Naa # nl)\\<rbrakk>\n       \\<Longrightarrow> Naa = Na\n 2. \\<And>runz Aa Ba Naa nl Rsa.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        \\<forall>Rsb.\n           (Rsb = Rs \\<longrightarrow>\n            Rsa = Rs \\<longrightarrow>\n            Na = Naa \\<longrightarrow>\n            B = Ba \\<longrightarrow>\n            A = Aa \\<longrightarrow> ils \\<noteq> nl) \\<and>\n           (Rsb \\<noteq> Rs \\<longrightarrow>\n            Rsa = Rsb \\<longrightarrow>\n            runz Rsb \\<noteq> Some (Serv, [Aa, Ba], aNon Naa # nl));\n        runz Rsa = Some (Serv, [Aa, Ba], aNon Naa # nl)\\<rbrakk>\n       \\<Longrightarrow> Ba = B\n 3. \\<And>runz Aa Ba Naa nl Rsa.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        \\<forall>Rsb.\n           (Rsb = Rs \\<longrightarrow>\n            Rsa = Rs \\<longrightarrow>\n            Na = Naa \\<longrightarrow>\n            B = Ba \\<longrightarrow>\n            A = Aa \\<longrightarrow> ils \\<noteq> nl) \\<and>\n           (Rsb \\<noteq> Rs \\<longrightarrow>\n            Rsa = Rsb \\<longrightarrow>\n            runz Rsb \\<noteq> Some (Serv, [Aa, Ba], aNon Naa # nl));\n        runz Rsa = Some (Serv, [Aa, Ba], aNon Naa # nl)\\<rbrakk>\n       \\<Longrightarrow> Rsa = Rs\n 4. \\<And>runz Aa Ba Naa nl Rsa.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        \\<forall>Rsb.\n           (Rsb = Rs \\<longrightarrow>\n            Rsa = Rs \\<longrightarrow>\n            Na = Naa \\<longrightarrow>\n            B = Ba \\<longrightarrow>\n            A = Aa \\<longrightarrow> ils \\<noteq> nl) \\<and>\n           (Rsb \\<noteq> Rs \\<longrightarrow>\n            Rsa = Rsb \\<longrightarrow>\n            runz Rsb \\<noteq> Some (Serv, [Aa, Ba], aNon Naa # nl));\n        runz Rsa = Some (Serv, [Aa, Ba], aNon Naa # nl)\\<rbrakk>\n       \\<Longrightarrow> Aa = A\n 5. \\<And>runz Aa Ba Naa nl Rsa.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        \\<forall>Rsb.\n           (Rsb = Rs \\<longrightarrow>\n            Rsa = Rs \\<longrightarrow>\n            Na = Naa \\<longrightarrow>\n            B = Ba \\<longrightarrow>\n            A = Aa \\<longrightarrow> ils \\<noteq> nl) \\<and>\n           (Rsb \\<noteq> Rs \\<longrightarrow>\n            Rsa = Rsb \\<longrightarrow>\n            runz Rsb \\<noteq> Some (Serv, [Aa, Ba], aNon Naa # nl));\n        runz Rsa = Some (Serv, [Aa, Ba], aNon Naa # nl)\\<rbrakk>\n       \\<Longrightarrow> nl = ils\n 6. \\<And>runz A Kab B nla.\n       \\<lbrakk>Rs \\<notin> dom runz;\n        runz Rs = Some (Init, [A, B], aKey Kab # nla)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (fastforce simp add: domIff)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []); ils = take is_len nla \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n     (is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra$na, ils) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Ra = Some (Init, [A, B], []);\n     ils = take is_len nla\\<rbrakk>\n    \\<Longrightarrow> is_runs2sigs\n                       (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) =\n                      (is_runs2sigs runz)\n                      (Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1)", "apply (rule ext, (erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla))) x =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1)) x", "apply (rule is_runs2sigs.induct)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x runz Aa Kaba Ba Na nl.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Running [Aa, Sv] (Kaba, Ba, Na, nl)) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Running [Aa, Sv] (Kaba, Ba, Na, nl))\n 2. \\<And>x runz Aa Kaba Ba Na nl.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Commit [Aa, Sv] (Kaba, Ba, Na, nl)) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Commit [Aa, Sv] (Kaba, Ba, Na, nl))\n 3. \\<And>x runz va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Running [] va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Running [] va)\n 4. \\<And>x runz vb va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Running [vb] va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Running [vb] va)\n 5. \\<And>x runz vb vf ve va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Running (vb # Agent vf # ve) va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Running (vb # Agent vf # ve) va)\n 6. \\<And>x runz vb vd vf vg va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Running (vb # vd # vf # vg) va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Running (vb # vd # vf # vg) va)\n 7. \\<And>x runz va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Commit [] va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Commit [] va)\n 8. \\<And>x runz vb va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Commit [vb] va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Commit [vb] va)\n 9. \\<And>x runz vb vf ve va.\n       ils = take is_len nla \\<longrightarrow>\n       runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n        (Commit (vb # Agent vf # ve) va) =\n       ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n        (Commit (vb # Agent vf # ve) va)\n 10. \\<And>x runz vb vd vf vg va.\n        ils = take is_len nla \\<longrightarrow>\n        runz Ra = Some (Init, [A, B], []) \\<longrightarrow>\n        is_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nla)))\n         (Commit (vb # vd # vf # vg) va) =\n        ((is_runs2sigs runz)(Commit [A, Sv] (Kab, B, Ra $ na, ils) := 1))\n         (Commit (vb # vd # vf # vg) va)", "apply (safe, simp_all)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>runz Aa Kaba Ba Raa nlaa.\n       \\<lbrakk>ils = take is_len nla; runz Ra = Some (Init, [A, B], []);\n        \\<forall>Rab.\n           (Rab = Ra \\<longrightarrow>\n            Raa = Ra \\<longrightarrow>\n            A = Aa \\<and> B = Ba \\<and> Kab = Kaba \\<longrightarrow>\n            take is_len nla \\<noteq> take is_len nlaa) \\<and>\n           (Rab \\<noteq> Ra \\<longrightarrow>\n            Raa = Rab \\<longrightarrow>\n            (\\<forall>nla.\n                runz Rab =\n                Some (Init, [Aa, Ba], aKey Kaba # nla) \\<longrightarrow>\n                take is_len nla \\<noteq> take is_len nlaa));\n        runz Raa = Some (Init, [Aa, Ba], aKey Kaba # nlaa)\\<rbrakk>\n       \\<Longrightarrow> Raa = Ra\n 2. \\<And>runz Aa Kaba Ba Raa nlaa.\n       \\<lbrakk>ils = take is_len nla; runz Ra = Some (Init, [A, B], []);\n        \\<forall>Rab.\n           (Rab = Ra \\<longrightarrow>\n            Raa = Ra \\<longrightarrow>\n            A = Aa \\<and> B = Ba \\<and> Kab = Kaba \\<longrightarrow>\n            take is_len nla \\<noteq> take is_len nlaa) \\<and>\n           (Rab \\<noteq> Ra \\<longrightarrow>\n            Raa = Rab \\<longrightarrow>\n            (\\<forall>nla.\n                runz Rab =\n                Some (Init, [Aa, Ba], aKey Kaba # nla) \\<longrightarrow>\n                take is_len nla \\<noteq> take is_len nlaa));\n        runz Raa = Some (Init, [Aa, Ba], aKey Kaba # nlaa)\\<rbrakk>\n       \\<Longrightarrow> Ba = B\n 3. \\<And>runz Aa Kaba Ba Raa nlaa.\n       \\<lbrakk>ils = take is_len nla; runz Ra = Some (Init, [A, B], []);\n        \\<forall>Rab.\n           (Rab = Ra \\<longrightarrow>\n            Raa = Ra \\<longrightarrow>\n            A = Aa \\<and> B = Ba \\<and> Kab = Kaba \\<longrightarrow>\n            take is_len nla \\<noteq> take is_len nlaa) \\<and>\n           (Rab \\<noteq> Ra \\<longrightarrow>\n            Raa = Rab \\<longrightarrow>\n            (\\<forall>nla.\n                runz Rab =\n                Some (Init, [Aa, Ba], aKey Kaba # nla) \\<longrightarrow>\n                take is_len nla \\<noteq> take is_len nlaa));\n        runz Raa = Some (Init, [Aa, Ba], aKey Kaba # nlaa)\\<rbrakk>\n       \\<Longrightarrow> Kaba = Kab\n 4. \\<And>runz Aa Kaba Ba Raa nlaa.\n       \\<lbrakk>ils = take is_len nla; runz Ra = Some (Init, [A, B], []);\n        \\<forall>Rab.\n           (Rab = Ra \\<longrightarrow>\n            Raa = Ra \\<longrightarrow>\n            A = Aa \\<and> B = Ba \\<and> Kab = Kaba \\<longrightarrow>\n            take is_len nla \\<noteq> take is_len nlaa) \\<and>\n           (Rab \\<noteq> Ra \\<longrightarrow>\n            Raa = Rab \\<longrightarrow>\n            (\\<forall>nla.\n                runz Rab =\n                Some (Init, [Aa, Ba], aKey Kaba # nla) \\<longrightarrow>\n                take is_len nla \\<noteq> take is_len nlaa));\n        runz Raa = Some (Init, [Aa, Ba], aKey Kaba # nlaa)\\<rbrakk>\n       \\<Longrightarrow> Aa = A\n 5. \\<And>runz Aa Kaba Ba Raa nlaa.\n       \\<lbrakk>ils = take is_len nla; runz Ra = Some (Init, [A, B], []);\n        \\<forall>Rab.\n           (Rab = Ra \\<longrightarrow>\n            Raa = Ra \\<longrightarrow>\n            A = Aa \\<and> B = Ba \\<and> Kab = Kaba \\<longrightarrow>\n            take is_len nla \\<noteq> take is_len nlaa) \\<and>\n           (Rab \\<noteq> Ra \\<longrightarrow>\n            Raa = Rab \\<longrightarrow>\n            (\\<forall>nla.\n                runz Rab =\n                Some (Init, [Aa, Ba], aKey Kaba # nla) \\<longrightarrow>\n                take is_len nla \\<noteq> take is_len nlaa));\n        runz Raa = Some (Init, [Aa, Ba], aKey Kaba # nlaa)\\<rbrakk>\n       \\<Longrightarrow> take is_len nlaa = take is_len nla", "apply (fastforce)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n     is_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Rb = Some (Resp, [A, B], []) \\<Longrightarrow>\n    is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n    is_runs2sigs runz", "apply (rule ext, erule rev_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       runz Rb = Some (Resp, [A, B], []) \\<longrightarrow>\n       is_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) x =\n       is_runs2sigs runz x", "apply (rule is_runs2sigs.induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step1 Ra A B Na) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step1 Ra A B Na {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step2 Rb A B {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_a0_is_running:\n  \"{R_a0m1a_is} \n     (a0i_running [A, Sv] (Kab, B, Na, nls)), \n     (m1a_step3 Rs A B Kab Na nls) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} a0i_running [A, Sv]\n                  (Kab, B, Na,\n                   nls), m1a_step3 Rs A B Kab Na nls {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs a0i_defs m1a_defs \n         dest: dom_lemmas)"], ["", "lemma PO_m1a_step4_refines_a0_is_commit:\n  \"{R_a0m1a_is \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0i_commit [A, Sv] (Kab, B, Na, take is_len nla)), \n     (m1a_step4 Ra A B Na Kab nla) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is \\<inter>\n     UNIV \\<times>\n     m1a_inv0_fin} a0i_commit [A, Sv]\n                    (Kab, B, Na,\n                     take is_len\n                      nla), m1a_step4 Ra A B Na Kab nla {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs a0i_defs m1a_defs)"], ["", "lemma PO_m1a_step5_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_step5 A B Rb Kab nlb) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_step5 A B Rb Kab nlb {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "lemma PO_m1a_leak_refines_a0_is_skip:\n  \"{R_a0m1a_is} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is} Id, m1a_leak Rs {> R_a0m1a_is}", "by (auto simp add: PO_rhoare_defs R_a0m1a_is_defs m1a_defs)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_a0_is_trans = \n  PO_m1a_step1_refines_a0_is_skip PO_m1a_step2_refines_a0_is_skip\n  PO_m1a_step3_refines_a0_is_running PO_m1a_step4_refines_a0_is_commit\n  PO_m1a_step5_refines_a0_is_skip PO_m1a_leak_refines_a0_is_skip"], ["", "lemma PO_m1a_refines_init_a0_is [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_is``(init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R_a0m1a_is `` init a0i", "by (auto simp add: R_a0m1a_is_defs a0i_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_a0_is [iff]:\n  \"{R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin} \n     (trans a0i), (trans m1a) \n   {> R_a0m1a_is}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_is \\<inter>\n     a0i_inv1_iagree \\<times>\n     m1a_inv0_fin} TS.trans a0i, TS.trans m1a {> R_a0m1a_is}", "by (force simp add: m1a_def m1a_trans_def a0i_def a0i_trans_def\n          intro!: PO_m1a_trans_refines_a0_is_trans)"], ["", "lemma obs_consistent_med_a0m1a_is [iff]: \n  \"obs_consistent R_a0m1a_is med_a0m1a_is a0i m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R_a0m1a_is med_a0m1a_is a0i m1a", "by (auto simp add: obs_consistent_def R_a0m1a_is_def med_a0m1a_is_def \n                   a0i_def m1a_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_a0_is [iff]: \n  \"refines (R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin) med_a0m1a_is a0i m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin)\n     med_a0m1a_is a0i m1a", "by (rule Refinement_using_invariants) \n   (auto del: subsetI)"], ["", "lemma  m1a_implements_a0_is: \"implements med_a0m1a_is a0i m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0m1a_is a0i m1a", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv2i (inherited): Initiator and server\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>This is a translation of the agreement property to Level 1. It\nfollows from the refinement and is needed to prove inv1.\\<close>"], ["", "definition \n  m1a_inv2i_serv :: \"'x m1x_state_scheme set\"\nwhere\n  \"m1a_inv2i_serv \\<equiv> {s. \\<forall>A B Ra Kab nla.\n     A \\<notin> bad \\<longrightarrow>\n     runs s Ra = Some (Init, [A, B], aKey Kab # nla) \\<longrightarrow>\n       (\\<exists>Rs. Kab = sesK (Rs$sk) \\<and> \n         runs s Rs = Some (Serv, [A, B], aNon (Ra$na) # take is_len nla))\n  }\""], ["", "lemmas m1a_inv2i_servI = \n  m1a_inv2i_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1a_inv2i_servE =     (* DO NOT declare elim: leads to slow proofs! *)\n  m1a_inv2i_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1a_inv2i_servD =     (* DO NOT declare dest: leads to slow proofs! *)\n  m1a_inv2i_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Invariance proof, see below after init/serv authentication proof.\\<close>"], ["", "lemma PO_m1a_inv2i_serv [iff]:\n  \"reach m1a \\<subseteq> m1a_inv2i_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1a_inv2i_serv", "apply (rule INV_from_Refinement_basic [OF PO_m1a_refines_a0_is])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R_a0m1a_is \\<inter> a0i_inv1_iagree \\<times> m1a_inv0_fin)\n    \\<subseteq> m1a_inv2i_serv", "apply (auto simp add: R_a0m1a_is_def a0i_inv1_iagree_def \n            intro!: m1a_inv2i_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Ra Kab nla a.\n       \\<lbrakk>A \\<notin> bad;\n        runs x Ra = Some (Init, [A, B], aKey Kab # nla);\n        x \\<in> m1a_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a aa ab b.\n               is_runs2sigs (runs x) (Commit h (a, aa, ab, b))\n               \\<le> is_runs2sigs (runs x) (Running h (a, aa, ab, b)));\n        signals a = is_runs2sigs (runs x); corrupted a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            runs x Rs =\n                            Some\n                             (Serv, [A, B],\n                              aNon (Ra $ na) # take is_len nla)", "apply (drule_tac x=\"[A, Sv]\" in spec, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>inv1: Key freshness for initiator\\<close>"], ["", "(*inv**************************************************************************)"], ["", "text \\<open>The initiator obtains key freshness from the injective agreement\nwith the server AND the fact that there is only one server run with a \ngiven key.\\<close>"], ["", "definition \n  m1a_inv1_ifresh :: \"'x m1a_pred\"\nwhere\n  \"m1a_inv1_ifresh \\<equiv> {s. \\<forall>A A' B B' Ra Ra' Kab nl nl'.\n     runs s Ra  = Some (Init, [A,  B],  aKey Kab # nl) \\<longrightarrow>\n     runs s Ra' = Some (Init, [A', B'], aKey Kab # nl') \\<longrightarrow>\n     A \\<notin> bad \\<longrightarrow> B \\<notin> bad \\<longrightarrow> Kab \\<notin> leak s \\<longrightarrow>\n       Ra = Ra'\n  }\""], ["", "lemmas m1a_inv1_ifreshI = m1a_inv1_ifresh_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1a_inv1_ifreshE [elim] = m1a_inv1_ifresh_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1a_inv1_ifreshD = m1a_inv1_ifresh_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof\\<close>"], ["", "lemma PO_m1a_inv1_ifresh_init [iff]:\n  \"init m1a \\<subseteq> m1a_inv1_ifresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> m1a_inv1_ifresh", "by (auto simp add: m1a_defs intro!: m1a_inv1_ifreshI)"], ["", "lemma PO_m1a_inv1_ifresh_step4:\n  \"{m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter> m1x_secrecy} \n      m1a_step4 Ra A B Na Kab nla\n   {> m1a_inv1_ifresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n     m1x_secrecy} m1a_step4 Ra A B Na Kab nla {> m1a_inv1_ifresh}", "proof (auto simp add: PO_hoare_defs m1a_defs intro!: m1a_inv1_ifreshI,  (* UGLY *)\n       auto dest: m1a_inv1_ifreshD, auto dest: m1a_inv2i_servD)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A' B' Ra' nl' xa Rs.\n       \\<lbrakk>A \\<notin> bad; B \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> leak xa; xa \\<in> m1x_secrecy;\n        xa \\<in> m1a_inv1_ifresh; xa \\<in> m1a_inv2i_serv;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        (sesK (Rs $ sk), A) \\<in> azC (runs xa);\n        runs xa Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n        Kab = sesK (Rs $ sk); Ra' \\<noteq> Ra;\n        runs xa Ra' =\n        Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\\<rbrakk>\n       \\<Longrightarrow> False", "fix Rs Ra' A' B' nl' s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A' B' Ra' nl' xa Rs.\n       \\<lbrakk>A \\<notin> bad; B \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> leak xa; xa \\<in> m1x_secrecy;\n        xa \\<in> m1a_inv1_ifresh; xa \\<in> m1a_inv2i_serv;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        (sesK (Rs $ sk), A) \\<in> azC (runs xa);\n        runs xa Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n        Kab = sesK (Rs $ sk); Ra' \\<noteq> Ra;\n        runs xa Ra' =\n        Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\\<rbrakk>\n       \\<Longrightarrow> False", "assume H: \n    \"(sesK (Rs $ sk), A) \\<in> azC (runs s)\" \"sesK (Rs $ sk) \\<notin> leak s\" \n    \"A \\<notin> bad\" \"B \\<notin> bad\" \"Ra' \\<noteq> Ra\"\n    \"runs s Ra = Some (Init, [A, B], [])\" \n    \"runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\" \n    \"runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\"\n    \"s \\<in> m1x_secrecy\" \"s \\<in> m1a_inv2i_serv\""], ["proof (state)\nthis:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n\ngoal (2 subgoals):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>A' B' Ra' nl' xa Rs.\n       \\<lbrakk>A \\<notin> bad; B \\<notin> bad;\n        sesK (Rs $ sk) \\<notin> leak xa; xa \\<in> m1x_secrecy;\n        xa \\<in> m1a_inv1_ifresh; xa \\<in> m1a_inv2i_serv;\n        runs xa Ra = Some (Init, [A, B], []); Na = Ra $ na;\n        (sesK (Rs $ sk), A) \\<in> azC (runs xa);\n        runs xa Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n        Kab = sesK (Rs $ sk); Ra' \\<noteq> Ra;\n        runs xa Ra' =\n        Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"A' \\<in> bad\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<in> bad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  A' \\<in> bad\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<in> bad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "from H"], ["proof (chain)\npicking this:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv", "have \"(sesK (Rs$sk), A') \\<in> azC (runs s)\""], ["proof (prove)\nusing this:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n\ngoal (1 subgoal):\n 1. (sesK (Rs $ sk), A') \\<in> azC (runs s)", "by (elim m1x_secrecyE, auto)"], ["proof (state)\nthis:\n  (sesK (Rs $ sk), A') \\<in> azC (runs s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<in> bad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "with H True"], ["proof (chain)\npicking this:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n  A' \\<in> bad\n  (sesK (Rs $ sk), A') \\<in> azC (runs s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n  A' \\<in> bad\n  (sesK (Rs $ sk), A') \\<in> azC (runs s)\n\ngoal (1 subgoal):\n 1. False", "by (elim azC.cases) (auto dest: m1a_inv2i_servD)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  A' \\<notin> bad\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sesK (Rs $ sk), A) \\<in> azC (runs s);\n     sesK (Rs $ sk) \\<notin> leak s; A \\<notin> bad; B \\<notin> bad;\n     Ra' \\<noteq> Ra; runs s Ra = Some (Init, [A, B], []);\n     runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla);\n     runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl');\n     s \\<in> m1x_secrecy; s \\<in> m1a_inv2i_serv; A' \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  A' \\<notin> bad\n\ngoal (1 subgoal):\n 1. False", "using H"], ["proof (prove)\nusing this:\n  A' \\<notin> bad\n  (sesK (Rs $ sk), A) \\<in> azC (runs s)\n  sesK (Rs $ sk) \\<notin> leak s\n  A \\<notin> bad\n  B \\<notin> bad\n  Ra' \\<noteq> Ra\n  runs s Ra = Some (Init, [A, B], [])\n  runs s Rs = Some (Serv, [A, B], aNon (Ra $ na) # take is_len nla)\n  runs s Ra' = Some (Init, [A', B'], aKey (sesK (Rs $ sk)) # nl')\n  s \\<in> m1x_secrecy\n  s \\<in> m1a_inv2i_serv\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: m1a_inv2i_servD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False", "fix A' B' Ra' nl s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \n    \"(Kab, A) \\<in> azC (runs s)\" \"Kab \\<notin> leak s\" \n    \"A' \\<notin> bad\"  \"B' \\<notin> bad\" \"A \\<in> bad\" \"Ra' \\<noteq> Ra\"\n    \"runs s Ra' = Some (Init, [A', B'], aKey Kab # nl)\"\n    \"runs s Ra = Some (Init, [A, B], [])\"\n    \"s \\<in> m1a_inv2i_serv\""], ["proof (state)\nthis:\n  (Kab, A) \\<in> azC (runs s)\n  Kab \\<notin> leak s\n  A' \\<notin> bad\n  B' \\<notin> bad\n  A \\<in> bad\n  Ra' \\<noteq> Ra\n  runs s Ra' = Some (Init, [A', B'], aKey Kab # nl)\n  runs s Ra = Some (Init, [A, B], [])\n  s \\<in> m1a_inv2i_serv\n\ngoal (1 subgoal):\n 1. \\<And>Aa Ba Raa nl xa.\n       \\<lbrakk>Aa \\<notin> bad; Ba \\<notin> bad; Kab \\<notin> leak xa;\n        xa \\<in> m1x_secrecy; xa \\<in> m1a_inv1_ifresh;\n        xa \\<in> m1a_inv2i_serv; runs xa Ra = Some (Init, [A, B], []);\n        Na = Ra $ na; (Kab, A) \\<in> azC (runs xa); A \\<in> bad;\n        Raa \\<noteq> Ra;\n        runs xa Raa = Some (Init, [Aa, Ba], aKey Kab # nl)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (Kab, A) \\<in> azC (runs s)\n  Kab \\<notin> leak s\n  A' \\<notin> bad\n  B' \\<notin> bad\n  A \\<in> bad\n  Ra' \\<noteq> Ra\n  runs s Ra' = Some (Init, [A', B'], aKey Kab # nl)\n  runs s Ra = Some (Init, [A, B], [])\n  s \\<in> m1a_inv2i_serv\n\ngoal (1 subgoal):\n 1. False", "by (elim azC.cases, auto dest: m1a_inv2i_servD)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_m1a_inv1_ifresh_trans [iff]:\n  \"{m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter> m1x_secrecy} trans m1a {> m1a_inv1_ifresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n     m1x_secrecy} TS.trans m1a {> m1a_inv1_ifresh}", "proof (simp add: m1a_def m1a_trans_def, safe)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step1 xb x xa xe {> m1a_inv1_ifresh}\n 2. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step2 xc x xa {> m1a_inv1_ifresh}\n 3. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step3 xd x xa xf xe xg {> m1a_inv1_ifresh}\n 4. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step4 xb x xa xe xf xg {> m1a_inv1_ifresh}\n 5. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step5 xc x xa xf xg {> m1a_inv1_ifresh}\n 6. \\<And>x xa xb xc xd.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_leak xd {> m1a_inv1_ifresh}", "fix Ra A B Kab Ts nla"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step1 xb x xa xe {> m1a_inv1_ifresh}\n 2. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step2 xc x xa {> m1a_inv1_ifresh}\n 3. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step3 xd x xa xf xe xg {> m1a_inv1_ifresh}\n 4. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step4 xb x xa xe xf xg {> m1a_inv1_ifresh}\n 5. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step5 xc x xa xf xg {> m1a_inv1_ifresh}\n 6. \\<And>x xa xb xc xd.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_leak xd {> m1a_inv1_ifresh}", "show\n    \"{m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter> m1x_secrecy} \n        m1a_step4 Ra A B Kab Ts nla\n     {> m1a_inv1_ifresh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n     m1x_secrecy} m1a_step4 Ra A B Kab Ts nla {> m1a_inv1_ifresh}", "by (rule PO_m1a_inv1_ifresh_step4)"], ["proof (state)\nthis:\n  {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n   m1x_secrecy} m1a_step4 Ra A B Kab Ts nla {> m1a_inv1_ifresh}\n\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step1 xb x xa xe {> m1a_inv1_ifresh}\n 2. \\<And>x xa xb xc xd xe.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step2 xc x xa {> m1a_inv1_ifresh}\n 3. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step3 xd x xa xf xe xg {> m1a_inv1_ifresh}\n 4. \\<And>x xa xb xc xd xe xf xg.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_step5 xc x xa xf xg {> m1a_inv1_ifresh}\n 5. \\<And>x xa xb xc xd.\n       {m1a_inv1_ifresh \\<inter> m1a_inv2i_serv \\<inter>\n        m1x_secrecy} m1a_leak xd {> m1a_inv1_ifresh}", "qed (auto simp add: PO_hoare_defs m1a_defs intro!: m1a_inv1_ifreshI)"], ["", "lemma PO_m1a_inv1_ifresh [iff]: \"reach m1a \\<subseteq> m1a_inv1_ifresh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1a_inv1_ifresh", "by (rule_tac J=\" m1a_inv2i_serv \\<inter> m1x_secrecy\" in inv_rule_incr) \n   (auto simp add: Int_assoc del: subsetI)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement of \\<open>a0n\\<close> for responder/server\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>For the responder, we get a non-injective agreement with the server on \nthe session key, the initiator's name, and additional data.\\<close>"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>We define two auxiliary functions to reconstruct the signals of the\ninitial model from completed responder and server runs.\\<close>"], ["", "type_synonym\n  rssig = \"key \\<times> agent \\<times> atom list\""], ["", "abbreviation\n  rs_commit :: \"[runs_t, agent, agent, key, atom list] \\<Rightarrow> rid_t set\" \nwhere\n  \"rs_commit runz A B Kab rsl \\<equiv> {Rb. \\<exists>nlb. \n     runz Rb = Some (Resp, [A, B], aKey Kab # nlb) \\<and> take rs_len nlb = rsl \n  }\""], ["", "fun\n  rs_runs2sigs :: \"runs_t \\<Rightarrow> rssig signal \\<Rightarrow> nat\"\nwhere\n  \"rs_runs2sigs runz (Running [B, Sv] (Kab, A, rsl)) = \n     (if (\\<exists>Rs Na. Kab = sesK (Rs$sk) \\<and> \n           runz Rs = Some (Serv, [A, B], aNon Na # rsl)) \n      then 1 else 0)\"\n\n| \"rs_runs2sigs runz (Commit [B, Sv] (Kab, A, rsl)) = \n     card (rs_commit runz A B Kab rsl)\"\n\n| \"rs_runs2sigs runz _ = 0\""], ["", "text \\<open>Simulation relation and mediator function. We map completed initiator \nand responder runs to commit and running signals, respectively.\\<close>"], ["", "definition \n  med_a0m1a_rs :: \"m1a_obs \\<Rightarrow> rssig a0n_obs\" where\n  \"med_a0m1a_rs o1 \\<equiv> \\<lparr> signals = rs_runs2sigs (runs o1), corrupted = {} \\<rparr>\""], ["", "definition\n  R_a0m1a_rs :: \"(rssig a0n_state \\<times> m1a_state) set\" where\n  \"R_a0m1a_rs \\<equiv> {(s, t). signals s = rs_runs2sigs (runs t) \\<and> corrupted s = {} }\""], ["", "lemmas R_a0m1a_rs_defs = R_a0m1a_rs_def med_a0m1a_rs_def"], ["", "subsubsection \\<open>Lemmas about the auxiliary functions\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Other lemmas\\<close>"], ["", "lemma rs_runs2sigs_empty [simp]: \n  \"runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz = Map.empty \\<Longrightarrow> rs_runs2sigs runz = (\\<lambda>s. 0)", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto)"], ["", "lemma rs_commit_finite [simp, intro]:\n  \"finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom runz) \\<Longrightarrow> finite (rs_commit runz A B Kab nls)", "by (auto intro: finite_subset dest: dom_lemmas)"], ["", "text \\<open>Update lemmas\\<close>"], ["", "lemma rs_runs2sigs_upd_init_none [simp]:\n  \"\\<lbrakk> Ra \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ra \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], []))) = rs_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_resp_none [simp]:\n  \"\\<lbrakk> Rb \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rb \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], []))) = rs_runs2sigs runz", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_serv [simp]:\n  \"\\<lbrakk> Rs \\<notin> dom runz \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # nls))) = \n     (rs_runs2sigs runz)(Running [B, Sv] (sesK (Rs$sk), A, nls) := 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rs \\<notin> dom runz \\<Longrightarrow>\n    rs_runs2sigs (runz(Rs \\<mapsto> (Serv, [A, B], aNon Na # nls))) =\n    (rs_runs2sigs runz)(Running [B, Sv] (sesK (Rs $ sk), A, nls) := 1)", "by (rule ext, erule rev_mp) \n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_init_some [simp]:\n  \"\\<lbrakk> runz Ra = Some (Init, [A, B], []) \\<rbrakk>\n  \\<Longrightarrow> rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n     rs_runs2sigs runz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runz Ra = Some (Init, [A, B], []) \\<Longrightarrow>\n    rs_runs2sigs (runz(Ra \\<mapsto> (Init, [A, B], aKey Kab # nl))) =\n    rs_runs2sigs runz", "by (rule ext, erule rev_mp)\n   (rule rs_runs2sigs.induct, auto dest: dom_lemmas)"], ["", "lemma rs_runs2sigs_upd_resp_some [simp]:\n  \"\\<lbrakk> runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb \\<rbrakk>\n \\<Longrightarrow> rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n   (rs_runs2sigs runz)(\n      Commit [B, Sv] (Kab, A, rsl) := Suc (card (rs_commit runz A B Kab rsl)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>runz Rb = Some (Resp, [A, B], []); finite (dom runz);\n     rsl = take rs_len nlb\\<rbrakk>\n    \\<Longrightarrow> rs_runs2sigs\n                       (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) =\n                      (rs_runs2sigs runz)\n                      (Commit [B, Sv] (Kab, A, rsl) :=\n                         Suc (card (rs_commit runz A B Kab rsl)))", "apply (rule ext, (erule rev_mp)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rsl = take rs_len nlb \\<longrightarrow>\n       finite (dom runz) \\<longrightarrow>\n       runz Rb = Some (Resp, [A, B], []) \\<longrightarrow>\n       rs_runs2sigs (runz(Rb \\<mapsto> (Resp, [A, B], aKey Kab # nlb))) x =\n       ((rs_runs2sigs runz)\n        (Commit [B, Sv] (Kab, A, rsl) :=\n           Suc (card (rs_commit runz A B Kab rsl))))\n        x", "apply (rule rs_runs2sigs.induct, auto dest: dom_lemmas)\n\\<comment> \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>runz.\n       \\<lbrakk>rsl = take rs_len nlb; finite (dom runz);\n        runz Rb = Some (Resp, [A, B], [])\\<rbrakk>\n       \\<Longrightarrow> card\n                          {Rba.\n                           Rba \\<noteq> Rb \\<longrightarrow>\n                           (\\<exists>nlba.\n                               runz Rba =\n                               Some (Resp, [A, B], aKey Kab # nlba) \\<and>\n                               take rs_len nlba = take rs_len nlb)} =\n                         Suc (card\n                               (rs_commit runz A B Kab (take rs_len nlb)))", "apply (rule_tac s=\"card (insert Rb (rs_commit runz A B Kab (take rs_len nlb)))\" \n       in trans, fast, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m1a_step1_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step1 Ra A B Na) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step1 Ra A B Na {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs m1a_defs)"], ["", "lemma PO_m1a_step2_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step2 Rb A B) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step2 Rb A B {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs m1a_defs)"], ["", "lemma PO_m1a_step3_refines_a0_rs_running:\n  \"{R_a0m1a_rs} \n     (a0n_running [B, Sv] (Kab, A, nls)), \n     (m1a_step3 Rs A B Kab Na nls) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} a0i_running [B, Sv]\n                  (Kab, A, nls), m1a_step3 Rs A B Kab Na nls {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0i_defs m1a_defs\n         dest: dom_lemmas)"], ["", "lemma PO_m1a_step4_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_step4 Ra A B Na Kab nla) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_step4 Ra A B Na Kab nla {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0i_defs m1a_defs)"], ["", "lemma PO_m1a_step5_refines_a0_rs_commit:\n  \"{R_a0m1a_rs \\<inter> UNIV \\<times> m1a_inv0_fin} \n     (a0n_commit [B, Sv] (Kab, A, take rs_len nlb)), \n     (m1a_step5 Rb A B Kab nlb) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs \\<inter>\n     UNIV \\<times>\n     m1a_inv0_fin} a0n_commit [B, Sv]\n                    (Kab, A,\n                     take rs_len\n                      nlb), m1a_step5 Rb A B Kab nlb {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0i_defs m1a_defs)"], ["", "lemma PO_m1a_leak_refines_a0_rs_skip:\n  \"{R_a0m1a_rs} \n     Id, (m1a_leak Rs) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs} Id, m1a_leak Rs {> R_a0m1a_rs}", "by (auto simp add: PO_rhoare_defs R_a0m1a_rs_defs a0i_defs m1a_defs)"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m1a_trans_refines_a0_rs_trans = \n  PO_m1a_step1_refines_a0_rs_skip PO_m1a_step2_refines_a0_rs_skip\n  PO_m1a_step3_refines_a0_rs_running PO_m1a_step4_refines_a0_rs_skip\n  PO_m1a_step5_refines_a0_rs_commit PO_m1a_leak_refines_a0_rs_skip"], ["", "lemma PO_m1a_refines_init_ra0n [iff]:\n  \"init m1a \\<subseteq>  R_a0m1a_rs``(init a0n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m1a \\<subseteq> R_a0m1a_rs `` init a0n", "by (auto simp add: R_a0m1a_rs_defs a0n_defs m1a_defs)"], ["", "lemma PO_m1a_refines_trans_ra0n [iff]:\n  \"{R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin} \n     (trans a0n), (trans m1a) \n   {> R_a0m1a_rs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R_a0m1a_rs \\<inter>\n     a0n_inv1_niagree \\<times>\n     m1a_inv0_fin} TS.trans a0n, TS.trans m1a {> R_a0m1a_rs}", "by (force simp add: m1a_def m1a_trans_def a0n_def a0n_trans_def\n          intro!: PO_m1a_trans_refines_a0_rs_trans)"], ["", "lemma obs_consistent_med_a0m1a_rs [iff]: \n  \"obs_consistent \n     (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin) \n     med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent\n     (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin)\n     med_a0m1a_rs a0n m1a", "by (auto simp add: obs_consistent_def R_a0m1a_rs_def med_a0m1a_rs_def \n                   a0n_def m1a_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma PO_m1a_refines_a0_rs [iff]: \n  \"refines (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin) med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin)\n     med_a0m1a_rs a0n m1a", "by (rule Refinement_using_invariants) (auto)"], ["", "lemma m1a_implements_ra0n: \"implements med_a0m1a_rs a0n m1a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med_a0m1a_rs a0n m1a", "by (rule refinement_soundness) (fast)"], ["", "subsubsection \\<open>inv2r (inherited): Responder and server\\<close>"], ["", "(*invh*************************************************************************)"], ["", "text \\<open>This is a translation of the agreement property to Level 1. It\nfollows from the refinement and not needed here but later.\\<close>"], ["", "definition \n  m1a_inv2r_serv :: \"'x m1x_state_scheme set\"\nwhere\n  \"m1a_inv2r_serv \\<equiv> {s. \\<forall>A B Rb Kab nlb.\n     B \\<notin> bad \\<longrightarrow> \n     runs s Rb = Some (Resp, [A, B], aKey Kab # nlb) \\<longrightarrow>\n       (\\<exists>Rs Na. Kab = sesK (Rs$sk) \\<and>\n        runs s Rs = Some (Serv, [A, B], aNon Na # take rs_len nlb))\n  }\""], ["", "lemmas m1a_inv2r_servI = \n  m1a_inv2r_serv_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m1a_inv2r_servE [elim] = \n  m1a_inv2r_serv_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m1a_inv2r_servD = \n  m1a_inv2r_serv_def [THEN setc_def_to_dest, rule_format, rotated -1]"], ["", "text \\<open>Invariance proof\\<close>"], ["", "lemma PO_m1a_inv2r_serv [iff]:\n  \"reach m1a \\<subseteq> m1a_inv2r_serv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m1a \\<subseteq> m1a_inv2r_serv", "apply (rule INV_from_Refinement_basic [OF PO_m1a_refines_a0_rs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R_a0m1a_rs \\<inter> a0n_inv1_niagree \\<times> m1a_inv0_fin)\n    \\<subseteq> m1a_inv2r_serv", "apply (auto simp add: R_a0m1a_rs_def a0n_inv1_niagree_def intro!: m1a_inv2r_servI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab nlb a.\n       \\<lbrakk>B \\<notin> bad;\n        runs x Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        x \\<in> m1a_inv0_fin;\n        \\<forall>h.\n           set h \\<subseteq> good \\<longrightarrow>\n           (\\<forall>a aa b.\n               0 < rs_runs2sigs (runs x)\n                    (Commit h (a, aa, b)) \\<longrightarrow>\n               0 < rs_runs2sigs (runs x) (Running h (a, aa, b)));\n        signals a = rs_runs2sigs (runs x); corrupted a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some\n                                 (Serv, [A, B], aNon Na # take rs_len nlb))", "apply (rename_tac x A B Rb Kab nlb a, drule_tac x=\"[B, Sv]\" in spec, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Kab nlb a.\n       \\<lbrakk>\\<forall>a aa b.\n                   (\\<exists>Rs.\n                       a = sesK (Rs $ sk) \\<and>\n                       (\\<exists>Na.\n                           runs x Rs =\n                           Some (Serv, [aa, B], aNon Na # b))) \\<or>\n                   card (rs_commit (runs x) aa B a b) = 0;\n        B \\<notin> bad; runs x Rb = Some (Resp, [A, B], aKey Kab # nlb);\n        x \\<in> m1a_inv0_fin; signals a = rs_runs2sigs (runs x);\n        corrupted a = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rs.\n                            Kab = sesK (Rs $ sk) \\<and>\n                            (\\<exists>Na.\n                                runs x Rs =\n                                Some\n                                 (Serv, [A, B], aNon Na # take rs_len nlb))", "apply (rename_tac x A B Rb Kab nlb a, drule_tac x=\"Kab\" in spec, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}