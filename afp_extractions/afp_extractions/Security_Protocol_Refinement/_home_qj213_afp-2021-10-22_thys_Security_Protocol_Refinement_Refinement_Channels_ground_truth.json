{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Refinement/Channels.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemma keys_forI [dest]: \"DynCh c K M \\<in> H \\<Longrightarrow> K \\<in> keys_for H\"", "lemma keys_for_empty [simp]: \"keys_for {} = {}\"", "lemma keys_for_monotone: \"G \\<subseteq> H \\<Longrightarrow> keys_for G \\<subseteq> keys_for H\"", "lemmas keys_for_mono [elim] = keys_for_monotone [THEN [2] rev_subsetD]", "lemma keys_for_insert_StatCh [simp]: \n  \"keys_for (insert (StatCh c A B M) H) = keys_for H\"", "lemma keys_for_insert_DynCh [simp]: \n  \"keys_for (insert (DynCh c K M) H) = insert K (keys_for H)\"", "lemma atoms_empty [simp]: \"atoms {} = {}\"", "lemma atoms_monotone: \"G \\<subseteq> H \\<Longrightarrow> atoms G \\<subseteq> atoms H\"", "lemmas atoms_mono [elim] = atoms_monotone [THEN [2] rev_subsetD]", "lemma atoms_insert_StatCh [simp]: \n  \"atoms (insert (StatCh c A B (Msg M)) H) = set M \\<union> atoms H\"", "lemma atoms_insert_DynCh [simp]: \n  \"atoms (insert (DynCh c K (Msg M)) H) = set M \\<union> atoms H\"", "lemma ik0_aAgt [iff]: \"aAgt A \\<in> ik0\"", "lemma ik0_aNum [iff]: \"aNum T \\<in> ik0\"", "lemma ik0_aNon [iff]: \"aNon N \\<notin> ik0\"", "lemma ik0_aKey_corr [simp]: \"(aKey K \\<in> ik0) = (K \\<in> corrKey)\"", "lemma extr_empty [simp]: \"extr T {} = T\"", "lemma extr_monotone [dest]: \"G \\<subseteq> H \\<Longrightarrow> extr T G \\<subseteq> extr T H\"", "lemmas extr_mono [elim] = extr_monotone [THEN [2] rev_subsetD]", "lemma extr_monotone_param [dest]: \"T \\<subseteq> U \\<Longrightarrow> extr T H \\<subseteq> extr U H\"", "lemmas extr_mono_param [elim] = extr_monotone_param [THEN [2] rev_subsetD]", "lemma extr_insert [intro]: \"At \\<in> extr T H \\<Longrightarrow> At \\<in> extr T (insert C H)\"", "lemma extr_into_atoms [dest]: \"At \\<in> extr T H \\<Longrightarrow> At \\<in> T \\<union> atoms H\"", "lemma extr_insert_non_key_param [simp]:\n  assumes \"At \\<in> range aNon \\<union> range aAgt \\<union> range aNum\"\n  shows \"extr (insert At T) H = insert At (extr T H)\"", "lemma extr_insert_unused_key_param [simp]:\n  assumes \"K \\<notin> keys_for H\"\n  shows \"extr (insert (aKey K) T) H = insert (aKey K) (extr T H)\"", "lemma extr_insert_StatCh [simp]: \n  \"extr T (insert (StatCh c A B (Msg M)) H) \n   = (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad then extr (set M \\<union> T) H else extr T H)\"", "lemma extr_insert_DynCh [simp]: \n  \"extr T (insert (DynCh c K (Msg M)) H) \n   = (if confid \\<notin> c \\<or> aKey K \\<in> extr T H then extr (set M \\<union> T) H else extr T H)\"", "lemma rkeys_sesK [simp, dest]: \"sesK (R$i) \\<in> rkeys U \\<Longrightarrow> R \\<in> U\"", "lemmas fake_intros = fake_StatCh fake_DynCh", "lemma fake_expanding [intro]: \"H \\<subseteq> fake T U H\"", "lemma fake_monotone [intro]: \"G \\<subseteq> H \\<Longrightarrow> fake T U G \\<subseteq> fake T U H\"", "lemma fake_monotone_param1 [intro]: \n  \"T \\<subseteq> T' \\<Longrightarrow> fake T U H \\<subseteq> fake T' U H\"", "lemmas fake_mono [elim] = fake_monotone [THEN [2] rev_subsetD]", "lemmas fake_mono_param1 [elim] = fake_monotone_param1 [THEN [2] rev_subsetD]", "lemma atoms_fake [simp]: \"atoms (fake T U H) = T \\<union> atoms H\"", "lemma extr_fake [simp]: \n  assumes \"T' \\<subseteq> T\" shows \"extr T (fake T' U H) = extr T H\""], "translations": [["", "lemma keys_forI [dest]: \"DynCh c K M \\<in> H \\<Longrightarrow> K \\<in> keys_for H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DynCh c K M \\<in> H \\<Longrightarrow> K \\<in> keys_for H", "by (auto simp add: keys_for_def)"], ["", "lemma keys_for_empty [simp]: \"keys_for {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_for {} = {}", "by (simp add: keys_for_def)"], ["", "lemma keys_for_monotone: \"G \\<subseteq> H \\<Longrightarrow> keys_for G \\<subseteq> keys_for H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> keys_for G \\<subseteq> keys_for H", "by (auto simp add: keys_for_def)"], ["", "lemmas keys_for_mono [elim] = keys_for_monotone [THEN [2] rev_subsetD]"], ["", "lemma keys_for_insert_StatCh [simp]: \n  \"keys_for (insert (StatCh c A B M) H) = keys_for H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_for (insert (StatCh c A B M) H) = keys_for H", "by (auto simp add: keys_for_def)"], ["", "lemma keys_for_insert_DynCh [simp]: \n  \"keys_for (insert (DynCh c K M) H) = insert K (keys_for H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys_for (insert (DynCh c K M) H) = insert K (keys_for H)", "by (auto simp add: keys_for_def)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Atoms in a set of channel messages\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The set of atoms contained in a set of channel messages. We also \ninclude the public atoms, i.e., the agent names, numbers, and corrupted keys. \n\\<close>"], ["", "inductive_set \n  atoms :: \"chmsg set \\<Rightarrow> atom set\"\n  for H :: \"chmsg set\"\nwhere\n  at_StatCh: \"\\<lbrakk> StatCh c A B (Msg M) \\<in> H; At \\<in> set M \\<rbrakk> \\<Longrightarrow> At \\<in> atoms H\"\n| at_DynCh: \"\\<lbrakk> DynCh c K (Msg M) \\<in> H; At \\<in> set M \\<rbrakk> \\<Longrightarrow> At \\<in> atoms H\""], ["", "declare atoms.intros [intro]"], ["", "lemma atoms_empty [simp]: \"atoms {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms {} = {}", "by (auto elim!: atoms.cases)"], ["", "lemma atoms_monotone: \"G \\<subseteq> H \\<Longrightarrow> atoms G \\<subseteq> atoms H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> atoms G \\<subseteq> atoms H", "by (auto elim!: atoms.cases)"], ["", "lemmas atoms_mono [elim] = atoms_monotone [THEN [2] rev_subsetD]"], ["", "lemma atoms_insert_StatCh [simp]: \n  \"atoms (insert (StatCh c A B (Msg M)) H) = set M \\<union> atoms H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (insert (StatCh c A B (Msg M)) H) = set M \\<union> atoms H", "by (auto elim!: atoms.cases)"], ["", "lemma atoms_insert_DynCh [simp]: \n  \"atoms (insert (DynCh c K (Msg M)) H) = set M \\<union> atoms H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (insert (DynCh c K (Msg M)) H) = set M \\<union> atoms H", "by (auto elim!: atoms.cases)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Intruder knowledge (atoms)\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Atoms that the intruder can extract from a set of channel messages.\\<close>"], ["", "inductive_set \n  extr :: \"atom set \\<Rightarrow> chmsg set \\<Rightarrow> atom set\"\n  for T :: \"atom set\" \n  and H :: \"chmsg set\"\nwhere \n  extr_Inj: \"At \\<in> T \\<Longrightarrow> At \\<in> extr T H\"\n| extr_StatCh: \n    \"\\<lbrakk> StatCh c A B (Msg M) \\<in> H; At \\<in> set M; confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<rbrakk> \n   \\<Longrightarrow> At \\<in> extr T H\"\n| extr_DynCh: \n    \"\\<lbrakk> DynCh c K (Msg M) \\<in> H; At \\<in> set M; confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<rbrakk> \n   \\<Longrightarrow> At \\<in> extr T H\""], ["", "declare extr.intros [intro]"], ["", "declare extr.cases [elim]"], ["", "text\\<open>Typical parameter describing initial intruder knowledge.\\<close>"], ["", "definition\n  ik0 :: \"atom set\" where \n  \"ik0 \\<equiv> range aAgt \\<union> range aNum \\<union> aKey`corrKey\""], ["", "lemma ik0_aAgt [iff]: \"aAgt A \\<in> ik0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aAgt A \\<in> ik0", "by (auto simp add: ik0_def)"], ["", "lemma ik0_aNum [iff]: \"aNum T \\<in> ik0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aNum T \\<in> ik0", "by (auto simp add: ik0_def)"], ["", "lemma ik0_aNon [iff]: \"aNon N \\<notin> ik0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aNon N \\<notin> ik0", "by (auto simp add: ik0_def)"], ["", "lemma ik0_aKey_corr [simp]: \"(aKey K \\<in> ik0) = (K \\<in> corrKey)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aKey K \\<in> ik0) = (K \\<in> corrKey)", "by (auto simp add: ik0_def)"], ["", "subsubsection \\<open>Basic lemmas\\<close>"], ["", "(******************************************************************************)"], ["", "lemma extr_empty [simp]: \"extr T {} = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr T {} = T", "by (auto)"], ["", "lemma extr_monotone [dest]: \"G \\<subseteq> H \\<Longrightarrow> extr T G \\<subseteq> extr T H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> extr T G \\<subseteq> extr T H", "by (safe, erule extr.induct, auto)"], ["", "lemmas extr_mono [elim] = extr_monotone [THEN [2] rev_subsetD]"], ["", "lemma extr_monotone_param [dest]: \"T \\<subseteq> U \\<Longrightarrow> extr T H \\<subseteq> extr U H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> U \\<Longrightarrow> extr T H \\<subseteq> extr U H", "by (safe, erule extr.induct, auto)"], ["", "lemmas extr_mono_param [elim] = extr_monotone_param [THEN [2] rev_subsetD]"], ["", "lemma extr_insert [intro]: \"At \\<in> extr T H \\<Longrightarrow> At \\<in> extr T (insert C H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At \\<in> extr T H \\<Longrightarrow> At \\<in> extr T (insert C H)", "by (erule extr_mono) (auto)"], ["", "lemma extr_into_atoms [dest]: \"At \\<in> extr T H \\<Longrightarrow> At \\<in> T \\<union> atoms H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At \\<in> extr T H \\<Longrightarrow> At \\<in> T \\<union> atoms H", "by (erule extr.induct, auto)"], ["", "subsubsection \\<open>Insertion lemmas for atom parameters\\<close>"], ["", "(******************************************************************************)"], ["", "lemma extr_insert_non_key_param [simp]:\n  assumes \"At \\<in> range aNon \\<union> range aAgt \\<union> range aNum\"\n  shows \"extr (insert At T) H = insert At (extr T H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "fix Bt"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "assume \"Bt \\<in> extr (insert At T) H\""], ["proof (state)\nthis:\n  Bt \\<in> extr (insert At T) H\n\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "hence \"Bt \\<in> insert At (extr T H)\""], ["proof (prove)\nusing this:\n  Bt \\<in> extr (insert At T) H\n\ngoal (1 subgoal):\n 1. Bt \\<in> insert At (extr T H)", "using assms"], ["proof (prove)\nusing this:\n  Bt \\<in> extr (insert At T) H\n  At \\<in> range aNon \\<union> range aAgt \\<union> range aNum\n\ngoal (1 subgoal):\n 1. Bt \\<in> insert At (extr T H)", "by induct auto"], ["proof (state)\nthis:\n  Bt \\<in> insert At (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "}"], ["proof (state)\nthis:\n  ?Bt2 \\<in> extr (insert At T) H \\<Longrightarrow>\n  ?Bt2 \\<in> insert At (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?Bt2 \\<in> extr (insert At T) H \\<Longrightarrow>\n  ?Bt2 \\<in> insert At (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert At T) H = insert At (extr T H)", "by auto"], ["proof (state)\nthis:\n  extr (insert At T) H = insert At (extr T H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extr_insert_unused_key_param [simp]:\n  assumes \"K \\<notin> keys_for H\"\n  shows \"extr (insert (aKey K) T) H = insert (aKey K) (extr T H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "fix At"], ["proof (state)\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "assume \"At \\<in> extr (insert (aKey K) T) H\""], ["proof (state)\nthis:\n  At \\<in> extr (insert (aKey K) T) H\n\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "hence \"At \\<in> insert (aKey K) (extr T H)\""], ["proof (prove)\nusing this:\n  At \\<in> extr (insert (aKey K) T) H\n\ngoal (1 subgoal):\n 1. At \\<in> insert (aKey K) (extr T H)", "using assms"], ["proof (prove)\nusing this:\n  At \\<in> extr (insert (aKey K) T) H\n  K \\<notin> keys_for H\n\ngoal (1 subgoal):\n 1. At \\<in> insert (aKey K) (extr T H)", "by induct (auto simp add: keys_for_def)"], ["proof (state)\nthis:\n  At \\<in> insert (aKey K) (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> extr (insert (aKey K) T) H \\<Longrightarrow>\n  ?At2 \\<in> insert (aKey K) (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?At2 \\<in> extr (insert (aKey K) T) H \\<Longrightarrow>\n  ?At2 \\<in> insert (aKey K) (extr T H)\n\ngoal (1 subgoal):\n 1. extr (insert (aKey K) T) H = insert (aKey K) (extr T H)", "by auto"], ["proof (state)\nthis:\n  extr (insert (aKey K) T) H = insert (aKey K) (extr T H)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Insertion lemmas for each type of channel message\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Note that the parameter accumulates the extracted atoms. In particular, \nthese may include keys that may open further dynamically confidential messages. \n\\<close>"], ["", "lemma extr_insert_StatCh [simp]: \n  \"extr T (insert (StatCh c A B (Msg M)) H) \n   = (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad then extr (set M \\<union> T) H else extr T H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "proof (cases \"confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\")"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "case True"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "{"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "fix At"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "assume \"At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\""], ["proof (state)\nthis:\n  At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "hence \"At \\<in> extr (set M \\<union> T) H\""], ["proof (prove)\nusing this:\n  At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n\ngoal (1 subgoal):\n 1. At \\<in> extr (set M \\<union> T) H", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "{"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "fix At"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "assume \"At \\<in> extr (set M \\<union> T) H\" \n    and    \"confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\""], ["proof (state)\nthis:\n  At \\<in> extr (set M \\<union> T) H\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "hence \"At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\""], ["proof (prove)\nusing this:\n  At \\<in> extr (set M \\<union> T) H\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n\ngoal (1 subgoal):\n 1. At \\<in> extr T (insert (StatCh c A B (Msg M)) H)", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?At2 \\<in> extr (set M \\<union> T) H;\n   confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "ultimately"], ["proof (chain)\npicking this:\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n  ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n  \\<lbrakk>?At2 \\<in> extr (set M \\<union> T) H;\n   confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H)", "show ?thesis"], ["proof (prove)\nusing this:\n  confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n  ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n  \\<lbrakk>?At2 \\<in> extr (set M \\<union> T) H;\n   confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n\ngoal (1 subgoal):\n 1. extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "by auto"], ["proof (state)\nthis:\n  extr T (insert (StatCh c A B (Msg M)) H) =\n  (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n   then extr (set M \\<union> T) H else extr T H)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "case False"], ["proof (state)\nthis:\n  \\<not> (confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  \\<not> (confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "{"], ["proof (state)\nthis:\n  \\<not> (confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "fix At"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "assume \"At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\"\n    and \"confid \\<in> c\" \"A \\<notin> bad\" \"B \\<notin> bad\""], ["proof (state)\nthis:\n  At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n  confid \\<in> c\n  A \\<notin> bad\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "hence \"At \\<in> extr T H\""], ["proof (prove)\nusing this:\n  At \\<in> extr T (insert (StatCh c A B (Msg M)) H)\n  confid \\<in> c\n  A \\<notin> bad\n  B \\<notin> bad\n\ngoal (1 subgoal):\n 1. At \\<in> extr T H", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr T H\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H);\n   confid \\<in> c; A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T H\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or>\n            A \\<in> bad \\<or> B \\<in> bad) \\<Longrightarrow>\n    extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad)\n  \\<lbrakk>?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H);\n   confid \\<in> c; A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T H", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad)\n  \\<lbrakk>?At2 \\<in> extr T (insert (StatCh c A B (Msg M)) H);\n   confid \\<in> c; A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n  \\<Longrightarrow> ?At2 \\<in> extr T H\n\ngoal (1 subgoal):\n 1. extr T (insert (StatCh c A B (Msg M)) H) =\n    (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then extr (set M \\<union> T) H else extr T H)", "by auto"], ["proof (state)\nthis:\n  extr T (insert (StatCh c A B (Msg M)) H) =\n  (if confid \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad\n   then extr (set M \\<union> T) H else extr T H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extr_insert_DynCh [simp]: \n  \"extr T (insert (DynCh c K (Msg M)) H) \n   = (if confid \\<notin> c \\<or> aKey K \\<in> extr T H then extr (set M \\<union> T) H else extr T H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "proof (cases \"confid \\<notin> c \\<or> aKey K \\<in> extr T H\")"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "case True"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "{"], ["proof (state)\nthis:\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "fix At"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "assume \"At \\<in> extr T (insert (DynCh c K (Msg M)) H)\""], ["proof (state)\nthis:\n  At \\<in> extr T (insert (DynCh c K (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "hence \"At \\<in> extr (set M \\<union> T) H\""], ["proof (prove)\nusing this:\n  At \\<in> extr T (insert (DynCh c K (Msg M)) H)\n\ngoal (1 subgoal):\n 1. At \\<in> extr (set M \\<union> T) H", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "{"], ["proof (state)\nthis:\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "fix At"], ["proof (state)\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "assume \"At \\<in> extr (set M \\<union> T) H\""], ["proof (state)\nthis:\n  At \\<in> extr (set M \\<union> T) H\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "hence \"At \\<in> extr T (insert (DynCh c K (Msg M)) H)\""], ["proof (prove)\nusing this:\n  At \\<in> extr (set M \\<union> T) H\n\ngoal (1 subgoal):\n 1. At \\<in> extr T (insert (DynCh c K (Msg M)) H)", "using True"], ["proof (prove)\nusing this:\n  At \\<in> extr (set M \\<union> T) H\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n\ngoal (1 subgoal):\n 1. At \\<in> extr T (insert (DynCh c K (Msg M)) H)", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr T (insert (DynCh c K (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> extr (set M \\<union> T) H \\<Longrightarrow>\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H)\n\ngoal (2 subgoals):\n 1. confid \\<notin> c \\<or> aKey K \\<in> extr T H \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)\n 2. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "ultimately"], ["proof (chain)\npicking this:\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n  ?At2 \\<in> extr (set M \\<union> T) H \\<Longrightarrow>\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H)", "show ?thesis"], ["proof (prove)\nusing this:\n  confid \\<notin> c \\<or> aKey K \\<in> extr T H\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H) \\<Longrightarrow>\n  ?At2 \\<in> extr (set M \\<union> T) H\n  ?At2 \\<in> extr (set M \\<union> T) H \\<Longrightarrow>\n  ?At2 \\<in> extr T (insert (DynCh c K (Msg M)) H)\n\ngoal (1 subgoal):\n 1. extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "by auto"], ["proof (state)\nthis:\n  extr T (insert (DynCh c K (Msg M)) H) =\n  (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n   then extr (set M \\<union> T) H else extr T H)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "case False"], ["proof (state)\nthis:\n  \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "moreover"], ["proof (state)\nthis:\n  \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H)\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "hence \"extr T (insert (DynCh c K (Msg M)) H) = extr T H\""], ["proof (prove)\nusing this:\n  \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H)\n\ngoal (1 subgoal):\n 1. extr T (insert (DynCh c K (Msg M)) H) = extr T H", "by (intro equalityI subsetI) (erule extr.induct, auto)+"], ["proof (state)\nthis:\n  extr T (insert (DynCh c K (Msg M)) H) = extr T H\n\ngoal (1 subgoal):\n 1. \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H) \\<Longrightarrow>\n    extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H)\n  extr T (insert (DynCh c K (Msg M)) H) = extr T H", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (confid \\<notin> c \\<or> aKey K \\<in> extr T H)\n  extr T (insert (DynCh c K (Msg M)) H) = extr T H\n\ngoal (1 subgoal):\n 1. extr T (insert (DynCh c K (Msg M)) H) =\n    (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n     then extr (set M \\<union> T) H else extr T H)", "by auto"], ["proof (state)\nthis:\n  extr T (insert (DynCh c K (Msg M)) H) =\n  (if confid \\<notin> c \\<or> aKey K \\<in> extr T H\n   then extr (set M \\<union> T) H else extr T H)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare extr.cases [rule del, elim]"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Faking messages\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Channel messages that are fakeable from a given set of channel\nmessages.  Parameters are a set of atoms and a set of freshness identifiers.\n\nFor faking messages on dynamic non-authentic channels, we cannot allow the\nintruder to use arbitrary keys. Otherwise, we would lose the possibility to \ngenerate fresh values in our model. Therefore, the chosen keys must correspond\nto session keys associated with existing runs (i.e., from set \n@{term \"rkeys U\"}).\n\\<close>"], ["", "abbreviation \n  rkeys :: \"fid_t set \\<Rightarrow> key set\" where\n  \"rkeys U \\<equiv> sesK`(\\<lambda>(x, y). x $ y)`(U \\<times> (UNIV::nat set))\""], ["", "lemma rkeys_sesK [simp, dest]: \"sesK (R$i) \\<in> rkeys U \\<Longrightarrow> R \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sesK (R $ i) \\<in> rkeys U \\<Longrightarrow> R \\<in> U", "by (auto simp add: image_def)"], ["", "inductive_set \n  fake :: \"atom set \\<Rightarrow> fid_t set \\<Rightarrow> chmsg set \\<Rightarrow> chmsg set\"\n  for T :: \"atom set\"\n  and U :: \"fid_t set\"\n  and H :: \"chmsg set\"\nwhere \n  fake_Inj:\n    \"M \\<in> H \\<Longrightarrow> M \\<in> fake T U H\"\n| fake_StatCh: \n    \"\\<lbrakk> set M \\<subseteq> extr T H; auth \\<notin> c \\<or> A \\<in> bad \\<or> B \\<in> bad  \\<rbrakk> \n   \\<Longrightarrow> StatCh c A B (Msg M) \\<in> fake T U H\"\n| fake_DynCh:  \n    \"\\<lbrakk> set M \\<subseteq> extr T H; auth \\<notin> c \\<and> K \\<in> rkeys U \\<or> aKey K \\<in> extr T H \\<rbrakk> \n   \\<Longrightarrow> DynCh c K (Msg M) \\<in> fake T U H\""], ["", "declare fake.cases [elim]"], ["", "declare fake.intros [intro]"], ["", "lemmas fake_intros = fake_StatCh fake_DynCh"], ["", "lemma fake_expanding [intro]: \"H \\<subseteq> fake T U H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> fake T U H", "by (auto)"], ["", "lemma fake_monotone [intro]: \"G \\<subseteq> H \\<Longrightarrow> fake T U G \\<subseteq> fake T U H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> fake T U G \\<subseteq> fake T U H", "by (safe, erule fake.cases, auto intro!: fake_intros)"], ["", "lemma fake_monotone_param1 [intro]: \n  \"T \\<subseteq> T' \\<Longrightarrow> fake T U H \\<subseteq> fake T' U H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> T' \\<Longrightarrow> fake T U H \\<subseteq> fake T' U H", "by (safe, erule fake.cases, auto intro!: fake_intros)"], ["", "lemmas fake_mono [elim] = fake_monotone [THEN [2] rev_subsetD]"], ["", "lemmas fake_mono_param1 [elim] = fake_monotone_param1 [THEN [2] rev_subsetD]"], ["", "subsubsection \\<open>Atoms and extr together with fake\\<close>"], ["", "(******************************************************************************)"], ["", "lemma atoms_fake [simp]: \"atoms (fake T U H) = T \\<union> atoms H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "fix At"], ["proof (state)\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "assume \"At \\<in> T\""], ["proof (state)\nthis:\n  At \\<in> T\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "hence \"At \\<in> atoms (fake T U H)\""], ["proof (prove)\nusing this:\n  At \\<in> T\n\ngoal (1 subgoal):\n 1. At \\<in> atoms (fake T U H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. At \\<in> T \\<Longrightarrow> At \\<in> atoms (fake T U H)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. At \\<in> T \\<Longrightarrow> At \\<in> atoms (fake T U H)", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. At \\<in> T \\<Longrightarrow> At \\<in> atoms (fake T U H)", "have \"Insec A B (Msg [At]) \\<in> fake T U H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Insec A B (Msg [At]) \\<in> fake T U H", "using \\<open>At \\<in> T\\<close>"], ["proof (prove)\nusing this:\n  At \\<in> T\n\ngoal (1 subgoal):\n 1. Insec A B (Msg [At]) \\<in> fake T U H", "by (intro fake_StatCh) (auto)"], ["proof (state)\nthis:\n  Insec A B (Msg [At]) \\<in> fake T U H\n\ngoal (1 subgoal):\n 1. At \\<in> T \\<Longrightarrow> At \\<in> atoms (fake T U H)", "}"], ["proof (state)\nthis:\n  Insec ?A2 ?B2 (Msg [At]) \\<in> fake T U H\n\ngoal (1 subgoal):\n 1. At \\<in> T \\<Longrightarrow> At \\<in> atoms (fake T U H)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Insec ?A2 ?B2 (Msg [At]) \\<in> fake T U H\n\ngoal (1 subgoal):\n 1. At \\<in> atoms (fake T U H)", "by (intro at_StatCh) (auto)"], ["proof (state)\nthis:\n  At \\<in> atoms (fake T U H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  At \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> T \\<Longrightarrow> ?At2 \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "moreover"], ["proof (state)\nthis:\n  ?At2 \\<in> T \\<Longrightarrow> ?At2 \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "{"], ["proof (state)\nthis:\n  ?At2 \\<in> T \\<Longrightarrow> ?At2 \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "fix At"], ["proof (state)\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "assume \"At \\<in> atoms (fake T U H) \""], ["proof (state)\nthis:\n  At \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "hence \"At \\<in> T \\<union> atoms H\""], ["proof (prove)\nusing this:\n  At \\<in> atoms (fake T U H)\n\ngoal (1 subgoal):\n 1. At \\<in> T \\<union> atoms H", "by cases blast+"], ["proof (state)\nthis:\n  At \\<in> T \\<union> atoms H\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "}"], ["proof (state)\nthis:\n  ?At2 \\<in> atoms (fake T U H) \\<Longrightarrow>\n  ?At2 \\<in> T \\<union> atoms H\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "ultimately"], ["proof (chain)\npicking this:\n  ?At2 \\<in> T \\<Longrightarrow> ?At2 \\<in> atoms (fake T U H)\n  ?At2 \\<in> atoms (fake T U H) \\<Longrightarrow>\n  ?At2 \\<in> T \\<union> atoms H", "show ?thesis"], ["proof (prove)\nusing this:\n  ?At2 \\<in> T \\<Longrightarrow> ?At2 \\<in> atoms (fake T U H)\n  ?At2 \\<in> atoms (fake T U H) \\<Longrightarrow>\n  ?At2 \\<in> T \\<union> atoms H\n\ngoal (1 subgoal):\n 1. atoms (fake T U H) = T \\<union> atoms H", "by auto"], ["proof (state)\nthis:\n  atoms (fake T U H) = T \\<union> atoms H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extr_fake [simp]: \n  assumes \"T' \\<subseteq> T\" shows \"extr T (fake T' U H) = extr T H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr T (fake T' U H) = extr T H", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> extr T (fake T' U H) \\<Longrightarrow> x \\<in> extr T H\n 2. \\<And>x. x \\<in> extr T H \\<Longrightarrow> x \\<in> extr T (fake T' U H)", "fix At"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> extr T (fake T' U H) \\<Longrightarrow> x \\<in> extr T H\n 2. \\<And>x. x \\<in> extr T H \\<Longrightarrow> x \\<in> extr T (fake T' U H)", "assume \"At \\<in> extr T (fake T' U H)\""], ["proof (state)\nthis:\n  At \\<in> extr T (fake T' U H)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> extr T (fake T' U H) \\<Longrightarrow> x \\<in> extr T H\n 2. \\<And>x. x \\<in> extr T H \\<Longrightarrow> x \\<in> extr T (fake T' U H)", "with assms"], ["proof (chain)\npicking this:\n  T' \\<subseteq> T\n  At \\<in> extr T (fake T' U H)", "have \"At \\<in> extr T (fake T U H)\""], ["proof (prove)\nusing this:\n  T' \\<subseteq> T\n  At \\<in> extr T (fake T' U H)\n\ngoal (1 subgoal):\n 1. At \\<in> extr T (fake T U H)", "by auto"], ["proof (state)\nthis:\n  At \\<in> extr T (fake T U H)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> extr T (fake T' U H) \\<Longrightarrow> x \\<in> extr T H\n 2. \\<And>x. x \\<in> extr T H \\<Longrightarrow> x \\<in> extr T (fake T' U H)", "thus \"At \\<in> extr T H\""], ["proof (prove)\nusing this:\n  At \\<in> extr T (fake T U H)\n\ngoal (1 subgoal):\n 1. At \\<in> extr T H", "by induct auto"], ["proof (state)\nthis:\n  At \\<in> extr T H\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> extr T H \\<Longrightarrow> x \\<in> extr T (fake T' U H)", "qed auto"], ["", "(*\nlemma extr_fake [simp]: \"extr T (fake T U H) = extr T H\"\nproof -\n  {\n    fix At\n    assume \"At \\<in> extr T (fake T U H)\"\n    hence \"At \\<in> extr T H\" by induct auto\n  }\n  thus ?thesis by auto\nqed\n*)"], ["", "end"]]}