{"file_name": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement/Auth_simple/m3_sig.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Security_Protocol_Refinement", "problem_names": ["lemmas m3_defs =\n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def\n  m3_DY_fake_def", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]", "lemmas m3_inv1_lkeysecI =\n  m3_inv1_lkeysec_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv1_lkeysecE [elim] =\n  m3_inv1_lkeysec_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv1_lkeysecD =\n  m3_inv1_lkeysec_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m3_inv1_lkeysec_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_lkeysec\"", "lemma PO_m3_inv1_lkeysec_trans [iff]:\n  \"{m3_inv1_lkeysec} trans m3 {> m3_inv1_lkeysec}\"", "lemma PO_m3_inv1_lkeysec [iff]: \"reach m3 \\<subseteq> m3_inv1_lkeysec\"", "lemmas m3_inv2_badkeysI =\n  m3_inv2_badkeys_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv2_badkeysE [elim] =\n  m3_inv2_badkeys_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv2_badkeysD [dest] =\n  m3_inv2_badkeys_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m3_inv2_badkeys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv2_badkeys\"", "lemma PO_m3_inv2_badkeys_trans [iff]:\n  \"{m3_inv2_badkeys} trans m3 {> m3_inv2_badkeys}\"", "lemma PO_m3_inv2_badkeys [iff]: \"reach m3 \\<subseteq> m3_inv2_badkeys\"", "lemmas m3_inv3_pubkeysI =\n  m3_inv3_pubkeys_def [THEN setc_def_to_intro, rule_format]", "lemmas m3_inv3_pubkeysE [elim] =\n  m3_inv3_pubkeys_def [THEN setc_def_to_elim, rule_format]", "lemmas m3_inv3_pubkeysD [dest] =\n  m3_inv3_pubkeys_def [THEN setc_def_to_dest, rule_format, rotated 1]", "lemma PO_m3_inv3_pubkeys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv3_pubkeys\"", "lemma PO_m3_inv3_pubkeys_trans [iff]:\n  \"{m3_inv3_pubkeys} trans m3 {> m3_inv3_pubkeys}\"", "lemma PO_m3_inv3_pubkeys [iff]: \"reach m3 \\<subseteq> m3_inv3_pubkeys\"", "lemmas MPair_parts [rule del, elim]", "lemmas MPair_analz [rule del, elim]", "lemmas R23_defs = R23_def R23_msgs_def R23_ink_def R23_preserved_def", "lemmas R23_msgsI =\n  R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_msgsE [elim] =\n  R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_msgsE' [elim] =\n  R23_msgs_def [THEN rel_def_to_dest, simplified, rule_format, THEN subsetD]", "lemmas R23_inkI =\n  R23_ink_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_inkE [elim] =\n  R23_ink_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_preservedI =\n  R23_preserved_def [THEN rel_def_to_intro, simplified, rule_format]", "lemmas R23_preservedE [elim] =\n  R23_preserved_def [THEN rel_def_to_elim, simplified, rule_format]", "lemmas R23_intros = R23_msgsI R23_inkI R23_preservedI", "lemma abs_msg_empty: \"abs_msg {} = {}\"", "lemma abs_msg_Un [simp]:\n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\"", "lemma abs_msg_mono [elim]:\n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\"", "lemma abs_msg_insert_mono [intro]:\n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\"", "lemma abs_msg_DY_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink; t \\<in> m3_inv1_lkeysec \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\"", "lemma absmsg_parts_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs \\<rbrakk>\n  \\<Longrightarrow> abs_msg (parts (IK t)) \\<subseteq> fake ik0 (-dom (runs s)) (chan s)\"", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23}\n     (m2_step1 Ra A B Na), (m3_step1 Ra A B Na)\n   {> R23}\"", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23 \\<^cancel>\\<open>\\<inter> UNIV \\<times> m3_inv3_pubkeys\\<close>}\n     (m2_step2 Rb A B Na Nb), (m3_step2 Rb A B Na Nb)\n   {> R23}\"", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23}\n     (m2_step3 Ra A B Na Nb), (m3_step3 Ra A B Na Nb)\n   {> R23}\"", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec \\<inter> m3_inv2_badkeys)}\n     m2_fake, m3_DY_fake\n   {> R23}\"", "lemmas PO_m3_trans_refines_m2_trans =\n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2\n  PO_m3_step3_refines_m2_step3 PO_m3_DY_fake_refines_m2_fake", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\"", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv2_badkeys \\<inter> m3_inv1_lkeysec)}\n     (trans m2), (trans m3)\n   {> R23}\"", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R23 med32 m2 m3\"", "lemma PO_m3_refines_m2:\n  \"refines\n     (R23 \\<inter> UNIV \\<times> (m3_inv2_badkeys \\<inter> m3_inv1_lkeysec))\n     med32 m2 m3\""], "translations": [["", "lemmas m3_defs =\n  m3_def m3_init_def m3_trans_def m3_obs_def\n  m3_step1_def m3_step2_def m3_step3_def\n  m3_DY_fake_def"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Specialize injectiveness of parts to enable aggressive application.\\<close>"], ["", "lemmas parts_Inj_IK = parts.Inj [where H=\"IK s\" for s]"], ["", "lemmas analz_Inj_IK = analz.Inj [where H=\"IK s\" for s]"], ["", "text \\<open>The following invariants do not depend on the protocol messages.\nWe want to keep this compilation refinement from channel protocols to\nfull-fledged Dolev-Yao protocols as generic as possible.\\<close>"], ["", "subsubsection \\<open>inv1: Long-term key secrecy\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Private signing keys are secret, that is, the intruder only knows\nprivate keys of corrupted agents.\n\nThe invariant uses the weaker @{term parts} operator instead of the perhaps\nmore intuitive @{term analz} in its premise.  This strengthens the invariant\nand potentially simplifies its proof.\n\\<close>"], ["", "definition\n  m3_inv1_lkeysec :: \"m3_state set\" where\n  \"m3_inv1_lkeysec \\<equiv> {s. \\<forall> A.\n     Key (priK A) \\<in> analz (IK s) \\<longrightarrow> A \\<in> bad\n  }\""], ["", "lemmas m3_inv1_lkeysecI =\n  m3_inv1_lkeysec_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv1_lkeysecE [elim] =\n  m3_inv1_lkeysec_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv1_lkeysecD =\n  m3_inv1_lkeysec_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "lemma PO_m3_inv1_lkeysec_init [iff]:\n  \"init m3 \\<subseteq> m3_inv1_lkeysec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> m3_inv1_lkeysec", "by (auto simp add: PO_hoare_def m3_defs intro!: m3_inv1_lkeysecI)"], ["", "lemma PO_m3_inv1_lkeysec_trans [iff]:\n  \"{m3_inv1_lkeysec} trans m3 {> m3_inv1_lkeysec}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m3_inv1_lkeysec} TS.trans m3 {> m3_inv1_lkeysec}", "by (auto simp add: PO_hoare_def m3_defs intro!: m3_inv1_lkeysecI)"], ["", "lemma PO_m3_inv1_lkeysec [iff]: \"reach m3 \\<subseteq> m3_inv1_lkeysec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m3 \\<subseteq> m3_inv1_lkeysec", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2: Intruder knows long-term keys of bad guys\\<close>"], ["", "(******************************************************************************)"], ["", "definition\n  m3_inv2_badkeys :: \"m3_state set\"\nwhere\n  \"m3_inv2_badkeys \\<equiv> {s. \\<forall>C.\n     C \\<in> bad \\<longrightarrow> Key (priK C) \\<in> analz (IK s)\n  }\""], ["", "lemmas m3_inv2_badkeysI =\n  m3_inv2_badkeys_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv2_badkeysE [elim] =\n  m3_inv2_badkeys_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv2_badkeysD [dest] =\n  m3_inv2_badkeys_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m3_inv2_badkeys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv2_badkeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> m3_inv2_badkeys", "by (auto simp add: m3_defs m3_inv2_badkeys_def)"], ["", "lemma PO_m3_inv2_badkeys_trans [iff]:\n  \"{m3_inv2_badkeys} trans m3 {> m3_inv2_badkeys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m3_inv2_badkeys} TS.trans m3 {> m3_inv2_badkeys}", "by (auto simp add: PO_hoare_defs m3_defs intro!: m3_inv2_badkeysI)"], ["", "lemma PO_m3_inv2_badkeys [iff]: \"reach m3 \\<subseteq> m3_inv2_badkeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m3 \\<subseteq> m3_inv2_badkeys", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3: Intruder knows all public keys (NOT USED)\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>This invariant is only needed with equality in \\<open>R23_msgs\\<close>.\\<close>"], ["", "definition\n  m3_inv3_pubkeys :: \"m3_state set\"\nwhere\n  \"m3_inv3_pubkeys \\<equiv> {s. \\<forall>C.\n     Key (pubK C) \\<in> analz (IK s)\n  }\""], ["", "lemmas m3_inv3_pubkeysI =\n  m3_inv3_pubkeys_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas m3_inv3_pubkeysE [elim] =\n  m3_inv3_pubkeys_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas m3_inv3_pubkeysD [dest] =\n  m3_inv3_pubkeys_def [THEN setc_def_to_dest, rule_format, rotated 1]"], ["", "text \\<open>Invariance proof.\\<close>"], ["", "lemma PO_m3_inv3_pubkeys_init [iff]:\n  \"init m3 \\<subseteq> m3_inv3_pubkeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> m3_inv3_pubkeys", "by (auto simp add: m3_defs m3_inv3_pubkeys_def)"], ["", "lemma PO_m3_inv3_pubkeys_trans [iff]:\n  \"{m3_inv3_pubkeys} trans m3 {> m3_inv3_pubkeys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m3_inv3_pubkeys} TS.trans m3 {> m3_inv3_pubkeys}", "by (auto simp add: PO_hoare_defs m3_defs intro!: m3_inv3_pubkeysI)"], ["", "lemma PO_m3_inv3_pubkeys [iff]: \"reach m3 \\<subseteq> m3_inv3_pubkeys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach m3 \\<subseteq> m3_inv3_pubkeys", "by (rule inv_rule_basic) (auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Automatic tool tuning. Tame too-agressive pair decomposition, which is\ndeclared as a safe elim rule ([elim!]).\\<close>"], ["", "lemmas MPair_parts [rule del, elim]"], ["", "lemmas MPair_analz [rule del, elim]"], ["", "subsubsection \\<open>Simulation relation\\<close>"], ["", "(******************************************************************************)"], ["", "abbreviation\n  nonces :: \"msg set \\<Rightarrow> nonce set\"\nwhere\n  \"nonces H \\<equiv> {N. Nonce N \\<in> analz H}\""], ["", "abbreviation\n  ink :: \"chmsg set \\<Rightarrow> nonce set\"\nwhere\n  \"ink H \\<equiv> {N. aNon N \\<in> extr ik0 H}\""], ["", "text \\<open>Abstraction function on sets of messages.\\<close>"], ["", "inductive_set\n  abs_msg :: \"msg set \\<Rightarrow> chmsg set\"\n  for H :: \"msg set\"\nwhere\n  am_M1:\n    \"\\<lbrace>Agent A, Agent B, Nonce Na\\<rbrace> \\<in> H\n  \\<Longrightarrow> Insec A B (Msg [aNon Na]) \\<in> abs_msg H\"\n\n| am_M2:\n    \"Crypt (priK B) \\<lbrace>Nonce Nb, Nonce Na, Agent A\\<rbrace> \\<in> H\n  \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na]) \\<in> abs_msg H\""], ["", "text \\<open>The simulation relation is canonical. It states that the protocol\nmessages in the intruder knowledge refine the abstract messages appearing in\nthe channels @{term Insec} and @{term Auth}.\\<close>"], ["", "definition\n  R23_msgs :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_msgs \\<equiv> {(s, t). abs_msg (parts (IK t)) \\<subseteq> chan s}\"   \\<comment> \\<open>with \\<open>parts\\<close>!\\<close>"], ["", "definition\n  R23_ink :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_ink \\<equiv> {(s, t). nonces (IK t) \\<subseteq> ink (chan s)}\""], ["", "definition\n  R23_preserved :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23_preserved \\<equiv> {(s, t). runs s = runs t}\""], ["", "definition\n  R23 :: \"(m2_state \\<times> m3_state) set\" where\n  \"R23 \\<equiv> R23_msgs \\<inter> R23_ink \\<inter> R23_preserved\""], ["", "lemmas R23_defs = R23_def R23_msgs_def R23_ink_def R23_preserved_def"], ["", "text \\<open>Mediator function: nothing new.\\<close>"], ["", "definition\n  med32 :: \"m3_obs \\<Rightarrow> m2_obs\" where\n  \"med32 \\<equiv> id\""], ["", "lemmas R23_msgsI =\n  R23_msgs_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_msgsE [elim] =\n  R23_msgs_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_msgsE' [elim] =\n  R23_msgs_def [THEN rel_def_to_dest, simplified, rule_format, THEN subsetD]"], ["", "lemmas R23_inkI =\n  R23_ink_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_inkE [elim] =\n  R23_ink_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_preservedI =\n  R23_preserved_def [THEN rel_def_to_intro, simplified, rule_format]"], ["", "lemmas R23_preservedE [elim] =\n  R23_preserved_def [THEN rel_def_to_elim, simplified, rule_format]"], ["", "lemmas R23_intros = R23_msgsI R23_inkI R23_preservedI"], ["", "subsubsection \\<open>Facts about the abstraction function\\<close>"], ["", "(******************************************************************************)"], ["", "declare abs_msg.intros [intro!]"], ["", "declare abs_msg.cases [elim!]"], ["", "lemma abs_msg_empty: \"abs_msg {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg {} = {}", "by (auto)"], ["", "lemma abs_msg_Un [simp]:\n  \"abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_msg (G \\<union> H) = abs_msg G \\<union> abs_msg H", "by (auto)"], ["", "lemma abs_msg_mono [elim]:\n  \"\\<lbrakk> m \\<in> abs_msg G; G \\<subseteq> H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> abs_msg G; G \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> m \\<in> abs_msg H", "by (auto)"], ["", "lemma abs_msg_insert_mono [intro]:\n  \"\\<lbrakk> m \\<in> abs_msg H \\<rbrakk> \\<Longrightarrow> m \\<in> abs_msg (insert m' H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> abs_msg H \\<Longrightarrow> m \\<in> abs_msg (insert m' H)", "by (auto)"], ["", "text \\<open>Abstraction of concretely fakeable message yields abstractly fakeable\nmessages. This is the key lemma for the refinement of the intruder.\\<close>"], ["", "lemma abs_msg_DY_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink; t \\<in> m3_inv1_lkeysec \\<rbrakk>\n  \\<Longrightarrow> abs_msg (synth (analz (IK t))) \\<subseteq> fake ik0 (dom (runs s)) (chan s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n     t \\<in> m3_inv1_lkeysec\\<rbrakk>\n    \\<Longrightarrow> abs_msg (synth (analz (IK t)))\n                      \\<subseteq> fake ik0 (dom (runs s)) (chan s)", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A B Na.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec; Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Insec A B (Msg [aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>B Nb Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (priK B) \\<lbrace>Nonce Nb, Nonce Na, msg.Agent A\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 3. \\<And>B Nb Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec; Key (priK B) \\<in> analz (IK t);\n        Nonce Nb \\<in> analz (IK t); Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_intros, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B Nb Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec;\n        Crypt (priK B) \\<lbrace>Nonce Nb, Nonce Na, msg.Agent A\\<rbrace>\n        \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)\n 2. \\<And>B Nb Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec; Key (priK B) \\<in> analz (IK t);\n        Nonce Nb \\<in> analz (IK t); Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_Inj, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B Nb Na A.\n       \\<lbrakk>(s, t) \\<in> R23_msgs; (s, t) \\<in> R23_ink;\n        t \\<in> m3_inv1_lkeysec; Key (priK B) \\<in> analz (IK t);\n        Nonce Nb \\<in> analz (IK t); Nonce Na \\<in> analz (IK t)\\<rbrakk>\n       \\<Longrightarrow> Auth B A (Msg [aNon Nb, aNon Na])\n                         \\<in> fake ik0 (dom (runs s)) (chan s)", "apply (rule fake_intros, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma absmsg_parts_subset_fakeable:\n  \"\\<lbrakk> (s, t) \\<in> R23_msgs \\<rbrakk>\n  \\<Longrightarrow> abs_msg (parts (IK t)) \\<subseteq> fake ik0 (-dom (runs s)) (chan s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> R23_msgs \\<Longrightarrow>\n    abs_msg (parts (IK t)) \\<subseteq> fake ik0 (- dom (runs s)) (chan s)", "by (rule_tac B=\"chan s\" in subset_trans) (auto)"], ["", "declare abs_msg_DY_subset_fakeable [simp, intro!]"], ["", "declare absmsg_parts_subset_fakeable [simp, intro!]"], ["", "subsubsection \\<open>Refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma PO_m3_step1_refines_m2_step1:\n  \"{R23}\n     (m2_step1 Ra A B Na), (m3_step1 Ra A B Na)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step1 Ra A B Na, m3_step1 Ra A B Na {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step2_refines_m2_step2:\n  \"{R23 \\<^cancel>\\<open>\\<inter> UNIV \\<times> m3_inv3_pubkeys\\<close>}\n     (m2_step2 Rb A B Na Nb), (m3_step2 Rb A B Na Nb)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step2 Rb A B Na Nb, m3_step2 Rb A B Na Nb {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)\n   (auto)"], ["", "lemma PO_m3_step3_refines_m2_step3:\n  \"{R23}\n     (m2_step3 Ra A B Na Nb), (m3_step3 Ra A B Na Nb)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23} m2_step3 Ra A B Na Nb, m3_step3 Ra A B Na Nb {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs intro!: R23_intros)\n   (auto)"], ["", "text \\<open>The Dolev-Yao fake event refines the abstract fake event.\\<close>"], ["", "lemma PO_m3_DY_fake_refines_m2_fake:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv1_lkeysec \\<inter> m3_inv2_badkeys)}\n     m2_fake, m3_DY_fake\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times>\n     (m3_inv1_lkeysec \\<inter> m3_inv2_badkeys)} m2_fake, m3_DY_fake {> R23}", "by (auto simp add: PO_rhoare_defs R23_def m2_defs m3_defs)\n   (rule R23_intros, auto)+"], ["", "text \\<open>All together now...\\<close>"], ["", "lemmas PO_m3_trans_refines_m2_trans =\n  PO_m3_step1_refines_m2_step1 PO_m3_step2_refines_m2_step2\n  PO_m3_step3_refines_m2_step3 PO_m3_DY_fake_refines_m2_fake"], ["", "lemma PO_m3_refines_init_m2 [iff]:\n  \"init m3 \\<subseteq> R23``(init m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init m3 \\<subseteq> R23 `` init m2", "by (auto simp add: R23_defs m2_defs m3_defs)"], ["", "lemma PO_m3_refines_trans_m2 [iff]:\n  \"{R23 \\<inter> UNIV \\<times> (m3_inv2_badkeys \\<inter> m3_inv1_lkeysec)}\n     (trans m2), (trans m3)\n   {> R23}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23 \\<inter>\n     UNIV \\<times>\n     (m3_inv2_badkeys \\<inter>\n      m3_inv1_lkeysec)} TS.trans m2, TS.trans m3 {> R23}", "apply (auto simp add: m3_def m3_trans_def m2_def m2_trans_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xd.\n       {R23 \\<inter>\n        UNIV \\<times>\n        (m3_inv2_badkeys \\<inter>\n         m3_inv1_lkeysec)} ((\\<Union>x xa xb xc xd Nb.\n                                m2_step1 xb x xa xd \\<union>\n                                m2_step2 xc x xa xd Nb \\<union>\n                                m2_step3 xb x xa xd Nb) \\<union>\n                            m2_fake)\\<^sup>=, m3_step1 xb x xa xd {> R23}\n 2. \\<And>x xa xc xd Nb.\n       {R23 \\<inter>\n        UNIV \\<times>\n        (m3_inv2_badkeys \\<inter>\n         m3_inv1_lkeysec)} ((\\<Union>x xa xb xc xd Nb.\n                                m2_step1 xb x xa xd \\<union>\n                                m2_step2 xc x xa xd Nb \\<union>\n                                m2_step3 xb x xa xd Nb) \\<union>\n                            m2_fake)\\<^sup>=, m3_step2 xc x xa xd Nb {> R23}\n 3. \\<And>x xa xb xd Nb.\n       {R23 \\<inter>\n        UNIV \\<times>\n        (m3_inv2_badkeys \\<inter>\n         m3_inv1_lkeysec)} ((\\<Union>x xa xb xc xd Nb.\n                                m2_step1 xb x xa xd \\<union>\n                                m2_step2 xc x xa xd Nb \\<union>\n                                m2_step3 xb x xa xd Nb) \\<union>\n                            m2_fake)\\<^sup>=, m3_step3 xb x xa xd Nb {> R23}\n 4. {R23 \\<inter>\n     UNIV \\<times>\n     (m3_inv2_badkeys \\<inter>\n      m3_inv1_lkeysec)} ((\\<Union>x xa xb xc xd Nb.\n                             m2_step1 xb x xa xd \\<union>\n                             m2_step2 xc x xa xd Nb \\<union>\n                             m2_step3 xb x xa xd Nb) \\<union>\n                         m2_fake)\\<^sup>=, m3_DY_fake {> R23}", "apply (blast intro!: PO_m3_trans_refines_m2_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_obs_consistent [iff]:\n  \"obs_consistent R23 med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R23 med32 m2 m3", "by (auto simp add: obs_consistent_def R23_def med32_def m2_defs m3_defs)"], ["", "lemma PO_m3_refines_m2:\n  \"refines\n     (R23 \\<inter> UNIV \\<times> (m3_inv2_badkeys \\<inter> m3_inv1_lkeysec))\n     med32 m2 m3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R23 \\<inter> UNIV \\<times> (m3_inv2_badkeys \\<inter> m3_inv1_lkeysec))\n     med32 m2 m3", "by (rule Refinement_using_invariants) (auto)"], ["", "end"]]}