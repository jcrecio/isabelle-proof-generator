{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg/Refinement_Lattice.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg", "problem_names": ["lemma inf_mono_left: \"a \\<sqsubseteq> b \\<Longrightarrow> a \\<sqinter> c \\<sqsubseteq> b \\<sqinter> c\"", "lemma inf_mono_right: \"c \\<sqsubseteq> d \\<Longrightarrow> a \\<sqinter> c \\<sqsubseteq> a \\<sqinter> d\"", "lemma Inf2_inf: \"\\<Sqinter>{ f x | x. x \\<in> {c, d}} = f c \\<sqinter> f d\"", "lemma INF_Inf: \"(\\<Sqinter>x\\<in>X. f x) = (\\<Sqinter>{f x |x. x \\<in> X})\"", "lemma (in -) INF_absorb_args: \"(\\<Sqinter>i j. (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j)) = (\\<Sqinter>k. f k)\"", "lemma (in -) nested_Collect: \"{f y |y. y \\<in> {g x |x. x \\<in> X}} = {f (g x) |x. x \\<in> X}\"", "lemma Inf_distrib_INF_qual:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes qual: \"P {d x |x. x \\<in> X}\"\n  assumes f_Inf_distrib: \"\\<And>c D. P D \\<Longrightarrow> f c (\\<Sqinter> D) = \\<Sqinter> {f c d | d . d \\<in> D }\"\n  shows \"f c (\\<Sqinter>x\\<in>X. d x) = (\\<Sqinter>x\\<in>X. f c (d x))\"", "lemma Inf_distrib_INF:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes f_Inf_distrib: \"\\<And>c D. f c (\\<Sqinter> D) = \\<Sqinter> {f c d | d . d \\<in> D }\"\n  shows \"f c (\\<Sqinter>x\\<in>X. d x) = (\\<Sqinter>x\\<in>X. f c (d x))\"", "lemmas refine_trans = order.trans"], "translations": [["", "lemma inf_mono_left: \"a \\<sqsubseteq> b \\<Longrightarrow> a \\<sqinter> c \\<sqsubseteq> b \\<sqinter> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> b \\<Longrightarrow>\n    a \\<sqinter> c \\<sqsubseteq> b \\<sqinter> c\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  a, b, c :: 'a\n  less_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\ntype variables:\n  'a :: type", "using inf_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a::'a::type) \\<sqsubseteq> (?c::'a::type);\n   (?b::'a::type) \\<sqsubseteq> (?d::'a::type)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<sqsubseteq> ?c \\<sqinter> ?d\n\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> b \\<Longrightarrow>\n    a \\<sqinter> c \\<sqsubseteq> b \\<sqinter> c\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  a, b, c :: 'a\n  less_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\ntype variables:\n  'a :: type", "by auto"], ["", "lemma inf_mono_right: \"c \\<sqsubseteq> d \\<Longrightarrow> a \\<sqinter> c \\<sqsubseteq> a \\<sqinter> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    a \\<sqinter> c \\<sqsubseteq> a \\<sqinter> d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  a, c, d :: 'a\n  less_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\ntype variables:\n  'a :: type", "using inf_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a::'a::type) \\<sqsubseteq> (?c::'a::type);\n   (?b::'a::type) \\<sqsubseteq> (?d::'a::type)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<sqsubseteq> ?c \\<sqinter> ?d\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    a \\<sqinter> c \\<sqsubseteq> a \\<sqinter> d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  a, c, d :: 'a\n  less_eq :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\ntype variables:\n  'a :: type", "by auto"], ["", "text \\<open>Binary choice is a special case of choice over a set.\\<close>"], ["", "lemma Inf2_inf: \"\\<Sqinter>{ f x | x. x \\<in> {c, d}} = f c \\<sqinter> f d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"{ f x | x. x \\<in> {c, d}} = {f c, f d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x::'b. x \\<in> {c, d}} = {f c, f d}\nvariables:\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by blast"], ["proof (state)\nthis:\n  {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n   x \\<in> {c::'b::type, d::'b::type}} =\n  {f c, f d}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "then"], ["proof (chain)\npicking this:\n  {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n   x \\<in> {c::'b::type, d::'b::type}} =\n  {f c, f d}", "have \"\\<Sqinter>{ f x | x. x \\<in> {c, d}} = \\<Sqinter>{f c, f d}\""], ["proof (prove)\nusing this:\n  {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n   x \\<in> {c::'b::type, d::'b::type}} =\n  {f c, f d}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = \\<Sqinter> {f c, f d}\nvariables:\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by simp"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n              x \\<in> {c::'b::type, d::'b::type}} =\n  \\<Sqinter> {f c, f d}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "also"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n              x \\<in> {c::'b::type, d::'b::type}} =\n  \\<Sqinter> {f c, f d}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"... = f c \\<sqinter> f d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {f c, f d} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by simp"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) (c::'b::type),\n              f (d::'b::type)} =\n  f c \\<sqinter> f d\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n              x \\<in> {c::'b::type, d::'b::type}} =\n  f c \\<sqinter> f d", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n              x \\<in> {c::'b::type, d::'b::type}} =\n  f c \\<sqinter> f d\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {f x |x::'b. x \\<in> {c, d}} = f c \\<sqinter> f d\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "."], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n              x \\<in> {c::'b::type, d::'b::type}} =\n  f c \\<sqinter> f d\n\ngoal:\nNo subgoals!\nvariables:\n  inf :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d :: 'b\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "qed"], ["", "text \\<open>Helper lemma for choice over indexed set.\\<close>"], ["", "lemma INF_Inf: \"(\\<Sqinter>x\\<in>X. f x) = (\\<Sqinter>{f x |x. x \\<in> X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` X) = \\<Sqinter> {f x |x::'b. x \\<in> X}\nvariables:\n  X :: 'b set\n  f :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp add: Setcompr_eq_image)"], ["", "lemma (in -) INF_absorb_args: \"(\\<Sqinter>i j. (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j)) = (\\<Sqinter>k. f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) = \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "proof (rule order_class.order.antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\n 2. \\<Sqinter> range f \\<le> (\\<Sqinter>(i::nat) j::nat. f (i + j))\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "show \"(\\<Sqinter>k. f k) \\<le> (\\<Sqinter>i j. f (i + j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> range f \\<le> (\\<Sqinter>(i::nat) j::nat. f (i + j))\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "by (simp add: complete_lattice_class.INF_lower complete_lattice_class.le_INF_iff)"], ["proof (state)\nthis:\n  \\<Sqinter> range (f::nat \\<Rightarrow> 'c::complete_lattice)\n  \\<le> (\\<Sqinter>(i::nat) j::nat. f (i + j))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "have \"\\<And>k. \\<exists>i j. f (i + j) \\<le> f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k::nat. \\<exists>(i::nat) j::nat. f (i + j) \\<le> f k\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "by (metis add.left_neutral order_class.eq_iff)"], ["proof (state)\nthis:\n  \\<exists>(i::nat) j::nat.\n     (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j) \\<le> f (?k::nat)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "then"], ["proof (chain)\npicking this:\n  \\<exists>(i::nat) j::nat.\n     (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j) \\<le> f (?k::nat)", "have \"\\<And>k. \\<exists>i. (\\<Sqinter>j. f (i + j)) \\<le> f k\""], ["proof (prove)\nusing this:\n  \\<exists>(i::nat) j::nat.\n     (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j) \\<le> f (?k::nat)\n\ngoal (1 subgoal):\n 1. \\<And>k::nat. \\<exists>i::nat. (\\<Sqinter>j::nat. f (i + j)) \\<le> f k\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "by (meson UNIV_I complete_lattice_class.INF_lower2)"], ["proof (state)\nthis:\n  \\<exists>i::nat.\n     (\\<Sqinter>j::nat. (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j))\n     \\<le> f (?k::nat)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "then"], ["proof (chain)\npicking this:\n  \\<exists>i::nat.\n     (\\<Sqinter>j::nat. (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j))\n     \\<le> f (?k::nat)", "show \"(\\<Sqinter>i j. f (i + j)) \\<le> (\\<Sqinter>k. f k)\""], ["proof (prove)\nusing this:\n  \\<exists>i::nat.\n     (\\<Sqinter>j::nat. (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j))\n     \\<le> f (?k::nat)\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(i::nat) j::nat. f (i + j)) \\<le> \\<Sqinter> range f\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "by (simp add: complete_lattice_class.INF_mono)"], ["proof (state)\nthis:\n  (\\<Sqinter>(i::nat) j::nat.\n      (f::nat \\<Rightarrow> 'c::complete_lattice) (i + j))\n  \\<le> \\<Sqinter> range f\n\ngoal:\nNo subgoals!\nvariables:\n  f :: nat \\<Rightarrow> 'c\ntype variables:\n  'c :: complete_lattice", "qed"], ["", "lemma (in -) nested_Collect: \"{f y |y. y \\<in> {g x |x. x \\<in> X}} = {f (g x) |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f y |y::'b. y \\<in> {g x |x::'c. x \\<in> X}} =\n    {f (g x) |x::'c. x \\<in> X}\nvariables:\n  X :: 'c set\n  g :: 'c \\<Rightarrow> 'b\n  f :: 'b \\<Rightarrow> 'a\ntype variables:\n  'a, 'b, 'c :: type", "by blast"], ["", "text \\<open>A transition lemma for INF distributivity properties, going from Inf to INF,\n  qualified version followed by a straightforward one.\\<close>"], ["", "lemma Inf_distrib_INF_qual:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes qual: \"P {d x |x. x \\<in> X}\"\n  assumes f_Inf_distrib: \"\\<And>c D. P D \\<Longrightarrow> f c (\\<Sqinter> D) = \\<Sqinter> {f c d | d . d \\<in> D }\"\n  shows \"f c (\\<Sqinter>x\\<in>X. d x) = (\\<Sqinter>x\\<in>X. f c (d x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"f c (\\<Sqinter>x\\<in>X. d x) = f c (\\<Sqinter>{d x |x. x \\<in> X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = f c (\\<Sqinter> {d x |x::'b. x \\<in> X})\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp add: INF_Inf)"], ["proof (state)\nthis:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> ((d::'b::type \\<Rightarrow> 'a::type) ` (X::'b::type set))) =\n  f c (\\<Sqinter> {d x |x::'b::type. x \\<in> X})\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "also"], ["proof (state)\nthis:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> ((d::'b::type \\<Rightarrow> 'a::type) ` (X::'b::type set))) =\n  f c (\\<Sqinter> {d x |x::'b::type. x \\<in> X})\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"... = (\\<Sqinter>{f c dx |dx. dx \\<in> {d x | x. x \\<in> X}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> {d x |x::'b. x \\<in> X}) =\n    \\<Sqinter> {f c dx |dx::'a. dx \\<in> {d x |x::'b. x \\<in> X}}\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp add: qual f_Inf_distrib)"], ["proof (state)\nthis:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> {(d::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n                x \\<in> (X::'b::type set)}) =\n  \\<Sqinter> {f c dx |dx::'a::type. dx \\<in> {d x |x::'b::type. x \\<in> X}}\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "also"], ["proof (state)\nthis:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> {(d::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n                x \\<in> (X::'b::type set)}) =\n  \\<Sqinter> {f c dx |dx::'a::type. dx \\<in> {d x |x::'b::type. x \\<in> X}}\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"... = (\\<Sqinter>{f c (d x) |x. x \\<in> X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {f c dx |dx::'a. dx \\<in> {d x |x::'b. x \\<in> X}} =\n    \\<Sqinter> {f c (d x) |x::'b. x \\<in> X}\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp only: nested_Collect)"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type)\n               (c::'a::type) dx |\n              dx::'a::type.\n              dx \\<in> {(d::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n                        x \\<in> (X::'b::type set)}} =\n  \\<Sqinter> {f c (d x) |x::'b::type. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "also"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type)\n               (c::'a::type) dx |\n              dx::'a::type.\n              dx \\<in> {(d::'b::type \\<Rightarrow> 'a::type) x |x::'b::type.\n                        x \\<in> (X::'b::type set)}} =\n  \\<Sqinter> {f c (d x) |x::'b::type. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "have \"... = (\\<Sqinter>x\\<in>X. f c (d x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {f c (d x) |x::'b. x \\<in> X} =\n    (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp add: INF_Inf)"], ["proof (state)\nthis:\n  \\<Sqinter> {(f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type)\n               (c::'a::type) ((d::'b::type \\<Rightarrow> 'a::type) x) |\n              x::'b::type. x \\<in> (X::'b::type set)} =\n  (\\<Sqinter>x::'b::type\\<in>X. f c (d x))\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "finally"], ["proof (chain)\npicking this:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> ((d::'b::type \\<Rightarrow> 'a::type) ` (X::'b::type set))) =\n  (\\<Sqinter>x::'b::type\\<in>X. f c (d x))", "show ?thesis"], ["proof (prove)\nusing this:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> ((d::'b::type \\<Rightarrow> 'a::type) ` (X::'b::type set))) =\n  (\\<Sqinter>x::'b::type\\<in>X. f c (d x))\n\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "."], ["proof (state)\nthis:\n  (f::'a::type \\<Rightarrow> 'a::type \\<Rightarrow> 'a::type) (c::'a::type)\n   (\\<Sqinter> ((d::'b::type \\<Rightarrow> 'a::type) ` (X::'b::type set))) =\n  (\\<Sqinter>x::'b::type\\<in>X. f c (d x))\n\ngoal:\nNo subgoals!\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "qed"], ["", "lemma Inf_distrib_INF:\n  fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes f_Inf_distrib: \"\\<And>c D. f c (\\<Sqinter> D) = \\<Sqinter> {f c d | d . d \\<in> D }\"\n  shows \"f c (\\<Sqinter>x\\<in>X. d x) = (\\<Sqinter>x\\<in>X. f c (d x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f c (\\<Sqinter> (d ` X)) = (\\<Sqinter>x::'b\\<in>X. f c (d x))\nvariables:\n  X :: 'b set\n  d :: 'b \\<Rightarrow> 'a\n  Inf :: 'a set \\<Rightarrow> 'a\n  c :: 'a\n  f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a, 'b :: type", "by (simp add: Setcompr_eq_image f_Inf_distrib image_comp)"], ["", "end"], ["", "lemmas refine_trans = order.trans"], ["", "text \\<open>More transitivity rules to make calculational reasoning smoother\\<close>"], ["", "declare ord_eq_le_trans[trans]"], ["", "declare ord_le_eq_trans[trans]"], ["", "declare dual_order.trans[trans]"], ["", "abbreviation\n  dist_over_sup :: \"('a::refinement_lattice \\<Rightarrow> 'a) \\<Rightarrow> bool\"\nwhere\n  \"dist_over_sup F \\<equiv> (\\<forall> X . F (\\<Squnion> X) = (\\<Squnion>x\\<in>X. F (x)))\""], ["", "abbreviation\n  dist_over_inf :: \"('a::refinement_lattice \\<Rightarrow> 'a) \\<Rightarrow> bool\"\nwhere\n  \"dist_over_inf F \\<equiv> (\\<forall> X . F (\\<Sqinter> X) = (\\<Sqinter>x\\<in>X. F (x)))\""], ["", "end"]]}