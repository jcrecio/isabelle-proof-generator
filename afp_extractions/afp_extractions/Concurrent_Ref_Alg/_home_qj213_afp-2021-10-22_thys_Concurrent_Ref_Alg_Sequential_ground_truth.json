{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg/Sequential.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg", "problem_names": ["lemmas seq_assoc = seq.assoc", "lemmas seq_nil_right = seq.right_neutral", "lemmas seq_nil_left = seq.left_neutral", "lemma seq_mono_right: \"c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow> d ; c\\<^sub>0 \\<sqsubseteq> d ; c\\<^sub>1\"", "lemma seq_bot_right [simp]: \"c;\\<bottom> \\<sqsubseteq> c\"", "lemma INF_seq_distrib: \"(\\<Sqinter>c\\<in>C. f c) ; d = (\\<Sqinter>c\\<in>C. f c ; d)\"", "lemma inf_seq_distrib: \"(c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d = (c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d)\"", "lemma seq_mono_left: \"c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow> c\\<^sub>0 ; d \\<sqsubseteq> c\\<^sub>1 ; d\"", "lemma seq_top [simp]: \"\\<top> ; c = \\<top>\"", "lemma seq_power_front: \"(a \\<^sup>;^ n) ; a = a ; (a \\<^sup>;^ n)\"", "lemma seq_power_split_less: \"i < j \\<Longrightarrow> (b \\<^sup>;^ j) = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\"", "lemma seq_mono: \"c\\<^sub>1 \\<sqsubseteq> d\\<^sub>1 \\<Longrightarrow> c\\<^sub>2 \\<sqsubseteq> d\\<^sub>2 \\<Longrightarrow> c\\<^sub>1;c\\<^sub>2 \\<sqsubseteq> d\\<^sub>1;d\\<^sub>2\""], "translations": [["", "lemmas seq_assoc = seq.assoc"], ["", "(* 30 *)"], ["", "lemmas seq_nil_right = seq.right_neutral"], ["", "(* 31 *)"], ["", "lemmas seq_nil_left = seq.left_neutral"], ["", "(* 32 *)"], ["", "end"], ["", "subsection \\<open>Distributed sequential\\<close>"], ["", "text \\<open>\n  Sequential composition distributes across arbitrary infima \n  from the right but only across the binary (finite) infima from the left\n  and hence it is monotonic in both arguments. \n  We consider left distribution first.\n  Note that Section \\ref{S:conjunctive-sequential} considers the\n  case in which the weak-seq-inf-distrib axiom is strengthened to\n  an equality.\n\\<close>"], ["", "locale seq_distrib_left = sequential +\n  assumes weak_seq_inf_distrib: \n    \"(c::'a::refinement_lattice);(d\\<^sub>0 \\<sqinter> d\\<^sub>1) \\<sqsubseteq> (c;d\\<^sub>0 \\<sqinter> c;d\\<^sub>1)\"  (* 33 *)\nbegin"], ["", "text \\<open>Left distribution implies sequential composition is monotonic is its right argument\\<close>"], ["", "lemma seq_mono_right: \"c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow> d ; c\\<^sub>0 \\<sqsubseteq> d ; c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow>\n    d ; c\\<^sub>0 \\<sqsubseteq> d ; c\\<^sub>1\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.absorb_iff2 le_inf_iff weak_seq_inf_distrib)"], ["", "(* Nec? *)"], ["", "lemma seq_bot_right [simp]: \"c;\\<bottom> \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<sqsubseteq> c\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis bot.extremum seq.right_neutral seq_mono_right)"], ["", "end"], ["", "locale seq_distrib_right = sequential +\n  assumes Inf_seq_distrib: \n    \"(\\<Sqinter> C) ; d = (\\<Sqinter>(c::'a::refinement_lattice)\\<in>C. c ; d)\" (* 34 *)\nbegin"], ["", "lemma INF_seq_distrib: \"(\\<Sqinter>c\\<in>C. f c) ; d = (\\<Sqinter>c\\<in>C. f c ; d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` C) ; d = (\\<Sqinter>c::'b\\<in>C. f c ; d)\nvariables:\n  d :: 'a\n  C :: 'b set\n  f :: 'b \\<Rightarrow> 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice\n  'b :: type", "using Inf_seq_distrib"], ["proof (prove)\nusing this:\n  \\<Sqinter> (?C::'a::refinement_lattice set) ;\n  (?d::'a::refinement_lattice) =\n  (\\<Sqinter>c::'a::refinement_lattice\\<in>?C. c ; ?d)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` C) ; d = (\\<Sqinter>c::'b\\<in>C. f c ; d)\nvariables:\n  d :: 'a\n  C :: 'b set\n  f :: 'b \\<Rightarrow> 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice\n  'b :: type", "by (auto simp add: image_comp)"], ["", "lemma inf_seq_distrib: \"(c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d = (c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d = (\\<Sqinter> {c\\<^sub>0, c\\<^sub>1}) ; d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    \\<Sqinter> {c\\<^sub>0, c\\<^sub>1} ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  ((c\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (c\\<^sub>1::'a::refinement_lattice)) ;\n  (d::'a::refinement_lattice) =\n  \\<Sqinter> {c\\<^sub>0, c\\<^sub>1} ; d\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  ((c\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (c\\<^sub>1::'a::refinement_lattice)) ;\n  (d::'a::refinement_lattice) =\n  \\<Sqinter> {c\\<^sub>0, c\\<^sub>1} ; d\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = (\\<Sqinter>c\\<in>{c\\<^sub>0, c\\<^sub>1}. c ; d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {c\\<^sub>0, c\\<^sub>1} ; d =\n    (\\<Sqinter>c::'a\\<in>{c\\<^sub>0, c\\<^sub>1}. c ; d)\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (fact Inf_seq_distrib)"], ["proof (state)\nthis:\n  \\<Sqinter> {c\\<^sub>0::'a::refinement_lattice,\n              c\\<^sub>1::'a::refinement_lattice} ;\n  (d::'a::refinement_lattice) =\n  (\\<Sqinter>c::'a::refinement_lattice\\<in>{c\\<^sub>0, c\\<^sub>1}. c ; d)\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  \\<Sqinter> {c\\<^sub>0::'a::refinement_lattice,\n              c\\<^sub>1::'a::refinement_lattice} ;\n  (d::'a::refinement_lattice) =\n  (\\<Sqinter>c::'a::refinement_lattice\\<in>{c\\<^sub>0, c\\<^sub>1}. c ; d)\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = (c\\<^sub>0 ; d) \\<sqinter> (c\\<^sub>1 ; d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>c::'a\\<in>{c\\<^sub>0, c\\<^sub>1}. c ; d) =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (\\<Sqinter>c::'a::refinement_lattice\\<in>{c\\<^sub>0::'a::refinement_lattice,\n      c\\<^sub>1::'a::refinement_lattice}.\n      c ; (d::'a::refinement_lattice)) =\n  c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "finally"], ["proof (chain)\npicking this:\n  ((c\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (c\\<^sub>1::'a::refinement_lattice)) ;\n  (d::'a::refinement_lattice) =\n  c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d", "show ?thesis"], ["proof (prove)\nusing this:\n  ((c\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (c\\<^sub>1::'a::refinement_lattice)) ;\n  (d::'a::refinement_lattice) =\n  c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\n\ngoal (1 subgoal):\n 1. (c\\<^sub>0 \\<sqinter> c\\<^sub>1) ; d =\n    c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "."], ["proof (state)\nthis:\n  ((c\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (c\\<^sub>1::'a::refinement_lattice)) ;\n  (d::'a::refinement_lattice) =\n  c\\<^sub>0 ; d \\<sqinter> c\\<^sub>1 ; d\n\ngoal:\nNo subgoals!\nvariables:\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma seq_mono_left: \"c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow> c\\<^sub>0 ; d \\<sqsubseteq> c\\<^sub>1 ; d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>0 \\<sqsubseteq> c\\<^sub>1 \\<Longrightarrow>\n    c\\<^sub>0 ; d \\<sqsubseteq> c\\<^sub>1 ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c\\<^sub>0, c\\<^sub>1, d :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.absorb_iff2 inf_seq_distrib)"], ["", "lemma seq_top [simp]: \"\\<top> ; c = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> ; c = \\<top>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<top> ; c = \\<top>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"\\<top> ; c = (\\<Sqinter>a\\<in>{}. a ; c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> ; c = (\\<Sqinter>a::'a\\<in>{}. a ; c)\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis Inf_empty Inf_seq_distrib)"], ["proof (state)\nthis:\n  \\<top> ; (c::'a::refinement_lattice) =\n  (\\<Sqinter>a::'a::refinement_lattice\\<in>{}. a ; c)\n\ngoal (1 subgoal):\n 1. \\<top> ; c = \\<top>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<top> ; (c::'a::refinement_lattice) =\n  (\\<Sqinter>a::'a::refinement_lattice\\<in>{}. a ; c)\n\ngoal (1 subgoal):\n 1. \\<top> ; c = \\<top>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  \\<top> ; (c::'a::refinement_lattice) = \\<top>\n\ngoal:\nNo subgoals!\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "primrec seq_power :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'a\" (infixr \"\\<^sup>;^\" 80) where\n    seq_power_0: \"a \\<^sup>;^ 0 = nil\"\n  | seq_power_Suc: \"a \\<^sup>;^ Suc n = a ; (a \\<^sup>;^ n)\""], ["", "notation (latex output)\n  seq_power (\"(_\\<^bsup>_\\<^esup>)\" [1000] 1000)"], ["", "notation (HTML output)\n  seq_power (\"(_\\<^bsup>_\\<^esup>)\" [1000] 1000)"], ["", "lemma seq_power_front: \"(a \\<^sup>;^ n) ; a = a ; (a \\<^sup>;^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<^sup>;^ n) ; a = a ; (a \\<^sup>;^ n)\nvariables:\n  n :: nat\n  a, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (induct n, simp_all add: seq_assoc)"], ["", "lemma seq_power_split_less: \"i < j \\<Longrightarrow> (b \\<^sup>;^ j) = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow>\n    b \\<^sup>;^ j = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\nvariables:\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  i, j :: nat\ntype variables:\n  'a :: refinement_lattice", "proof (induct j arbitrary: i type: nat)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i::nat.\n       i < (0::nat) \\<Longrightarrow>\n       b \\<^sup>;^ (0::nat) = (b \\<^sup>;^ i) ; (b \\<^sup>;^ ((0::nat) - i))\n 2. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case 0"], ["proof (state)\nthis:\n  (i::nat) < 0\n\ngoal (2 subgoals):\n 1. \\<And>i::nat.\n       i < (0::nat) \\<Longrightarrow>\n       b \\<^sup>;^ (0::nat) = (b \\<^sup>;^ i) ; (b \\<^sup>;^ ((0::nat) - i))\n 2. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?case"], ["proof (prove)\nusing this:\n  (i::nat) < 0\n\ngoal (1 subgoal):\n 1. b \\<^sup>;^ (0::nat) = (b \\<^sup>;^ i) ; (b \\<^sup>;^ ((0::nat) - i))\nvariables:\n  i :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) \\<^sup>;^ 0 =\n  (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (0 - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case (Suc j)"], ["proof (state)\nthis:\n  (?i::nat) < (j::nat) \\<Longrightarrow>\n  (b::'a::refinement_lattice) \\<^sup>;^ j =\n  (b \\<^sup>;^ ?i) ; (b \\<^sup>;^ (j - ?i))\n  (i::nat) < Suc (j::nat)\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"b \\<^sup>;^ Suc j = b ; (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<^sup>;^ Suc j = b ; (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using Suc.hyps Suc.prems less_Suc_eq seq_assoc"], ["proof (prove)\nusing this:\n  (?i::nat) < (j::nat) \\<Longrightarrow>\n  (b::'a::refinement_lattice) \\<^sup>;^ j =\n  (b \\<^sup>;^ ?i) ; (b \\<^sup>;^ (j - ?i))\n  (i::nat) < Suc (j::nat)\n  ((?m::nat) < Suc (?n::nat)) = (?m < ?n \\<or> ?m = ?n)\n  (?a::'a::refinement_lattice) ; (?b::'a::refinement_lattice) ;\n  (?c::'a::refinement_lattice) =\n  ?a ; (?b ; ?c)\n\ngoal (1 subgoal):\n 1. b \\<^sup>;^ Suc j = b ; (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) \\<^sup>;^ Suc (j::nat) =\n  b ; (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (j - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) \\<^sup>;^ Suc (j::nat) =\n  b ; (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (j - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ; (b \\<^sup>;^ i) ; (b \\<^sup>;^ (j - i)) =\n    (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: seq_power_front)"], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) ; (b \\<^sup>;^ (i::nat)) ;\n  (b \\<^sup>;^ ((j::nat) - i)) =\n  (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) ; (b \\<^sup>;^ (i::nat)) ;\n  (b \\<^sup>;^ ((j::nat) - i)) =\n  (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc j - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i)) =\n    (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using Suc.prems Suc_diff_le seq_assoc"], ["proof (prove)\nusing this:\n  (i::nat) < Suc (j::nat)\n  (?n::nat) \\<le> (?m::nat) \\<Longrightarrow> Suc ?m - ?n = Suc (?m - ?n)\n  (?a::'a::refinement_lattice) ; (?b::'a::refinement_lattice) ;\n  (?c::'a::refinement_lattice) =\n  ?a ; (?b ; ?c)\n\ngoal (1 subgoal):\n 1. (b \\<^sup>;^ i) ; b ; (b \\<^sup>;^ (j - i)) =\n    (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by force"], ["proof (state)\nthis:\n  ((b::'a::refinement_lattice) \\<^sup>;^ (i::nat)) ; b ;\n  (b \\<^sup>;^ ((j::nat) - i)) =\n  (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc j - i))\n\ngoal (1 subgoal):\n 1. \\<And>(n::nat) i::nat.\n       \\<lbrakk>\\<And>i::nat.\n                   i < n \\<Longrightarrow>\n                   b \\<^sup>;^ n = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (n - i));\n        i < Suc n\\<rbrakk>\n       \\<Longrightarrow> b \\<^sup>;^ Suc n =\n                         (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc n - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "finally"], ["proof (chain)\npicking this:\n  (b::'a::refinement_lattice) \\<^sup>;^ Suc (j::nat) =\n  (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (Suc j - i))", "show ?case"], ["proof (prove)\nusing this:\n  (b::'a::refinement_lattice) \\<^sup>;^ Suc (j::nat) =\n  (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (Suc j - i))\n\ngoal (1 subgoal):\n 1. b \\<^sup>;^ Suc j = (b \\<^sup>;^ i) ; (b \\<^sup>;^ (Suc j - i))\nvariables:\n  i, j :: nat\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "."], ["proof (state)\nthis:\n  (b::'a::refinement_lattice) \\<^sup>;^ Suc (j::nat) =\n  (b \\<^sup>;^ (i::nat)) ; (b \\<^sup>;^ (Suc j - i))\n\ngoal:\nNo subgoals!\nvariables:\n  b, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  i, j :: nat\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "locale seq_distrib = seq_distrib_right + seq_distrib_left\nbegin"], ["", "lemma seq_mono: \"c\\<^sub>1 \\<sqsubseteq> d\\<^sub>1 \\<Longrightarrow> c\\<^sub>2 \\<sqsubseteq> d\\<^sub>2 \\<Longrightarrow> c\\<^sub>1;c\\<^sub>2 \\<sqsubseteq> d\\<^sub>1;d\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1 \\<sqsubseteq> d\\<^sub>1;\n     c\\<^sub>2 \\<sqsubseteq> d\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 ; c\\<^sub>2 \\<sqsubseteq>\n                      d\\<^sub>1 ; d\\<^sub>2\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c\\<^sub>1, c\\<^sub>2, d\\<^sub>1, d\\<^sub>2 :: 'a\ntype variables:\n  'a :: refinement_lattice", "using seq_mono_left seq_mono_right"], ["proof (prove)\nusing this:\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  ?c\\<^sub>0 ; (?d::'a::refinement_lattice) \\<sqsubseteq> ?c\\<^sub>1 ; ?d\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  (?d::'a::refinement_lattice) ; ?c\\<^sub>0 \\<sqsubseteq> ?d ; ?c\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c\\<^sub>1 \\<sqsubseteq> d\\<^sub>1;\n     c\\<^sub>2 \\<sqsubseteq> d\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> c\\<^sub>1 ; c\\<^sub>2 \\<sqsubseteq>\n                      d\\<^sub>1 ; d\\<^sub>2\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c\\<^sub>1, c\\<^sub>2, d\\<^sub>1, d\\<^sub>2 :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.orderE le_infI2)"], ["", "end"], ["", "end"]]}