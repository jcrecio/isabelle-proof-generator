{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg/Conjunctive_Iteration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg", "problem_names": ["lemma isolation: \"c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\"", "lemma iter_induct_isolate: \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = lfp (\\<lambda> x. d \\<sqinter> c;x)\"", "lemma iter_induct_eq: \"c\\<^sup>\\<omega>;d = lfp (\\<lambda> x. d \\<sqinter> c;x)\"", "lemma iter_induct: \"d \\<sqinter> c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<omega>;d \\<sqsubseteq> x\"", "lemma iter_isolate: \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = c\\<^sup>\\<omega>;d\"", "lemma iter_isolate2: \"c;c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = c;c\\<^sup>\\<omega>;d\"", "lemma iter_decomp: \"(c \\<sqinter> d)\\<^sup>\\<omega> = c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega>\"", "lemma iter_leapfrog_var: \"(c;d)\\<^sup>\\<omega>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<omega>\"", "lemma iter_leapfrog: \"c;(d;c)\\<^sup>\\<omega> = (c;d)\\<^sup>\\<omega>;c\"", "lemma fiter_leapfrog: \"c;(d;c)\\<^sup>\\<star> = (c;d)\\<^sup>\\<star>;c\"", "lemma fiter_seq_choice: \"c\\<^sup>\\<star> = (\\<Sqinter>i::nat. c \\<^sup>;^ i)\"", "lemma fiter_seq_choice_nonempty: \"c ; c\\<^sup>\\<star> = (\\<Sqinter>i\\<in>{i. 0 < i}. c \\<^sup>;^ i)\"", "lemma conj_distrib4: \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<star>\""], "translations": [["", "lemma isolation: \"c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define F where \"F = (\\<lambda> x. c\\<^sup>\\<star> \\<sqinter> x)\""], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>) ((c::'a::refinement_lattice)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define G where \"G = (\\<lambda> x. c;x)\""], ["proof (state)\nthis:\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define H where \"H = (\\<lambda> x. nil \\<sqinter> c;x)\""], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter> (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have FG: \"F \\<circ> G = (\\<lambda> x. c\\<^sup>\\<star> \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<circ> G = (\\<lambda>x::'a. c\\<^sup>\\<star> \\<sqinter> c ; x)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def G_def"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>) ((c::'a::refinement_lattice)\\<^sup>\\<star>)\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. F \\<circ> G = (\\<lambda>x::'a. c\\<^sup>\\<star> \\<sqinter> c ; x)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have HF: \"H \\<circ> F = (\\<lambda> x. nil \\<sqinter> c;(c\\<^sup>\\<star> \\<sqinter> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<circ> F =\n    (\\<lambda>x::'a. nil \\<sqinter> c ; (c\\<^sup>\\<star> \\<sqinter> x))\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\n  F, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def H_def"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>) ((c::'a::refinement_lattice)\\<^sup>\\<star>)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter> (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. H \\<circ> F =\n    (\\<lambda>x::'a. nil \\<sqinter> c ; (c\\<^sup>\\<star> \\<sqinter> x))\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\n  F, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter>\n      (c::'a::refinement_lattice) ; (c\\<^sup>\\<star> \\<sqinter> x))\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have adjoint: \"dist_over_sup F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_over_sup F\nvariables:\n  F :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: F_def inf_Sup)"], ["proof (state)\nthis:\n  dist_over_sup\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoH: \"mono H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono H\nvariables:\n  H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis H_def inf_mono monoI order_refl seq_mono_right)"], ["proof (state)\nthis:\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoG: \"mono G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono G\nvariables:\n  G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis G_def inf.absorb_iff2 monoI seq_inf_distrib)"], ["proof (state)\nthis:\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"\\<forall> x. ((F \\<circ> G) x = (H \\<circ> F) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using FG HF"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqinter> c ; x)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter>\n      (c::'a::refinement_lattice) ; (c\\<^sup>\\<star> \\<sqinter> x))\n\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_unfold inf_sup_aci(2) seq_inf_distrib)"], ["proof (state)\nthis:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x", "have \"F (lfp G) = lfp H\""], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. F (lfp G) = lfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using adjoint monoH monoG fusion_lfp_eq"], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n  dist_over_sup\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  \\<lbrakk>mono\n            (?H::?'a::refinement_lattice\n                 \\<Rightarrow> ?'a::refinement_lattice);\n   mono (?G::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   dist_over_sup\n    (?F::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   \\<And>x::?'a::refinement_lattice.\n      (?F \\<circ> ?G) x = (?H \\<circ> ?F) x\\<rbrakk>\n  \\<Longrightarrow> ?F (lfp ?G) = lfp ?H\n\ngoal (1 subgoal):\n 1. F (lfp G) = lfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)", "have \"c\\<^sup>\\<star> \\<sqinter> lfp (\\<lambda> x. c;x) = lfp (\\<lambda> x. nil \\<sqinter> c;x)\""], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqinter> lfp ((;) c) =\n    lfp (\\<lambda>x::'a. nil \\<sqinter> c ; x)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def G_def H_def"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>) ((c::'a::refinement_lattice)\\<^sup>\\<star>)\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter> (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqinter> lfp ((;) c) =\n    lfp (\\<lambda>x::'a. nil \\<sqinter> c ; x)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqinter> lfp ((;) c) =\n  lfp (\\<lambda>x::'a::refinement_lattice. nil \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqinter> lfp ((;) c) =\n  lfp (\\<lambda>x::'a::refinement_lattice. nil \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: infiter_def iter_def)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> =\n  c\\<^sup>\\<star> \\<sqinter> c\\<^sup>\\<infinity>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_induct_isolate: \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = lfp (\\<lambda> x. d \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define F where \"F = (\\<lambda> x. c\\<^sup>\\<star>;d \\<sqinter> x)\""], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>)\n   ((c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define G where \"G = (\\<lambda> x. c;x)\""], ["proof (state)\nthis:\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define H where \"H = (\\<lambda> x. d \\<sqinter> c;x)\""], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (d::'a::refinement_lattice) \\<sqinter>\n      (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have FG: \"F \\<circ> G = (\\<lambda> x. c\\<^sup>\\<star>;d \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<circ> G = (\\<lambda>x::'a. c\\<^sup>\\<star> ; d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def G_def"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>)\n   ((c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice))\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. F \\<circ> G = (\\<lambda>x::'a. c\\<^sup>\\<star> ; d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have HF: \"H \\<circ> F = (\\<lambda> x. d \\<sqinter> c;c\\<^sup>\\<star>;d \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<circ> F =\n    (\\<lambda>x::'a. d \\<sqinter> c ; c\\<^sup>\\<star> ; d \\<sqinter> c ; x)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\n  F, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def H_def weak_seq_inf_distrib"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>)\n   ((c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice))\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (d::'a::refinement_lattice) \\<sqinter>\n      (c::'a::refinement_lattice) ; x)\n  (?c::'a::refinement_lattice) ;\n  ((?d\\<^sub>0::'a::refinement_lattice) \\<sqinter>\n   (?d\\<^sub>1::'a::refinement_lattice)) \\<sqsubseteq>\n  ?c ; ?d\\<^sub>0 \\<sqinter> ?c ; ?d\\<^sub>1\n\ngoal (1 subgoal):\n 1. H \\<circ> F =\n    (\\<lambda>x::'a. d \\<sqinter> c ; c\\<^sup>\\<star> ; d \\<sqinter> c ; x)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\n  F, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis comp_apply inf.commute inf.left_commute seq_assoc seq_inf_distrib)"], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (d::'a::refinement_lattice) \\<sqinter>\n      (c::'a::refinement_lattice) ; c\\<^sup>\\<star> ; d \\<sqinter>\n      c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have unroll: \"c\\<^sup>\\<star>;d = (nil \\<sqinter> c;c\\<^sup>\\<star>);d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = (nil \\<sqinter> c ; c\\<^sup>\\<star>) ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using fiter_unfold"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<star> =\n  nil \\<sqinter> ?c ; ?c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = (nil \\<sqinter> c ; c\\<^sup>\\<star>) ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice) =\n  (nil \\<sqinter> c ; c\\<^sup>\\<star>) ; d\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have distribute: \"c\\<^sup>\\<star>;d = d \\<sqinter> c;c\\<^sup>\\<star>;d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = d \\<sqinter> c ; c\\<^sup>\\<star> ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: unroll inf_seq_distrib)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice) =\n  d \\<sqinter> c ; c\\<^sup>\\<star> ; d\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have FGx: \"(F \\<circ> G) x = d \\<sqinter> c;c\\<^sup>\\<star>;d \\<sqinter> c;x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F \\<circ> G) x = d \\<sqinter> c ; c\\<^sup>\\<star> ; d \\<sqinter> c ; x\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using FG distribute"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      c ; x)\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice) =\n  d \\<sqinter> c ; c\\<^sup>\\<star> ; d\n\ngoal (1 subgoal):\n 1. (F \\<circ> G) x = d \\<sqinter> c ; c\\<^sup>\\<star> ; d \\<sqinter> c ; x\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  ((F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n   (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n   (x::'a::refinement_lattice) =\n  (d::'a::refinement_lattice) \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<star> ; d \\<sqinter>\n  c ; x\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have adjoint: \"dist_over_sup F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_over_sup F\nvariables:\n  F :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: F_def inf_Sup)"], ["proof (state)\nthis:\n  dist_over_sup\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoH: \"mono H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono H\nvariables:\n  H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis H_def inf_mono monoI order_refl seq_mono_right)"], ["proof (state)\nthis:\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoG: \"mono G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono G\nvariables:\n  G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis G_def inf.absorb_iff2 monoI seq_inf_distrib)"], ["proof (state)\nthis:\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"\\<forall> x. ((F \\<circ> G) x = (H \\<circ> F) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using FGx HF"], ["proof (prove)\nusing this:\n  ((F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n   (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n   (x::'a::refinement_lattice) =\n  (d::'a::refinement_lattice) \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<star> ; d \\<sqinter>\n  c ; x\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (d::'a::refinement_lattice) \\<sqinter>\n      (c::'a::refinement_lattice) ; c\\<^sup>\\<star> ; d \\<sqinter>\n      c ; x)\n\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: FG distribute)"], ["proof (state)\nthis:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x", "have \"F (lfp G) = lfp H\""], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. F (lfp G) = lfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using adjoint monoH monoG fusion_lfp_eq"], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n  dist_over_sup\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  \\<lbrakk>mono\n            (?H::?'a::refinement_lattice\n                 \\<Rightarrow> ?'a::refinement_lattice);\n   mono (?G::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   dist_over_sup\n    (?F::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   \\<And>x::?'a::refinement_lattice.\n      (?F \\<circ> ?G) x = (?H \\<circ> ?F) x\\<rbrakk>\n  \\<Longrightarrow> ?F (lfp ?G) = lfp ?H\n\ngoal (1 subgoal):\n 1. F (lfp G) = lfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)", "have \"c\\<^sup>\\<star>;d \\<sqinter> lfp (\\<lambda> x. c;x) = lfp (\\<lambda> x. d \\<sqinter> c;x)\""], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> lfp ((;) c) =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def G_def H_def"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (lfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  lfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<sqinter>)\n   ((c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice))\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (;) (c::'a::refinement_lattice)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (d::'a::refinement_lattice) \\<sqinter>\n      (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> lfp ((;) c) =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  lfp ((;) c) =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  lfp ((;) c) =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: infiter_def)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_induct_eq: \"c\\<^sup>\\<omega>;d = lfp (\\<lambda> x. d \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"c\\<^sup>\\<omega>;d = c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity>;d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d =\n    c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: isolation inf_seq_distrib)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; (d::'a::refinement_lattice) =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; (d::'a::refinement_lattice) =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d", "have \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity>;d = c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; (d::'a::refinement_lattice) =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d =\n    c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: infiter_annil)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> ; d =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> ; d =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity>", "have \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = lfp (\\<lambda> x. d \\<sqinter> c;x)\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> ; d =\n  c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: iter_induct_isolate)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ;\n  (d::'a::refinement_lattice) \\<sqinter>\n  c\\<^sup>\\<infinity> =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; d = lfp (\\<lambda>x::'a. d \\<sqinter> c ; x)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: \\<open>c\\<^sup>\\<omega> ; d = c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d\\<close> \\<open>c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> ; d = c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity>\\<close>)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; (d::'a::refinement_lattice) =\n  lfp (\\<lambda>x::'a::refinement_lattice. d \\<sqinter> c ; x)\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_induct: \"d \\<sqinter> c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<omega>;d \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<sqinter> c ; x \\<sqsubseteq> x \\<Longrightarrow>\n    c\\<^sup>\\<omega> ; d \\<sqsubseteq> x\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: iter_induct_eq lfp_lowerbound)"], ["", "lemma iter_isolate: \"c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = c\\<^sup>\\<omega>;d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    c\\<^sup>\\<omega> ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: iter_induct_eq iter_induct_isolate)"], ["", "lemma iter_isolate2: \"c;c\\<^sup>\\<star>;d \\<sqinter> c\\<^sup>\\<infinity> = c;c\\<^sup>\\<omega>;d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> ; d \\<sqinter> c\\<^sup>\\<infinity> =\n    c ; c\\<^sup>\\<omega> ; d\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis infiter_unfold iter_isolate seq_assoc seq_inf_distrib)"], ["", "lemma iter_decomp: \"(c \\<sqinter> d)\\<^sup>\\<omega> = c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<sqinter> d)\\<^sup>\\<omega> =\n    c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n    c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\n 2. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have      \"c;c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqinter> (d;c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqinter>\n    (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_commute order.refl inf_seq_distrib seq_nil_left iter_unfold)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqinter>\n  (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\n\ngoal (2 subgoals):\n 1. (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n    c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\n 2. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus \"(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqinter>\n  (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n    c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.left_commute iter_induct_nil iter_unfold seq_assoc inf_seq_distrib)"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) \\<sqinter>\n   (d::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(c;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> d;(c \\<sqinter> d)\\<^sup>\\<omega>) \\<sqinter> nil \\<sqsubseteq> (c \\<sqinter> d)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    nil \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_commute order.refl inf_seq_distrib iter_unfold)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  (c \\<sqinter> (d::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqinter>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  nil \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice) ;\n  (c \\<sqinter> (d::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqinter>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  nil \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>", "have a: \"c\\<^sup>\\<omega>;(d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq> (c \\<sqinter> d)\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) ;\n  (c \\<sqinter> (d::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqinter>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  nil \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    nil \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega> \\<Longrightarrow>\n    c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"nil \\<sqinter> d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> c;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq> (c \\<sqinter> d)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis eq_iff inf.semigroup_axioms inf_commute inf_seq_distrib iter_unfold semigroup.assoc)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n    nil \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega> \\<Longrightarrow>\n    c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using iter_induct_eq"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n  c ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  (?d::'a::refinement_lattice) =\n  lfp (\\<lambda>x::'a::refinement_lattice. ?d \\<sqinter> ?c ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_sup_aci(1) iter_induct)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n   nil) \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n   nil) \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n   nil) \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>", "have \"d;c\\<^sup>\\<omega>;(d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqinter> nil \\<sqsubseteq> d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n   nil) \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. d ; c\\<^sup>\\<omega> ;\n    (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqinter>\n    nil \\<sqsubseteq>\n    d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_mono order.refl seq_assoc seq_mono)"], ["proof (state)\nthis:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqinter>\n  nil \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqinter>\n  nil \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil", "have \"(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq> d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\""], ["proof (prove)\nusing this:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil) \\<sqinter>\n  nil \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_commute iter_induct_nil)"], ["proof (state)\nthis:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice)\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice)\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil", "have \"c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>;(d;(c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil)\""], ["proof (prove)\nusing this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice)\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    c\\<^sup>\\<omega> ; (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis order.refl seq_mono)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ;\n   c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus \"c\\<^sup>\\<omega>;(d;c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq> (c \\<sqinter> d)\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ;\n   c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using a refine_trans"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ;\n   c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; (d ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter> nil)\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ; (c \\<sqinter> d)\\<^sup>\\<omega> \\<sqinter>\n   nil) \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n  \\<lbrakk>(?a::?'a::order) \\<le> (?b::?'a::order);\n   ?b \\<le> (?c::?'a::order)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; (d ; c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n    (c \\<sqinter> d)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  ((d::'a::refinement_lattice) ;\n   c\\<^sup>\\<omega>)\\<^sup>\\<omega> \\<sqsubseteq>\n  (c \\<sqinter> d)\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_leapfrog_var: \"(c;d)\\<^sup>\\<omega>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"c \\<sqinter> c;d;c;(d;c)\\<^sup>\\<omega> \\<sqsubseteq> c;(d;c)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqinter> c ; d ; c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n    c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis iter_unfold order_refl seq_assoc seq_inf_distrib seq_nil_right)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<sqinter>\n  c ; (d::'a::refinement_lattice) ; c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<sqinter>\n  c ; (d::'a::refinement_lattice) ; c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using iter_induct_eq"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<sqinter>\n  c ; (d::'a::refinement_lattice) ; c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<omega>\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  (?d::'a::refinement_lattice) =\n  lfp (\\<lambda>x::'a::refinement_lattice. ?d \\<sqinter> ?c ; x)\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis iter_induct seq_assoc)"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<omega> ;\n  c \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_leapfrog: \"c;(d;c)\\<^sup>\\<omega> = (c;d)\\<^sup>\\<omega>;c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> = (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\n 2. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"(c;d)\\<^sup>\\<omega>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<omega> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis iter_leapfrog_var)"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<omega> ;\n  c \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(d;c)\\<^sup>\\<omega> \\<sqsubseteq> ((d;c)\\<^sup>\\<omega>;d);c \\<sqinter> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<omega> ; d ; c \\<sqinter> nil\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.bounded_iff order.refl seq_assoc seq_mono iter_unfold iter1 iter2)"], ["proof (state)\nthis:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<omega> ; d ; c \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<omega> ; d ; c \\<sqinter> nil", "have \"(d;c)\\<^sup>\\<omega> \\<sqsubseteq> (d;(c;d)\\<^sup>\\<omega>);c \\<sqinter> nil\""], ["proof (prove)\nusing this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<omega> ; d ; c \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n    d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.absorb_iff2 inf.boundedE inf_assoc iter_leapfrog_var inf_seq_distrib)"], ["proof (state)\nthis:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil", "have \"c;(d;c)\\<^sup>\\<omega> \\<sqsubseteq> c;d;(c;d)\\<^sup>\\<omega>;c \\<sqinter> nil;c\""], ["proof (prove)\nusing this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n    c ; d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using inf.bounded_iff seq_assoc seq_mono_right seq_nil_left seq_nil_right"], ["proof (prove)\nusing this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil\n  ((?a::?'a::semilattice_inf)\n   \\<le> (?b::?'a::semilattice_inf) \\<sqinter> (?c::?'a::semilattice_inf)) =\n  (?a \\<le> ?b \\<and> ?a \\<le> ?c)\n  (?a::'a::refinement_lattice) ; (?b::'a::refinement_lattice) ;\n  (?c::'a::refinement_lattice) =\n  ?a ; (?b ; ?c)\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  (?d::'a::refinement_lattice) ; ?c\\<^sub>0 \\<sqsubseteq> ?d ; ?c\\<^sub>1\n  nil ; (?a::'a::refinement_lattice) = ?a\n  (?a::'a::refinement_lattice) ; nil = ?a\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n    c ; d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  c ; d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil ; c\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus \"c;(d;c)\\<^sup>\\<omega> \\<sqsubseteq> (c;d)\\<^sup>\\<omega>;c\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  c ; d ; (c ; d)\\<^sup>\\<omega> ; c \\<sqinter> nil ; c\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<omega> \\<sqsubseteq> (c ; d)\\<^sup>\\<omega> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_commute inf_seq_distrib iter_unfold)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<omega> \\<sqsubseteq>\n  (c ; d)\\<^sup>\\<omega> ; c\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma fiter_leapfrog: \"c;(d;c)\\<^sup>\\<star> = (c;d)\\<^sup>\\<star>;c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> = (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> = (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have lr: \"c;(d;c)\\<^sup>\\<star> \\<sqsubseteq> (c;d)\\<^sup>\\<star>;c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> \\<sqsubseteq> (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> \\<sqsubseteq> (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(d ; c)\\<^sup>\\<star> = nil \\<sqinter> d ; c ; (d ; c)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d ; c)\\<^sup>\\<star> = nil \\<sqinter> d ; c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson finite_iteration.fiter_unfold finite_iteration_axioms)"], ["proof (state)\nthis:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<star> =\n  nil \\<sqinter> d ; c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> \\<sqsubseteq> (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<star> =\n  nil \\<sqinter> d ; c ; (d ; c)\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  ((d::'a::refinement_lattice) ;\n   (c::'a::refinement_lattice))\\<^sup>\\<star> =\n  nil \\<sqinter> d ; c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> \\<sqsubseteq> (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_induct seq_assoc seq_distrib_left.weak_seq_inf_distrib \n          seq_distrib_left_axioms seq_nil_right)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<star> \\<sqsubseteq>\n  (c ; d)\\<^sup>\\<star> ; c\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<star> \\<sqsubseteq>\n  (c ; d)\\<^sup>\\<star> ; c\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> = (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have rl: \"(c;d)\\<^sup>\\<star>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have a1: \"(c;d)\\<^sup>\\<star>;c = c \\<sqinter> c;d;(c;d)\\<^sup>\\<star>;c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c =\n    c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis finite_iteration.fiter_unfold finite_iteration_axioms \n           inf_seq_distrib seq_nil_left)"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n  c =\n  c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have a2: \"(c;d)\\<^sup>\\<star>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<star> \\<longleftrightarrow> c \\<sqinter> c;d;(c;d)\\<^sup>\\<star>;c \\<sqsubseteq> c;(d;c)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>) =\n    (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n     c ; (d ; c)\\<^sup>\\<star>)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: a1)"], ["proof (state)\nthis:\n  (((c::'a::refinement_lattice) ;\n    (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n   c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (((c::'a::refinement_lattice) ;\n    (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n   c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)", "have a3: \"... \\<longleftrightarrow> c;( nil \\<sqinter> d;(c;d)\\<^sup>\\<star>;c) \\<sqsubseteq> c;(d;c)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (((c::'a::refinement_lattice) ;\n    (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n   c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n     c ; (d ; c)\\<^sup>\\<star>) =\n    (c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n     c ; (d ; c)\\<^sup>\\<star>)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis a1 eq_iff fiter_unfold lr seq_assoc seq_inf_distrib seq_nil_right)"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) \\<sqinter>\n   c ; (d::'a::refinement_lattice) ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have a4: \"(nil \\<sqinter> d;(c;d)\\<^sup>\\<star>;c) \\<sqsubseteq> (d;c)\\<^sup>\\<star> \\<Longrightarrow> c;( nil \\<sqinter> d;(c;d)\\<^sup>\\<star>;c) \\<sqsubseteq> c;(d;c)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star> \\<Longrightarrow>\n    c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n    c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "using seq_mono_right"], ["proof (prove)\nusing this:\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  (?d::'a::refinement_lattice) ; ?c\\<^sub>0 \\<sqsubseteq> ?d ; ?c\\<^sub>1\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star> \\<Longrightarrow>\n    c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n    c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star> \\<Longrightarrow>\n  c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have a5: \"(nil \\<sqinter> d;(c;d)\\<^sup>\\<star>;c) \\<sqsubseteq> (d;c)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "have f1: \"d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil = d ; ((c ; d)\\<^sup>\\<star> ; c) \\<sqinter> nil \\<sqinter> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil =\n    d ; ((c ; d)\\<^sup>\\<star> ; c) \\<sqinter> nil \\<sqinter> nil\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: seq_assoc)"], ["proof (state)\nthis:\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqinter>\n  nil =\n  d ; ((c ; d)\\<^sup>\\<star> ; c) \\<sqinter> nil \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "have \"d ; c ; (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) = d ; ((c ; d)\\<^sup>\\<star> ; c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d ; c ; (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) =\n    d ; ((c ; d)\\<^sup>\\<star> ; c)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (no_types) a1 inf_sup_aci(1) seq_assoc \n                seq_finite_conjunctive.seq_inf_distrib seq_finite_conjunctive_axioms \n                seq_nil_right)"], ["proof (state)\nthis:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice) ;\n  (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) =\n  d ; ((c ; d)\\<^sup>\\<star> ; c)\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice) ;\n  (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) =\n  d ; ((c ; d)\\<^sup>\\<star> ; c)", "show ?thesis"], ["proof (prove)\nusing this:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice) ;\n  (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) =\n  d ; ((c ; d)\\<^sup>\\<star> ; c)\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "using f1"], ["proof (prove)\nusing this:\n  (d::'a::refinement_lattice) ; (c::'a::refinement_lattice) ;\n  (d ; (c ; d)\\<^sup>\\<star> ; c \\<sqinter> nil) =\n  d ; ((c ; d)\\<^sup>\\<star> ; c)\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqinter>\n  nil =\n  d ; ((c ; d)\\<^sup>\\<star> ; c) \\<sqinter> nil \\<sqinter> nil\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n    (d ; c)\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (no_types) finite_iteration.fiter_induct finite_iteration_axioms \n                           inf.cobounded1 inf_sup_aci(1) seq_nil_right)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using a2 a3 a4"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star>\n  (((c::'a::refinement_lattice) ;\n    (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n   c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c \\<sqinter> c ; d ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)\n  ((c::'a::refinement_lattice) \\<sqinter>\n   c ; (d::'a::refinement_lattice) ; (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>) =\n  (c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n   c ; (d ; c)\\<^sup>\\<star>)\n  nil \\<sqinter>\n  (d::'a::refinement_lattice) ;\n  ((c::'a::refinement_lattice) ; d)\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  (d ; c)\\<^sup>\\<star> \\<Longrightarrow>\n  c ; (nil \\<sqinter> d ; (c ; d)\\<^sup>\\<star> ; c) \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (c ; d)\\<^sup>\\<star> ; c \\<sqsubseteq> c ; (d ; c)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> = (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((c::'a::refinement_lattice) ;\n   (d::'a::refinement_lattice))\\<^sup>\\<star> ;\n  c \\<sqsubseteq>\n  c ; (d ; c)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; (d ; c)\\<^sup>\\<star> = (c ; d)\\<^sup>\\<star> ; c\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: eq_iff lr)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ;\n  ((d::'a::refinement_lattice) ; c)\\<^sup>\\<star> =\n  (c ; d)\\<^sup>\\<star> ; c\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "locale iteration_infinite_conjunctive = seq_infinite_conjunctive + iteration + infimum_nat\n\nbegin"], ["", "lemma fiter_seq_choice: \"c\\<^sup>\\<star> = (\\<Sqinter>i::nat. c \\<^sup>;^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> = \\<Sqinter> range ((\\<^sup>;^) c)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> \\<Sqinter> range ((\\<^sup>;^) c)\n 2. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"c\\<^sup>\\<star> \\<sqsubseteq> (\\<Sqinter>i. c \\<^sup>;^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> \\<Sqinter> range ((\\<^sup>;^) c)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule INF_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i::nat.\n       i \\<in> UNIV \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ i\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i::nat.\n       i \\<in> UNIV \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ i\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ i\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (induct i type: nat)"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ (0::nat)\n 2. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ (0::nat)\n 2. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ (0::nat)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: fiter0)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ 0\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case (Suc n)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ (n::nat)\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"c\\<^sup>\\<star> \\<sqsubseteq> c ; c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c ; c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_unfold inf_le2)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... \\<sqsubseteq> c ; (c \\<^sup>;^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> \\<sqsubseteq> c ; (c \\<^sup>;^ n)\nvariables:\n  n :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using Suc.hyps"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ (n::nat)\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> \\<sqsubseteq> c ; (c \\<^sup>;^ n)\nvariables:\n  n :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp only: seq_mono_right)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<star> \\<sqsubseteq>\n  c ; (c \\<^sup>;^ (n::nat))\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<star> \\<sqsubseteq>\n  c ; (c \\<^sup>;^ (n::nat))\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = c \\<^sup>;^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (c \\<^sup>;^ n) = c \\<^sup>;^ Suc n\nvariables:\n  n :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; (c \\<^sup>;^ (n::nat)) = c \\<^sup>;^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n::nat.\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ n \\<Longrightarrow>\n       c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "finally"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ Suc (n::nat)", "show \"c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ Suc (n::nat)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c \\<^sup>;^ Suc n\nvariables:\n  n :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "."], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ Suc (n::nat)\n\ngoal:\nNo subgoals!\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c \\<^sup>;^ (i::nat)\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  \\<Sqinter> range ((\\<^sup>;^) c)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(\\<Sqinter>i. c \\<^sup>;^ i) \\<sqsubseteq> (c \\<^sup>;^ 0) \\<sqinter> (\\<Sqinter>i. c \\<^sup>;^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq>\n    c \\<^sup>;^ (0::nat) \\<sqinter> (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson INF_greatest INF_lower UNIV_I le_inf_iff)"], ["proof (state)\nthis:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  c \\<^sup>;^ 0 \\<sqinter> (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  c \\<^sup>;^ 0 \\<sqinter> (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = nil \\<sqinter> (\\<Sqinter>i. c ; (c \\<^sup>;^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<^sup>;^ (0::nat) \\<sqinter> (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i) =\n    nil \\<sqinter> (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<^sup>;^ 0 \\<sqinter>\n  (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i) =\n  nil \\<sqinter> (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<^sup>;^ 0 \\<sqinter>\n  (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i) =\n  nil \\<sqinter> (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = nil \\<sqinter> c ; (\\<Sqinter>i. c \\<^sup>;^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i)) =\n    nil \\<sqinter> c ; \\<Sqinter> range ((\\<^sup>;^) c)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: seq_INF_distrib)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (\\<Sqinter>i::nat. (c::'a::refinement_lattice) ; (c \\<^sup>;^ i)) =\n  nil \\<sqinter> c ; \\<Sqinter> range ((\\<^sup>;^) c)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  nil \\<sqinter> c ; \\<Sqinter> range ((\\<^sup>;^) c)", "show \"(\\<Sqinter>i. c \\<^sup>;^ i) \\<sqsubseteq> c\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  nil \\<sqinter> c ; \\<Sqinter> range ((\\<^sup>;^) c)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using fiter_induct"], ["proof (prove)\nusing this:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  nil \\<sqinter> c ; \\<Sqinter> range ((\\<^sup>;^) c)\n  (?x::'a::refinement_lattice) \\<sqsubseteq>\n  (?d::'a::refinement_lattice) \\<sqinter>\n  (?c::'a::refinement_lattice) ; ?x \\<Longrightarrow>\n  ?x \\<sqsubseteq> ?c\\<^sup>\\<star> ; ?d\n\ngoal (1 subgoal):\n 1. \\<Sqinter> range ((\\<^sup>;^) c) \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  \\<Sqinter> range ((\\<^sup>;^) (c::'a::refinement_lattice)) \\<sqsubseteq>\n  c\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma fiter_seq_choice_nonempty: \"c ; c\\<^sup>\\<star> = (\\<Sqinter>i\\<in>{i. 0 < i}. c \\<^sup>;^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"(\\<Sqinter>i\\<in>{i. 0 < i}. c \\<^sup>;^ i) = (\\<Sqinter>i. c \\<^sup>;^ (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i}) =\n    (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: INF_nat_shift)"], ["proof (state)\nthis:\n  \\<Sqinter> ((\\<^sup>;^) (c::'a::refinement_lattice) ` {i::nat. 0 < i}) =\n  (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  \\<Sqinter> ((\\<^sup>;^) (c::'a::refinement_lattice) ` {i::nat. 0 < i}) =\n  (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i)\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = (\\<Sqinter>i. c ; (c \\<^sup>;^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>i::nat. c \\<^sup>;^ Suc i) =\n    (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (\\<Sqinter>i::nat. (c::'a::refinement_lattice) \\<^sup>;^ Suc i) =\n  (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>i::nat. (c::'a::refinement_lattice) \\<^sup>;^ Suc i) =\n  (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i))\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = c ; (\\<Sqinter>i. c \\<^sup>;^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>i::nat. c ; (c \\<^sup>;^ i)) =\n    c ; \\<Sqinter> range ((\\<^sup>;^) c)\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: seq_INF_distrib_UNIV)"], ["proof (state)\nthis:\n  (\\<Sqinter>i::nat. (c::'a::refinement_lattice) ; (c \\<^sup>;^ i)) =\n  c ; \\<Sqinter> range ((\\<^sup>;^) c)\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>i::nat. (c::'a::refinement_lattice) ; (c \\<^sup>;^ i)) =\n  c ; \\<Sqinter> range ((\\<^sup>;^) c)\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"... = c ; c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<Sqinter> range ((\\<^sup>;^) c) = c ; c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: fiter_seq_choice)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; \\<Sqinter> range ((\\<^sup>;^) c) =\n  c ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> ((\\<^sup>;^) (c::'a::refinement_lattice) ` {i::nat. 0 < i}) =\n  c ; c\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> ((\\<^sup>;^) (c::'a::refinement_lattice) ` {i::nat. 0 < i}) =\n  c ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c ; c\\<^sup>\\<star> =\n    \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. (0::nat) < i})\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<star> =\n  \\<Sqinter> ((\\<^sup>;^) c ` {i::nat. 0 < i})\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "locale conj_iteration = cra + iteration_infinite_conjunctive\n\nbegin"], ["", "lemma conj_distrib4: \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> = (nil \\<sqinter> (c;c\\<^sup>\\<star>)) \\<iinter> d\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> =\n    (nil \\<sqinter> c ; c\\<^sup>\\<star>) \\<iinter> d\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_unfold)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<star>) \\<iinter> d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<star>) \\<iinter> d\\<^sup>\\<star>", "have \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> = (nil \\<iinter> d\\<^sup>\\<star>) \\<sqinter> ((c;c\\<^sup>\\<star>) \\<iinter> d\\<^sup>\\<star>)\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<star>) \\<iinter> d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> =\n    nil \\<iinter> d\\<^sup>\\<star> \\<sqinter>\n    c ; c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: inf_conj_distrib)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  nil \\<iinter> d\\<^sup>\\<star> \\<sqinter>\n  c ; c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  nil \\<iinter> d\\<^sup>\\<star> \\<sqinter>\n  c ; c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>", "have \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq> nil \\<sqinter> ((c;c\\<^sup>\\<star>) \\<iinter> (d;d\\<^sup>\\<star>))\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> =\n  nil \\<iinter> d\\<^sup>\\<star> \\<sqinter>\n  c ; c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    nil \\<sqinter> c ; c\\<^sup>\\<star> \\<iinter> d ; d\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis conj_idem fiter0 fiter_unfold inf.bounded_iff inf_le2 local.conj_mono)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<star> \\<iinter> d ; d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<star> \\<iinter> d ; d\\<^sup>\\<star>", "have \"c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq> nil \\<sqinter> ((c \\<iinter> d);(c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>))\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<star> \\<iinter> d ; d\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    nil \\<sqinter>\n    (c \\<iinter> d) ; (c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>)\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson inf_mono_right order.trans sequential_interchange)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter>\n  (c \\<iinter> d) ; (c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter>\n  (c \\<iinter> d) ; (c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<iinter> d\\<^sup>\\<star> \\<sqsubseteq>\n    (c \\<iinter> d)\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis seq_nil_right fiter_induct)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<iinter>\n  (d::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  (c \\<iinter> d)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (\\<iinter>), (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "end"]]}