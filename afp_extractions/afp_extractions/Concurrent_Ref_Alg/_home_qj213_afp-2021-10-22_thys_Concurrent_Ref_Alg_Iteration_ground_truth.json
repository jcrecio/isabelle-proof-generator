{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg/Iteration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg", "problem_names": ["lemma iter_step_mono: \"mono (\\<lambda> x. nil \\<sqinter> c;x)\"", "theorem iter_unfold: \"c\\<^sup>\\<omega> = nil \\<sqinter> c;c\\<^sup>\\<omega>\"", "lemma iter_induct_nil: \"nil \\<sqinter> c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<omega> \\<sqsubseteq> x\"", "lemma iter0: \"c\\<^sup>\\<omega> \\<sqsubseteq> nil\"", "lemma iter1: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\"", "lemma iter2 [simp]: \"c\\<^sup>\\<omega>;c\\<^sup>\\<omega> = c\\<^sup>\\<omega>\"", "lemma iter_mono: \"c \\<sqsubseteq> d \\<Longrightarrow> c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\"", "lemma iter_abort: \"\\<bottom> = nil\\<^sup>\\<omega>\"", "lemma nil_iter: \"\\<top>\\<^sup>\\<omega> = nil\"", "lemma fin_iter_step_mono: \"mono (\\<lambda> x. nil \\<sqinter> c;x)\"", "lemma fiter_unfold: \"c\\<^sup>\\<star> = nil \\<sqinter> c;c\\<^sup>\\<star>\"", "lemma fiter_induct_nil: \"x \\<sqsubseteq> nil \\<sqinter> c;x \\<Longrightarrow> x \\<sqsubseteq> c\\<^sup>\\<star>\"", "lemma fiter0: \"c\\<^sup>\\<star> \\<sqsubseteq> nil\"", "lemma fiter1: \"c\\<^sup>\\<star> \\<sqsubseteq> c\"", "lemma fiter_induct_eq: \"c\\<^sup>\\<star>;d = gfp (\\<lambda> x. c;x \\<sqinter> d)\"", "theorem fiter_induct: \"x \\<sqsubseteq> d \\<sqinter> c;x \\<Longrightarrow> x \\<sqsubseteq> c\\<^sup>\\<star>;d\"", "lemma fiter2 [simp]: \"c\\<^sup>\\<star>;c\\<^sup>\\<star> = c\\<^sup>\\<star>\"", "lemma fiter3 [simp]: \"(c\\<^sup>\\<star>)\\<^sup>\\<star> = c\\<^sup>\\<star>\"", "lemma fiter_mono: \"c \\<sqsubseteq> d \\<Longrightarrow> c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\"", "lemma infiter_step_mono: \"mono (\\<lambda> x. c;x)\"", "theorem infiter_unfold: \"c\\<^sup>\\<infinity> = c;c\\<^sup>\\<infinity>\"", "lemma infiter_induct: \"c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<infinity> \\<sqsubseteq> x\"", "theorem infiter_unfold_any: \"c\\<^sup>\\<infinity> = (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity>\"", "lemma infiter_annil: \"c\\<^sup>\\<infinity>;x = c\\<^sup>\\<infinity>\"", "lemma refine_iter: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<star>\"", "lemma iter_absorption [simp]: \"(c\\<^sup>\\<omega>)\\<^sup>\\<star> = c\\<^sup>\\<omega>\"", "lemma infiter_inf_top: \"c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\"", "lemma infiter_fiter_top:\n  shows \"c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<star> ; \\<top>\"", "lemma inf_ref_infiter: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<infinity>\""], "translations": [["", "lemma iter_step_mono: \"mono (\\<lambda> x. nil \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>x::'a. nil \\<sqinter> c ; x)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson inf_mono order_refl seq_mono_right mono_def)"], ["", "text \\<open>\n  This fixed point definition leads to the two core iteration lemmas:\n  folding and induction.\n\\<close>"], ["", "theorem iter_unfold: \"c\\<^sup>\\<omega> = nil \\<sqinter> c;c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = nil \\<sqinter> c ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using iter_def iter_step_mono lfp_unfold"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> \\<equiv>\n  lfp (\\<lambda>x::'a::refinement_lattice. nil \\<sqinter> ?c ; x)\n  mono\n   (\\<lambda>x::'a::refinement_lattice.\n       nil \\<sqinter> (?c::'a::refinement_lattice) ; x)\n  mono\n   (?f::?'a::complete_lattice\n        \\<Rightarrow> ?'a::complete_lattice) \\<Longrightarrow>\n  lfp ?f = ?f (lfp ?f)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> = nil \\<sqinter> c ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["", "lemma iter_induct_nil: \"nil \\<sqinter> c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<omega> \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; x \\<sqsubseteq> x \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> x\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: iter_def lfp_lowerbound)"], ["", "lemma iter0: \"c\\<^sup>\\<omega> \\<sqsubseteq> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> nil\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis iter_unfold sup.orderI sup_inf_absorb)"], ["", "lemma iter1: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_le2 iter0 iter_unfold order.trans seq_mono_right seq_nil_right)"], ["", "lemma iter2 [simp]: \"c\\<^sup>\\<omega>;c\\<^sup>\\<omega> = c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> = c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\n 2. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"c\\<^sup>\\<omega>;c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using iter0 seq_mono_right"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq> nil\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  (?d::'a::refinement_lattice) ; ?c\\<^sub>0 \\<sqsubseteq> ?d ; ?c\\<^sub>1\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have a: \"nil \\<sqinter> c;c\\<^sup>\\<omega>;c\\<^sup>\\<omega> \\<sqsubseteq> nil \\<sqinter> c;c\\<^sup>\\<omega> \\<sqinter> c;c\\<^sup>\\<omega>;c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> \\<sqsubseteq>\n    nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n    c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_greatest inf_le2 inf_mono iter0 order_refl seq_distrib_left.seq_mono_right seq_distrib_left_axioms seq_nil_right)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>", "have b: \"\\<dots> = c\\<^sup>\\<omega> \\<sqinter> c;c\\<^sup>\\<omega>;c\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n    c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n    c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "using iter_unfold"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> =\n  nil \\<sqinter> ?c ; ?c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n    c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n    c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  nil \\<sqinter> (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  nil \\<sqinter> (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>", "have c: \"\\<dots> = (nil \\<sqinter> c;c\\<^sup>\\<omega>);c\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  nil \\<sqinter> (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqinter> c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n    (nil \\<sqinter> c ; c\\<^sup>\\<omega>) ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: inf_seq_distrib)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<omega>) ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus \"c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>;c\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<omega>) ; c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using a iter_induct_nil iter_unfold seq_assoc"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega> =\n  (nil \\<sqinter> c ; c\\<^sup>\\<omega>) ; c\\<^sup>\\<omega>\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ; c\\<^sup>\\<omega> ;\n  c\\<^sup>\\<omega> \\<sqsubseteq>\n  nil \\<sqinter> c ; c\\<^sup>\\<omega> \\<sqinter>\n  c ; c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n  nil \\<sqinter>\n  (?c::'a::refinement_lattice) ; (?x::'a::refinement_lattice) \\<sqsubseteq>\n  ?x \\<Longrightarrow>\n  ?c\\<^sup>\\<omega> \\<sqsubseteq> ?x\n  (?c::'a::refinement_lattice)\\<^sup>\\<omega> =\n  nil \\<sqinter> ?c ; ?c\\<^sup>\\<omega>\n  (?a::'a::refinement_lattice) ; (?b::'a::refinement_lattice) ;\n  (?c::'a::refinement_lattice) =\n  ?a ; (?b ; ?c)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; c\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_mono: \"c \\<sqsubseteq> d \\<Longrightarrow> c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "assume \"c \\<sqsubseteq> d\""], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)", "have \"nil \\<sqinter> c;d\\<^sup>\\<omega> \\<sqsubseteq> d;d\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; d\\<^sup>\\<omega> \\<sqsubseteq> d ; d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.absorb_iff2 inf_left_commute inf_seq_distrib)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ;\n  (d::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; d\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ;\n  (d::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; d\\<^sup>\\<omega>", "have \"nil \\<sqinter> c;d\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\""], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ;\n  (d::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  d ; d\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. nil \\<sqinter> c ; d\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.bounded_iff inf_sup_ord(1) iter_unfold)"], ["proof (state)\nthis:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ;\n  (d::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  d\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  nil \\<sqinter>\n  (c::'a::refinement_lattice) ;\n  (d::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  d\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> d\\<^sup>\\<omega>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: iter_induct_nil)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  (d::'a::refinement_lattice)\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma iter_abort: \"\\<bottom> = nil\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> = nil\\<^sup>\\<omega>\nvariables:\n  nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: antisym iter_induct_nil)"], ["", "lemma nil_iter: \"\\<top>\\<^sup>\\<omega> = nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top>\\<^sup>\\<omega> = nil\nvariables:\n  nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (no_types) inf_top.right_neutral iter_unfold seq_top)"], ["", "(*\nlemma iter_conj_distrib:\n  assumes nil: \"c \\<sqsubseteq> nil\"\n    and repeat: \"c \\<sqsubseteq> c ; c\"\n  shows \"c \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<omega>\"\nproof (unfold iter_def)\n  def F \\<equiv> \"(\\<lambda> x. c \\<iinter> x)\"\n  def G \\<equiv> \"(\\<lambda> x. nil \\<sqinter> d;x)\"\n  def H \\<equiv> \"(\\<lambda> x. nil \\<sqinter> ((c \\<iinter> d);x))\"\n\n  have FG: \"F \\<circ> G = (\\<lambda> x. c \\<iinter> (nil \\<sqinter> d;x))\"  by (metis comp_def F_def G_def) \n  have HF: \"H \\<circ> F = (\\<lambda> x. (nil \\<sqinter> (c \\<iinter> d);(c \\<iinter> x)))\" by (metis comp_def H_def F_def) \n\n  have \"F (lfp G) \\<sqsubseteq> lfp H\"\n  proof (rule fusion_lfp_leq)\n    show \"mono H\" by (simp add: H_def iter_step_mono)\n  next\n    show \"dist_over_sup F\" by (simp add: F_def conj_Sup_distrib)\n  next\n    fix x\n    have \"c \\<iinter> (nil \\<sqinter> d;x) = (c \\<iinter> nil) \\<sqinter> (c \\<iinter> d;x)\" by (metis inf_conj_distrib conj_commute)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c \\<iinter> d;x)\" by (metis conjunction_sup inf_mono_left le_iff_sup nil)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c;c \\<iinter> d;x)\" by (metis inf_conj_distrib inf.absorb_iff2 inf_mono_right repeat)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c \\<iinter> d);(c \\<iinter> x)\" by (meson inf_mono_right sequential_interchange)\n    finally show \"(F \\<circ> G) x \\<sqsubseteq> (H \\<circ> F) x\" by (simp add: FG HF)\n  qed\n\n  then show \"c \\<iinter> lfp(\\<lambda>x. nil \\<sqinter> d ; x) \\<sqsubseteq> lfp (\\<lambda>x. nil \\<sqinter> (c \\<iinter> d) ; x)\" using F_def G_def H_def by simp\nqed\n\nlemma iter_conj_distrib1: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c\\<^sup>\\<omega> \\<iinter> d)\\<^sup>\\<omega>\"\n  by (simp add: iter0 iter_conj_distrib)\n\nlemma iter_conj_distrib2: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<omega>\"\nproof -\n  have a: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\" by (metis iter1)\n  have b: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c\\<^sup>\\<omega> \\<iinter> d)\\<^sup>\\<omega>\" by (metis iter_conj_distrib1)\n  have \"c\\<^sup>\\<omega> \\<iinter> d \\<sqsubseteq> c \\<iinter> d\" by (metis a conj_mono order.refl) \n  thus ?thesis using a b by (metis refine_trans iter_mono) \nqed\n*)"], ["", "end"], ["", "subsection \\<open>Finite iteration\\<close>"], ["", "text \\<open>\n  Iteration of a finite number of steps (Kleene star) is defined\n  using the greatest fixed point.\n\\<close>"], ["", "locale finite_iteration = seq_distrib + lower_galois_connections\nbegin"], ["", "definition\n  fiter :: \"'a \\<Rightarrow> 'a\" (\"_\\<^sup>\\<star>\" [101] 100)\nwhere\n  \"c\\<^sup>\\<star> \\<equiv> gfp (\\<lambda> x. nil \\<sqinter> c;x)\""], ["", "lemma fin_iter_step_mono: \"mono (\\<lambda> x. nil \\<sqinter> c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>x::'a. nil \\<sqinter> c ; x)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson inf_mono order_refl seq_mono_right mono_def)"], ["", "text \\<open>\n  This definition leads to the two core iteration lemmas:\n  folding and induction.\n\\<close>"], ["", "lemma fiter_unfold: \"c\\<^sup>\\<star> = nil \\<sqinter> c;c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> = nil \\<sqinter> c ; c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using fiter_def gfp_unfold fin_iter_step_mono"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<star> \\<equiv>\n  gfp (\\<lambda>x::'a::refinement_lattice. nil \\<sqinter> ?c ; x)\n  mono\n   (?f::?'a::complete_lattice\n        \\<Rightarrow> ?'a::complete_lattice) \\<Longrightarrow>\n  gfp ?f = ?f (gfp ?f)\n  mono\n   (\\<lambda>x::'a::refinement_lattice.\n       nil \\<sqinter> (?c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> = nil \\<sqinter> c ; c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["", "lemma fiter_induct_nil: \"x \\<sqsubseteq> nil \\<sqinter> c;x \\<Longrightarrow> x \\<sqsubseteq> c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> nil \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: fiter_def gfp_upperbound)"], ["", "lemma fiter0: \"c\\<^sup>\\<star> \\<sqsubseteq> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> nil\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_unfold inf.cobounded1)"], ["", "lemma fiter1: \"c\\<^sup>\\<star> \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter0 fiter_unfold inf_le2 order.trans seq_mono_right seq_nil_right)"], ["", "lemma fiter_induct_eq: \"c\\<^sup>\\<star>;d = gfp (\\<lambda> x. c;x \\<sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define F where \"F = (\\<lambda> x. x;d)\""], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice. x ; (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define G where \"G = (\\<lambda> x. nil \\<sqinter> c;x)\""], ["proof (state)\nthis:\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter> (c::'a::refinement_lattice) ; x)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "define H where \"H = (\\<lambda> x. c;x \\<sqinter> d)\""], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x \\<sqinter>\n      (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have FG: \"F \\<circ> G = (\\<lambda> x. c;x;d \\<sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<circ> G = (\\<lambda>x::'a. c ; x ; d \\<sqinter> d)\nvariables:\n  c, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: F_def G_def comp_def inf_commute inf_seq_distrib)"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      d)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have HF: \"H \\<circ> F = (\\<lambda> x. c;x;d \\<sqinter> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<circ> F = (\\<lambda>x::'a. c ; x ; d \\<sqinter> d)\nvariables:\n  c, d :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  F, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis comp_def seq_assoc H_def F_def)"], ["proof (state)\nthis:\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      d)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have adjoint: \"dist_over_inf F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist_over_inf F\nvariables:\n  F :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using Inf_seq_distrib F_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> (?C::'a::refinement_lattice set) ;\n  (?d::'a::refinement_lattice) =\n  (\\<Sqinter>c::'a::refinement_lattice\\<in>?C. c ; ?d)\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice. x ; (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. dist_over_inf F\nvariables:\n  F :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  dist_over_inf\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoH: \"mono H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono H\nvariables:\n  H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis H_def inf_mono_left monoI seq_distrib_left.seq_mono_right seq_distrib_left_axioms)"], ["proof (state)\nthis:\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have monoG: \"mono G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono G\nvariables:\n  G :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis G_def inf_mono_right mono_def seq_mono_right)"], ["proof (state)\nthis:\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"\\<forall> x. ((F \\<circ> G) x = (H \\<circ> F) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using FG HF"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      d)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x ;\n      (d::'a::refinement_lattice) \\<sqinter>\n      d)\n\ngoal (1 subgoal):\n 1. \\<forall>x::'a. (F \\<circ> G) x = (H \\<circ> F) x\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x", "have \"F (gfp G) = gfp H\""], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n\ngoal (1 subgoal):\n 1. F (gfp G) = gfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using adjoint monoG monoH fusion_gfp_eq"], ["proof (prove)\nusing this:\n  \\<forall>x::'a::refinement_lattice.\n     ((F::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice))\n      x =\n     ((H::'a::refinement_lattice\n          \\<Rightarrow> 'a::refinement_lattice) \\<circ>\n      F)\n      x\n  dist_over_inf\n   (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  mono (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  \\<lbrakk>mono\n            (?H::?'a::refinement_lattice\n                 \\<Rightarrow> ?'a::refinement_lattice);\n   mono (?G::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   dist_over_inf\n    (?F::?'a::refinement_lattice \\<Rightarrow> ?'a::refinement_lattice);\n   \\<And>x::?'a::refinement_lattice.\n      (?F \\<circ> ?G) x = (?H \\<circ> ?F) x\\<rbrakk>\n  \\<Longrightarrow> ?F (gfp ?G) = gfp ?H\n\ngoal (1 subgoal):\n 1. F (gfp G) = gfp H\nvariables:\n  F, G, H :: 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (gfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  gfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (gfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  gfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)", "have \"(gfp (\\<lambda> x. nil \\<sqinter> c;x));d = gfp (\\<lambda> x. c;x \\<sqinter> d)\""], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (gfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  gfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. gfp (\\<lambda>x::'a. nil \\<sqinter> c ; x) ; d =\n    gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using F_def G_def H_def inf_commute"], ["proof (prove)\nusing this:\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n   (gfp (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)) =\n  gfp (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice)\n  (F::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice. x ; (d::'a::refinement_lattice))\n  (G::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      nil \\<sqinter> (c::'a::refinement_lattice) ; x)\n  (H::'a::refinement_lattice \\<Rightarrow> 'a::refinement_lattice) =\n  (\\<lambda>x::'a::refinement_lattice.\n      (c::'a::refinement_lattice) ; x \\<sqinter>\n      (d::'a::refinement_lattice))\n  (?x::?'a::semilattice_inf) \\<sqinter> (?y::?'a::semilattice_inf) =\n  ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. gfp (\\<lambda>x::'a. nil \\<sqinter> c ; x) ; d =\n    gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  gfp (\\<lambda>x::'a::refinement_lattice.\n          nil \\<sqinter> (c::'a::refinement_lattice) ; x) ;\n  (d::'a::refinement_lattice) =\n  gfp (\\<lambda>x::'a::refinement_lattice. c ; x \\<sqinter> d)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  gfp (\\<lambda>x::'a::refinement_lattice.\n          nil \\<sqinter> (c::'a::refinement_lattice) ; x) ;\n  (d::'a::refinement_lattice) =\n  gfp (\\<lambda>x::'a::refinement_lattice. c ; x \\<sqinter> d)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; d = gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_def)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice) =\n  gfp (\\<lambda>x::'a::refinement_lattice. c ; x \\<sqinter> d)\n\ngoal:\nNo subgoals!\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "theorem fiter_induct: \"x \\<sqsubseteq> d \\<sqinter> c;x \\<Longrightarrow> x \\<sqsubseteq> c\\<^sup>\\<star>;d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> d \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> d \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "assume \"x \\<sqsubseteq> d \\<sqinter> c;x\""], ["proof (state)\nthis:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (d::'a::refinement_lattice) \\<sqinter> (c::'a::refinement_lattice) ; x\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> d \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (d::'a::refinement_lattice) \\<sqinter> (c::'a::refinement_lattice) ; x", "have \"x \\<sqsubseteq> c;x \\<sqinter> d\""], ["proof (prove)\nusing this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (d::'a::refinement_lattice) \\<sqinter> (c::'a::refinement_lattice) ; x\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> c ; x \\<sqinter> d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "using inf_commute"], ["proof (prove)\nusing this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (d::'a::refinement_lattice) \\<sqinter> (c::'a::refinement_lattice) ; x\n  (?x::?'a::semilattice_inf) \\<sqinter> (?y::?'a::semilattice_inf) =\n  ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> c ; x \\<sqinter> d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (c::'a::refinement_lattice) ; x \\<sqinter> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> d \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (c::'a::refinement_lattice) ; x \\<sqinter> (d::'a::refinement_lattice)", "have \"x \\<sqsubseteq> gfp (\\<lambda> x. c;x \\<sqinter> d)\""], ["proof (prove)\nusing this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (c::'a::refinement_lattice) ; x \\<sqinter> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> gfp (\\<lambda>x::'a. c ; x \\<sqinter> d)\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: gfp_upperbound)"], ["proof (state)\nthis:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  gfp (\\<lambda>x::'a::refinement_lattice.\n          (c::'a::refinement_lattice) ; x \\<sqinter>\n          (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> d \\<sqinter> c ; x \\<Longrightarrow>\n    x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  gfp (\\<lambda>x::'a::refinement_lattice.\n          (c::'a::refinement_lattice) ; x \\<sqinter>\n          (d::'a::refinement_lattice))\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> c\\<^sup>\\<star> ; d\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (full_types) fiter_induct_eq)"], ["proof (state)\nthis:\n  (x::'a::refinement_lattice) \\<sqsubseteq>\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; (d::'a::refinement_lattice)\n\ngoal:\nNo subgoals!\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil, x :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma fiter2 [simp]: \"c\\<^sup>\\<star>;c\\<^sup>\\<star> = c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have lr: \"c\\<^sup>\\<star>;c\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using fiter0 seq_mono_right seq_nil_right"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq> nil\n  (?c\\<^sub>0::'a::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'a::refinement_lattice) \\<Longrightarrow>\n  (?d::'a::refinement_lattice) ; ?c\\<^sub>0 \\<sqsubseteq> ?d ; ?c\\<^sub>1\n  (?a::'a::refinement_lattice) ; nil = ?a\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; c\\<^sup>\\<star> \\<sqsubseteq>\n  c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have rl: \"c\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<star>;c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<star> ; c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter_induct fiter_unfold inf.right_idem order_refl)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c\\<^sup>\\<star> ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  c\\<^sup>\\<star> ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> ; c\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: antisym lr)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> ; c\\<^sup>\\<star> =\n  c\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma fiter3 [simp]: \"(c\\<^sup>\\<star>)\\<^sup>\\<star> = c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c\\<^sup>\\<star>)\\<^sup>\\<star> = c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis dual_order.refl fiter0 fiter1 fiter2 fiter_induct inf.commute inf_absorb1 seq_nil_right)"], ["", "lemma fiter_mono: \"c \\<sqsubseteq> d \\<Longrightarrow> c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "assume \"c \\<sqsubseteq> d\""], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)", "have \"c\\<^sup>\\<star> \\<sqsubseteq> nil \\<sqinter> d;c\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> (d::'a::refinement_lattice)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> nil \\<sqinter> d ; c\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter0 fiter1 fiter2 inf.bounded_iff refine_trans seq_mono_left)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter> (d::'a::refinement_lattice) ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> d \\<Longrightarrow>\n    c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  nil \\<sqinter> (d::'a::refinement_lattice) ; c\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<star> \\<sqsubseteq> d\\<^sup>\\<star>\nvariables:\n  c, d, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis seq_nil_right fiter_induct)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<star> \\<sqsubseteq>\n  (d::'a::refinement_lattice)\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d, nil :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "subsection \\<open>Infinite iteration\\<close>"], ["", "text \\<open>\n  Iteration of infinite number of steps can be defined\n  using a least fixed point.\n\\<close>"], ["", "locale infinite_iteration = seq_distrib + lower_galois_connections\nbegin"], ["", "definition\n  infiter :: \"'a  \\<Rightarrow> 'a\" (\"_\\<^sup>\\<infinity>\" [105] 106)\nwhere\n  \"c\\<^sup>\\<infinity> \\<equiv> lfp (\\<lambda> x. c;x)\""], ["", "lemma infiter_step_mono: \"mono (\\<lambda> x. c;x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((;) c)\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (meson inf_mono order_refl seq_mono_right mono_def)"], ["", "text \\<open>\n  This definition leads to the two core iteration lemmas:\n  folding and induction.\n\\<close>"], ["", "theorem infiter_unfold: \"c\\<^sup>\\<infinity> = c;c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c ; c\\<^sup>\\<infinity>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using infiter_def infiter_step_mono lfp_unfold"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<infinity> \\<equiv> lfp ((;) ?c)\n  mono ((;) (?c::'a::refinement_lattice))\n  mono\n   (?f::?'a::complete_lattice\n        \\<Rightarrow> ?'a::complete_lattice) \\<Longrightarrow>\n  lfp ?f = ?f (lfp ?f)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c ; c\\<^sup>\\<infinity>\nvariables:\n  c :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["", "lemma infiter_induct: \"c;x \\<sqsubseteq> x \\<Longrightarrow> c\\<^sup>\\<infinity> \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; x \\<sqsubseteq> x \\<Longrightarrow>\n    c\\<^sup>\\<infinity> \\<sqsubseteq> x\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: infiter_def lfp_lowerbound)"], ["", "theorem infiter_unfold_any: \"c\\<^sup>\\<infinity> = (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ (0::nat)) ; c\\<^sup>\\<infinity>\n 2. \\<And>i::nat.\n       c\\<^sup>\\<infinity> =\n       (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity> \\<Longrightarrow>\n       c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ (0::nat)) ; c\\<^sup>\\<infinity>\n 2. \\<And>i::nat.\n       c\\<^sup>\\<infinity> =\n       (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity> \\<Longrightarrow>\n       c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ (0::nat)) ; c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> =\n  (c \\<^sup>;^ 0) ; c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>i::nat.\n       c\\<^sup>\\<infinity> =\n       (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity> \\<Longrightarrow>\n       c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i::nat.\n       c\\<^sup>\\<infinity> =\n       (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity> \\<Longrightarrow>\n       c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "case (Suc i)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> =\n  (c \\<^sup>;^ (i::nat)) ; c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>i::nat.\n       c\\<^sup>\\<infinity> =\n       (c \\<^sup>;^ i) ; c\\<^sup>\\<infinity> \\<Longrightarrow>\n       c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?case"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> =\n  (c \\<^sup>;^ (i::nat)) ; c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using infiter_unfold seq_assoc seq_power_Suc"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> =\n  (c \\<^sup>;^ (i::nat)) ; c\\<^sup>\\<infinity>\n  (?c::'a::refinement_lattice)\\<^sup>\\<infinity> = ?c ; ?c\\<^sup>\\<infinity>\n  (?a::'a::refinement_lattice) ; (?b::'a::refinement_lattice) ;\n  (?c::'a::refinement_lattice) =\n  ?a ; (?b ; ?c)\n  (?a::'a::refinement_lattice) \\<^sup>;^ Suc (?n::nat) =\n  ?a ; (?a \\<^sup>;^ ?n)\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = (c \\<^sup>;^ Suc i) ; c\\<^sup>\\<infinity>\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> =\n  (c \\<^sup>;^ Suc (i::nat)) ; c\\<^sup>\\<infinity>\n\ngoal:\nNo subgoals!\nvariables:\n  i :: nat\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma infiter_annil: \"c\\<^sup>\\<infinity>;x = c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> ; x = c\\<^sup>\\<infinity>\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> ; x = c\\<^sup>\\<infinity>\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"\\<forall>a. (\\<bottom>::'a) \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a::'a. \\<bottom> \\<sqsubseteq> a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  \\<forall>a::'a::refinement_lattice. \\<bottom> \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> ; x = c\\<^sup>\\<infinity>\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a::'a::refinement_lattice. \\<bottom> \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> ; x = c\\<^sup>\\<infinity>\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (no_types) eq_iff inf.cobounded2 infiter_induct infiter_unfold inf_sup_ord(1) seq_assoc seq_bot weak_seq_inf_distrib seq_nil_right)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> ;\n  (x::'a::refinement_lattice) =\n  c\\<^sup>\\<infinity>\n\ngoal:\nNo subgoals!\nvariables:\n  c, x :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "subsection \\<open>Combined iteration\\<close>"], ["", "text \\<open>\n  The three different iteration operators can be combined to show that \n  finite iteration refines finite-or-infinite iteration.\n\\<close>"], ["", "locale iteration = finite_or_infinite_iteration + finite_iteration + \n                   infinite_iteration\nbegin"], ["", "lemma refine_iter: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis seq_nil_right order.refl iter_unfold fiter_induct)"], ["", "lemma iter_absorption [simp]: \"(c\\<^sup>\\<omega>)\\<^sup>\\<star> = c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega>\\<^sup>\\<star> = c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c\\<^sup>\\<omega>\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<omega>\n 2. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"(c\\<^sup>\\<omega>)\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega>\\<^sup>\\<star> \\<sqsubseteq> c\\<^sup>\\<omega>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter1)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega>\\<^sup>\\<star> \\<sqsubseteq>\n  c\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "show \"c\\<^sup>\\<omega> \\<sqsubseteq> (c\\<^sup>\\<omega>)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<omega>\\<^sup>\\<star>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis fiter1 fiter_induct inf_left_idem iter2 iter_unfold seq_nil_right sup.cobounded2 sup.orderE sup_commute)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> \\<sqsubseteq>\n  c\\<^sup>\\<omega>\\<^sup>\\<star>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma infiter_inf_top: \"c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have lr: \"c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<omega> ; \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have \"c ; (c\\<^sup>\\<omega> ; \\<top>) = nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; (c\\<^sup>\\<omega> ; \\<top>) =\n    nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using semigroup.assoc seq.semigroup_axioms"], ["proof (prove)\nusing this:\n  semigroup\n   (?f::?'a::type\n        \\<Rightarrow> ?'a::type \\<Rightarrow> ?'a::type) \\<Longrightarrow>\n  ?f (?f (?a::?'a::type) (?b::?'a::type)) (?c::?'a::type) = ?f ?a (?f ?b ?c)\n  semigroup (;)\n\ngoal (1 subgoal):\n 1. c ; (c\\<^sup>\\<omega> ; \\<top>) =\n    nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) ; (c\\<^sup>\\<omega> ; \\<top>) =\n  nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice) ; (c\\<^sup>\\<omega> ; \\<top>) =\n  nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) ; (c\\<^sup>\\<omega> ; \\<top>) =\n  nil ; \\<top> \\<sqinter> c ; c\\<^sup>\\<omega> ; \\<top>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis (no_types) eq_refl finite_or_infinite_iteration.iter_unfold \n         finite_or_infinite_iteration_axioms infiter_induct \n         seq_distrib_right.inf_seq_distrib seq_distrib_right_axioms)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; \\<top>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; \\<top>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "have rl: \"c\\<^sup>\\<omega> ; \\<top> \\<sqsubseteq> c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> ; \\<top> \\<sqsubseteq> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf_le2 infiter_annil infiter_unfold iter_induct_nil seq_mono_left)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; \\<top> \\<sqsubseteq>\n  c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; \\<top> \\<sqsubseteq>\n  c\\<^sup>\\<infinity>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using antisym_conv lr"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice)\\<^sup>\\<omega> ; \\<top> \\<sqsubseteq>\n  c\\<^sup>\\<infinity>\n  (?y::?'a::order) \\<le> (?x::?'a::order) \\<Longrightarrow>\n  (?x \\<le> ?y) = (?x = ?y)\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> \\<sqsubseteq>\n  c\\<^sup>\\<omega> ; \\<top>\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice)\\<^sup>\\<infinity> = c\\<^sup>\\<omega> ; \\<top>\n\ngoal:\nNo subgoals!\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma infiter_fiter_top:\n  shows \"c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<star> ; \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<infinity> \\<sqsubseteq> c\\<^sup>\\<star> ; \\<top>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis eq_iff fiter_induct inf_top_left infiter_unfold)"], ["", "lemma inf_ref_infiter: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using infiter_unfold iter_induct_nil"], ["proof (prove)\nusing this:\n  (?c::'a::refinement_lattice)\\<^sup>\\<infinity> = ?c ; ?c\\<^sup>\\<infinity>\n  nil \\<sqinter>\n  (?c::'a::refinement_lattice) ; (?x::'a::refinement_lattice) \\<sqsubseteq>\n  ?x \\<Longrightarrow>\n  ?c\\<^sup>\\<omega> \\<sqsubseteq> ?x\n\ngoal (1 subgoal):\n 1. c\\<^sup>\\<omega> \\<sqsubseteq> c\\<^sup>\\<infinity>\nvariables:\n  c, nil :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["", "end"], ["", "end"]]}