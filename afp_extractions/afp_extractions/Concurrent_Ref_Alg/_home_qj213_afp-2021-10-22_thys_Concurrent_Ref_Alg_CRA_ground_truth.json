{"file_name": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg/CRA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Concurrent_Ref_Alg", "problem_names": ["lemma nil_absorb: \"nil \\<parallel> nil = nil\"", "lemma skip_absorb [simp]: \"skip;skip = skip\"", "lemma chaos_skip: \"chaos \\<sqsubseteq> skip\"", "lemma chaos_par_chaos_eq: \"chaos = chaos \\<parallel> chaos\"", "lemma nonabort_par_top: \"chaos \\<sqsubseteq> c \\<Longrightarrow> c \\<parallel> \\<top> = \\<top>\"", "lemma skip_conj_top: \"skip \\<iinter> \\<top> = \\<top>\"", "lemma conj_distrib2: \"c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow> c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq> (c \\<iinter> d\\<^sub>0) \\<parallel> (c \\<iinter> d\\<^sub>1)\"", "lemma chaos_nil: \"chaos \\<sqsubseteq> nil\"", "lemma chaos_seq_absorb: \"chaos = chaos;chaos\"", "lemma seq_bot_conj: \"c;\\<bottom> \\<iinter> d \\<sqsubseteq> (c \\<iinter> d);\\<bottom>\"", "lemma conj_seq_bot_right [simp]: \"c;\\<bottom> \\<iinter> c =  c;\\<bottom>\"", "lemma conj_distrib3: \"c \\<sqsubseteq> c;c \\<Longrightarrow> c \\<iinter> (d\\<^sub>0 ; d\\<^sub>1) \\<sqsubseteq> (c \\<iinter> d\\<^sub>0);(c \\<iinter> d\\<^sub>1)\""], "translations": [["", "lemma nil_absorb: \"nil \\<parallel> nil = nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nil \\<parallel> nil = nil\nvariables:\n  nil :: 'a\n  (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using nil_par_nil skip_nil par_skip"], ["proof (prove)\nusing this:\n  nil \\<parallel> nil \\<sqsubseteq> nil\n  skip \\<sqsubseteq> nil\n  (?a::'a::refinement_lattice) \\<parallel> skip = ?a\n\ngoal (1 subgoal):\n 1. nil \\<parallel> nil = nil\nvariables:\n  nil :: 'a\n  (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis inf.absorb_iff2 inf.orderE inf_par_distrib2)"], ["", "lemma skip_absorb [simp]: \"skip;skip = skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skip ; skip = skip\nvariables:\n  skip :: 'a\n  (;) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis antisym seq_mono_right seq_nil_right skip_skip skip_nil)"], ["", "end"], ["", "text \\<open>\n  Locale conjunction-parallel brings together the weak conjunction and\n  parallel operators and relates their identities.\n  It also introduces the interchange axiom for conjunction and parallel.\n\\<close>"], ["", "locale conjunction_parallel = conj_distrib + par_distrib + \n  assumes chaos_par_top: \"\\<top> \\<sqsubseteq> chaos \\<parallel> \\<top>\"\n  assumes chaos_par_chaos: \"chaos \\<sqsubseteq> chaos \\<parallel> chaos\"     (* 47 *)\n  assumes parallel_interchange: \"(c\\<^sub>0 \\<parallel> c\\<^sub>1) \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq> (c\\<^sub>0 \\<iinter> d\\<^sub>0) \\<parallel> (c\\<^sub>1 \\<iinter> d\\<^sub>1)\" (* 50 *)\nbegin"], ["", "lemma chaos_skip: \"chaos \\<sqsubseteq> skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "(* 46 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "have \"chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "by simp"], ["proof (state)\nthis:\n  chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)\n\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)", "have \"\\<dots> \\<sqsubseteq> (chaos \\<iinter> skip) \\<parallel> (skip \\<iinter> chaos)\""], ["proof (prove)\nusing this:\n  chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)\n\ngoal (1 subgoal):\n 1. (chaos \\<parallel> skip) \\<iinter>\n    (skip \\<parallel> chaos) \\<sqsubseteq>\n    chaos \\<iinter> skip \\<parallel> skip \\<iinter> chaos\nvariables:\n  chaos, skip :: 'a\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "using parallel_interchange"], ["proof (prove)\nusing this:\n  chaos = (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos)\n  ((?c\\<^sub>0::'a::refinement_lattice) \\<parallel>\n   (?c\\<^sub>1::'a::refinement_lattice)) \\<iinter>\n  ((?d\\<^sub>0::'a::refinement_lattice) \\<parallel>\n   (?d\\<^sub>1::'a::refinement_lattice)) \\<sqsubseteq>\n  ?c\\<^sub>0 \\<iinter> ?d\\<^sub>0 \\<parallel>\n  ?c\\<^sub>1 \\<iinter> ?d\\<^sub>1\n\ngoal (1 subgoal):\n 1. (chaos \\<parallel> skip) \\<iinter>\n    (skip \\<parallel> chaos) \\<sqsubseteq>\n    chaos \\<iinter> skip \\<parallel> skip \\<iinter> chaos\nvariables:\n  chaos, skip :: 'a\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by blast"], ["proof (state)\nthis:\n  (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos) \\<sqsubseteq>\n  chaos \\<iinter> skip \\<parallel> skip \\<iinter> chaos\n\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (chaos \\<parallel> skip) \\<iinter> (skip \\<parallel> chaos) \\<sqsubseteq>\n  chaos \\<iinter> skip \\<parallel> skip \\<iinter> chaos\n\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> skip\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "by auto"], ["proof (state)\nthis:\n  chaos \\<sqsubseteq> skip\n\ngoal:\nNo subgoals!\nvariables:\n  chaos, skip :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "lemma chaos_par_chaos_eq: \"chaos = chaos \\<parallel> chaos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos = chaos \\<parallel> chaos\nvariables:\n  (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  chaos :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis antisym chaos_par_chaos chaos_skip order_refl par_mono par_skip)"], ["", "lemma nonabort_par_top: \"chaos \\<sqsubseteq> c \\<Longrightarrow> c \\<parallel> \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> c \\<Longrightarrow> c \\<parallel> \\<top> = \\<top>\nvariables:\n  (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, chaos :: 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis chaos_par_top par_mono top.extremum_uniqueI)"], ["", "lemma skip_conj_top: \"skip \\<iinter> \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skip \\<iinter> \\<top> = \\<top>\nvariables:\n  skip :: 'a\n  (\\<iinter>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (simp add: chaos_skip conjoin_top)"], ["", "lemma conj_distrib2: \"c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow> c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq> (c \\<iinter> d\\<^sub>0) \\<parallel> (c \\<iinter> d\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow>\n    c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\ntype variables:\n  'a :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow>\n    c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\ntype variables:\n  'a :: refinement_lattice", "assume \"c \\<sqsubseteq> c \\<parallel> c\""], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<sqsubseteq> c \\<parallel> c\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow>\n    c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\ntype variables:\n  'a :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> c \\<parallel> c", "have \"c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq> (c \\<parallel> c) \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1)\""], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<sqsubseteq> c \\<parallel> c\n\ngoal (1 subgoal):\n 1. c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    (c \\<parallel> c) \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1)\nvariables:\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis conj_mono order.refl)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<iinter>\n  ((d\\<^sub>0::'a::refinement_lattice) \\<parallel>\n   (d\\<^sub>1::'a::refinement_lattice)) \\<sqsubseteq>\n  (c \\<parallel> c) \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1)\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c \\<parallel> c \\<Longrightarrow>\n    c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\ntype variables:\n  'a :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'a::refinement_lattice) \\<iinter>\n  ((d\\<^sub>0::'a::refinement_lattice) \\<parallel>\n   (d\\<^sub>1::'a::refinement_lattice)) \\<sqsubseteq>\n  (c \\<parallel> c) \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1)\n\ngoal (1 subgoal):\n 1. c \\<iinter> (d\\<^sub>0 \\<parallel> d\\<^sub>1) \\<sqsubseteq>\n    c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\nvariables:\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\ntype variables:\n  'a :: refinement_lattice", "by (metis parallel_interchange refine_trans)"], ["proof (state)\nthis:\n  (c::'a::refinement_lattice) \\<iinter>\n  ((d\\<^sub>0::'a::refinement_lattice) \\<parallel>\n   (d\\<^sub>1::'a::refinement_lattice)) \\<sqsubseteq>\n  c \\<iinter> d\\<^sub>0 \\<parallel> c \\<iinter> d\\<^sub>1\n\ngoal:\nNo subgoals!\nvariables:\n  (\\<iinter>), (\\<parallel>) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\n  c, d\\<^sub>0, d\\<^sub>1 :: 'a\ntype variables:\n  'a :: refinement_lattice", "qed"], ["", "end"], ["", "text \\<open>\n  Locale conjunction-sequential brings together the weak conjunction and\n  sequential operators.\n  It also introduces the interchange axiom for conjunction and sequential.\n\\<close>"], ["", "locale conjunction_sequential = conj_distrib + seq_distrib + (* iteration + *)\n  assumes chaos_seq_chaos: \"chaos \\<sqsubseteq> chaos;chaos\"\n  assumes sequential_interchange: \"(c\\<^sub>0;c\\<^sub>1) \\<iinter> (d\\<^sub>0;d\\<^sub>1) \\<sqsubseteq> (c\\<^sub>0 \\<iinter> d\\<^sub>0);(c\\<^sub>1 \\<iinter> d\\<^sub>1)\"  (* 51 *)\nbegin"], ["", "lemma chaos_nil: \"chaos \\<sqsubseteq> nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> nil\nvariables:\n  chaos, nil :: 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis conj_chaos local.conj_commute seq_nil_left seq_nil_right\n       sequential_interchange)"], ["", "lemma chaos_seq_absorb: \"chaos = chaos;chaos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos = chaos ; chaos\nvariables:\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  chaos :: 'b\ntype variables:\n  'b :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. chaos \\<sqsubseteq> chaos ; chaos\n 2. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  chaos :: 'b\ntype variables:\n  'b :: refinement_lattice", "show \"chaos \\<sqsubseteq> chaos;chaos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos \\<sqsubseteq> chaos ; chaos\nvariables:\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  chaos :: 'b\ntype variables:\n  'b :: refinement_lattice", "by (simp add: chaos_seq_chaos)"], ["proof (state)\nthis:\n  chaos \\<sqsubseteq> chaos ; chaos\n\ngoal (1 subgoal):\n 1. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  chaos :: 'b\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  chaos :: 'b\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "show \"chaos;chaos \\<sqsubseteq> chaos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  chaos :: 'b\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "using chaos_nil"], ["proof (prove)\nusing this:\n  chaos \\<sqsubseteq> nil\n\ngoal (1 subgoal):\n 1. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  chaos :: 'b\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "using seq_mono_left seq_nil_left"], ["proof (prove)\nusing this:\n  chaos \\<sqsubseteq> nil\n  (?c\\<^sub>0::'b::refinement_lattice) \\<sqsubseteq>\n  (?c\\<^sub>1::'b::refinement_lattice) \\<Longrightarrow>\n  ?c\\<^sub>0 ; (?d::'b::refinement_lattice) \\<sqsubseteq> ?c\\<^sub>1 ; ?d\n  nil ; (?a::'b::refinement_lattice) = ?a\n\ngoal (1 subgoal):\n 1. chaos ; chaos \\<sqsubseteq> chaos\nvariables:\n  chaos :: 'b\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by fastforce"], ["proof (state)\nthis:\n  chaos ; chaos \\<sqsubseteq> chaos\n\ngoal:\nNo subgoals!\nvariables:\n  (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  chaos :: 'b\ntype variables:\n  'b :: refinement_lattice", "qed"], ["", "lemma seq_bot_conj: \"c;\\<bottom> \\<iinter> d \\<sqsubseteq> (c \\<iinter> d);\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<iinter> d \\<sqsubseteq> (c \\<iinter> d) ; \\<bottom>\nvariables:\n  c, d :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis (no_types) conj_bot_left seq_nil_right sequential_interchange)"], ["", "lemma conj_seq_bot_right [simp]: \"c;\\<bottom> \\<iinter> c =  c;\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<iinter> c = c ; \\<bottom>\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. c ; \\<bottom> \\<iinter> c \\<sqsubseteq> c ; \\<bottom>\n 2. c ; \\<bottom> \\<sqsubseteq> c ; \\<bottom> \\<iinter> c\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "show lr: \"c;\\<bottom> \\<iinter> c \\<sqsubseteq>  c;\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<iinter> c \\<sqsubseteq> c ; \\<bottom>\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis seq_bot_conj conj_idem)"], ["proof (state)\nthis:\n  (c::'b::refinement_lattice) ; \\<bottom> \\<iinter> c \\<sqsubseteq>\n  c ; \\<bottom>\n\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<sqsubseteq> c ; \\<bottom> \\<iinter> c\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<sqsubseteq> c ; \\<bottom> \\<iinter> c\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "show rl: \"c;\\<bottom> \\<sqsubseteq> c;\\<bottom> \\<iinter> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ; \\<bottom> \\<sqsubseteq> c ; \\<bottom> \\<iinter> c\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis conj_idem conj_mono_right seq_bot_right)"], ["proof (state)\nthis:\n  (c::'b::refinement_lattice) ; \\<bottom> \\<sqsubseteq>\n  c ; \\<bottom> \\<iinter> c\n\ngoal:\nNo subgoals!\nvariables:\n  c :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "qed"], ["", "lemma conj_distrib3: \"c \\<sqsubseteq> c;c \\<Longrightarrow> c \\<iinter> (d\\<^sub>0 ; d\\<^sub>1) \\<sqsubseteq> (c \\<iinter> d\\<^sub>0);(c \\<iinter> d\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c ; c \\<Longrightarrow>\n    c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\nvariables:\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\ntype variables:\n  'b :: refinement_lattice", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c ; c \\<Longrightarrow>\n    c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\nvariables:\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\ntype variables:\n  'b :: refinement_lattice", "assume \"c \\<sqsubseteq> c;c\""], ["proof (state)\nthis:\n  (c::'b::refinement_lattice) \\<sqsubseteq> c ; c\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c ; c \\<Longrightarrow>\n    c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\nvariables:\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\ntype variables:\n  'b :: refinement_lattice", "then"], ["proof (chain)\npicking this:\n  (c::'b::refinement_lattice) \\<sqsubseteq> c ; c", "have \"c \\<iinter> (d\\<^sub>0;d\\<^sub>1) \\<sqsubseteq> (c;c) \\<iinter> (d\\<^sub>0;d\\<^sub>1)\""], ["proof (prove)\nusing this:\n  (c::'b::refinement_lattice) \\<sqsubseteq> c ; c\n\ngoal (1 subgoal):\n 1. c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    c ; c \\<iinter> d\\<^sub>0 ; d\\<^sub>1\nvariables:\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis conj_mono order.refl)"], ["proof (state)\nthis:\n  (c::'b::refinement_lattice) \\<iinter>\n  (d\\<^sub>0::'b::refinement_lattice) ;\n  (d\\<^sub>1::'b::refinement_lattice) \\<sqsubseteq>\n  c ; c \\<iinter> d\\<^sub>0 ; d\\<^sub>1\n\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c ; c \\<Longrightarrow>\n    c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\nvariables:\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\ntype variables:\n  'b :: refinement_lattice", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c::'b::refinement_lattice) \\<iinter>\n  (d\\<^sub>0::'b::refinement_lattice) ;\n  (d\\<^sub>1::'b::refinement_lattice) \\<sqsubseteq>\n  c ; c \\<iinter> d\\<^sub>0 ; d\\<^sub>1\n\ngoal (1 subgoal):\n 1. c \\<iinter> d\\<^sub>0 ; d\\<^sub>1 \\<sqsubseteq>\n    (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\nvariables:\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\ntype variables:\n  'b :: refinement_lattice", "by (metis sequential_interchange refine_trans)"], ["proof (state)\nthis:\n  (c::'b::refinement_lattice) \\<iinter>\n  (d\\<^sub>0::'b::refinement_lattice) ;\n  (d\\<^sub>1::'b::refinement_lattice) \\<sqsubseteq>\n  (c \\<iinter> d\\<^sub>0) ; (c \\<iinter> d\\<^sub>1)\n\ngoal:\nNo subgoals!\nvariables:\n  (\\<iinter>), (;) :: 'b \\<Rightarrow> 'b \\<Rightarrow> 'b\n  c, d\\<^sub>0, d\\<^sub>1 :: 'b\ntype variables:\n  'b :: refinement_lattice", "qed"], ["", "(*\nlemma iter_conj_distrib:\n  assumes nil: \"c \\<sqsubseteq> nil\"\n    and repeat: \"c \\<sqsubseteq> c ; c\"\n  shows \"c \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<omega>\"\nproof (unfold iter_def)\n  def F \\<equiv> \"(\\<lambda> x. c \\<iinter> x)\"\n  def G \\<equiv> \"(\\<lambda> x. nil \\<sqinter> d;x)\"\n  def H \\<equiv> \"(\\<lambda> x. nil \\<sqinter> ((c \\<iinter> d);x))\"\n\n  have FG: \"F \\<circ> G = (\\<lambda> x. c \\<iinter> (nil \\<sqinter> d;x))\"  by (metis comp_def F_def G_def) \n  have HF: \"H \\<circ> F = (\\<lambda> x. (nil \\<sqinter> (c \\<iinter> d);(c \\<iinter> x)))\" by (metis comp_def H_def F_def) \n\n  have \"F (lfp G) \\<sqsubseteq> lfp H\"\n  proof (rule fusion_lfp_leq)\n    show \"mono H\" by (simp add: H_def iter_step_mono)\n  next\n    show \"dist_over_sup F\" by (simp add: F_def conj_Sup_distrib)\n  next\n    fix x\n    have \"c \\<iinter> (nil \\<sqinter> d;x) = (c \\<iinter> nil) \\<sqinter> (c \\<iinter> d;x)\" by (metis inf_conj_distrib conj_commute)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c \\<iinter> d;x)\" by (metis conjunction_sup inf_mono_left le_iff_sup nil)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c;c \\<iinter> d;x)\" by (metis inf_conj_distrib inf.absorb_iff2 inf_mono_right repeat)\n    also have \"... \\<sqsubseteq> nil \\<sqinter> (c \\<iinter> d);(c \\<iinter> x)\" by (meson inf_mono_right sequential_interchange)\n    finally show \"(F \\<circ> G) x \\<sqsubseteq> (H \\<circ> F) x\" by (simp add: FG HF)\n  qed\n\n  then show \"c \\<iinter> lfp(\\<lambda>x. nil \\<sqinter> d ; x) \\<sqsubseteq> lfp (\\<lambda>x. nil \\<sqinter> (c \\<iinter> d) ; x)\" using F_def G_def H_def by simp\nqed\n\nlemma iter_conj_distrib1: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c\\<^sup>\\<omega> \\<iinter> d)\\<^sup>\\<omega>\"\n  by (simp add: iter0 iter_conj_distrib)\n\nlemma iter_conj_distrib2: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c \\<iinter> d)\\<^sup>\\<omega>\"\nproof -\n  have a: \"c\\<^sup>\\<omega> \\<sqsubseteq> c\" by (metis iter1)\n  have b: \"c\\<^sup>\\<omega> \\<iinter> d\\<^sup>\\<omega> \\<sqsubseteq> (c\\<^sup>\\<omega> \\<iinter> d)\\<^sup>\\<omega>\" by (metis iter_conj_distrib1)\n  have \"c\\<^sup>\\<omega> \\<iinter> d \\<sqsubseteq> c \\<iinter> d\" by (metis a conj_mono order.refl) \n  thus ?thesis using a b by (metis refine_trans iter_mono) \nqed\n*)"], ["", "end"], ["", "text \\<open>\n  Locale cra brings together sequential, parallel and weak conjunction.\n\\<close>"], ["", "locale cra = sequential_parallel + conjunction_parallel + conjunction_sequential"], ["", "end"]]}