{"file_name": "/home/qj213/afp-2021-10-22/thys/Skip_Lists/Skip_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Skip_Lists", "problem_names": ["lemma bind_pmf_if': \"(do {c \\<leftarrow> C;\n                         ab \\<leftarrow> (if c then A else B);\n                         D ab}::'a pmf) =\n                     do {c \\<leftarrow> C;\n                         (if c then (A \\<bind> D) else (B \\<bind> D))}\"", "lemma\n  assumes \"finite A\"\n  shows \"H A = H\\<^sub>N (card A)\"", "lemma prob_Max_IID_geometric_atMost:\n  assumes \"p \\<in> {0..1}\"\n  shows \"measure_pmf.prob (H\\<^sub>N n) {..i}\n       = (measure_pmf.prob (geometric_pmf p) {..i}) ^ n\" (is \"?lhs = ?rhs\")", "lemma prob_Max_IID_geometric_greaterThan:\n  assumes \"p \\<in> {0<..1}\"\n  shows \"measure_pmf.prob (H\\<^sub>N n) {i<..} =\n         1 - (1 - q ^ (i + 1)) ^ n\"", "lemma expectation_prob_atLeast:\n  assumes \"(\\<lambda>i. measure_pmf.prob N {i..}) abs_summable_on {1..}\"\n  shows \"measure_pmf.expectation N real = infsetsum (\\<lambda>i. measure_pmf.prob N {i..}) {1..}\"\n    \"integrable N real\"", "lemma infsetsum_set_nn_integral_reals:\n  assumes \"f abs_summable_on UNIV\" \"\\<And>n. f n \\<ge> 0\"\n  shows \"infsetsum f UNIV = set_nn_integral lborel {0::real..} (\\<lambda>x. f (nat (floor x)))\"", "lemma nn_integral_nats_reals:\n  shows \"(\\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV) = \\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel\"", "lemma nn_integral_floor_less_eq:\n  assumes \"\\<And>x y. x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"\\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f x)\\<partial>lborel \\<le> \\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel\"", "lemma nn_integral_finite_imp_abs_sumable_on:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  assumes \"nn_integral (count_space A) (\\<lambda>x. norm (f x)) < \\<infinity>\"\n  shows   \"f abs_summable_on A\"", "lemma nn_integral_finite_imp_abs_sumable_on':\n  assumes \"nn_integral (count_space A) (\\<lambda>x. ennreal (f x)) < \\<infinity>\" \"\\<And>x. f x \\<ge> 0\"\n  shows   \"f abs_summable_on A\"", "lemma harm_integral_x_raised_n:\n  \"set_integrable lborel {0::real..1} (\\<lambda>x. (\\<Sum>i\\<in>{..<n}. x ^ i))\" (is ?thesis1)\n  \"LBINT x = 0..1. (\\<Sum>i\\<in>{..<n}. x ^ i) = harm n\" (is ?thesis2)", "lemma harm_integral_0_1_fraction:\n  \"set_integrable lborel {0::real..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\"\n  \"(LBINT x = 0..1. ((1 - x ^ n) / (1 - x))) = harm n\"", "lemma one_minus_one_minus_q_x_n_integral:\n  assumes \"q \\<in> {0<..<1}\"\n  shows \"set_integrable lborel (einterval 0 \\<infinity>) (\\<lambda>x. (1 - (1 - q powr x) ^ n))\"\n        \"(LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n) = - harm n / ln q\"", "lemma one_minus_one_minus_q_x_n_nn_integral:\n  fixes q::real\n  assumes \"q \\<in> {0<..<1}\"\n  shows \"set_nn_integral lborel {0..} (\\<lambda>x. (1 - (1 - q powr x) ^ n)) =\n        LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n\"", "lemma EH\\<^sub>N_bounds':\n  fixes n::nat\n  assumes \"p \\<in> {0<..<1}\" \"0 < n\"\n  shows \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\"\n     \"EH\\<^sub>N n \\<le> - harm n / ln q\"\n     \"integrable (H\\<^sub>N n) real\"", "theorem EH\\<^sub>N_bounds:\n  fixes n::nat\n  assumes \"p \\<in> {0<..<1}\"\n  shows\n    \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\"\n    \"EH\\<^sub>N n \\<le> - harm n / ln q\"\n    \"integrable (H\\<^sub>N n) real\"", "lemma steps_empty [simp]: \"steps {} f l up left = 0\"", "lemma steps_lsteps: \"steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\"", "lemma lsteps_comp_map: \"lsteps zs (f \\<circ> g) l u v = lsteps (map g zs) f l u v\"", "lemma steps_image:\n  assumes \"finite A\" \"mono_on g A\" \"inj_on g A\"\n  shows \"steps A (f \\<circ> g) l u v = steps (g ` A) f l u v\"", "lemma lsteps_cong:\n  assumes \"ys = xs\" \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x\" \"l = l'\"\n  shows \"lsteps xs f l u v = lsteps ys g l' u v\"", "lemma steps_cong:\n  assumes \"A = B\" \"\\<And>x. x \\<in> A \\<Longrightarrow> f x = g x\" \"l = l'\"\n  shows   \"steps A f l u v = steps B g l' u v\"", "lemma lsteps_f_add':\n  shows \"lsteps xs f l u v = lsteps xs (\\<lambda>x. f x + m) (l + m) u v\"", "lemma steps_f_add':\n  shows \"steps A f l u v = steps A (\\<lambda>x. f x + m) (l + m) u v\"", "lemma lsteps_smaller_set:\n  assumes \"m \\<le> l\"\n  shows \"lsteps xs f l u v = lsteps [x \\<leftarrow> xs. m \\<le> f x] f l u v\"", "lemma steps_smaller_set:\n  assumes \"finite A\" \"m \\<le> l\"\n  shows \"steps A f l u v = steps {x\\<in>A. f x \\<ge> m} f l u v\"", "lemma lsteps_level_greater_fun_image:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x < l\"\n  shows   \"lsteps xs f l u v = 0\"", "lemma lsteps_smaller_card_Max_fun':\n  assumes \"\\<exists>x \\<in> set xs. l \\<le> f x\"\n  shows   \"lsteps xs f l u v + l * u \\<le> v * length xs + u * Max ((f ` (set xs)) \\<union> {0})\"", "lemma steps_smaller_card_Max_fun':\n  assumes \"finite A\" \"\\<exists>x\\<in>A. l \\<le> f x\"\n  shows   \"steps A f l up left + l * up \\<le> left * card A + up * Max\\<^sub>0 (f ` A)\"", "lemma lsteps_height:\n  assumes  \"\\<exists>x \\<in> set xs. l \\<le> f x\"\n  shows \"lsteps xs f l up 0 + up * l = up * Max\\<^sub>0 (f ` (set xs))\"", "lemma steps_height:\n  assumes \"finite A\"\n  shows   \"steps A f 0 up 0 = up * Max\\<^sub>0 (f ` A)\"", "lemma R\\<^sub>N_alt_def: \"R\\<^sub>N n u l = map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)\"", "lemma R_R\\<^sub>N:\n  assumes \"finite A\" \"p \\<in> {0..1}\"\n  shows \"R A u l = R\\<^sub>N (card A) u l\"", "lemma R\\<^sub>N_recurrence:\n  assumes \"0 < n\" \"p \\<in> {0<..1}\"\n  shows   \"R\\<^sub>N n u l =\n             do {\n               b \\<leftarrow> bernoulli_pmf p;\n               if b then               \\<comment> \\<open>leftwards\\<close>\n                 map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n               else do {               \\<comment> \\<open>upwards\\<close>\n                 m \\<leftarrow> binomial_pmf (n - 1) (1 - p);\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)\n               }\n             }\"", "lemma NH\\<^sub>N_EH\\<^sub>N:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"NH\\<^sub>N n = EH\\<^sub>N n\"", "lemma R\\<^sub>N_0 [simp]: \"R\\<^sub>N 0 u l = return_pmf 0\"", "lemma NR\\<^sub>N_bounds:\n  fixes u l::nat\n  shows \"NR\\<^sub>N n u l \\<le> l * n + u * NH\\<^sub>N n\"", "lemma NR\\<^sub>N_recurrence:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u l = (p * (l + NR\\<^sub>N (n - 1) u l) +\n                     q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (pmf (binomial_pmf (n - 1) q) k))))\n                     / (1 - (q ^ n))\"", "lemma NR\\<^sub>n_NH\\<^sub>N: \"NR\\<^sub>N n u 0 = u * NH\\<^sub>N n\"", "lemma NR\\<^sub>N_recurrence':\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u l = (p * l + p * NR\\<^sub>N (n - 1) u l +\n                     q * u + q * (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (pmf (binomial_pmf (n - 1) q) k)))\n                     / (1 - (q ^ n))\"", "lemma NR\\<^sub>N_l_0:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u 0 = (p * NR\\<^sub>N (n - 1) u 0 +\n                     q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u 0 * (pmf (binomial_pmf (n - 1) q) k))))\n                     / (1 - (q ^ n))\"", "lemma NR\\<^sub>N_u_0:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n 0 l = (p * (l + NR\\<^sub>N (n - 1) 0 l) +\n                     q * (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) 0 l * (pmf (binomial_pmf (n - 1) q) k)))\n                     / (1 - (q ^ n))\"", "lemma NR\\<^sub>N_0[simp]: \"NR\\<^sub>N 0 u l = 0\"", "lemma NR\\<^sub>N_1:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N 1 u l = (u * q + l * p) / p\"", "lemma NR\\<^sub>N_NR\\<^sub>N_l_0:\n  assumes n: \"0 < n\" and p: \"p \\<in> {0<..<1}\" and \"u \\<ge> 1\"\n  shows \"NR\\<^sub>N n u 0 = (u * q / (u * q + l * p)) * NR\\<^sub>N n u l\"", "theorem EH\\<^sub>N_EL\\<^sub>s\\<^sub>p:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"1 / q * EH\\<^sub>N n = EL\\<^sub>N n\""], "translations": [["", "lemma bind_pmf_if': \"(do {c \\<leftarrow> C;\n                         ab \\<leftarrow> (if c then A else B);\n                         D ab}::'a pmf) =\n                     do {c \\<leftarrow> C;\n                         (if c then (A \\<bind> D) else (B \\<bind> D))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<bind> (\\<lambda>c. (if c then A else B) \\<bind> D) =\n    C \\<bind> (\\<lambda>c. if c then A \\<bind> D else B \\<bind> D)", "by (metis (mono_tags, lifting))"], ["", "abbreviation (input) Max\\<^sub>0 where \"Max\\<^sub>0 \\<equiv> (\\<lambda>A. Max (A \\<union> {0}))\""], ["", "subsection \\<open>Definition of a Randomised Skip List\\<close>"], ["", "text \\<open>\n  Given a set A we assign a geometric random variable (counting the number of failed Bernoulli\n  trials before the first success) to every element in A. That means an arbitrary element of A is\n  on level n with probability $(1-p)^{n}p$. We define he height of the skip list as the maximum\n  assigned level. So a skip list with only one level has height 0 but the calculation of the\n  expected height is cleaner this way.\n\\<close>"], ["", "locale random_skip_list =\n  fixes p::real\nbegin"], ["", "definition q where \"q = 1 - p\""], ["", "definition SL :: \"('a::linorder) set \\<Rightarrow> ('a \\<Rightarrow> nat) pmf\" where \"SL A = Pi_pmf A 0 (\\<lambda>_. geometric_pmf p)\""], ["", "definition SL\\<^sub>N :: \"nat \\<Rightarrow> (nat \\<Rightarrow> nat) pmf\" where \"SL\\<^sub>N n = SL {..<n}\""], ["", "subsection \\<open>Height of Skip List\\<close>"], ["", "definition H where \"H A = map_pmf (\\<lambda>f. Max\\<^sub>0 (f ` A)) (SL A)\""], ["", "definition H\\<^sub>N :: \"nat \\<Rightarrow> nat pmf\" where \"H\\<^sub>N n = H {..<n}\""], ["", "context includes monad_normalisation\nbegin"], ["", "text \\<open>\n  The height of a skip list is independent of the values in a set A. For simplicity we can\n  therefore work on the skip list over the set @{term \"{..< card A}\"}\n\\<close>"], ["", "lemma\n  assumes \"finite A\"\n  shows \"H A = H\\<^sub>N (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "define f' where \"f' = (\\<lambda>x. if x \\<in> A\n                             then the_inv_into {..<card A} ((!) (sorted_list_of_set A)) x\n                             else card A)\""], ["proof (state)\nthis:\n  f' =\n  (\\<lambda>x.\n      if x \\<in> A\n      then the_inv_into {..<card A} ((!) (sorted_list_of_set A)) x\n      else card A)\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "have bij_f': \"bij_betw f' A {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "(* I know the proof looks weird, but for some reason all tools have problems with this proof *)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "have \"bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n     {..<card A}", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n     {..<card A}", "using sorted_list_of_set_bij_betw assms bij_betw_the_inv_into"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow>\n  bij_betw ((!) (sorted_list_of_set ?A)) {..<card ?A} ?A\n  finite A\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (the_inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n     {..<card A}", "by blast"], ["proof (state)\nthis:\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A}\n\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "moreover"], ["proof (state)\nthis:\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A}\n\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "have \"bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A {..<card A}\n                     = bij_betw f' A {..<card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n     {..<card A} =\n    bij_betw f' A {..<card A}", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n     {..<card A} =\n    bij_betw\n     (\\<lambda>x.\n         if x \\<in> A\n         then the_inv_into {..<card A} ((!) (sorted_list_of_set A)) x\n         else card A)\n     A {..<card A}", "by (rule bij_betw_cong) simp"], ["proof (state)\nthis:\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A} =\n  bij_betw f' A {..<card A}\n\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A}\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A} =\n  bij_betw f' A {..<card A}", "show ?thesis"], ["proof (prove)\nusing this:\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A}\n  bij_betw (the_inv_into {..<card A} ((!) (sorted_list_of_set A))) A\n   {..<card A} =\n  bij_betw f' A {..<card A}\n\ngoal (1 subgoal):\n 1. bij_betw f' A {..<card A}", "by blast"], ["proof (state)\nthis:\n  bij_betw f' A {..<card A}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw f' A {..<card A}\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "have *: \"Max\\<^sub>0 ((f \\<circ> f') ` A) = Max\\<^sub>0 (f ` {..<card A})\" for f :: \"nat \\<Rightarrow> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max ((f \\<circ> f') ` A \\<union> {0}) =\n    Max (f ` {..<card A} \\<union> {0})", "using  bij_betw_imp_surj_on bij_f' image_comp"], ["proof (prove)\nusing this:\n  bij_betw ?f ?A ?B \\<Longrightarrow> ?f ` ?A = ?B\n  bij_betw f' A {..<card A}\n  ?f ` ?g ` ?r = (?f \\<circ> ?g) ` ?r\n\ngoal (1 subgoal):\n 1. Max ((f \\<circ> f') ` A \\<union> {0}) =\n    Max (f ` {..<card A} \\<union> {0})", "by metis"], ["proof (state)\nthis:\n  Max ((?f2 \\<circ> f') ` A \\<union> {0}) =\n  Max (?f2 ` {..<card A} \\<union> {0})\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "have \"H A = map_pmf (\\<lambda>f. Max\\<^sub>0 (f ` A)) (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H A =\n    map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A)))", "using assms bij_f'"], ["proof (prove)\nusing this:\n  finite A\n  bij_betw f' A {..<card A}\n\ngoal (1 subgoal):\n 1. H A =\n    map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A)))", "unfolding H_def SL_def SL\\<^sub>N_def"], ["proof (prove)\nusing this:\n  finite A\n  bij_betw f' A {..<card A}\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (Pi_pmf A 0 (\\<lambda>_. geometric_pmf p)) =\n    map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f')\n       (Pi_pmf {..<card A} 0 (\\<lambda>_. geometric_pmf p)))", "by (subst Pi_pmf_bij_betw[of _ f' \"{..<card A}\"]) (auto simp add: f'_def)"], ["proof (state)\nthis:\n  H A =\n  map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n   (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A)))\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "also"], ["proof (state)\nthis:\n  H A =\n  map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n   (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A)))\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "have \"\\<dots> =  H\\<^sub>N (card A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A))) =\n    H\\<^sub>N (card A)", "unfolding H\\<^sub>N_def H_def SL\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f') (SL {..<card A})) =\n    map_pmf (\\<lambda>f. Max (f ` {..<card A} \\<union> {0}))\n     (SL {..<card A})", "using *"], ["proof (prove)\nusing this:\n  Max ((?f2 \\<circ> f') ` A \\<union> {0}) =\n  Max (?f2 ` {..<card A} \\<union> {0})\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n     (map_pmf (\\<lambda>g. g \\<circ> f') (SL {..<card A})) =\n    map_pmf (\\<lambda>f. Max (f ` {..<card A} \\<union> {0}))\n     (SL {..<card A})", "by (auto intro!: bind_pmf_cong simp add: map_pmf_def)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. Max (f ` A \\<union> {0}))\n   (map_pmf (\\<lambda>g. g \\<circ> f') (SL\\<^sub>N (card A))) =\n  H\\<^sub>N (card A)\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "finally"], ["proof (chain)\npicking this:\n  H A = H\\<^sub>N (card A)", "show ?thesis"], ["proof (prove)\nusing this:\n  H A = H\\<^sub>N (card A)\n\ngoal (1 subgoal):\n 1. H A = H\\<^sub>N (card A)", "by simp"], ["proof (state)\nthis:\n  H A = H\\<^sub>N (card A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The cumulative distribution function (CDF) of the height is the CDF of the geometric PMF to the\n  power of n\n\\<close>"], ["", "lemma prob_Max_IID_geometric_atMost:\n  assumes \"p \\<in> {0..1}\"\n  shows \"measure_pmf.prob (H\\<^sub>N n) {..i}\n       = (measure_pmf.prob (geometric_pmf p) {..i}) ^ n\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "note SL_def[simp] SL\\<^sub>N_def[simp] H_def[simp] H\\<^sub>N_def[simp]"], ["proof (state)\nthis:\n  SL ?A = Pi_pmf ?A 0 (\\<lambda>_. geometric_pmf p)\n  SL\\<^sub>N ?n = SL {..<?n}\n  H ?A = map_pmf (\\<lambda>f. Max (f ` ?A \\<union> {0})) (SL ?A)\n  H\\<^sub>N ?n = H {..<?n}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "have \"{f. Max\\<^sub>0 (f ` {..<n}) \\<le> i}  = {..<n} \\<rightarrow> {..i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. Max (f ` {..<n} \\<union> {0}) \\<le> i} = {..<n} \\<rightarrow> {..i}", "by auto"], ["proof (state)\nthis:\n  {f. Max (f ` {..<n} \\<union> {0}) \\<le> i} = {..<n} \\<rightarrow> {..i}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "then"], ["proof (chain)\npicking this:\n  {f. Max (f ` {..<n} \\<union> {0}) \\<le> i} = {..<n} \\<rightarrow> {..i}", "have \"?lhs = measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i})\""], ["proof (prove)\nusing this:\n  {f. Max (f ` {..<n} \\<union> {0}) \\<le> i} = {..<n} \\<rightarrow> {..i}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i})", "by (simp add: vimage_def)"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {..i} =\n  measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i})\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {..i} =\n  measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i})\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "have \"\\<dots> = measure_pmf.prob (SL\\<^sub>N n) (PiE_dflt {..<n} 0 (\\<lambda>_. {..i}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i}) =\n    measure_pmf.prob (SL\\<^sub>N n) (PiE_dflt {..<n} 0 (\\<lambda>_. {..i}))", "by (intro measure_prob_cong_0) (auto simp add: PiE_dflt_def pmf_Pi split: if_splits)"], ["proof (state)\nthis:\n  measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i}) =\n  measure_pmf.prob (SL\\<^sub>N n) (PiE_dflt {..<n} 0 (\\<lambda>_. {..i}))\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (SL\\<^sub>N n) ({..<n} \\<rightarrow> {..i}) =\n  measure_pmf.prob (SL\\<^sub>N n) (PiE_dflt {..<n} 0 (\\<lambda>_. {..i}))\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "have \"\\<dots> = measure_pmf.prob (geometric_pmf p) {..i} ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (SL\\<^sub>N n)\n     (PiE_dflt {..<n} 0 (\\<lambda>_. {..i})) =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (SL\\<^sub>N n)\n     (PiE_dflt {..<n} 0 (\\<lambda>_. {..i})) =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "by (auto simp add: measure_Pi_pmf_PiE_dflt)"], ["proof (state)\nthis:\n  measure_pmf.prob (SL\\<^sub>N n) (PiE_dflt {..<n} 0 (\\<lambda>_. {..i})) =\n  measure_pmf.prob (geometric_pmf p) {..i} ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob (H\\<^sub>N n) {..i} =\n  measure_pmf.prob (geometric_pmf p) {..i} ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.prob (H\\<^sub>N n) {..i} =\n  measure_pmf.prob (geometric_pmf p) {..i} ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {..i} =\n    measure_pmf.prob (geometric_pmf p) {..i} ^ n", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {..i} =\n  measure_pmf.prob (geometric_pmf p) {..i} ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prob_Max_IID_geometric_greaterThan:\n  assumes \"p \\<in> {0<..1}\"\n  shows \"measure_pmf.prob (H\\<^sub>N n) {i<..} =\n         1 - (1 - q ^ (i + 1)) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "have \"UNIV - {..i} = {i<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - {..i} = {i<..}", "by auto"], ["proof (state)\nthis:\n  UNIV - {..i} = {i<..}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "then"], ["proof (chain)\npicking this:\n  UNIV - {..i} = {i<..}", "have \"measure_pmf.prob (H\\<^sub>N n) {i<..} = measure_pmf.prob (H\\<^sub>N n) (space (measure_pmf (H\\<^sub>N n)) - {..i})\""], ["proof (prove)\nusing this:\n  UNIV - {..i} = {i<..}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} =\n    measure_pmf.prob (H\\<^sub>N n)\n     (space (measure_pmf (H\\<^sub>N n)) - {..i})", "by (auto)"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {i<..} =\n  measure_pmf.prob (H\\<^sub>N n) (space (measure_pmf (H\\<^sub>N n)) - {..i})\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {i<..} =\n  measure_pmf.prob (H\\<^sub>N n) (space (measure_pmf (H\\<^sub>N n)) - {..i})\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "have \"\\<dots> = 1 - (measure_pmf.prob (geometric_pmf p) {..i}) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n)\n     (space (measure_pmf (H\\<^sub>N n)) - {..i}) =\n    1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n)\n     (space (measure_pmf (H\\<^sub>N n)) - {..i}) =\n    1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n", "by (subst measure_pmf.prob_compl) (auto simp add: prob_Max_IID_geometric_atMost)"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n)\n   (space (measure_pmf (H\\<^sub>N n)) - {..i}) =\n  1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n)\n   (space (measure_pmf (H\\<^sub>N n)) - {..i}) =\n  1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "have \"\\<dots> =   1 - (1 - q ^ (i + 1)) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n =\n    1 - (1 - q ^ (i + 1)) ^ n", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n =\n    1 - (1 - q ^ (i + 1)) ^ n", "unfolding q_def"], ["proof (prove)\nusing this:\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. 1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n =\n    1 - (1 - (1 - p) ^ (i + 1)) ^ n", "by (subst geometric_pmf_prob_atMost) auto"], ["proof (state)\nthis:\n  1 - measure_pmf.prob (geometric_pmf p) {..i} ^ n =\n  1 - (1 - q ^ (i + 1)) ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (H\\<^sub>N n) {i<..} = 1 - (1 - q ^ (i + 1)) ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context includes monad_normalisation *)"], ["", "end"], ["", "(* locale skip_list *)"], ["", "text \\<open>\n  An alternative definition of the expected value of a non-negative random variable\n  \\footnote{\\url{https://en.wikipedia.org/w/index.php?title=Expected\\_value&oldid=881384346\\#Formula\\_for\\_non-negative\\_random\\_variables}}\n\\<close>"], ["", "lemma expectation_prob_atLeast:\n  assumes \"(\\<lambda>i. measure_pmf.prob N {i..}) abs_summable_on {1..}\"\n  shows \"measure_pmf.expectation N real = infsetsum (\\<lambda>i. measure_pmf.prob N {i..}) {1..}\"\n    \"integrable N real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..}) &&&\n    integrable (measure_pmf N) real", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"(\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>i. measure_pmf.prob N {i..}) abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast", "by (auto simp add: measure_pmf_conv_infsetsum abs_summable_on_Sigma_iff)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast", "have summable: \"(\\<lambda>(x, y). pmf N x) abs_summable_on Sigma {Suc 0..} (atLeastAtMost (Suc 0))\""], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). pmf N y) abs_summable_on Sigma {Suc 0..} atLeast\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). pmf N x) abs_summable_on\n    Sigma {Suc 0..} (atLeastAtMost (Suc 0))", "by (subst abs_summable_on_reindex_bij_betw[of \"\\<lambda>(x,y). (y,x)\", symmetric])\n      (auto intro!: bij_betw_imageI simp add: inj_on_def case_prod_beta)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). pmf N x) abs_summable_on\n  Sigma {Suc 0..} (atLeastAtMost (Suc 0))\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"measure_pmf.expectation N real = (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x)", "by (auto simp add: infsetsum_def integral_density measure_pmf_eq_density)"], ["proof (state)\nthis:\n  measure_pmf.expectation N real =\n  (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation N real =\n  (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"\\<dots> = (\\<Sum>\\<^sub>ax \\<in> ({0} \\<union> {Suc 0..}). pmf N x *\\<^sub>R real x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x) =\n    (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x)", "by (auto intro!: infsetsum_cong)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x) =\n  (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax. pmf N x *\\<^sub>R real x) =\n  (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"\\<dots> = (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n    (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n    (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)", "have \"(\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on {0} \\<union> {Suc 0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n    {0} \\<union> {Suc 0..}", "using summable"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). pmf N x) abs_summable_on\n  Sigma {Suc 0..} (atLeastAtMost (Suc 0))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n    {0} \\<union> {Suc 0..}", "by (subst (asm) abs_summable_on_Sigma_iff) (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n    (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n    (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)", "by (subst infsetsum_Un_Int) auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n  (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n  (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>{0} \\<union> {Suc 0..}. pmf N x *\\<^sub>R real x) =\n  (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"\\<dots> = (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)). pmf N x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x) =\n    (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n       pmf N x)", "using summable"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). pmf N x) abs_summable_on\n  Sigma {Suc 0..} (atLeastAtMost (Suc 0))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x) =\n    (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n       pmf N x)", "by (subst infsetsum_Sigma) (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x) =\n  (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n     pmf N x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. pmf N x * real x) =\n  (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n     pmf N x)\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"\\<dots> = (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n       pmf N x) =\n    (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x))", "by (subst infsetsum_reindex_bij_betw[of \"\\<lambda>(x,y). (y,x)\", symmetric])\n      (auto intro!: bij_betw_imageI simp add: inj_on_def case_prod_beta)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n     pmf N x) =\n  (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x))\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>a(x, y)\\<in>Sigma {Suc 0..} (atLeastAtMost (Suc 0)).\n     pmf N x) =\n  (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x))\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "have \"\\<dots> = infsetsum (\\<lambda>i. measure_pmf.prob N {i..}) {1..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x)) =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>i. measure_pmf.prob N {i..}) abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x)) =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})", "by (subst infsetsum_Sigma)\n      (auto simp add: measure_pmf_conv_infsetsum abs_summable_on_Sigma_iff infsetsum_Sigma')"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ax\\<in>Sigma {Suc 0..} atLeast. pmf N (snd x)) =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n\ngoal (2 subgoals):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n 2. integrable (measure_pmf N) real", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.expectation N real =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})", "show \"measure_pmf.expectation N real = infsetsum (\\<lambda>i. measure_pmf.prob N {i..}) {1..}\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation N real =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation N real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})", "by simp"], ["proof (state)\nthis:\n  measure_pmf.expectation N real =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob N {i..})\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf N) real", "have \"(\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on {0} \\<union> {Suc 0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n    {0} \\<union> {Suc 0..}", "using summable"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). pmf N x) abs_summable_on\n  Sigma {Suc 0..} (atLeastAtMost (Suc 0))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n    {0} \\<union> {Suc 0..}", "by (subst (asm) abs_summable_on_Sigma_iff) (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf N) real", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}", "have \"(\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on\n  {0} \\<union> {Suc 0..}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on UNIV", "by (simp add: atLeast_Suc)"], ["proof (state)\nthis:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf N) real", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on UNIV", "have \"integrable (count_space UNIV) (\\<lambda>x. pmf N x *\\<^sub>R real x)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. pmf N x *\\<^sub>R real x) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. integrable (count_space UNIV) (\\<lambda>x. pmf N x *\\<^sub>R real x)", "by (subst abs_summable_on_def[symmetric]) blast"], ["proof (state)\nthis:\n  integrable (count_space UNIV) (\\<lambda>x. pmf N x *\\<^sub>R real x)\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf N) real", "then"], ["proof (chain)\npicking this:\n  integrable (count_space UNIV) (\\<lambda>x. pmf N x *\\<^sub>R real x)", "show \"integrable N real\""], ["proof (prove)\nusing this:\n  integrable (count_space UNIV) (\\<lambda>x. pmf N x *\\<^sub>R real x)\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf N) real", "by (subst measure_pmf_eq_density, subst integrable_density) auto"], ["proof (state)\nthis:\n  integrable (measure_pmf N) real\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The expected height of a skip list has no closed-form expression but we can approximate it. We\n  start by showing how we can calculate an infinite sum over the natural numbers with an integral\n  over the positive reals and the floor function.\n\\<close>"], ["", "lemma infsetsum_set_nn_integral_reals:\n  assumes \"f abs_summable_on UNIV\" \"\\<And>n. f n \\<ge> 0\"\n  shows \"infsetsum f UNIV = set_nn_integral lborel {0::real..} (\\<lambda>x. f (nat (floor x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"x < 1 + (floor x)\"for x::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < real_of_int (1 + \\<lfloor>x\\<rfloor>)", "by linarith"], ["proof (state)\nthis:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)", "have \"\\<exists>n. real n \\<le> x \\<and> x < 1 + real n\" if \"x \\<ge> 0\" for x"], ["proof (prove)\nusing this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>n. real n \\<le> x \\<and> x < 1 + real n", "using that of_nat_floor"], ["proof (prove)\nusing this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n  0 \\<le> x\n  (0::?'a) \\<le> ?r \\<Longrightarrow>\n  of_nat (nat \\<lfloor>?r\\<rfloor>) \\<le> ?r\n\ngoal (1 subgoal):\n 1. \\<exists>n. real n \\<le> x \\<and> x < 1 + real n", "by (intro exI[of _ \"nat (floor x)\"]) auto"], ["proof (state)\nthis:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n", "have \"{0..} = (\\<Union>n. {real n..<real (Suc n)})\""], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n\n\ngoal (1 subgoal):\n 1. {0..} = (\\<Union>n. {real n..<real (Suc n)})", "by auto"], ["proof (state)\nthis:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})", "have \"\\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel =\n             (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel)\""], ["proof (prove)\nusing this:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                           ennreal (f (nat \\<lfloor>x\\<rfloor>))\n        \\<partial>lborel)", "by (auto simp add: disjoint_family_on_def nn_integral_disjoint_family)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                           ennreal (f (nat \\<lfloor>x\\<rfloor>))\n        \\<partial>lborel) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n        \\<partial>lborel)", "by(subst suminf_cong, rule nn_integral_cong_AE)\n      (auto intro!: eventuallyI  simp add: indicator_def floor_eq4)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = (\\<Sum>n. ennreal (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n        \\<partial>lborel) =\n    (\\<Sum>n. ennreal (f n))", "by (auto intro!: suminf_cong simp add: nn_integral_cmult)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel) =\n  (\\<Sum>n. ennreal (f n))\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel) =\n  (\\<Sum>n. ennreal (f n))\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = infsetsum f {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f n)) = ennreal (infsetsum f {0..})", "using assms suminf_ennreal2 abs_summable_on_nat_iff' summable_norm_cancel"], ["proof (prove)\nusing this:\n  f abs_summable_on UNIV\n  0 \\<le> f ?n\n  \\<lbrakk>\\<And>i. 0 \\<le> ?f i; summable ?f\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i. ennreal (?f i)) = ennreal (\\<Sum>i. ?f i)\n  (?f abs_summable_on UNIV) = summable (\\<lambda>n. norm (?f n))\n  summable (\\<lambda>n. norm (?f n)) \\<Longrightarrow> summable ?f\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f n)) = ennreal (infsetsum f {0..})", "by (auto simp add: infsetsum_nat)"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f n)) = ennreal (infsetsum f {0..})\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  ennreal (infsetsum f {0..})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  ennreal (infsetsum f {0..})\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "by simp"], ["proof (state)\nthis:\n  ennreal (infsetsum f UNIV) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nn_integral_nats_reals:\n  shows \"(\\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV) = \\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"x < 1 + (floor x)\"for x::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < real_of_int (1 + \\<lfloor>x\\<rfloor>)", "by linarith"], ["proof (state)\nthis:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)", "have \"\\<exists>n. real n \\<le> x \\<and> x < 1 + real n\" if \"x \\<ge> 0\" for x"], ["proof (prove)\nusing this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>n. real n \\<le> x \\<and> x < 1 + real n", "using that of_nat_floor"], ["proof (prove)\nusing this:\n  ?x < real_of_int (1 + \\<lfloor>?x\\<rfloor>)\n  0 \\<le> x\n  (0::?'a) \\<le> ?r \\<Longrightarrow>\n  of_nat (nat \\<lfloor>?r\\<rfloor>) \\<le> ?r\n\ngoal (1 subgoal):\n 1. \\<exists>n. real n \\<le> x \\<and> x < 1 + real n", "by (intro exI[of _ \"nat (floor x)\"]) auto"], ["proof (state)\nthis:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n", "have \"{0..} = (\\<Union>n. {real n..<real (Suc n)})\""], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<Longrightarrow>\n  \\<exists>n. real n \\<le> ?x \\<and> ?x < 1 + real n\n\ngoal (1 subgoal):\n 1. {0..} = (\\<Union>n. {real n..<real (Suc n)})", "by auto"], ["proof (state)\nthis:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})", "have \"\\<integral>\\<^sup>+x\\<in>{0::real..}. f (nat \\<lfloor>x\\<rfloor>)\\<partial>lborel =\n             (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel)\""], ["proof (prove)\nusing this:\n  {0..} = (\\<Union>n. {real n..<real (Suc n)})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                           ennreal (f (nat \\<lfloor>x\\<rfloor>))\n        \\<partial>lborel)", "by (auto simp add: disjoint_family_on_def nn_integral_disjoint_family)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = (\\<Sum>n. \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                           ennreal (f (nat \\<lfloor>x\\<rfloor>))\n        \\<partial>lborel) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n        \\<partial>lborel)", "by(subst suminf_cong,rule nn_integral_cong_AE)\n      (auto intro!: eventuallyI  simp add: indicator_def floor_eq4)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}.\n                         ennreal (f (nat \\<lfloor>x\\<rfloor>))\n      \\<partial>lborel) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = (\\<Sum>n. ennreal (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n        \\<partial>lborel) =\n    (\\<Sum>n. ennreal (f n))", "by (auto intro!: suminf_cong simp add: nn_integral_cmult)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel) =\n  (\\<Sum>n. ennreal (f n))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>{real n..<1 + real n}. ennreal (f n)\n      \\<partial>lborel) =\n  (\\<Sum>n. ennreal (f n))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"\\<dots> = (\\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f n)) =\n    \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV", "by (simp add: nn_integral_count_space_nat)"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f n)) =\n  \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ i. ennreal (f i) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nn_integral_floor_less_eq:\n  assumes \"\\<And>x y. x \\<le> y \\<Longrightarrow> f y \\<le> f x\"\n  shows \"\\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f x)\\<partial>lborel \\<le> \\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                             ennreal (f (real (nat \\<lfloor>x\\<rfloor>)))\n          \\<partial>lborel", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> f ?y \\<le> f ?x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f x)\\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                             ennreal (f (real (nat \\<lfloor>x\\<rfloor>)))\n          \\<partial>lborel", "by (auto simp add: indicator_def intro!: nn_integral_mono ennreal_leI)"], ["", "lemma nn_integral_finite_imp_abs_sumable_on:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  assumes \"nn_integral (count_space A) (\\<lambda>x. norm (f x)) < \\<infinity>\"\n  shows   \"f abs_summable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f abs_summable_on A", "using assms"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (norm (f x)) \\<partial>count_space A\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. f abs_summable_on A", "unfolding abs_summable_on_def integrable_iff_bounded"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (norm (f x)) \\<partial>count_space A\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable (count_space A) \\<and>\n    \\<integral>\\<^sup>+ x. ennreal (norm (f x)) \\<partial>count_space A\n    < \\<infinity>", "by auto"], ["", "lemma nn_integral_finite_imp_abs_sumable_on':\n  assumes \"nn_integral (count_space A) (\\<lambda>x. ennreal (f x)) < \\<infinity>\" \"\\<And>x. f x \\<ge> 0\"\n  shows   \"f abs_summable_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f abs_summable_on A", "using assms"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space A < \\<infinity>\n  0 \\<le> f ?x\n\ngoal (1 subgoal):\n 1. f abs_summable_on A", "unfolding abs_summable_on_def integrable_iff_bounded"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space A < \\<infinity>\n  0 \\<le> f ?x\n\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable (count_space A) \\<and>\n    \\<integral>\\<^sup>+ x. ennreal (norm (f x)) \\<partial>count_space A\n    < \\<infinity>", "by auto"], ["", "text \\<open>\n  We now show that $\\int_0^\\infty 1 - (1 - q^x) ^ n\\;dx = \\frac{- H_n}{\\ln q}$ if $0 < q < 1$.\n\\<close>"], ["", "lemma harm_integral_x_raised_n:\n  \"set_integrable lborel {0::real..1} (\\<lambda>x. (\\<Sum>i\\<in>{..<n}. x ^ i))\" (is ?thesis1)\n  \"LBINT x = 0..1. (\\<Sum>i\\<in>{..<n}. x ^ i) = harm n\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n}) &&&\n    LBINT x=0..1. sum ((^) x) {..<n} = harm n", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n})\n 2. LBINT x=0..1. sum ((^) x) {..<n} = harm n", "have h: \"set_integrable lborel {0::real..1} (\\<lambda>x. (\\<Sum>i\\<in>{..<n}. x ^ i))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n})", "by (intro borel_integrable_atLeastAtMost') (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})\n\ngoal (2 subgoals):\n 1. set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n})\n 2. LBINT x=0..1. sum ((^) x) {..<n} = harm n", "then"], ["proof (chain)\npicking this:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})", "show ?thesis1"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n})", "by (intro borel_integrable_atLeastAtMost') (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<n})\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} = harm n", "show ?thesis2"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} = harm n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0\n 2. \\<And>n.\n       LBINT x=0..1. sum ((^) x) {..<n} = harm n \\<Longrightarrow>\n       LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<n} = harm n\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0\n 2. \\<And>n.\n       LBINT x=0..1. sum ((^) x) {..<n} = harm n \\<Longrightarrow>\n       LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "have \"(LBINT x=0..1.(\\<Sum>i\\<in>{..<n}. x ^ i) + x ^ n) =\n          (LBINT x=0..1. (\\<Sum>i\\<in>{..<n}. x ^ i)) + (LBINT x=0..1. x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "have \"set_integrable lborel (einterval 0 1) (\\<lambda>x. (\\<Sum>i\\<in>{..<n}. x ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1) (\\<lambda>x. sum ((^) x) {..<n})", "by (rule set_integrable_subset) (use h in \\<open>auto simp add: einterval_def\\<close>)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. sum ((^) x) {..<n})\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "moreover"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. sum ((^) x) {..<n})\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "have \"set_integrable lborel (einterval 0 1) (\\<lambda>x. (x ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)", "have \"set_integrable lborel {0::real..1} (\\<lambda>x. (x ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. x ^ n)", "by (rule borel_integrable_atLeastAtMost')\n            (auto intro!: borel_integrable_atLeastAtMost' continuous_intros)"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. x ^ n)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)", "then"], ["proof (chain)\npicking this:\n  set_integrable lborel {0..1} (\\<lambda>x. x ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. x ^ n)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)", "by (rule set_integrable_subset) (auto simp add: einterval_def)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "ultimately"], ["proof (chain)\npicking this:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. sum ((^) x) {..<n})\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. sum ((^) x) {..<n})\n  set_integrable lborel (einterval 0 1) (\\<lambda>x. x ^ n)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n    (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)", "by (auto intro!: borel_integrable_atLeastAtMost' simp add:  interval_lebesgue_integrable_def)"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0\n 2. \\<And>n.\n       LBINT x=0..1. sum ((^) x) {..<n} = harm n \\<Longrightarrow>\n       LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "also"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + (LBINT x=0..1. x ^ n)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0\n 2. \\<And>n.\n       LBINT x=0..1. sum ((^) x) {..<n} = harm n \\<Longrightarrow>\n       LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "have \"(LBINT x=0..1. x ^ n) = 1 / (1 + real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = 1 / (1 + real n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = 1 / (1 + real n)", "have \"(LBINT x=0..1. x ^ n) = LBINT x. x ^ n * indicator {0..1} x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "have \"AE x in lborel. x ^ n * indicator {0..1} x = indicator (einterval 0 1) x * x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in lborel. x ^ n * indicat_real {0..1} x =\n                    indicat_real (einterval 0 1) x * x ^ n", "by(rule eventually_mono[OF eventually_conj[OF  AE_lborel_singleton[of 1]\n                  AE_lborel_singleton[of 0]]])\n            (auto simp add: indicator_def einterval_def)"], ["proof (state)\nthis:\n  AE x in lborel. x ^ n * indicat_real {0..1} x =\n                  indicat_real (einterval 0 1) x * x ^ n\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "then"], ["proof (chain)\npicking this:\n  AE x in lborel. x ^ n * indicat_real {0..1} x =\n                  indicat_real (einterval 0 1) x * x ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  AE x in lborel. x ^ n * indicat_real {0..1} x =\n                  indicat_real (einterval 0 1) x * x ^ n\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "using integral_cong_AE"], ["proof (prove)\nusing this:\n  AE x in lborel. x ^ n * indicat_real {0..1} x =\n                  indicat_real (einterval 0 1) x * x ^ n\n  \\<lbrakk>?f \\<in> borel_measurable ?M; ?g \\<in> borel_measurable ?M;\n   AE x in ?M. ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> integral\\<^sup>L ?M ?f = integral\\<^sup>L ?M ?g\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "unfolding interval_lebesgue_integral_def set_lebesgue_integral_def"], ["proof (prove)\nusing this:\n  AE x in lborel. x ^ n * indicat_real {0..1} x =\n                  indicat_real (einterval 0 1) x * x ^ n\n  \\<lbrakk>?f \\<in> borel_measurable ?M; ?g \\<in> borel_measurable ?M;\n   AE x in ?M. ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> integral\\<^sup>L ?M ?f = integral\\<^sup>L ?M ?g\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> 1\n     then LBINT x. indicat_real (einterval 0 1) x *\\<^sub>R x ^ n\n     else - (LBINT x. indicat_real (einterval 1 0) x *\\<^sub>R x ^ n)) =\n    LBINT x. x ^ n * indicat_real {0..1} x", "by (auto intro!: integral_cong_AE)"], ["proof (state)\nthis:\n  LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = 1 / (1 + real n)", "then"], ["proof (chain)\npicking this:\n  LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x", "show ?thesis"], ["proof (prove)\nusing this:\n  LBINT x=0..1. x ^ n = LBINT x. x ^ n * indicat_real {0..1} x\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. x ^ n = 1 / (1 + real n)", "by (auto simp add: integral_power)"], ["proof (state)\nthis:\n  LBINT x=0..1. x ^ n = 1 / (1 + real n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT x=0..1. x ^ n = 1 / (1 + real n)\n\ngoal (2 subgoals):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0\n 2. \\<And>n.\n       LBINT x=0..1. sum ((^) x) {..<n} = harm n \\<Longrightarrow>\n       LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "finally"], ["proof (chain)\npicking this:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + 1 / (1 + real n)", "show ?case"], ["proof (prove)\nusing this:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + 1 / (1 + real n)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "using Suc"], ["proof (prove)\nusing this:\n  LBINT x=0..1. sum ((^) x) {..<n} + x ^ n =\n  (LBINT x=0..1. sum ((^) x) {..<n}) + 1 / (1 + real n)\n  LBINT x=0..1. sum ((^) x) {..<n} = harm n\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)", "by (auto simp add: harm_def inverse_eq_divide)"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<Suc n} = harm (Suc n)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. sum ((^) x) {..<0} = harm 0", "qed (auto simp add: harm_def)"], ["proof (state)\nthis:\n  LBINT x=0..1. sum ((^) x) {..<n} = harm n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma harm_integral_0_1_fraction:\n  \"set_integrable lborel {0::real..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\"\n  \"(LBINT x = 0..1. ((1 - x ^ n) / (1 - x))) = harm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x)) &&&\n    LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n 2. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "show \"set_integrable lborel {0::real..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))", "have \"AE x\\<in>{0::real..1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x\\<in>{0..1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}", "by (auto intro!: eventually_mono[OF AE_lborel_singleton[of 1]] simp add: sum_gp_strict)"], ["proof (state)\nthis:\n  AE x\\<in>{0..1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))", "with harm_integral_x_raised_n"], ["proof (chain)\npicking this:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})\n  LBINT x=0..1. sum ((^) x) {..<?n} = harm ?n\n  AE x\\<in>{0..1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}", "show ?thesis"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})\n  LBINT x=0..1. sum ((^) x) {..<?n} = harm ?n\n  AE x\\<in>{0..1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))", "by (subst set_integrable_cong_AE) auto"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "moreover"], ["proof (state)\nthis:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "have \"AE x\\<in>{0::real<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}", "by (auto simp add: sum_gp_strict)"], ["proof (state)\nthis:\n  AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "moreover"], ["proof (state)\nthis:\n  AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "have \"einterval (min 0 1) (max 0 1) = {0::real<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. einterval (min 0 1) (max 0 1) = {0<..<1}", "by (auto simp add: min_def max_def einterval_iff)"], ["proof (state)\nthis:\n  einterval (min 0 1) (max 0 1) = {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "ultimately"], ["proof (chain)\npicking this:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n  AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n  einterval (min 0 1) (max 0 1) = {0<..<1}", "show \"(LBINT x = 0..1. ((1 - x ^ n) / (1 - x))) = harm n\""], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n  AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n  einterval (min 0 1) (max 0 1) = {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "using harm_integral_x_raised_n"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ n) / (1 - x))\n  AE x\\<in>{0<..<1} in lborel. (1 - x ^ n) / (1 - x) = sum ((^) x) {..<n}\n  einterval (min 0 1) (max 0 1) = {0<..<1}\n  set_integrable lborel {0..1} (\\<lambda>x. sum ((^) x) {..<?n})\n  LBINT x=0..1. sum ((^) x) {..<?n} = harm ?n\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n", "by (subst interval_integral_cong_AE) auto"], ["proof (state)\nthis:\n  LBINT x=0..1. (1 - x ^ n) / (1 - x) = harm n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_minus_one_minus_q_x_n_integral:\n  assumes \"q \\<in> {0<..<1}\"\n  shows \"set_integrable lborel (einterval 0 \\<infinity>) (\\<lambda>x. (1 - (1 - q powr x) ^ n))\"\n        \"(LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n) = - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n) &&&\n    LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "have [simp]: \"q powr (log q (1-x)) = 1 - x\" if \"x \\<in> {0<..<1}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. q powr log q (1 - x) = 1 - x", "using that assms"], ["proof (prove)\nusing this:\n  x \\<in> {0<..<1}\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. q powr log q (1 - x) = 1 - x", "by (subst powr_log_cancel) auto"], ["proof (state)\nthis:\n  ?x \\<in> {0<..<1} \\<Longrightarrow> q powr log q (1 - ?x) = 1 - ?x\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "have 1: \"((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ> real_of_ereal) \\<longlongrightarrow> 0) (at_right 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     0)\n     (at_right 0)", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     0)\n     (at_right 0)", "unfolding zero_ereal_def ereal_tendsto_simps"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. log q (1 - x)) \\<longlongrightarrow> 0) (at_right 0)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_right 0)\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "have 2: \"((ereal \\<circ> (\\<lambda>x. log q (1-x)) \\<circ> real_of_ereal) \\<longlongrightarrow> \\<infinity>) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     \\<infinity>)\n     (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     \\<infinity>)\n     (at_left 1)", "have \"filterlim ((-) 1) (at_right 0) (at_left (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim ((-) 1) (at_right 0) (at_left 1)", "by (intro filterlim_at_withinI eventually_at_leftI[of 0]) (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  filterlim ((-) 1) (at_right 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     \\<infinity>)\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  filterlim ((-) 1) (at_right 0) (at_left 1)", "have \"LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top\""], ["proof (prove)\nusing this:\n  filterlim ((-) 1) (at_right 0) (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top", "using assms"], ["proof (prove)\nusing this:\n  filterlim ((-) 1) (at_right 0) (at_left 1)\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top", "by (intro filterlim_tendsto_pos_mult_at_top [OF tendsto_const])\n        (auto simp: filterlim_uminus_at_top intro!: filterlim_compose[OF ln_at_0])"], ["proof (state)\nthis:\n  LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top\n\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     \\<infinity>)\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top", "show ?thesis"], ["proof (prove)\nusing this:\n  LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top\n\ngoal (1 subgoal):\n 1. ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n      real_of_ereal) \\<longlongrightarrow>\n     \\<infinity>)\n     (at_left 1)", "unfolding one_ereal_def ereal_tendsto_simps log_def"], ["proof (prove)\nusing this:\n  LIM x at_left 1. - inverse (ln q) * - ln (1 - x) :> at_top\n\ngoal (1 subgoal):\n 1. LIM x at_left 1. ln (1 - x) / ln q :> at_top", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   \\<infinity>)\n   (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   \\<infinity>)\n   (at_left 1)\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "have 3: \"set_integrable lborel (einterval 0 1)\n     (\\<lambda>x. (1 - (1 - q powr (log q (1 - x))) ^ n) * (- 1 / (ln q * (1 - x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1)\n     (\\<lambda>x.\n         (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1)\n     (\\<lambda>x.\n         (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))", "have \"set_integrable lborel (einterval 0 1) (\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1)\n     (\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x)))", "by(intro set_integrable_mult_right)\n        (auto intro!: harm_integral_0_1_fraction intro: set_integrable_subset simp add: einterval_def)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x)))\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1)\n     (\\<lambda>x.\n         (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))", "then"], ["proof (chain)\npicking this:\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x)))\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 1)\n     (\\<lambda>x.\n         (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))", "by(subst set_integrable_cong_AE[where g=\"\\<lambda>x. - (1 / ln q) * ((1 - x ^ n) / (1 - x))\"])\n        (auto intro!: eventuallyI simp add: einterval_def)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x.\n       (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x.\n       (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "have 4: \"LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) / (ln q * (1 - x))) = - (harm n / ln q)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "have \"?lhs = LBINT x=0..1. ((1 - x ^ n) / (1 - x)) * (- 1 / ln q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q)", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q)", "by (intro interval_integral_cong_AE)\n      (auto intro!: eventuallyI simp add: max_def einterval_def field_simps)"], ["proof (state)\nthis:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "also"], ["proof (state)\nthis:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "have \"\\<dots> = harm n * (-1 / ln q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q) =\n    harm n * (- 1 / ln q)", "using harm_integral_0_1_fraction"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..1} (\\<lambda>x. (1 - x ^ ?n) / (1 - x))\n  LBINT x=0..1. (1 - x ^ ?n) / (1 - x) = harm ?n\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q) =\n    harm n * (- 1 / ln q)", "by (subst interval_lebesgue_integral_mult_left) auto"], ["proof (state)\nthis:\n  LBINT x=0..1. (1 - x ^ n) / (1 - x) * (- 1 / ln q) = harm n * (- 1 / ln q)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "finally"], ["proof (chain)\npicking this:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  harm n * (- 1 / ln q)", "show ?thesis"], ["proof (prove)\nusing this:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  harm n * (- 1 / ln q)\n\ngoal (1 subgoal):\n 1. LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                     (ln q * (1 - x))) =\n    - (harm n / ln q)", "by auto"], ["proof (state)\nthis:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  - (harm n / ln q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  - (harm n / ln q)\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "note sub = interval_integral_substitution_nonneg\n             [where f = \"(\\<lambda>x. (1 - (1 - q powr x) ^ n))\" and g=\"(\\<lambda>x. log q (1-x))\"\n                    and g'=\"(\\<lambda>x. - 1 / (ln q * (1 - x)))\" and a = 0 and b = 1]"], ["proof (state)\nthis:\n  \\<lbrakk>0 < 1;\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> ((\\<lambda>x. log q (1 - x)) has_real_derivative\n                         - 1 / (ln q * (1 - x)))\n                         (at x);\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> isCont (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n                         (log q (1 - x));\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> isCont (\\<lambda>x. - 1 / (ln q * (1 - x))) x;\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> 0 \\<le> 1 - (1 - q powr log q (1 - x)) ^ n;\n   \\<And>x.\n      \\<lbrakk>0 \\<le> ereal x; ereal x \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> 0 \\<le> - 1 / (ln q * (1 - x));\n   ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n     real_of_ereal) \\<longlongrightarrow>\n    ?A)\n    (at_right 0);\n   ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n     real_of_ereal) \\<longlongrightarrow>\n    ?B)\n    (at_left 1);\n   set_integrable lborel (einterval 0 1)\n    (\\<lambda>x.\n        (1 - (1 - q powr log q (1 - x)) ^ n) *\n        (- 1 / (ln q * (1 - x))))\\<rbrakk>\n  \\<Longrightarrow> set_integrable lborel (einterval ?A ?B)\n                     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n  \\<lbrakk>0 < 1;\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> ((\\<lambda>x. log q (1 - x)) has_real_derivative\n                         - 1 / (ln q * (1 - x)))\n                         (at x);\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> isCont (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n                         (log q (1 - x));\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> isCont (\\<lambda>x. - 1 / (ln q * (1 - x))) x;\n   \\<And>x.\n      \\<lbrakk>0 < ereal x; ereal x < 1\\<rbrakk>\n      \\<Longrightarrow> 0 \\<le> 1 - (1 - q powr log q (1 - x)) ^ n;\n   \\<And>x.\n      \\<lbrakk>0 \\<le> ereal x; ereal x \\<le> 1\\<rbrakk>\n      \\<Longrightarrow> 0 \\<le> - 1 / (ln q * (1 - x));\n   ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n     real_of_ereal) \\<longlongrightarrow>\n    ?A)\n    (at_right 0);\n   ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n     real_of_ereal) \\<longlongrightarrow>\n    ?B)\n    (at_left 1);\n   set_integrable lborel (einterval 0 1)\n    (\\<lambda>x.\n        (1 - (1 - q powr log q (1 - x)) ^ n) *\n        (- 1 / (ln q * (1 - x))))\\<rbrakk>\n  \\<Longrightarrow> LBINT x=?A..?B. 1 - (1 - q powr x) ^ n =\n                    LBINT x=0..1. (1 - (1 - q powr log q (1 - x)) ^ n) *\n                                  (- 1 / (ln q * (1 - x)))\n\ngoal (2 subgoals):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n 2. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "show \"set_integrable lborel (einterval 0 \\<infinity>) (\\<lambda>x. (1 - (1 - q powr x) ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)", "using assms 1 2 3 4"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_right 0)\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   \\<infinity>)\n   (at_left 1)\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x.\n       (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  - (harm n / ln q)\n\ngoal (1 subgoal):\n 1. set_integrable lborel (einterval 0 \\<infinity>)\n     (\\<lambda>x. 1 - (1 - q powr x) ^ n)", "by (intro sub) (auto intro!: derivative_eq_intros mult_nonneg_nonpos2 tendsto_intros power_le_one)"], ["proof (state)\nthis:\n  set_integrable lborel (einterval 0 \\<infinity>)\n   (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n\ngoal (1 subgoal):\n 1. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "show \"(LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n) = - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "using assms 1 2 3 4"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   0)\n   (at_right 0)\n  ((ereal \\<circ> (\\<lambda>x. log q (1 - x)) \\<circ>\n    real_of_ereal) \\<longlongrightarrow>\n   \\<infinity>)\n   (at_left 1)\n  set_integrable lborel (einterval 0 1)\n   (\\<lambda>x.\n       (1 - (1 - q powr log q (1 - x)) ^ n) * (- 1 / (ln q * (1 - x))))\n  LBINT x=0..1. - ((1 - (1 - q powr log q (1 - x)) ^ n) /\n                   (ln q * (1 - x))) =\n  - (harm n / ln q)\n\ngoal (1 subgoal):\n 1. LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q", "by (subst sub) (auto intro!: derivative_eq_intros mult_nonneg_nonpos2 tendsto_intros power_le_one)"], ["proof (state)\nthis:\n  LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n = - harm n / ln q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_minus_one_minus_q_x_n_nn_integral:\n  fixes q::real\n  assumes \"q \\<in> {0<..<1}\"\n  shows \"set_nn_integral lborel {0..} (\\<lambda>x. (1 - (1 - q powr x) ^ n)) =\n        LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "have \"set_nn_integral  lborel {0..} (\\<lambda>x. (1 - (1 - q powr x) ^ n)) =\n        nn_integral lborel (\\<lambda>x. indicator (einterval 0 \\<infinity>) x *  (1 - (1 - q powr x) ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real (einterval 0 \\<infinity>) x *\n                             (1 - (1 - q powr x) ^ n))\n                       \\<partial>lborel", "using assms"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real (einterval 0 \\<infinity>) x *\n                             (1 - (1 - q powr x) ^ n))\n                       \\<partial>lborel", "by (intro nn_integral_cong_AE eventually_mono[OF AE_lborel_singleton[of 0]])\n      (auto simp add: indicator_def einterval_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real (einterval 0 \\<infinity>) x *\n                           (1 - (1 - q powr x) ^ n))\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real (einterval 0 \\<infinity>) x *\n                           (1 - (1 - q powr x) ^ n))\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "have \"\\<dots> = ennreal (LBINT x. indicator (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real (einterval 0 \\<infinity>) x *\n                             (1 - (1 - q powr x) ^ n))\n                       \\<partial>lborel =\n    ennreal\n     (LBINT x.\n        indicat_real (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))", "using one_minus_one_minus_q_x_n_integral assms"], ["proof (prove)\nusing this:\n  ?q \\<in> {0<..<1} \\<Longrightarrow>\n  set_integrable lborel (einterval 0 \\<infinity>)\n   (\\<lambda>x. 1 - (1 - ?q powr x) ^ ?n)\n  ?q \\<in> {0<..<1} \\<Longrightarrow>\n  LBINT x=0..\\<infinity>. 1 - (1 - ?q powr x) ^ ?n = - harm ?n / ln ?q\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real (einterval 0 \\<infinity>) x *\n                             (1 - (1 - q powr x) ^ n))\n                       \\<partial>lborel =\n    ennreal\n     (LBINT x.\n        indicat_real (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))", "by(intro nn_integral_eq_integral)\n    (auto simp add: indicator_def einterval_def set_integrable_def\n      intro!: eventuallyI power_le_one powr_le1)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real (einterval 0 \\<infinity>) x *\n                           (1 - (1 - q powr x) ^ n))\n                     \\<partial>lborel =\n  ennreal\n   (LBINT x.\n      indicat_real (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n  \\<partial>lborel =\n  ennreal\n   (LBINT x.\n      indicat_real (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n  \\<partial>lborel =\n  ennreal\n   (LBINT x.\n      indicat_real (einterval 0 \\<infinity>) x * (1 - (1 - q powr x) ^ n))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)", "by (simp add: interval_lebesgue_integral_def set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n  \\<partial>lborel =\n  ennreal (LBINT x=0..\\<infinity>. 1 - (1 - q powr x) ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We can now derive bounds for the expected height.\n\\<close>"], ["", "context random_skip_list\nbegin"], ["", "definition EH\\<^sub>N where \"EH\\<^sub>N n = measure_pmf.expectation (H\\<^sub>N n) real\""], ["", "lemma EH\\<^sub>N_bounds':\n  fixes n::nat\n  assumes \"p \\<in> {0<..<1}\" \"0 < n\"\n  shows \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\"\n     \"EH\\<^sub>N n \\<le> - harm n / ln q\"\n     \"integrable (H\\<^sub>N n) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n &&&\n    EH\\<^sub>N n \\<le> - harm n / ln q &&&\n    integrable (measure_pmf (H\\<^sub>N n)) real", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "define f where \"f = (\\<lambda>x. 1 - (1 - q ^ x) ^ n)\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. 1 - (1 - q ^ x) ^ n)\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "define f' where \"f' = (\\<lambda>x. 1 - (1 - q powr x) ^ n)\""], ["proof (state)\nthis:\n  f' = (\\<lambda>x. 1 - (1 - q powr x) ^ n)\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have q: \"q \\<in> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> {0<..<1}", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - p \\<in> {0<..<1}", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 - p \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  q \\<in> {0<..<1}\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have f_descending: \"f y \\<le> f x\" if \"x \\<le> y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f y \\<le> f x", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (1 - q ^ y) ^ n \\<le> 1 - (1 - q ^ x) ^ n", "using that q"], ["proof (prove)\nusing this:\n  x \\<le> y\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 - (1 - q ^ y) ^ n \\<le> 1 - (1 - q ^ x) ^ n", "by (auto intro!: power_mono simp add: power_decreasing power_le_one_iff)"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<Longrightarrow> f ?y2 \\<le> f ?x2\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have f'_descending: \"f' y \\<le> f' x\" if \"x \\<le> y\" \"0 \\<le> x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' y \\<le> f' x", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (1 - q powr y) ^ n \\<le> 1 - (1 - q powr x) ^ n", "using that q"], ["proof (prove)\nusing this:\n  x \\<le> y\n  0 \\<le> x\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 - (1 - q powr y) ^ n \\<le> 1 - (1 - q powr x) ^ n", "by (auto intro!: power_mono simp add: ln_powr powr_def mult_nonneg_nonpos)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<le> ?y2; 0 \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> f' ?y2 \\<le> f' ?x2\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have [simp]: \"harm n / ln q <= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. harm n / ln q \\<le> 0", "using harm_nonneg ln_ge_zero_imp_ge_one q"], ["proof (prove)\nusing this:\n  (0::?'a) \\<le> harm ?n\n  \\<lbrakk>0 \\<le> ln ?x; 0 < ?x\\<rbrakk> \\<Longrightarrow> 1 \\<le> ?x\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. harm n / ln q \\<le> 0", "by (intro divide_nonneg_neg) auto"], ["proof (state)\nthis:\n  harm n / ln q \\<le> 0\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have f_nn_integral_harm:\n    \"- harm n / ln q \\<le> \\<integral>\\<^sup>+ x. (f x) \\<partial>count_space UNIV\"\n    \"(\\<integral>\\<^sup>+ i. f (i + 1) \\<partial>count_space UNIV) \\<le> - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x)\n                             \\<partial>count_space UNIV &&&\n    \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "have \"(\\<integral>\\<^sup>+ i. f (i + 1) \\<partial>count_space UNIV) = (\\<integral>\\<^sup>+x\\<in>{0::real..}. (f (nat \\<lfloor>x\\<rfloor> + 1))\\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel", "using nn_integral_nats_reals"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ i. ennreal (?f i) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (?f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "have \"\\<dots> = \\<integral>\\<^sup>+x\\<in>{0::real..}. ennreal (f' (nat \\<lfloor>x\\<rfloor> + 1))\\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel", "have \"0 \\<le> x \\<Longrightarrow> (1 - q * q ^ nat \\<lfloor>x\\<rfloor>) ^ n = (1 - q powr (1 + real_of_int \\<lfloor>x\\<rfloor>)) ^ n\" for x::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    (1 - q * q ^ nat \\<lfloor>x\\<rfloor>) ^ n =\n    (1 - q powr (1 + real_of_int \\<lfloor>x\\<rfloor>)) ^ n", "using q"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    (1 - q * q ^ nat \\<lfloor>x\\<rfloor>) ^ n =\n    (1 - q powr (1 + real_of_int \\<lfloor>x\\<rfloor>)) ^ n", "by (subst powr_realpow [symmetric]) (auto simp: powr_add)"], ["proof (state)\nthis:\n  0 \\<le> ?x2 \\<Longrightarrow>\n  (1 - q * q ^ nat \\<lfloor>?x2\\<rfloor>) ^ n =\n  (1 - q powr (1 + real_of_int \\<lfloor>?x2\\<rfloor>)) ^ n\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?x2 \\<Longrightarrow>\n  (1 - q * q ^ nat \\<lfloor>?x2\\<rfloor>) ^ n =\n  (1 - q powr (1 + real_of_int \\<lfloor>?x2\\<rfloor>)) ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> ?x2 \\<Longrightarrow>\n  (1 - q * q ^ nat \\<lfloor>?x2\\<rfloor>) ^ n =\n  (1 - q powr (1 + real_of_int \\<lfloor>?x2\\<rfloor>)) ^ n\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel", "unfolding f_def f'_def"], ["proof (prove)\nusing this:\n  0 \\<le> ?x2 \\<Longrightarrow>\n  (1 - q * q ^ nat \\<lfloor>?x2\\<rfloor>) ^ n =\n  (1 - q powr (1 + real_of_int \\<lfloor>?x2\\<rfloor>)) ^ n\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 - (1 - q ^ (nat \\<lfloor>x\\<rfloor> + 1)) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 -\n                         (1 - q powr real (nat \\<lfloor>x\\<rfloor> + 1)) ^\n                         n)\n    \\<partial>lborel", "using q"], ["proof (prove)\nusing this:\n  0 \\<le> ?x2 \\<Longrightarrow>\n  (1 - q * q ^ nat \\<lfloor>?x2\\<rfloor>) ^ n =\n  (1 - q powr (1 + real_of_int \\<lfloor>?x2\\<rfloor>)) ^ n\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 - (1 - q ^ (nat \\<lfloor>x\\<rfloor> + 1)) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 -\n                         (1 - q powr real (nat \\<lfloor>x\\<rfloor> + 1)) ^\n                         n)\n    \\<partial>lborel", "by (auto intro!: nn_integral_cong ennreal_cong  simp add: powr_real_of_int indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "have \"\\<dots> \\<le> set_nn_integral lborel {0..} f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel", "have \"x \\<le> 1 + real_of_int \\<lfloor>x\\<rfloor>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 1 + real_of_int \\<lfloor>x\\<rfloor>", "by linarith"], ["proof (state)\nthis:\n  ?x2 \\<le> 1 + real_of_int \\<lfloor>?x2\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<le> 1 + real_of_int \\<lfloor>?x2\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<le> 1 + real_of_int \\<lfloor>?x2\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n    \\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel", "by (auto simp add: indicator_def intro!: f'_descending nn_integral_mono ennreal_leI)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor> + 1)))\n  \\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "have harm_integral_f': \"\\<dots> = - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel =\n    ennreal (- harm n / ln q)", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (- harm n / ln q)", "using q"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (1 - (1 - q powr x) ^ n)\n    \\<partial>lborel =\n    ennreal (- harm n / ln q)", "by (auto intro!: ennreal_cong\n          simp add: one_minus_one_minus_q_x_n_nn_integral one_minus_one_minus_q_x_n_integral)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel =\n  ennreal (- harm n / ln q)\n\ngoal (2 subgoals):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n 2. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)", "show \"(\\<integral>\\<^sup>+ i. f (i + 1) \\<partial>count_space UNIV) \\<le> - harm n / ln q\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "note harm_integral_f'[symmetric]"], ["proof (state)\nthis:\n  ennreal (- harm n / ln q) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  ennreal (- harm n / ln q) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "have \"set_nn_integral lborel {0..} f' \\<le> \\<integral>\\<^sup>+x\\<in>{0::real..}. f' (nat \\<lfloor>x\\<rfloor>)\\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                             ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n          \\<partial>lborel", "using assms f'_descending"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  0 < n\n  \\<lbrakk>?x2 \\<le> ?y2; 0 \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> f' ?y2 \\<le> f' ?x2\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n    \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                             ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n          \\<partial>lborel", "by (auto simp add: indicator_def intro!: nn_integral_mono ennreal_leI)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                           ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n        \\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f' x)\\<partial>lborel\n  \\<le> \\<integral>\\<^sup>+x\\<in>{0..}.\n                           ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n        \\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "have \"\\<dots> = \\<integral>\\<^sup>+x\\<in>{0::real..}. f (nat \\<lfloor>x\\<rfloor>)\\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "unfolding f_def f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 -\n                         (1 - q powr real (nat \\<lfloor>x\\<rfloor>)) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (1 - (1 - q ^ nat \\<lfloor>x\\<rfloor>) ^ n)\n    \\<partial>lborel", "using q"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal\n                        (1 -\n                         (1 - q powr real (nat \\<lfloor>x\\<rfloor>)) ^ n)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (1 - (1 - q ^ nat \\<lfloor>x\\<rfloor>) ^ n)\n    \\<partial>lborel", "by (auto intro!: nn_integral_cong ennreal_cong simp add: powr_real_of_int indicator_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}.\n                     ennreal (f' (real (nat \\<lfloor>x\\<rfloor>)))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. f x \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "using nn_integral_nats_reals"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ i. ennreal (?f i) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (?f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "finally"], ["proof (chain)\npicking this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "show \"- harm n / ln q \\<le> \\<integral>\\<^sup>+ x. f x \\<partial>count_space UNIV\""], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "by simp"], ["proof (state)\nthis:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "then"], ["proof (chain)\npicking this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)", "have f1_abs_summable_on: \"(\\<lambda>i. f (i + 1)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (i + 1)) abs_summable_on UNIV", "unfolding f_def"], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (1 - (1 - q ^ x) ^ n)\n                           \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (1 - (1 - q ^ (x + 1)) ^ n)\n                     \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. 1 - (1 - q ^ (i + 1)) ^ n) abs_summable_on UNIV", "using q"], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (1 - (1 - q ^ x) ^ n)\n                           \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (1 - (1 - q ^ (x + 1)) ^ n)\n                     \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. 1 - (1 - q ^ (i + 1)) ^ n) abs_summable_on UNIV", "by (intro nn_integral_finite_imp_abs_sumable_on')\n      (auto simp add: f_def le_less_trans intro!: power_le_one mult_le_one)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (i + 1)) abs_summable_on UNIV\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (i + 1)) abs_summable_on UNIV", "have f_abs_summable_on: \"f abs_summable_on {1..}\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (i + 1)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. f abs_summable_on {1..}", "using Suc_le_lessD greaterThan_0"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (i + 1)) abs_summable_on UNIV\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m < ?n\n  {0<..} = range Suc\n\ngoal (1 subgoal):\n 1. f abs_summable_on {1..}", "by (subst abs_summable_on_reindex_bij_betw[symmetric, where g=\"\\<lambda>x. x + 1\" and A=\"UNIV\"]) auto"], ["proof (state)\nthis:\n  f abs_summable_on {1..}\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "also"], ["proof (state)\nthis:\n  f abs_summable_on {1..}\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "have \"(f abs_summable_on {1..}) = ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "have \"((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..}) =\n          ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on {1..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n     {1..})", "by (auto intro!: measure_prob_cong_0 abs_summable_on_cong)"], ["proof (state)\nthis:\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n   {1..}) =\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n   {1..})\n\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n   {1..}) =\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n   {1..})\n\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "have \"\\<dots> = (f abs_summable_on {1..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n     {1..}) =\n    (f abs_summable_on {1..})", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  0 < n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n     {1..}) =\n    (f abs_summable_on {1..})", "by (intro abs_summable_on_cong) (auto simp add: f_def prob_Max_IID_geometric_greaterThan)"], ["proof (state)\nthis:\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x - 1<..}) abs_summable_on\n   {1..}) =\n  (f abs_summable_on {1..})\n\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n   {1..}) =\n  (f abs_summable_on {1..})", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n   {1..}) =\n  (f abs_summable_on {1..})\n\ngoal (1 subgoal):\n 1. (f abs_summable_on {1..}) =\n    ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on\n     {1..})", "by simp"], ["proof (state)\nthis:\n  (f abs_summable_on {1..}) =\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f abs_summable_on {1..}) =\n  ((\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..})\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..}", "have EH\\<^sub>N_sum:\n    \"EH\\<^sub>N n = (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..})\"\n    \"integrable (measure_pmf (H\\<^sub>N n)) real\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..}) &&&\n    integrable (measure_pmf (H\\<^sub>N n)) real", "unfolding EH\\<^sub>N_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (H\\<^sub>N n) real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..}) &&&\n    integrable (measure_pmf (H\\<^sub>N n)) real", "using expectation_prob_atLeast"], ["proof (prove)\nusing this:\n  (\\<lambda>x. measure_pmf.prob (H\\<^sub>N n) {x..}) abs_summable_on {1..}\n  (\\<lambda>i. measure_pmf.prob ?N {i..}) abs_summable_on\n  {1..} \\<Longrightarrow>\n  measure_pmf.expectation ?N real =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob ?N {i..})\n  (\\<lambda>i. measure_pmf.prob ?N {i..}) abs_summable_on\n  {1..} \\<Longrightarrow>\n  integrable (measure_pmf ?N) real\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (H\\<^sub>N n) real =\n    (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..}) &&&\n    integrable (measure_pmf (H\\<^sub>N n)) real", "by auto"], ["proof (state)\nthis:\n  EH\\<^sub>N n =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..})\n  integrable (measure_pmf (H\\<^sub>N n)) real\n\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "then"], ["proof (chain)\npicking this:\n  EH\\<^sub>N n =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..})\n  integrable (measure_pmf (H\\<^sub>N n)) real", "show \"integrable (measure_pmf (H\\<^sub>N n)) real\""], ["proof (prove)\nusing this:\n  EH\\<^sub>N n =\n  (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..})\n  integrable (measure_pmf (H\\<^sub>N n)) real\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf (H\\<^sub>N n)) real", "by simp"], ["proof (state)\nthis:\n  integrable (measure_pmf (H\\<^sub>N n)) real\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "have EH\\<^sub>N_sum': \"EH\\<^sub>N n = infsetsum f {1..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "have \"EH\\<^sub>N n = (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EH\\<^sub>N n =\n    (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..})", "unfolding EH\\<^sub>N_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {i..}) =\n    (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..})", "by (auto intro!: measure_prob_cong_0 infsetsum_cong)"], ["proof (state)\nthis:\n  EH\\<^sub>N n =\n  (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..})\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "also"], ["proof (state)\nthis:\n  EH\\<^sub>N n =\n  (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..})\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "have \"\\<dots> = infsetsum f {1..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..}) =\n    infsetsum f {1..}", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..}) =\n    infsetsum f {1..}", "by (intro infsetsum_cong) (auto simp add: f_def prob_Max_IID_geometric_greaterThan)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ak\\<in>{1..}. measure_pmf.prob (H\\<^sub>N n) {k - 1<..}) =\n  infsetsum f {1..}\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "finally"], ["proof (chain)\npicking this:\n  EH\\<^sub>N n = infsetsum f {1..}", "show ?thesis"], ["proof (prove)\nusing this:\n  EH\\<^sub>N n = infsetsum f {1..}\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n = infsetsum f {1..}", "by simp"], ["proof (state)\nthis:\n  EH\\<^sub>N n = infsetsum f {1..}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  EH\\<^sub>N n = infsetsum f {1..}\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "also"], ["proof (state)\nthis:\n  EH\\<^sub>N n = infsetsum f {1..}\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "have \"\\<dots> = (\\<Sum>\\<^sub>ak. f (k + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infsetsum f {1..} = (\\<Sum>\\<^sub>ak. f (k + 1))", "using Suc_le_lessD greaterThan_0"], ["proof (prove)\nusing this:\n  Suc ?m \\<le> ?n \\<Longrightarrow> ?m < ?n\n  {0<..} = range Suc\n\ngoal (1 subgoal):\n 1. infsetsum f {1..} = (\\<Sum>\\<^sub>ak. f (k + 1))", "by (subst infsetsum_reindex_bij_betw[symmetric, where g=\"\\<lambda>x. x + 1\" and A=\"UNIV\"]) auto"], ["proof (state)\nthis:\n  infsetsum f {1..} = (\\<Sum>\\<^sub>ak. f (k + 1))\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "also"], ["proof (state)\nthis:\n  infsetsum f {1..} = (\\<Sum>\\<^sub>ak. f (k + 1))\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "have \"ennreal \\<dots> = (\\<integral>\\<^sup>+x\\<in>{0::real..}. f (nat \\<lfloor>x\\<rfloor> + 1)\\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>\\<^sub>ak. f (k + 1)) =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel", "using f1_abs_summable_on q"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (i + 1)) abs_summable_on UNIV\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>\\<^sub>ak. f (k + 1)) =\n    \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel", "by (intro infsetsum_set_nn_integral_reals) (auto simp add: f_def mult_le_one power_le_one)"], ["proof (state)\nthis:\n  ennreal (\\<Sum>\\<^sub>ak. f (k + 1)) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "also"], ["proof (state)\nthis:\n  ennreal (\\<Sum>\\<^sub>ak. f (k + 1)) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "have \"\\<dots> = (\\<integral>\\<^sup>+ i. f (i + 1) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV", "using nn_integral_nats_reals"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ i. ennreal (?f i) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (?f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}.\n                       ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor> + 1))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "have \"\\<dots> \\<le> - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "using f_nn_integral_harm"], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n    \\<le> ennreal (- harm n / ln q)", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (2 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q", "finally"], ["proof (chain)\npicking this:\n  ennreal (EH\\<^sub>N n) \\<le> ennreal (- harm n / ln q)", "show \"EH\\<^sub>N n \\<le> - harm n / ln q\""], ["proof (prove)\nusing this:\n  ennreal (EH\\<^sub>N n) \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n \\<le> - harm n / ln q", "by (subst (asm) ennreal_le_iff) (auto)"], ["proof (state)\nthis:\n  EH\\<^sub>N n \\<le> - harm n / ln q\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "have \"EH\\<^sub>N n + 1 = (\\<Sum>\\<^sub>ax\\<in>{Suc 0..}. f x) + (\\<Sum>\\<^sub>ax\\<in>{0}. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EH\\<^sub>N n + 1 = infsetsum f {Suc 0..} + infsetsum f {0}", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  0 < n\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n + 1 = infsetsum f {Suc 0..} + infsetsum f {0}", "by (subst EH\\<^sub>N_sum') (auto simp add: f_def)"], ["proof (state)\nthis:\n  EH\\<^sub>N n + 1 = infsetsum f {Suc 0..} + infsetsum f {0}\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  EH\\<^sub>N n + 1 = infsetsum f {Suc 0..} + infsetsum f {0}\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "have \"\\<dots> = infsetsum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infsetsum f {Suc 0..} + infsetsum f {0} = infsetsum f UNIV", "using f_abs_summable_on"], ["proof (prove)\nusing this:\n  f abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. infsetsum f {Suc 0..} + infsetsum f {0} = infsetsum f UNIV", "by (subst infsetsum_Un_disjoint[symmetric]) (auto intro!: infsetsum_cong)"], ["proof (state)\nthis:\n  infsetsum f {Suc 0..} + infsetsum f {0} = infsetsum f UNIV\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  infsetsum f {Suc 0..} + infsetsum f {0} = infsetsum f UNIV\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "have \"\\<dots> = (\\<integral>\\<^sup>+x\\<in>{0::real..}. f (nat \\<lfloor>x\\<rfloor>)\\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"f abs_summable_on ({0} \\<union> {1..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f abs_summable_on {0} \\<union> {1..}", "using f_abs_summable_on"], ["proof (prove)\nusing this:\n  f abs_summable_on {1..}\n\ngoal (1 subgoal):\n 1. f abs_summable_on {0} \\<union> {1..}", "by (intro abs_summable_on_union) (auto)"], ["proof (state)\nthis:\n  f abs_summable_on {0} \\<union> {1..}\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "also"], ["proof (state)\nthis:\n  f abs_summable_on {0} \\<union> {1..}\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "have \"{0::nat} \\<union> {1..} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0} \\<union> {1..} = UNIV", "by auto"], ["proof (state)\nthis:\n  {0} \\<union> {1..} = UNIV\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "finally"], ["proof (chain)\npicking this:\n  f abs_summable_on UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  f abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "using q"], ["proof (prove)\nusing this:\n  f abs_summable_on UNIV\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal (infsetsum f UNIV) =\n    \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel", "by (intro infsetsum_set_nn_integral_reals) (auto simp add: f_def mult_le_one power_le_one)"], ["proof (state)\nthis:\n  ennreal (infsetsum f UNIV) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (infsetsum f UNIV) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  ennreal (infsetsum f UNIV) =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "have \"\\<dots> = (\\<integral>\\<^sup>+ x. f x \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "using nn_integral_nats_reals"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ i. ennreal (?f i) \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (?f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (f (nat \\<lfloor>x\\<rfloor>))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "have \"... \\<ge> - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "using f_nn_integral_harm"], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n  \\<integral>\\<^sup>+ x. ennreal (f (x + 1)) \\<partial>count_space UNIV\n  \\<le> ennreal (- harm n / ln q)\n\ngoal (1 subgoal):\n 1. ennreal (- harm n / ln q)\n    \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV", "by auto"], ["proof (state)\nthis:\n  ennreal (- harm n / ln q)\n  \\<le> \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "finally"], ["proof (chain)\npicking this:\n  ennreal (- harm n / ln q) \\<le> ennreal (EH\\<^sub>N n + 1)", "have \"- harm n / ln q \\<le> EH\\<^sub>N n + 1\""], ["proof (prove)\nusing this:\n  ennreal (- harm n / ln q) \\<le> ennreal (EH\\<^sub>N n + 1)\n\ngoal (1 subgoal):\n 1. - harm n / ln q \\<le> EH\\<^sub>N n + 1", "by (subst (asm) ennreal_le_iff) (auto simp add: EH\\<^sub>N_def)"], ["proof (state)\nthis:\n  - harm n / ln q \\<le> EH\\<^sub>N n + 1\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "then"], ["proof (chain)\npicking this:\n  - harm n / ln q \\<le> EH\\<^sub>N n + 1", "show \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\""], ["proof (prove)\nusing this:\n  - harm n / ln q \\<le> EH\\<^sub>N n + 1\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "by simp"], ["proof (state)\nthis:\n  - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem EH\\<^sub>N_bounds:\n  fixes n::nat\n  assumes \"p \\<in> {0<..<1}\"\n  shows\n    \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\"\n    \"EH\\<^sub>N n \\<le> - harm n / ln q\"\n    \"integrable (H\\<^sub>N n) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n &&&\n    EH\\<^sub>N n \\<le> - harm n / ln q &&&\n    integrable (measure_pmf (H\\<^sub>N n)) real", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n 2. EH\\<^sub>N n \\<le> - harm n / ln q\n 3. integrable (measure_pmf (H\\<^sub>N n)) real", "show \"- harm n / ln q - 1 \\<le> EH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "using assms EH\\<^sub>N_bounds'"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. - harm n / ln q - 1 \\<le> EH\\<^sub>N n", "by (cases \"n = 0\") (auto simp add: EH\\<^sub>N_def H\\<^sub>N_def H_def SL_def harm_expand)"], ["proof (state)\nthis:\n  - harm n / ln q - 1 \\<le> EH\\<^sub>N n\n\ngoal (2 subgoals):\n 1. EH\\<^sub>N n \\<le> - harm n / ln q\n 2. integrable (measure_pmf (H\\<^sub>N n)) real", "show \"EH\\<^sub>N n \\<le> - harm n / ln q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EH\\<^sub>N n \\<le> - harm n / ln q", "using assms EH\\<^sub>N_bounds'"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. EH\\<^sub>N n \\<le> - harm n / ln q", "by (cases \"n = 0\") (auto simp add: EH\\<^sub>N_def H\\<^sub>N_def H_def SL_def harm_expand)"], ["proof (state)\nthis:\n  EH\\<^sub>N n \\<le> - harm n / ln q\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf (H\\<^sub>N n)) real", "show \"integrable (H\\<^sub>N n) real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (measure_pmf (H\\<^sub>N n)) real", "using assms EH\\<^sub>N_bounds'"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  \\<lbrakk>p \\<in> {0<..<1}; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf (H\\<^sub>N n)) real", "by (cases \"n = 0\") (auto simp add: H\\<^sub>N_def H_def SL_def intro!: integrable_measure_pmf_finite)"], ["proof (state)\nthis:\n  integrable (measure_pmf (H\\<^sub>N n)) real\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context random_skip_list *)"], ["", "subsection \\<open>Expected Length of Search Path\\<close>"], ["", "text \\<open>\n  Let @{term \"A::'a::linorder set\"} and @{term \"f::'a \\<Rightarrow> nat\"} where f is an abstract description\n  of a skip list (assign each value its maximum level). steps A f s u l starts on the rightmost element\n  on level s in the skip lists. If possible it moves up, if not it moves to the left. For every step\n  up it adds cost u and for every step to the left it adds cost l. steps A f 0 1 1 therefore walks\n  from the bottom right corner of a skip list to the top left corner of a skip list and counts\n  all steps.\n\\<close>\n\n\\<comment> \\<open>NOTE: You could also define steps with lsteps and then prove that the following recursive\n    definition holds\\<close>"], ["", "function steps :: \"'a :: linorder set \\<Rightarrow> ('a \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"steps A f l up left = (if A = {} \\<or> infinite A\n              then 0\n              else (let m = Max A in (if f m < l then       steps (A - {m}) f l up left\n                                      else (if f m > l then up + steps A f (l + 1) up left\n                                      else                  left + steps (A - {m}) f l up left))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>A f l up left.\n           x = (A, f, l, up, left) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>A f l up left Aa fa la upa lefta.\n       (A, f, l, up, left) = (Aa, fa, la, upa, lefta) \\<Longrightarrow>\n       (if A = {} \\<or> infinite A then 0\n        else let m = Max A\n             in if f m < l then steps_sumC (A - {m}, f, l, up, left)\n                else if l < f m then up + steps_sumC (A, f, l + 1, up, left)\n                     else left + steps_sumC (A - {m}, f, l, up, left)) =\n       (if Aa = {} \\<or> infinite Aa then 0\n        else let m = Max Aa\n             in if fa m < la then steps_sumC (Aa - {m}, fa, la, upa, lefta)\n                else if la < fa m\n                     then upa + steps_sumC (Aa, fa, la + 1, upa, lefta)\n                     else lefta + steps_sumC (Aa - {m}, fa, la, upa, lefta))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All steps_dom", "proof (relation \"(\\<lambda>(A,f,l,a,b). card A) <*mlex*> (\\<lambda>(A,f,l,a,b). Max (f ` A) - l) <*mlex*> {}\", goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ((\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {})\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A;\n        f x < l\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 3. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 4. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. wf ((\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {})\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A;\n        f x < l\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 3. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 4. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {})", "by(intro wf_mlex wf_empty)"], ["proof (state)\nthis:\n  wf ((\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n      (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {})\n\ngoal (3 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A;\n        f x < l\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 3. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A;\n        f x < l\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 3. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "case 2"], ["proof (state)\nthis:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  f_ x_ < l_\n\ngoal (3 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A;\n        f x < l\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 3. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  f_ x_ < l_", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  f_ x_ < l_\n\ngoal (1 subgoal):\n 1. ((A_ - {x_}, f_, l_, up_, left_), A_, f_, l_, up_, left_)\n    \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n          (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}", "by (intro mlex_less) (auto simp: card_gt_0_iff)"], ["proof (state)\nthis:\n  ((A_ - {x_}, f_, l_, up_, left_), A_, f_, l_, up_, left_)\n  \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\n\ngoal (2 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "case (3 A f l a b x)"], ["proof (state)\nthis:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n\ngoal (2 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x", "have \"Max (f ` A) - Suc l < Max (f ` A) - l\""], ["proof (prove)\nusing this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n\ngoal (1 subgoal):\n 1. Max (f ` A) - Suc l < Max (f ` A) - l", "by (meson Max_gr_iff Max_in diff_less_mono2 finite_imageI imageI image_is_empty lessI)"], ["proof (state)\nthis:\n  Max (f ` A) - Suc l < Max (f ` A) - l\n\ngoal (2 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "with 3"], ["proof (chain)\npicking this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n  Max (f ` A) - Suc l < Max (f ` A) - l", "have \"((A, f, l + 1, a, b), A, f, l, a, b) \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\""], ["proof (prove)\nusing this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n  Max (f ` A) - Suc l < Max (f ` A) - l\n\ngoal (1 subgoal):\n 1. ((A, f, l + 1, a, b), A, f, l, a, b)\n    \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}", "by (intro mlex_less) (auto)"], ["proof (state)\nthis:\n  ((A, f, l + 1, a, b), A, f, l, a, b)\n  \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\n\ngoal (2 subgoals):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A, f, l + 1, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}\n 2. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "with 3"], ["proof (chain)\npicking this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n  ((A, f, l + 1, a, b), A, f, l, a, b)\n  \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> (A = {} \\<or> infinite A)\n  x = Max A\n  \\<not> f x < l\n  l < f x\n  ((A, f, l + 1, a, b), A, f, l, a, b)\n  \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\n\ngoal (1 subgoal):\n 1. ((A, f, l + 1, a, b), A, f, l, a, b)\n    \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n          (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n     l < f x;\n     ((A, f, l + 1, a, b), A, f, l, a, b)\n     \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\\<rbrakk>\n    \\<Longrightarrow> ((A, f, l + 1, a, b), A, f, l, a, b)\n                      \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                            (\\<lambda>(A, f, l, a, b).\n                                Max (f ` A) - l) <*mlex*>\n                            {}", "apply(rule mlex_leq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n     l < f x;\n     ((A, f, l + 1, a, b), A, f, l, a, b)\n     \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\\<rbrakk>\n    \\<Longrightarrow> (case (A, f, l + 1, a, b) of\n                       (A, f, l, a, b) \\<Rightarrow> card A)\n                      \\<le> (case (A, f, l, a, b) of\n                             (A, f, l, a, b) \\<Rightarrow> card A)\n 2. \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n     l < f x;\n     ((A, f, l + 1, a, b), A, f, l, a, b)\n     \\<in> (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\\<rbrakk>\n    \\<Longrightarrow> ((A, f, l + 1, a, b), A, f, l, a, b)\n                      \\<in> (\\<lambda>(A, f, l, a, b).\n                                Max (f ` A) - l) <*mlex*>\n                            {}", "by auto"], ["proof (state)\nthis:\n  ((A, f, l + 1, a, b), A, f, l, a, b)\n  \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\n\ngoal (1 subgoal):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "case 4"], ["proof (state)\nthis:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_\n\ngoal (1 subgoal):\n 1. \\<And>A f l up left x.\n       \\<lbrakk>\\<not> (A = {} \\<or> infinite A); x = Max A; \\<not> f x < l;\n        \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((A - {x}, f, l, up, left), A, f, l, up, left)\n                         \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n                               (\\<lambda>(A, f, l, a, b).\n                                   Max (f ` A) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> (A_ = {} \\<or> infinite A_)\n  x_ = Max A_\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_\n\ngoal (1 subgoal):\n 1. ((A_ - {x_}, f_, l_, up_, left_), A_, f_, l_, up_, left_)\n    \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n          (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}", "by (intro mlex_less) (auto simp: card_gt_0_iff)"], ["proof (state)\nthis:\n  ((A_ - {x_}, f_, l_, up_, left_), A_, f_, l_, up_, left_)\n  \\<in> (\\<lambda>(A, f, l, a, b). card A) <*mlex*>\n        (\\<lambda>(A, f, l, a, b). Max (f ` A) - l) <*mlex*> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "declare steps.simps[simp del]"], ["", "text \\<open>\n  lsteps is similar to steps but is using lists instead of sets. This makes the proofs where we use\n  induction easier.\n\\<close>"], ["", "function lsteps :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"lsteps [] f l up left = 0\" |\n  \"lsteps (x#xs) f l up left = (if       f x < l then lsteps xs f l up left\n                                 else (if f x > l then up + lsteps (x#xs) f (l + 1) up left\n                                 else                        left + lsteps xs f l up left))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>f l up left.\n                   x = ([], f, l, up, left) \\<Longrightarrow> P;\n        \\<And>xa xs f l up left.\n           x = (xa # xs, f, l, up, left) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>f l up left fa la upa lefta.\n       ([], f, l, up, left) = ([], fa, la, upa, lefta) \\<Longrightarrow>\n       0 = 0\n 3. \\<And>f l up left x xs fa la upa lefta.\n       ([], f, l, up, left) = (x # xs, fa, la, upa, lefta) \\<Longrightarrow>\n       0 =\n       (if fa x < la then lsteps_sumC (xs, fa, la, upa, lefta)\n        else if la < fa x\n             then upa + lsteps_sumC (x # xs, fa, la + 1, upa, lefta)\n             else lefta + lsteps_sumC (xs, fa, la, upa, lefta))\n 4. \\<And>x xs f l up left xa xsa fa la upa lefta.\n       (x # xs, f, l, up, left) =\n       (xa # xsa, fa, la, upa, lefta) \\<Longrightarrow>\n       (if f x < l then lsteps_sumC (xs, f, l, up, left)\n        else if l < f x then up + lsteps_sumC (x # xs, f, l + 1, up, left)\n             else left + lsteps_sumC (xs, f, l, up, left)) =\n       (if fa xa < la then lsteps_sumC (xsa, fa, la, upa, lefta)\n        else if la < fa xa\n             then upa + lsteps_sumC (xa # xsa, fa, la + 1, upa, lefta)\n             else lefta + lsteps_sumC (xsa, fa, la, upa, lefta))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All lsteps_dom", "proof (relation \"(\\<lambda>(xs,f,l,a,b). length xs) <*mlex*> (\\<lambda>(xs,f,l,a,b).\n                 Max (f ` set xs) - l) <*mlex*> {}\",\n       goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ((\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {})\n 2. \\<And>x xs f l up left.\n       f x < l \\<Longrightarrow>\n       ((xs, f, l, up, left), x # xs, f, l, up, left)\n       \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n             (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n 3. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 4. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. wf ((\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {})\n 2. \\<And>x xs f l up left.\n       f x < l \\<Longrightarrow>\n       ((xs, f, l, up, left), x # xs, f, l, up, left)\n       \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n             (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n 3. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 4. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {})", "by(intro wf_mlex wf_empty)"], ["proof (state)\nthis:\n  wf ((\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n      (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {})\n\ngoal (3 subgoals):\n 1. \\<And>x xs f l up left.\n       f x < l \\<Longrightarrow>\n       ((xs, f, l, up, left), x # xs, f, l, up, left)\n       \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n             (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 3. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs f l up left.\n       f x < l \\<Longrightarrow>\n       ((xs, f, l, up, left), x # xs, f, l, up, left)\n       \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n             (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 3. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "case 2"], ["proof (state)\nthis:\n  f_ x_ < l_\n\ngoal (3 subgoals):\n 1. \\<And>x xs f l up left.\n       f x < l \\<Longrightarrow>\n       ((xs, f, l, up, left), x # xs, f, l, up, left)\n       \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n             (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 3. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:\n  f_ x_ < l_", "show ?case"], ["proof (prove)\nusing this:\n  f_ x_ < l_\n\ngoal (1 subgoal):\n 1. ((xs_, f_, l_, up_, left_), x_ # xs_, f_, l_, up_, left_)\n    \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n          (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}", "by (auto intro: mlex_less simp: card_gt_0_iff)"], ["proof (state)\nthis:\n  ((xs_, f_, l_, up_, left_), x_ # xs_, f_, l_, up_, left_)\n  \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n\ngoal (2 subgoals):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "case (3 n f l a b)"], ["proof (state)\nthis:\n  \\<not> l n < a\n  a < l n\n\ngoal (2 subgoals):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; l < f x\\<rbrakk>\n       \\<Longrightarrow> ((x # xs, f, l + 1, up, left), x # xs, f, l, up,\n                          left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n # f, l, a + 1, b, left_), n # f, l, a, b, left_)\n    \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n          (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}", "by (rule mlex_leq) (use 3 in \\<open>auto intro: mlex_less mlex_leq intro!:  diff_less_mono2 simp add: Max_gr_iff\\<close>)"], ["proof (state)\nthis:\n  ((n # f, l, a + 1, b, left_), n # f, l, a, b, left_)\n  \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "case 4"], ["proof (state)\nthis:\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_\n\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<not> f x < l; \\<not> l < f x\\<rbrakk>\n       \\<Longrightarrow> ((xs, f, l, up, left), x # xs, f, l, up, left)\n                         \\<in> (\\<lambda>(xs, f, l, a, b).\n                                   length xs) <*mlex*>\n                               (\\<lambda>(xs, f, l, a, b).\n                                   Max (f ` set xs) - l) <*mlex*>\n                               {}", "then"], ["proof (chain)\npicking this:\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> f_ x_ < l_\n  \\<not> l_ < f_ x_\n\ngoal (1 subgoal):\n 1. ((xs_, f_, l_, up_, left_), x_ # xs_, f_, l_, up_, left_)\n    \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n          (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}", "by (intro mlex_less) (auto simp: card_gt_0_iff)"], ["proof (state)\nthis:\n  ((xs_, f_, l_, up_, left_), x_ # xs_, f_, l_, up_, left_)\n  \\<in> (\\<lambda>(xs, f, l, a, b). length xs) <*mlex*>\n        (\\<lambda>(xs, f, l, a, b). Max (f ` set xs) - l) <*mlex*> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "declare lsteps.simps(2)[simp del]"], ["", "lemma steps_empty [simp]: \"steps {} f l up left = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps {} f l up left = 0", "by (simp add: steps.simps)"], ["", "lemma steps_lsteps: \"steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "proof (cases \"finite A \\<and> A \\<noteq> {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite' A \\<Longrightarrow>\n    steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\n 2. \\<not> finite' A \\<Longrightarrow>\n    steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "case True"], ["proof (state)\nthis:\n  finite' A\n\ngoal (2 subgoals):\n 1. finite' A \\<Longrightarrow>\n    steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\n 2. \\<not> finite' A \\<Longrightarrow>\n    steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "then"], ["proof (chain)\npicking this:\n  finite' A", "show ?thesis"], ["proof (prove)\nusing this:\n  finite' A\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "proof(induction \"(rev (sorted_list_of_set A))\" f l u v arbitrary: A rule: lsteps.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left\n 2. \\<And>x xs f l up left A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>f x < l; xs = rev (sorted_list_of_set A);\n                    finite' A\\<rbrakk>\n                   \\<Longrightarrow> steps A f l up left =\n                                     lsteps (rev (sorted_list_of_set A)) f l\nup left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; l < f x;\n            x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f (l + 1) up left =\n                             lsteps (rev (sorted_list_of_set A)) f (l + 1)\n                              up left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n            xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f l up left =\n                             lsteps (rev (sorted_list_of_set A)) f l up\n                              left;\n        x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "case (2 y ys f l u v A)"], ["proof (state)\nthis:\n  \\<lbrakk>f y < l; ys = rev (sorted_list_of_set ?A); finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  \\<lbrakk>\\<not> f y < l; l < f y; y # ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f (l + 1) u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f (l + 1) u v\n  \\<lbrakk>\\<not> f y < l; \\<not> l < f y; ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  y # ys = rev (sorted_list_of_set A)\n  finite' A\n\ngoal (2 subgoals):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left\n 2. \\<And>x xs f l up left A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>f x < l; xs = rev (sorted_list_of_set A);\n                    finite' A\\<rbrakk>\n                   \\<Longrightarrow> steps A f l up left =\n                                     lsteps (rev (sorted_list_of_set A)) f l\nup left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; l < f x;\n            x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f (l + 1) up left =\n                             lsteps (rev (sorted_list_of_set A)) f (l + 1)\n                              up left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n            xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f l up left =\n                             lsteps (rev (sorted_list_of_set A)) f l up\n                              left;\n        x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>f y < l; ys = rev (sorted_list_of_set ?A); finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  \\<lbrakk>\\<not> f y < l; l < f y; y # ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f (l + 1) u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f (l + 1) u v\n  \\<lbrakk>\\<not> f y < l; \\<not> l < f y; ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  y # ys = rev (sorted_list_of_set A)\n  finite' A", "have y_ys: \"y = Max A\" \"ys  = rev (sorted_list_of_set (A - {y}))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>f y < l; ys = rev (sorted_list_of_set ?A); finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  \\<lbrakk>\\<not> f y < l; l < f y; y # ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f (l + 1) u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f (l + 1) u v\n  \\<lbrakk>\\<not> f y < l; \\<not> l < f y; ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  y # ys = rev (sorted_list_of_set A)\n  finite' A\n\ngoal (1 subgoal):\n 1. y = Max A &&& ys = rev (sorted_list_of_set (A - {y}))", "by (auto simp add: sorted_list_of_set_Max_snoc)"], ["proof (state)\nthis:\n  y = Max A\n  ys = rev (sorted_list_of_set (A - {y}))\n\ngoal (2 subgoals):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left\n 2. \\<And>x xs f l up left A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>f x < l; xs = rev (sorted_list_of_set A);\n                    finite' A\\<rbrakk>\n                   \\<Longrightarrow> steps A f l up left =\n                                     lsteps (rev (sorted_list_of_set A)) f l\nup left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; l < f x;\n            x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f (l + 1) up left =\n                             lsteps (rev (sorted_list_of_set A)) f (l + 1)\n                              up left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n            xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f l up left =\n                             lsteps (rev (sorted_list_of_set A)) f l up\n                              left;\n        x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "consider (a) \"l < f y\" | (b) \"f y < l\" | (c) \"f y = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < f y \\<Longrightarrow> thesis;\n     f y < l \\<Longrightarrow> thesis;\n     f y = l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>l < f y \\<Longrightarrow> ?thesis;\n   f y < l \\<Longrightarrow> ?thesis;\n   f y = l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left\n 2. \\<And>x xs f l up left A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>f x < l; xs = rev (sorted_list_of_set A);\n                    finite' A\\<rbrakk>\n                   \\<Longrightarrow> steps A f l up left =\n                                     lsteps (rev (sorted_list_of_set A)) f l\nup left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; l < f x;\n            x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f (l + 1) up left =\n                             lsteps (rev (sorted_list_of_set A)) f (l + 1)\n                              up left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n            xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f l up left =\n                             lsteps (rev (sorted_list_of_set A)) f l up\n                              left;\n        x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l < f y \\<Longrightarrow> ?thesis;\n   f y < l \\<Longrightarrow> ?thesis;\n   f y = l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"steps A f l u v = lsteps (y#ys) f l u v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>l < f y \\<Longrightarrow> ?thesis;\n   f y < l \\<Longrightarrow> ?thesis;\n   f y = l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (y # ys) f l u v", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. l < f y \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 2. f y < l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 3. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "case a"], ["proof (state)\nthis:\n  l < f y\n\ngoal (3 subgoals):\n 1. l < f y \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 2. f y < l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 3. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "then"], ["proof (chain)\npicking this:\n  l < f y", "show ?thesis"], ["proof (prove)\nusing this:\n  l < f y\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (y # ys) f l u v", "by (subst steps.simps, subst lsteps.simps) (use y_ys 2 in auto)"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (y # ys) f l u v\n\ngoal (2 subgoals):\n 1. f y < l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 2. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f y < l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 2. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "case b"], ["proof (state)\nthis:\n  f y < l\n\ngoal (2 subgoals):\n 1. f y < l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v\n 2. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "then"], ["proof (chain)\npicking this:\n  f y < l", "show ?thesis"], ["proof (prove)\nusing this:\n  f y < l\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (y # ys) f l u v", "using y_ys 2(1)"], ["proof (prove)\nusing this:\n  f y < l\n  y = Max A\n  ys = rev (sorted_list_of_set (A - {y}))\n  \\<lbrakk>f y < l; ys = rev (sorted_list_of_set ?A); finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (y # ys) f l u v", "by (cases \"ys = []\") (auto simp add: steps.simps lsteps.simps)"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (y # ys) f l u v\n\ngoal (1 subgoal):\n 1. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "case c"], ["proof (state)\nthis:\n  f y = l\n\ngoal (1 subgoal):\n 1. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "then"], ["proof (chain)\npicking this:\n  f y = l", "have \"steps (A - {Max A}) f l u v =\n                 lsteps (rev (sorted_list_of_set (A - {Max A}))) f l u v\""], ["proof (prove)\nusing this:\n  f y = l\n\ngoal (1 subgoal):\n 1. steps (A - {Max A}) f l u v =\n    lsteps (rev (sorted_list_of_set (A - {Max A}))) f l u v", "by (cases \"A = {Max A}\") (use y_ys 2 in \\<open>auto intro!: 2(3) simp add: steps.simps\\<close>)"], ["proof (state)\nthis:\n  steps (A - {Max A}) f l u v =\n  lsteps (rev (sorted_list_of_set (A - {Max A}))) f l u v\n\ngoal (1 subgoal):\n 1. f y = l \\<Longrightarrow> steps A f l u v = lsteps (y # ys) f l u v", "then"], ["proof (chain)\npicking this:\n  steps (A - {Max A}) f l u v =\n  lsteps (rev (sorted_list_of_set (A - {Max A}))) f l u v", "show ?thesis"], ["proof (prove)\nusing this:\n  steps (A - {Max A}) f l u v =\n  lsteps (rev (sorted_list_of_set (A - {Max A}))) f l u v\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (y # ys) f l u v", "by (subst steps.simps, subst lsteps.simps) (use y_ys 2 in auto)"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (y # ys) f l u v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (y # ys) f l u v\n\ngoal (2 subgoals):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left\n 2. \\<And>x xs f l up left A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>f x < l; xs = rev (sorted_list_of_set A);\n                    finite' A\\<rbrakk>\n                   \\<Longrightarrow> steps A f l up left =\n                                     lsteps (rev (sorted_list_of_set A)) f l\nup left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; l < f x;\n            x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f (l + 1) up left =\n                             lsteps (rev (sorted_list_of_set A)) f (l + 1)\n                              up left;\n        \\<And>A.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n            xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n           \\<Longrightarrow> steps A f l up left =\n                             lsteps (rev (sorted_list_of_set A)) f l up\n                              left;\n        x # xs = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "then"], ["proof (chain)\npicking this:\n  steps A f l u v = lsteps (y # ys) f l u v", "show ?case"], ["proof (prove)\nusing this:\n  steps A f l u v = lsteps (y # ys) f l u v\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "using 2"], ["proof (prove)\nusing this:\n  steps A f l u v = lsteps (y # ys) f l u v\n  \\<lbrakk>f y < l; ys = rev (sorted_list_of_set ?A); finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  \\<lbrakk>\\<not> f y < l; l < f y; y # ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f (l + 1) u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f (l + 1) u v\n  \\<lbrakk>\\<not> f y < l; \\<not> l < f y; ys = rev (sorted_list_of_set ?A);\n   finite' ?A\\<rbrakk>\n  \\<Longrightarrow> steps ?A f l u v =\n                    lsteps (rev (sorted_list_of_set ?A)) f l u v\n  y # ys = rev (sorted_list_of_set A)\n  finite' A\n\ngoal (1 subgoal):\n 1. steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "by simp"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\n\ngoal (1 subgoal):\n 1. \\<And>f l up left A.\n       \\<lbrakk>[] = rev (sorted_list_of_set A); finite' A\\<rbrakk>\n       \\<Longrightarrow> steps A f l up left =\n                         lsteps (rev (sorted_list_of_set A)) f l up left", "qed (auto simp add: steps.simps)"], ["proof (state)\nthis:\n  steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v\n\ngoal (1 subgoal):\n 1. \\<not> finite' A \\<Longrightarrow>\n    steps A f l u v = lsteps (rev (sorted_list_of_set A)) f l u v", "qed (auto simp add: steps.simps)"], ["", "lemma lsteps_comp_map: \"lsteps zs (f \\<circ> g) l u v = lsteps (map g zs) f l u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps zs (f \\<circ> g) l u v = lsteps (map g zs) f l u v", "by (induction zs \"f \\<circ> g\" l u v rule: lsteps.induct) (auto simp add: lsteps.simps)"], ["", "lemma steps_image:\n  assumes \"finite A\" \"mono_on g A\" \"inj_on g A\"\n  shows \"steps A (f \\<circ> g) l u v = steps (g ` A) f l u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "have \"(sorted_list_of_set (g ` A)) = map g (sorted_list_of_set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_list_of_set (g ` A) = map g (sorted_list_of_set A)", "using sorted_list_of_set_image assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>mono_on ?g ?A; inj_on ?g ?A\\<rbrakk>\n  \\<Longrightarrow> sorted_list_of_set (?g ` ?A) =\n                    map ?g (sorted_list_of_set ?A)\n  finite A\n  mono_on g A\n  inj_on g A\n\ngoal (1 subgoal):\n 1. sorted_list_of_set (g ` A) = map g (sorted_list_of_set A)", "by auto"], ["proof (state)\nthis:\n  sorted_list_of_set (g ` A) = map g (sorted_list_of_set A)\n\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "also"], ["proof (state)\nthis:\n  sorted_list_of_set (g ` A) = map g (sorted_list_of_set A)\n\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "have \"rev \\<dots> = map g (rev (sorted_list_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (map g (sorted_list_of_set A)) = map g (rev (sorted_list_of_set A))", "using rev_map"], ["proof (prove)\nusing this:\n  rev (map ?f ?xs) = map ?f (rev ?xs)\n\ngoal (1 subgoal):\n 1. rev (map g (sorted_list_of_set A)) = map g (rev (sorted_list_of_set A))", "by auto"], ["proof (state)\nthis:\n  rev (map g (sorted_list_of_set A)) = map g (rev (sorted_list_of_set A))\n\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "finally"], ["proof (chain)\npicking this:\n  rev (sorted_list_of_set (g ` A)) = map g (rev (sorted_list_of_set A))", "show ?thesis"], ["proof (prove)\nusing this:\n  rev (sorted_list_of_set (g ` A)) = map g (rev (sorted_list_of_set A))\n\ngoal (1 subgoal):\n 1. steps A (f \\<circ> g) l u v = steps (g ` A) f l u v", "by (simp add: steps_lsteps lsteps_comp_map)"], ["proof (state)\nthis:\n  steps A (f \\<circ> g) l u v = steps (g ` A) f l u v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsteps_cong:\n  assumes \"ys = xs\" \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x\" \"l = l'\"\n  shows \"lsteps xs f l u v = lsteps ys g l' u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l u v = lsteps ys g l' u v", "using assms"], ["proof (prove)\nusing this:\n  ys = xs\n  ?x \\<in> set xs \\<Longrightarrow> f ?x = g ?x\n  l = l'\n\ngoal (1 subgoal):\n 1. lsteps xs f l u v = lsteps ys g l' u v", "proof (induction xs f l u v arbitrary: ys l' rule: lsteps.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l up left ys l'.\n       \\<lbrakk>ys = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x; l = l'\\<rbrakk>\n       \\<Longrightarrow> lsteps [] f l up left = lsteps ys g l' up left\n 2. \\<And>x xs f l up left ys l'.\n       \\<lbrakk>\\<And>ys l'.\n                   \\<lbrakk>f x < l; ys = xs;\n                    \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x;\n                    l = l'\\<rbrakk>\n                   \\<Longrightarrow> lsteps xs f l up left =\n                                     lsteps ys g l' up left;\n        \\<And>ys l'.\n           \\<lbrakk>\\<not> f x < l; l < f x; ys = x # xs;\n            \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n            l + 1 = l'\\<rbrakk>\n           \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left =\n                             lsteps ys g l' up left;\n        \\<And>ys l'.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x; ys = xs;\n            \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x;\n            l = l'\\<rbrakk>\n           \\<Longrightarrow> lsteps xs f l up left = lsteps ys g l' up left;\n        ys = x # xs;\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n        l = l'\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left =\n                         lsteps ys g l' up left", "case (2 x xs f l up left)"], ["proof (state)\nthis:\n  \\<lbrakk>f x < l; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; l < f x; ?ys = x # xs;\n   \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n   l + 1 = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left =\n                    lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  ys = x # xs\n  ?x \\<in> set (x # xs) \\<Longrightarrow> f ?x = g ?x\n  l = l'\n\ngoal (2 subgoals):\n 1. \\<And>f l up left ys l'.\n       \\<lbrakk>ys = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x; l = l'\\<rbrakk>\n       \\<Longrightarrow> lsteps [] f l up left = lsteps ys g l' up left\n 2. \\<And>x xs f l up left ys l'.\n       \\<lbrakk>\\<And>ys l'.\n                   \\<lbrakk>f x < l; ys = xs;\n                    \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x;\n                    l = l'\\<rbrakk>\n                   \\<Longrightarrow> lsteps xs f l up left =\n                                     lsteps ys g l' up left;\n        \\<And>ys l'.\n           \\<lbrakk>\\<not> f x < l; l < f x; ys = x # xs;\n            \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n            l + 1 = l'\\<rbrakk>\n           \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left =\n                             lsteps ys g l' up left;\n        \\<And>ys l'.\n           \\<lbrakk>\\<not> f x < l; \\<not> l < f x; ys = xs;\n            \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x;\n            l = l'\\<rbrakk>\n           \\<Longrightarrow> lsteps xs f l up left = lsteps ys g l' up left;\n        ys = x # xs;\n        \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n        l = l'\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left =\n                         lsteps ys g l' up left", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>f x < l; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; l < f x; ?ys = x # xs;\n   \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n   l + 1 = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left =\n                    lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  ys = x # xs\n  ?x \\<in> set (x # xs) \\<Longrightarrow> f ?x = g ?x\n  l = l'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>f x < l; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; l < f x; ?ys = x # xs;\n   \\<And>xa. xa \\<in> set (x # xs) \\<Longrightarrow> f xa = g xa;\n   l + 1 = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left =\n                    lsteps ?ys g ?l' up left\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x; ?ys = xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> f x = g x; l = ?l'\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left = lsteps ?ys g ?l' up left\n  ys = x # xs\n  ?x \\<in> set (x # xs) \\<Longrightarrow> f ?x = g ?x\n  l = l'\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left = lsteps ys g l' up left", "by (subst \\<open>ys = x # xs\\<close>, subst lsteps.simps, subst (2) lsteps.simps) auto"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left = lsteps ys g l' up left\n\ngoal (1 subgoal):\n 1. \\<And>f l up left ys l'.\n       \\<lbrakk>ys = [];\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> f x = g x; l = l'\\<rbrakk>\n       \\<Longrightarrow> lsteps [] f l up left = lsteps ys g l' up left", "qed (auto)"], ["", "lemma steps_cong:\n  assumes \"A = B\" \"\\<And>x. x \\<in> A \\<Longrightarrow> f x = g x\" \"l = l'\"\n  shows   \"steps A f l u v = steps B g l' u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l u v = steps B g l' u v", "using assms"], ["proof (prove)\nusing this:\n  A = B\n  ?x \\<in> A \\<Longrightarrow> f ?x = g ?x\n  l = l'\n\ngoal (1 subgoal):\n 1. steps A f l u v = steps B g l' u v", "by (cases \"A = {} \\<or> infinite A\") (auto simp add: steps_lsteps steps.simps intro!: lsteps_cong)"], ["", "lemma lsteps_f_add':\n  shows \"lsteps xs f l u v = lsteps xs (\\<lambda>x. f x + m) (l + m) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l u v = lsteps xs (\\<lambda>x. f x + m) (l + m) u v", "by  (induction xs f l u v rule: lsteps.induct) (auto simp add: lsteps.simps)"], ["", "lemma steps_f_add':\n  shows \"steps A f l u v = steps A (\\<lambda>x. f x + m) (l + m) u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l u v = steps A (\\<lambda>x. f x + m) (l + m) u v", "by (cases \"A = {} \\<or> infinite A\") (auto simp add: steps_lsteps steps.simps intro!: lsteps_f_add')"], ["", "lemma lsteps_smaller_set:\n  assumes \"m \\<le> l\"\n  shows \"lsteps xs f l u v = lsteps [x \\<leftarrow> xs. m \\<le> f x] f l u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l u v = lsteps (filter (\\<lambda>x. m \\<le> f x) xs) f l u v", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> l\n\ngoal (1 subgoal):\n 1. lsteps xs f l u v = lsteps (filter (\\<lambda>x. m \\<le> f x) xs) f l u v", "by (induction xs f l u v rule: lsteps.induct) (auto simp add: lsteps.simps)"], ["", "lemma steps_smaller_set:\n  assumes \"finite A\" \"m \\<le> l\"\n  shows \"steps A f l u v = steps {x\\<in>A. f x \\<ge> m} f l u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l u v = steps {x \\<in> A. m \\<le> f x} f l u v", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  m \\<le> l\n\ngoal (1 subgoal):\n 1. steps A f l u v = steps {x \\<in> A. m \\<le> f x} f l u v", "by(cases \"A = {} \\<or> infinite A\")\n    (auto simp add: steps_lsteps steps.simps rev_filter sorted_list_of_set_filter\n      intro!: lsteps_smaller_set)"], ["", "lemma lsteps_level_greater_fun_image:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> f x < l\"\n  shows   \"lsteps xs f l u v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l u v = 0", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> f ?x < l\n\ngoal (1 subgoal):\n 1. lsteps xs f l u v = 0", "by (induction xs f l u v rule: lsteps.induct) (auto simp add: lsteps.simps)"], ["", "lemma lsteps_smaller_card_Max_fun':\n  assumes \"\\<exists>x \\<in> set xs. l \\<le> f x\"\n  shows   \"lsteps xs f l u v + l * u \\<le> v * length xs + u * Max ((f ` (set xs)) \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l u v + l * u\n    \\<le> v * length xs + u * Max (f ` set xs \\<union> {0})", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set xs. l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps xs f l u v + l * u\n    \\<le> v * length xs + u * Max (f ` set xs \\<union> {0})", "proof (induction xs f l u v rule: lsteps.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l up left.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up left + l * up\n       \\<le> left * length [] + up * Max (f ` set [] \\<union> {0})\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "case (1 f l up left)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set []. l \\<le> f x\n\ngoal (2 subgoals):\n 1. \\<And>f l up left.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up left + l * up\n       \\<le> left * length [] + up * Max (f ` set [] \\<union> {0})\n 2. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set []. l \\<le> f x", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set []. l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps [] f l up left + l * up\n    \\<le> left * length [] + up * Max (f ` set [] \\<union> {0})", "by (simp)"], ["proof (state)\nthis:\n  lsteps [] f l up left + l * up\n  \\<le> left * length [] + up * Max (f ` set [] \\<union> {0})\n\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "case (2 x xs f l up left)"], ["proof (state)\nthis:\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                    \\<le> left * length (x # xs) +\n                          up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "consider \"l = f x\" \"\\<exists>y\\<in>set xs. l \\<le> f y\" | \"f x = l\" \"\\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\" |\n   \"f x < l\" | \"l < f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     f x < l \\<Longrightarrow> thesis;\n     l < f x \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs f l up left.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up left + l * up\n                                  \\<le> left * length xs +\n  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                          \\<le> left * length (x # xs) +\n                                up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up left + l * up\n                          \\<le> left * length xs +\n                                up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                         \\<le> left * length (x # xs) +\n                               up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "assume a: \"l = f x\" \"\\<exists>y\\<in>set xs. l \\<le> f y\""], ["proof (state)\nthis:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"lsteps (x # xs) f l up left + l * up = lsteps xs f l up left + f x * up + left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up =\n    lsteps xs f l up left + f x * up + left", "using a"], ["proof (prove)\nusing this:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up =\n    lsteps xs f l up left + f x * up + left", "by (auto simp add: lsteps.simps)"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up =\n  lsteps xs f l up left + f x * up + left\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up =\n  lsteps xs f l up left + f x * up + left\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"lsteps xs f l up left + f x * up \\<le> left * length xs + up * Max (f ` set xs \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l up left + f x * up\n    \\<le> left * length xs + up * Max (f ` set xs \\<union> {0})", "using a 2"], ["proof (prove)\nusing this:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                    \\<le> left * length (x # xs) +\n                          up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps xs f l up left + f x * up\n    \\<le> left * length xs + up * Max (f ` set xs \\<union> {0})", "by blast"], ["proof (state)\nthis:\n  lsteps xs f l up left + f x * up\n  \\<le> left * length xs + up * Max (f ` set xs \\<union> {0})\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps xs f l up left + f x * up\n  \\<le> left * length xs + up * Max (f ` set xs \\<union> {0})\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"up * Max (f ` set xs \\<union> {0}) \\<le> up * Max (insert (f x) (f ` set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up * Max (f ` set xs \\<union> {0})\n    \\<le> up * Max (insert (f x) (f ` set xs))", "by simp"], ["proof (state)\nthis:\n  up * Max (f ` set xs \\<union> {0})\n  \\<le> up * Max (insert (f x) (f ` set xs))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + left \\<le> y + left;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      left * length xs + x + left \\<le> left * length xs + y + left\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (insert (f x) (f ` set xs)) +\n                          left", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y. x \\<le> y \\<Longrightarrow> x + left \\<le> y + left;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      left * length xs + x + left \\<le> left * length xs + y + left\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (insert (f x) (f ` set xs)) +\n                          left\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "by auto"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "assume a: \"f x = l\" \"\\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\""], ["proof (state)\nthis:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"lsteps (x # xs) f l up left + l * up = lsteps xs f l up left + f x * up + left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up =\n    lsteps xs f l up left + f x * up + left", "using a"], ["proof (prove)\nusing this:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up =\n    lsteps xs f l up left + f x * up + left", "by (auto simp add: lsteps.simps)"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up =\n  lsteps xs f l up left + f x * up + left\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up =\n  lsteps xs f l up left + f x * up + left\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"lsteps xs f l up left = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l up left = 0", "using a"], ["proof (prove)\nusing this:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (1 subgoal):\n 1. lsteps xs f l up left = 0", "by (subst lsteps_level_greater_fun_image) auto"], ["proof (state)\nthis:\n  lsteps xs f l up left = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps xs f l up left = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"f x * up \\<le> up * Max (insert (f x) (f ` set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x * up \\<le> up * Max (insert (f x) (f ` set xs))", "by simp"], ["proof (state)\nthis:\n  f x * up \\<le> up * Max (insert (f x) (f ` set xs))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up left + l * up\n                      \\<le> left * length (x # xs) +\n                            up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      0 + x + left \\<le> 0 + y + left) \\<Longrightarrow>\n  lsteps (x # xs) f l up left + l * up\n  \\<le> 0 + up * Max (insert (f x) (f ` set xs)) + left", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      0 + x + left \\<le> 0 + y + left) \\<Longrightarrow>\n  lsteps (x # xs) f l up left + l * up\n  \\<le> 0 + up * Max (insert (f x) (f ` set xs)) + left\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "by simp"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "assume a: \"f x < l\""], ["proof (state)\nthis:\n  f x < l\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  f x < l", "have \"lsteps (x # xs) f l up left = lsteps xs f l up left\""], ["proof (prove)\nusing this:\n  f x < l\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left = lsteps xs f l up left", "by (auto simp add: lsteps.simps)"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left = lsteps xs f l up left\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left = lsteps xs f l up left\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"\\<dots> + l * up \\<le> left * length (x # xs) + up * Max (insert 0 (f ` set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (insert 0 (f ` set xs))", "using a 2"], ["proof (prove)\nusing this:\n  f x < l\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                    \\<le> left * length (x # xs) +\n                          up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps xs f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (insert 0 (f ` set xs))", "by auto"], ["proof (state)\nthis:\n  lsteps xs f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (insert 0 (f ` set xs))\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps xs f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (insert 0 (f ` set xs))\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "have \"Max (insert 0 (f ` set xs)) \\<le> Max (f ` set (x # xs) \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max (insert 0 (f ` set xs)) \\<le> Max (f ` set (x # xs) \\<union> {0})", "by simp"], ["proof (state)\nthis:\n  Max (insert 0 (f ` set xs)) \\<le> Max (f ` set (x # xs) \\<union> {0})\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "finally"], ["proof (chain)\npicking this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      left * length (x # xs) + up * xa\n      \\<le> left * length (x # xs) + up * y) \\<Longrightarrow>\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      left * length (x # xs) + up * xa\n      \\<le> left * length (x # xs) + up * y) \\<Longrightarrow>\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "by simp"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "assume \"f x > l\""], ["proof (state)\nthis:\n  l < f x\n\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  l < f x", "show ?case"], ["proof (prove)\nusing this:\n  l < f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "using 2"], ["proof (prove)\nusing this:\n  l < f x\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up left + (l + 1) * up\n                    \\<le> left * length (x # xs) +\n                          up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up left + l * up\n                    \\<le> left * length xs +\n                          up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up left + l * up\n    \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})", "by (subst lsteps.simps) auto"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up left + l * up\n  \\<le> left * length (x # xs) + up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_smaller_card_Max_fun':\n  assumes \"finite A\" \"\\<exists>x\\<in>A. l \\<le> f x\"\n  shows   \"steps A f l up left + l * up \\<le> left * card A + up * Max\\<^sub>0 (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "let ?xs = \"rev (sorted_list_of_set A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "have \"steps A f l up left  = lsteps (rev (sorted_list_of_set A)) f l up left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f l up left = lsteps (rev (sorted_list_of_set A)) f l up left", "using steps_lsteps"], ["proof (prove)\nusing this:\n  steps ?A ?f ?l ?u ?v = lsteps (rev (sorted_list_of_set ?A)) ?f ?l ?u ?v\n\ngoal (1 subgoal):\n 1. steps A f l up left = lsteps (rev (sorted_list_of_set A)) f l up left", "by blast"], ["proof (state)\nthis:\n  steps A f l up left = lsteps (rev (sorted_list_of_set A)) f l up left\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "also"], ["proof (state)\nthis:\n  steps A f l up left = lsteps (rev (sorted_list_of_set A)) f l up left\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "have \"\\<dots> + l * up \\<le> left * length ?xs + up * Max (f ` set ?xs \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps (rev (sorted_list_of_set A)) f l up left + l * up\n    \\<le> left * length (rev (sorted_list_of_set A)) +\n          up * Max (f ` set (rev (sorted_list_of_set A)) \\<union> {0})", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<exists>x\\<in>A. l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps (rev (sorted_list_of_set A)) f l up left + l * up\n    \\<le> left * length (rev (sorted_list_of_set A)) +\n          up * Max (f ` set (rev (sorted_list_of_set A)) \\<union> {0})", "by (intro lsteps_smaller_card_Max_fun') auto"], ["proof (state)\nthis:\n  lsteps (rev (sorted_list_of_set A)) f l up left + l * up\n  \\<le> left * length (rev (sorted_list_of_set A)) +\n        up * Max (f ` set (rev (sorted_list_of_set A)) \\<union> {0})\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "also"], ["proof (state)\nthis:\n  lsteps (rev (sorted_list_of_set A)) f l up left + l * up\n  \\<le> left * length (rev (sorted_list_of_set A)) +\n        up * Max (f ` set (rev (sorted_list_of_set A)) \\<union> {0})\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "have \"left * length ?xs = left * card A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left * length (rev (sorted_list_of_set A)) = left * card A", "using assms sorted_list_of_set_length"], ["proof (prove)\nusing this:\n  finite A\n  \\<exists>x\\<in>A. l \\<le> f x\n  length (sorted_list_of_set ?A) = card ?A\n\ngoal (1 subgoal):\n 1. left * length (rev (sorted_list_of_set A)) = left * card A", "by (auto)"], ["proof (state)\nthis:\n  left * length (rev (sorted_list_of_set A)) = left * card A\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "also"], ["proof (state)\nthis:\n  left * length (rev (sorted_list_of_set A)) = left * card A\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "have \"set ?xs = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rev (sorted_list_of_set A)) = A", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<exists>x\\<in>A. l \\<le> f x\n\ngoal (1 subgoal):\n 1. set (rev (sorted_list_of_set A)) = A", "by (auto)"], ["proof (state)\nthis:\n  set (rev (sorted_list_of_set A)) = A\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "finally"], ["proof (chain)\npicking this:\n  steps A f l up left + l * up\n  \\<le> left * card A + up * Max (f ` A \\<union> {0})", "show ?thesis"], ["proof (prove)\nusing this:\n  steps A f l up left + l * up\n  \\<le> left * card A + up * Max (f ` A \\<union> {0})\n\ngoal (1 subgoal):\n 1. steps A f l up left + l * up\n    \\<le> left * card A + up * Max (f ` A \\<union> {0})", "by simp"], ["proof (state)\nthis:\n  steps A f l up left + l * up\n  \\<le> left * card A + up * Max (f ` A \\<union> {0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lsteps_height:\n  assumes  \"\\<exists>x \\<in> set xs. l \\<le> f x\"\n  shows \"lsteps xs f l up 0 + up * l = up * Max\\<^sub>0 (f ` (set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l up 0 + up * l = up * Max (f ` set xs \\<union> {0})", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set xs. l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps xs f l up 0 + up * l = up * Max (f ` set xs \\<union> {0})", "proof (induction xs f l up \"0::nat\" rule: lsteps.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l up.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up 0 + up * l = up * Max (f ` set [] \\<union> {0})\n 2. \\<And>x xs f l up.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                                  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                          up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                          up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                         up * Max (f ` set (x # xs) \\<union> {0})", "case (2 x xs f l up)"], ["proof (state)\nthis:\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (2 subgoals):\n 1. \\<And>f l up.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up 0 + up * l = up * Max (f ` set [] \\<union> {0})\n 2. \\<And>x xs f l up.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                                  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                          up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                          up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                         up * Max (f ` set (x # xs) \\<union> {0})", "consider \"l = f x\" \"\\<exists>y\\<in>set xs. l \\<le> f y\" | \"f x = l\" \"\\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\" |\n   \"f x < l\" | \"l < f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     f x < l \\<Longrightarrow> thesis;\n     l < f x \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>f l up.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up 0 + up * l = up * Max (f ` set [] \\<union> {0})\n 2. \\<And>x xs f l up.\n       \\<lbrakk>\\<lbrakk>f x < l;\n                 \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n                \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                                  up * Max (f ` set xs \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; l < f x;\n         \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                          up * Max (f ` set (x # xs) \\<union> {0});\n        \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n         \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n        \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                          up * Max (f ` set xs \\<union> {0});\n        \\<exists>x\\<in>set (x # xs). l \\<le> f x\\<rbrakk>\n       \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                         up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   f x < l \\<Longrightarrow> ?thesis;\n   l < f x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "assume 0: \"l = f x\" \"\\<exists>y\\<in>set xs. l \\<le> f y\""], ["proof (state)\nthis:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y", "have 1: \"set xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "using 2"], ["proof (prove)\nusing this:\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set xs \\<noteq> {}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  set xs \\<noteq> {}", "have \"\\<exists>xa\\<in>set xs. f x \\<le> f xa\""], ["proof (prove)\nusing this:\n  set xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>set xs. f x \\<le> f xa", "using 0 2"], ["proof (prove)\nusing this:\n  set xs \\<noteq> {}\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>set xs. f x \\<le> f xa", "by force"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa", "have \"f x \\<le> Max (f ` set xs)\""], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` set xs)", "using 0 2"], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` set xs)", "by (subst Max_ge_iff) auto"], ["proof (state)\nthis:\n  f x \\<le> Max (f ` set xs)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  f x \\<le> Max (f ` set xs)", "have \"max (f x) (Max (f ` set xs)) = (Max (f ` set xs))\""], ["proof (prove)\nusing this:\n  f x \\<le> Max (f ` set xs)\n\ngoal (1 subgoal):\n 1. max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "using 0 2"], ["proof (prove)\nusing this:\n  f x \\<le> Max (f ` set xs)\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "by (auto intro!: simp add: max_def)"], ["proof (state)\nthis:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>l = f x; \\<exists>y\\<in>set xs. l \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 3. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 4. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "show ?case"], ["proof (prove)\nusing this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "using 0 1 2"], ["proof (prove)\nusing this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n  l = f x\n  \\<exists>y\\<in>set xs. l \\<le> f y\n  set xs \\<noteq> {}\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "by (subst lsteps.simps) (auto)"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up 0 + up * l =\n  up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "assume 0: \"f x = l\" \"\\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\""], ["proof (state)\nthis:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)", "have \"Max (insert l (f ` set xs)) = l\""], ["proof (prove)\nusing this:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (1 subgoal):\n 1. Max (insert l (f ` set xs)) = l", "by (intro Max_eqI) (auto)"], ["proof (state)\nthis:\n  Max (insert l (f ` set xs)) = l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "moreover"], ["proof (state)\nthis:\n  Max (insert l (f ` set xs)) = l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "have \"lsteps xs f l up 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps xs f l up 0 = 0", "using 0"], ["proof (prove)\nusing this:\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (1 subgoal):\n 1. lsteps xs f l up 0 = 0", "by (subst lsteps_level_greater_fun_image) auto"], ["proof (state)\nthis:\n  lsteps xs f l up 0 = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>f x = l; \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\\<rbrakk>\n    \\<Longrightarrow> lsteps (x # xs) f l up 0 + up * l =\n                      up * Max (f ` set (x # xs) \\<union> {0})\n 2. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 3. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "ultimately"], ["proof (chain)\npicking this:\n  Max (insert l (f ` set xs)) = l\n  lsteps xs f l up 0 = 0", "show ?case"], ["proof (prove)\nusing this:\n  Max (insert l (f ` set xs)) = l\n  lsteps xs f l up 0 = 0\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "using 0"], ["proof (prove)\nusing this:\n  Max (insert l (f ` set xs)) = l\n  lsteps xs f l up 0 = 0\n  f x = l\n  \\<not> (\\<exists>y\\<in>set xs. l \\<le> f y)\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "by (subst lsteps.simps) auto"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up 0 + up * l =\n  up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "assume 0: \"f x < l\""], ["proof (state)\nthis:\n  f x < l\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  f x < l", "have 1: \"set xs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  f x < l\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "using 2"], ["proof (prove)\nusing this:\n  f x < l\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. set xs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set xs \\<noteq> {}\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  set xs \\<noteq> {}", "have \"\\<exists>xa\\<in>set xs. f x \\<le> f xa\""], ["proof (prove)\nusing this:\n  set xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>set xs. f x \\<le> f xa", "using 0 2"], ["proof (prove)\nusing this:\n  set xs \\<noteq> {}\n  f x < l\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>set xs. f x \\<le> f xa", "by force"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa", "have \" f x \\<le> Max (f ` set xs)\""], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` set xs)", "using 0 2"], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>set xs. f x \\<le> f xa\n  f x < l\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. f x \\<le> Max (f ` set xs)", "by (subst Max_ge_iff) auto"], ["proof (state)\nthis:\n  f x \\<le> Max (f ` set xs)\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  f x \\<le> Max (f ` set xs)", "have \"max (f x) (Max (f ` set xs)) = Max (f ` set xs)\""], ["proof (prove)\nusing this:\n  f x \\<le> Max (f ` set xs)\n\ngoal (1 subgoal):\n 1. max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "using 0 2"], ["proof (prove)\nusing this:\n  f x \\<le> Max (f ` set xs)\n  f x < l\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "by (auto intro!: simp add: max_def)"], ["proof (state)\nthis:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n\ngoal (2 subgoals):\n 1. f x < l \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})\n 2. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)", "show ?case"], ["proof (prove)\nusing this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "using 0 1 2"], ["proof (prove)\nusing this:\n  max (f x) (Max (f ` set xs)) = Max (f ` set xs)\n  f x < l\n  set xs \\<noteq> {}\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "by (subst lsteps.simps) (auto)"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up 0 + up * l =\n  up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "assume \"f x > l\""], ["proof (state)\nthis:\n  l < f x\n\ngoal (1 subgoal):\n 1. l < f x \\<Longrightarrow>\n    lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "then"], ["proof (chain)\npicking this:\n  l < f x", "show ?case"], ["proof (prove)\nusing this:\n  l < f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "using 2"], ["proof (prove)\nusing this:\n  l < f x\n  \\<lbrakk>f x < l; \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; l < f x;\n   \\<exists>x\\<in>set (x # xs). l + 1 \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps (x # xs) f (l + 1) up 0 + up * (l + 1) =\n                    up * Max (f ` set (x # xs) \\<union> {0})\n  \\<lbrakk>\\<not> f x < l; \\<not> l < f x;\n   \\<exists>x\\<in>set xs. l \\<le> f x\\<rbrakk>\n  \\<Longrightarrow> lsteps xs f l up 0 + up * l =\n                    up * Max (f ` set xs \\<union> {0})\n  \\<exists>x\\<in>set (x # xs). l \\<le> f x\n\ngoal (1 subgoal):\n 1. lsteps (x # xs) f l up 0 + up * l =\n    up * Max (f ` set (x # xs) \\<union> {0})", "by (subst lsteps.simps) auto"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up 0 + up * l =\n  up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lsteps (x # xs) f l up 0 + up * l =\n  up * Max (f ` set (x # xs) \\<union> {0})\n\ngoal (1 subgoal):\n 1. \\<And>f l up.\n       \\<exists>x\\<in>set []. l \\<le> f x \\<Longrightarrow>\n       lsteps [] f l up 0 + up * l = up * Max (f ` set [] \\<union> {0})", "qed (simp)"], ["", "lemma steps_height:\n  assumes \"finite A\"\n  shows   \"steps A f 0 up 0 = up * Max\\<^sub>0 (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "have \"steps A f 0 up 0 = lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0", "by (subst steps_lsteps) simp"], ["proof (state)\nthis:\n  steps A f 0 up 0 = lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0\n\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "also"], ["proof (state)\nthis:\n  steps A f 0 up 0 = lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0\n\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "have \"\\<dots> = up * Max (f ` A \\<union> {0})\" if \"A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0 =\n    up * Max (f ` A \\<union> {0})", "using assms that"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0 =\n    up * Max (f ` A \\<union> {0})", "by (subst lsteps_height) auto"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<Longrightarrow>\n  lsteps (rev (sorted_list_of_set A)) f 0 up 0 + up * 0 =\n  up * Max (f ` A \\<union> {0})\n\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "finally"], ["proof (chain)\npicking this:\n  A \\<noteq> {} \\<Longrightarrow>\n  steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<Longrightarrow>\n  steps A f 0 up 0 = up * Max (f ` A \\<union> {0})\n\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "using assms"], ["proof (prove)\nusing this:\n  A \\<noteq> {} \\<Longrightarrow>\n  steps A f 0 up 0 = up * Max (f ` A \\<union> {0})\n  finite A\n\ngoal (1 subgoal):\n 1. steps A f 0 up 0 = up * Max (f ` A \\<union> {0})", "by (cases \"A = {}\") (auto)"], ["proof (state)\nthis:\n  steps A f 0 up 0 = up * Max (f ` A \\<union> {0})\n\ngoal:\nNo subgoals!", "qed"], ["", "context random_skip_list\nbegin"], ["", "text \\<open>\n  We can now define the pmf describing the length of the search path in a skip list.\n  Like the height it only depends on the number of elements in the skip list's underlying set.\n\\<close>"], ["", "definition R where \"R A u l = map_pmf (\\<lambda>f. steps A f 0 u l) (SL A)\""], ["", "definition R\\<^sub>N :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat pmf\" where \"R\\<^sub>N n u l = R {..<n} u l\""], ["", "lemma R\\<^sub>N_alt_def: \"R\\<^sub>N n u l = map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)", "unfolding SL\\<^sub>N_def R\\<^sub>N_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL {..<n}) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL {..<n})", "by simp"], ["", "context includes monad_normalisation\nbegin"], ["", "lemma R_R\\<^sub>N:\n  assumes \"finite A\" \"p \\<in> {0..1}\"\n  shows \"R A u l = R\\<^sub>N (card A) u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "let ?steps = \"\\<lambda>A f. steps A f 0 u l\""], ["proof (state)\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "let ?f' = \"bij_mono_map_set_to_nat A\""], ["proof (state)\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "have \"R A u l = SL A \\<bind> (\\<lambda>f. return_pmf (?steps A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R A u l = SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l))", "unfolding R_def map_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>x. return_pmf (steps A x 0 u l)) =\n    SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l))", "by simp"], ["proof (state)\nthis:\n  R A u l = SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "also"], ["proof (state)\nthis:\n  R A u l = SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "have \"\\<dots> = SL\\<^sub>N (card A) \\<bind> (\\<lambda>f. return_pmf (?steps A (f \\<circ> ?f')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "have \"?f' x \\<notin> {..<card A}\" if \"x \\<notin> A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_mono_map_set_to_nat A x \\<notin> {..<card A}", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. bij_mono_map_set_to_nat A x \\<notin> {..<card A}", "unfolding bij_mono_map_set_to_nat_def"], ["proof (prove)\nusing this:\n  x \\<notin> A\n\ngoal (1 subgoal):\n 1. (if x \\<in> A\n     then the_inv_into {..<card A} ((!) (sorted_list_of_set A)) x\n     else card A)\n    \\<notin> {..<card A}", "by (auto)"], ["proof (state)\nthis:\n  ?x4 \\<notin> A \\<Longrightarrow>\n  bij_mono_map_set_to_nat A ?x4 \\<notin> {..<card A}\n\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "then"], ["proof (chain)\npicking this:\n  ?x4 \\<notin> A \\<Longrightarrow>\n  bij_mono_map_set_to_nat A ?x4 \\<notin> {..<card A}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x4 \\<notin> A \\<Longrightarrow>\n  bij_mono_map_set_to_nat A ?x4 \\<notin> {..<card A}\n\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "using assms bij_mono_map_set_to_nat"], ["proof (prove)\nusing this:\n  ?x4 \\<notin> A \\<Longrightarrow>\n  bij_mono_map_set_to_nat A ?x4 \\<notin> {..<card A}\n  finite A\n  p \\<in> {0..1}\n  finite ?A \\<Longrightarrow>\n  bij_betw (bij_mono_map_set_to_nat ?A) ?A {..<card ?A}\n  finite ?A \\<Longrightarrow> mono_on (bij_mono_map_set_to_nat ?A) ?A\n  finite ?A \\<Longrightarrow> bij_mono_map_set_to_nat ?A ` ?A = {..<card ?A}\n\ngoal (1 subgoal):\n 1. SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "unfolding SL_def SL\\<^sub>N_def"], ["proof (prove)\nusing this:\n  ?x4 \\<notin> A \\<Longrightarrow>\n  bij_mono_map_set_to_nat A ?x4 \\<notin> {..<card A}\n  finite A\n  p \\<in> {0..1}\n  finite ?A \\<Longrightarrow>\n  bij_betw (bij_mono_map_set_to_nat ?A) ?A {..<card ?A}\n  finite ?A \\<Longrightarrow> mono_on (bij_mono_map_set_to_nat ?A) ?A\n  finite ?A \\<Longrightarrow> bij_mono_map_set_to_nat ?A ` ?A = {..<card ?A}\n\ngoal (1 subgoal):\n 1. Pi_pmf A 0 (\\<lambda>_. geometric_pmf p) \\<bind>\n    (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n    Pi_pmf {..<card A} 0 (\\<lambda>_. geometric_pmf p) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))", "by (subst Pi_pmf_bij_betw[of _ ?f' \"{..<card A}\"])\n        (auto simp add: map_pmf_def)"], ["proof (state)\nthis:\n  SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f.\n      return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f.\n      return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "also"], ["proof (state)\nthis:\n  SL A \\<bind> (\\<lambda>f. return_pmf (steps A f 0 u l)) =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f.\n      return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "have \"\\<dots> = SL\\<^sub>N (card A) \\<bind> (\\<lambda>f. return_pmf (?steps {..<card A} f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))", "using assms bij_mono_map_set_to_nat bij_betw_def"], ["proof (prove)\nusing this:\n  finite A\n  p \\<in> {0..1}\n  finite ?A \\<Longrightarrow>\n  bij_betw (bij_mono_map_set_to_nat ?A) ?A {..<card ?A}\n  finite ?A \\<Longrightarrow> mono_on (bij_mono_map_set_to_nat ?A) ?A\n  finite ?A \\<Longrightarrow> bij_mono_map_set_to_nat ?A ` ?A = {..<card ?A}\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f.\n        return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l)) =\n    SL\\<^sub>N (card A) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))", "by (subst steps_image) (fastforce)+"], ["proof (state)\nthis:\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f.\n      return_pmf (steps A (f \\<circ> bij_mono_map_set_to_nat A) 0 u l)) =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "finally"], ["proof (chain)\npicking this:\n  R A u l =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))", "show ?thesis"], ["proof (prove)\nusing this:\n  R A u l =\n  SL\\<^sub>N (card A) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))\n\ngoal (1 subgoal):\n 1. R A u l = R\\<^sub>N (card A) u l", "unfolding R\\<^sub>N_def R_def SL\\<^sub>N_def SL_def"], ["proof (prove)\nusing this:\n  map_pmf (\\<lambda>f. steps A f 0 u l)\n   (Pi_pmf A 0 (\\<lambda>_. geometric_pmf p)) =\n  Pi_pmf {..<card A} 0 (\\<lambda>_. geometric_pmf p) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<card A} f 0 u l))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps A f 0 u l)\n     (Pi_pmf A 0 (\\<lambda>_. geometric_pmf p)) =\n    map_pmf (\\<lambda>f. steps {..<card A} f 0 u l)\n     (Pi_pmf {..<card A} 0 (\\<lambda>_. geometric_pmf p))", "by (simp add: map_pmf_def)"], ["proof (state)\nthis:\n  R A u l = R\\<^sub>N (card A) u l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  @{const R\\<^sub>N} fulfills a recurrence relation. If we move up or to the left the ``remaining'' length of the\n  search path is again a slightly different probability distribution over the length.\n\\<close>"], ["", "lemma R\\<^sub>N_recurrence:\n  assumes \"0 < n\" \"p \\<in> {0<..1}\"\n  shows   \"R\\<^sub>N n u l =\n             do {\n               b \\<leftarrow> bernoulli_pmf p;\n               if b then               \\<comment> \\<open>leftwards\\<close>\n                 map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n               else do {               \\<comment> \\<open>upwards\\<close>\n                 m \\<leftarrow> binomial_pmf (n - 1) (1 - p);\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)\n               }\n             }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "define B where \"B = (\\<lambda>b. insert (n-1) {x \\<in> {..<n - 1}. \\<not> b x})\""], ["proof (state)\nthis:\n  B = (\\<lambda>b. insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x})\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"R\\<^sub>N n u l = map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)", "by (auto simp add: R\\<^sub>N_def R_def SL\\<^sub>N_def)"], ["proof (state)\nthis:\n  R\\<^sub>N n u l =\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  R\\<^sub>N n u l =\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> = map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n                          (map_pmf (\\<lambda>(y, f). f(n-1 := y)) (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))", "have \"{..<n} = insert (n - Suc 0) {..<n - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<n} = insert (n - Suc 0) {..<n - 1}", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. {..<n} = insert (n - Suc 0) {..<n - 1}", "by force"], ["proof (state)\nthis:\n  {..<n} = insert (n - Suc 0) {..<n - 1}\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))", "then"], ["proof (chain)\npicking this:\n  {..<n} = insert (n - Suc 0) {..<n - 1}", "have \"(Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p)) =\n                map_pmf (\\<lambda>(y, f). f(n - 1 := y)) (pair_pmf (geometric_pmf p)\n                     (Pi_pmf {..<n-1} 0 (\\<lambda>_. geometric_pmf p)))\""], ["proof (prove)\nusing this:\n  {..<n} = insert (n - Suc 0) {..<n - 1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p) =\n    map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p)\n       (Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p)))", "using assms"], ["proof (prove)\nusing this:\n  {..<n} = insert (n - Suc 0) {..<n - 1}\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p) =\n    map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p)\n       (Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p)))", "by (subst Pi_pmf_insert[of \"{..<n-1}\" \"n-1\" 0 \"\\<lambda>_. geometric_pmf p\", symmetric])  (auto)"], ["proof (state)\nthis:\n  Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p) =\n  map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n   (pair_pmf (geometric_pmf p)\n     (Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p)))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))", "then"], ["proof (chain)\npicking this:\n  Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p) =\n  map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n   (pair_pmf (geometric_pmf p)\n     (Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p) =\n  map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n   (pair_pmf (geometric_pmf p)\n     (Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p)))\n\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n    map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))", "by (simp add: SL\\<^sub>N_def SL_def)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n   (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n   (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n) =\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n   (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n        do { g \\<leftarrow> geometric_pmf p;\n             f \\<leftarrow> SL\\<^sub>N (n - 1);\n             return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n     (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n       (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1)))) =\n    geometric_pmf p \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))", "by (simp add: case_prod_beta map_pmf_def pair_pmf_def)"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n   (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1)))) =\n  geometric_pmf p \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>f. steps {..<n} f 0 u l)\n   (map_pmf (\\<lambda>(y, f). f(n - 1 := y))\n     (pair_pmf (geometric_pmf p) (SL\\<^sub>N (n - 1)))) =\n  geometric_pmf p \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n        do { b \\<leftarrow>  bernoulli_pmf p;\n             g \\<leftarrow> if b then return_pmf 0 else map_pmf Suc (geometric_pmf p);\n             f \\<leftarrow> SL\\<^sub>N (n - 1);\n             return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geometric_pmf p \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>g.\n            SL\\<^sub>N (n - 1) \\<bind>\n            (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. geometric_pmf p \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>g.\n            SL\\<^sub>N (n - 1) \\<bind>\n            (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "by (subst geometric_bind_pmf_unfold) (auto)"], ["proof (state)\nthis:\n  geometric_pmf p \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>g.\n          SL\\<^sub>N (n - 1) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  geometric_pmf p \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>g.\n          SL\\<^sub>N (n - 1) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n        do { b \\<leftarrow> bernoulli_pmf p;\n             if b\n               then do { g \\<leftarrow> return_pmf 0;\n                         f \\<leftarrow> SL\\<^sub>N (n - 1);\n                         return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l) }\n               else do { g \\<leftarrow> map_pmf Suc (geometric_pmf p);\n                         f \\<leftarrow> SL\\<^sub>N (n - 1);\n                         return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l) }}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>g.\n            SL\\<^sub>N (n - 1) \\<bind>\n            (\\<lambda>f.\n                return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b\n        then return_pmf 0 \\<bind>\n             (\\<lambda>g.\n                 SL\\<^sub>N (n - 1) \\<bind>\n                 (\\<lambda>f.\n                     return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n        else map_pmf Suc (geometric_pmf p) \\<bind>\n             (\\<lambda>g.\n                 SL\\<^sub>N (n - 1) \\<bind>\n                 (\\<lambda>f.\n                     return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "by (subst bind_pmf_if') (auto)"], ["proof (state)\nthis:\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>g.\n          SL\\<^sub>N (n - 1) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      if b\n      then return_pmf 0 \\<bind>\n           (\\<lambda>g.\n               SL\\<^sub>N (n - 1) \\<bind>\n               (\\<lambda>f.\n                   return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n      else map_pmf Suc (geometric_pmf p) \\<bind>\n           (\\<lambda>g.\n               SL\\<^sub>N (n - 1) \\<bind>\n               (\\<lambda>f.\n                   return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      (if b then return_pmf 0 else map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>g.\n          SL\\<^sub>N (n - 1) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      if b\n      then return_pmf 0 \\<bind>\n           (\\<lambda>g.\n               SL\\<^sub>N (n - 1) \\<bind>\n               (\\<lambda>f.\n                   return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n      else map_pmf Suc (geometric_pmf p) \\<bind>\n           (\\<lambda>g.\n               SL\\<^sub>N (n - 1) \\<bind>\n               (\\<lambda>f.\n                   return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"do { g \\<leftarrow> return_pmf 0;\n                       f \\<leftarrow> SL\\<^sub>N (n - 1);\n                       return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l) }  =\n              do { f \\<leftarrow> SL\\<^sub>N (n - 1);\n                        return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf 0 \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l))", "by (subst bind_return_pmf) auto"], ["proof (state)\nthis:\n  return_pmf 0 \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  SL\\<^sub>N (n - 1) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  return_pmf 0 \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  SL\\<^sub>N (n - 1) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> = map_pmf (\\<lambda>n. n + l) (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "have I: \"{..<n} - {n - Suc 0} = {..<n - Suc 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<n} - {n - Suc 0} = {..<n - Suc 0}", "by fastforce"], ["proof (state)\nthis:\n  {..<n} - {n - Suc 0} = {..<n - Suc 0}\n\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "have \"Max {..<n} = n - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {..<n} = n - Suc 0", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Max {..<n} = n - Suc 0", "by (intro Max_eqI) (auto)"], ["proof (state)\nthis:\n  Max {..<n} = n - Suc 0\n\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "then"], ["proof (chain)\npicking this:\n  Max {..<n} = n - Suc 0", "have \"steps {..<n} (f(n - 1 := 0)) 0 u l = l + steps {..<n - 1} f 0 u l\" for f"], ["proof (prove)\nusing this:\n  Max {..<n} = n - Suc 0\n\ngoal (1 subgoal):\n 1. steps {..<n} (f(n - 1 := 0)) 0 u l = l + steps {..<n - 1} f 0 u l", "using assms"], ["proof (prove)\nusing this:\n  Max {..<n} = n - Suc 0\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. steps {..<n} (f(n - 1 := 0)) 0 u l = l + steps {..<n - 1} f 0 u l", "by (subst steps.simps) (auto intro!: steps_cong simp add: I simp add: Let_def)"], ["proof (state)\nthis:\n  steps {..<n} (?f3(n - 1 := 0)) 0 u l = l + steps {..<n - 1} ?f3 0 u l\n\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "then"], ["proof (chain)\npicking this:\n  steps {..<n} (?f3(n - 1 := 0)) 0 u l = l + steps {..<n - 1} ?f3 0 u l", "show ?thesis"], ["proof (prove)\nusing this:\n  steps {..<n} (?f3(n - 1 := 0)) 0 u l = l + steps {..<n - 1} ?f3 0 u l\n\ngoal (1 subgoal):\n 1. SL\\<^sub>N (n - 1) \\<bind>\n    (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))", "by (auto simp add: add_ac map_pmf_def)"], ["proof (state)\nthis:\n  SL\\<^sub>N (n - 1) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n  map_pmf (\\<lambda>n. n + l)\n   (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SL\\<^sub>N (n - 1) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n  map_pmf (\\<lambda>n. n + l)\n   (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  SL\\<^sub>N (n - 1) \\<bind>\n  (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := 0)) 0 u l)) =\n  map_pmf (\\<lambda>n. n + l)\n   (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> = map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1))) =\n    map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)", "unfolding R\\<^sub>N_def R_def SL\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL {..<n - 1})) =\n    map_pmf (\\<lambda>n. n + l)\n     (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL {..<n - 1}))", "by simp"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>n. n + l)\n   (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1))) =\n  map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>n. n + l)\n   (map_pmf (\\<lambda>f. steps {..<n - 1} f 0 u l) (SL\\<^sub>N (n - 1))) =\n  map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"map_pmf Suc (geometric_pmf p) \\<bind>\n             (\\<lambda>g. SL\\<^sub>N (n - 1) \\<bind>\n             (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))\n             =\n             Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n             (\\<lambda>b. map_pmf Suc (geometric_pmf p) \\<bind>\n             (\\<lambda>g. Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n             (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf Suc (geometric_pmf p) \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        map_pmf Suc (geometric_pmf p) \\<bind>\n        (\\<lambda>g.\n            Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n             (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n            (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. map_pmf Suc (geometric_pmf p) \\<bind>\n    (\\<lambda>g.\n        SL\\<^sub>N (n - 1) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        map_pmf Suc (geometric_pmf p) \\<bind>\n        (\\<lambda>g.\n            Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n             (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n            (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "unfolding SL\\<^sub>N_def SL_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. map_pmf Suc (geometric_pmf p) \\<bind>\n    (\\<lambda>g.\n        Pi_pmf {..<n - 1} 0 (\\<lambda>_. geometric_pmf p) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        map_pmf Suc (geometric_pmf p) \\<bind>\n        (\\<lambda>g.\n            Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n             (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n            (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))", "by (subst Pi_pmf_geometric_filter) (auto)"], ["proof (state)\nthis:\n  map_pmf Suc (geometric_pmf p) \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      map_pmf Suc (geometric_pmf p) \\<bind>\n      (\\<lambda>g.\n          Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n           (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  map_pmf Suc (geometric_pmf p) \\<bind>\n  (\\<lambda>g.\n      SL\\<^sub>N (n - 1) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      map_pmf Suc (geometric_pmf p) \\<bind>\n      (\\<lambda>g.\n          Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n           (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l))))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n             do {\n             b \\<leftarrow> Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p);\n             f \\<leftarrow> Pi_pmf (insert (n-1) {x \\<in> {..<n - 1}. \\<not> b x}) 0 (\\<lambda>_. map_pmf Suc (geometric_pmf p));\n             return_pmf (steps {..<n} f 0 u l)}\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        map_pmf Suc (geometric_pmf p) \\<bind>\n        (\\<lambda>g.\n            Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n             (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n            (\\<lambda>f.\n                return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n         (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} f 0 u l)))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        map_pmf Suc (geometric_pmf p) \\<bind>\n        (\\<lambda>g.\n            Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n             (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n            (\\<lambda>f.\n                return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n         (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} f 0 u l)))", "by (subst Pi_pmf_insert') (auto)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      map_pmf Suc (geometric_pmf p) \\<bind>\n      (\\<lambda>g.\n          Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n           (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n       (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} f 0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      map_pmf Suc (geometric_pmf p) \\<bind>\n      (\\<lambda>g.\n          Pi_pmf {x \\<in> {..<n - 1}. \\<not> b x} 0\n           (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n          (\\<lambda>f. return_pmf (steps {..<n} (f(n - 1 := g)) 0 u l)))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n       (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} f 0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n             do {\n               b \\<leftarrow> Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p);\n               f \\<leftarrow> Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p));\n               return_pmf (steps {..<n} (\\<lambda>x. if x \\<in> (B b) then f x else 0) 0 u l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n         (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f. return_pmf (steps {..<n} f 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l)))", "by (subst Pi_pmf_default_swap[symmetric, of _ _ _ 1]) (auto simp add: map_pmf_def B_def)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n       (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} f 0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n             l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) 0\n       (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f. return_pmf (steps {..<n} f 0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n             l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n             do {\n               b \\<leftarrow> Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p);\n               f \\<leftarrow> SL (B b);\n               return_pmf (steps {..<n} (\\<lambda>x. if x \\<in> (B b) then Suc (f x) else 0) 0 u l)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l)))", "have *: \"(Suc \\<circ> f) x = Suc (f x)\" for x and f::\"nat \\<Rightarrow> nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc \\<circ> f) x = Suc (f x)", "by simp"], ["proof (state)\nthis:\n  (Suc \\<circ> ?f3) ?x3 = Suc (?f3 ?x3)\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l)))", "have \"(\\<lambda>f. return_pmf (steps {..<n} (\\<lambda>x. if x \\<in> B b then (Suc \\<circ> f) x else 0) 0 u l)) =\n          (\\<lambda>f. return_pmf (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l))\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        return_pmf\n         (steps {..<n}\n           (\\<lambda>x. if x \\<in> B b then (Suc \\<circ> f) x else 0) 0 u\n           l)) =\n    (\\<lambda>f.\n        return_pmf\n         (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0\n           u l))", "by (subst *) (simp)"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n}\n         (\\<lambda>x. if x \\<in> B ?b3 then (Suc \\<circ> f) x else 0) 0 u\n         l)) =\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (f x) else 0) 0\n         u l))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l)))", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n}\n         (\\<lambda>x. if x \\<in> B ?b3 then (Suc \\<circ> f) x else 0) 0 u\n         l)) =\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (f x) else 0) 0\n         u l))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n}\n         (\\<lambda>x. if x \\<in> B ?b3 then (Suc \\<circ> f) x else 0) 0 u\n         l)) =\n  (\\<lambda>f.\n      return_pmf\n       (steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (f x) else 0) 0\n         u l))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n               l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l)))", "by (subst Pi_pmf_map[of _ _ 0]) (auto simp add: map_pmf_def B_def SL_def)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n             l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n             l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      Pi_pmf (B b) 1 (\\<lambda>_. map_pmf Suc (geometric_pmf p)) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then f x else 0) 0 u\n             l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> =\n               do {\n               b \\<leftarrow> Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p);\n               r \\<leftarrow> R (B b) u l;\n               return_pmf (u + r)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "have \"steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l = u + steps (B b) f 0 u l\"\n      for f b"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "have \"Max {..<n} = n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {..<n} = n - 1", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Max {..<n} = n - 1", "by (intro Max_eqI) auto"], ["proof (state)\nthis:\n  Max {..<n} = n - 1\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "then"], ["proof (chain)\npicking this:\n  Max {..<n} = n - 1", "have \"steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n              u + (steps {..<n} (\\<lambda>x. if x \\<in> (B b) then Suc (f x) else 0) 1 u l)\""], ["proof (prove)\nusing this:\n  Max {..<n} = n - 1\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u +\n    steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l", "unfolding B_def"], ["proof (prove)\nusing this:\n  Max {..<n} = n - 1\n\ngoal (1 subgoal):\n 1. steps {..<n}\n     (\\<lambda>x.\n         if x \\<in> insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}\n         then Suc (f x) else 0)\n     0 u l =\n    u +\n    steps {..<n}\n     (\\<lambda>x.\n         if x \\<in> insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}\n         then Suc (f x) else 0)\n     1 u l", "using assms"], ["proof (prove)\nusing this:\n  Max {..<n} = n - 1\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. steps {..<n}\n     (\\<lambda>x.\n         if x \\<in> insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}\n         then Suc (f x) else 0)\n     0 u l =\n    u +\n    steps {..<n}\n     (\\<lambda>x.\n         if x \\<in> insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}\n         then Suc (f x) else 0)\n     1 u l", "by (subst steps.simps) (auto simp add: Let_def)"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n  u + steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "also"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n  u + steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "have \"steps {..<n} (\\<lambda>x. if x \\<in> (B b) then Suc (f x) else 0) 1 u l =\n                   steps (B b) (\\<lambda>x. if x \\<in> (B b) then Suc (f x) else 0) 1 u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n    steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n    steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l", "have \"{x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. {x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b", "unfolding B_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. {x \\<in> {..<n}.\n     1 \\<le> (if x \\<in> insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}\n              then Suc (f x) else 0)} =\n    insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}", "by force"], ["proof (state)\nthis:\n  {x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n    steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l", "then"], ["proof (chain)\npicking this:\n  {x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b", "show ?thesis"], ["proof (prove)\nusing this:\n  {x \\<in> {..<n}. 1 \\<le> (if x \\<in> B b then Suc (f x) else 0)} = B b\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n    steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l", "by (subst steps_smaller_set[of _ 1]) auto"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n  steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n  steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "also"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n  steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "have \"\\<dots> = steps (B b) (\\<lambda>x. f x + 1) 1 u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n    steps (B b) (\\<lambda>x. f x + 1) 1 u l", "by (rule steps_cong) (auto)"], ["proof (state)\nthis:\n  steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n  steps (B b) (\\<lambda>x. f x + 1) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "also"], ["proof (state)\nthis:\n  steps (B b) (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 1 u l =\n  steps (B b) (\\<lambda>x. f x + 1) 1 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "have \"\\<dots> = steps (B b) f 0 u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (B b) (\\<lambda>x. f x + 1) 1 u l = steps (B b) f 0 u l", "by (subst (2) steps_f_add'[of _ _ _ _ _ 1]) simp"], ["proof (state)\nthis:\n  steps (B b) (\\<lambda>x. f x + 1) 1 u l = steps (B b) f 0 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "finally"], ["proof (chain)\npicking this:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n  u + steps (B b) f 0 u l", "show ?thesis"], ["proof (prove)\nusing this:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n  u + steps (B b) f 0 u l\n\ngoal (1 subgoal):\n 1. steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n    u + steps (B b) f 0 u l", "by auto"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l =\n  u + steps (B b) f 0 u l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (?f3 x) else 0) 0 u\n   l =\n  u + steps (B ?b3) ?f3 0 u l\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "then"], ["proof (chain)\npicking this:\n  steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (?f3 x) else 0) 0 u\n   l =\n  u + steps (B ?b3) ?f3 0 u l", "show ?thesis"], ["proof (prove)\nusing this:\n  steps {..<n} (\\<lambda>x. if x \\<in> B ?b3 then Suc (?f3 x) else 0) 0 u\n   l =\n  u + steps (B ?b3) ?f3 0 u l\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        SL (B b) \\<bind>\n        (\\<lambda>f.\n            return_pmf\n             (steps {..<n}\n               (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0) 0 u l))) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "by (simp add: R_def map_pmf_def)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b.\n      SL (B b) \\<bind>\n      (\\<lambda>f.\n          return_pmf\n           (steps {..<n} (\\<lambda>x. if x \\<in> B b then Suc (f x) else 0)\n             0 u l))) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> = do {\n                   b \\<leftarrow> Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p));\n                   let m = 1 + card {x. x < n - 1 \\<and> b x};\n                   r \\<leftarrow> R {..<m} u l;\n                   return_pmf (u + r)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "have *: \"card (insert (n - Suc 0) {x. x < n - 1 \\<and> b x}) =\n              (Suc (card {x. x < n - 1 \\<and> b x}))\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert (n - Suc 0) {x. x < n - 1 \\<and> b x}) =\n    Suc (card {x. x < n - 1 \\<and> b x})", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. card (insert (n - Suc 0) {x. x < n - 1 \\<and> b x}) =\n    Suc (card {x. x < n - 1 \\<and> b x})", "by (auto simp add: card_insert_if)"], ["proof (state)\nthis:\n  card (insert (n - Suc 0) {x. x < n - 1 \\<and> ?b3 x}) =\n  Suc (card {x. x < n - 1 \\<and> ?b3 x})\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "have \"Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n              Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p)))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n    Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p)))", "by (subst bernoulli_pmf_Not) auto"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p)))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p)))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "have \"\\<dots> = map_pmf ((\\<circ>) Not) (Pi_pmf {..<n - 1}  False (\\<lambda>_. bernoulli_pmf (1 - p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True\n     (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p))) =\n    map_pmf ((\\<circ>) Not)\n     (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True\n     (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p))) =\n    map_pmf ((\\<circ>) Not)\n     (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))", "by (subst Pi_pmf_map[of _ _ False]) auto"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. map_pmf Not (bernoulli_pmf (1 - p))) =\n  map_pmf ((\\<circ>) Not)\n   (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "finally"], ["proof (chain)\npicking this:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  map_pmf ((\\<circ>) Not)\n   (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  map_pmf ((\\<circ>) Not)\n   (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "unfolding B_def"], ["proof (prove)\nusing this:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  map_pmf ((\\<circ>) Not)\n   (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        R (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) u l \\<bind>\n        (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "using assms *"], ["proof (prove)\nusing this:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) =\n  map_pmf ((\\<circ>) Not)\n   (Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)))\n  0 < n\n  p \\<in> {0<..1}\n  card (insert (n - Suc 0) {x. x < n - 1 \\<and> ?b3 x}) =\n  Suc (card {x. x < n - 1 \\<and> ?b3 x})\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n    (\\<lambda>b.\n        R (insert (n - 1) {x \\<in> {..<n - 1}. \\<not> b x}) u l \\<bind>\n        (\\<lambda>r. return_pmf (u + r))) =\n    Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))", "by (subst R_R\\<^sub>N) (auto simp add: R_R\\<^sub>N map_pmf_def)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n  Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n  (\\<lambda>b.\n      let m = 1 + card {x. x < n - 1 \\<and> b x}\n      in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n  Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n  (\\<lambda>b.\n      let m = 1 + card {x. x < n - 1 \\<and> b x}\n      in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "also"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} True (\\<lambda>_. bernoulli_pmf p) \\<bind>\n  (\\<lambda>b. R (B b) u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n  Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n  (\\<lambda>b.\n      let m = 1 + card {x. x < n - 1 \\<and> b x}\n      in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "have \"\\<dots> = binomial_pmf (n - 1) (1 - p) \\<bind> (\\<lambda>m. map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    binomial_pmf (n - 1) (1 - p) \\<bind>\n    (\\<lambda>m. map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..1}\n\ngoal (1 subgoal):\n 1. Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n    (\\<lambda>b.\n        let m = 1 + card {x. x < n - 1 \\<and> b x}\n        in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n    binomial_pmf (n - 1) (1 - p) \\<bind>\n    (\\<lambda>m. map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l))", "by (subst binomial_pmf_altdef'[where A = \"{..<n - 1}\" and dflt = \"False\"])\n      (auto simp add: R\\<^sub>N_def R_def SL_def map_pmf_def ac_simps)"], ["proof (state)\nthis:\n  Pi_pmf {..<n - 1} False (\\<lambda>_. bernoulli_pmf (1 - p)) \\<bind>\n  (\\<lambda>b.\n      let m = 1 + card {x. x < n - 1 \\<and> b x}\n      in R {..<m} u l \\<bind> (\\<lambda>r. return_pmf (u + r))) =\n  binomial_pmf (n - 1) (1 - p) \\<bind>\n  (\\<lambda>m. map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "finally"], ["proof (chain)\npicking this:\n  R\\<^sub>N n u l =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n      else binomial_pmf (n - 1) (1 - p) \\<bind>\n           (\\<lambda>m.\n               map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "show ?thesis"], ["proof (prove)\nusing this:\n  R\\<^sub>N n u l =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n      else binomial_pmf (n - 1) (1 - p) \\<bind>\n           (\\<lambda>m.\n               map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))\n\ngoal (1 subgoal):\n 1. R\\<^sub>N n u l =\n    bernoulli_pmf p \\<bind>\n    (\\<lambda>b.\n        if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n        else binomial_pmf (n - 1) (1 - p) \\<bind>\n             (\\<lambda>m.\n                 map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))", "by simp"], ["proof (state)\nthis:\n  R\\<^sub>N n u l =\n  bernoulli_pmf p \\<bind>\n  (\\<lambda>b.\n      if b then map_pmf (\\<lambda>n. n + l) (R\\<^sub>N (n - 1) u l)\n      else binomial_pmf (n - 1) (1 - p) \\<bind>\n           (\\<lambda>m.\n               map_pmf (\\<lambda>n. n + u) (R\\<^sub>N (m + 1) u l)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context includes monad_normalisation *)"], ["", "text \\<open>\n  The expected height and length of search path defined as non-negative integral. It's easier\n  to prove the recurrence relation of the expected length of the search path using non-negative\n  integrals.\n\\<close>"], ["", "definition NH\\<^sub>N where \"NH\\<^sub>N n = nn_integral (H\\<^sub>N n) real\""], ["", "definition NR\\<^sub>N where \"NR\\<^sub>N n u l = nn_integral (R\\<^sub>N n u l) real\""], ["", "lemma NH\\<^sub>N_EH\\<^sub>N:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"NH\\<^sub>N n = EH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = ennreal (EH\\<^sub>N n)", "using assms EH\\<^sub>N_bounds"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  p \\<in> {0<..<1} \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = ennreal (EH\\<^sub>N n)", "unfolding EH\\<^sub>N_def NH\\<^sub>N_def"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  - harm ?n / ln q - 1 \\<le> measure_pmf.expectation (H\\<^sub>N ?n) real\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  measure_pmf.expectation (H\\<^sub>N ?n) real \\<le> - harm ?n / ln q\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf (H\\<^sub>N n) =\n    ennreal (measure_pmf.expectation (H\\<^sub>N n) real)", "by (subst nn_integral_eq_integral) (auto)"], ["", "lemma R\\<^sub>N_0 [simp]: \"R\\<^sub>N 0 u l = return_pmf 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sub>N 0 u l = return_pmf 0", "unfolding R\\<^sub>N_def R_def SL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>f. steps {..<0} f 0 u l)\n     (Pi_pmf {..<0} 0 (\\<lambda>_. geometric_pmf p)) =\n    return_pmf 0", "by (auto simp add: steps.simps)"], ["", "lemma NR\\<^sub>N_bounds:\n  fixes u l::nat\n  shows \"NR\\<^sub>N n u l \\<le> l * n + u * NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "have \"NR\\<^sub>N n u l = \\<integral>\\<^sup>+ x. x \\<partial>measure_pmf (R\\<^sub>N n u l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat", "unfolding NR\\<^sub>N_def R\\<^sub>N_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf\n                                  (map_pmf\n                                    (\\<lambda>f. steps {..<n} f 0 u l)\n                                    (SL\\<^sub>N n)) =\n    integral\\<^sup>N\n     (measure_pmf\n       (map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)))\n     of_nat", "by (simp add: ennreal_of_nat_eq_real_of_nat)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l = integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l = integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ x. x \\<partial>(measure_pmf (map_pmf (\\<lambda>f. l * n + u * Max\\<^sub>0 (f ` {..<n})) (SL\\<^sub>N n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n    \\<le> integral\\<^sup>N\n           (measure_pmf\n             (map_pmf\n               (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n               (SL\\<^sub>N n)))\n           of_nat", "using of_nat_mono[OF steps_smaller_card_Max_fun'[of \"{..<n}\" 0 _ u l]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {..<n}; \\<exists>x\\<in>{..<n}. 0 \\<le> ?f1 x\\<rbrakk>\n  \\<Longrightarrow> of_nat (steps {..<n} ?f1 0 u l + 0 * u)\n                    \\<le> of_nat\n                           (l * card {..<n} +\n                            u * Max (?f1 ` {..<n} \\<union> {0}))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n    \\<le> integral\\<^sup>N\n           (measure_pmf\n             (map_pmf\n               (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n               (SL\\<^sub>N n)))\n           of_nat", "unfolding R\\<^sub>N_alt_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {..<n}; \\<exists>x\\<in>{..<n}. 0 \\<le> ?f1 x\\<rbrakk>\n  \\<Longrightarrow> of_nat (steps {..<n} ?f1 0 u l + 0 * u)\n                    \\<le> of_nat\n                           (l * card {..<n} +\n                            u * Max (?f1 ` {..<n} \\<union> {0}))\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N\n     (measure_pmf\n       (map_pmf (\\<lambda>f. steps {..<n} f 0 u l) (SL\\<^sub>N n)))\n     of_nat\n    \\<le> integral\\<^sup>N\n           (measure_pmf\n             (map_pmf\n               (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n               (SL\\<^sub>N n)))\n           of_nat", "by (cases \"n = 0\") (auto intro!: nn_integral_mono)"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n  \\<le> integral\\<^sup>N\n         (measure_pmf\n           (map_pmf (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n             (SL\\<^sub>N n)))\n         of_nat\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N (measure_pmf (R\\<^sub>N n u l)) of_nat\n  \\<le> integral\\<^sup>N\n         (measure_pmf\n           (map_pmf (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n             (SL\\<^sub>N n)))\n         of_nat\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "have \"\\<dots> = l * n + u * NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N\n     (measure_pmf\n       (map_pmf (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n         (SL\\<^sub>N n)))\n     of_nat =\n    of_nat (l * n) + of_nat u * NH\\<^sub>N n", "unfolding NH\\<^sub>N_def H\\<^sub>N_def H_def SL\\<^sub>N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N\n     (measure_pmf\n       (map_pmf (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n         (SL {..<n})))\n     of_nat =\n    of_nat (l * n) +\n    of_nat u *\n    \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf\n                                  (map_pmf\n                                    (\\<lambda>f.\n  Max (f ` {..<n} \\<union> {0}))\n                                    (SL {..<n}))", "by (auto simp add: nn_integral_add nn_integral_cmult ennreal_of_nat_eq_real_of_nat ennreal_mult)"], ["proof (state)\nthis:\n  integral\\<^sup>N\n   (measure_pmf\n     (map_pmf (\\<lambda>f. l * n + u * Max (f ` {..<n} \\<union> {0}))\n       (SL\\<^sub>N n)))\n   of_nat =\n  of_nat (l * n) + of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "show \"NR\\<^sub>N n u l \\<le> l * n + u * NH\\<^sub>N n\""], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NR\\<^sub>N_recurrence:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u l = (p * (l + NR\\<^sub>N (n - 1) u l) +\n                     q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (pmf (binomial_pmf (n - 1) q) k))))\n                     / (1 - (q ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "define B where \"B = (\\<lambda>n k. pmf (binomial_pmf n q) k)\""], ["proof (state)\nthis:\n  B = (\\<lambda>n. pmf (binomial_pmf n q))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have q: \"q \\<in> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> {0<..<1}", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. q \\<in> {0<..<1}", "unfolding q_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. 1 - p \\<in> {0<..<1}", "by auto"], ["proof (state)\nthis:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "then"], ["proof (chain)\npicking this:\n  q \\<in> {0<..<1}", "have \"q ^ n < 1\""], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. q ^ n < 1", "using assms power_Suc_less_one"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n  0 < n\n  p \\<in> {0<..<1}\n  \\<lbrakk>(0::?'a) < ?a; ?a < (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a ^ Suc ?n < (1::?'a)\n\ngoal (1 subgoal):\n 1. q ^ n < 1", "by (induction n) (auto)"], ["proof (state)\nthis:\n  q ^ n < 1\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "then"], ["proof (chain)\npicking this:\n  q ^ n < 1", "have qn: \"q ^ n \\<in> {0<..<1}\""], ["proof (prove)\nusing this:\n  q ^ n < 1\n\ngoal (1 subgoal):\n 1. q ^ n \\<in> {0<..<1}", "using assms q"], ["proof (prove)\nusing this:\n  q ^ n < 1\n  0 < n\n  p \\<in> {0<..<1}\n  q \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. q ^ n \\<in> {0<..<1}", "by (auto)"], ["proof (state)\nthis:\n  q ^ n \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"NR\\<^sub>N n u l = p * (l + NR\\<^sub>N (n - 1) u l) +\n                    q * (u + \\<integral>\\<^sup>+ k. NR\\<^sub>N (k + 1) u l  \\<partial>measure_pmf (binomial_pmf (n - 1) q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n    ennreal q *\n    (of_nat u +\n     \\<integral>\\<^sup>+ k. NR\\<^sub>N (k + 1) u l\n                        \\<partial>measure_pmf (binomial_pmf (n - 1) q))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n    ennreal q *\n    (of_nat u +\n     \\<integral>\\<^sup>+ k. NR\\<^sub>N (k + 1) u l\n                        \\<partial>measure_pmf (binomial_pmf (n - 1) q))", "unfolding NR\\<^sub>N_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf (R\\<^sub>N n u l) =\n    ennreal p *\n    (of_nat l +\n     \\<integral>\\<^sup>+ x. ennreal (real x)\n                        \\<partial>measure_pmf (R\\<^sub>N (n - 1) u l)) +\n    ennreal q *\n    (of_nat u +\n     \\<integral>\\<^sup>+ k. \\<integral>\\<^sup>+ x. ennreal (real x)\n         \\<partial>measure_pmf (R\\<^sub>N (k + 1) u l)\n                        \\<partial>measure_pmf (binomial_pmf (n - 1) q))", "by(subst R\\<^sub>N_recurrence)\n      (auto simp add: field_simps nn_integral_add q_def ennreal_of_nat_eq_real_of_nat)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   \\<integral>\\<^sup>+ k. NR\\<^sub>N (k + 1) u l\n                      \\<partial>measure_pmf (binomial_pmf (n - 1) q))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   \\<integral>\\<^sup>+ k. NR\\<^sub>N (k + 1) u l\n                      \\<partial>measure_pmf (binomial_pmf (n - 1) q))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"(\\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l  \\<partial>measure_pmf (binomial_pmf (n - 1) q)) =\n    (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * B (n - 1) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l\n                       \\<partial>measure_pmf (binomial_pmf (n - 1) q) =\n    (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l\n                       \\<partial>measure_pmf (binomial_pmf (n - 1) q) =\n    (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))", "unfolding B_def q_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l\n                       \\<partial>measure_pmf\n                                  (binomial_pmf (n - 1) (1 - p)) =\n    (\\<Sum>k\\<le>n - 1.\n        NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (n - 1) (1 - p)) k))", "by (auto simp add: nn_integral_measure_pmf_finite)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l\n                     \\<partial>measure_pmf (binomial_pmf (n - 1) q) =\n  (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ m. NR\\<^sub>N (m + 1) u l\n                     \\<partial>measure_pmf (binomial_pmf (n - 1) q) =\n  (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"\\<dots> = (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}. NR\\<^sub>N (k + 1) u l * B (n - 1) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) =\n    (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n       NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))", "by (rule sum.cong) (auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) =\n  (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n     NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) =\n  (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n     NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"\\<dots> = (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * B (n - 1) k) + NR\\<^sub>N n u l * q ^ (n - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n       NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) =\n    (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1))", "unfolding B_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n       NR\\<^sub>N (k + 1) u l *\n       ennreal (pmf (binomial_pmf (n - 1) (1 - p)) k)) =\n    (\\<Sum>k<n - 1.\n        NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (n - 1) (1 - p)) k)) +\n    NR\\<^sub>N n u l * ennreal ((1 - p) ^ (n - 1))", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n       NR\\<^sub>N (k + 1) u l *\n       ennreal (pmf (binomial_pmf (n - 1) (1 - p)) k)) =\n    (\\<Sum>k<n - 1.\n        NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (n - 1) (1 - p)) k)) +\n    NR\\<^sub>N n u l * ennreal ((1 - p) ^ (n - 1))", "by (subst sum.union_disjoint) (auto)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>{..<n - 1} \\<union> {n - 1}.\n     NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) =\n  (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n  NR\\<^sub>N n u l * ennreal (q ^ (n - 1))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1))))", "have \"NR\\<^sub>N n u l = p * (l + NR\\<^sub>N (n - 1) u l) +\n                            q * ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * B (n - 1) k) + u) +\n                            NR\\<^sub>N n u l * (q ^ (n - 1)) * q\""], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1))))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n    ennreal q *\n    ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n     of_nat u) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q", "using assms"], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1))))\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n    ennreal q *\n    ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n     of_nat u) +\n    NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q", "by (auto simp add: field_simps numerals)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n   of_nat u) +\n  NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n   of_nat u) +\n  NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"NR\\<^sub>N n u l * (q ^ (n - 1)) * q = (q ^ n) * NR\\<^sub>N n u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q =\n    ennreal (q ^ n) * NR\\<^sub>N n u l", "using q power_minus_mult[of _ q] assms"], ["proof (prove)\nusing this:\n  q \\<in> {0<..<1}\n  0 < ?n \\<Longrightarrow> q ^ (?n - 1) * q = q ^ ?n\n  0 < n\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q =\n    ennreal (q ^ n) * NR\\<^sub>N n u l", "by (subst mult_ac, subst ennreal_mult[symmetric], auto simp add: mult_ac)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l * ennreal (q ^ (n - 1)) * ennreal q =\n  ennreal (q ^ n) * NR\\<^sub>N n u l\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n   of_nat u) +\n  ennreal (q ^ n) * NR\\<^sub>N n u l", "have 1: \"NR\\<^sub>N n u l = p * (l + NR\\<^sub>N (n - 1) u l) +\n                               q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (B (n - 1) k))) +\n                               (q ^ n) * NR\\<^sub>N n u l \""], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  ((\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)) +\n   of_nat u) +\n  ennreal (q ^ n) * NR\\<^sub>N n u l\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n    ennreal q *\n    (of_nat u +\n     (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))) +\n    ennreal (q ^ n) * NR\\<^sub>N n u l", "by (simp add: add_ac)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))) +\n  ennreal (q ^ n) * NR\\<^sub>N n u l\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"x - z = y\" if \"x = y + z\" \"z \\<noteq> \\<top>\" for x y z::ennreal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - z = y", "using that"], ["proof (prove)\nusing this:\n  x = y + z\n  z \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. x - z = y", "by (subst that) (auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 = ?y3 + ?z3; ?z3 \\<noteq> \\<top>\\<rbrakk>\n  \\<Longrightarrow> ?x3 - ?z3 = ?y3\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"NR\\<^sub>N n u l \\<le> l * n + u * NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "using NR\\<^sub>N_bounds"], ["proof (prove)\nusing this:\n  NR\\<^sub>N ?n ?u ?l \\<le> of_nat (?l * ?n) + of_nat ?u * NH\\<^sub>N ?n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n", "by (auto simp add: ennreal_of_nat_eq_real_of_nat)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l \\<le> of_nat (l * n) + of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"NH\\<^sub>N n = EH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = ennreal (EH\\<^sub>N n)", "using assms NH\\<^sub>N_EH\\<^sub>N"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  p \\<in> {0<..<1} \\<Longrightarrow> NH\\<^sub>N ?n = ennreal (EH\\<^sub>N ?n)\n\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = ennreal (EH\\<^sub>N n)", "by auto"], ["proof (state)\nthis:\n  NH\\<^sub>N n = ennreal (EH\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "also"], ["proof (state)\nthis:\n  NH\\<^sub>N n = ennreal (EH\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"(l * n) + u * ennreal (EH\\<^sub>N n) < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (l * n) + of_nat u * ennreal (EH\\<^sub>N n) < \\<top>", "by (simp add: ennreal_mult_less_top of_nat_less_top)"], ["proof (state)\nthis:\n  of_nat (l * n) + of_nat u * ennreal (EH\\<^sub>N n) < \\<top>\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u l < \\<top>", "have 3: \"NR\\<^sub>N n u l \\<noteq> \\<top>\""], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l < \\<top>\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l \\<noteq> \\<top>", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have 2: \"x = y / (1 - a)\" if \"x = y + a * x\" and t: \"x \\<noteq> \\<top>\" \"a \\<in> {0<..<1}\" for x y::ennreal\n          and a::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "have \"y = x - a * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = x - ennreal a * x", "using t"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<top>\n  a \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. y = x - ennreal a * x", "by (subst that) (auto simp add: ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  y = x - ennreal a * x\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "also"], ["proof (state)\nthis:\n  y = x - ennreal a * x\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "have \"\\<dots> = x * (ennreal 1 - ennreal a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - ennreal a * x = x * (ennreal 1 - ennreal a)", "using that"], ["proof (prove)\nusing this:\n  x = y + ennreal a * x\n  x \\<noteq> \\<top>\n  a \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. x - ennreal a * x = x * (ennreal 1 - ennreal a)", "by (auto simp add: mult_ac ennreal_right_diff_distrib)"], ["proof (state)\nthis:\n  x - ennreal a * x = x * (ennreal 1 - ennreal a)\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "also"], ["proof (state)\nthis:\n  x - ennreal a * x = x * (ennreal 1 - ennreal a)\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "have \"ennreal 1 - ennreal a = ennreal (1 - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal 1 - ennreal a = ennreal (1 - a)", "using that"], ["proof (prove)\nusing this:\n  x = y + ennreal a * x\n  x \\<noteq> \\<top>\n  a \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal 1 - ennreal a = ennreal (1 - a)", "by (subst ennreal_minus) (auto)"], ["proof (state)\nthis:\n  ennreal 1 - ennreal a = ennreal (1 - a)\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "also"], ["proof (state)\nthis:\n  ennreal 1 - ennreal a = ennreal (1 - a)\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "have \"x * (1 - a) / (1 - a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * ennreal (1 - a) / ennreal (1 - a) = x", "using that ennreal_minus_eq_0 not_less"], ["proof (prove)\nusing this:\n  x = y + ennreal a * x\n  x \\<noteq> \\<top>\n  a \\<in> {0<..<1}\n  ?a - ?b = 0 \\<Longrightarrow> ?a \\<le> ?b\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. x * ennreal (1 - a) / ennreal (1 - a) = x", "by (subst mult_divide_eq_ennreal) auto"], ["proof (state)\nthis:\n  x * ennreal (1 - a) / ennreal (1 - a) = x\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "finally"], ["proof (chain)\npicking this:\n  y / ennreal (1 - a) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  y / ennreal (1 - a) = x\n\ngoal (1 subgoal):\n 1. x = y / ennreal (1 - a)", "by simp"], ["proof (state)\nthis:\n  x = y / ennreal (1 - a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 = ?y3 + ennreal ?a3 * ?x3; ?x3 \\<noteq> \\<top>;\n   ?a3 \\<in> {0<..<1}\\<rbrakk>\n  \\<Longrightarrow> ?x3 = ?y3 / ennreal (1 - ?a3)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "have \"NR\\<^sub>N n u l = (p * (l + NR\\<^sub>N (n - 1) u l) +\n                     q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (B (n - 1) k))))\n                   / (1 - (q ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)))) /\n    ennreal (1 - q ^ n)", "using 1 3 assms qn"], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n  ennreal q *\n  (of_nat u +\n   (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k))) +\n  ennreal (q ^ n) * NR\\<^sub>N n u l\n  NR\\<^sub>N n u l \\<noteq> \\<top>\n  0 < n\n  p \\<in> {0<..<1}\n  q ^ n \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)))) /\n    ennreal (1 - q ^ n)", "by (intro 2) auto"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)))) /\n  ennreal (1 - q ^ n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "then"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u l =\n  (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)))) /\n  ennreal (1 - q ^ n)", "show ?thesis"], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * ennreal (B (n - 1) k)))) /\n  ennreal (1 - q ^ n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "unfolding B_def"], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u l =\n  (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<n - 1.\n        NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n  ennreal (1 - q ^ n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N n u l =\n  (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<n - 1.\n        NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n  ennreal (1 - q ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NR\\<^sub>n_NH\\<^sub>N: \"NR\\<^sub>N n u 0 = u * NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "have \"NR\\<^sub>N n u 0 = \\<integral>\\<^sup>+ f. steps {..<n} f 0 u 0 \\<partial>measure_pmf (SL\\<^sub>N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 =\n    \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                       \\<partial>measure_pmf (SL\\<^sub>N n)", "unfolding NR\\<^sub>N_def R\\<^sub>N_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf\n                                  (map_pmf\n                                    (\\<lambda>f. steps {..<n} f 0 u 0)\n                                    (SL\\<^sub>N n)) =\n    \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                       \\<partial>measure_pmf (SL\\<^sub>N n)", "by (auto simp add: ennreal_of_nat_eq_real_of_nat)"], ["proof (state)\nthis:\n  NR\\<^sub>N n u 0 =\n  \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                     \\<partial>measure_pmf (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N n u 0 =\n  \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                     \\<partial>measure_pmf (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "have \"\\<dots> = \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max\\<^sub>0 (f ` {..<n})) \\<partial>measure_pmf (SL\\<^sub>N n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                       \\<partial>measure_pmf (SL\\<^sub>N n) =\n    \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max (f ` {..<n} \\<union> {0}))\n                       \\<partial>measure_pmf (SL\\<^sub>N n)", "by (intro nn_integral_cong) (auto simp add: steps_height)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                     \\<partial>measure_pmf (SL\\<^sub>N n) =\n  \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max (f ` {..<n} \\<union> {0}))\n                     \\<partial>measure_pmf (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. of_nat (steps {..<n} x 0 u 0)\n                     \\<partial>measure_pmf (SL\\<^sub>N n) =\n  \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max (f ` {..<n} \\<union> {0}))\n                     \\<partial>measure_pmf (SL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "have \"\\<dots> = u * NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max (f ` {..<n} \\<union> {0}))\n                       \\<partial>measure_pmf (SL\\<^sub>N n) =\n    of_nat u * NH\\<^sub>N n", "by (auto simp add: NH\\<^sub>N_def H\\<^sub>N_def H_def SL\\<^sub>N_def  ennreal_of_nat_eq_real_of_nat nn_integral_cmult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ f. of_nat u * of_nat (Max (f ` {..<n} \\<union> {0}))\n                     \\<partial>measure_pmf (SL\\<^sub>N n) =\n  of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "show ?thesis"], ["proof (prove)\nusing this:\n  NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N n u 0 = of_nat u * NH\\<^sub>N n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NR\\<^sub>N_recurrence':\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u l = (p * l + p * NR\\<^sub>N (n - 1) u l +\n                     q * u + q * (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u l * (pmf (binomial_pmf (n - 1) q) k)))\n                     / (1 - (q ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u l =\n    (ennreal (p * real l) + ennreal p * NR\\<^sub>N (n - 1) u l +\n     ennreal (q * real u) +\n     ennreal q *\n     (\\<Sum>k<n - 1.\n         NR\\<^sub>N (k + 1) u l *\n         ennreal (pmf (binomial_pmf (n - 1) q) k))) /\n    ennreal (1 - q ^ n)", "unfolding NR\\<^sub>N_recurrence[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) u l) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n) =\n    (ennreal (p * real l) + ennreal p * NR\\<^sub>N (n - 1) u l +\n     ennreal (q * real u) +\n     ennreal q *\n     (\\<Sum>k<n - 1.\n         NR\\<^sub>N (k + 1) u l *\n         ennreal (pmf (binomial_pmf (n - 1) q) k))) /\n    ennreal (1 - q ^ n)", "by (auto simp add: field_simps ennreal_of_nat_eq_real_of_nat ennreal_mult' ennreal_mult'')"], ["", "lemma NR\\<^sub>N_l_0:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n u 0 = (p * NR\\<^sub>N (n - 1) u 0 +\n                     q * (u + (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) u 0 * (pmf (binomial_pmf (n - 1) q) k))))\n                     / (1 - (q ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 =\n    (ennreal p * NR\\<^sub>N (n - 1) u 0 +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u 0 *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "unfolding NR\\<^sub>N_recurrence[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ennreal p * (of_nat 0 + NR\\<^sub>N (n - 1) u 0) +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u 0 *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n) =\n    (ennreal p * NR\\<^sub>N (n - 1) u 0 +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) u 0 *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n)", "by (simp)"], ["", "lemma NR\\<^sub>N_u_0:\n  assumes \"0 < n\" \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N n 0 l = (p * (l + NR\\<^sub>N (n - 1) 0 l) +\n                     q * (\\<Sum>k<n - 1. NR\\<^sub>N (k + 1) 0 l * (pmf (binomial_pmf (n - 1) q) k)))\n                     / (1 - (q ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n 0 l =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) 0 l) +\n     ennreal q *\n     (\\<Sum>k<n - 1.\n         NR\\<^sub>N (k + 1) 0 l *\n         ennreal (pmf (binomial_pmf (n - 1) q) k))) /\n    ennreal (1 - q ^ n)", "unfolding NR\\<^sub>N_recurrence[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) 0 l) +\n     ennreal q *\n     (of_nat 0 +\n      (\\<Sum>k<n - 1.\n          NR\\<^sub>N (k + 1) 0 l *\n          ennreal (pmf (binomial_pmf (n - 1) q) k)))) /\n    ennreal (1 - q ^ n) =\n    (ennreal p * (of_nat l + NR\\<^sub>N (n - 1) 0 l) +\n     ennreal q *\n     (\\<Sum>k<n - 1.\n         NR\\<^sub>N (k + 1) 0 l *\n         ennreal (pmf (binomial_pmf (n - 1) q) k))) /\n    ennreal (1 - q ^ n)", "by (simp)"], ["", "lemma NR\\<^sub>N_0[simp]: \"NR\\<^sub>N 0 u l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N 0 u l = 0", "unfolding NR\\<^sub>N_def R\\<^sub>N_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf\n                                  (map_pmf\n                                    (\\<lambda>f. steps {..<0} f 0 u l)\n                                    (SL {..<0})) =\n    0", "by (auto)"], ["", "lemma NR\\<^sub>N_1:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"NR\\<^sub>N 1 u l = (u * q + l * p) / p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "have \"NR\\<^sub>N 1 u l = (ennreal p * of_nat l + ennreal q * of_nat u) / ennreal (1 - q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l =\n    (ennreal p * of_nat l + ennreal q * of_nat u) / ennreal (1 - q)", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l =\n    (ennreal p * of_nat l + ennreal q * of_nat u) / ennreal (1 - q)", "by (subst NR\\<^sub>N_recurrence) auto"], ["proof (state)\nthis:\n  NR\\<^sub>N 1 u l =\n  (ennreal p * of_nat l + ennreal q * of_nat u) / ennreal (1 - q)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N 1 u l =\n  (ennreal p * of_nat l + ennreal q * of_nat u) / ennreal (1 - q)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "have \"(ennreal p * of_nat l + ennreal q * of_nat u) = (u * q + l * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal p * of_nat l + ennreal q * of_nat u =\n    ennreal (real u * q + real l * p)", "using assms q_def"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1}\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. ennreal p * of_nat l + ennreal q * of_nat u =\n    ennreal (real u * q + real l * p)", "by (subst ennreal_plus)\n      (auto simp add: field_simps ennreal_mult' ennreal_of_nat_eq_real_of_nat)"], ["proof (state)\nthis:\n  ennreal p * of_nat l + ennreal q * of_nat u =\n  ennreal (real u * q + real l * p)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "also"], ["proof (state)\nthis:\n  ennreal p * of_nat l + ennreal q * of_nat u =\n  ennreal (real u * q + real l * p)\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "have \"\\<dots> / ennreal (1 - q) = ennreal ((u * q + l * p) / (1 - q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real u * q + real l * p) / ennreal (1 - q) =\n    ennreal ((real u * q + real l * p) / (1 - q))", "using q_def assms"], ["proof (prove)\nusing this:\n  q = 1 - p\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal (real u * q + real l * p) / ennreal (1 - q) =\n    ennreal ((real u * q + real l * p) / (1 - q))", "by (intro divide_ennreal) auto"], ["proof (state)\nthis:\n  ennreal (real u * q + real l * p) / ennreal (1 - q) =\n  ennreal ((real u * q + real l * p) / (1 - q))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / (1 - q))", "show ?thesis"], ["proof (prove)\nusing this:\n  NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / (1 - q))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)", "unfolding q_def"], ["proof (prove)\nusing this:\n  NR\\<^sub>N 1 u l =\n  ennreal ((real u * (1 - p) + real l * p) / (1 - (1 - p)))\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N 1 u l = ennreal ((real u * (1 - p) + real l * p) / p)", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N 1 u l = ennreal ((real u * q + real l * p) / p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NR\\<^sub>N_NR\\<^sub>N_l_0:\n  assumes n: \"0 < n\" and p: \"p \\<in> {0<..<1}\" and \"u \\<ge> 1\"\n  shows \"NR\\<^sub>N n u 0 = (u * q / (u * q + l * p)) * NR\\<^sub>N n u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N n u l", "using n"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N n u l", "proof (induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y3 < i; 0 < ?y3\\<rbrakk>\n  \\<Longrightarrow> NR\\<^sub>N ?y3 u 0 =\n                    ennreal (real u * q / (real u * q + real l * p)) *\n                    NR\\<^sub>N ?y3 u l\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "have 1: \"0 < u * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real u * q", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real u * (1 - p)", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n\ngoal (1 subgoal):\n 1. 0 < real u * (1 - p)", "by simp"], ["proof (state)\nthis:\n  0 < real u * q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "moreover"], ["proof (state)\nthis:\n  0 < real u * q\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "have \"0 \\<le> l * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real l * p", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n\ngoal (1 subgoal):\n 1. 0 \\<le> real l * p", "by auto"], ["proof (state)\nthis:\n  0 \\<le> real l * p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "ultimately"], ["proof (chain)\npicking this:\n  0 < real u * q\n  0 \\<le> real l * p", "have 2: \"0 < u * q + l * p\""], ["proof (prove)\nusing this:\n  0 < real u * q\n  0 \\<le> real l * p\n\ngoal (1 subgoal):\n 1. 0 < real u * q + real l * p", "by arith"], ["proof (state)\nthis:\n  0 < real u * q + real l * p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "define c where \"c = ennreal (u * q / (u * q + l * p))\""], ["proof (state)\nthis:\n  c = ennreal (real u * q / (real u * q + real l * p))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "have [simp]: \"c / c = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c / c = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c / c = 1", "have \"u * q / (u * q + l * p) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) \\<noteq> 0", "using assms q_def 2"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n  q = 1 - p\n  0 < real u * q + real l * p\n\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real u * q / (real u * q + real l * p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c / c = 1", "then"], ["proof (chain)\npicking this:\n  real u * q / (real u * q + real l * p) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  real u * q / (real u * q + real l * p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c / c = 1", "unfolding c_def"], ["proof (prove)\nusing this:\n  real u * q / (real u * q + real l * p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ennreal (real u * q / (real u * q + real l * p)) /\n    ennreal (real u * q / (real u * q + real l * p)) =\n    1", "using p q_def"], ["proof (prove)\nusing this:\n  real u * q / (real u * q + real l * p) \\<noteq> 0\n  p \\<in> {0<..<1}\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. ennreal (real u * q / (real u * q + real l * p)) /\n    ennreal (real u * q / (real u * q + real l * p)) =\n    1", "by (auto intro!: ennreal_divide_self)"], ["proof (state)\nthis:\n  c / c = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c / c = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; 0 < y\\<rbrakk>\n                   \\<Longrightarrow> NR\\<^sub>N y u 0 =\n                                     ennreal\n(real u * q / (real u * q + real l * p)) *\n                                     NR\\<^sub>N y u l;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> NR\\<^sub>N x u 0 =\n                         ennreal (real u * q / (real u * q + real l * p)) *\n                         NR\\<^sub>N x u l", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "proof (cases \"i = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "case True"], ["proof (state)\nthis:\n  i = 1\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"c * NR\\<^sub>N i u l = c * ((u * q + l * p) / p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * NR\\<^sub>N i u l = c * ennreal ((real u * q + real l * p) / p)", "unfolding c_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N 1 u l =\n    ennreal (real u * q / (real u * q + real l * p)) *\n    ennreal ((real u * q + real l * p) / p)", "by (subst NR\\<^sub>N_1[OF p]) auto"], ["proof (state)\nthis:\n  c * NR\\<^sub>N i u l = c * ennreal ((real u * q + real l * p) / p)\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  c * NR\\<^sub>N i u l = c * ennreal ((real u * q + real l * p) / p)\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"\\<dots> = ennreal ((u * q / (u * q + l * p)) * ((u * q + l * p) / p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * ennreal ((real u * q + real l * p) / p) =\n    ennreal\n     (real u * q / (real u * q + real l * p) *\n      ((real u * q + real l * p) / p))", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real u * q / (real u * q + real l * p)) *\n    ennreal ((real u * q + real l * p) / p) =\n    ennreal\n     (real u * q / (real u * q + real l * p) *\n      ((real u * q + real l * p) / p))", "using assms q_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. ennreal (real u * q / (real u * q + real l * p)) *\n    ennreal ((real u * q + real l * p) / p) =\n    ennreal\n     (real u * q / (real u * q + real l * p) *\n      ((real u * q + real l * p) / p))", "by (subst ennreal_mult'') auto"], ["proof (state)\nthis:\n  c * ennreal ((real u * q + real l * p) / p) =\n  ennreal\n   (real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p))\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  c * ennreal ((real u * q + real l * p) / p) =\n  ennreal\n   (real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p))\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"(u * q / (u * q + l * p)) * ((u * q + l * p) / p) = u * q / p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p) =\n    real u * q / p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p) =\n    real u * q / p", "have I: \"(a / b) * (b / c) = a / c\" if \"0 < b\" for a b c::\"real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / b * (b / c) = a / c", "using that"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. a / b * (b / c) = a / c", "by (auto)"], ["proof (state)\nthis:\n  0 < ?b3 \\<Longrightarrow> ?a3 / ?b3 * (?b3 / ?c3) = ?a3 / ?c3\n\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p) =\n    real u * q / p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p) =\n    real u * q / p", "using 2 q_def"], ["proof (prove)\nusing this:\n  0 < real u * q + real l * p\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. real u * q / (real u * q + real l * p) *\n    ((real u * q + real l * p) / p) =\n    real u * q / p", "by (intro I) auto"], ["proof (state)\nthis:\n  real u * q / (real u * q + real l * p) * ((real u * q + real l * p) / p) =\n  real u * q / p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real u * q / (real u * q + real l * p) * ((real u * q + real l * p) / p) =\n  real u * q / p\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  real u * q / (real u * q + real l * p) * ((real u * q + real l * p) / p) =\n  real u * q / p\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"\\<dots> = NR\\<^sub>N i u 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real u * q / p) = NR\\<^sub>N i u 0", "unfolding True c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (real u * q / p) = NR\\<^sub>N 1 u 0", "by (subst NR\\<^sub>N_1[OF p]) (auto)"], ["proof (state)\nthis:\n  ennreal (real u * q / p) = NR\\<^sub>N i u 0\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n 2. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "finally"], ["proof (chain)\npicking this:\n  c * NR\\<^sub>N i u l = NR\\<^sub>N i u 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c * NR\\<^sub>N i u l = NR\\<^sub>N i u 0\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "unfolding c_def"], ["proof (prove)\nusing this:\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l =\n  NR\\<^sub>N i u 0\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "using True"], ["proof (prove)\nusing this:\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l =\n  NR\\<^sub>N i u 0\n  i = 1\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N i u 0 =\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 1", "have i: \"i > 1\""], ["proof (prove)\nusing this:\n  i \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < i", "using less"], ["proof (prove)\nusing this:\n  i \\<noteq> 1\n  \\<lbrakk>?y3 < i; 0 < ?y3\\<rbrakk>\n  \\<Longrightarrow> NR\\<^sub>N ?y3 u 0 =\n                    ennreal (real u * q / (real u * q + real l * p)) *\n                    NR\\<^sub>N ?y3 u l\n  0 < i\n\ngoal (1 subgoal):\n 1. 1 < i", "by auto"], ["proof (state)\nthis:\n  1 < i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "define c where \"c = ennreal (u * q / (u * q + l * p))\""], ["proof (state)\nthis:\n  c = ennreal (real u * q / (real u * q + real l * p))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "define B where \"B = (\\<Sum>k<i - 1. NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))\""], ["proof (state)\nthis:\n  B =\n  (\\<Sum>k<i - 1.\n      NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"NR\\<^sub>N i u 0 = (p * NR\\<^sub>N (i - 1) u 0 +\n                     q * (u + (\\<Sum>k<i - 1. NR\\<^sub>N (k + 1) u 0 * (pmf (binomial_pmf (i - 1) q) k))))\n                     / (1 - (q ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    (ennreal p * NR\\<^sub>N (i - 1) u 0 +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<i - 1.\n          NR\\<^sub>N (k + 1) u 0 *\n          ennreal (pmf (binomial_pmf (i - 1) q) k)))) /\n    ennreal (1 - q ^ i)", "using less assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < i; 0 < ?y3\\<rbrakk>\n  \\<Longrightarrow> NR\\<^sub>N ?y3 u 0 =\n                    ennreal (real u * q / (real u * q + real l * p)) *\n                    NR\\<^sub>N ?y3 u l\n  0 < i\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    (ennreal p * NR\\<^sub>N (i - 1) u 0 +\n     ennreal q *\n     (of_nat u +\n      (\\<Sum>k<i - 1.\n          NR\\<^sub>N (k + 1) u 0 *\n          ennreal (pmf (binomial_pmf (i - 1) q) k)))) /\n    ennreal (1 - q ^ i)", "by (subst NR\\<^sub>N_l_0) auto"], ["proof (state)\nthis:\n  NR\\<^sub>N i u 0 =\n  (ennreal p * NR\\<^sub>N (i - 1) u 0 +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u 0 *\n        ennreal (pmf (binomial_pmf (i - 1) q) k)))) /\n  ennreal (1 - q ^ i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N i u 0 =\n  (ennreal p * NR\\<^sub>N (i - 1) u 0 +\n   ennreal q *\n   (of_nat u +\n    (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u 0 *\n        ennreal (pmf (binomial_pmf (i - 1) q) k)))) /\n  ennreal (1 - q ^ i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"q * (u + (\\<Sum>k<i - 1. NR\\<^sub>N (k + 1) u 0 * (pmf (binomial_pmf (i - 1) q) k))) =\n             q * u + q * (\\<Sum>k<i - 1. NR\\<^sub>N (k + 1) u 0 * (pmf (binomial_pmf (i - 1) q) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal q *\n    (of_nat u +\n     (\\<Sum>k<i - 1.\n         NR\\<^sub>N (k + 1) u 0 *\n         ennreal (pmf (binomial_pmf (i - 1) q) k))) =\n    ennreal (q * real u) +\n    ennreal q *\n    (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))", "using assms q_def"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. ennreal q *\n    (of_nat u +\n     (\\<Sum>k<i - 1.\n         NR\\<^sub>N (k + 1) u 0 *\n         ennreal (pmf (binomial_pmf (i - 1) q) k))) =\n    ennreal (q * real u) +\n    ennreal q *\n    (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))", "by (auto simp add: field_simps ennreal_of_nat_eq_real_of_nat ennreal_mult)"], ["proof (state)\nthis:\n  ennreal q *\n  (of_nat u +\n   (\\<Sum>k<i - 1.\n       NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))) =\n  ennreal (q * real u) +\n  ennreal q *\n  (\\<Sum>k<i - 1.\n      NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  ennreal q *\n  (of_nat u +\n   (\\<Sum>k<i - 1.\n       NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))) =\n  ennreal (q * real u) +\n  ennreal q *\n  (\\<Sum>k<i - 1.\n      NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"NR\\<^sub>N (i - 1) u 0 = c * NR\\<^sub>N (i - 1) u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N (i - 1) u 0 = c * NR\\<^sub>N (i - 1) u l", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N (i - 1) u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) *\n    NR\\<^sub>N (i - 1) u l", "using less i"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y3 < i; 0 < ?y3\\<rbrakk>\n  \\<Longrightarrow> NR\\<^sub>N ?y3 u 0 =\n                    ennreal (real u * q / (real u * q + real l * p)) *\n                    NR\\<^sub>N ?y3 u l\n  0 < i\n  1 < i\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N (i - 1) u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) *\n    NR\\<^sub>N (i - 1) u l", "by (intro less) (auto)"], ["proof (state)\nthis:\n  NR\\<^sub>N (i - 1) u 0 = c * NR\\<^sub>N (i - 1) u l\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  NR\\<^sub>N (i - 1) u 0 = c * NR\\<^sub>N (i - 1) u l\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"(\\<Sum>k<i - 1. NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n             (\\<Sum>k<i - 1. c * NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n    (\\<Sum>k<i - 1.\n        c * NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (i - 1) q) k))", "by (auto intro!: sum.cong simp add: less c_def)"], ["proof (state)\nthis:\n  (\\<Sum>k<i - 1.\n      NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n  (\\<Sum>k<i - 1.\n      c * NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<i - 1.\n      NR\\<^sub>N (k + 1) u 0 * ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n  (\\<Sum>k<i - 1.\n      c * NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"\\<dots> = c * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<i - 1.\n        c * NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n    c * B", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<i - 1.\n        c * NR\\<^sub>N (k + 1) u l *\n        ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n    c *\n    (\\<Sum>k<i - 1.\n        NR\\<^sub>N (k + 1) u l * ennreal (pmf (binomial_pmf (i - 1) q) k))", "by (subst sum_distrib_left) (auto intro!: sum.cong mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>k<i - 1.\n      c * NR\\<^sub>N (k + 1) u l *\n      ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n  c * B\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<i - 1.\n      c * NR\\<^sub>N (k + 1) u l *\n      ennreal (pmf (binomial_pmf (i - 1) q) k)) =\n  c * B\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"q * (c * B) = c * (q * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal q * (c * B) = c * (ennreal q * B)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  ennreal q * (c * B) = c * (ennreal q * B)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  ennreal q * (c * B) = c * (ennreal q * B)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"ennreal (q * real u) = q * u * ((u * q + l * p) / (u * q + l * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (q * real u) =\n    ennreal\n     (q * real u * ((real u * q + real l * p) / (real u * q + real l * p)))", "using assms 2"], ["proof (prove)\nusing this:\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n  0 < real u * q + real l * p\n\ngoal (1 subgoal):\n 1. ennreal (q * real u) =\n    ennreal\n     (q * real u * ((real u * q + real l * p) / (real u * q + real l * p)))", "by (auto simp add: field_simps q_def)"], ["proof (state)\nthis:\n  ennreal (q * real u) =\n  ennreal\n   (q * real u * ((real u * q + real l * p) / (real u * q + real l * p)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  ennreal (q * real u) =\n  ennreal\n   (q * real u * ((real u * q + real l * p) / (real u * q + real l * p)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"\\<dots> = c * (real u * q + real l * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (q * real u *\n      ((real u * q + real l * p) / (real u * q + real l * p))) =\n    c * ennreal (real u * q + real l * p)", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (q * real u *\n      ((real u * q + real l * p) / (real u * q + real l * p))) =\n    ennreal (real u * q / (real u * q + real l * p)) *\n    ennreal (real u * q + real l * p)", "using 2"], ["proof (prove)\nusing this:\n  0 < real u * q + real l * p\n\ngoal (1 subgoal):\n 1. ennreal\n     (q * real u *\n      ((real u * q + real l * p) / (real u * q + real l * p))) =\n    ennreal (real u * q / (real u * q + real l * p)) *\n    ennreal (real u * q + real l * p)", "by (subst ennreal_mult''[symmetric]) (auto simp add: mult_ac)"], ["proof (state)\nthis:\n  ennreal\n   (q * real u * ((real u * q + real l * p) / (real u * q + real l * p))) =\n  c * ennreal (real u * q + real l * p)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  ennreal\n   (q * real u * ((real u * q + real l * p) / (real u * q + real l * p))) =\n  c * ennreal (real u * q + real l * p)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"c * ennreal (real u * q + real l * p) + c * (ennreal q * B) =\n             c * (ennreal (real u * q + real l * p) + (ennreal q * B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * ennreal (real u * q + real l * p) + c * (ennreal q * B) =\n    c * (ennreal (real u * q + real l * p) + ennreal q * B)", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  c * ennreal (real u * q + real l * p) + c * (ennreal q * B) =\n  c * (ennreal (real u * q + real l * p) + ennreal q * B)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  c * ennreal (real u * q + real l * p) + c * (ennreal q * B) =\n  c * (ennreal (real u * q + real l * p) + ennreal q * B)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"ennreal p * (c * NR\\<^sub>N (i - 1) u l) = c * (ennreal p * NR\\<^sub>N (i - 1) u l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal p * (c * NR\\<^sub>N (i - 1) u l) =\n    c * (ennreal p * NR\\<^sub>N (i - 1) u l)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  ennreal p * (c * NR\\<^sub>N (i - 1) u l) =\n  c * (ennreal p * NR\\<^sub>N (i - 1) u l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  ennreal p * (c * NR\\<^sub>N (i - 1) u l) =\n  c * (ennreal p * NR\\<^sub>N (i - 1) u l)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"(c * (ennreal p * NR\\<^sub>N (i - 1) u l) + c * (ennreal (u * q + l * p) + ennreal q * B))\n            = c * ((ennreal p * NR\\<^sub>N (i - 1) u l) + (ennreal (u * q + l * p) + ennreal q * B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c * (ennreal p * NR\\<^sub>N (i - 1) u l) +\n    c * (ennreal (real u * q + real l * p) + ennreal q * B) =\n    c *\n    (ennreal p * NR\\<^sub>N (i - 1) u l +\n     (ennreal (real u * q + real l * p) + ennreal q * B))", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  c * (ennreal p * NR\\<^sub>N (i - 1) u l) +\n  c * (ennreal (real u * q + real l * p) + ennreal q * B) =\n  c *\n  (ennreal p * NR\\<^sub>N (i - 1) u l +\n   (ennreal (real u * q + real l * p) + ennreal q * B))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  c * (ennreal p * NR\\<^sub>N (i - 1) u l) +\n  c * (ennreal (real u * q + real l * p) + ennreal q * B) =\n  c *\n  (ennreal p * NR\\<^sub>N (i - 1) u l +\n   (ennreal (real u * q + real l * p) + ennreal q * B))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \" c * (ennreal p * NR\\<^sub>N (i - 1) u l + (ennreal (u * q + l * p) + ennreal q * B)) / ennreal (1 - q ^ i)\n         =  c * ((ennreal p * NR\\<^sub>N (i - 1) u l + (ennreal (u * q + l * p) + ennreal q * B)) / ennreal (1 - q ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\n    (ennreal p * NR\\<^sub>N (i - 1) u l +\n     (ennreal (real u * q + real l * p) + ennreal q * B)) /\n    ennreal (1 - q ^ i) =\n    c *\n    ((ennreal p * NR\\<^sub>N (i - 1) u l +\n      (ennreal (real u * q + real l * p) + ennreal q * B)) /\n     ennreal (1 - q ^ i))", "by (auto simp add: ennreal_times_divide)"], ["proof (state)\nthis:\n  c *\n  (ennreal p * NR\\<^sub>N (i - 1) u l +\n   (ennreal (real u * q + real l * p) + ennreal q * B)) /\n  ennreal (1 - q ^ i) =\n  c *\n  ((ennreal p * NR\\<^sub>N (i - 1) u l +\n    (ennreal (real u * q + real l * p) + ennreal q * B)) /\n   ennreal (1 - q ^ i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "also"], ["proof (state)\nthis:\n  c *\n  (ennreal p * NR\\<^sub>N (i - 1) u l +\n   (ennreal (real u * q + real l * p) + ennreal q * B)) /\n  ennreal (1 - q ^ i) =\n  c *\n  ((ennreal p * NR\\<^sub>N (i - 1) u l +\n    (ennreal (real u * q + real l * p) + ennreal q * B)) /\n   ennreal (1 - q ^ i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "have \"(ennreal p * NR\\<^sub>N (i - 1) u l + (ennreal (real u * q + real l * p) + ennreal q * B)) / ennreal (1 - q ^ i)\n        = NR\\<^sub>N i u l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ennreal p * NR\\<^sub>N (i - 1) u l +\n     (ennreal (real u * q + real l * p) + ennreal q * B)) /\n    ennreal (1 - q ^ i) =\n    NR\\<^sub>N i u l", "apply(subst (2) NR\\<^sub>N_recurrence')"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < i\n 2. p \\<in> {0<..<1}\n 3. (ennreal p * NR\\<^sub>N (i - 1) u l +\n     (ennreal (real u * q + real l * p) + ennreal q * B)) /\n    ennreal (1 - q ^ i) =\n    (ennreal (p * real l) + ennreal p * NR\\<^sub>N (i - 1) u l +\n     ennreal (q * real u) +\n     ennreal q *\n     (\\<Sum>k<i - 1.\n         NR\\<^sub>N (k + 1) u l *\n         ennreal (pmf (binomial_pmf (i - 1) q) k))) /\n    ennreal (1 - q ^ i)", "using i assms q_def"], ["proof (prove)\nusing this:\n  1 < i\n  0 < n\n  p \\<in> {0<..<1}\n  1 \\<le> u\n  q = 1 - p\n\ngoal (3 subgoals):\n 1. 0 < i\n 2. p \\<in> {0<..<1}\n 3. (ennreal p * NR\\<^sub>N (i - 1) u l +\n     (ennreal (real u * q + real l * p) + ennreal q * B)) /\n    ennreal (1 - q ^ i) =\n    (ennreal (p * real l) + ennreal p * NR\\<^sub>N (i - 1) u l +\n     ennreal (q * real u) +\n     ennreal q *\n     (\\<Sum>k<i - 1.\n         NR\\<^sub>N (k + 1) u l *\n         ennreal (pmf (binomial_pmf (i - 1) q) k))) /\n    ennreal (1 - q ^ i)", "by\n        (auto simp add: field_simps B_def ennreal_of_nat_eq_real_of_nat ennreal_mult' ennreal_mult'')"], ["proof (state)\nthis:\n  (ennreal p * NR\\<^sub>N (i - 1) u l +\n   (ennreal (real u * q + real l * p) + ennreal q * B)) /\n  ennreal (1 - q ^ i) =\n  NR\\<^sub>N i u l\n\ngoal (1 subgoal):\n 1. i \\<noteq> 1 \\<Longrightarrow>\n    NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "finally"], ["proof (chain)\npicking this:\n  NR\\<^sub>N i u 0 = c * NR\\<^sub>N i u l", "show ?thesis"], ["proof (prove)\nusing this:\n  NR\\<^sub>N i u 0 = c * NR\\<^sub>N i u l\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "unfolding c_def"], ["proof (prove)\nusing this:\n  NR\\<^sub>N i u 0 =\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N i u 0 =\n    ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l", "by simp"], ["proof (state)\nthis:\n  NR\\<^sub>N i u 0 =\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NR\\<^sub>N i u 0 =\n  ennreal (real u * q / (real u * q + real l * p)) * NR\\<^sub>N i u l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Assigning 1 as the cost for going up and/or left, we can now show the relation between the\n  expected length of the reverse search path and the expected height.\n\\<close>"], ["", "definition EL\\<^sub>N where \"EL\\<^sub>N n = measure_pmf.expectation (R\\<^sub>N n 1 1) real\""], ["", "theorem EH\\<^sub>N_EL\\<^sub>s\\<^sub>p:\n  assumes \"p \\<in> {0<..<1}\"\n  shows \"1 / q * EH\\<^sub>N n = EL\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have 1: \"ennreal (1 / y * x) = r\" if \"ennreal x = y * r\" \"x \\<ge> 0\" \"y > 0\"\n    for x y::real and r::ennreal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "have \"ennreal ((1 / y) * x) = ennreal (1 / y) * ennreal x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = ennreal (1 / y) * ennreal x", "using that"], ["proof (prove)\nusing this:\n  ennreal x = ennreal y * r\n  0 \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = ennreal (1 / y) * ennreal x", "apply(subst ennreal_mult'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ennreal x = ennreal y * r; 0 \\<le> x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> x\n 2. \\<lbrakk>ennreal x = ennreal y * r; 0 \\<le> x; 0 < y\\<rbrakk>\n    \\<Longrightarrow> ennreal (1 / y) * ennreal x =\n                      ennreal (1 / y) * ennreal x", "by auto"], ["proof (state)\nthis:\n  ennreal (1 / y * x) = ennreal (1 / y) * ennreal x\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "also"], ["proof (state)\nthis:\n  ennreal (1 / y * x) = ennreal (1 / y) * ennreal x\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "note that(1)"], ["proof (state)\nthis:\n  ennreal x = ennreal y * r\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "also"], ["proof (state)\nthis:\n  ennreal x = ennreal y * r\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "have \"ennreal (1 / y) * (ennreal y * r) = ennreal ((1 / y) * y) * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / y) * (ennreal y * r) = ennreal (1 / y * y) * r", "using that"], ["proof (prove)\nusing this:\n  ennreal x = ennreal y * r\n  0 \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. ennreal (1 / y) * (ennreal y * r) = ennreal (1 / y * y) * r", "by (subst ennreal_mult'') (auto simp add: mult_ac)"], ["proof (state)\nthis:\n  ennreal (1 / y) * (ennreal y * r) = ennreal (1 / y * y) * r\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "also"], ["proof (state)\nthis:\n  ennreal (1 / y) * (ennreal y * r) = ennreal (1 / y * y) * r\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "have \"(1 / y) * y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / y * y = 1", "using that"], ["proof (prove)\nusing this:\n  ennreal x = ennreal y * r\n  0 \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. 1 / y * y = 1", "by (auto)"], ["proof (state)\nthis:\n  1 / y * y = 1\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "finally"], ["proof (chain)\npicking this:\n  ennreal (1 / y * x) = ennreal 1 * r", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (1 / y * x) = ennreal 1 * r\n\ngoal (1 subgoal):\n 1. ennreal (1 / y * x) = r", "by auto"], ["proof (state)\nthis:\n  ennreal (1 / y * x) = r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ennreal ?x3 = ennreal ?y3 * ?r3; 0 \\<le> ?x3; 0 < ?y3\\<rbrakk>\n  \\<Longrightarrow> ennreal (1 / ?y3 * ?x3) = ?r3\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have \"EH\\<^sub>N n = NH\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (EH\\<^sub>N n) = NH\\<^sub>N n", "using NH\\<^sub>N_EH\\<^sub>N assms"], ["proof (prove)\nusing this:\n  p \\<in> {0<..<1} \\<Longrightarrow> NH\\<^sub>N ?n = ennreal (EH\\<^sub>N ?n)\n  p \\<in> {0<..<1}\n\ngoal (1 subgoal):\n 1. ennreal (EH\\<^sub>N n) = NH\\<^sub>N n", "by auto"], ["proof (state)\nthis:\n  ennreal (EH\\<^sub>N n) = NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "also"], ["proof (state)\nthis:\n  ennreal (EH\\<^sub>N n) = NH\\<^sub>N n\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have \"NH\\<^sub>N n = NR\\<^sub>N n 1 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = NR\\<^sub>N n 1 0", "using NR\\<^sub>n_NH\\<^sub>N"], ["proof (prove)\nusing this:\n  NR\\<^sub>N ?n ?u 0 = of_nat ?u * NH\\<^sub>N ?n\n\ngoal (1 subgoal):\n 1. NH\\<^sub>N n = NR\\<^sub>N n 1 0", "by auto"], ["proof (state)\nthis:\n  NH\\<^sub>N n = NR\\<^sub>N n 1 0\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "also"], ["proof (state)\nthis:\n  NH\\<^sub>N n = NR\\<^sub>N n 1 0\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have \"NR\\<^sub>N n 1 0 = q * NR\\<^sub>N n 1 1\" if \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n 1 0 = ennreal q * NR\\<^sub>N n 1 1", "using NR\\<^sub>N_NR\\<^sub>N_l_0[of _ 1 1] that assms q_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; p \\<in> {0<..<1}; 1 \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> NR\\<^sub>N ?n 1 0 =\n                    ennreal (real 1 * q / (real 1 * q + real 1 * p)) *\n                    NR\\<^sub>N ?n 1 1\n  0 < n\n  p \\<in> {0<..<1}\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n 1 0 = ennreal q * NR\\<^sub>N n 1 1", "by force"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> NR\\<^sub>N n 1 0 = ennreal q * NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "finally"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1", "have \"ennreal (EH\\<^sub>N n) = q * NR\\<^sub>N n 1 1\" if \"n > 0\""], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1", "using that"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1\n  0 < n\n\ngoal (1 subgoal):\n 1. ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1", "by blast"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "then"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1", "have \"1 / q * EH\\<^sub>N n = NR\\<^sub>N n 1 1\" if \"n > 0\""], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1", "using that assms q_def"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  ennreal (EH\\<^sub>N n) = ennreal q * NR\\<^sub>N n 1 1\n  0 < n\n  p \\<in> {0<..<1}\n  q = 1 - p\n\ngoal (1 subgoal):\n 1. ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1", "by (intro 1) (auto simp add: EH\\<^sub>N_def H\\<^sub>N_def H_def)"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "moreover"], ["proof (state)\nthis:\n  0 < n \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have \"1 / q * EH\\<^sub>N n = NR\\<^sub>N n 1 1\" if \"n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1", "unfolding that"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 / q * EH\\<^sub>N 0) = NR\\<^sub>N 0 1 1", "by (auto simp add: EH\\<^sub>N_def H\\<^sub>N_def H_def)"], ["proof (state)\nthis:\n  n = 0 \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "ultimately"], ["proof (chain)\npicking this:\n  0 < n \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n  n = 0 \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1", "have 2: \"ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\""], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n  n = 0 \\<Longrightarrow> ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1", "by blast"], ["proof (state)\nthis:\n  ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "also"], ["proof (state)\nthis:\n  ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "have \"NR\\<^sub>N n 1 1 = EL\\<^sub>N n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NR\\<^sub>N n 1 1 = ennreal (EL\\<^sub>N n)", "using 2 assms EH\\<^sub>N_bounds"], ["proof (prove)\nusing this:\n  ennreal (1 / q * EH\\<^sub>N n) = NR\\<^sub>N n 1 1\n  p \\<in> {0<..<1}\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  p \\<in> {0<..<1} \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. NR\\<^sub>N n 1 1 = ennreal (EL\\<^sub>N n)", "unfolding EL\\<^sub>N_def NR\\<^sub>N_def"], ["proof (prove)\nusing this:\n  ennreal (1 / q * EH\\<^sub>N n) =\n  \\<integral>\\<^sup>+ x. ennreal (real x)\n                     \\<partial>measure_pmf (R\\<^sub>N n 1 1)\n  p \\<in> {0<..<1}\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  - harm ?n / ln q - 1 \\<le> EH\\<^sub>N ?n\n  p \\<in> {0<..<1} \\<Longrightarrow> EH\\<^sub>N ?n \\<le> - harm ?n / ln q\n  p \\<in> {0<..<1} \\<Longrightarrow>\n  integrable (measure_pmf (H\\<^sub>N ?n)) real\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real x)\n                       \\<partial>measure_pmf (R\\<^sub>N n 1 1) =\n    ennreal (measure_pmf.expectation (R\\<^sub>N n 1 1) real)", "by(subst nn_integral_eq_integral)\n      (auto intro!: integrableI_nn_integral_finite[where x=\"EH\\<^sub>N n / q\"])"], ["proof (state)\nthis:\n  NR\\<^sub>N n 1 1 = ennreal (EL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "finally"], ["proof (chain)\npicking this:\n  ennreal (1 / q * EH\\<^sub>N n) = ennreal (EL\\<^sub>N n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (1 / q * EH\\<^sub>N n) = ennreal (EL\\<^sub>N n)\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "using assms q_def ennreal_inj"], ["proof (prove)\nusing this:\n  ennreal (1 / q * EH\\<^sub>N n) = ennreal (EL\\<^sub>N n)\n  p \\<in> {0<..<1}\n  q = 1 - p\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (ennreal ?a = ennreal ?b) = (?a = ?b)\n\ngoal (1 subgoal):\n 1. 1 / q * EH\\<^sub>N n = EL\\<^sub>N n", "unfolding EL\\<^sub>N_def EH\\<^sub>N_def H\\<^sub>N_def H_def SL_def"], ["proof (prove)\nusing this:\n  ennreal\n   (1 / q *\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>f. Max (f ` {..<n} \\<union> {0}))\n       (Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p)))\n     real) =\n  ennreal (measure_pmf.expectation (R\\<^sub>N n 1 1) real)\n  p \\<in> {0<..<1}\n  q = 1 - p\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (ennreal ?a = ennreal ?b) = (?a = ?b)\n\ngoal (1 subgoal):\n 1. 1 / q *\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>f. Max (f ` {..<n} \\<union> {0}))\n       (Pi_pmf {..<n} 0 (\\<lambda>_. geometric_pmf p)))\n     real =\n    measure_pmf.expectation (R\\<^sub>N n 1 1) real", "by (auto)"], ["proof (state)\nthis:\n  1 / q * EH\\<^sub>N n = EL\\<^sub>N n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context random_skip_list *)"], ["", "thm random_skip_list.EH\\<^sub>N_EL\\<^sub>s\\<^sub>p[unfolded random_skip_list.q_def]\n    random_skip_list.EH\\<^sub>N_bounds'[unfolded random_skip_list.q_def]"], ["", "end"]]}