{"file_name": "/home/qj213/afp-2021-10-22/thys/Stable_Matching/Contracts.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stable_Matching", "problem_names": ["lemmas Pd_linear' = Pd_linear[rule_format]", "lemmas Pd_range' = subsetD[OF Pd_range[rule_format], simplified, of x d] for x d", "lemma Pd_refl:\n  assumes \"x \\<in> Field (Pd d)\"\n  shows \"(x, x) \\<in> Pd d\"", "lemma Pd_Xd:\n  assumes \"(x, y) \\<in> Pd d\"\n  shows \"Xd x = d \\<and> Xd y = d\"", "lemma Above_Pd_Xd:\n  assumes \"x \\<in> Above (Pd d) X\"\n  shows \"Xd x = d\"", "lemma AboveS_Pd_Xd:\n  assumes \"x \\<in> AboveS (Pd d) X\"\n  shows \"Xd x = d\"", "lemmas Cd_domain = Cd.domain", "lemmas Cd_f_range = Cd.f_range", "lemmas Cd_range = Cd.range", "lemmas Cd_range' = Cd.range'", "lemmas Rf_Cd_mono = Cd.Rf_mono_on[of UNIV, unfolded mono_on_mono]", "lemmas Cd_Chernoff = Cd.Chernoff", "lemmas Cd_path_independent = Cd.path_independent", "lemmas Cd_iia = Cd.iia", "lemmas Cd_irc = Cd.irc", "lemmas Cd_lad = Cd.lad", "lemmas Cd_mono = Cd.mono", "lemmas Cd_greatest = Cd.greatest", "lemmas Cd_preferred = Cd.preferred", "lemmas Cd_singleton = Cd.singleton", "lemmas Cd_union = Cd.union", "lemmas Cd_idem = iia_f_idem[OF Cd.f_range[of UNIV d, folded Cd_def] Cd_iia[of UNIV], simplified] for d", "lemma Cd_Xd:\n  shows \"x \\<in> Cd d X \\<Longrightarrow> Xd x = d\"", "lemma Cd_inj_on_Xd:\n  shows \"inj_on Xd (Cd d X)\"", "lemma Cd_range_disjoint:\n  assumes \"d \\<noteq> d'\"\n  shows \"Cd d A \\<inter> Cd d' A = {}\"", "lemma Cd_single:\n  assumes \"x \\<in> X\"\n  assumes \"inj_on Xd X\"\n  assumes \"x \\<in> Field (Pd d)\"\n  shows \"x \\<in> Cd d X\"", "lemma Cd_Above:\n  shows \"Cd d X = Above (Pd d) (X \\<inter> Field (Pd d)) \\<inter> X\"", "lemma MaxR_maxR:\n  shows \"MaxR.maxR (Pd d) = maxR d\"", "lemma MaxR_MaxR_f:\n  shows \"MaxR.MaxR_f (Pd d) = MaxR_f d\"", "lemmas Cd_code[code] = Cd.code[unfolded MaxR_MaxR_f]", "lemma Cd_simps[simp, nitpick_simp]:\n  shows \"Cd d {} = {}\"\n        \"Cd d (insert x A) = (if x \\<in> Field (Pd d) then if Cd d A = {} then {x} else {maxR d x y |y. y \\<in> Cd d A} else Cd d A)\"", "lemma CD_on_def2:\n  shows \"CD_on ds A = (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d)))\"", "lemma CD_on_Xd:\n  assumes \"x \\<in> CD_on ds A\"\n  shows \"Xd x \\<in> ds\"", "lemma mem_CD_on_Cd:\n  shows \"x \\<in> CD_on ds X \\<longleftrightarrow> (x \\<in> Cd (Xd x) X \\<and> Xd x \\<in> ds)\"", "lemma CD_on_domain:\n  assumes \"d \\<in> ds\"\n  shows \"CD_on ds A \\<inter> Field (Pd d) = Cd d (A \\<inter> Field (Pd d))\"", "lemma CD_on_range:\n  shows \"CD_on ds A \\<subseteq> A \\<inter> (\\<Union>d\\<in>ds. Field (Pd d))\"", "lemmas CD_on_range' = subsetD[OF CD_on_range]", "lemma CD_on_f_range_on:\n  shows \"f_range_on A (CD_on ds)\"", "lemma RD_on_mono:\n  shows \"mono (RD_on ds)\"", "lemma CD_on_Chernoff:\n  shows \"Chernoff (CD_on ds)\"", "lemma CD_on_irc:\n  shows \"irc (CD_on ds)\"", "lemmas CD_on_consistency = irc_on_consistency_on[OF CD_on_irc, simplified]", "lemma CD_on_path_independent:\n  shows \"path_independent (\\<lambda>X. CD_on ds X)\"", "lemma CD_on_simps:\n  shows \"CD_on ds {} = {}\"", "lemmas CD_on_iia = RD_on_mono[unfolded Rf_mono_iia]", "lemmas CD_on_idem = iia_f_idem[OF CD_on_f_range_on CD_on_iia, simplified]", "lemma CD_on_inj_on_Xd:\n  shows \"inj_on Xd (CD_on ds X)\"", "lemma CD_on_card:\n  shows \"card (CD_on ds X) = (\\<Sum>d\\<in>ds. card (Cd d X))\"", "lemma CD_on_closed:\n  assumes \"inj_on Xd X\"\n  assumes \"X \\<subseteq> (\\<Union>d\\<in>ds. Field (Pd d))\"\n  shows \"CD_on ds X = X\"", "lemmas Ch_singular' = Ch_singular[rule_format]", "lemmas Ch_range' = subsetD[OF Ch_range[rule_format], simplified, of x h X] for x h X", "lemma Ch_simps:\n  shows \"Ch h {} = {}\"", "lemma Ch_range_disjoint:\n  assumes \"h \\<noteq> h'\"\n  shows \"Ch h A \\<inter> Ch h' A = {}\"", "lemma Ch_f_range:\n  shows \"f_range (Ch h)\"", "lemma CH_card:\n  shows \"card (CH X) = (\\<Sum>h\\<in>UNIV. card (Ch h X))\"", "lemma CH_simps:\n  shows \"CH {} = {}\"", "lemma CH_range:\n  shows \"CH A \\<subseteq> A\"", "lemmas CH_range' = subsetD[OF CH_range]", "lemmas CH_f_range_on = f_range_onI[OF CH_range]", "lemma mem_CH_Ch:\n  shows \"x \\<in> CH X \\<longleftrightarrow> x \\<in> Ch (Xh x) X\"", "lemma mem_Ch_CH:\n  assumes \"x \\<in> Ch h X\"\n  shows \"x \\<in> CH X\"", "lemma dX_union:\n  shows \"dX (X \\<union> Y) d = dX X d \\<union> dX Y d\"", "lemma dX_range:\n  shows \"\\<forall>d. dX X d \\<subseteq> {x. Xd x = d}\"", "lemma dX_range':\n  assumes \"x \\<in> dX X d\"\n  shows \"x \\<in> X \\<and> Xd x = d\"", "lemma dX_empty_or_singleton:\n  assumes \"allocation X\"\n  shows \"\\<forall>d. dX X d = {} \\<or> (\\<exists>x. dX X d = {x})\"", "lemma dX_linear:\n  assumes \"allocation X\"\n  shows \"Linear_order (dX X d \\<times> dX X d)\"", "lemma dX_singular:\n  assumes \"allocation X\"\n  assumes \"x \\<in> X\"\n  assumes \"d = Xd x\"\n  shows \"dX X d = {x}\"", "lemma dX_Int_Field_Pd:\n  assumes \"dX X d \\<subseteq> Field (Pd d)\"\n  shows \"X \\<inter> Field (Pd d) = dX X d\"", "lemma Cd_Above_dX:\n  assumes \"dX X d \\<subseteq> Field (Pd d)\"\n  shows \"Cd d X = Above (Pd d) (dX X d) \\<inter> X\"", "lemma stable_onI:\n  assumes \"individually_rational_on ds X\"\n  assumes \"stable_no_blocking_on ds X\"\n  shows \"stable_on ds X\"", "lemma individually_rational_onI:\n  assumes \"CD_on ds X = X\"\n  assumes \"CH X = X\"\n  shows \"individually_rational_on ds X\"", "lemma individually_rational_on_CD_on:\n  assumes \"individually_rational_on ds X\"\n  shows \"CD_on ds X = X\"", "lemma individually_rational_on_Cd:\n  assumes \"individually_rational_on ds X\"\n  shows \"Cd d X = dX X d\"", "lemma individually_rational_on_empty:\n  shows \"individually_rational_on ds {}\"", "lemma blocking_onI:\n  assumes \"X'' \\<noteq> Ch h X\"\n  assumes \"X'' = Ch h (X \\<union> X'')\"\n  assumes \"\\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\"\n  shows \"blocking_on ds X h X''\"", "lemma blocking_on_imp_not_stable:\n  assumes \"blocking_on ds X h X''\"\n  shows \"\\<not>stable_on ds X\"", "lemma blocking_on_allocation:\n  assumes \"blocking_on ds X h X''\"\n  shows \"allocation X''\"", "lemma blocking_on_Field:\n  assumes \"blocking_on ds X h X''\"\n  shows \"dX X'' d \\<subseteq> Field (Pd d)\"", "lemma blocking_on_CD_on:\n  assumes \"blocking_on ds X h X''\"\n  shows \"X'' \\<subseteq> CD_on ds (X \\<union> X'')\"", "lemma blocking_on_CD_on':\n  assumes \"blocking_on ds X h X''\"\n  assumes \"x \\<in> X''\"\n  shows \"x \\<in> CD_on ds (X \\<union> X'')\"", "lemma blocking_on_Cd:\n  assumes \"blocking_on ds X h X''\"\n  shows \"dX X'' d \\<subseteq> Cd d (X \\<union> X'')\"", "lemma stable_no_blocking_onI:\n  assumes \"\\<And>h X''. \\<lbrakk>X'' = Ch h (X \\<union> X''); X'' \\<noteq> Ch h X; X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"stable_no_blocking_on ds X\"", "lemma stable_no_blocking_onI2:\n  assumes \"\\<And>h X''. blocking_on ds X h X'' \\<Longrightarrow> False\"\n  shows \"stable_no_blocking_on ds X\"", "lemma \"stable_no_blocking_on ds UNIV\"", "lemma\n  assumes \"stable_on ds X\"\n  shows stable_on_CD_on: \"CD_on ds X = X\"\n    and stable_on_Xd: \"x \\<in> X \\<Longrightarrow> Xd x \\<in> ds\"\n    and stable_on_range': \"x \\<in> X \\<Longrightarrow> x \\<in> Field (Pd (Xd x))\"\n    and stable_on_CH: \"CH X = X\"\n    and stable_on_no_blocking_on: \"stable_no_blocking_on ds X\"", "lemma stable_on_allocation:\n  assumes \"stable_on ds X\"\n  shows \"allocation X\"", "lemma stable_on_blocking_onD:\n  assumes \"stable_on ds X\"\n  shows \"\\<lbrakk>X'' = Ch h (X \\<union> X''); X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk> \\<Longrightarrow> X'' = Ch h X\"", "lemma not_stable_on_cases[consumes 1, case_names not_individually_rational not_no_blocking]:\n  assumes \"\\<not> stable_on ds X\"\n  assumes \"\\<not> individually_rational_on ds X \\<Longrightarrow> P\"\n  assumes \"\\<not> stable_no_blocking_on ds X \\<Longrightarrow> P\"\n  shows \"P\"", "lemma stable_pair_on_CD_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"match XD_XH = CD_on ds (fst XD_XH)\"", "lemma stable_pair_on_CH:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"match XD_XH = CH (snd XD_XH)\"", "lemma stable_pair_on_CD_on_CH:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"CD_on ds (fst XD_XH) = CH (snd XD_XH)\"", "lemma stable_pair_on_allocation:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"allocation (match XD_XH)\"", "lemma stable_pair_onI:\n  assumes \"fst XD_XH = - RH (snd XD_XH)\"\n  assumes \"snd XD_XH = - RD_on ds (fst XD_XH)\"\n  shows \"stable_pair_on ds XD_XH\"", "lemma stable_pair_onE:\n  shows \"\\<lbrakk>stable_pair_on ds XD_XH; \\<lbrakk>- RH (snd XD_XH) = fst XD_XH; - RD_on ds (fst XD_XH) = snd XD_XH\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma stable_pair_on_Cd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (fst XD_XH) = match XD_XH \\<inter> Field (Pd d)\"", "lemma stable_pair_on_Cd_match:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (match XD_XH) = Cd d (fst XD_XH)\"", "lemma stable_pair_on_Xd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> match XD_XH\"\n  shows \"Xd x \\<in> ds\"", "lemma stable_pair_on_match_Cd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> match XD_XH\"\n  shows \"x \\<in> Cd (Xd x) (match XD_XH)\"", "lemma\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"individually_rational_on ds (match XD_XH)\"", "lemma\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_no_blocking (match XD_XH)\"", "lemma\n  assumes \"stable_on ds X\"\n  obtains XD_XH where \"stable_pair_on ds XD_XH\" and \"X = match XD_XH\"", "lemma D2_UNIV:\n  shows \"UNIV = set [D1, D2]\"", "lemma D2_ALL:\n  shows \"(\\<forall>d. P d) = (\\<forall>d\\<in>{D1, D2}. P d)\"", "lemma D2_UNION:\n  shows \"(\\<Union>d. P d) = (\\<Union>d\\<in>{D1, D2}. P d)\"", "lemma X4_UNIV:\n  shows \"UNIV = set [Xd1, Xd1', Xd2, Xd2']\"", "lemmas X4_pow = subset_subseqs[OF subset_trans[OF subset_UNIV Set.equalityD1[OF X4_UNIV]]]", "lemma X4_ALL:\n  shows \"(\\<forall>X''. P X'') \\<longleftrightarrow> (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2, Xd2']). P X'')\"", "lemma PX4d_linear:\n  shows \"Linear_order (PX4d d)\"", "lemma PX4d_range:\n  shows \"Field (PX4d d) \\<subseteq> {x. X4d x = d}\"", "lemma CX4h_range:\n  shows \"CX4h h X \\<subseteq> {x \\<in> X. H = h}\"", "lemma CX4h_singular:\n  shows \"inj_on X4d (CX4h h X)\"", "lemma Xd1_Xd2_stable:\n  shows \"StableNoDecomp.stable {Xd1, Xd2}\"", "lemma Xd1'_Xd2'_stable:\n  shows \"StableNoDecomp.stable {Xd1', Xd2'}\"", "lemma stable:\n  shows \"StableNoDecomp.stable X \\<longleftrightarrow> X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\"\n(*<*)\n(is \"?lhs = ?rhs\")", "lemma StableNoDecomp_XD_XH:\n  shows \"StableNoDecomp.stable_pair (XD, XH) \\<longleftrightarrow> (XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'})\"\n(*<*)\n(is \"?lhs = ?rhs\")", "lemma\n  shows \"substitutes (CX4h H)\"", "lemma\n  shows \"\\<not>irc (CX4h H)\"", "lemma Ch_domain:\n  shows \"Ch h (A \\<inter> {x. Xh x = h}) = Ch h A\"", "lemma %invisible CH_domain:\n  shows \"CH A \\<inter> {x. Xh x = h} = Ch h (A \\<inter> {x. Xh x = h})\"", "lemma %invisible stable_pair_on_Ch:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"Ch h (snd XD_XH) = match XD_XH \\<inter> {x. Xh x = h}\"", "lemmas %invisible Ch_consistency = irc_on_consistency_on[OF spec[OF Ch_irc], simplified, of h] for h", "lemmas Ch_irc_idem = consistency_on_f_idem[OF Ch_f_range Ch_consistency, simplified]", "lemma CH_irc_idem:\n  shows \"CH (CH A) = CH A\"", "lemma Ch_CH_irc_idem:\n  shows \"Ch h (CH A) = Ch h A\"", "lemma stable_pair_on_individually_rational:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"individually_rational_on ds (match XD_XH)\"", "lemma stable_pair_on_stable_no_blocking_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_no_blocking_on ds (match XD_XH)\"", "theorem stable_pair_on_stable_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_on ds (match XD_XH)\"", "lemma Ch_XH_largest_Field:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"x \\<in> Field (Pd (Xd x))\"", "lemma Ch_XH_largest_Xd:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"Xd x \\<in> ds\"", "lemma X_subseteq_XH_largest:\n  shows \"X \\<subseteq> XH_largest\"", "lemma X_subseteq_XD_smallest:\n  shows \"X \\<subseteq> XD_smallest\"", "lemma X_XD_smallest_XH_largest:\n  shows \"X = XD_smallest \\<inter> XH_largest\"", "lemma XH_largestCdXXH_largest:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)\"", "lemma CH_XH_largest:\n  shows \"CH XH_largest = X\"", "lemma Cd_XD_smallest:\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (XD_smallest \\<inter> Field (Pd d)) = Cd d (X \\<inter> Field (Pd d))\"", "lemma CD_on_XD_smallest:\n  shows \"CD_on ds XD_smallest = X\"", "theorem stable_on_stable_pair_on:\n  shows \"stable_pair_on ds (XD_smallest, XH_largest)\"", "theorem T1:\n  shows \"stable_on ds X \\<longleftrightarrow> (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> X = match XD_XH)\"", "lemma fix_F_stable_pair_on:\n  assumes \"X = F ds X\"\n  shows \"stable_pair_on ds (map_prod id undual X)\"", "lemma stable_pair_on_fix_F:\n  assumes \"stable_pair_on ds X\"\n  shows \"map_prod id dual X = F ds (map_prod id dual X)\"", "lemma Rh_mono:\n  shows \"mono (Rh h)\"", "lemmas Ch_iia = Rh_mono[unfolded Rf_mono_iia]", "lemmas Ch_Chernoff = Ch_iia[unfolded Chernoff_on_iia_on[symmetric]]", "lemmas Ch_subsitutes_idem = iia_f_idem[OF Ch_f_range Ch_iia, simplified]", "lemma RH_mono:\n  shows \"mono RH\"", "lemmas CH_iia = RH_mono[unfolded Rf_mono_iia]", "lemmas CH_Chernoff = CH_iia[unfolded Chernoff_on_iia_on[symmetric]]", "lemmas CH_substitutes_idem = iia_f_idem[OF CH_f_range_on CH_iia, simplified]", "lemma F1_antimono:\n  shows \"antimono F1\"", "lemma F2_antimono:\n  shows \"antimono (F2 ds)\"", "lemma F_mono:\n  shows \"mono (F ds)\"", "lemmas gfp_F_stable_pair_on = fix_F_stable_pair_on[OF gfp_unfold[OF F_mono], folded gfp_F_def]", "lemmas lfp_F_stable_pair_on = fix_F_stable_pair_on[OF lfp_unfold[OF F_mono], folded lfp_F_def]", "lemma F2_o_F1_mono:\n  shows \"mono (F2 ds \\<circ> F1)\"", "lemmas F2_F1_mono = F2_o_F1_mono[unfolded o_def]", "lemma gfp_F_lfp_F:\n  shows \"gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))\"", "lemmas gfp_F_stable_on = stable_pair_on_stable_on[OF gfp_F_stable_pair_on]", "lemmas lfp_F_stable_on = stable_pair_on_stable_on[OF lfp_F_stable_pair_on]", "lemma gfp_F_code[code]:\n  shows \"gfp_F ds = map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) top)\"", "lemma lfp_F_code[code]:\n  shows \"lfp_F ds = map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) bot)\"", "lemma H2_UNIV:\n  shows \"UNIV = set [H1, H2]\"", "lemma H2_ALL [simp]:\n  shows \"(\\<forall>h. P h) = (\\<forall>h\\<in>{H1, H2}. P h)\"", "lemma H2_UNION:\n  shows \"(\\<Union>h. P h) = (\\<Union>h\\<in>{H1, H2}. P h)\"", "lemma P_D2_H2_d_linear:\n  shows \"Linear_order (P_D2_H2_d d)\"", "lemma P_D2_H2_d_range:\n  shows \"Field (P_D2_H2_d d) \\<subseteq> {x. fst x = d}\"", "lemma P_D2_H2_h_substitutes:\n  shows \"substitutes (P_D2_H2_h h)\"", "lemma P920_example_gfp_F_value:\n  shows \"P920_example_gfp_F UNIV = ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})\"", "lemma P920_example_gfp_F_match_value:\n  shows \"P920_example.match (P920_example_gfp_F UNIV) = {(D1, H1), (D2, H2)}\"", "lemma P920_example_lfp_F_value:\n  shows \"P920_example_lfp_F UNIV = ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})\"", "lemmas doctor_optimal_matchI = iffD2[OF doctor_optimal_match_def, unfolded conj_imp_eq_imp_imp, rule_format]", "lemmas doctor_optimal_match_stable_on = iffD1[OF doctor_optimal_match_def, THEN conjunct1]", "lemmas doctor_optimal_match_optimal = iffD1[OF doctor_optimal_match_def, THEN conjunct2, rule_format]", "lemma doctor_optimal_match_unique:\n  assumes \"doctor_optimal_match ds X\"\n  assumes \"doctor_optimal_match ds Y\"\n  shows \"X = Y\"", "lemma gfp_F_upperbound:\n  shows \"(fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)\"", "lemma XD_XH_gfp_F:\n  shows \"fst XD_XH \\<subseteq> fst (gfp_F ds)\"\n    and \"snd (gfp_F ds) \\<subseteq> snd XD_XH\"", "lemma lfp_F_upperbound:\n  shows \"lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))\"", "lemma XD_XH_lfp_F:\n  shows \"fst (lfp_F ds) \\<subseteq> fst XD_XH\"\n    and \"snd XD_XH \\<subseteq> snd (lfp_F ds)\"", "theorem gfp_f_doctor_optimal:\n  assumes \"x \\<in> match XD_XH\"\n  shows \"\\<exists>y \\<in> match (gfp_F ds). (x, y) \\<in> Pd (Xd x)\"", "theorem lfp_f_doctor_pessimal:\n  assumes \"x \\<in> match (lfp_F ds)\"\n  shows \"\\<exists>y \\<in> match XD_XH. (x, y) \\<in> Pd (Xd x)\"", "theorem (in ContractsWithSubstitutesAndIRC) gfp_F_doctor_optimal_match:\n  shows \"doctor_optimal_match ds (match (gfp_F ds))\"", "theorem lfp_f_hospital_optimal:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> Ch h (match (lfp_F ds))\"\n  shows \"x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)\"", "theorem gfp_f_hospital_pessimal:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> Ch h (match XD_XH)\"\n  shows \"x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)\"", "lemma F'_apply:\n  \"F' (XD, XH) = (- RH (undual XH), dual (- RD_on (ds - {d'}) XD))\"", "lemma %invisible F1'_antimono:\n  shows \"antimono (\\<lambda>XH. - RH XH)\"", "lemma %invisible F2'_antimono:\n  shows \"antimono (\\<lambda>XD. - RD_on (ds-{d'}) XD)\"", "lemma F'_mono:\n  shows \"mono F'\"", "lemma fix_F'_stable_pair_on:\n  \"stable_pair_on (ds - {d'}) (map_prod id undual A)\"\n  if \"A = F' A\"", "lemma F_start:\n  shows \"F ds (XD_smallest ds X, dual (XH_largest ds X)) = (XD_smallest ds X, dual (XH_largest ds X))\"", "lemma F'_start:\n  shows \"(XD_smallest ds X, dual (XH_largest ds X)) \\<le> F' (XD_smallest ds X, dual (XH_largest ds X))\"", "lemma\n  shows F'_iter_stable_pair_on: \"stable_pair_on (ds-{d'}) (map_prod id undual F'_iter)\" (is \"?thesis1\")\n    and F'_start_le_F'_iter: \"(XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\" (is \"?thesis2\")", "lemma F'_iter_match_stable_on:\n  shows \"stable_on (ds-{d'}) F'_iter_match\"", "theorem F'_iter_match_doctors_weakly_better_off:\n  assumes \"x \\<in> Cd d X\"\n  assumes \"d \\<noteq> d'\"\n  shows \"\\<exists>y \\<in> Cd d F'_iter_match. (x, y) \\<in> Pd d\"", "theorem F'_iter_match_hospitals_weakly_worse_off:\n  assumes \"x \\<in> Ch h X\"\n  shows \"x \\<in> Ch h (F'_iter_match \\<union> X)\"", "lemma Cd_XD_gfp_F_card:\n  assumes \"d \\<in> ds\"\n  shows \"card (Cd d (fst XD_XH)) \\<le> card (Cd d (fst (gfp_F ds)))\"", "lemma Ch_gfp_F_XH_card:\n  shows \"card (Ch h (snd (gfp_F ds))) \\<le> card (Ch h (snd XD_XH))\"", "theorem Theorem_8:\n  shows \"d \\<in> ds \\<Longrightarrow> card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\"\n    and \"card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))\"", "lemma (in ContractsWithSubstitutesAndIRC) Theorem_9_counterexample:\n  assumes \"stable_on ds Y\"\n  assumes \"stable_on ds Z\"\n  shows \"card (Ch h Y) = card (Ch h Z)\"", "lemma X3_UNIV:\n  shows \"UNIV = set [Xd1, Xd1', Xd2]\"", "lemmas X3_pow = subset_subseqs[OF subset_trans[OF subset_UNIV Set.equalityD1[OF X3_UNIV]]]", "lemma X3_all_pow:\n  shows \"(\\<forall>X''. P X'') \\<longleftrightarrow> (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2]). P X'')\"", "lemma PX3d_linear:\n  shows \"Linear_order (PX3d d)\"", "lemma PX3d_range:\n  shows \"Field (PX3d d) \\<subseteq> {x. X3d x = d}\"", "lemma CX3h_range:\n  shows \"CX3h h X \\<subseteq> {x\\<in>X. X3h x = h}\"", "lemma CX3h_singular:\n  shows \"inj_on X3d (CX3h h X)\"", "lemma CX3h_substitutes:\n  shows \"substitutes (CX3h h)\"", "lemma CX3h_irc:\n  shows \"irc (CX3h h)\"", "lemma Theorem_9_stable_Xd1':\n  shows \"Theorem_9.stable_on UNIV {Xd1'}\"", "lemma Theorem_9_stable_Xd1_Xd2:\n  shows \"Theorem_9.stable_on UNIV {Xd1, Xd2}\"", "theorem\n  shows \"card (Theorem_9.CH {Xd1'}) \\<noteq> card (Theorem_9.CH {Xd1, Xd2})\"", "lemma CX3h_not_lad:\n  shows \"\\<not>lad (CX3h h)\"", "lemma cop_F_HM_cop_F:\n  shows \"cop_F_HM ds XD_XH = (- RH (snd XD_XH), cop_F ds (snd XD_XH))\"", "lemma cop_F_increasing:\n  shows \"x \\<le> cop_F ds x\"", "lemma cop_F_cases:\n  assumes \"x \\<in> cop_F ds fp\"\n  obtains (fp) \"x \\<in> fp\" | (CD_on) \"x \\<in> CD_on ds (-RH fp) - fp\"", "lemma CH_cop_F_cases:\n  assumes \"x \\<in> CH (cop_F ds fp)\"\n  obtains (CH) \"x \\<in> CH fp\" | (RH_fp) \"x \\<in> RH fp\" | (CD_on) \"x \\<in> CD_on ds (-RH fp) - fp\"", "lemmas fp_cop_F_unfold = COP.fixp_above_unfold[where a=\"{}\", folded fp_cop_F_def, simplified Field_def, simplified]", "lemmas fp_cop_F_code = COP.fixp_above_conv_while[where a=\"{}\", folded fp_cop_F_def, simplified Field_def, simplified]", "lemma fp_cop_F_induct[case_names base step]:\n  assumes \"P {}\"\n  assumes \"\\<And>fp. P fp \\<Longrightarrow> P (cop_F ds fp)\"\n  shows \"P (fp_cop_F ds)\"", "lemma validI[case_names base step]:\n  assumes \"Q ds {}\"\n  assumes \"\\<And>fp. \\<lbrakk>P ds fp; Q ds fp\\<rbrakk> \\<Longrightarrow> Q ds (cop_F ds fp)\"\n  shows \"valid ds P Q\"", "lemma invariant_cop_FD:\n  assumes \"invariant ds P\"\n  assumes \"P ds fp\"\n  shows \"P ds (cop_F ds fp)\"", "lemma invariantD:\n  assumes \"invariant ds P\"\n  shows \"P ds (fp_cop_F ds)\"", "lemma valid_pre:\n  assumes \"valid ds P' Q\"\n  assumes \"\\<And>fp. P ds fp \\<Longrightarrow> P' ds fp\"\n  shows \"valid ds P Q\"", "lemma valid_invariant:\n  assumes \"valid ds P Q\"\n  assumes \"invariant ds P\"\n  shows \"invariant ds (\\<lambda> ds fp. P ds fp \\<and> Q ds fp)\"", "lemma valid_conj:\n  assumes \"valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) P\"\n  assumes \"valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) Q\"\n  shows \"valid ds R (\\<lambda> ds fp. P ds fp \\<and> Q ds fp)\"", "lemma lfp_F2_o_F1_fp_cop_F:\n  shows \"lfp (F2 ds \\<circ> F1) = fp_cop_F ds\"", "theorem Theorem_15:\n  shows \"gfp_F ds = (- RH (fp_cop_F ds), fp_cop_F ds)\"", "theorem Theorem_15_match:\n  shows \"match (gfp_F ds) = CH (fp_cop_F ds)\"", "lemmas P920_example_cop_F_code[code] = P920_example.cop_F_def[folded P920_example_cop_F_def]", "lemmas P920_example_fp_cop_F_code[code] = P920_example.fp_cop_F_code[folded P920_example_fp_cop_F_def P920_example_cop_F_def]", "lemma P920_example_fp_cop_F_value:\n  shows \"P920_example_CH (P920_example_fp_cop_F UNIV) = {(D1, H1), (D2, H2)}\"", "lemma %invisible CH_Ch_singular:\n  assumes \"(UNIV::'h set) = {h}\"\n  shows \"CH A = Ch h A\"", "lemma cop_F_range_inv:\n  shows \"invariant ds cop_F_range_inv\"", "lemma cop_F_closed_inv:\n  shows \"invariant ds cop_F_closed_inv\"", "lemmas fp_cop_F_range_inv = invariantD[OF cop_F_range_inv]", "lemmas fp_cop_F_range_inv' = fp_cop_F_range_inv[unfolded cop_F_range_inv_def, rule_format]", "lemmas fp_cop_F_closed_inv = invariantD[OF cop_F_closed_inv]", "lemmas fp_cop_F_closed_inv' = subsetD[OF bspec[OF invariantD[OF cop_F_closed_inv, unfolded cop_F_closed_inv_def, simplified]]]", "lemma cop_F_RH:\n  assumes \"d \\<in> ds\"\n  assumes \"x \\<in> Field (Pd d)\"\n  assumes \"aboveS (Pd d) x \\<subseteq> RH fp\"\n  shows \"x \\<in> cop_F ds fp\"", "lemma fp_cop_F_all:\n  assumes \"d \\<in> ds\"\n  assumes \"d \\<notin> Xd ` CH (fp_cop_F ds)\"\n  shows \"Field (Pd d) \\<subseteq> fp_cop_F ds\"", "lemma fp_cop_F_preferred:\n  assumes \"y \\<in> CD_on ds (CH (fp_cop_F ds) \\<union> X'')\"\n  assumes \"x \\<in> CH (fp_cop_F ds)\"\n  assumes \"Xd x = Xd y\"\n  shows \"(x, y) \\<in> Pd (Xd x)\"", "lemma X''_closed:\n  assumes \"X'' \\<subseteq> CD_on ds (CH (fp_cop_F ds) \\<union> X'')\"\n  shows \"X'' \\<subseteq> fp_cop_F ds\"", "lemma cop_stable_no_blocking_on:\n  shows \"stable_no_blocking_on ds (cop ds)\"", "theorem Theorem_16:\n  assumes h: \"(UNIV::'c set) = {h}\"\n  shows \"stable_on ds (cop ds)\" (is \"stable_on ds ?fp\")"], "translations": [["", "lemmas Pd_linear' = Pd_linear[rule_format]"], ["", "lemmas Pd_range' = subsetD[OF Pd_range[rule_format], simplified, of x d] for x d"], ["", "lemma Pd_refl:\n  assumes \"x \\<in> Field (Pd d)\"\n  shows \"(x, x) \\<in> Pd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<in> Pd d", "using assms Pd_linear'"], ["proof (prove)\nusing this:\n  x \\<in> Field (Pd d)\n  Linear_order (Pd ?d)\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> Pd d", "by (meson subset_refl underS_incl_iff)"], ["", "lemma Pd_Xd:\n  assumes \"(x, y) \\<in> Pd d\"\n  shows \"Xd x = d \\<and> Xd y = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x = d \\<and> Xd y = d", "using assms Pd_range contra_subsetD"], ["proof (prove)\nusing this:\n  (x, y) \\<in> Pd d\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?B\\<rbrakk>\n  \\<Longrightarrow> ?c \\<notin> ?A\n\ngoal (1 subgoal):\n 1. Xd x = d \\<and> Xd y = d", "unfolding Field_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> Pd d\n  \\<forall>d. Domain (Pd d) \\<union> Range (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?B\\<rbrakk>\n  \\<Longrightarrow> ?c \\<notin> ?A\n\ngoal (1 subgoal):\n 1. Xd x = d \\<and> Xd y = d", "by blast"], ["", "lemma Above_Pd_Xd:\n  assumes \"x \\<in> Above (Pd d) X\"\n  shows \"Xd x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x = d", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Above (Pd d) X\n\ngoal (1 subgoal):\n 1. Xd x = d", "by (blast dest: Above_Field Pd_range')"], ["", "lemma AboveS_Pd_Xd:\n  assumes \"x \\<in> AboveS (Pd d) X\"\n  shows \"Xd x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x = d", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> AboveS (Pd d) X\n\ngoal (1 subgoal):\n 1. Xd x = d", "by (blast dest: AboveS_Field Pd_range')"], ["", "(* Cd *)"], ["", "interpretation Cd: linear_cf \"Pd d\" \"Cd d\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf (Pd d) (Cd d)", "using Cd_def Pd_linear"], ["proof (prove)\nusing this:\n  Cd ?d \\<equiv> set_option \\<circ> MaxR.MaxR_opt (Pd ?d)\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. linear_cf (Pd d) (Cd d)", "by unfold_locales simp_all"], ["", "lemmas Cd_domain = Cd.domain"], ["", "lemmas Cd_f_range = Cd.f_range"], ["", "lemmas Cd_range = Cd.range"], ["", "lemmas Cd_range' = Cd.range'"], ["", "lemmas Rf_Cd_mono = Cd.Rf_mono_on[of UNIV, unfolded mono_on_mono]"], ["", "lemmas Cd_Chernoff = Cd.Chernoff"], ["", "lemmas Cd_path_independent = Cd.path_independent"], ["", "lemmas Cd_iia = Cd.iia"], ["", "lemmas Cd_irc = Cd.irc"], ["", "lemmas Cd_lad = Cd.lad"], ["", "lemmas Cd_mono = Cd.mono"], ["", "lemmas Cd_greatest = Cd.greatest"], ["", "lemmas Cd_preferred = Cd.preferred"], ["", "lemmas Cd_singleton = Cd.singleton"], ["", "lemmas Cd_union = Cd.union"], ["", "lemmas Cd_idem = iia_f_idem[OF Cd.f_range[of UNIV d, folded Cd_def] Cd_iia[of UNIV], simplified] for d"], ["", "lemma Cd_Xd:\n  shows \"x \\<in> Cd d X \\<Longrightarrow> Xd x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Cd d X \\<Longrightarrow> Xd x = d", "using Pd_range Cd_range"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n\ngoal (1 subgoal):\n 1. x \\<in> Cd d X \\<Longrightarrow> Xd x = d", "by fastforce"], ["", "lemma Cd_inj_on_Xd:\n  shows \"inj_on Xd (Cd d X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd (Cd d X)", "by (rule inj_onI) (clarsimp simp: Cd_Xd Cd_singleton)"], ["", "lemma Cd_range_disjoint:\n  assumes \"d \\<noteq> d'\"\n  shows \"Cd d A \\<inter> Cd d' A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d A \\<inter> Cd d' A = {}", "using assms Cd_range Pd_range"], ["proof (prove)\nusing this:\n  d \\<noteq> d'\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n\ngoal (1 subgoal):\n 1. Cd d A \\<inter> Cd d' A = {}", "by blast"], ["", "lemma Cd_single:\n  assumes \"x \\<in> X\"\n  assumes \"inj_on Xd X\"\n  assumes \"x \\<in> Field (Pd d)\"\n  shows \"x \\<in> Cd d X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Cd d X", "using assms Pd_linear"], ["proof (prove)\nusing this:\n  x \\<in> X\n  inj_on Xd X\n  x \\<in> Field (Pd d)\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. x \\<in> Cd d X", "unfolding Cd_greatest greatest_def"], ["proof (prove)\nusing this:\n  x \\<in> X\n  inj_on Xd X\n  x \\<in> Field (Pd d)\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. x \\<in> {x \\<in> X \\<inter> Field (Pd d).\n             \\<forall>y\\<in>X \\<inter> Field (Pd d). (y, x) \\<in> Pd d}", "by clarsimp (metis Pd_Xd inj_on_eq_iff subset_refl underS_incl_iff)"], ["", "lemma Cd_Above:\n  shows \"Cd d X = Above (Pd d) (X \\<inter> Field (Pd d)) \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d X = Above (Pd d) (X \\<inter> Field (Pd d)) \\<inter> X", "unfolding Cd_greatest greatest_Above Above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {b \\<in> Field (Pd d).\n     \\<forall>a\\<in>X \\<inter> Field (Pd d). (a, b) \\<in> Pd d} \\<inter>\n    (X \\<inter> Field (Pd d)) =\n    {b \\<in> Field (Pd d).\n     \\<forall>a\\<in>X \\<inter> Field (Pd d). (a, b) \\<in> Pd d} \\<inter>\n    X", "by blast"], ["", "(* Code generator setup. Repeats a lot of stuff. *)"], ["", "definition maxR :: \"'d \\<Rightarrow> 'x \\<Rightarrow> 'x \\<Rightarrow> 'x\" where\n  \"maxR d x y = (if (x, y) \\<in> Pd d then y else x)\""], ["", "definition MaxR_f :: \"'d \\<Rightarrow> 'x \\<Rightarrow> 'x option \\<Rightarrow> 'x option\" where\n  \"MaxR_f d = (\\<lambda>x acc. if x \\<in> Field (Pd d) then Some (case acc of None \\<Rightarrow> x | Some y \\<Rightarrow> maxR d x y) else acc)\""], ["", "lemma MaxR_maxR:\n  shows \"MaxR.maxR (Pd d) = maxR d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR.maxR (Pd d) = maxR d", "by (simp add: fun_eq_iff maxR_def Cd.maxR_code)"], ["", "lemma MaxR_MaxR_f:\n  shows \"MaxR.MaxR_f (Pd d) = MaxR_f d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR.MaxR_f (Pd d) = MaxR_f d", "by (simp add: fun_eq_iff Cd.MaxR_f_code MaxR_f_def MaxR_maxR cong: option.case_cong)"], ["", "lemmas Cd_code[code] = Cd.code[unfolded MaxR_MaxR_f]"], ["", "lemma Cd_simps[simp, nitpick_simp]:\n  shows \"Cd d {} = {}\"\n        \"Cd d (insert x A) = (if x \\<in> Field (Pd d) then if Cd d A = {} then {x} else {maxR d x y |y. y \\<in> Cd d A} else Cd d A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d {} = {} &&&\n    Cd d (insert x A) =\n    (if x \\<in> Field (Pd d)\n     then if Cd d A = {} then {x} else {maxR d x y |y. y \\<in> Cd d A}\n     else Cd d A)", "unfolding Cd.simps MaxR_maxR"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = {} &&&\n    (if x \\<in> Field (Pd d)\n     then if Cd d A = {} then {x} else {maxR d x y |y. y \\<in> Cd d A}\n     else Cd d A) =\n    (if x \\<in> Field (Pd d)\n     then if Cd d A = {} then {x} else {maxR d x y |y. y \\<in> Cd d A}\n     else Cd d A)", "by simp_all"], ["", "(* CD *)"], ["", "lemma CD_on_def2:\n  shows \"CD_on ds A = (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds A = (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d)))", "using Cd_domain"], ["proof (prove)\nusing this:\n  Cd ?d (?X \\<inter> Field (Pd ?d)) = Cd ?d ?X\n\ngoal (1 subgoal):\n 1. CD_on ds A = (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d)))", "unfolding CD_on_def"], ["proof (prove)\nusing this:\n  Cd ?d (?X \\<inter> Field (Pd ?d)) = Cd ?d ?X\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d A) =\n    (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d)))", "by blast"], ["", "lemma CD_on_Xd:\n  assumes \"x \\<in> CD_on ds A\"\n  shows \"Xd x \\<in> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "using assms Cd_Xd"], ["proof (prove)\nusing this:\n  x \\<in> CD_on ds A\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "unfolding CD_on_def"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>d\\<in>ds. Cd d A)\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "by blast"], ["", "lemma mem_CD_on_Cd:\n  shows \"x \\<in> CD_on ds X \\<longleftrightarrow> (x \\<in> Cd (Xd x) X \\<and> Xd x \\<in> ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> CD_on ds X) = (x \\<in> Cd (Xd x) X \\<and> Xd x \\<in> ds)", "unfolding CD_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>d\\<in>ds. Cd d X)) =\n    (x \\<in> Cd (Xd x) X \\<and> Xd x \\<in> ds)", "using Cd_range Cd_Xd"], ["proof (prove)\nusing this:\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>d\\<in>ds. Cd d X)) =\n    (x \\<in> Cd (Xd x) X \\<and> Xd x \\<in> ds)", "by blast"], ["", "lemma CD_on_domain:\n  assumes \"d \\<in> ds\"\n  shows \"CD_on ds A \\<inter> Field (Pd d) = Cd d (A \\<inter> Field (Pd d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds A \\<inter> Field (Pd d) = Cd d (A \\<inter> Field (Pd d))", "unfolding CD_on_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d))) \\<inter>\n    Field (Pd d) =\n    Cd d (A \\<inter> Field (Pd d))", "using assms Cd_range"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d (A \\<inter> Field (Pd d))) \\<inter>\n    Field (Pd d) =\n    Cd d (A \\<inter> Field (Pd d))", "by (force dest: Pd_range')"], ["", "lemma CD_on_range:\n  shows \"CD_on ds A \\<subseteq> A \\<inter> (\\<Union>d\\<in>ds. Field (Pd d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds A \\<subseteq> A \\<inter> (\\<Union>d\\<in>ds. Field (Pd d))", "using Cd_range"], ["proof (prove)\nusing this:\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n\ngoal (1 subgoal):\n 1. CD_on ds A \\<subseteq> A \\<inter> (\\<Union>d\\<in>ds. Field (Pd d))", "unfolding CD_on_def"], ["proof (prove)\nusing this:\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d A)\n    \\<subseteq> A \\<inter> (\\<Union>d\\<in>ds. Field (Pd d))", "by blast"], ["", "lemmas CD_on_range' = subsetD[OF CD_on_range]"], ["", "lemma CD_on_f_range_on:\n  shows \"f_range_on A (CD_on ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_range_on A (CD_on ds)", "by (rule f_range_onI) (meson CD_on_range Int_subset_iff)"], ["", "lemma RD_on_mono:\n  shows \"mono (RD_on ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Rf (CD_on ds))", "unfolding CD_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>X. X - (\\<Union>d\\<in>ds. Cd d X))", "by (rule monoI) (auto dest: monoD[OF Rf_Cd_mono])"], ["", "lemma CD_on_Chernoff:\n  shows \"Chernoff (CD_on ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff (CD_on ds)", "using mono_on_mono RD_on_mono[of ds] Rf_mono_on_iia_on[of UNIV] Chernoff_on_iia_on"], ["proof (prove)\nusing this:\n  Basis.mono_on UNIV = mono\n  mono (Rf (CD_on ds))\n  Basis.mono_on (Pow UNIV) (Rf ?f) = iia ?f\n  Chernoff_on ?A ?f = iia_on ?A ?f\n\ngoal (1 subgoal):\n 1. Chernoff (CD_on ds)", "by (simp add: fun_eq_iff) blast"], ["", "lemma CD_on_irc:\n  shows \"irc (CD_on ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irc (CD_on ds)", "by (rule ircI) (fastforce simp: CD_on_def ircD[OF Cd_irc] simp del: Cd_simps cong: SUP_cong)"], ["", "lemmas CD_on_consistency = irc_on_consistency_on[OF CD_on_irc, simplified]"], ["", "lemma CD_on_path_independent:\n  shows \"path_independent (\\<lambda>X. CD_on ds X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent (CD_on ds)", "using CD_on_f_range_on CD_on_Chernoff CD_on_consistency"], ["proof (prove)\nusing this:\n  f_range_on ?A (CD_on ?ds)\n  Chernoff (CD_on ?ds)\n  consistency (CD_on ?ds)\n\ngoal (1 subgoal):\n 1. path_independent (CD_on ds)", "by (blast intro: path_independent_onI2)"], ["", "lemma CD_on_simps:\n  shows \"CD_on ds {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds {} = {}", "using CD_on_range"], ["proof (prove)\nusing this:\n  CD_on ?ds ?A \\<subseteq> ?A \\<inter> (\\<Union>d\\<in>?ds. Field (Pd d))\n\ngoal (1 subgoal):\n 1. CD_on ds {} = {}", "by blast"], ["", "lemmas CD_on_iia = RD_on_mono[unfolded Rf_mono_iia]"], ["", "lemmas CD_on_idem = iia_f_idem[OF CD_on_f_range_on CD_on_iia, simplified]"], ["", "lemma CD_on_inj_on_Xd:\n  shows \"inj_on Xd (CD_on ds X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd (CD_on ds X)", "unfolding CD_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd (\\<Union>d\\<in>ds. Cd d X)", "by (rule inj_onI) (clarsimp simp: Cd_Xd Cd_singleton)"], ["", "lemma CD_on_card:\n  shows \"card (CD_on ds X) = (\\<Sum>d\\<in>ds. card (Cd d X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (CD_on ds X) = (\\<Sum>d\\<in>ds. card (Cd d X))", "unfolding CD_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>d\\<in>ds. Cd d X) = (\\<Sum>d\\<in>ds. card (Cd d X))", "by (simp add: card_UN_disjoint Cd_range_disjoint)"], ["", "lemma CD_on_closed:\n  assumes \"inj_on Xd X\"\n  assumes \"X \\<subseteq> (\\<Union>d\\<in>ds. Field (Pd d))\"\n  shows \"CD_on ds X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds X = X", "using assms Cd_domain Cd_single[OF _ assms(1)]"], ["proof (prove)\nusing this:\n  inj_on Xd X\n  X \\<subseteq> (\\<Union>d\\<in>ds. Field (Pd d))\n  Cd ?d (?X \\<inter> Field (Pd ?d)) = Cd ?d ?X\n  \\<lbrakk>?x \\<in> X; ?x \\<in> Field (Pd ?d)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> Cd ?d X\n\ngoal (1 subgoal):\n 1. CD_on ds X = X", "unfolding CD_on_def2"], ["proof (prove)\nusing this:\n  inj_on Xd X\n  X \\<subseteq> (\\<Union>d\\<in>ds. Field (Pd d))\n  Cd ?d (?X \\<inter> Field (Pd ?d)) = Cd ?d ?X\n  \\<lbrakk>?x \\<in> X; ?x \\<in> Field (Pd ?d)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> Cd ?d X\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d (X \\<inter> Field (Pd d))) = X", "by (force dest: Cd_range')"], ["", "(* Ch *)"], ["", "lemmas Ch_singular' = Ch_singular[rule_format]"], ["", "lemmas Ch_range' = subsetD[OF Ch_range[rule_format], simplified, of x h X] for x h X"], ["", "lemma Ch_simps:\n  shows \"Ch h {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h {} = {}", "using Ch_range"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. Ch h {} = {}", "by blast"], ["", "lemma Ch_range_disjoint:\n  assumes \"h \\<noteq> h'\"\n  shows \"Ch h A \\<inter> Ch h' A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h A \\<inter> Ch h' A = {}", "using assms Ch_range"], ["proof (prove)\nusing this:\n  h \\<noteq> h'\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. Ch h A \\<inter> Ch h' A = {}", "by blast"], ["", "lemma Ch_f_range:\n  shows \"f_range (Ch h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_range (Ch h)", "using Ch_range"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. f_range (Ch h)", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>UNIV. Ch h B \\<subseteq> B", "by blast"], ["", "(* CH *)"], ["", "lemma CH_card:\n  shows \"card (CH X) = (\\<Sum>h\\<in>UNIV. card (Ch h X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (CH X) = (\\<Sum>h\\<in>UNIV. card (Ch h X))", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (\\<Union>h. Ch h X) = (\\<Sum>h\\<in>UNIV. card (Ch h X))", "by (simp add: card_UN_disjoint Ch_range_disjoint)"], ["", "lemma CH_simps:\n  shows \"CH {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH {} = {}", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h {}) = {}", "by (simp add: Ch_simps)"], ["", "lemma CH_range:\n  shows \"CH A \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH A \\<subseteq> A", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) \\<subseteq> A", "using Ch_range"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) \\<subseteq> A", "by blast"], ["", "lemmas CH_range' = subsetD[OF CH_range]"], ["", "lemmas CH_f_range_on = f_range_onI[OF CH_range]"], ["", "lemma mem_CH_Ch:\n  shows \"x \\<in> CH X \\<longleftrightarrow> x \\<in> Ch (Xh x) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> CH X) = (x \\<in> Ch (Xh x) X)", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>h. Ch h X)) = (x \\<in> Ch (Xh x) X)", "using Ch_range"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. (x \\<in> (\\<Union>h. Ch h X)) = (x \\<in> Ch (Xh x) X)", "by blast"], ["", "lemma mem_Ch_CH:\n  assumes \"x \\<in> Ch h X\"\n  shows \"x \\<in> CH X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> CH X", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>h. Ch h X)", "using assms Ch_range"], ["proof (prove)\nusing this:\n  x \\<in> Ch h X\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>h. Ch h X)", "by blast"], ["", "(*>*)"], ["", "text\\<open>\n\nAn @{emph \\<open>allocation\\<close>} is a set of contracts where each names a distinct\ndoctor. (Hospitals can contract multiple doctors.)\n\n\\<close>"], ["", "abbreviation (input) allocation :: \"'x set \\<Rightarrow> bool\" where\n  \"allocation \\<equiv> inj_on Xd\""], ["", "text\\<open>\n\nWe often wish to extract a doctor's or a hospital's contract from an\n@{const \"allocation\"}.\n\n\\<close>"], ["", "definition dX :: \"'x set \\<Rightarrow> 'd \\<Rightarrow> 'x set\" where\n  \"dX X d = {x \\<in> X. Xd x = d}\""], ["", "definition hX :: \"'x set \\<Rightarrow> 'h \\<Rightarrow> 'x set\" where\n  \"hX X h = {x \\<in> X. Xh x = h}\""], ["", "(*<*)"], ["", "lemma dX_union:\n  shows \"dX (X \\<union> Y) d = dX X d \\<union> dX Y d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dX (X \\<union> Y) d = dX X d \\<union> dX Y d", "unfolding dX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X \\<union> Y. Xd x = d} =\n    {x \\<in> X. Xd x = d} \\<union> {x \\<in> Y. Xd x = d}", "by auto"], ["", "lemma dX_range:\n  shows \"\\<forall>d. dX X d \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d. dX X d \\<subseteq> {x. Xd x = d}", "unfolding dX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d. {x \\<in> X. Xd x = d} \\<subseteq> {x. Xd x = d}", "by clarsimp"], ["", "lemma dX_range':\n  assumes \"x \\<in> dX X d\"\n  shows \"x \\<in> X \\<and> Xd x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<and> Xd x = d", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> dX X d\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<and> Xd x = d", "unfolding dX_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. Xd x = d}\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<and> Xd x = d", "by simp"], ["", "lemma dX_empty_or_singleton:\n  assumes \"allocation X\"\n  shows \"\\<forall>d. dX X d = {} \\<or> (\\<exists>x. dX X d = {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d. dX X d = {} \\<or> (\\<exists>x. dX X d = {x})", "unfolding dX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d.\n       {x \\<in> X. Xd x = d} = {} \\<or>\n       (\\<exists>x. {x \\<in> X. Xd x = d} = {x})", "using \\<open>allocation X\\<close>"], ["proof (prove)\nusing this:\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. \\<forall>d.\n       {x \\<in> X. Xd x = d} = {} \\<or>\n       (\\<exists>x. {x \\<in> X. Xd x = d} = {x})", "by (fastforce dest: inj_onD)"], ["", "lemma dX_linear:\n  assumes \"allocation X\"\n  shows \"Linear_order (dX X d \\<times> dX X d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (dX X d \\<times> dX X d)", "using spec[OF dX_empty_or_singleton[OF \\<open>allocation X\\<close>], where x=d]"], ["proof (prove)\nusing this:\n  dX X d = {} \\<or> (\\<exists>x. dX X d = {x})\n\ngoal (1 subgoal):\n 1. Linear_order (dX X d \\<times> dX X d)", "by fastforce"], ["", "lemma dX_singular:\n  assumes \"allocation X\"\n  assumes \"x \\<in> X\"\n  assumes \"d = Xd x\"\n  shows \"dX X d = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dX X d = {x}", "using assms"], ["proof (prove)\nusing this:\n  inj_on Xd X\n  x \\<in> X\n  d = Xd x\n\ngoal (1 subgoal):\n 1. dX X d = {x}", "unfolding dX_def"], ["proof (prove)\nusing this:\n  inj_on Xd X\n  x \\<in> X\n  d = Xd x\n\ngoal (1 subgoal):\n 1. {x \\<in> X. Xd x = d} = {x}", "by (fastforce dest: inj_onD)"], ["", "lemma dX_Int_Field_Pd:\n  assumes \"dX X d \\<subseteq> Field (Pd d)\"\n  shows \"X \\<inter> Field (Pd d) = dX X d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) = dX X d", "using assms"], ["proof (prove)\nusing this:\n  dX X d \\<subseteq> Field (Pd d)\n\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) = dX X d", "unfolding dX_def"], ["proof (prove)\nusing this:\n  {x \\<in> X. Xd x = d} \\<subseteq> Field (Pd d)\n\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) = {x \\<in> X. Xd x = d}", "by (fastforce dest: Pd_range')"], ["", "lemma Cd_Above_dX:\n  assumes \"dX X d \\<subseteq> Field (Pd d)\"\n  shows \"Cd d X = Above (Pd d) (dX X d) \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d X = Above (Pd d) (dX X d) \\<inter> X", "using assms"], ["proof (prove)\nusing this:\n  dX X d \\<subseteq> Field (Pd d)\n\ngoal (1 subgoal):\n 1. Cd d X = Above (Pd d) (dX X d) \\<inter> X", "unfolding Cd_greatest greatest_Above Above_def dX_def"], ["proof (prove)\nusing this:\n  {x \\<in> X. Xd x = d} \\<subseteq> Field (Pd d)\n\ngoal (1 subgoal):\n 1. {b \\<in> Field (Pd d).\n     \\<forall>a\\<in>X \\<inter> Field (Pd d). (a, b) \\<in> Pd d} \\<inter>\n    (X \\<inter> Field (Pd d)) =\n    {b \\<in> Field (Pd d).\n     \\<forall>a\\<in>{x \\<in> X. Xd x = d}. (a, b) \\<in> Pd d} \\<inter>\n    X", "by (auto dest: Pd_range')"], ["", "(*>*)"], ["", "text\\<open>\n\n@{emph \\<open>Stability\\<close>} is the key property we look for in a match (here a\nset of contracts), and consists of two parts.\n\nFirstly, we ask that it be @{emph \\<open>individually rational\\<close>}, i.e., the\ncontracts in the match are actually acceptable to all\nparticipants. Note that this implies the match is an @{const\n\"allocation\"}.\n\n\\<close>"], ["", "definition individually_rational_on :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"individually_rational_on ds X \\<longleftrightarrow> CD_on ds X = X \\<and> CH X = X\""], ["", "abbreviation individually_rational :: \"'x set \\<Rightarrow> bool\" where\n  \"individually_rational \\<equiv> individually_rational_on UNIV\""], ["", "text\\<open>\n\nThe second condition requires that there be no coalition of a hospital\nand one or more doctors who prefer another set of contracts involving\nthem; the hospital strictly, the doctors weakly. Contrast this\ndefinition with the classical one for stable marriages given in\n\\S\\ref{sec:sotomayor}.\n\n\\<close>"], ["", "definition blocking_on :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> 'h \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"blocking_on ds X h X' \\<longleftrightarrow> X' \\<noteq> Ch h X \\<and> X' = Ch h (X \\<union> X') \\<and> X' \\<subseteq> CD_on ds (X \\<union> X')\""], ["", "definition stable_no_blocking_on :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"stable_no_blocking_on ds X \\<longleftrightarrow> (\\<forall>h X'. \\<not>blocking_on ds X h X')\""], ["", "abbreviation stable_no_blocking :: \"'x set \\<Rightarrow> bool\" where\n  \"stable_no_blocking \\<equiv> stable_no_blocking_on UNIV\""], ["", "definition stable_on :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"stable_on ds X \\<longleftrightarrow> individually_rational_on ds X \\<and> stable_no_blocking_on ds X\""], ["", "abbreviation stable :: \"'x set \\<Rightarrow> bool\" where\n  \"stable \\<equiv> stable_on UNIV\""], ["", "(*<*)"], ["", "lemma stable_onI:\n  assumes \"individually_rational_on ds X\"\n  assumes \"stable_no_blocking_on ds X\"\n  shows \"stable_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_on ds X", "unfolding stable_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds X \\<and> stable_no_blocking_on ds X", "using assms"], ["proof (prove)\nusing this:\n  individually_rational_on ds X\n  stable_no_blocking_on ds X\n\ngoal (1 subgoal):\n 1. individually_rational_on ds X \\<and> stable_no_blocking_on ds X", "by blast"], ["", "lemma individually_rational_onI:\n  assumes \"CD_on ds X = X\"\n  assumes \"CH X = X\"\n  shows \"individually_rational_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds X", "unfolding individually_rational_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds X = X \\<and> CH X = X", "using assms"], ["proof (prove)\nusing this:\n  CD_on ds X = X\n  CH X = X\n\ngoal (1 subgoal):\n 1. CD_on ds X = X \\<and> CH X = X", "by blast"], ["", "lemma individually_rational_on_CD_on:\n  assumes \"individually_rational_on ds X\"\n  shows \"CD_on ds X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds X = X", "using assms"], ["proof (prove)\nusing this:\n  individually_rational_on ds X\n\ngoal (1 subgoal):\n 1. CD_on ds X = X", "unfolding individually_rational_on_def"], ["proof (prove)\nusing this:\n  CD_on ds X = X \\<and> CH X = X\n\ngoal (1 subgoal):\n 1. CD_on ds X = X", "by blast"], ["", "lemma individually_rational_on_Cd:\n  assumes \"individually_rational_on ds X\"\n  shows \"Cd d X = dX X d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d X = dX X d", "using individually_rational_on_CD_on[OF assms]"], ["proof (prove)\nusing this:\n  CD_on ds X = X\n\ngoal (1 subgoal):\n 1. Cd d X = dX X d", "by (auto simp: dX_def mem_CD_on_Cd dest: Cd_range' Cd_Xd)"], ["", "lemma individually_rational_on_empty:\n  shows \"individually_rational_on ds {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds {}", "by (simp add: CD_on_simps CH_simps individually_rational_onI)"], ["", "lemma blocking_onI:\n  assumes \"X'' \\<noteq> Ch h X\"\n  assumes \"X'' = Ch h (X \\<union> X'')\"\n  assumes \"\\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\"\n  shows \"blocking_on ds X h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blocking_on ds X h X''", "unfolding blocking_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h X \\<and>\n    X'' = Ch h (X \\<union> X'') \\<and>\n    X'' \\<subseteq> CD_on ds (X \\<union> X'')", "using assms"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X\n  X'' = Ch h (X \\<union> X'')\n  ?x \\<in> X'' \\<Longrightarrow> ?x \\<in> CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h X \\<and>\n    X'' = Ch h (X \\<union> X'') \\<and>\n    X'' \\<subseteq> CD_on ds (X \\<union> X'')", "by blast"], ["", "lemma blocking_on_imp_not_stable:\n  assumes \"blocking_on ds X h X''\"\n  shows \"\\<not>stable_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> stable_on ds X", "unfolding stable_on_def stable_no_blocking_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (individually_rational_on ds X \\<and>\n            (\\<forall>h X'. \\<not> blocking_on ds X h X'))", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. \\<not> (individually_rational_on ds X \\<and>\n            (\\<forall>h X'. \\<not> blocking_on ds X h X'))", "by blast"], ["", "lemma blocking_on_allocation:\n  assumes \"blocking_on ds X h X''\"\n  shows \"allocation X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd X''", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. inj_on Xd X''", "unfolding blocking_on_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X \\<and>\n  X'' = Ch h (X \\<union> X'') \\<and>\n  X'' \\<subseteq> CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. inj_on Xd X''", "by (metis Ch_singular')"], ["", "lemma blocking_on_Field:\n  assumes \"blocking_on ds X h X''\"\n  shows \"dX X'' d \\<subseteq> Field (Pd d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dX X'' d \\<subseteq> Field (Pd d)", "using assms blocking_on_allocation[OF assms]"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n  inj_on Xd X''\n\ngoal (1 subgoal):\n 1. dX X'' d \\<subseteq> Field (Pd d)", "unfolding blocking_on_def dX_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X \\<and>\n  X'' = Ch h (X \\<union> X'') \\<and>\n  X'' \\<subseteq> CD_on ds (X \\<union> X'')\n  inj_on Xd X''\n\ngoal (1 subgoal):\n 1. {x \\<in> X''. Xd x = d} \\<subseteq> Field (Pd d)", "by (force simp: Pd_range' dest: CD_on_range')"], ["", "lemma blocking_on_CD_on:\n  assumes \"blocking_on ds X h X''\"\n  shows \"X'' \\<subseteq> CD_on ds (X \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (X \\<union> X'')", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (X \\<union> X'')", "unfolding blocking_on_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X \\<and>\n  X'' = Ch h (X \\<union> X'') \\<and>\n  X'' \\<subseteq> CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (X \\<union> X'')", "by blast"], ["", "lemma blocking_on_CD_on':\n  assumes \"blocking_on ds X h X''\"\n  assumes \"x \\<in> X''\"\n  shows \"x \\<in> CD_on ds (X \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n  x \\<in> X''\n\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "unfolding blocking_on_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X \\<and>\n  X'' = Ch h (X \\<union> X'') \\<and>\n  X'' \\<subseteq> CD_on ds (X \\<union> X'')\n  x \\<in> X''\n\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "by blast"], ["", "lemma blocking_on_Cd:\n  assumes \"blocking_on ds X h X''\"\n  shows \"dX X'' d \\<subseteq> Cd d (X \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dX X'' d \\<subseteq> Cd d (X \\<union> X'')", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. dX X'' d \\<subseteq> Cd d (X \\<union> X'')", "unfolding blocking_on_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h X \\<and>\n  X'' = Ch h (X \\<union> X'') \\<and>\n  X'' \\<subseteq> CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. dX X'' d \\<subseteq> Cd d (X \\<union> X'')", "by (force dest: dX_range' simp: mem_CD_on_Cd)"], ["", "lemma stable_no_blocking_onI:\n  assumes \"\\<And>h X''. \\<lbrakk>X'' = Ch h (X \\<union> X''); X'' \\<noteq> Ch h X; X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"stable_no_blocking_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds X", "unfolding stable_no_blocking_on_def blocking_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h X'.\n       \\<not> (X' \\<noteq> Ch h X \\<and>\n               X' = Ch h (X \\<union> X') \\<and>\n               X' \\<subseteq> CD_on ds (X \\<union> X'))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?X'' = Ch ?h (X \\<union> ?X''); ?X'' \\<noteq> Ch ?h X;\n   ?X'' \\<subseteq> CD_on ds (X \\<union> ?X'')\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>h X'.\n       \\<not> (X' \\<noteq> Ch h X \\<and>\n               X' = Ch h (X \\<union> X') \\<and>\n               X' \\<subseteq> CD_on ds (X \\<union> X'))", "by blast"], ["", "lemma stable_no_blocking_onI2:\n  assumes \"\\<And>h X''. blocking_on ds X h X'' \\<Longrightarrow> False\"\n  shows \"stable_no_blocking_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds X", "unfolding stable_no_blocking_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h X'. \\<not> blocking_on ds X h X'", "using assms"], ["proof (prove)\nusing this:\n  blocking_on ds X ?h ?X'' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>h X'. \\<not> blocking_on ds X h X'", "by blast"], ["", "lemma \"stable_no_blocking_on ds UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds UNIV", "using stable_no_blocking_onI"], ["proof (prove)\nusing this:\n  (\\<And>h X''.\n      \\<lbrakk>X'' = Ch h (?X \\<union> X''); X'' \\<noteq> Ch h ?X;\n       X'' \\<subseteq> CD_on ?ds (?X \\<union> X'')\\<rbrakk>\n      \\<Longrightarrow> False) \\<Longrightarrow>\n  stable_no_blocking_on ?ds ?X\n\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds UNIV", "by fastforce"], ["", "lemma\n  assumes \"stable_on ds X\"\n  shows stable_on_CD_on: \"CD_on ds X = X\"\n    and stable_on_Xd: \"x \\<in> X \\<Longrightarrow> Xd x \\<in> ds\"\n    and stable_on_range': \"x \\<in> X \\<Longrightarrow> x \\<in> Field (Pd (Xd x))\"\n    and stable_on_CH: \"CH X = X\"\n    and stable_on_no_blocking_on: \"stable_no_blocking_on ds X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CD_on ds X = X &&& (x \\<in> X \\<Longrightarrow> Xd x \\<in> ds)) &&&\n    (x \\<in> X \\<Longrightarrow> x \\<in> Field (Pd (Xd x))) &&&\n    CH X = X &&& stable_no_blocking_on ds X", "using assms mem_CD_on_Cd Cd_range' Pd_range'"], ["proof (prove)\nusing this:\n  stable_on ds X\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> ?x \\<in> ?X \\<inter> Field (Pd ?d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. (CD_on ds X = X &&& (x \\<in> X \\<Longrightarrow> Xd x \\<in> ds)) &&&\n    (x \\<in> X \\<Longrightarrow> x \\<in> Field (Pd (Xd x))) &&&\n    CH X = X &&& stable_no_blocking_on ds X", "unfolding stable_on_def individually_rational_on_def"], ["proof (prove)\nusing this:\n  (CD_on ds X = X \\<and> CH X = X) \\<and> stable_no_blocking_on ds X\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> ?x \\<in> ?X \\<inter> Field (Pd ?d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. (CD_on ds X = X &&& (x \\<in> X \\<Longrightarrow> Xd x \\<in> ds)) &&&\n    (x \\<in> X \\<Longrightarrow> x \\<in> Field (Pd (Xd x))) &&&\n    CH X = X &&& stable_no_blocking_on ds X", "by blast+"], ["", "lemma stable_on_allocation:\n  assumes \"stable_on ds X\"\n  shows \"allocation X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd X", "using assms"], ["proof (prove)\nusing this:\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. inj_on Xd X", "unfolding stable_on_def individually_rational_on_def"], ["proof (prove)\nusing this:\n  (CD_on ds X = X \\<and> CH X = X) \\<and> stable_no_blocking_on ds X\n\ngoal (1 subgoal):\n 1. inj_on Xd X", "by (metis CD_on_inj_on_Xd)"], ["", "lemma stable_on_blocking_onD:\n  assumes \"stable_on ds X\"\n  shows \"\\<lbrakk>X'' = Ch h (X \\<union> X''); X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk> \\<Longrightarrow> X'' = Ch h X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X'' = Ch h (X \\<union> X'');\n     X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk>\n    \\<Longrightarrow> X'' = Ch h X", "using \\<open>stable_on ds X\\<close>"], ["proof (prove)\nusing this:\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X'' = Ch h (X \\<union> X'');\n     X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk>\n    \\<Longrightarrow> X'' = Ch h X", "unfolding stable_on_def individually_rational_on_def stable_no_blocking_on_def blocking_on_def"], ["proof (prove)\nusing this:\n  (CD_on ds X = X \\<and> CH X = X) \\<and>\n  (\\<forall>h X'.\n      \\<not> (X' \\<noteq> Ch h X \\<and>\n              X' = Ch h (X \\<union> X') \\<and>\n              X' \\<subseteq> CD_on ds (X \\<union> X')))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X'' = Ch h (X \\<union> X'');\n     X'' \\<subseteq> CD_on ds (X \\<union> X'')\\<rbrakk>\n    \\<Longrightarrow> X'' = Ch h X", "by blast"], ["", "lemma not_stable_on_cases[consumes 1, case_names not_individually_rational not_no_blocking]:\n  assumes \"\\<not> stable_on ds X\"\n  assumes \"\\<not> individually_rational_on ds X \\<Longrightarrow> P\"\n  assumes \"\\<not> stable_no_blocking_on ds X \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  \\<not> stable_on ds X\n  \\<not> individually_rational_on ds X \\<Longrightarrow> P\n  \\<not> stable_no_blocking_on ds X \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding stable_on_def"], ["proof (prove)\nusing this:\n  \\<not> (individually_rational_on ds X \\<and> stable_no_blocking_on ds X)\n  \\<not> individually_rational_on ds X \\<Longrightarrow> P\n  \\<not> stable_no_blocking_on ds X \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by blast"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "end"], ["", "subsection\\<open> Theorem~1: Existence of stable pairs \\<close>"], ["", "text\\<open>\n\nWe proceed to define a function whose fixed points capture all stable\nmatches. \\citet[I(B), p917]{HatfieldMilgrom:2005} provide the\nfollowing intuition:\n\\begin{quote}\n\nThe first theorem states that a set of contracts is stable if any\nalternative contract would be rejected by some doctor or some hospital\nfrom its suitably defined opportunity set. In the formulas below,\nthink of the doctors' opportunity set as @{term \"XD\"} and the\nhospitals' opportunity set as @{term \"XH\"}. If @{term \"X'\"} is the\ncorresponding stable set, then @{term \"XD\"} must include, in addition\nto @{term \"X'\"}, all contracts that would not be rejected by the\nhospitals, and @{term \"XH\"} must similarly include @{term \"X'\"} and\nall contracts that would not be rejected by the doctors. If @{term\n\"X'\"} is stable, then every alternative contract is rejected by\nsomebody, so @{term \"X = XH \\<union> XD\"} [where @{term \"X\"} is the\nset of all contracts]. This logic is summarized in the first theorem.\n\n\\end{quote}\nSee also \\citet[p6,\\S4]{Fleiner:2003} and \\citet[\\S2]{Fleiner:2002},\nfrom whom we adopt the term @{emph \\<open>stable pair\\<close>}.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition stable_pair_on :: \"'d set \\<Rightarrow> 'x set \\<times> 'x set \\<Rightarrow> bool\" where\n  \"stable_pair_on ds = (\\<lambda>(XD, XH). XD = - RH XH \\<and> XH = - RD_on ds XD)\""], ["", "abbreviation stable_pair :: \"'x set \\<times> 'x set \\<Rightarrow> bool\" where\n  \"stable_pair \\<equiv> stable_pair_on UNIV\""], ["", "abbreviation match :: \"'x set \\<times> 'x set \\<Rightarrow> 'x set\" where\n  \"match X \\<equiv> fst X \\<inter> snd X\""], ["", "text \\<open>\n\n\\citet[Theorem~1]{HatfieldMilgrom:2005} state that every solution\n@{term \"(XD, XH)\"} of @{const \"stable_pair\"} yields a stable match\n@{term \"XD \\<inter> XH\"}, and conversely, i.e., every stable match is\nthe intersection of some stable pair. \\citet{AygunSonmez:2012-WP2}\nshow that neither is the case without further restrictions on the\nhospitals' choice functions @{term \"Ch\"}; we exhibit their\ncounterexample below.\n\nEven so we can establish some properties in the present setting:\n\n\\<close>"], ["", "lemma stable_pair_on_CD_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"match XD_XH = CD_on ds (fst XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match XD_XH = CD_on ds (fst XD_XH)", "using %invisible assms CD_on_range"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  CD_on ?ds ?A \\<subseteq> ?A \\<inter> (\\<Union>d\\<in>?ds. Field (Pd d))\n\ngoal (1 subgoal):\n 1. match XD_XH = CD_on ds (fst XD_XH)", "unfolding stable_pair_on_def split_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n  CD_on ?ds ?A \\<subseteq> ?A \\<inter> (\\<Union>d\\<in>?ds. Field (Pd d))\n\ngoal (1 subgoal):\n 1. match XD_XH = CD_on ds (fst XD_XH)", "by blast"], ["", "lemma stable_pair_on_CH:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"match XD_XH = CH (snd XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match XD_XH = CH (snd XD_XH)", "using %invisible assms CH_range"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  CH ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. match XD_XH = CH (snd XD_XH)", "unfolding stable_pair_on_def split_def fst_conv snd_conv"], ["proof (prove)\nusing this:\n  fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n  CH ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. match XD_XH = CH (snd XD_XH)", "by blast"], ["", "lemma stable_pair_on_CD_on_CH:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"CD_on ds (fst XD_XH) = CH (snd XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds (fst XD_XH) = CH (snd XD_XH)", "using %invisible assms stable_pair_on_CD_on stable_pair_on_CH"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  match ?XD_XH = CD_on ?ds (fst ?XD_XH)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow> match ?XD_XH = CH (snd ?XD_XH)\n\ngoal (1 subgoal):\n 1. CD_on ds (fst XD_XH) = CH (snd XD_XH)", "by blast"], ["", "lemma stable_pair_on_allocation:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"allocation (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd (match XD_XH)", "unfolding %invisible stable_pair_on_CD_on[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Xd (CD_on ds (fst XD_XH))", "by (rule CD_on_inj_on_Xd)"], ["", "(*<*)"], ["", "lemma stable_pair_onI:\n  assumes \"fst XD_XH = - RH (snd XD_XH)\"\n  assumes \"snd XD_XH = - RD_on ds (fst XD_XH)\"\n  shows \"stable_pair_on ds XD_XH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_pair_on ds XD_XH", "using assms"], ["proof (prove)\nusing this:\n  fst XD_XH = - Rf CH (snd XD_XH)\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n\ngoal (1 subgoal):\n 1. stable_pair_on ds XD_XH", "unfolding stable_pair_on_def split_def"], ["proof (prove)\nusing this:\n  fst XD_XH = - Rf CH (snd XD_XH)\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n\ngoal (1 subgoal):\n 1. fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n    snd XD_XH = - Rf (CD_on ds) (fst XD_XH)", "by blast"], ["", "lemma stable_pair_onE:\n  shows \"\\<lbrakk>stable_pair_on ds XD_XH; \\<lbrakk>- RH (snd XD_XH) = fst XD_XH; - RD_on ds (fst XD_XH) = snd XD_XH\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stable_pair_on ds XD_XH;\n     \\<lbrakk>- Rf CH (snd XD_XH) = fst XD_XH;\n      - Rf (CD_on ds) (fst XD_XH) = snd XD_XH\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding stable_pair_on_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n             snd XD_XH = - Rf (CD_on ds) (fst XD_XH);\n     \\<lbrakk>- Rf CH (snd XD_XH) = fst XD_XH;\n      - Rf (CD_on ds) (fst XD_XH) = snd XD_XH\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "lemma stable_pair_on_Cd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (fst XD_XH) = match XD_XH \\<inter> Field (Pd d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d (fst XD_XH) = match XD_XH \\<inter> Field (Pd d)", "using stable_pair_on_CD_on[OF \\<open>stable_pair_on ds XD_XH\\<close>] CD_on_domain Cd_domain \\<open>d \\<in> ds\\<close>"], ["proof (prove)\nusing this:\n  match XD_XH = CD_on ds (fst XD_XH)\n  ?d \\<in> ?ds \\<Longrightarrow>\n  CD_on ?ds ?A \\<inter> Field (Pd ?d) = Cd ?d (?A \\<inter> Field (Pd ?d))\n  Cd ?d (?X \\<inter> Field (Pd ?d)) = Cd ?d ?X\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. Cd d (fst XD_XH) = match XD_XH \\<inter> Field (Pd d)", "by simp"], ["", "lemma stable_pair_on_Cd_match:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (match XD_XH) = Cd d (fst XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d (match XD_XH) = Cd d (fst XD_XH)", "using assms"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. Cd d (match XD_XH) = Cd d (fst XD_XH)", "by (metis Cd_domain Cd_idem stable_pair_on_Cd)"], ["", "lemma stable_pair_on_Xd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> match XD_XH\"\n  shows \"Xd x \\<in> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "using assms CD_on_Xd"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  x \\<in> match XD_XH\n  ?x \\<in> CD_on ?ds ?A \\<Longrightarrow> Xd ?x \\<in> ?ds\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "unfolding stable_pair_on_def split_def"], ["proof (prove)\nusing this:\n  fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n  x \\<in> match XD_XH\n  ?x \\<in> CD_on ?ds ?A \\<Longrightarrow> Xd ?x \\<in> ?ds\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "by blast"], ["", "lemma stable_pair_on_match_Cd:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> match XD_XH\"\n  shows \"x \\<in> Cd (Xd x) (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (match XD_XH)", "using assms"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  x \\<in> match XD_XH\n\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (match XD_XH)", "by (metis (full_types) CD_on_def Cd_Xd UN_iff stable_pair_on_CD_on stable_pair_on_Cd_match)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe run out of steam on the following two lemmas, which are the\nremaining requirements for stability.\n\n\\<close>"], ["", "lemma\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"individually_rational_on ds (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds (match XD_XH)", "oops"], ["", "lemma\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_no_blocking (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on UNIV (match XD_XH)", "oops"], ["", "text\\<open>\n\n\\citet{HatfieldMilgrom:2005} also claim that the converse holds:\n\n\\<close>"], ["", "lemma\n  assumes \"stable_on ds X\"\n  obtains XD_XH where \"stable_pair_on ds XD_XH\" and \"X = match XD_XH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>XD_XH.\n        \\<lbrakk>stable_pair_on ds XD_XH; X = match XD_XH\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "oops"], ["", "text\\<open>\n\nAgain, the following counterexample shows that the @{const\nsubstitutes} condition on @{term \"Ch\"} is too weak to guarantee\nthis. We show it holds under stronger assumptions in\n\\S\\ref{sec:contracts-t1-converse}.\n\n\\<close>"], ["", "end"], ["", "subsubsection\\<open> Theorem~1 does not hold \\citep{AygunSonmez:2012-WP2} \\label{sec:contracts-t1-counterexample} \\<close>"], ["", "text\\<open>\n\nThe following counterexample, due to \\citet[\\S3:\nExample~2]{AygunSonmez:2012-WP2}, comprehensively demonstrates that\n\\citet[Theorem~1]{HatfieldMilgrom:2005} does not hold.\n\nWe create three types: \\<open>D2\\<close> consists of two elements,\nrepresenting the doctors, and \\<open>H\\<close> is the type of the single\nhospital. There are four contracts in the type \\<open>X4\\<close>.\n\n\\<close>"], ["", "datatype D2 = D1 | D2"], ["", "datatype H1 = H"], ["", "datatype X4 = Xd1 | Xd1' | Xd2 | Xd2'"], ["", "(*<*)"], ["", "lemma D2_UNIV:\n  shows \"UNIV = set [D1, D2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set [D1, D2]", "using D2.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = D1 \\<Longrightarrow> ?P;\n   ?y = D2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = set [D1, D2]", "by auto"], ["", "instantiation D2 :: enum\nbegin"], ["", "definition \"enum_class.enum = [D1, D2]\""], ["", "definition \"enum_class.enum_all P = (P D1 \\<and> P D2)\""], ["", "definition \"enum_class.enum_ex P = (P D1 \\<or> P D2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(D2, enum_class)", "by standard (simp_all add: enum_D2_def enum_all_D2_def enum_ex_D2_def D2_UNIV)"], ["", "end"], ["", "lemma D2_ALL:\n  shows \"(\\<forall>d. P d) = (\\<forall>d\\<in>{D1, D2}. P d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>d. P d) = (\\<forall>d\\<in>{D1, D2}. P d)", "using D2_UNIV"], ["proof (prove)\nusing this:\n  UNIV = set [D1, D2]\n\ngoal (1 subgoal):\n 1. (\\<forall>d. P d) = (\\<forall>d\\<in>{D1, D2}. P d)", "by auto"], ["", "lemma D2_UNION:\n  shows \"(\\<Union>d. P d) = (\\<Union>d\\<in>{D1, D2}. P d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range P) = \\<Union> (P ` {D1, D2})", "using D2_UNIV"], ["proof (prove)\nusing this:\n  UNIV = set [D1, D2]\n\ngoal (1 subgoal):\n 1. \\<Union> (range P) = \\<Union> (P ` {D1, D2})", "by auto"], ["", "instance H1 :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(H1, finite_class)", "by standard (metis (full_types) H1.exhaust ex_new_if_finite finite.intros(1) finite_insert insert_subset subset_insertI)"], ["", "lemma X4_UNIV:\n  shows \"UNIV = set [Xd1, Xd1', Xd2, Xd2']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set [Xd1, Xd1', Xd2, Xd2']", "using X4.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Xd1 \\<Longrightarrow> ?P; ?y = Xd1' \\<Longrightarrow> ?P;\n   ?y = Xd2 \\<Longrightarrow> ?P; ?y = Xd2' \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = set [Xd1, Xd1', Xd2, Xd2']", "by auto"], ["", "lemmas X4_pow = subset_subseqs[OF subset_trans[OF subset_UNIV Set.equalityD1[OF X4_UNIV]]]"], ["", "instance X4 :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(X4, finite_class)", "by standard (simp add: X4_UNIV)"], ["", "lemma X4_ALL:\n  shows \"(\\<forall>X''. P X'') \\<longleftrightarrow> (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2, Xd2']). P X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>X''. P X'') =\n    (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2, Xd2']). P X'')", "using X4_pow"], ["proof (prove)\nusing this:\n  ?X \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\n\ngoal (1 subgoal):\n 1. (\\<forall>X''. P X'') =\n    (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2, Xd2']). P X'')", "by blast"], ["", "(*>*)"], ["", "primrec X4d :: \"X4 \\<Rightarrow> D2\" where\n  \"X4d Xd1 = D1\"\n| \"X4d Xd1' = D1\"\n| \"X4d Xd2 = D2\"\n| \"X4d Xd2' = D2\""], ["", "abbreviation X4h :: \"X4 \\<Rightarrow> H1\" where\n  \"X4h _ \\<equiv> H\""], ["", "primrec PX4d :: \"D2 \\<Rightarrow> X4 rel\" where\n  \"PX4d D1 = linord_of_list [Xd1', Xd1]\"\n| \"PX4d D2 = linord_of_list [Xd2, Xd2']\""], ["", "function CX4h :: \"H1 \\<Rightarrow> X4 cfun\" where\n  \"CX4h _ {Xd1} = {Xd1}\"\n| \"CX4h _ {Xd1'} = {Xd1'}\"\n| \"CX4h _ {Xd2} = {Xd2}\"\n| \"CX4h _ {Xd2'} = {Xd2'}\"\n| \"CX4h _ {Xd1, Xd1'} = {Xd1}\"\n| \"CX4h _ {Xd1, Xd2} = {Xd1, Xd2}\"\n| \"CX4h _ {Xd1, Xd2'} = {Xd2'}\"\n| \"CX4h _ {Xd1', Xd2} = {Xd1'}\"\n| \"CX4h _ {Xd1', Xd2'} = {Xd1', Xd2'}\"\n| \"CX4h _ {Xd2, Xd2'} = {Xd2}\"\n| \"CX4h _ {Xd1, Xd1', Xd2} = {}\"\n| \"CX4h _ {Xd1, Xd1', Xd2'} = {}\"\n| \"CX4h _ {Xd1, Xd2, Xd2'} = {}\"\n| \"CX4h _ {Xd1', Xd2, Xd2'} = {}\"\n| \"CX4h _ {Xd1, Xd1', Xd2, Xd2'} = {}\"\n| \"CX4h _ {} = {}\""], ["proof (prove)\ngoal (137 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {Xd2'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {Xd1, Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {Xd1, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vc_. x = (vc_, {Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vd_. x = (vd_, {Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>ve_. x = (ve_, {Xd1, Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vf_. x = (vf_, {Xd1, Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vg_. x = (vg_, {Xd1, Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vh_. x = (vh_, {Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vi_. x = (vi_, {Xd1, Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vj_. x = (vj_, {}) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {Xd1}) = (uua_, {Xd1}) \\<Longrightarrow> {Xd1} = {Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {Xd1}) = (uv_, {Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {Xd1}) = (uw_, {Xd2}) \\<Longrightarrow> {Xd1} = {Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {Xd1}) = (ux_, {Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 6. \\<And>uu_ uy_.\n       (uu_, {Xd1}) = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1}\n 7. \\<And>uu_ uz_.\n       (uu_, {Xd1}) = (uz_, {Xd1, Xd2}) \\<Longrightarrow> {Xd1} = {Xd1, Xd2}\n 8. \\<And>uu_ va_.\n       (uu_, {Xd1}) = (va_, {Xd1, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 9. \\<And>uu_ vb_.\n       (uu_, {Xd1}) = (vb_, {Xd1', Xd2}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 10. \\<And>uu_ vc_.\n        (uu_, {Xd1}) = (vc_, {Xd1', Xd2'}) \\<Longrightarrow>\n        {Xd1} = {Xd1', Xd2'}\nA total of 137 subgoals...", "apply %invisible (case_tac x)"], ["proof (prove)\ngoal (137 subgoals):\n 1. \\<And>P x a b.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {Xd2'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {Xd1, Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {Xd1, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vc_. x = (vc_, {Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vd_. x = (vd_, {Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>ve_. x = (ve_, {Xd1, Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vf_. x = (vf_, {Xd1, Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vg_. x = (vg_, {Xd1, Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vh_. x = (vh_, {Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vi_. x = (vi_, {Xd1, Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vj_. x = (vj_, {}) \\<Longrightarrow> P; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {Xd1}) = (uua_, {Xd1}) \\<Longrightarrow> {Xd1} = {Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {Xd1}) = (uv_, {Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {Xd1}) = (uw_, {Xd2}) \\<Longrightarrow> {Xd1} = {Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {Xd1}) = (ux_, {Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 6. \\<And>uu_ uy_.\n       (uu_, {Xd1}) = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1}\n 7. \\<And>uu_ uz_.\n       (uu_, {Xd1}) = (uz_, {Xd1, Xd2}) \\<Longrightarrow> {Xd1} = {Xd1, Xd2}\n 8. \\<And>uu_ va_.\n       (uu_, {Xd1}) = (va_, {Xd1, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 9. \\<And>uu_ vb_.\n       (uu_, {Xd1}) = (vb_, {Xd1', Xd2}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 10. \\<And>uu_ vc_.\n        (uu_, {Xd1}) = (vc_, {Xd1', Xd2'}) \\<Longrightarrow>\n        {Xd1} = {Xd1', Xd2'}\nA total of 137 subgoals...", "apply (cut_tac X=b in X4_pow)"], ["proof (prove)\ngoal (137 subgoals):\n 1. \\<And>P x a b.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {Xd2'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {Xd1, Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {Xd1, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vc_. x = (vc_, {Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vd_. x = (vd_, {Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>ve_. x = (ve_, {Xd1, Xd1', Xd2}) \\<Longrightarrow> P;\n        \\<And>vf_. x = (vf_, {Xd1, Xd1', Xd2'}) \\<Longrightarrow> P;\n        \\<And>vg_. x = (vg_, {Xd1, Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vh_. x = (vh_, {Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vi_. x = (vi_, {Xd1, Xd1', Xd2, Xd2'}) \\<Longrightarrow> P;\n        \\<And>vj_. x = (vj_, {}) \\<Longrightarrow> P; x = (a, b);\n        b \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {Xd1}) = (uua_, {Xd1}) \\<Longrightarrow> {Xd1} = {Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {Xd1}) = (uv_, {Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {Xd1}) = (uw_, {Xd2}) \\<Longrightarrow> {Xd1} = {Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {Xd1}) = (ux_, {Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 6. \\<And>uu_ uy_.\n       (uu_, {Xd1}) = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1}\n 7. \\<And>uu_ uz_.\n       (uu_, {Xd1}) = (uz_, {Xd1, Xd2}) \\<Longrightarrow> {Xd1} = {Xd1, Xd2}\n 8. \\<And>uu_ va_.\n       (uu_, {Xd1}) = (va_, {Xd1, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 9. \\<And>uu_ vb_.\n       (uu_, {Xd1}) = (vb_, {Xd1', Xd2}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 10. \\<And>uu_ vc_.\n        (uu_, {Xd1}) = (vc_, {Xd1', Xd2'}) \\<Longrightarrow>\n        {Xd1} = {Xd1', Xd2'}\nA total of 137 subgoals...", "apply simp"], ["proof (prove)\ngoal (137 subgoals):\n 1. \\<And>P x a b.\n       \\<lbrakk>b = {Xd1} \\<Longrightarrow> P;\n        b = {Xd1'} \\<Longrightarrow> P; b = {Xd2} \\<Longrightarrow> P;\n        b = {Xd2'} \\<Longrightarrow> P; b = {Xd1, Xd1'} \\<Longrightarrow> P;\n        b = {Xd1, Xd2} \\<Longrightarrow> P;\n        b = {Xd1, Xd2'} \\<Longrightarrow> P;\n        b = {Xd1', Xd2} \\<Longrightarrow> P;\n        b = {Xd1', Xd2'} \\<Longrightarrow> P;\n        b = {Xd2, Xd2'} \\<Longrightarrow> P;\n        b = {Xd1, Xd1', Xd2} \\<Longrightarrow> P;\n        b = {Xd1, Xd1', Xd2'} \\<Longrightarrow> P;\n        b = {Xd1, Xd2, Xd2'} \\<Longrightarrow> P;\n        b = {Xd1', Xd2, Xd2'} \\<Longrightarrow> P;\n        b = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow> P;\n        b = {} \\<Longrightarrow> P; x = (a, b);\n        b = {Xd1, Xd1', Xd2, Xd2'} \\<or>\n        b = {Xd1, Xd1', Xd2} \\<or>\n        b = {Xd1, Xd1', Xd2'} \\<or>\n        b = {Xd1, Xd1'} \\<or>\n        b = {Xd1, Xd2, Xd2'} \\<or>\n        b = {Xd1, Xd2} \\<or>\n        b = {Xd1, Xd2'} \\<or>\n        b = {Xd1} \\<or>\n        b = {Xd1', Xd2, Xd2'} \\<or>\n        b = {Xd1', Xd2} \\<or>\n        b = {Xd1', Xd2'} \\<or>\n        b = {Xd1'} \\<or>\n        b = {Xd2, Xd2'} \\<or>\n        b = {Xd2} \\<or> b = {Xd2'} \\<or> b = {}\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {Xd1}) = (uua_, {Xd1}) \\<Longrightarrow> {Xd1} = {Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {Xd1}) = (uv_, {Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {Xd1}) = (uw_, {Xd2}) \\<Longrightarrow> {Xd1} = {Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {Xd1}) = (ux_, {Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 6. \\<And>uu_ uy_.\n       (uu_, {Xd1}) = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1}\n 7. \\<And>uu_ uz_.\n       (uu_, {Xd1}) = (uz_, {Xd1, Xd2}) \\<Longrightarrow> {Xd1} = {Xd1, Xd2}\n 8. \\<And>uu_ va_.\n       (uu_, {Xd1}) = (va_, {Xd1, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 9. \\<And>uu_ vb_.\n       (uu_, {Xd1}) = (vb_, {Xd1', Xd2}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 10. \\<And>uu_ vc_.\n        (uu_, {Xd1}) = (vc_, {Xd1', Xd2'}) \\<Longrightarrow>\n        {Xd1} = {Xd1', Xd2'}\nA total of 137 subgoals...", "apply force"], ["proof (prove)\ngoal (136 subgoals):\n 1. \\<And>uu_ uua_.\n       (uu_, {Xd1}) = (uua_, {Xd1}) \\<Longrightarrow> {Xd1} = {Xd1}\n 2. \\<And>uu_ uv_.\n       (uu_, {Xd1}) = (uv_, {Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 3. \\<And>uu_ uw_.\n       (uu_, {Xd1}) = (uw_, {Xd2}) \\<Longrightarrow> {Xd1} = {Xd2}\n 4. \\<And>uu_ ux_.\n       (uu_, {Xd1}) = (ux_, {Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 5. \\<And>uu_ uy_.\n       (uu_, {Xd1}) = (uy_, {Xd1, Xd1'}) \\<Longrightarrow> {Xd1} = {Xd1}\n 6. \\<And>uu_ uz_.\n       (uu_, {Xd1}) = (uz_, {Xd1, Xd2}) \\<Longrightarrow> {Xd1} = {Xd1, Xd2}\n 7. \\<And>uu_ va_.\n       (uu_, {Xd1}) = (va_, {Xd1, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2'}\n 8. \\<And>uu_ vb_.\n       (uu_, {Xd1}) = (vb_, {Xd1', Xd2}) \\<Longrightarrow> {Xd1} = {Xd1'}\n 9. \\<And>uu_ vc_.\n       (uu_, {Xd1}) = (vc_, {Xd1', Xd2'}) \\<Longrightarrow>\n       {Xd1} = {Xd1', Xd2'}\n 10. \\<And>uu_ vd_.\n        (uu_, {Xd1}) = (vd_, {Xd2, Xd2'}) \\<Longrightarrow> {Xd1} = {Xd2}\nA total of 136 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All CX4h_dom", "by %invisible lexicographic_order"], ["", "lemma PX4d_linear:\n  shows \"Linear_order (PX4d d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (PX4d d)", "by (cases d) (simp_all add: linord_of_list_Linear_order)"], ["", "lemma PX4d_range:\n  shows \"Field (PX4d d) \\<subseteq> {x. X4d x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (PX4d d) \\<subseteq> {x. X4d x = d}", "by (cases d) simp_all"], ["", "lemma CX4h_range:\n  shows \"CX4h h X \\<subseteq> {x \\<in> X. H = h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CX4h h X \\<subseteq> {x \\<in> X. H = h}", "by (cases \"(h, X)\" rule: CX4h.cases) (auto simp: spec[OF H1.nchotomy, of h])"], ["", "lemma CX4h_singular:\n  shows \"inj_on X4d (CX4h h X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on X4d (CX4h h X)", "by (cases \"(h, X)\" rule: CX4h.cases) auto"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "interpretation StableNoDecomp: Contracts X4d X4h PX4d CX4h"], ["proof (prove)\ngoal (1 subgoal):\n 1. Contracts X4d X4h PX4d CX4h", "using %invisible PX4d_linear PX4d_range CX4h_range CX4h_singular"], ["proof (prove)\nusing this:\n  Linear_order (PX4d ?d)\n  Field (PX4d ?d) \\<subseteq> {x. X4d x = ?d}\n  CX4h ?h ?X \\<subseteq> {x \\<in> ?X. H = ?h}\n  inj_on X4d (CX4h ?h ?X)\n\ngoal (1 subgoal):\n 1. Contracts X4d X4h PX4d CX4h", "by unfold_locales blast+"], ["", "text\\<open>\n\nThere are two stable matches in this model.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma Xd1_Xd2_stable:\n  shows \"StableNoDecomp.stable {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_on UNIV {Xd1, Xd2}", "proof(rule StableNoDecomp.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. StableNoDecomp.individually_rational_on UNIV {Xd1, Xd2}\n 2. StableNoDecomp.stable_no_blocking_on UNIV {Xd1, Xd2}", "show \"StableNoDecomp.individually_rational {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.individually_rational_on UNIV {Xd1, Xd2}", "by (simp add: StableNoDecomp.individually_rational_on_def StableNoDecomp.CD_on_def\n      StableNoDecomp.CH_def insert_commute D2_UNION cong add: SUP_cong_simp)"], ["proof (state)\nthis:\n  StableNoDecomp.individually_rational_on UNIV {Xd1, Xd2}\n\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_no_blocking_on UNIV {Xd1, Xd2}", "show \"StableNoDecomp.stable_no_blocking {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_no_blocking_on UNIV {Xd1, Xd2}", "apply (rule StableNoDecomp.stable_no_blocking_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV\n                     ({Xd1, Xd2} \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule_tac x=\"(H, X'')\" in CX4h.cases)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>h X'' uu_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (uu_, {Xd1})\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>h X'' uv_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (uv_, {Xd1'})\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>h X'' uw_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (uw_, {Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>h X'' ux_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (ux_, {Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>h X'' uy_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (uy_, {Xd1, Xd1'})\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>h X'' uz_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (uz_, {Xd1, Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>h X'' va_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (va_, {Xd1, Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>h X'' vb_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (vb_, {Xd1', Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>h X'' vc_.\n       \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1, Xd2};\n        X'' \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n        (H, X'') = (vc_, {Xd1', Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>h X'' vd_.\n        \\<lbrakk>X'' = CX4h h ({Xd1, Xd2} \\<union> X'');\n         X'' \\<noteq> CX4h h {Xd1, Xd2};\n         X''\n         \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1, Xd2} \\<union> X'');\n         (H, X'') = (vd_, {Xd2, Xd2'})\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 16 subgoals...", "apply (simp_all add: insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  StableNoDecomp.stable_no_blocking_on UNIV {Xd1, Xd2}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Xd1'_Xd2'_stable:\n  shows \"StableNoDecomp.stable {Xd1', Xd2'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_on UNIV {Xd1', Xd2'}", "proof(rule StableNoDecomp.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. StableNoDecomp.individually_rational_on UNIV {Xd1', Xd2'}\n 2. StableNoDecomp.stable_no_blocking_on UNIV {Xd1', Xd2'}", "show \"StableNoDecomp.individually_rational {Xd1', Xd2'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.individually_rational_on UNIV {Xd1', Xd2'}", "by (simp add: StableNoDecomp.individually_rational_on_def StableNoDecomp.CD_on_def\n      StableNoDecomp.CH_def insert_commute D2_UNION cong add: SUP_cong_simp)"], ["proof (state)\nthis:\n  StableNoDecomp.individually_rational_on UNIV {Xd1', Xd2'}\n\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_no_blocking_on UNIV {Xd1', Xd2'}", "show \"StableNoDecomp.stable_no_blocking {Xd1', Xd2'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_no_blocking_on UNIV {Xd1', Xd2'}", "apply (rule StableNoDecomp.stable_no_blocking_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV\n                     ({Xd1', Xd2'} \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule_tac x=\"(H, X'')\" in CX4h.cases)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>h X'' uu_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (uu_, {Xd1})\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>h X'' uv_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (uv_, {Xd1'})\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>h X'' uw_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (uw_, {Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>h X'' ux_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (ux_, {Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>h X'' uy_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (uy_, {Xd1, Xd1'})\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>h X'' uz_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (uz_, {Xd1, Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>h X'' va_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (va_, {Xd1, Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>h X'' vb_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (vb_, {Xd1', Xd2})\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>h X'' vc_.\n       \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n        X'' \\<noteq> CX4h h {Xd1', Xd2'};\n        X''\n        \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n        (H, X'') = (vc_, {Xd1', Xd2'})\\<rbrakk>\n       \\<Longrightarrow> False\n 10. \\<And>h X'' vd_.\n        \\<lbrakk>X'' = CX4h h ({Xd1', Xd2'} \\<union> X'');\n         X'' \\<noteq> CX4h h {Xd1', Xd2'};\n         X''\n         \\<subseteq> StableNoDecomp.CD_on UNIV ({Xd1', Xd2'} \\<union> X'');\n         (H, X'') = (vd_, {Xd2, Xd2'})\\<rbrakk>\n        \\<Longrightarrow> False\nA total of 16 subgoals...", "apply (simp_all add: insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  StableNoDecomp.stable_no_blocking_on UNIV {Xd1', Xd2'}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma stable:\n  shows \"StableNoDecomp.stable X \\<longleftrightarrow> X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\"\n(*<*)\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_on UNIV X =\n    (X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'})", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_on UNIV X \\<Longrightarrow>\n    X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n 2. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_on UNIV X", "assume ?lhs"], ["proof (state)\nthis:\n  StableNoDecomp.stable_on UNIV X\n\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_on UNIV X \\<Longrightarrow>\n    X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n 2. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_on UNIV X", "then"], ["proof (chain)\npicking this:\n  StableNoDecomp.stable_on UNIV X", "show ?rhs"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_on UNIV X\n\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}", "using X4_pow[where X=X]"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_on UNIV X\n  X \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\n\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}", "unfolding StableNoDecomp.stable_on_def StableNoDecomp.individually_rational_on_def\n              StableNoDecomp.stable_no_blocking_on_def StableNoDecomp.blocking_on_def\n              StableNoDecomp.CD_on_def StableNoDecomp.CH_def"], ["proof (prove)\nusing this:\n  ((\\<Union>d. StableNoDecomp.Cd d X) = X \\<and>\n   (\\<Union>h. CX4h h X) = X) \\<and>\n  (\\<forall>h X'.\n      \\<not> (X' \\<noteq> CX4h h X \\<and>\n              X' = CX4h h (X \\<union> X') \\<and>\n              X' \\<subseteq> (\\<Union>d.\n                                 StableNoDecomp.Cd d (X \\<union> X'))))\n  X \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\n\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}", "by simp (elim disjE, simp_all add: D2_UNION X4_ALL insert_commute StableNoDecomp.maxR_def cong add: SUP_cong_simp)"], ["proof (state)\nthis:\n  X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_on UNIV X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_on UNIV X", "assume ?rhs"], ["proof (state)\nthis:\n  X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n\ngoal (1 subgoal):\n 1. X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_on UNIV X", "then"], ["proof (chain)\npicking this:\n  X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}", "show ?lhs"], ["proof (prove)\nusing this:\n  X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_on UNIV X", "using Xd1_Xd2_stable Xd1'_Xd2'_stable"], ["proof (prove)\nusing this:\n  X = {Xd1, Xd2} \\<or> X = {Xd1', Xd2'}\n  StableNoDecomp.stable_on UNIV {Xd1, Xd2}\n  StableNoDecomp.stable_on UNIV {Xd1', Xd2'}\n\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_on UNIV X", "by blast"], ["proof (state)\nthis:\n  StableNoDecomp.stable_on UNIV X\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nHowever neither arises from a pair \\<open>XD, XH\\<close> that satisfy\n@{const \"StableNoDecomp.stable_pair\"}:\n\n\\<close>"], ["", "lemma StableNoDecomp_XD_XH:\n  shows \"StableNoDecomp.stable_pair (XD, XH) \\<longleftrightarrow> (XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'})\"\n(*<*)\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) =\n    (XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'})", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<Longrightarrow>\n    XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "note image_cong_simp [cong del]"], ["proof (state)\nthis:\n  \\<lbrakk>?M = ?N; \\<And>x. x \\<in> ?N =simp=> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<Longrightarrow>\n    XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "note INF_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Inf (?C ` ?A) = Inf (?D ` ?B)\n\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<Longrightarrow>\n    XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "note SUP_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Sup (?C ` ?A) = Sup (?D ` ?B)\n\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<Longrightarrow>\n    XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "assume ?lhs"], ["proof (state)\nthis:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n\ngoal (2 subgoals):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<Longrightarrow>\n    XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "then"], ["proof (chain)\npicking this:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)", "show ?rhs"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "(* Expand the Cartesian product and check. *)"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "using X4_pow [of XD] X4_pow [of XH]"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n  XD \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\n  XH \\<in> set ` set (subseqs [Xd1, Xd1', Xd2, Xd2'])\n\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>StableNoDecomp.stable_pair_on UNIV (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'} \\<or>\n     XD = {Xd1, Xd1', Xd2} \\<or>\n     XD = {Xd1, Xd1', Xd2'} \\<or>\n     XD = {Xd1, Xd1'} \\<or>\n     XD = {Xd1, Xd2, Xd2'} \\<or>\n     XD = {Xd1, Xd2} \\<or>\n     XD = {Xd1, Xd2'} \\<or>\n     XD = {Xd1} \\<or>\n     XD = {Xd1', Xd2, Xd2'} \\<or>\n     XD = {Xd1', Xd2} \\<or>\n     XD = {Xd1', Xd2'} \\<or>\n     XD = {Xd1'} \\<or>\n     XD = {Xd2, Xd2'} \\<or> XD = {Xd2} \\<or> XD = {Xd2'} \\<or> XD = {};\n     XH = {Xd1, Xd1', Xd2, Xd2'} \\<or>\n     XH = {Xd1, Xd1', Xd2} \\<or>\n     XH = {Xd1, Xd1', Xd2'} \\<or>\n     XH = {Xd1, Xd1'} \\<or>\n     XH = {Xd1, Xd2, Xd2'} \\<or>\n     XH = {Xd1, Xd2} \\<or>\n     XH = {Xd1, Xd2'} \\<or>\n     XH = {Xd1} \\<or>\n     XH = {Xd1', Xd2, Xd2'} \\<or>\n     XH = {Xd1', Xd2} \\<or>\n     XH = {Xd1', Xd2'} \\<or>\n     XH = {Xd1'} \\<or>\n     XH = {Xd2, Xd2'} \\<or>\n     XH = {Xd2} \\<or> XH = {Xd2'} \\<or> XH = {}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "apply (erule StableNoDecomp.stable_pair_onE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>XD = {Xd1, Xd1', Xd2, Xd2'} \\<or>\n             XD = {Xd1, Xd1', Xd2} \\<or>\n             XD = {Xd1, Xd1', Xd2'} \\<or>\n             XD = {Xd1, Xd1'} \\<or>\n             XD = {Xd1, Xd2, Xd2'} \\<or>\n             XD = {Xd1, Xd2} \\<or>\n             XD = {Xd1, Xd2'} \\<or>\n             XD = {Xd1} \\<or>\n             XD = {Xd1', Xd2, Xd2'} \\<or>\n             XD = {Xd1', Xd2} \\<or>\n             XD = {Xd1', Xd2'} \\<or>\n             XD = {Xd1'} \\<or>\n             XD = {Xd2, Xd2'} \\<or>\n             XD = {Xd2} \\<or> XD = {Xd2'} \\<or> XD = {};\n     XH = {Xd1, Xd1', Xd2, Xd2'} \\<or>\n     XH = {Xd1, Xd1', Xd2} \\<or>\n     XH = {Xd1, Xd1', Xd2'} \\<or>\n     XH = {Xd1, Xd1'} \\<or>\n     XH = {Xd1, Xd2, Xd2'} \\<or>\n     XH = {Xd1, Xd2} \\<or>\n     XH = {Xd1, Xd2'} \\<or>\n     XH = {Xd1} \\<or>\n     XH = {Xd1', Xd2, Xd2'} \\<or>\n     XH = {Xd1', Xd2} \\<or>\n     XH = {Xd1', Xd2'} \\<or>\n     XH = {Xd1'} \\<or>\n     XH = {Xd2, Xd2'} \\<or> XH = {Xd2} \\<or> XH = {Xd2'} \\<or> XH = {};\n     - Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH)\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "apply (elim disjE)"], ["proof (prove)\ngoal (256 subgoals):\n 1. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 2. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 3. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 4. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 5. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 6. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 7. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 8. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 9. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n     - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n 10. \\<lbrakk>- Rf StableNoDecomp.CH (snd (XD, XH)) = fst (XD, XH);\n      - Rf (StableNoDecomp.CD_on UNIV) (fst (XD, XH)) = snd (XD, XH);\n      XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2}\\<rbrakk>\n     \\<Longrightarrow> XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\nA total of 256 subgoals...", "apply (simp_all add: StableNoDecomp.CD_on_def StableNoDecomp.CH_def)"], ["proof (prove)\ngoal (244 subgoals):\n 1. \\<lbrakk>- {Xd1, Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     insert Xd1\n      (insert Xd1'\n        (insert Xd2\n          (insert Xd2'\n            (\\<Union>x.\n                if Xd1 \\<in> Field (PX4d x)\n                then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {}\n                     then {Xd1}\n                     else {StableNoDecomp.maxR x Xd1 y |y.\n                           y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n                else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'})))) =\n     {Xd1, Xd1', Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>- {Xd1, Xd1', Xd2} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1', Xd2};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>- {Xd1, Xd1', Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1', Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>- {Xd1'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1'}\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>- {Xd1, Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<lbrakk>UNIV = {Xd1, Xd1', Xd2, Xd2'};\n     (\\<Union>d. StableNoDecomp.Cd d UNIV) = {Xd1, Xd2}; XD = UNIV;\n     XH = {Xd1, Xd2}\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>insert Xd2' (- {Xd1, Xd2'}) = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 8. \\<lbrakk>UNIV = {Xd1, Xd1', Xd2, Xd2'};\n     (\\<Union>d. StableNoDecomp.Cd d UNIV) = {Xd1}; XD = UNIV;\n     XH = {Xd1}\\<rbrakk>\n    \\<Longrightarrow> False\n 9. \\<lbrakk>- {Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1', Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 10. \\<lbrakk>- {Xd2} = {Xd1, Xd1', Xd2, Xd2'};\n      - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n      (\\<Union>x.\n          if Xd1 \\<in> Field (PX4d x)\n          then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n               else {StableNoDecomp.maxR x Xd1 y |y.\n                     y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n          else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n      {Xd1', Xd2};\n      XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2}\\<rbrakk>\n     \\<Longrightarrow> False\nA total of 244 subgoals...", "unfolding X4_UNIV [simplified]"], ["proof (prove)\ngoal (244 subgoals):\n 1. \\<lbrakk>- {Xd1, Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     insert Xd1\n      (insert Xd1'\n        (insert Xd2\n          (insert Xd2'\n            (\\<Union>x.\n                if Xd1 \\<in> Field (PX4d x)\n                then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {}\n                     then {Xd1}\n                     else {StableNoDecomp.maxR x Xd1 y |y.\n                           y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n                else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'})))) =\n     {Xd1, Xd1', Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>- {Xd1, Xd1', Xd2} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1', Xd2};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2}\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>- {Xd1, Xd1', Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1', Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1', Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>- {Xd1'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd1'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd1'}\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>- {Xd1, Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 6. \\<lbrakk>{Xd1, Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     (\\<Union>d. StableNoDecomp.Cd d {Xd1, Xd1', Xd2, Xd2'}) = {Xd1, Xd2};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2}\\<rbrakk>\n    \\<Longrightarrow> False\n 7. \\<lbrakk>insert Xd2' (- {Xd1, Xd2'}) = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 8. \\<lbrakk>{Xd1, Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     (\\<Union>d. StableNoDecomp.Cd d {Xd1, Xd1', Xd2, Xd2'}) = {Xd1};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1}\\<rbrakk>\n    \\<Longrightarrow> False\n 9. \\<lbrakk>- {Xd1', Xd2, Xd2'} = {Xd1, Xd1', Xd2, Xd2'};\n     - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n     (\\<Union>x.\n         if Xd1 \\<in> Field (PX4d x)\n         then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n              else {StableNoDecomp.maxR x Xd1 y |y.\n                    y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n         else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n     {Xd1', Xd2, Xd2'};\n     XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2, Xd2'}\\<rbrakk>\n    \\<Longrightarrow> False\n 10. \\<lbrakk>- {Xd2} = {Xd1, Xd1', Xd2, Xd2'};\n      - {Xd1, Xd1', Xd2, Xd2'} \\<union>\n      (\\<Union>x.\n          if Xd1 \\<in> Field (PX4d x)\n          then if StableNoDecomp.Cd x {Xd1', Xd2, Xd2'} = {} then {Xd1}\n               else {StableNoDecomp.maxR x Xd1 y |y.\n                     y \\<in> StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}}\n          else StableNoDecomp.Cd x {Xd1', Xd2, Xd2'}) =\n      {Xd1', Xd2};\n      XD = {Xd1, Xd1', Xd2, Xd2'}; XH = {Xd1', Xd2}\\<rbrakk>\n     \\<Longrightarrow> False\nA total of 244 subgoals...", "apply (auto simp: D2_ALL D2_UNION X4_ALL insert_commute StableNoDecomp.maxR_def linord_of_list_linord_of_listP)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "assume ?rhs"], ["proof (state)\nthis:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    StableNoDecomp.stable_pair_on UNIV (XD, XH)", "then"], ["proof (chain)\npicking this:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}", "show ?lhs"], ["proof (prove)\nusing this:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n\ngoal (1 subgoal):\n 1. StableNoDecomp.stable_pair_on UNIV (XD, XH)", "unfolding StableNoDecomp.stable_pair_on_def"], ["proof (prove)\nusing this:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n\ngoal (1 subgoal):\n 1. case (XD, XH) of\n    (XD, XH) \\<Rightarrow>\n      XD = - Rf StableNoDecomp.CH XH \\<and>\n      XH = - Rf (StableNoDecomp.CD_on UNIV) XD", "using X4.exhaust"], ["proof (prove)\nusing this:\n  XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'}\n  \\<lbrakk>?y = Xd1 \\<Longrightarrow> ?P; ?y = Xd1' \\<Longrightarrow> ?P;\n   ?y = Xd2 \\<Longrightarrow> ?P; ?y = Xd2' \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. case (XD, XH) of\n    (XD, XH) \\<Rightarrow>\n      XD = - Rf StableNoDecomp.CH XH \\<and>\n      XH = - Rf (StableNoDecomp.CD_on UNIV) XD", "by (auto simp: StableNoDecomp.CH_def)"], ["proof (state)\nthis:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "proposition\n  assumes \"StableNoDecomp.stable_pair (XD, XH)\"\n  shows \"\\<not>StableNoDecomp.stable (XD \\<inter> XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> StableNoDecomp.stable_on UNIV (XD \\<inter> XH)", "using %invisible assms"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_pair_on UNIV (XD, XH)\n\ngoal (1 subgoal):\n 1. \\<not> StableNoDecomp.stable_on UNIV (XD \\<inter> XH)", "apply (subst (asm) StableNoDecomp_XD_XH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    \\<not> StableNoDecomp.stable_on UNIV (XD \\<inter> XH)", "apply (simp add: StableNoDecomp.stable_on_def StableNoDecomp.stable_no_blocking_on_def StableNoDecomp.blocking_on_def StableNoDecomp.individually_rational_on_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. XD = {} \\<and> XH = {Xd1, Xd1', Xd2, Xd2'} \\<Longrightarrow>\n    \\<exists>h X'.\n       X' = CX4h h X' \\<and>\n       X' \\<noteq> {} \\<and> X' \\<subseteq> StableNoDecomp.CD_on UNIV X'", "apply (auto simp: StableNoDecomp.mem_CD_on_Cd MaxR_def exI[where x=D1] exI[where x=H] exI[where x=\"{Xd1}\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\nMoreover the converse of Theorem~1 does not hold either: the single\ndecomposition that satisfies @{const \"StableNoDecomp.stable_pair\"} (@{thm\n[source] \"StableNoDecomp_XD_XH\"}) does not yield a stable match:\n\n\\<close>"], ["", "proposition\n  assumes \"StableNoDecomp.stable X\"\n  shows \"\\<not>(\\<exists>XD XH. StableNoDecomp.stable_pair (XD, XH) \\<and> X = XD \\<inter> XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>XD XH.\n       StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<and> X = XD \\<inter> XH", "using %invisible assms StableNoDecomp_XD_XH stable"], ["proof (prove)\nusing this:\n  StableNoDecomp.stable_on UNIV X\n  StableNoDecomp.stable_pair_on UNIV (?XD, ?XH) =\n  (?XD = {} \\<and> ?XH = {Xd1, Xd1', Xd2, Xd2'})\n  StableNoDecomp.stable_on UNIV ?X =\n  (?X = {Xd1, Xd2} \\<or> ?X = {Xd1', Xd2'})\n\ngoal (1 subgoal):\n 1. \\<nexists>XD XH.\n       StableNoDecomp.stable_pair_on UNIV (XD, XH) \\<and> X = XD \\<inter> XH", "by fastforce"], ["", "text\\<open>\n\nSo there is not hope for \\citet[Theorem~1]{HatfieldMilgrom:2005} as it\nstands. Note that the counterexample satisfies the @{const \"substitutes\"}\ncondition (see \\S\\ref{sec:cf-substitutes}):\n\n\\<close>"], ["", "lemma\n  shows \"substitutes (CX4h H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes (CX4h H)", "proof %invisible (rule substitutes_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX4h H (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b B))", "fix A a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX4h H (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b B))", "assume \"b \\<notin> CX4h H (insert b A)\""], ["proof (state)\nthis:\n  b \\<notin> CX4h H (insert b A)\n\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX4h H (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b B))", "then"], ["proof (chain)\npicking this:\n  b \\<notin> CX4h H (insert b A)", "show \"b \\<notin> CX4h H (insert a (insert b A))\""], ["proof (prove)\nusing this:\n  b \\<notin> CX4h H (insert b A)\n\ngoal (1 subgoal):\n 1. b \\<notin> CX4h H (insert a (insert b A))", "apply (case_tac [!] a)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 2. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 3. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd2\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 4. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd2'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))", "apply (case_tac [!] b)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1; b = Xd1\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 2. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1; b = Xd1'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 3. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1; b = Xd2\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 4. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1; b = Xd2'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 5. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1'; b = Xd1\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 6. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1'; b = Xd1'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 7. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1'; b = Xd2\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 8. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd1'; b = Xd2'\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 9. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd2; b = Xd1\\<rbrakk>\n    \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\n 10. \\<lbrakk>b \\<notin> CX4h H (insert b A); a = Xd2; b = Xd1'\\<rbrakk>\n     \\<Longrightarrow> b \\<notin> CX4h H (insert a (insert b A))\nA total of 16 subgoals...", "apply ( (rule CX4h.cases[of \"(H, A)\"], auto simp: insert_commute)[1] )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b \\<notin> CX4h H (insert a (insert b A))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nTherefore while @{const \"substitutes\"} supports the monotonicity argument\nthat underpins their deferred-acceptance algorithm (see\n\\S\\ref{sec:contracts-algorithmics}), it is not enough to rescue\nTheorem~1. One way forward is to constrain the hospitals'\nchoice functions, which we discuss in the next section.\n\n\\<close>"], ["", "subsubsection\\<open> Theorem 1 holds with @{emph \\<open>independence of rejected contracts\\<close>} \\label{sec:contracts-irc} \\<close>"], ["", "text\\<open>\n\n\\citet{AygunSonmez:2012-WP2} propose to rectify this issue by\nrequiring hospitals' choices to satisfy @{const \"irc\"}\n(\\S\\ref{sec:cf-irc}). Reassuringly their counterexample fails to\nsatisfy it:\n\n\\<close>"], ["", "lemma\n  shows \"\\<not>irc (CX4h H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> irc (CX4h H)", "by %invisible (fastforce simp: insert_commute dest: irc_onD[where a=\"Xd2\" and B=\"{Xd1, Xd1'}\"])"], ["", "text\\<open>\n\nWe adopt this hypothesis by extending the @{const \"Contracts\"} locale:\n\n\\<close>"], ["", "locale ContractsWithIRC = Contracts +\n  assumes Ch_irc: \"\\<forall>h. irc (Ch h)\"\nbegin"], ["", "text\\<open>\n\nThis property requires that \\<open>Ch\\<close> behave, for example, as\nfollows:\n\n\\<close>"], ["", "lemma Ch_domain:\n  shows \"Ch h (A \\<inter> {x. Xh x = h}) = Ch h A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h (A \\<inter> {x. Xh x = h}) = Ch h A", "using %invisible irc_on_discard[OF spec[OF Ch_irc, of h], where B=\"A \\<inter> {x. Xh x = h}\" and C=\"A - {x. Xh x = h}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (A - {x. Xh x = h});\n   A \\<inter> {x. Xh x = h} \\<union> (A - {x. Xh x = h}) \\<subseteq> UNIV;\n   Ch h (A \\<inter> {x. Xh x = h} \\<union> (A - {x. Xh x = h})) \\<inter>\n   (A - {x. Xh x = h}) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> Ch h\n                     (A \\<inter> {x. Xh x = h} \\<union>\n                      (A - {x. Xh x = h})) =\n                    Ch h (A \\<inter> {x. Xh x = h})\n\ngoal (1 subgoal):\n 1. Ch h (A \\<inter> {x. Xh x = h}) = Ch h A", "by (fastforce simp: Un_Diff_Int ac_simps dest: Ch_range')"], ["", "lemma %invisible CH_domain:\n  shows \"CH A \\<inter> {x. Xh x = h} = Ch h (A \\<inter> {x. Xh x = h})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH A \\<inter> {x. Xh x = h} = Ch h (A \\<inter> {x. Xh x = h})", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) \\<inter> {x. Xh x = h} =\n    Ch h (A \\<inter> {x. Xh x = h})", "using Ch_range"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) \\<inter> {x. Xh x = h} =\n    Ch h (A \\<inter> {x. Xh x = h})", "by (auto simp: Ch_domain)"], ["", "lemma %invisible stable_pair_on_Ch:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"Ch h (snd XD_XH) = match XD_XH \\<inter> {x. Xh x = h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h (snd XD_XH) = match XD_XH \\<inter> {x. Xh x = h}", "using stable_pair_on_CH[OF assms] CH_domain Ch_domain"], ["proof (prove)\nusing this:\n  match XD_XH = CH (snd XD_XH)\n  CH ?A \\<inter> {x. Xh x = ?h} = Ch ?h (?A \\<inter> {x. Xh x = ?h})\n  Ch ?h (?A \\<inter> {x. Xh x = ?h}) = Ch ?h ?A\n\ngoal (1 subgoal):\n 1. Ch h (snd XD_XH) = match XD_XH \\<inter> {x. Xh x = h}", "by simp"], ["", "lemmas %invisible Ch_consistency = irc_on_consistency_on[OF spec[OF Ch_irc], simplified, of h] for h"], ["", "lemmas Ch_irc_idem = consistency_on_f_idem[OF Ch_f_range Ch_consistency, simplified]"], ["", "lemma CH_irc_idem:\n  shows \"CH (CH A) = CH A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH (CH A) = CH A", "unfolding %invisible CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h (\\<Union>h. Ch h A)) = (\\<Union>h. Ch h A)", "by (metis CH_def CH_domain Ch_domain Ch_irc_idem)"], ["", "lemma Ch_CH_irc_idem:\n  shows \"Ch h (CH A) = Ch h A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h (CH A) = Ch h A", "using %invisible CH_domain CH_irc_idem Ch_domain"], ["proof (prove)\nusing this:\n  CH ?A \\<inter> {x. Xh x = ?h} = Ch ?h (?A \\<inter> {x. Xh x = ?h})\n  CH (CH ?A) = CH ?A\n  Ch ?h (?A \\<inter> {x. Xh x = ?h}) = Ch ?h ?A\n\ngoal (1 subgoal):\n 1. Ch h (CH A) = Ch h A", "by blast"], ["", "text\\<open>\n\nThis suffices to show the left-to-right direction of Theorem~1.\n\n\\<close>"], ["", "lemma stable_pair_on_individually_rational:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"individually_rational_on ds (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds (match XD_XH)", "by %invisible (metis CD_on_idem CH_irc_idem stable_pair_on_CD_on stable_pair_on_CD_on_CH assms individually_rational_onI)"], ["", "lemma stable_pair_on_stable_no_blocking_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_no_blocking_on ds (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds (match XD_XH)", "proof(rule stable_no_blocking_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "fix h X''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume C: \"X'' = Ch h (match XD_XH \\<union> X'')\""], ["proof (state)\nthis:\n  X'' = Ch h (match XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume NE: \"X'' \\<noteq> Ch h (match XD_XH)\""], ["proof (state)\nthis:\n  X'' \\<noteq> Ch h (match XD_XH)\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume CD: \"X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\""], ["proof (state)\nthis:\n  X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "have \"X'' \\<subseteq> snd XD_XH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "from CD"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')", "have \"X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')\""], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')", "by (simp only: stable_pair_on_CD_on[OF assms])"], ["proof (state)\nthis:\n  X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "then"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')", "have \"X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\""], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')", "using CD_on_path_independent"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')\n  path_independent (CD_on ?ds)\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')", "unfolding path_independent_def"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (CD_on ds (fst XD_XH) \\<union> X'')\n  \\<forall>B C.\n     CD_on ?ds (B \\<union> C) = CD_on ?ds (B \\<union> CD_on ?ds C)\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')", "by (simp add: Un_commute)"], ["proof (state)\nthis:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "moreover"], ["proof (state)\nthis:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "have \"fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'') \\<subseteq> CD_on ds (fst XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n    \\<subseteq> CD_on ds (fst XD_XH)", "using CD_on_Chernoff"], ["proof (prove)\nusing this:\n  Chernoff (CD_on ?ds)\n\ngoal (1 subgoal):\n 1. fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n    \\<subseteq> CD_on ds (fst XD_XH)", "unfolding Chernoff_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>UNIV.\n     \\<forall>C\\<subseteq>B. CD_on ?ds B \\<inter> C \\<subseteq> CD_on ?ds C\n\ngoal (1 subgoal):\n 1. fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n    \\<subseteq> CD_on ds (fst XD_XH)", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n  \\<subseteq> CD_on ds (fst XD_XH)\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "ultimately"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n  fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n  \\<subseteq> CD_on ds (fst XD_XH)", "show ?thesis"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n  fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n  \\<subseteq> CD_on ds (fst XD_XH)\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "using assms"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n  fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n  \\<subseteq> CD_on ds (fst XD_XH)\n  stable_pair_on ds XD_XH\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "unfolding stable_pair_on_def split_def"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (fst XD_XH \\<union> X'')\n  fst XD_XH \\<inter> CD_on ds (fst XD_XH \\<union> X'')\n  \\<subseteq> CD_on ds (fst XD_XH)\n  fst XD_XH = - Rf CH (snd XD_XH) \\<and>\n  snd XD_XH = - Rf (CD_on ds) (fst XD_XH)\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> snd XD_XH", "by blast"], ["proof (state)\nthis:\n  X'' \\<subseteq> snd XD_XH\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X'' \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> snd XD_XH", "have \"Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\""], ["proof (prove)\nusing this:\n  X'' \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')", "by (force intro!: consistencyD[OF Ch_consistency] dest: Ch_range')"], ["proof (state)\nthis:\n  Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "from NE"], ["proof (chain)\npicking this:\n  X'' \\<noteq> Ch h (match XD_XH)", "have \"X'' \\<noteq> Ch h (snd XD_XH)\""], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h (match XD_XH)\n\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h (snd XD_XH)", "using stable_pair_on_CH[OF assms] CH_domain[of _ h] Ch_domain[of h]"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h (match XD_XH)\n  match XD_XH = CH (snd XD_XH)\n  CH ?A \\<inter> {x. Xh x = h} = Ch h (?A \\<inter> {x. Xh x = h})\n  Ch h (?A \\<inter> {x. Xh x = h}) = Ch h ?A\n\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h (snd XD_XH)", "by (metis Ch_irc_idem)"], ["proof (state)\nthis:\n  X'' \\<noteq> Ch h (snd XD_XH)\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\n  X'' \\<noteq> Ch h (snd XD_XH)", "have \"X'' \\<noteq> Ch h (match XD_XH \\<union> X'')\""], ["proof (prove)\nusing this:\n  Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\n  X'' \\<noteq> Ch h (snd XD_XH)\n\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h (match XD_XH \\<union> X'')", "using stable_pair_on_CH[OF assms] CH_domain[of _ h] Ch_domain[of h]"], ["proof (prove)\nusing this:\n  Ch h (snd XD_XH) = Ch h (Ch h (snd XD_XH) \\<union> X'')\n  X'' \\<noteq> Ch h (snd XD_XH)\n  match XD_XH = CH (snd XD_XH)\n  CH ?A \\<inter> {x. Xh x = h} = Ch h (?A \\<inter> {x. Xh x = h})\n  Ch h (?A \\<inter> {x. Xh x = h}) = Ch h ?A\n\ngoal (1 subgoal):\n 1. X'' \\<noteq> Ch h (match XD_XH \\<union> X'')", "by (metis (no_types, lifting) inf.right_idem inf_sup_distrib2)"], ["proof (state)\nthis:\n  X'' \\<noteq> Ch h (match XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (match XD_XH \\<union> X'');\n        X'' \\<noteq> Ch h (match XD_XH);\n        X'' \\<subseteq> CD_on ds (match XD_XH \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "with C"], ["proof (chain)\npicking this:\n  X'' = Ch h (match XD_XH \\<union> X'')\n  X'' \\<noteq> Ch h (match XD_XH \\<union> X'')", "show False"], ["proof (prove)\nusing this:\n  X'' = Ch h (match XD_XH \\<union> X'')\n  X'' \\<noteq> Ch h (match XD_XH \\<union> X'')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem stable_pair_on_stable_on:\n  assumes \"stable_pair_on ds XD_XH\"\n  shows \"stable_on ds (match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_on ds (match XD_XH)", "using %invisible assms stable_pair_on_allocation stable_pair_on_individually_rational stable_pair_on_stable_no_blocking_on"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow> inj_on Xd (match ?XD_XH)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  individually_rational_on ?ds (match ?XD_XH)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  stable_no_blocking_on ?ds (match ?XD_XH)\n\ngoal (1 subgoal):\n 1. stable_on ds (match XD_XH)", "by (blast intro: stable_onI)"], ["", "end"], ["", "subsubsection\\<open> The converse of Theorem~1 \\label{sec:contracts-t1-converse} \\<close>"], ["", "text (in Contracts) \\<open>\n\nThe forward direction of Theorem~1 gives us a way of finding stable\nmatches by computing fixed points of a function closely related to\n@{const \"stable_pair\"} (see \\S\\ref{sec:contracts-algorithmics}). The\nconverse says that every stable match can be decomposed in this way,\nwhich implies that the stable matches form a lattice (see also\n\\S\\ref{sec:contracts-algorithmics}).\n\nThe following proofs assume that the hospitals' choice functions\nsatisfy @{const \"substitutes\"} and @{const \"irc\"}.\n\n\\<close>"], ["", "context ContractsWithIRC\nbegin"], ["", "context\n  fixes ds :: \"'b set\"\n  fixes X :: \"'a set\"\nbegin"], ["", "text\\<open>\n\nFollowing \\citet[Proof of Theorem~1]{HatfieldMilgrom:2005}, we\npartition the set of all contracts into @{term \"[X, XD_smallest - X,\nXH_largest - X]\"} with careful definitions of the two sets @{term\n\"XD_smallest\"} and @{term \"XH_largest\"}. Specifically @{term\n\"XH_largest\"} contains all contracts ranked at least as good as those\nin @{term \"X\"} by the doctors, considering unemployment and\nunacceptable contracts. Similarly @{term \"XD_smallest\"} contains those\nranked at least as poorly.\n\n\\<close>"], ["", "definition XH_largest :: \"'a set\" where\n  \"XH_largest =\n     {y. Xd y \\<in> ds\n       \\<and> y \\<in> Field (Pd (Xd y))\n       \\<and> (\\<forall>x \\<in> dX X (Xd y). (x, y) \\<in> Pd (Xd y))}\""], ["", "definition XD_smallest :: \"'a set\" where\n  \"XD_smallest = - (XH_largest - X)\""], ["", "context\n  assumes \"stable_on ds X\"\nbegin"], ["", "lemma Ch_XH_largest_Field:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"x \\<in> Field (Pd (Xd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd (Xd x))", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Ch h XH_largest\n\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd (Xd x))", "unfolding XH_largest_def"], ["proof (prove)\nusing this:\n  x \\<in> Ch h\n           {y. Xd y \\<in> ds \\<and>\n               y \\<in> Field (Pd (Xd y)) \\<and>\n               (\\<forall>x\\<in>dX X (Xd y). (x, y) \\<in> Pd (Xd y))}\n\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd (Xd x))", "by (blast dest: Ch_range')"], ["", "lemma Ch_XH_largest_Xd:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"Xd x \\<in> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Ch h XH_largest\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "unfolding XH_largest_def"], ["proof (prove)\nusing this:\n  x \\<in> Ch h\n           {y. Xd y \\<in> ds \\<and>\n               y \\<in> Field (Pd (Xd y)) \\<and>\n               (\\<forall>x\\<in>dX X (Xd y). (x, y) \\<in> Pd (Xd y))}\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "by (blast dest: Ch_range')"], ["", "lemma X_subseteq_XH_largest:\n  shows \"X \\<subseteq> XH_largest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> XH_largest", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> XH_largest", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> XH_largest", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> XH_largest", "then"], ["proof (chain)\npicking this:\n  x \\<in> X", "obtain d where \"d \\<in> ds\" \"x \\<in> Cd d X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ds; x \\<in> Cd d X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using stable_on_CD_on[OF \\<open>stable_on ds X\\<close>]"], ["proof (prove)\nusing this:\n  x \\<in> X\n  CD_on ds X = X\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ds; x \\<in> Cd d X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding CD_on_def"], ["proof (prove)\nusing this:\n  x \\<in> X\n  (\\<Union>d\\<in>ds. Cd d X) = X\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<in> ds; x \\<in> Cd d X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  d \\<in> ds\n  x \\<in> Cd d X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> XH_largest", "with \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  stable_on ds X\n  d \\<in> ds\n  x \\<in> Cd d X", "show \"x \\<in> XH_largest\""], ["proof (prove)\nusing this:\n  stable_on ds X\n  d \\<in> ds\n  x \\<in> Cd d X\n\ngoal (1 subgoal):\n 1. x \\<in> XH_largest", "using Pd_linear' Pd_range' Cd_range subset_Image1_Image1_iff[of \"Pd d\"] stable_on_allocation[of ds X]"], ["proof (prove)\nusing this:\n  stable_on ds X\n  d \\<in> ds\n  x \\<in> Cd d X\n  Linear_order (Pd ?d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n  \\<lbrakk>Preorder (Pd d); ?a \\<in> Field (Pd d);\n   ?b \\<in> Field (Pd d)\\<rbrakk>\n  \\<Longrightarrow> (Pd d `` {?a} \\<subseteq> Pd d `` {?b}) =\n                    ((?b, ?a) \\<in> Pd d)\n  stable_on ds X \\<Longrightarrow> inj_on Xd X\n\ngoal (1 subgoal):\n 1. x \\<in> XH_largest", "unfolding XH_largest_def linear_order_on_def partial_order_on_def stable_on_def inj_on_def dX_def"], ["proof (prove)\nusing this:\n  individually_rational_on ds X \\<and> stable_no_blocking_on ds X\n  d \\<in> ds\n  x \\<in> Cd d X\n  (Preorder (Pd ?d) \\<and> antisym (Pd ?d)) \\<and> Total (Pd ?d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  Cd ?d ?X \\<subseteq> ?X \\<inter> Field (Pd ?d)\n  \\<lbrakk>Preorder (Pd d); ?a \\<in> Field (Pd d);\n   ?b \\<in> Field (Pd d)\\<rbrakk>\n  \\<Longrightarrow> (Pd d `` {?a} \\<subseteq> Pd d `` {?b}) =\n                    ((?b, ?a) \\<in> Pd d)\n  individually_rational_on ds X \\<and>\n  stable_no_blocking_on ds X \\<Longrightarrow>\n  \\<forall>x\\<in>X. \\<forall>y\\<in>X. Xd x = Xd y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. x \\<in> {y. Xd y \\<in> ds \\<and>\n                y \\<in> Field (Pd (Xd y)) \\<and>\n                (\\<forall>x\\<in>{x \\<in> X. Xd x = Xd y}.\n                    (x, y) \\<in> Pd (Xd y))}", "by simp blast"], ["proof (state)\nthis:\n  x \\<in> XH_largest\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma X_subseteq_XD_smallest:\n  shows \"X \\<subseteq> XD_smallest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> XD_smallest", "unfolding XD_smallest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> - (XH_largest - X)", "by blast"], ["", "lemma X_XD_smallest_XH_largest:\n  shows \"X = XD_smallest \\<inter> XH_largest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = XD_smallest \\<inter> XH_largest", "using X_subseteq_XH_largest"], ["proof (prove)\nusing this:\n  X \\<subseteq> XH_largest\n\ngoal (1 subgoal):\n 1. X = XD_smallest \\<inter> XH_largest", "unfolding XD_smallest_def"], ["proof (prove)\nusing this:\n  X \\<subseteq> XH_largest\n\ngoal (1 subgoal):\n 1. X = - (XH_largest - X) \\<inter> XH_largest", "by blast"], ["", "text\\<open>\n\nThe goal of the next few lemmas is to show the constituents of @{term\n\"stable_pair_on ds (XD_smallest, XH_largest)\"}.\n\nIntuitively, if a doctor has a contract @{term \"x\"} in @{term \"X\"},\nthen all of their contracts in @{const \"XH_largest\"} are at least as\ndesirable as @{term \"x\"}, and so the @{const\n\"stable_no_blocking\"} hypothesis guarantees the hospitals choose\n@{term \"x\"} from @{const \"XH_largest\"}, and similarly the doctors\n@{term \"x\"} from @{const \"XD_smallest\"}.\n\n\\<close>"], ["", "lemma XH_largestCdXXH_largest:\n  assumes \"x \\<in> Ch h XH_largest\"\n  shows \"x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> Ch h XH_largest", "have \"(y, x) \\<in> Pd (Xd x)\" if \"Xd y = Xd x\" and \"y \\<in> X\" for y"], ["proof (prove)\nusing this:\n  x \\<in> Ch h XH_largest\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> Pd (Xd x)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> Ch h XH_largest\n  Xd y = Xd x\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> Pd (Xd x)", "by (fastforce simp: XH_largest_def dX_def dest: Ch_range')"], ["proof (state)\nthis:\n  \\<lbrakk>Xd ?y = Xd x; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (?y, x) \\<in> Pd (Xd x)\n\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)", "with Ch_XH_largest_Field[OF assms] Pd_linear Pd_range"], ["proof (chain)\npicking this:\n  x \\<in> Field (Pd (Xd x))\n  \\<forall>d. Linear_order (Pd d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<lbrakk>Xd ?y = Xd x; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (?y, x) \\<in> Pd (Xd x)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Field (Pd (Xd x))\n  \\<forall>d. Linear_order (Pd d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<lbrakk>Xd ?y = Xd x; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (?y, x) \\<in> Pd (Xd x)\n\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)", "using assms Ch_XH_largest_Field[OF assms]"], ["proof (prove)\nusing this:\n  x \\<in> Field (Pd (Xd x))\n  \\<forall>d. Linear_order (Pd d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<lbrakk>Xd ?y = Xd x; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (?y, x) \\<in> Pd (Xd x)\n  x \\<in> Ch h XH_largest\n  x \\<in> Field (Pd (Xd x))\n\ngoal (1 subgoal):\n 1. x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)", "by (clarsimp simp: Cd_greatest greatest_def)\n       (metis Ch_singular Pd_range' inj_onD subset_refl underS_incl_iff)"], ["proof (state)\nthis:\n  x \\<in> Cd (Xd x) (X \\<union> Ch h XH_largest)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CH_XH_largest:\n  shows \"CH XH_largest = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH XH_largest = X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CH XH_largest = X", "have \"Ch h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch h XH_largest)\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ch h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch h XH_largest)", "using XH_largestCdXXH_largest Ch_XH_largest_Xd Ch_XH_largest_Field"], ["proof (prove)\nusing this:\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow>\n  ?x \\<in> Cd (Xd ?x) (X \\<union> Ch ?h XH_largest)\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow> Xd ?x \\<in> ds\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow> ?x \\<in> Field (Pd (Xd ?x))\n\ngoal (1 subgoal):\n 1. Ch h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch h XH_largest)", "unfolding CD_on_def"], ["proof (prove)\nusing this:\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow>\n  ?x \\<in> Cd (Xd ?x) (X \\<union> Ch ?h XH_largest)\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow> Xd ?x \\<in> ds\n  ?x \\<in> Ch ?h XH_largest \\<Longrightarrow> ?x \\<in> Field (Pd (Xd ?x))\n\ngoal (1 subgoal):\n 1. Ch h XH_largest\n    \\<subseteq> (\\<Union>d\\<in>ds. Cd d (X \\<union> Ch h XH_largest))", "by blast"], ["proof (state)\nthis:\n  Ch ?h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch ?h XH_largest)\n\ngoal (1 subgoal):\n 1. CH XH_largest = X", "from \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  stable_on ds X", "have \"Ch h XH_largest = Ch h X\" for h"], ["proof (prove)\nusing this:\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. Ch h XH_largest = Ch h X", "using \\<open>Ch h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch h XH_largest)\\<close> X_subseteq_XH_largest"], ["proof (prove)\nusing this:\n  stable_on ds X\n  Ch h XH_largest \\<subseteq> CD_on ds (X \\<union> Ch h XH_largest)\n  X \\<subseteq> XH_largest\n\ngoal (1 subgoal):\n 1. Ch h XH_largest = Ch h X", "by - (erule stable_on_blocking_onD[where h=h and X''=\"Ch h XH_largest\"];\n          force intro!: consistencyD[OF Ch_consistency] dest: Ch_range')"], ["proof (state)\nthis:\n  Ch ?h XH_largest = Ch ?h X\n\ngoal (1 subgoal):\n 1. CH XH_largest = X", "with stable_on_CH[OF \\<open>stable_on ds X\\<close>]"], ["proof (chain)\npicking this:\n  CH X = X\n  Ch ?h XH_largest = Ch ?h X", "show ?thesis"], ["proof (prove)\nusing this:\n  CH X = X\n  Ch ?h XH_largest = Ch ?h X\n\ngoal (1 subgoal):\n 1. CH XH_largest = X", "unfolding CH_def"], ["proof (prove)\nusing this:\n  (\\<Union>h. Ch h X) = X\n  Ch ?h XH_largest = Ch ?h X\n\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h XH_largest) = X", "by simp"], ["proof (state)\nthis:\n  CH XH_largest = X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cd_XD_smallest:\n  assumes \"d \\<in> ds\"\n  shows \"Cd d (XD_smallest \\<inter> Field (Pd d)) = Cd d (X \\<inter> Field (Pd d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "proof(cases \"X \\<inter> Field (Pd d) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<inter> Field (Pd d) = {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))\n 2. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "case True"], ["proof (state)\nthis:\n  X \\<inter> Field (Pd d) = {}\n\ngoal (2 subgoals):\n 1. X \\<inter> Field (Pd d) = {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))\n 2. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "with Pd_range' Cd_range'[where X=X] stable_on_CD_on[OF \\<open>stable_on ds X\\<close>] mem_CD_on_Cd assms"], ["proof (chain)\npicking this:\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  ?x \\<in> Cd ?d X \\<Longrightarrow> ?x \\<in> X \\<inter> Field (Pd ?d)\n  CD_on ds X = X\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  d \\<in> ds\n  X \\<inter> Field (Pd d) = {}", "have \"- XH_largest \\<inter> Field (Pd d) = {}\""], ["proof (prove)\nusing this:\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  ?x \\<in> Cd ?d X \\<Longrightarrow> ?x \\<in> X \\<inter> Field (Pd ?d)\n  CD_on ds X = X\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  d \\<in> ds\n  X \\<inter> Field (Pd d) = {}\n\ngoal (1 subgoal):\n 1. - XH_largest \\<inter> Field (Pd d) = {}", "unfolding XH_largest_def dX_def"], ["proof (prove)\nusing this:\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  ?x \\<in> Cd ?d X \\<Longrightarrow> ?x \\<in> X \\<inter> Field (Pd ?d)\n  CD_on ds X = X\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  d \\<in> ds\n  X \\<inter> Field (Pd d) = {}\n\ngoal (1 subgoal):\n 1. - {y. Xd y \\<in> ds \\<and>\n          y \\<in> Field (Pd (Xd y)) \\<and>\n          (\\<forall>x\\<in>{x \\<in> X. Xd x = Xd y}.\n              (x, y) \\<in> Pd (Xd y))} \\<inter>\n    Field (Pd d) =\n    {}", "by auto blast"], ["proof (state)\nthis:\n  - XH_largest \\<inter> Field (Pd d) = {}\n\ngoal (2 subgoals):\n 1. X \\<inter> Field (Pd d) = {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))\n 2. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "then"], ["proof (chain)\npicking this:\n  - XH_largest \\<inter> Field (Pd d) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  - XH_largest \\<inter> Field (Pd d) = {}\n\ngoal (1 subgoal):\n 1. Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "unfolding XD_smallest_def"], ["proof (prove)\nusing this:\n  - XH_largest \\<inter> Field (Pd d) = {}\n\ngoal (1 subgoal):\n 1. Cd d (- (XH_largest - X) \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "by (simp add: Int_Un_distrib2)"], ["proof (state)\nthis:\n  Cd d (XD_smallest \\<inter> Field (Pd d)) = Cd d (X \\<inter> Field (Pd d))\n\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "case False"], ["proof (state)\nthis:\n  X \\<inter> Field (Pd d) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<inter> Field (Pd d) \\<noteq> {} \\<Longrightarrow>\n    Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "with Pd_linear'[of d] \\<open>stable_on ds X\\<close> stable_on_CD_on stable_on_allocation assms"], ["proof (chain)\npicking this:\n  Linear_order (Pd d)\n  stable_on ds X\n  stable_on ?ds ?X \\<Longrightarrow> CD_on ?ds ?X = ?X\n  stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  d \\<in> ds\n  X \\<inter> Field (Pd d) \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Linear_order (Pd d)\n  stable_on ds X\n  stable_on ?ds ?X \\<Longrightarrow> CD_on ?ds ?X = ?X\n  stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  d \\<in> ds\n  X \\<inter> Field (Pd d) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Cd d (XD_smallest \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "unfolding XD_smallest_def order_on_defs total_on_def"], ["proof (prove)\nusing this:\n  ((Refl (Pd d) \\<and> trans (Pd d)) \\<and> antisym (Pd d)) \\<and>\n  (\\<forall>x\\<in>Field (Pd d).\n      \\<forall>y\\<in>Field (Pd d).\n         x \\<noteq> y \\<longrightarrow>\n         (x, y) \\<in> Pd d \\<or> (y, x) \\<in> Pd d)\n  stable_on ds X\n  stable_on ?ds ?X \\<Longrightarrow> CD_on ?ds ?X = ?X\n  stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  d \\<in> ds\n  X \\<inter> Field (Pd d) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Cd d (- (XH_largest - X) \\<inter> Field (Pd d)) =\n    Cd d (X \\<inter> Field (Pd d))", "by (auto 0 0 simp: Int_Un_distrib2 Cd_greatest greatest_def XH_largest_def dX_def)\n       (metis (mono_tags, lifting) IntI Pd_range' UnCI inj_onD)+"], ["proof (state)\nthis:\n  Cd d (XD_smallest \\<inter> Field (Pd d)) = Cd d (X \\<inter> Field (Pd d))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CD_on_XD_smallest:\n  shows \"CD_on ds XD_smallest = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CD_on ds XD_smallest = X", "using stable_on_CD_on[OF \\<open>stable_on ds X\\<close>]"], ["proof (prove)\nusing this:\n  CD_on ds X = X\n\ngoal (1 subgoal):\n 1. CD_on ds XD_smallest = X", "unfolding CD_on_def2"], ["proof (prove)\nusing this:\n  (\\<Union>d\\<in>ds. Cd d (X \\<inter> Field (Pd d))) = X\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Cd d (XD_smallest \\<inter> Field (Pd d))) = X", "by (simp add: Cd_XD_smallest)"], ["", "theorem stable_on_stable_pair_on:\n  shows \"stable_pair_on ds (XD_smallest, XH_largest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_pair_on ds (XD_smallest, XH_largest)", "proof(rule stable_pair_onI, simp_all only: prod.sel)"], ["proof (state)\ngoal (2 subgoals):\n 1. XD_smallest = - Rf CH XH_largest\n 2. XH_largest = - Rf (CD_on ds) XD_smallest", "from CH_XH_largest"], ["proof (chain)\npicking this:\n  CH XH_largest = X", "have \"- RH XH_largest = - (XH_largest - X)\""], ["proof (prove)\nusing this:\n  CH XH_largest = X\n\ngoal (1 subgoal):\n 1. - Rf CH XH_largest = - (XH_largest - X)", "by blast"], ["proof (state)\nthis:\n  - Rf CH XH_largest = - (XH_largest - X)\n\ngoal (2 subgoals):\n 1. XD_smallest = - Rf CH XH_largest\n 2. XH_largest = - Rf (CD_on ds) XD_smallest", "also"], ["proof (state)\nthis:\n  - Rf CH XH_largest = - (XH_largest - X)\n\ngoal (2 subgoals):\n 1. XD_smallest = - Rf CH XH_largest\n 2. XH_largest = - Rf (CD_on ds) XD_smallest", "from X_XD_smallest_XH_largest"], ["proof (chain)\npicking this:\n  X = XD_smallest \\<inter> XH_largest", "have \"\\<dots> = XD_smallest\""], ["proof (prove)\nusing this:\n  X = XD_smallest \\<inter> XH_largest\n\ngoal (1 subgoal):\n 1. - (XH_largest - X) = XD_smallest", "unfolding XD_smallest_def"], ["proof (prove)\nusing this:\n  X = - (XH_largest - X) \\<inter> XH_largest\n\ngoal (1 subgoal):\n 1. - (XH_largest - X) = - (XH_largest - X)", "by blast"], ["proof (state)\nthis:\n  - (XH_largest - X) = XD_smallest\n\ngoal (2 subgoals):\n 1. XD_smallest = - Rf CH XH_largest\n 2. XH_largest = - Rf (CD_on ds) XD_smallest", "finally"], ["proof (chain)\npicking this:\n  - Rf CH XH_largest = XD_smallest", "show \"XD_smallest = -RH XH_largest\""], ["proof (prove)\nusing this:\n  - Rf CH XH_largest = XD_smallest\n\ngoal (1 subgoal):\n 1. XD_smallest = - Rf CH XH_largest", "by blast"], ["proof (state)\nthis:\n  XD_smallest = - Rf CH XH_largest\n\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "from CD_on_XD_smallest"], ["proof (chain)\npicking this:\n  CD_on ds XD_smallest = X", "have \"-RD_on ds XD_smallest = -(XD_smallest - X)\""], ["proof (prove)\nusing this:\n  CD_on ds XD_smallest = X\n\ngoal (1 subgoal):\n 1. - Rf (CD_on ds) XD_smallest = - (XD_smallest - X)", "by simp"], ["proof (state)\nthis:\n  - Rf (CD_on ds) XD_smallest = - (XD_smallest - X)\n\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "also"], ["proof (state)\nthis:\n  - Rf (CD_on ds) XD_smallest = - (XD_smallest - X)\n\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "have \"\\<dots> = XH_largest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (XD_smallest - X) = XH_largest", "unfolding XD_smallest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- (XH_largest - X) - X) = XH_largest", "using X_subseteq_XH_largest"], ["proof (prove)\nusing this:\n  X \\<subseteq> XH_largest\n\ngoal (1 subgoal):\n 1. - (- (XH_largest - X) - X) = XH_largest", "by blast"], ["proof (state)\nthis:\n  - (XD_smallest - X) = XH_largest\n\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "finally"], ["proof (chain)\npicking this:\n  - Rf (CD_on ds) XD_smallest = XH_largest", "show \"XH_largest = -RD_on ds XD_smallest\""], ["proof (prove)\nusing this:\n  - Rf (CD_on ds) XD_smallest = XH_largest\n\ngoal (1 subgoal):\n 1. XH_largest = - Rf (CD_on ds) XD_smallest", "by blast"], ["proof (state)\nthis:\n  XH_largest = - Rf (CD_on ds) XD_smallest\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "text\\<open>\n\nOur ultimate statement of Theorem~1 of \\cite{HatfieldMilgrom:2005} ala\n\\citet{AygunSonmez:2012-WP2} goes as follows, bearing in mind that we\nare working in the @{const \"ContractsWithIRC\"} locale:\n\n\\<close>"], ["", "theorem T1:\n  shows \"stable_on ds X \\<longleftrightarrow> (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> X = match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_on ds X =\n    (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> X = match XD_XH)", "using stable_pair_on_stable_on stable_on_stable_pair_on X_XD_smallest_XH_largest"], ["proof (prove)\nusing this:\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow> stable_on ?ds (match ?XD_XH)\n  stable_on ?ds ?X \\<Longrightarrow>\n  stable_pair_on ?ds (XD_smallest ?ds ?X, XH_largest ?ds ?X)\n  stable_on ?ds ?X \\<Longrightarrow>\n  ?X = XD_smallest ?ds ?X \\<inter> XH_largest ?ds ?X\n\ngoal (1 subgoal):\n 1. stable_on ds X =\n    (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> X = match XD_XH)", "by fastforce"], ["", "end"], ["", "subsection\\<open> Theorem~3: Algorithmics \\label{sec:contracts-algorithmics} \\<close>"], ["", "text (in Contracts) \\<open>\n\nHaving revived Theorem~1, we reformulate @{const \"stable_pair\"} as a\nmonotone (aka @{emph \\<open>isotone\\<close>}) function and exploit the lattice\nstructure of its fixed points, following \\citet[{\\S}II,\nTheorem~3]{HatfieldMilgrom:2005}. This underpins all of their results\nthat we formulate here. \\citet[\\S2]{Fleiner:2002} provides an\nintuitive gloss of these definitions.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition F1 :: \"'x cfun\" where\n  \"F1 X' = - RH X'\""], ["", "definition F2 :: \"'d set \\<Rightarrow> 'x cfun\" where\n  \"F2 ds X' = - RD_on ds X'\""], ["", "definition F :: \"'d set \\<Rightarrow> 'x set \\<times> 'x set dual \\<Rightarrow> 'x set \\<times> 'x set dual\" where\n  \"F ds = (\\<lambda>(XD, XH). (F1 (undual XH), dual (F2 ds (F1 (undual XH)))))\""], ["", "text\\<open>\n\nWe exploit Isabelle/HOL's ordering type classes (over the type\nconstructors @{typ \"'a set\"} and @{typ \"'a \\<times> 'b\"}) to define\n@{const \"F\"}. As @{const \"F\"} is @{const \"antimono\"} (where @{thm\n\"antimono_def\"} for a lattice order \\<open>\\<le>\\<close>) on its\nsecond argument \\<open>XH\\<close>, we adopt the dual lattice order\nusing the type constructor @{typ \"'a dual\"}, where @{const \"dual\"} and\n@{const \"undual\"} mediate the isomorphism on values, to satisfy\nIsabelle/HOL's @{const \"mono\"} predicate. Note we work under the\n@{const \"substitutes\"} hypothesis here.\n\nRelating this function to @{const \"stable_pair\"} is syntactically\nawkward but straightforward:\n\n\\<close>"], ["", "lemma fix_F_stable_pair_on:\n  assumes \"X = F ds X\"\n  shows \"stable_pair_on ds (map_prod id undual X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_pair_on ds (map_prod id undual X)", "using %invisible assms"], ["proof (prove)\nusing this:\n  X = F ds X\n\ngoal (1 subgoal):\n 1. stable_pair_on ds (map_prod id undual X)", "by (cases X) (simp add: F_def F1_def F2_def stable_pair_on_def dual_eq_iff)"], ["", "lemma stable_pair_on_fix_F:\n  assumes \"stable_pair_on ds X\"\n  shows \"map_prod id dual X = F ds (map_prod id dual X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod id dual X = F ds (map_prod id dual X)", "using %invisible assms"], ["proof (prove)\nusing this:\n  stable_pair_on ds X\n\ngoal (1 subgoal):\n 1. map_prod id dual X = F ds (map_prod id dual X)", "unfolding F_def F1_def F2_def stable_pair_on_def split_def"], ["proof (prove)\nusing this:\n  fst X = - Rf CH (snd X) \\<and> snd X = - Rf (CD_on ds) (fst X)\n\ngoal (1 subgoal):\n 1. map_prod id dual X =\n    (- Rf CH (undual (snd (map_prod id dual X))),\n     dual (- Rf (CD_on ds) (- Rf CH (undual (snd (map_prod id dual X))))))", "by (metis fst_map_prod id_apply prod.collapse snd_map_prod undual_dual)"], ["", "end"], ["", "text (in Contracts) \\<open>\n\nThe function @{const F} is monotonic under @{const substitutes}.\n\n\\<close>"], ["", "locale ContractsWithSubstitutes = Contracts +\n  assumes Ch_substitutes: \"\\<forall>h. substitutes (Ch h)\"\nbegin"], ["", "(*<*)"], ["", "lemma Rh_mono:\n  shows \"mono (Rh h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Rf (Ch h))", "using %invisible substitutes_on_Rf_mono_on[OF spec[OF Ch_substitutes]] mono_on_mono"], ["proof (prove)\nusing this:\n  finite UNIV \\<Longrightarrow> Basis.mono_on (Pow UNIV) (Rf (Ch ?x1))\n  Basis.mono_on UNIV = mono\n\ngoal (1 subgoal):\n 1. mono (Rf (Ch h))", "by (simp add: fun_eq_iff) blast"], ["", "lemmas Ch_iia = Rh_mono[unfolded Rf_mono_iia]"], ["", "lemmas Ch_Chernoff = Ch_iia[unfolded Chernoff_on_iia_on[symmetric]]"], ["", "lemmas Ch_subsitutes_idem = iia_f_idem[OF Ch_f_range Ch_iia, simplified]"], ["", "lemma RH_mono:\n  shows \"mono RH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Rf CH)", "unfolding %invisible CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>X. X - (\\<Union>h. Ch h X))", "by (rule monoI) (auto dest: monoD[OF Rh_mono])"], ["", "lemmas CH_iia = RH_mono[unfolded Rf_mono_iia]"], ["", "lemmas CH_Chernoff = CH_iia[unfolded Chernoff_on_iia_on[symmetric]]"], ["", "lemmas CH_substitutes_idem = iia_f_idem[OF CH_f_range_on CH_iia, simplified]"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma F1_antimono:\n  shows \"antimono F1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono F1", "by %invisible (rule antimonoI) (auto simp: F1_def dest: Diff_mono[OF _ monoD[OF RH_mono]])"], ["", "lemma F2_antimono:\n  shows \"antimono (F2 ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono (F2 ds)", "by %invisible (rule antimonoI) (auto simp: F2_def dest: Diff_mono[OF _ monoD[OF RD_on_mono]])"], ["", "lemma F_mono:\n  shows \"mono (F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (F ds)", "unfolding %invisible F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(XD, XH). (F1 (undual XH), dual (F2 ds (F1 (undual XH)))))", "using antimonoD[OF F1_antimono] antimonoD[OF F2_antimono]"], ["proof (prove)\nusing this:\n  ?x \\<subseteq> ?y \\<Longrightarrow> F1 ?y \\<subseteq> F1 ?x\n  ?x \\<subseteq> ?y \\<Longrightarrow> F2 ?ds1 ?y \\<subseteq> F2 ?ds1 ?x\n\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(XD, XH). (F1 (undual XH), dual (F2 ds (F1 (undual XH)))))", "by (auto intro: monoI simp: less_eq_dual_def)"], ["", "text\\<open>\n\nWe define the extremal fixed points using Isabelle/HOL's least and\ngreatest fixed point operators:\n\n\\<close>"], ["", "definition gfp_F :: \"'b set \\<Rightarrow> 'a set \\<times> 'a set\" where\n  \"gfp_F ds = map_prod id undual (gfp (F ds))\""], ["", "definition lfp_F :: \"'b set \\<Rightarrow> 'a set \\<times> 'a set\" where\n  \"lfp_F ds = map_prod id undual (lfp (F ds))\""], ["", "lemmas gfp_F_stable_pair_on = fix_F_stable_pair_on[OF gfp_unfold[OF F_mono], folded gfp_F_def]"], ["", "lemmas lfp_F_stable_pair_on = fix_F_stable_pair_on[OF lfp_unfold[OF F_mono], folded lfp_F_def]"], ["", "text\\<open>\n\nThese last two lemmas show that the least and greatest fixed points do\nsatisfy @{const \"stable_pair\"}.\n\nUsing standard fixed-point properties, we can establish:\n\n\\<close>"], ["", "lemma F2_o_F1_mono:\n  shows \"mono (F2 ds \\<circ> F1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (F2 ds \\<circ> F1)", "by %invisible (metis F2_antimono F1_antimono antimono_def comp_apply monoI)"], ["", "lemmas F2_F1_mono = F2_o_F1_mono[unfolded o_def]"], ["", "lemma gfp_F_lfp_F:\n  shows \"gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "let ?F' = \"dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual\""], ["proof (state)\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "have \"gfp (F ds) = (F1 (undual (gfp ?F')), gfp ?F')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (F ds) =\n    (F1 (undual (gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))),\n     gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))", "by (subst gfp_prod[OF F_mono]) (simp add: F_def o_def gfp_const)"], ["proof (state)\nthis:\n  gfp (F ds) =\n  (F1 (undual (gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))),\n   gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))\n\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "also"], ["proof (state)\nthis:\n  gfp (F ds) =\n  (F1 (undual (gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))),\n   gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual))\n\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "have \"gfp ?F' = dual (lfp (F2 ds \\<circ> F1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual) =\n    dual (lfp (F2 ds \\<circ> F1))", "by (simp add: lfp_dual_gfp[OF F2_o_F1_mono, simplified o_assoc])"], ["proof (state)\nthis:\n  gfp (dual \\<circ> F2 ds \\<circ> F1 \\<circ> undual) =\n  dual (lfp (F2 ds \\<circ> F1))\n\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "finally"], ["proof (chain)\npicking this:\n  gfp (F ds) =\n  (F1 (undual (dual (lfp (F2 ds \\<circ> F1)))),\n   dual (lfp (F2 ds \\<circ> F1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  gfp (F ds) =\n  (F1 (undual (dual (lfp (F2 ds \\<circ> F1)))),\n   dual (lfp (F2 ds \\<circ> F1)))\n\ngoal (1 subgoal):\n 1. gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "unfolding gfp_F_def"], ["proof (prove)\nusing this:\n  gfp (F ds) =\n  (F1 (undual (dual (lfp (F2 ds \\<circ> F1)))),\n   dual (lfp (F2 ds \\<circ> F1)))\n\ngoal (1 subgoal):\n 1. map_prod id undual (gfp (F ds)) =\n    (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))", "by simp"], ["proof (state)\nthis:\n  gfp_F ds = (F1 (lfp (F2 ds \\<circ> F1)), lfp (F2 ds \\<circ> F1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\nWe need hospital CFs to satisfy both @{const substitutes} and @{const irc}\nto relate these fixed points to stable matches.\n\n\\<close>"], ["", "locale ContractsWithSubstitutesAndIRC =\n  ContractsWithSubstitutes + ContractsWithIRC\nbegin"], ["", "lemmas gfp_F_stable_on = stable_pair_on_stable_on[OF gfp_F_stable_pair_on]"], ["", "lemmas lfp_F_stable_on = stable_pair_on_stable_on[OF lfp_F_stable_pair_on]"], ["", "end"], ["", "text\\<open>\n\n\\label{sec:contracts-codegen-gfp_F}\n\nWe demonstrate the effectiveness of our definitions by executing an\nexample due to \\citet[p920]{HatfieldMilgrom:2005} using Isabelle/HOL's\ncode generator \\citep{Haftmann-Nipkow:2010:code}. Note that, while\nadequate for this toy instance, the representations used here are\nhopelessly n{\\\"a}ive: sets are represented by lists and operations\ntypically traverse the entire contract space. It is feasible, with\nmore effort, to derive efficient algorithms; see, for instance,\n\\citet{Bijlsma:1991,Bulwahn-et-al:2008:imp_HOL}.\n\n\\<close>"], ["", "context ContractsWithSubstitutes\nbegin"], ["", "lemma gfp_F_code[code]:\n  shows \"gfp_F ds = map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp_F ds =\n    map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) top)", "using %invisible gfp_F_def gfp_while_lattice[OF F_mono]"], ["proof (prove)\nusing this:\n  gfp_F ?ds = map_prod id undual (gfp (F ?ds))\n  finite UNIV \\<Longrightarrow>\n  gfp (F ?ds1) = while (\\<lambda>A. F ?ds1 A \\<noteq> A) (F ?ds1) top\n\ngoal (1 subgoal):\n 1. gfp_F ds =\n    map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) top)", "by simp"], ["", "lemma lfp_F_code[code]:\n  shows \"lfp_F ds = map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp_F ds =\n    map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) bot)", "using %invisible lfp_F_def lfp_while_lattice[OF F_mono]"], ["proof (prove)\nusing this:\n  lfp_F ?ds = map_prod id undual (lfp (F ?ds))\n  finite UNIV \\<Longrightarrow>\n  lfp (F ?ds1) = while (\\<lambda>A. F ?ds1 A \\<noteq> A) (F ?ds1) bot\n\ngoal (1 subgoal):\n 1. lfp_F ds =\n    map_prod id undual (while (\\<lambda>A. F ds A \\<noteq> A) (F ds) bot)", "by simp"], ["", "end"], ["", "text\\<open>\n\nThere are two hospitals and two doctors.\n\n\\<close>"], ["", "datatype H2 = H1 | H2"], ["", "text\\<open>\n\nThe contract space is simply the Cartesian product @{typ \"D2 \\<times>\nH2\"}.\n\n\\<close>"], ["", "type_synonym X_D2_H2 = \"D2 \\<times> H2\""], ["", "text\\<open>\n\nDoctor @{const \"D1\"} prefers \\<open>H1 \\<succ> H2\\<close>, doctor @{const\n\"D2\"} the same \\<open>H1 \\<succ> H2\\<close> (but over different\ncontracts).\n\n\\<close>"], ["", "primrec P_D2_H2_d :: \"D2 \\<Rightarrow> X_D2_H2 rel\" where\n  \"P_D2_H2_d D1 = linord_of_list [(D1, H1), (D1, H2)]\"\n| \"P_D2_H2_d D2 = linord_of_list [(D2, H1), (D2, H2)]\""], ["", "text\\<open>\n\nHospital @{const \"H1\"} prefers \\<open>{D1} \\<succ> {D2} \\<succ>\n\\<emptyset>\\<close>, and hospital @{const \"H2\"} \\<open>{D1, D2}\n\\<succ> {D1} \\<succ> {D2} \\<succ> \\<emptyset>\\<close>. We interpret\nthese constraints as follows:\n\n\\<close>"], ["", "definition P_D2_H2_H1 :: \"X_D2_H2 cfun\" where\n  \"P_D2_H2_H1 A = (if (D1, H1) \\<in> A then {(D1, H1)} else if (D2, H1) \\<in> A then {(D2, H1)} else {})\""], ["", "definition P_D2_H2_H2 :: \"X_D2_H2 cfun\" where\n  \"P_D2_H2_H2 A =\n     (if {(D1, H2), (D2, H2)} \\<subseteq> A then {(D1, H2), (D2, H2)} else\n      if (D1, H2) \\<in> A then {(D1, H2)} else if (D2, H2) \\<in> A then {(D2, H2)} else {})\""], ["", "primrec P_D2_H2_h :: \"H2 \\<Rightarrow> X_D2_H2 cfun\" where\n  \"P_D2_H2_h H1 = P_D2_H2_H1\"\n| \"P_D2_H2_h H2 = P_D2_H2_H2\""], ["", "(*<*)"], ["", "lemma H2_UNIV:\n  shows \"UNIV = set [H1, H2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set [H1, H2]", "using H2.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = H1 \\<Longrightarrow> ?P;\n   ?y = H2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = set [H1, H2]", "by auto"], ["", "instantiation H2 :: enum\nbegin"], ["", "definition \"enum_class.enum = [H1, H2]\""], ["", "definition \"enum_class.enum_all P = (P H1 \\<and> P H2)\""], ["", "definition \"enum_class.enum_ex P = (P H1 \\<or> P H2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(H2, enum_class)", "by standard (simp_all add: enum_H2_def enum_all_H2_def enum_ex_H2_def H2_UNIV)"], ["", "end"], ["", "lemma H2_ALL [simp]:\n  shows \"(\\<forall>h. P h) = (\\<forall>h\\<in>{H1, H2}. P h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h. P h) = (\\<forall>h\\<in>{H1, H2}. P h)", "using H2_UNIV"], ["proof (prove)\nusing this:\n  UNIV = set [H1, H2]\n\ngoal (1 subgoal):\n 1. (\\<forall>h. P h) = (\\<forall>h\\<in>{H1, H2}. P h)", "by auto"], ["", "lemma H2_UNION:\n  shows \"(\\<Union>h. P h) = (\\<Union>h\\<in>{H1, H2}. P h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range P) = \\<Union> (P ` {H1, H2})", "using H2_UNIV"], ["proof (prove)\nusing this:\n  UNIV = set [H1, H2]\n\ngoal (1 subgoal):\n 1. \\<Union> (range P) = \\<Union> (P ` {H1, H2})", "by auto"], ["", "lemma P_D2_H2_d_linear:\n  shows \"Linear_order (P_D2_H2_d d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (P_D2_H2_d d)", "by (cases d) (simp_all add: linord_of_list_Linear_order)"], ["", "lemma P_D2_H2_d_range:\n  shows \"Field (P_D2_H2_d d) \\<subseteq> {x. fst x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (P_D2_H2_d d) \\<subseteq> {x. fst x = d}", "by (cases d) simp_all"], ["", "lemma P_D2_H2_h_substitutes:\n  shows \"substitutes (P_D2_H2_h h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes (P_D2_H2_h h)", "by %invisible (cases h) (auto intro!: substitutes_onI simp: P_D2_H2_H1_def P_D2_H2_H2_def split: if_splits)"], ["", "(*>*)"], ["", "text\\<open>\n\nIsabelle's code generator requires us to hoist the relevant\ndefinitions from the locale to the top-level (see the \\verb!codegen!\ndocumentation, \\S7.3).\n\n\\<close>"], ["", "global_interpretation P920_example:\n  ContractsWithSubstitutes fst snd P_D2_H2_d P_D2_H2_h\ndefines P920_example_gfp_F = P920_example.gfp_F\n    and P920_example_lfp_F = P920_example.lfp_F\n    and P920_example_F = P920_example.F\n    and P920_example_F1 = P920_example.F1\n    and P920_example_F2 = P920_example.F2\n    and P920_example_maxR = P920_example.maxR\n    and P920_example_MaxR_f = P920_example.MaxR_f\n    and P920_example_Cd = P920_example.Cd\n    and P920_example_CD_on = P920_example.CD_on\n    and P920_example_CH = P920_example.CH"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithSubstitutes fst snd P_D2_H2_d P_D2_H2_h", "using %invisible P_D2_H2_d_linear P_D2_H2_h_substitutes"], ["proof (prove)\nusing this:\n  Linear_order (P_D2_H2_d ?d)\n  substitutes (P_D2_H2_h ?h)\n\ngoal (1 subgoal):\n 1. ContractsWithSubstitutes fst snd P_D2_H2_d P_D2_H2_h", "by %invisible unfold_locales (simp_all, simp_all add: D2_ALL P_D2_H2_H1_def P_D2_H2_H2_def)"], ["", "(*<*)\n\n(*\n\nCodegen hackery: avoid the CoSet constructor as some operations do not\nhandle it.\n\n*)"], ["", "declare UNIV_coset[code del]"], ["", "declare UNIV_enum[code]"], ["", "declare compl_set[code del] compl_coset[code del]"], ["", "declare Compl_eq_Diff_UNIV[code]"], ["", "(*\ncode_thms P920_example_gfp_F\nexport_code P920_example_gfp_F in SML module_name F file \"F.sml\"\nvalue \"P920_example_gfp_F UNIV\"\n*)"], ["", "lemma P920_example_gfp_F_value:\n  shows \"P920_example_gfp_F UNIV = ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P920_example_gfp_F UNIV =\n    ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})", "by eval"], ["", "lemma P920_example_gfp_F_match_value:\n  shows \"P920_example.match (P920_example_gfp_F UNIV) = {(D1, H1), (D2, H2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P920_example.match (P920_example_gfp_F UNIV) = {(D1, H1), (D2, H2)}", "unfolding P920_example_gfp_F_value"], ["proof (prove)\ngoal (1 subgoal):\n 1. P920_example.match\n     ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)}) =\n    {(D1, H1), (D2, H2)}", "by simp"], ["", "lemma P920_example_lfp_F_value:\n  shows \"P920_example_lfp_F UNIV = ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P920_example_lfp_F UNIV =\n    ({(D1, H1), (D1, H2), (D2, H2)}, {(D1, H1), (D2, H1), (D2, H2)})", "by eval"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can now evaluate the @{const \"gfp\"} of @{const \"P920_example.F\"}\n(i.e., \\<open>F\\<close> specialized to the above constants) using\nIsabelle's \\verb!value! antiquotation or \\verb!eval! method. This\nyields the \\<open>(XD, XH)\\<close> pair:\n\n\\begin{center}\n  @{thm (rhs) \"P920_example_gfp_F_value\"}\n\\end{center}\n\nThe stable match is therefore @{thm (rhs) \"P920_example_gfp_F_match_value\"}.\n\nThe @{const \"lfp\"} of @{const \"P920_example.F\"} is identical to the\n@{const \"gfp\"}:\n\n\\begin{center}\n  @{thm (rhs) \"P920_example_lfp_F_value\"}\n\\end{center}\n\nThis implies that there is only one stable match in this scenario.\n\n\\<close>"], ["", "subsection\\<open> Theorem~4: Optimality \\label{sec:contracts-optimality} \\<close>"], ["", "text (in ContractsWithSubstitutes) \\<open>\n\n\\citet[Theorem~4]{HatfieldMilgrom:2005} assert that the greatest fixed\npoint @{const \"gfp_F\"} of @{const \"F\"} yields the stable match most\npreferred by the doctors in the following sense:\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition doctor_optimal_match :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"doctor_optimal_match ds Y\n    \\<longleftrightarrow> (stable_on ds Y \\<and> (\\<forall>X. \\<forall>x\\<in>X. stable_on ds X \\<longrightarrow> (\\<exists>y \\<in> Y. (x, y) \\<in> Pd (Xd x))))\""], ["", "(*<*)"], ["", "lemmas doctor_optimal_matchI = iffD2[OF doctor_optimal_match_def, unfolded conj_imp_eq_imp_imp, rule_format]"], ["", "lemmas doctor_optimal_match_stable_on = iffD1[OF doctor_optimal_match_def, THEN conjunct1]"], ["", "lemmas doctor_optimal_match_optimal = iffD1[OF doctor_optimal_match_def, THEN conjunct2, rule_format]"], ["", "lemma doctor_optimal_match_unique:\n  assumes \"doctor_optimal_match ds X\"\n  assumes \"doctor_optimal_match ds Y\"\n  shows \"X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = Y", "proof(rule iffD2[OF set_eq_iff, rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> X) = (x \\<in> Y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> X) = (x \\<in> Y)", "from Pd_linear'[where d=\"Xd x\"] Pd_Xd[where d=\"Xd x\"]\n       stable_on_allocation[OF doctor_optimal_match_stable_on[OF assms(1)]]\n       stable_on_allocation[OF doctor_optimal_match_stable_on[OF assms(2)]]\n       assms"], ["proof (chain)\npicking this:\n  Linear_order (Pd (Xd x))\n  (?x, ?y) \\<in> Pd (Xd x) \\<Longrightarrow>\n  Xd ?x = Xd x \\<and> Xd ?y = Xd x\n  inj_on Xd X\n  inj_on Xd Y\n  doctor_optimal_match ds X\n  doctor_optimal_match ds Y", "show \"x \\<in> X \\<longleftrightarrow> x \\<in> Y\""], ["proof (prove)\nusing this:\n  Linear_order (Pd (Xd x))\n  (?x, ?y) \\<in> Pd (Xd x) \\<Longrightarrow>\n  Xd ?x = Xd x \\<and> Xd ?y = Xd x\n  inj_on Xd X\n  inj_on Xd Y\n  doctor_optimal_match ds X\n  doctor_optimal_match ds Y\n\ngoal (1 subgoal):\n 1. (x \\<in> X) = (x \\<in> Y)", "unfolding doctor_optimal_match_def order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl (Pd (Xd x)) \\<and> trans (Pd (Xd x))) \\<and>\n   antisym (Pd (Xd x))) \\<and>\n  Total (Pd (Xd x))\n  (?x, ?y) \\<in> Pd (Xd x) \\<Longrightarrow>\n  Xd ?x = Xd x \\<and> Xd ?y = Xd x\n  inj_on Xd X\n  inj_on Xd Y\n  stable_on ds X \\<and>\n  (\\<forall>Xa.\n      \\<forall>x\\<in>Xa.\n         stable_on ds Xa \\<longrightarrow>\n         (\\<exists>y\\<in>X. (x, y) \\<in> Pd (Xd x)))\n  stable_on ds Y \\<and>\n  (\\<forall>X.\n      \\<forall>x\\<in>X.\n         stable_on ds X \\<longrightarrow>\n         (\\<exists>y\\<in>Y. (x, y) \\<in> Pd (Xd x)))\n\ngoal (1 subgoal):\n 1. (x \\<in> X) = (x \\<in> Y)", "by - (rule iffI; metis antisymD inj_on_eq_iff)"], ["proof (state)\nthis:\n  (x \\<in> X) = (x \\<in> Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "text (in ContractsWithSubstitutes) \\<open>\n\nIn a similar sense, @{const \"lfp_F\"} is the doctor-pessimal match.\n\nWe state a basic doctor-optimality result in terms of @{const\n\"stable_pair\"} in the @{const \"ContractsWithSubstitutes\"} locale for\ngenerality; we can establish @{const \"doctor_optimal_match\"} only\nunder additional constraints on hospital choice functions (see\n\\S\\ref{sec:contracts-irc}).\n\n\\<close>"], ["", "context ContractsWithSubstitutes\nbegin"], ["", "context\n  fixes XD_XH :: \"'a set \\<times> 'a set\"\n  fixes ds :: \"'b set\"\n  assumes \"stable_pair_on ds XD_XH\"\nbegin"], ["", "lemma gfp_F_upperbound:\n  shows \"(fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)", "have \"(fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "using stable_pair_on_fix_F[OF \\<open>stable_pair_on ds XD_XH\\<close>]"], ["proof (prove)\nusing this:\n  map_prod id dual XD_XH = F ds (map_prod id dual XD_XH)\n\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "by (metis id_apply map_prod_simp prod.collapse)"], ["proof (state)\nthis:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)", "then"], ["proof (chain)\npicking this:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)", "by (fastforce intro: gfp_upperbound)"], ["proof (state)\nthis:\n  (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma XD_XH_gfp_F:\n  shows \"fst XD_XH \\<subseteq> fst (gfp_F ds)\"\n    and \"snd (gfp_F ds) \\<subseteq> snd XD_XH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst XD_XH \\<subseteq> fst (gfp_F ds) &&&\n    snd (gfp_F ds) \\<subseteq> snd XD_XH", "using %invisible gfp_F_upperbound"], ["proof (prove)\nusing this:\n  (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)\n\ngoal (1 subgoal):\n 1. fst XD_XH \\<subseteq> fst (gfp_F ds) &&&\n    snd (gfp_F ds) \\<subseteq> snd XD_XH", "unfolding gfp_F_def"], ["proof (prove)\nusing this:\n  (fst XD_XH, dual (snd XD_XH)) \\<le> gfp (F ds)\n\ngoal (1 subgoal):\n 1. fst XD_XH \\<subseteq> fst (map_prod id undual (gfp (F ds))) &&&\n    snd (map_prod id undual (gfp (F ds))) \\<subseteq> snd XD_XH", "by (simp_all add: less_eq_dual_def less_eq_prod_def)"], ["", "lemma lfp_F_upperbound:\n  shows \"lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))", "have \"(fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "using stable_pair_on_fix_F[OF \\<open>stable_pair_on ds XD_XH\\<close>]"], ["proof (prove)\nusing this:\n  map_prod id dual XD_XH = F ds (map_prod id dual XD_XH)\n\ngoal (1 subgoal):\n 1. (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "by (metis id_apply map_prod_simp prod.collapse)"], ["proof (state)\nthis:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))", "then"], ["proof (chain)\npicking this:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))", "show ?thesis"], ["proof (prove)\nusing this:\n  (fst XD_XH, dual (snd XD_XH)) = F ds (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))", "by (fastforce intro: lfp_lowerbound)"], ["proof (state)\nthis:\n  lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma XD_XH_lfp_F:\n  shows \"fst (lfp_F ds) \\<subseteq> fst XD_XH\"\n    and \"snd XD_XH \\<subseteq> snd (lfp_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (lfp_F ds) \\<subseteq> fst XD_XH &&&\n    snd XD_XH \\<subseteq> snd (lfp_F ds)", "using %invisible lfp_F_upperbound"], ["proof (prove)\nusing this:\n  lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. fst (lfp_F ds) \\<subseteq> fst XD_XH &&&\n    snd XD_XH \\<subseteq> snd (lfp_F ds)", "unfolding lfp_F_def"], ["proof (prove)\nusing this:\n  lfp (F ds) \\<le> (fst XD_XH, dual (snd XD_XH))\n\ngoal (1 subgoal):\n 1. fst (map_prod id undual (lfp (F ds))) \\<subseteq> fst XD_XH &&&\n    snd XD_XH \\<subseteq> snd (map_prod id undual (lfp (F ds)))", "by (simp_all add: less_eq_dual_def less_eq_prod_def)"], ["", "text\\<open>\n\nWe appeal to the doctors' linear preferences to show the optimality\n(pessimality) of @{const \"gfp_F\"} (@{const \"lfp_F\"}) for doctors.\n\n\\<close>"], ["", "theorem gfp_f_doctor_optimal:\n  assumes \"x \\<in> match XD_XH\"\n  shows \"\\<exists>y \\<in> match (gfp_F ds). (x, y) \\<in> Pd (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>match (gfp_F ds). (x, y) \\<in> Pd (Xd x)", "using %invisible assms gfp_F_stable_pair_on[where ds=ds] \\<open>stable_pair_on ds XD_XH\\<close>\n      stable_pair_on_CD_on stable_pair_on_Xd Cd_Xd mem_CD_on_Cd\n      XD_XH_gfp_F(1) Cd_mono[where d=\"Xd x\" and x=x and X=\"fst XD_XH\" and Y=\"fst (gfp_F ds)\"]"], ["proof (prove)\nusing this:\n  x \\<in> match XD_XH\n  stable_pair_on ds (gfp_F ds)\n  stable_pair_on ds XD_XH\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  match ?XD_XH = CD_on ?ds (fst ?XD_XH)\n  \\<lbrakk>stable_pair_on ?ds ?XD_XH; ?x \\<in> match ?XD_XH\\<rbrakk>\n  \\<Longrightarrow> Xd ?x \\<in> ?ds\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> Xd ?x = ?d\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  fst XD_XH \\<subseteq> fst (gfp_F ds)\n  x \\<in> Cd (Xd x) (fst XD_XH) \\<Longrightarrow>\n  \\<exists>y\\<in>Cd (Xd x) (fst XD_XH \\<union> fst (gfp_F ds)).\n     (x, y) \\<in> Pd (Xd x)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>match (gfp_F ds). (x, y) \\<in> Pd (Xd x)", "by (metis sup.absorb_iff2)"], ["", "theorem lfp_f_doctor_pessimal:\n  assumes \"x \\<in> match (lfp_F ds)\"\n  shows \"\\<exists>y \\<in> match XD_XH. (x, y) \\<in> Pd (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>match XD_XH. (x, y) \\<in> Pd (Xd x)", "using %invisible assms lfp_F_stable_pair_on[where ds=ds] \\<open>stable_pair_on ds XD_XH\\<close>\n      stable_pair_on_CD_on stable_pair_on_Xd Cd_Xd mem_CD_on_Cd\n      XD_XH_lfp_F(1) Cd_mono[where d=\"Xd x\" and x=x and X=\"fst (lfp_F ds)\" and Y=\"fst XD_XH\"]"], ["proof (prove)\nusing this:\n  x \\<in> match (lfp_F ds)\n  stable_pair_on ds (lfp_F ds)\n  stable_pair_on ds XD_XH\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  match ?XD_XH = CD_on ?ds (fst ?XD_XH)\n  \\<lbrakk>stable_pair_on ?ds ?XD_XH; ?x \\<in> match ?XD_XH\\<rbrakk>\n  \\<Longrightarrow> Xd ?x \\<in> ?ds\n  ?x \\<in> Cd ?d ?X \\<Longrightarrow> Xd ?x = ?d\n  (?x \\<in> CD_on ?ds ?X) = (?x \\<in> Cd (Xd ?x) ?X \\<and> Xd ?x \\<in> ?ds)\n  fst (lfp_F ds) \\<subseteq> fst XD_XH\n  x \\<in> Cd (Xd x) (fst (lfp_F ds)) \\<Longrightarrow>\n  \\<exists>y\\<in>Cd (Xd x) (fst (lfp_F ds) \\<union> fst XD_XH).\n     (x, y) \\<in> Pd (Xd x)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>match XD_XH. (x, y) \\<in> Pd (Xd x)", "by (metis sup.absorb_iff2)"], ["", "end"], ["", "end"], ["", "theorem (in ContractsWithSubstitutesAndIRC) gfp_F_doctor_optimal_match:\n  shows \"doctor_optimal_match ds (match (gfp_F ds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doctor_optimal_match ds (match (gfp_F ds))", "by %invisible (rule doctor_optimal_matchI[OF gfp_F_stable_on]) (auto simp: T1 elim: gfp_f_doctor_optimal)"], ["", "text (in ContractsWithSubstitutesAndIRC) \\<open>\n\nConversely @{const \"lfp_F\"} is most preferred by the hospitals in a\nrevealed-preference sense, and @{const \"gfp_F\"} least preferred. These\nresults depend on @{thm [source] Ch_domain} and hence the @{const\n\"irc\"} hypothesis on hospital choice functions.\n\n\\<close>"], ["", "context ContractsWithSubstitutesAndIRC\nbegin"], ["", "theorem lfp_f_hospital_optimal:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> Ch h (match (lfp_F ds))\"\n  shows \"x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)", "from \\<open>stable_pair_on ds XD_XH\\<close>"], ["proof (chain)\npicking this:\n  stable_pair_on ds XD_XH", "have \"match (lfp_F ds) \\<union> match XD_XH \\<subseteq> snd (lfp_F ds)\""], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n\ngoal (1 subgoal):\n 1. match (lfp_F ds) \\<union> match XD_XH \\<subseteq> snd (lfp_F ds)", "by (simp add: XD_XH_lfp_F(2) le_infI2)"], ["proof (state)\nthis:\n  match (lfp_F ds) \\<union> match XD_XH \\<subseteq> snd (lfp_F ds)\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)", "with \\<open>x \\<in> Ch h (match (lfp_F ds))\\<close> lfp_F_stable_pair_on stable_pair_on_Ch Ch_range"], ["proof (chain)\npicking this:\n  x \\<in> Ch h (match (lfp_F ds))\n  stable_pair_on ?ds (lfp_F ?ds)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  Ch ?h (snd ?XD_XH) = match ?XD_XH \\<inter> {x. Xh x = ?h}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  match (lfp_F ds) \\<union> match XD_XH \\<subseteq> snd (lfp_F ds)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Ch h (match (lfp_F ds))\n  stable_pair_on ?ds (lfp_F ?ds)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  Ch ?h (snd ?XD_XH) = match ?XD_XH \\<inter> {x. Xh x = ?h}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  match (lfp_F ds) \\<union> match XD_XH \\<subseteq> snd (lfp_F ds)\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)", "by - (rule iia_onD[OF Ch_iia[where h=h], where B=\"snd (lfp_F ds)\", simplified]; blast)"], ["proof (state)\nthis:\n  x \\<in> Ch h (match (lfp_F ds) \\<union> match XD_XH)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gfp_f_hospital_pessimal:\n  assumes \"stable_pair_on ds XD_XH\"\n  assumes \"x \\<in> Ch h (match XD_XH)\"\n  shows \"x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)", "from \\<open>stable_pair_on ds XD_XH\\<close>"], ["proof (chain)\npicking this:\n  stable_pair_on ds XD_XH", "have \"match (gfp_F ds) \\<union> match XD_XH \\<subseteq> snd XD_XH\""], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n\ngoal (1 subgoal):\n 1. match (gfp_F ds) \\<union> match XD_XH \\<subseteq> snd XD_XH", "by (simp add: XD_XH_gfp_F(2) le_infI2)"], ["proof (state)\nthis:\n  match (gfp_F ds) \\<union> match XD_XH \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)", "with assms lfp_F_stable_pair_on stable_pair_on_Ch Ch_range"], ["proof (chain)\npicking this:\n  stable_pair_on ds XD_XH\n  x \\<in> Ch h (match XD_XH)\n  stable_pair_on ?ds (lfp_F ?ds)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  Ch ?h (snd ?XD_XH) = match ?XD_XH \\<inter> {x. Xh x = ?h}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  match (gfp_F ds) \\<union> match XD_XH \\<subseteq> snd XD_XH", "show ?thesis"], ["proof (prove)\nusing this:\n  stable_pair_on ds XD_XH\n  x \\<in> Ch h (match XD_XH)\n  stable_pair_on ?ds (lfp_F ?ds)\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  Ch ?h (snd ?XD_XH) = match ?XD_XH \\<inter> {x. Xh x = ?h}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  match (gfp_F ds) \\<union> match XD_XH \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)", "by - (rule iia_onD[OF Ch_iia[where h=h], where B=\"snd XD_XH\", simplified]; blast+)"], ["proof (state)\nthis:\n  x \\<in> Ch h (match (gfp_F ds) \\<union> match XD_XH)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\nThe general lattice-theoretic results of e.g. \\citet{Fleiner:2002}\ndepend on the full Tarski-Knaster fixed point theorem, which is\ndifficult to state in the present type class-based setting. (The\ntheorem itself is available in the Isabelle/HOL distribution but\nrequires working with less convenient machinery.)\n\n\\<close>"], ["", "subsection\\<open> Theorem~5 does not hold \\citep{HatfieldKojima:2008} \\<close>"], ["", "text (in Contracts) \\<open>\n\n\\citet[Theorem~5]{HatfieldMilgrom:2005} claim that:\n\\begin{quote}\n\nSuppose \\<open>H\\<close> contains at least two hospitals, which we\ndenote by \\<open>h\\<close> and \\<open>h'\\<close>. Further suppose that\n@{term \"Rh h\"} is not isotone, that is, contracts are not @{const\n\"substitutes\"} for \\<open>h\\<close>. Then there exist preference\norderings for the doctors in set \\<open>D\\<close>, a preference\nordering for a hospital \\<open>h'\\<close> with a single job opening\nsuch that, regardless of the preferences of the other hospitals, no\nstable set of contracts exists.\n\n\\end{quote}\n\n\\citet[Observation~1]{HatfieldKojima:2008} show this is not true:\nthere can be stable matches even if hospital choice functions violate\n@{const \"substitutes\"}. This motivates looking for conditions weaker\nthan @{const \"substitutes\"} that still guarantee stable matches, a\nproject taken up by \\citet{HatfieldKojima:2010}; see\n\\S\\ref{sec:cop}. We omit their counterexample to this incorrect claim.\n\n\\<close>"], ["", "subsection\\<open> Theorem~6: ``Vacancy chain'' dynamics \\label{sec:contracts-vacancy-chain} \\<close>"], ["", "text (in ContractsWithSubstitutesAndIRC) \\<open>\n\n\\citet[II(C), p923]{HatfieldMilgrom:2005} propose a model for updating\na stable match @{term \"X\"} when a doctor @{term \"d'\"}\nretires. Intuitively the contracts mentioning @{term \"d'\"} are\ndiscarded and a modified algorithm run from the @{const \"XH_largest\"}\nand @{const \"XD_smallest\"} sets determined from @{term \"X\"}. The\nresult is another stable match where the remaining doctors @{term \"ds\n- {d'}\"} are (weakly) better off and the hospitals (weakly) worse off\nthan they were in the initial state. The proofs are essentially the\nsame as for optimality (\\S\\ref{sec:contracts-optimality}).\n\n\\<close>"], ["", "context ContractsWithSubstitutesAndIRC\nbegin"], ["", "context\n  fixes X :: \"'a set\"\n  fixes d' :: \"'b\"\n  fixes ds :: \"'b set\"\nbegin"], ["", "text\\<open>\n\n\\citeauthor{HatfieldMilgrom:2005} do not motivate why the process uses\nthis functional and not @{const \"F\"}.\n\n\\<close>"], ["", "definition F' :: \"'a set \\<times> 'a set dual \\<Rightarrow> 'a set \\<times> 'a set dual\" where\n  \"F' = (\\<lambda>(XD, XH). (- RH (undual XH), dual (- RD_on (ds-{d'}) XD)))\""], ["", "lemma F'_apply:\n  \"F' (XD, XH) = (- RH (undual XH), dual (- RD_on (ds - {d'}) XD))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F' (XD, XH) = (- Rf CH (undual XH), dual (- Rf (CD_on (ds - {d'})) XD))", "by (simp add: F'_def)"], ["", "lemma %invisible F1'_antimono:\n  shows \"antimono (\\<lambda>XH. - RH XH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono (\\<lambda>XH. - Rf CH XH)", "by %invisible (rule antimonoI) (auto simp: F1_def dest: Diff_mono[OF _ monoD[OF RH_mono]])"], ["", "lemma %invisible F2'_antimono:\n  shows \"antimono (\\<lambda>XD. - RD_on (ds-{d'}) XD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono (\\<lambda>XD. - Rf (CD_on (ds - {d'})) XD)", "by %invisible (rule antimonoI) (auto simp: F2_def dest: Diff_mono[OF _ monoD[OF RD_on_mono]])"], ["", "lemma F'_mono:\n  shows \"mono F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono F'", "unfolding %invisible F'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(XD, XH).\n         (- Rf CH (undual XH), dual (- Rf (CD_on (ds - {d'})) XD)))", "using antimonoD[OF F1'_antimono] antimonoD[OF F2'_antimono]"], ["proof (prove)\nusing this:\n  ?x \\<subseteq> ?y \\<Longrightarrow> - Rf CH ?y \\<subseteq> - Rf CH ?x\n  ?x \\<subseteq> ?y \\<Longrightarrow>\n  - Rf (CD_on (ds - {d'})) ?y \\<subseteq> - Rf (CD_on (ds - {d'})) ?x\n\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>(XD, XH).\n         (- Rf CH (undual XH), dual (- Rf (CD_on (ds - {d'})) XD)))", "by (auto intro: monoI simp: less_eq_dual_def)"], ["", "lemma fix_F'_stable_pair_on:\n  \"stable_pair_on (ds - {d'}) (map_prod id undual A)\"\n  if \"A = F' A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "obtain x y where \"A = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. A = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A)"], ["proof (state)\nthis:\n  A = (x, y)\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "with that"], ["proof (chain)\npicking this:\n  A = F' A\n  A = (x, y)", "have \"F' (x, y) = (x, y)\""], ["proof (prove)\nusing this:\n  A = F' A\n  A = (x, y)\n\ngoal (1 subgoal):\n 1. F' (x, y) = (x, y)", "by simp"], ["proof (state)\nthis:\n  F' (x, y) = (x, y)\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "then"], ["proof (chain)\npicking this:\n  F' (x, y) = (x, y)", "have \"- Rf CH (undual y) = x\" and\n    \"dual (- Rf (CD_on (ds - {d'})) x) = y\""], ["proof (prove)\nusing this:\n  F' (x, y) = (x, y)\n\ngoal (1 subgoal):\n 1. - Rf CH (undual y) = x &&& dual (- Rf (CD_on (ds - {d'})) x) = y", "by (simp_all only: F'_apply prod_eq_iff fst_conv snd_conv)"], ["proof (state)\nthis:\n  - Rf CH (undual y) = x\n  dual (- Rf (CD_on (ds - {d'})) x) = y\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "with \\<open>A = (x, y)\\<close>"], ["proof (chain)\npicking this:\n  A = (x, y)\n  - Rf CH (undual y) = x\n  dual (- Rf (CD_on (ds - {d'})) x) = y", "show ?thesis"], ["proof (prove)\nusing this:\n  A = (x, y)\n  - Rf CH (undual y) = x\n  dual (- Rf (CD_on (ds - {d'})) x) = y\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual A)", "by (simp add: stable_pair_on_def dual_eq_iff)"], ["proof (state)\nthis:\n  stable_pair_on (ds - {d'}) (map_prod id undual A)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWe model their update process using the @{const \"while\"} combinator,\nas we cannot connect it to the extremal fixed points as we did in\n\\S\\ref{sec:contracts-algorithmics} because we begin computing from the\nstable match @{term \"X\"}.\n\n\\<close>"], ["", "definition F'_iter :: \"'a set \\<times> 'a set dual\" where\n  \"F'_iter = (while (\\<lambda>A. F' A \\<noteq> A) F' (XD_smallest ds X, dual (XH_largest ds X)))\""], ["", "abbreviation F'_iter_match :: \"'a set\" where\n  \"F'_iter_match \\<equiv> match (map_prod id undual F'_iter)\""], ["", "context\n  assumes \"stable_on ds X\"\nbegin"], ["", "lemma F_start:\n  shows \"F ds (XD_smallest ds X, dual (XH_largest ds X)) = (XD_smallest ds X, dual (XH_largest ds X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F ds (XD_smallest ds X, dual (XH_largest ds X)) =\n    (XD_smallest ds X, dual (XH_largest ds X))", "using %invisible CH_XH_largest[OF \\<open>stable_on ds X\\<close>] CD_on_XD_smallest[OF \\<open>stable_on ds X\\<close>] X_subseteq_XH_largest[OF \\<open>stable_on ds X\\<close>]"], ["proof (prove)\nusing this:\n  CH (XH_largest ds X) = X\n  CD_on ds (XD_smallest ds X) = X\n  X \\<subseteq> XH_largest ds X\n\ngoal (1 subgoal):\n 1. F ds (XD_smallest ds X, dual (XH_largest ds X)) =\n    (XD_smallest ds X, dual (XH_largest ds X))", "unfolding F_def F1_def F2_def XD_smallest_def"], ["proof (prove)\nusing this:\n  CH (XH_largest ds X) = X\n  CD_on ds (- (XH_largest ds X - X)) = X\n  X \\<subseteq> XH_largest ds X\n\ngoal (1 subgoal):\n 1. (case (- (XH_largest ds X - X), dual (XH_largest ds X)) of\n     (XD, XH) \\<Rightarrow>\n       (- Rf CH (undual XH),\n        dual (- Rf (CD_on ds) (- Rf CH (undual XH))))) =\n    (- (XH_largest ds X - X), dual (XH_largest ds X))", "by (auto simp add: dual_eq_iff)"], ["", "lemma F'_start:\n  shows \"(XD_smallest ds X, dual (XH_largest ds X)) \\<le> F' (XD_smallest ds X, dual (XH_largest ds X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (XD_smallest ds X, dual (XH_largest ds X))\n    \\<le> F' (XD_smallest ds X, dual (XH_largest ds X))", "using %invisible F_start"], ["proof (prove)\nusing this:\n  F ds (XD_smallest ds X, dual (XH_largest ds X)) =\n  (XD_smallest ds X, dual (XH_largest ds X))\n\ngoal (1 subgoal):\n 1. (XD_smallest ds X, dual (XH_largest ds X))\n    \\<le> F' (XD_smallest ds X, dual (XH_largest ds X))", "unfolding F_def F1_def F2_def F'_def"], ["proof (prove)\nusing this:\n  (case (XD_smallest ds X, dual (XH_largest ds X)) of\n   (XD, XH) \\<Rightarrow>\n     (- Rf CH (undual XH), dual (- Rf (CD_on ds) (- Rf CH (undual XH))))) =\n  (XD_smallest ds X, dual (XH_largest ds X))\n\ngoal (1 subgoal):\n 1. (XD_smallest ds X, dual (XH_largest ds X))\n    \\<le> (case (XD_smallest ds X, dual (XH_largest ds X)) of\n           (XD, XH) \\<Rightarrow>\n             (- Rf CH (undual XH), dual (- Rf (CD_on (ds - {d'})) XD)))", "unfolding CD_on_def XD_smallest_def"], ["proof (prove)\nusing this:\n  (case (- (XH_largest ds X - X), dual (XH_largest ds X)) of\n   (XD, XH) \\<Rightarrow>\n     (- Rf CH (undual XH),\n      dual\n       (- (- Rf CH (undual XH) -\n           (\\<Union>d\\<in>ds. Cd d (- Rf CH (undual XH))))))) =\n  (- (XH_largest ds X - X), dual (XH_largest ds X))\n\ngoal (1 subgoal):\n 1. (- (XH_largest ds X - X), dual (XH_largest ds X))\n    \\<le> (case (- (XH_largest ds X - X), dual (XH_largest ds X)) of\n           (XD, XH) \\<Rightarrow>\n             (- Rf CH (undual XH),\n              dual (- (XD - (\\<Union>d\\<in>ds - {d'}. Cd d XD)))))", "by (auto simp add: dual_eq_iff dual_less_eq_iff)"], ["", "lemma\n  shows F'_iter_stable_pair_on: \"stable_pair_on (ds-{d'}) (map_prod id undual F'_iter)\" (is \"?thesis1\")\n    and F'_start_le_F'_iter: \"(XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual F'_iter) &&&\n    (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter", "proof %invisible -"], ["proof (state)\ngoal (2 subgoals):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n 2. (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter", "obtain P where XXX: \"while_option (\\<lambda>A. F' A \\<noteq> A) F' ((XD_smallest ds X), dual (XH_largest ds X)) = Some P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        while_option (\\<lambda>A. F' A \\<noteq> A) F'\n         (XD_smallest ds X, dual (XH_largest ds X)) =\n        Some P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using while_option_finite_increasing_Some[OF F'_mono _ F'_start, simplified]"], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     while_option (\\<lambda>A. F' A \\<noteq> A) F'\n      (XD_smallest ds X, dual (XH_largest ds X)) =\n     Some (a, b)\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        while_option (\\<lambda>A. F' A \\<noteq> A) F'\n         (XD_smallest ds X, dual (XH_largest ds X)) =\n        Some P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  while_option (\\<lambda>A. F' A \\<noteq> A) F'\n   (XD_smallest ds X, dual (XH_largest ds X)) =\n  Some P\n\ngoal (2 subgoals):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n 2. (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter", "with while_option_stop2[OF XXX] fix_F'_stable_pair_on[where A=P]"], ["proof (chain)\npicking this:\n  \\<exists>k.\n     P = (F' ^^ k) (XD_smallest ds X, dual (XH_largest ds X)) \\<and>\n     \\<not> F' P \\<noteq> P\n  P = F' P \\<Longrightarrow>\n  stable_pair_on (ds - {d'}) (map_prod id undual P)\n  while_option (\\<lambda>A. F' A \\<noteq> A) F'\n   (XD_smallest ds X, dual (XH_largest ds X)) =\n  Some P", "show ?thesis1 and ?thesis2"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     P = (F' ^^ k) (XD_smallest ds X, dual (XH_largest ds X)) \\<and>\n     \\<not> F' P \\<noteq> P\n  P = F' P \\<Longrightarrow>\n  stable_pair_on (ds - {d'}) (map_prod id undual P)\n  while_option (\\<lambda>A. F' A \\<noteq> A) F'\n   (XD_smallest ds X, dual (XH_largest ds X)) =\n  Some P\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual F'_iter) &&&\n    (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter", "using funpow_mono2[OF F'_mono _ order.refl F'_start, where i=0]"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     P = (F' ^^ k) (XD_smallest ds X, dual (XH_largest ds X)) \\<and>\n     \\<not> F' P \\<noteq> P\n  P = F' P \\<Longrightarrow>\n  stable_pair_on (ds - {d'}) (map_prod id undual P)\n  while_option (\\<lambda>A. F' A \\<noteq> A) F'\n   (XD_smallest ds X, dual (XH_largest ds X)) =\n  Some P\n  0 \\<le> ?j \\<Longrightarrow>\n  (F' ^^ 0) (XD_smallest ds X, dual (XH_largest ds X))\n  \\<le> (F' ^^ ?j) (XD_smallest ds X, dual (XH_largest ds X))\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'}) (map_prod id undual F'_iter) &&&\n    (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter", "unfolding F'_iter_def while_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     P = (F' ^^ k) (XD_smallest ds X, dual (XH_largest ds X)) \\<and>\n     \\<not> F' P \\<noteq> P\n  P = F' P \\<Longrightarrow>\n  stable_pair_on (ds - {d'}) (map_prod id undual P)\n  while_option (\\<lambda>A. F' A \\<noteq> A) F'\n   (XD_smallest ds X, dual (XH_largest ds X)) =\n  Some P\n  0 \\<le> ?j \\<Longrightarrow>\n  (F' ^^ 0) (XD_smallest ds X, dual (XH_largest ds X))\n  \\<le> (F' ^^ ?j) (XD_smallest ds X, dual (XH_largest ds X))\n\ngoal (1 subgoal):\n 1. stable_pair_on (ds - {d'})\n     (map_prod id undual\n       (the (while_option (\\<lambda>A. F' A \\<noteq> A) F'\n              (XD_smallest ds X, dual (XH_largest ds X))))) &&&\n    (XD_smallest ds X, dual (XH_largest ds X))\n    \\<le> the (while_option (\\<lambda>A. F' A \\<noteq> A) F'\n                (XD_smallest ds X, dual (XH_largest ds X)))", "by auto"], ["proof (state)\nthis:\n  stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n  (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma F'_iter_match_stable_on:\n  shows \"stable_on (ds-{d'}) F'_iter_match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_on (ds - {d'}) (match (map_prod id undual F'_iter))", "by %invisible (rule stable_pair_on_stable_on) (metis F'_iter_stable_pair_on)"], ["", "theorem F'_iter_match_doctors_weakly_better_off:\n  assumes \"x \\<in> Cd d X\"\n  assumes \"d \\<noteq> d'\"\n  shows \"\\<exists>y \\<in> Cd d F'_iter_match. (x, y) \\<in> Pd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "from \\<open>stable_on ds X\\<close> assms"], ["proof (chain)\npicking this:\n  stable_on ds X\n  x \\<in> Cd d X\n  d \\<noteq> d'", "have \"d \\<in> ds\""], ["proof (prove)\nusing this:\n  stable_on ds X\n  x \\<in> Cd d X\n  d \\<noteq> d'\n\ngoal (1 subgoal):\n 1. d \\<in> ds", "by (blast dest: Cd_Xd Cd_range' stable_on_Xd)"], ["proof (state)\nthis:\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "with assms \\<open>stable_on ds X\\<close> stable_on_stable_pair_on[OF \\<open>stable_on ds X\\<close>]"], ["proof (chain)\npicking this:\n  x \\<in> Cd d X\n  d \\<noteq> d'\n  stable_on ds X\n  stable_pair_on ds (XD_smallest ds X, XH_largest ds X)\n  d \\<in> ds", "have \"\\<exists>y\\<in>Cd d (XD_smallest ds X \\<union> fst F'_iter). (x, y) \\<in> Pd d\""], ["proof (prove)\nusing this:\n  x \\<in> Cd d X\n  d \\<noteq> d'\n  stable_on ds X\n  stable_pair_on ds (XD_smallest ds X, XH_largest ds X)\n  d \\<in> ds\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (XD_smallest ds X \\<union> fst F'_iter).\n       (x, y) \\<in> Pd d", "by - (rule Cd_mono; fastforce dest: X_XD_smallest_XH_largest stable_pair_on_Cd_match)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>Cd d (XD_smallest ds X \\<union> fst F'_iter).\n     (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "with F'_iter_stable_pair_on F'_start_le_F'_iter"], ["proof (chain)\npicking this:\n  stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n  (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\n  \\<exists>y\\<in>Cd d (XD_smallest ds X \\<union> fst F'_iter).\n     (x, y) \\<in> Pd d", "have \"\\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d\""], ["proof (prove)\nusing this:\n  stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n  (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\n  \\<exists>y\\<in>Cd d (XD_smallest ds X \\<union> fst F'_iter).\n     (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d", "by (metis Pair_le Un_absorb1 prod.collapse)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "with \\<open>d \\<noteq> d'\\<close> \\<open>d \\<in> ds\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> d'\n  d \\<in> ds\n  \\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<noteq> d'\n  d \\<in> ds\n  \\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "using stable_pair_on_Cd[OF F'_iter_stable_pair_on, symmetric, of d]"], ["proof (prove)\nusing this:\n  d \\<noteq> d'\n  d \\<in> ds\n  \\<exists>y\\<in>Cd d (fst F'_iter). (x, y) \\<in> Pd d\n  d \\<in> ds - {d'} \\<Longrightarrow>\n  match (map_prod id undual F'_iter) \\<inter> Field (Pd d) =\n  Cd d (fst (map_prod id undual F'_iter))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n       (x, y) \\<in> Pd d", "by (subst Cd_domain[symmetric]) (simp add: Cd_idem)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>Cd d (match (map_prod id undual F'_iter)).\n     (x, y) \\<in> Pd d\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem F'_iter_match_hospitals_weakly_worse_off:\n  assumes \"x \\<in> Ch h X\"\n  shows \"x \\<in> Ch h (F'_iter_match \\<union> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (map_prod id undual F'_iter) \\<union> X)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (map_prod id undual F'_iter) \\<union> X)", "from F'_iter_stable_pair_on F'_start_le_F'_iter stable_on_stable_pair_on[OF \\<open>stable_on ds X\\<close>] X_subseteq_XH_largest[OF \\<open>stable_on ds X\\<close>]"], ["proof (chain)\npicking this:\n  stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n  (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\n  stable_pair_on ds (XD_smallest ds X, XH_largest ds X)\n  X \\<subseteq> XH_largest ds X", "have \"F'_iter_match \\<union> X \\<subseteq> XH_largest ds X\""], ["proof (prove)\nusing this:\n  stable_pair_on (ds - {d'}) (map_prod id undual F'_iter)\n  (XD_smallest ds X, dual (XH_largest ds X)) \\<le> F'_iter\n  stable_pair_on ds (XD_smallest ds X, XH_largest ds X)\n  X \\<subseteq> XH_largest ds X\n\ngoal (1 subgoal):\n 1. match (map_prod id undual F'_iter) \\<union> X\n    \\<subseteq> XH_largest ds X", "by (simp add: less_eq_prod_def le_infI2 less_eq_dual_def)"], ["proof (state)\nthis:\n  match (map_prod id undual F'_iter) \\<union> X \\<subseteq> XH_largest ds X\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (map_prod id undual F'_iter) \\<union> X)", "with assms Ch_range \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> Ch h X\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  stable_on ds X\n  match (map_prod id undual F'_iter) \\<union> X \\<subseteq> XH_largest ds X", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Ch h X\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  stable_on ds X\n  match (map_prod id undual F'_iter) \\<union> X \\<subseteq> XH_largest ds X\n\ngoal (1 subgoal):\n 1. x \\<in> Ch h (match (map_prod id undual F'_iter) \\<union> X)", "by - (rule iia_onD[OF Ch_iia, where B=\"XH_largest ds X\"], auto, metis Ch_CH_irc_idem CH_XH_largest)"], ["proof (state)\nthis:\n  x \\<in> Ch h (match (map_prod id undual F'_iter) \\<union> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\n\\citeauthor{HatfieldMilgrom:2005} observe but do not prove that\n@{const \"F'_iter_match\"} is not necessarily doctor-optimal wrt the new\nset of doctors, even if @{term \"X\"} was.\n\nThese results seem incomplete. One might expect that the process of\nreacting to a doctor's retirement would involve considering new\nentrants to the workforce and allowing the set of possible contracts\nto be refined. There are also the questions of hospitals opening and\nclosing.\n\n\\<close>"], ["", "end"], ["", "end"], ["", "end"], ["", "subsection\\<open> Theorems~8~and~9: A ``rural hospitals'' theorem \\label{sec:contracts-rh} \\<close>"], ["", "text\\<open>\n\nGiven that some hospitals are less desirable than others, the question\narises of whether there is a mechanism that can redistribute doctors\nto under-resourced hospitals while retaining the stability of the\nmatch. Roth's @{emph \\<open>rural hospitals theorem\\<close>}\n\\citep[Theorem~5.12]{RothSotomayor:1990} resolves this in the negative\nby showing that each doctor and hospital signs the same number of\ncontracts in every stable match. In the context of contracts the\ntheorem relies on the further hypothesis that hospital choices satisfy\nthe law of aggregate demand (\\S\\ref{sec:cf-lad}).\n\n\\<close>"], ["", "locale ContractsWithLAD = Contracts +\n  assumes Ch_lad: \"\\<forall>h. lad (Ch h)\""], ["", "locale ContractsWithSubstitutesAndLAD =\n  ContractsWithSubstitutes + ContractsWithLAD"], ["", "text\\<open>\n\nWe can use results that hold under @{const \"irc\"} by discharging that\nhypothesis against @{const \"lad\"} using the @{thm [source]\n\"lad_on_substitutes_on_irc_on\"} lemma. This is the effect of the\nfollowing \\<open>sublocale\\<close> command:\n\n\\<close>"], ["", "sublocale ContractsWithSubstitutesAndLAD < ContractsWithSubstitutesAndIRC"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC Xd Xh Pd Ch", "using Ch_range Ch_substitutes Ch_lad"], ["proof (prove)\nusing this:\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h. substitutes (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC Xd Xh Pd Ch", "by unfold_locales (blast intro: lad_on_substitutes_on_irc_on f_range_onI)"], ["", "context ContractsWithSubstitutesAndLAD\nbegin"], ["", "text\\<open>\n\nThe following results lead to \\citet[Theorem~8]{HatfieldMilgrom:2005},\nand the proofs go as they say. Again we state these with respect to an\narbitrary solution to @{const \"stable_pair\"}.\n\n\\<close>"], ["", "context\n  fixes XD_XH :: \"'a set \\<times> 'a set\"\n  fixes ds :: \"'b set\"\n  assumes \"stable_pair_on ds XD_XH\"\nbegin"], ["", "lemma Cd_XD_gfp_F_card:\n  assumes \"d \\<in> ds\"\n  shows \"card (Cd d (fst XD_XH)) \\<le> card (Cd d (fst (gfp_F ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Cd d (fst XD_XH)) \\<le> card (Cd d (fst (gfp_F ds)))", "using %invisible assms Cd_lad XD_XH_gfp_F(1)[OF \\<open>stable_pair_on ds XD_XH\\<close>]"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  lad_on ?X (Cd ?d)\n  fst XD_XH \\<subseteq> fst (gfp_F ds)\n\ngoal (1 subgoal):\n 1. card (Cd d (fst XD_XH)) \\<le> card (Cd d (fst (gfp_F ds)))", "unfolding lad_on_def"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  \\<forall>B\\<subseteq>?X.\n     \\<forall>C\\<subseteq>B. card (Cd ?d C) \\<le> card (Cd ?d B)\n  fst XD_XH \\<subseteq> fst (gfp_F ds)\n\ngoal (1 subgoal):\n 1. card (Cd d (fst XD_XH)) \\<le> card (Cd d (fst (gfp_F ds)))", "by blast"], ["", "lemma Ch_gfp_F_XH_card:\n  shows \"card (Ch h (snd (gfp_F ds))) \\<le> card (Ch h (snd XD_XH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Ch h (snd (gfp_F ds))) \\<le> card (Ch h (snd XD_XH))", "using %invisible Ch_lad XD_XH_gfp_F(2)[OF \\<open>stable_pair_on ds XD_XH\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>h. lad (Ch h)\n  snd (gfp_F ds) \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. card (Ch h (snd (gfp_F ds))) \\<le> card (Ch h (snd XD_XH))", "unfolding lad_on_def"], ["proof (prove)\nusing this:\n  \\<forall>h B.\n     B \\<subseteq> UNIV \\<longrightarrow>\n     (\\<forall>C\\<subseteq>B. card (Ch h C) \\<le> card (Ch h B))\n  snd (gfp_F ds) \\<subseteq> snd XD_XH\n\ngoal (1 subgoal):\n 1. card (Ch h (snd (gfp_F ds))) \\<le> card (Ch h (snd XD_XH))", "by blast"], ["", "theorem Theorem_8:\n  shows \"d \\<in> ds \\<Longrightarrow> card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\"\n    and \"card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d \\<in> ds \\<Longrightarrow>\n     card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))) &&&\n    card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "proof %invisible -"], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "let ?Sum_Cd_gfp = \"\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))\""], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "let ?Sum_Ch_gfp = \"\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))\""], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "let ?Sum_Cd_XD = \"\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))\""], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "let ?Sum_Ch_XH = \"\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))\""], ["proof (state)\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"?Sum_Cd_gfp = ?Sum_Ch_gfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))", "using stable_pair_on_CD_on_CH[OF gfp_F_stable_pair_on] CD_on_card[symmetric] CH_card[symmetric]"], ["proof (prove)\nusing this:\n  CD_on ?ds (fst (gfp_F ?ds)) = CH (snd (gfp_F ?ds))\n  (\\<Sum>d\\<in>?ds. card (Cd d ?X)) = card (CD_on ?ds ?X)\n  (\\<Sum>h\\<in>UNIV. card (Ch h ?X)) = card (CH ?X)\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"\\<dots> \\<le> ?Sum_Ch_XH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n    \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))", "using Ch_gfp_F_XH_card"], ["proof (prove)\nusing this:\n  card (Ch ?h (snd (gfp_F ds))) \\<le> card (Ch ?h (snd XD_XH))\n\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n    \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))", "by (simp add: sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n  \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n  \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"\\<dots> = ?Sum_Cd_XD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))", "using stable_pair_on_CD_on_CH[OF \\<open>stable_pair_on ds XD_XH\\<close>] CD_on_card[symmetric] CH_card[symmetric]"], ["proof (prove)\nusing this:\n  CD_on ds (fst XD_XH) = CH (snd XD_XH)\n  (\\<Sum>d\\<in>?ds. card (Cd d ?X)) = card (CD_on ?ds ?X)\n  (\\<Sum>h\\<in>UNIV. card (Ch h ?X)) = card (CH ?X)\n\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n  \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))", "have \"?Sum_Cd_XD = ?Sum_Cd_gfp\""], ["proof (prove)\nusing this:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n  \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))", "using Cd_XD_gfp_F_card"], ["proof (prove)\nusing this:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n  \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n  ?d \\<in> ds \\<Longrightarrow>\n  card (Cd ?d (fst XD_XH)) \\<le> card (Cd ?d (fst (gfp_F ds)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))", "by (simp add: eq_iff sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n\ngoal (2 subgoals):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n 2. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "with Cd_XD_gfp_F_card"], ["proof (chain)\npicking this:\n  ?d \\<in> ds \\<Longrightarrow>\n  card (Cd ?d (fst XD_XH)) \\<le> card (Cd ?d (fst (gfp_F ds)))\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))", "show \"d \\<in> ds \\<Longrightarrow> card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\""], ["proof (prove)\nusing this:\n  ?d \\<in> ds \\<Longrightarrow>\n  card (Cd ?d (fst XD_XH)) \\<le> card (Cd ?d (fst (gfp_F ds)))\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n\ngoal (1 subgoal):\n 1. d \\<in> ds \\<Longrightarrow>\n    card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))", "by (fastforce elim: sum_mono_inv)"], ["proof (state)\nthis:\n  d \\<in> ds \\<Longrightarrow>\n  card (Cd d (fst XD_XH)) = card (Cd d (fst (gfp_F ds)))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"?Sum_Ch_XH = ?Sum_Cd_XD\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))", "using stable_pair_on_CD_on_CH[OF \\<open>stable_pair_on ds XD_XH\\<close>] CD_on_card[symmetric] CH_card[symmetric]"], ["proof (prove)\nusing this:\n  CD_on ds (fst XD_XH) = CH (snd XD_XH)\n  (\\<Sum>d\\<in>?ds. card (Cd d ?X)) = card (CD_on ?ds ?X)\n  (\\<Sum>h\\<in>UNIV. card (Ch h ?X)) = card (CH ?X)\n\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n    (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH))) =\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"\\<dots> \\<le> ?Sum_Cd_gfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n    \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))", "using Cd_XD_gfp_F_card"], ["proof (prove)\nusing this:\n  ?d \\<in> ds \\<Longrightarrow>\n  card (Cd ?d (fst XD_XH)) \\<le> card (Cd ?d (fst (gfp_F ds)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n    \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))", "by (simp add: sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n  \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst XD_XH)))\n  \\<le> (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds))))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "have \"\\<dots> = ?Sum_Ch_gfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))", "using stable_pair_on_CD_on_CH[OF gfp_F_stable_pair_on] CD_on_card[symmetric] CH_card[symmetric]"], ["proof (prove)\nusing this:\n  CD_on ?ds (fst (gfp_F ?ds)) = CH (snd (gfp_F ?ds))\n  (\\<Sum>d\\<in>?ds. card (Cd d ?X)) = card (CD_on ?ds ?X)\n  (\\<Sum>h\\<in>UNIV. card (Ch h ?X)) = card (CH ?X)\n\ngoal (1 subgoal):\n 1. (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>d\\<in>ds. card (Cd d (fst (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n  \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))", "have \"?Sum_Ch_gfp = ?Sum_Ch_XH\""], ["proof (prove)\nusing this:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n  \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))", "using Ch_gfp_F_XH_card"], ["proof (prove)\nusing this:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n  \\<le> (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds))))\n  card (Ch ?h (snd (gfp_F ds))) \\<le> card (Ch ?h (snd XD_XH))\n\ngoal (1 subgoal):\n 1. (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))) =\n    (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))", "by (simp add: eq_iff sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "with Ch_gfp_F_XH_card"], ["proof (chain)\npicking this:\n  card (Ch ?h (snd (gfp_F ds))) \\<le> card (Ch ?h (snd XD_XH))\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))", "show \"card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))\""], ["proof (prove)\nusing this:\n  card (Ch ?h (snd (gfp_F ds))) \\<le> card (Ch ?h (snd XD_XH))\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd (gfp_F ds)))) =\n  (\\<Sum>h\\<in>UNIV. card (Ch h (snd XD_XH)))\n\ngoal (1 subgoal):\n 1. card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))", "by (fastforce elim: sym[OF sum_mono_inv])"], ["proof (state)\nthis:\n  card (Ch h (snd XD_XH)) = card (Ch h (snd (gfp_F ds)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\nTheir result may be more easily understood when phrased in terms of\narbitrary stable matches:\n\n\\<close>"], ["", "corollary rural_hospitals_theorem:\n  assumes \"stable_on ds X\"\n  assumes \"stable_on ds Y\"\n  shows \"d \\<in> ds \\<Longrightarrow> card (Cd d X) = card (Cd d Y)\"\n    and \"card (Ch h X) = card (Ch h Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d \\<in> ds \\<Longrightarrow> card (Cd d X) = card (Cd d Y)) &&&\n    card (Ch h X) = card (Ch h Y)", "using %invisible assms T1[of ds X] T1[of ds Y] Theorem_8 stable_pair_on_Cd_match Ch_CH_irc_idem stable_pair_on_CH"], ["proof (prove)\nusing this:\n  stable_on ds X\n  stable_on ds Y\n  stable_on ds X =\n  (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> X = match XD_XH)\n  stable_on ds Y =\n  (\\<exists>XD_XH. stable_pair_on ds XD_XH \\<and> Y = match XD_XH)\n  \\<lbrakk>stable_pair_on ?ds ?XD_XH; ?d \\<in> ?ds\\<rbrakk>\n  \\<Longrightarrow> card (Cd ?d (fst ?XD_XH)) =\n                    card (Cd ?d (fst (gfp_F ?ds)))\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow>\n  card (Ch ?h (snd ?XD_XH)) = card (Ch ?h (snd (gfp_F ?ds)))\n  \\<lbrakk>stable_pair_on ?ds ?XD_XH; ?d \\<in> ?ds\\<rbrakk>\n  \\<Longrightarrow> Cd ?d (match ?XD_XH) = Cd ?d (fst ?XD_XH)\n  Ch ?h (CH ?A) = Ch ?h ?A\n  stable_pair_on ?ds ?XD_XH \\<Longrightarrow> match ?XD_XH = CH (snd ?XD_XH)\n\ngoal (1 subgoal):\n 1. (d \\<in> ds \\<Longrightarrow> card (Cd d X) = card (Cd d Y)) &&&\n    card (Ch h X) = card (Ch h Y)", "by force+"], ["", "end"], ["", "text\\<open>\n\n\\citet[Theorem~9]{HatfieldMilgrom:2005} show that without @{const\n\"lad\"}, the rural hospitals theorem does not hold. Their proof does\nnot seem to justify the theorem as stated (for instance, the contracts\n\\<open>x'\\<close>, \\<open>y'\\<close> and \\<open>z'\\<close> need not\nexist), and so we instead simply provide a counterexample (discovered\nby \\verb!nitpick!) to the same effect.\n\n\\<close>"], ["", "lemma (in ContractsWithSubstitutesAndIRC) Theorem_9_counterexample:\n  assumes \"stable_on ds Y\"\n  assumes \"stable_on ds Z\"\n  shows \"card (Ch h Y) = card (Ch h Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Ch h Y) = card (Ch h Z)", "oops"], ["", "datatype X3 = Xd1 | Xd1' | Xd2"], ["", "(*<*)"], ["", "lemma X3_UNIV:\n  shows \"UNIV = set [Xd1, Xd1', Xd2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set [X3.Xd1, X3.Xd1', X3.Xd2]", "using X3.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = X3.Xd1 \\<Longrightarrow> ?P;\n   ?y = X3.Xd1' \\<Longrightarrow> ?P;\n   ?y = X3.Xd2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = set [X3.Xd1, X3.Xd1', X3.Xd2]", "by auto"], ["", "lemmas X3_pow = subset_subseqs[OF subset_trans[OF subset_UNIV Set.equalityD1[OF X3_UNIV]]]"], ["", "instance X3 :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(X3, finite_class)", "by standard (simp add: X3_UNIV)"], ["", "lemma X3_all_pow:\n  shows \"(\\<forall>X''. P X'') \\<longleftrightarrow> (\\<forall>X''\\<in>set ` set (subseqs [Xd1, Xd1', Xd2]). P X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>X''. P X'') =\n    (\\<forall>X''\\<in>set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]). P X'')", "using X3_pow"], ["proof (prove)\nusing this:\n  ?X \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\n\ngoal (1 subgoal):\n 1. (\\<forall>X''. P X'') =\n    (\\<forall>X''\\<in>set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]). P X'')", "by blast"], ["", "(*>*)"], ["", "primrec X3d :: \"X3 \\<Rightarrow> D2\" where\n  \"X3d Xd1 = D1\"\n| \"X3d Xd1' = D1\"\n| \"X3d Xd2 = D2\""], ["", "abbreviation X3h :: \"X3 \\<Rightarrow> H1\" where\n  \"X3h _ \\<equiv> H\""], ["", "primrec PX3d :: \"D2 \\<Rightarrow> X3 rel\" where\n  \"PX3d D1 = linord_of_list [Xd1, Xd1']\"\n| \"PX3d D2 = linord_of_list [Xd2]\""], ["", "function CX3h :: \"H1 \\<Rightarrow> X3 set \\<Rightarrow> X3 set\" where\n  \"CX3h _ {Xd1} = {Xd1}\"\n| \"CX3h _ {Xd1'} = {Xd1'}\"\n| \"CX3h _ {Xd2} = {Xd2}\"\n| \"CX3h _ {Xd1, Xd1'} = {Xd1'}\"\n| \"CX3h _ {Xd1, Xd2} = {Xd1, Xd2}\"\n| \"CX3h _ {Xd1', Xd2} = {Xd1'}\"\n| \"CX3h _ {Xd1, Xd1', Xd2} = {Xd1'}\"\n| \"CX3h _ {} = {}\""], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {X3.Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {}) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {X3.Xd1}) = (uua_, {X3.Xd1}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {X3.Xd1}) = (uv_, {X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {X3.Xd1}) = (uw_, {X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {X3.Xd1}) = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 6. \\<And>uu_ uy_.\n       (uu_, {X3.Xd1}) = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1, X3.Xd2}\n 7. \\<And>uu_ uz_.\n       (uu_, {X3.Xd1}) = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 8. \\<And>uu_ va_.\n       (uu_, {X3.Xd1}) = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 9. \\<And>uu_ vb_.\n       (uu_, {X3.Xd1}) = (vb_, {}) \\<Longrightarrow> {X3.Xd1} = {}\n 10. \\<And>uv_ uva_.\n        (uv_, {X3.Xd1'}) = (uva_, {X3.Xd1'}) \\<Longrightarrow>\n        {X3.Xd1'} = {X3.Xd1'}\nA total of 37 subgoals...", "apply %invisible (case_tac x)"], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x a b.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {X3.Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {}) \\<Longrightarrow> P; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {X3.Xd1}) = (uua_, {X3.Xd1}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {X3.Xd1}) = (uv_, {X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {X3.Xd1}) = (uw_, {X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {X3.Xd1}) = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 6. \\<And>uu_ uy_.\n       (uu_, {X3.Xd1}) = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1, X3.Xd2}\n 7. \\<And>uu_ uz_.\n       (uu_, {X3.Xd1}) = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 8. \\<And>uu_ va_.\n       (uu_, {X3.Xd1}) = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 9. \\<And>uu_ vb_.\n       (uu_, {X3.Xd1}) = (vb_, {}) \\<Longrightarrow> {X3.Xd1} = {}\n 10. \\<And>uv_ uva_.\n        (uv_, {X3.Xd1'}) = (uva_, {X3.Xd1'}) \\<Longrightarrow>\n        {X3.Xd1'} = {X3.Xd1'}\nA total of 37 subgoals...", "apply (cut_tac X=b in X3_pow)"], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x a b.\n       \\<lbrakk>\\<And>uu_. x = (uu_, {X3.Xd1}) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, {X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uw_. x = (uw_, {X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>ux_. x = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow> P;\n        \\<And>uy_. x = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>uz_. x = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>va_. x = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow> P;\n        \\<And>vb_. x = (vb_, {}) \\<Longrightarrow> P; x = (a, b);\n        b \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (uu_, {X3.Xd1}) = (uua_, {X3.Xd1}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1}\n 3. \\<And>uu_ uv_.\n       (uu_, {X3.Xd1}) = (uv_, {X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 4. \\<And>uu_ uw_.\n       (uu_, {X3.Xd1}) = (uw_, {X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd2}\n 5. \\<And>uu_ ux_.\n       (uu_, {X3.Xd1}) = (ux_, {X3.Xd1, X3.Xd1'}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 6. \\<And>uu_ uy_.\n       (uu_, {X3.Xd1}) = (uy_, {X3.Xd1, X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1, X3.Xd2}\n 7. \\<And>uu_ uz_.\n       (uu_, {X3.Xd1}) = (uz_, {X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 8. \\<And>uu_ va_.\n       (uu_, {X3.Xd1}) = (va_, {X3.Xd1, X3.Xd1', X3.Xd2}) \\<Longrightarrow>\n       {X3.Xd1} = {X3.Xd1'}\n 9. \\<And>uu_ vb_.\n       (uu_, {X3.Xd1}) = (vb_, {}) \\<Longrightarrow> {X3.Xd1} = {}\n 10. \\<And>uv_ uva_.\n        (uv_, {X3.Xd1'}) = (uva_, {X3.Xd1'}) \\<Longrightarrow>\n        {X3.Xd1'} = {X3.Xd1'}\nA total of 37 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All CX3h_dom", "by lexicographic_order"], ["", "lemma PX3d_linear:\n  shows \"Linear_order (PX3d d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (PX3d d)", "by (cases d) (simp_all add: linord_of_list_Linear_order)"], ["", "lemma PX3d_range:\n  shows \"Field (PX3d d) \\<subseteq> {x. X3d x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (PX3d d) \\<subseteq> {x. X3d x = d}", "by (cases d) simp_all"], ["", "lemma CX3h_range:\n  shows \"CX3h h X \\<subseteq> {x\\<in>X. X3h x = h}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CX3h h X \\<subseteq> {x \\<in> X. H = h}", "by (cases \"(h, X)\" rule: CX3h.cases; simp; metis (mono_tags) H1.exhaust)"], ["", "lemma CX3h_singular:\n  shows \"inj_on X3d (CX3h h X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on X3d (CX3h h X)", "by (cases \"(h, X)\" rule: CX3h.cases) auto"], ["", "lemma CX3h_substitutes:\n  shows \"substitutes (CX3h h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes (CX3h h)", "apply (rule substitutes_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))", "apply (cut_tac X=B in X3_pow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))", "apply (case_tac b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        b = X3.Xd1\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 2. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        b = X3.Xd1'\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 3. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        b = X3.Xd2\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))", "apply (case_tac [!] a)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1;\n        a = X3.Xd1\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 2. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1;\n        a = X3.Xd1'\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 3. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1;\n        a = X3.Xd2\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 4. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1';\n        a = X3.Xd1\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 5. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1';\n        a = X3.Xd1'\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 6. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd1';\n        a = X3.Xd2\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 7. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd2;\n        a = X3.Xd1\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 8. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd2;\n        a = X3.Xd1'\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))\n 9. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> UNIV; a \\<in> UNIV; b \\<in> UNIV;\n        b \\<notin> CX3h h (insert b B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]); b = X3.Xd2;\n        a = X3.Xd2\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> CX3h h (insert a (insert b B))", "apply (auto simp: insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CX3h_irc:\n  shows \"irc (CX3h h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irc (CX3h h)", "apply (rule ircI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a.\n       a \\<notin> CX3h h (insert a B) \\<Longrightarrow>\n       CX3h h (insert a B) = CX3h h B", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>a \\<notin> CX3h h (insert a B); h = H\\<rbrakk>\n       \\<Longrightarrow> CX3h h (insert a B) = CX3h h B", "apply (cut_tac X=B in X3_pow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>a \\<notin> CX3h h (insert a B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\\<rbrakk>\n       \\<Longrightarrow> CX3h h (insert a B) = CX3h h B", "apply (case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>B a.\n       \\<lbrakk>a \\<notin> CX3h h (insert a B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        a = X3.Xd1\\<rbrakk>\n       \\<Longrightarrow> CX3h h (insert a B) = CX3h h B\n 2. \\<And>B a.\n       \\<lbrakk>a \\<notin> CX3h h (insert a B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        a = X3.Xd1'\\<rbrakk>\n       \\<Longrightarrow> CX3h h (insert a B) = CX3h h B\n 3. \\<And>B a.\n       \\<lbrakk>a \\<notin> CX3h h (insert a B); h = H;\n        B \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2]);\n        a = X3.Xd2\\<rbrakk>\n       \\<Longrightarrow> CX3h h (insert a B) = CX3h h B", "apply (auto simp: insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "interpretation Theorem_9: ContractsWithSubstitutesAndIRC X3d X3h PX3d CX3h"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC X3d X3h PX3d CX3h", "using %invisible PX3d_linear PX3d_range CX3h_range CX3h_singular CX3h_substitutes CX3h_irc"], ["proof (prove)\nusing this:\n  Linear_order (PX3d ?d)\n  Field (PX3d ?d) \\<subseteq> {x. X3d x = ?d}\n  CX3h ?h ?X \\<subseteq> {x \\<in> ?X. H = ?h}\n  inj_on X3d (CX3h ?h ?X)\n  substitutes (CX3h ?h)\n  irc (CX3h ?h)\n\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC X3d X3h PX3d CX3h", "by unfold_locales blast+"], ["", "lemma Theorem_9_stable_Xd1':\n  shows \"Theorem_9.stable_on UNIV {Xd1'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.stable_on UNIV {X3.Xd1'}", "proof %invisible (rule Theorem_9.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1'}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "note image_cong_simp [cong del]"], ["proof (state)\nthis:\n  \\<lbrakk>?M = ?N; \\<And>x. x \\<in> ?N =simp=> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1'}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "note INF_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Inf (?C ` ?A) = Inf (?D ` ?B)\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1'}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "note SUP_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Sup (?C ` ?A) = Sup (?D ` ?B)\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1'}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "show \"Theorem_9.individually_rational_on UNIV {Xd1'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1'}", "by (rule Theorem_9.individually_rational_onI)\n       (simp_all add: D2_UNION Theorem_9.CD_on_def Theorem_9.CH_def)"], ["proof (state)\nthis:\n  Theorem_9.individually_rational_on UNIV {X3.Xd1'}\n\ngoal (1 subgoal):\n 1. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "show \"Theorem_9.stable_no_blocking_on UNIV {Xd1'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}", "apply (rule Theorem_9.stable_no_blocking_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1'} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1'};\n        X''\n        \\<subseteq> Theorem_9.CD_on UNIV ({X3.Xd1'} \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1'} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1'};\n        X'' \\<subseteq> Theorem_9.CD_on UNIV ({X3.Xd1'} \\<union> X'');\n        h = H\\<rbrakk>\n       \\<Longrightarrow> False", "apply (cut_tac X=X'' in X3_pow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1'} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1'};\n        X'' \\<subseteq> Theorem_9.CD_on UNIV ({X3.Xd1'} \\<union> X'');\n        h = H;\n        X'' \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h H (insert X3.Xd1' X''); X'' \\<noteq> {X3.Xd1'};\n        X'' \\<subseteq> Theorem_9.CD_on UNIV (insert X3.Xd1' X''); h = H;\n        X'' = {X3.Xd1, X3.Xd1', X3.Xd2} \\<or>\n        X'' = {X3.Xd1, X3.Xd1'} \\<or>\n        X'' = {X3.Xd1, X3.Xd2} \\<or>\n        X'' = {X3.Xd1} \\<or>\n        X'' = {X3.Xd1', X3.Xd2} \\<or> X'' = {X3.Xd2} \\<or> X'' = {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1', X3.Xd2} =\n                CX3h H {X3.Xd1', X3.Xd1, X3.Xd1', X3.Xd2};\n        {X3.Xd1, X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd1'\n 2. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1', X3.Xd2} =\n                CX3h H {X3.Xd1', X3.Xd1, X3.Xd1', X3.Xd2};\n        {X3.Xd1, X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd2 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd2 = X3.Xd1'\n 3. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1'} = CX3h H {X3.Xd1', X3.Xd1, X3.Xd1'};\n        {X3.Xd1, X3.Xd1'}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd1'};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd1'\n 4. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd2} = CX3h H {X3.Xd1', X3.Xd1, X3.Xd2};\n        {X3.Xd1, X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd2};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd1'\n 5. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd2} = CX3h H {X3.Xd1', X3.Xd1, X3.Xd2};\n        {X3.Xd1, X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd2};\n        \\<not> False; X3.Xd2 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd2 = X3.Xd1'\n 6. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1} = CX3h H {X3.Xd1', X3.Xd1};\n        {X3.Xd1} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd1'\n 7. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1', X3.Xd2} = CX3h H {X3.Xd1', X3.Xd1', X3.Xd2};\n        {X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd2 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd2 = X3.Xd1'\n 8. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd2} = CX3h H {X3.Xd1', X3.Xd2};\n        {X3.Xd2} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd2 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd2 = X3.Xd1'\n 9. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd2} = CX3h H {X3.Xd1', X3.Xd1, X3.Xd2};\n        {X3.Xd1, X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1, X3.Xd2};\n        \\<not> False; X3.Xd1' \\<noteq> X3.Xd1; X3.Xd1' \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1' = X3.Xd2\n 10. \\<And>h X'' x.\n        \\<lbrakk>{X3.Xd1} = CX3h H {X3.Xd1', X3.Xd1};\n         {X3.Xd1} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1', X3.Xd1};\n         \\<not> False; X3.Xd1' \\<notin> {}\\<rbrakk>\n        \\<Longrightarrow> X3.Xd1' = X3.Xd1\nA total of 12 subgoals...", "apply (simp_all add: insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Theorem_9.stable_no_blocking_on UNIV {X3.Xd1'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Theorem_9_stable_Xd1_Xd2:\n  shows \"Theorem_9.stable_on UNIV {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.stable_on UNIV {X3.Xd1, X3.Xd2}", "proof %invisible (rule Theorem_9.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "note image_cong_simp [cong del]"], ["proof (state)\nthis:\n  \\<lbrakk>?M = ?N; \\<And>x. x \\<in> ?N =simp=> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "note INF_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Inf (?C ` ?A) = Inf (?D ` ?B)\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "note SUP_cong_simp [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?A = ?B; \\<And>x. x \\<in> ?B =simp=> ?C x = ?D x\\<rbrakk>\n  \\<Longrightarrow> Sup (?C ` ?A) = Sup (?D ` ?B)\n\ngoal (2 subgoals):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}\n 2. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "show \"Theorem_9.individually_rational_on UNIV {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}", "by (rule Theorem_9.individually_rational_onI)\n       (simp_all add: D2_UNION Theorem_9.CD_on_def Theorem_9.CH_def insert_commute)"], ["proof (state)\nthis:\n  Theorem_9.individually_rational_on UNIV {X3.Xd1, X3.Xd2}\n\ngoal (1 subgoal):\n 1. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "show \"Theorem_9.stable_no_blocking_on UNIV {Xd1, Xd2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}", "apply (rule Theorem_9.stable_no_blocking_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1, X3.Xd2} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1, X3.Xd2};\n        X''\n        \\<subseteq> Theorem_9.CD_on UNIV\n                     ({X3.Xd1, X3.Xd2} \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1, X3.Xd2} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1, X3.Xd2};\n        X''\n        \\<subseteq> Theorem_9.CD_on UNIV ({X3.Xd1, X3.Xd2} \\<union> X'');\n        h = H\\<rbrakk>\n       \\<Longrightarrow> False", "apply (cut_tac X=X'' in X3_pow)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h h ({X3.Xd1, X3.Xd2} \\<union> X'');\n        X'' \\<noteq> CX3h h {X3.Xd1, X3.Xd2};\n        X''\n        \\<subseteq> Theorem_9.CD_on UNIV ({X3.Xd1, X3.Xd2} \\<union> X'');\n        h = H;\n        X'' \\<in> set ` set (subseqs [X3.Xd1, X3.Xd1', X3.Xd2])\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = CX3h H (insert X3.Xd1 (insert X3.Xd2 X''));\n        X'' \\<noteq> {X3.Xd1, X3.Xd2};\n        X''\n        \\<subseteq> Theorem_9.CD_on UNIV\n                     (insert X3.Xd1 (insert X3.Xd2 X''));\n        h = H;\n        X'' = {X3.Xd1, X3.Xd1', X3.Xd2} \\<or>\n        X'' = {X3.Xd1, X3.Xd1'} \\<or>\n        X'' = {X3.Xd1} \\<or>\n        X'' = {X3.Xd1', X3.Xd2} \\<or>\n        X'' = {X3.Xd1'} \\<or> X'' = {X3.Xd2} \\<or> X'' = {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply safe"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1', X3.Xd2} =\n                CX3h H {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1', X3.Xd2};\n        {X3.Xd1, X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV\n                     {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd1' \\<noteq> X3.Xd1; X3.Xd1' \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1' = X3.Xd2\n 2. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1'} =\n                CX3h H {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1'};\n        {X3.Xd1, X3.Xd1'}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1'};\n        \\<not> False; X3.Xd1' \\<noteq> X3.Xd1; X3.Xd1' \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1' = X3.Xd2\n 3. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1', X3.Xd2} =\n                CX3h H {X3.Xd1, X3.Xd2, X3.Xd1', X3.Xd2};\n        {X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd1' \\<noteq> X3.Xd1; X3.Xd1' \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1' = X3.Xd2\n 4. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1'} = CX3h H {X3.Xd1, X3.Xd2, X3.Xd1'};\n        {X3.Xd1'}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1'};\n        \\<not> False; X3.Xd1' \\<noteq> X3.Xd1; X3.Xd1' \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1' = X3.Xd2\n 5. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1', X3.Xd2} =\n                CX3h H {X3.Xd1, X3.Xd2, X3.Xd1', X3.Xd2};\n        {X3.Xd1', X3.Xd2}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1', X3.Xd2};\n        \\<not> False; X3.Xd1 \\<noteq> X3.Xd1'; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd2\n 6. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1'} = CX3h H {X3.Xd1, X3.Xd2, X3.Xd1'};\n        {X3.Xd1'}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1'};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd1'\n 7. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd2} = CX3h H {X3.Xd1, X3.Xd2, X3.Xd2};\n        {X3.Xd2} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd2};\n        \\<not> False; X3.Xd1 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 = X3.Xd2\n 8. \\<And>h X'' x.\n       \\<lbrakk>{} = CX3h H {X3.Xd1, X3.Xd2};\n        {} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2};\n        \\<not> False\\<rbrakk>\n       \\<Longrightarrow> X3.Xd1 \\<in> {}\n 9. \\<And>h X'' x.\n       \\<lbrakk>{X3.Xd1, X3.Xd1'} =\n                CX3h H {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1'};\n        {X3.Xd1, X3.Xd1'}\n        \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1, X3.Xd1'};\n        \\<not> False; X3.Xd2 \\<noteq> X3.Xd1; X3.Xd2 \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> X3.Xd2 = X3.Xd1'\n 10. \\<And>h X'' x.\n        \\<lbrakk>{X3.Xd1} = CX3h H {X3.Xd1, X3.Xd2, X3.Xd1};\n         {X3.Xd1} \\<subseteq> Theorem_9.CD_on UNIV {X3.Xd1, X3.Xd2, X3.Xd1};\n         \\<not> False; X3.Xd2 \\<notin> {}\\<rbrakk>\n        \\<Longrightarrow> X3.Xd2 = X3.Xd1\nA total of 12 subgoals...", "apply (simp_all add: D2_UNION Theorem_9.CD_on_def Theorem_9.maxR_def linord_of_list_linord_of_listP insert_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Theorem_9.stable_no_blocking_on UNIV {X3.Xd1, X3.Xd2}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\nThis violates the rural hospitals theorem:\n\n\\<close>"], ["", "theorem\n  shows \"card (Theorem_9.CH {Xd1'}) \\<noteq> card (Theorem_9.CH {Xd1, Xd2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Theorem_9.CH {X3.Xd1'}) \\<noteq>\n    card (Theorem_9.CH {X3.Xd1, X3.Xd2})", "using %invisible Theorem_9_stable_Xd1' Theorem_9_stable_Xd1_Xd2 Theorem_9.stable_on_CH"], ["proof (prove)\nusing this:\n  Theorem_9.stable_on UNIV {X3.Xd1'}\n  Theorem_9.stable_on UNIV {X3.Xd1, X3.Xd2}\n  Theorem_9.stable_on ?ds ?X \\<Longrightarrow> Theorem_9.CH ?X = ?X\n\ngoal (1 subgoal):\n 1. card (Theorem_9.CH {X3.Xd1'}) \\<noteq>\n    card (Theorem_9.CH {X3.Xd1, X3.Xd2})", "by simp"], ["", "text\\<open>\n\n{\\ldots}which is attributed to the failure of the hospitals' choice\nfunctions to satisfy @{const \"lad\"}:\n\n\\<close>"], ["", "lemma CX3h_not_lad:\n  shows \"\\<not>lad (CX3h h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lad (CX3h h)", "unfolding %invisible lad_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>B\\<subseteq>UNIV.\n               \\<forall>C\\<subseteq>B.\n                  card (CX3h h C) \\<le> card (CX3h h B))", "apply (cases h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h = H \\<Longrightarrow>\n    \\<not> (\\<forall>B\\<subseteq>UNIV.\n               \\<forall>C\\<subseteq>B.\n                  card (CX3h h C) \\<le> card (CX3h h B))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. h = H \\<Longrightarrow>\n    \\<exists>B C.\n       C \\<subseteq> B \\<and> \\<not> card (CX3h H C) \\<le> card (CX3h H B)", "apply (rule exI[where x=\"{Xd1, Xd1', Xd2}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. h = H \\<Longrightarrow>\n    \\<exists>C\\<subseteq>{X3.Xd1, X3.Xd1', X3.Xd2}.\n       \\<not> card (CX3h H C) \\<le> card (CX3h H {X3.Xd1, X3.Xd1', X3.Xd2})", "apply (rule exI[where x=\"{Xd1, Xd2}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. h = H \\<Longrightarrow>\n    {X3.Xd1, X3.Xd2} \\<subseteq> {X3.Xd1, X3.Xd1', X3.Xd2} \\<and>\n    \\<not> card (CX3h H {X3.Xd1, X3.Xd2})\n           \\<le> card (CX3h H {X3.Xd1, X3.Xd1', X3.Xd2})", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n\n\\citet{CiupanHatfieldKominers:2016} discuss an alternative approach to\nthis result in a marriage market.\n\n\\<close>"], ["", "subsection\\<open> Theorems~15 and 16: Cumulative Offer Processes \\label{sec:contracts-cop} \\<close>"], ["", "text\\<open>\n\nThe goal of \\citet[{\\S}V]{HatfieldMilgrom:2005} is to connect this\ntheory of contracts with matching to earlier work on auctions by the\nfirst of the authors, in particular by eliminating the @{const\n\"substitutes\"} hypothesis. They do so by defining a @{emph \\<open>cumulative\noffer process\\<close>} (COP):\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition cop_F_HM :: \"'d set \\<Rightarrow> 'x set \\<times> 'x set \\<Rightarrow> 'x set \\<times> 'x set\" where\n  \"cop_F_HM ds = (\\<lambda>(XD, XH). (- RH XH, XH \\<union> CD_on ds (- RH XH)))\""], ["", "text\\<open>\n\nIntuitively all of the doctors simultaneously offer their most\npreferred contracts that have yet to be rejected by the hospitals, and\nthe hospitals choose amongst these and all that have been offered\npreviously. Asking hospital choice functions to satisfy the @{const\n\"substitutes\"} condition effectively forces hospitals to consider only\nthe contracts they have previously not rejected.\n\nThis definition is neither monotonic nor increasing (i.e., it is not\nthe case that @{term \"\\<forall>x. x \\<le> cop_F_HM ds x\"}). We rectify\nthis by focusing on the second part of the definition.\n\n\\<close>"], ["", "definition cop_F :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> 'x set\" where\n  \"cop_F ds XH = XH \\<union> CD_on ds (- RH XH)\""], ["", "lemma cop_F_HM_cop_F:\n  shows \"cop_F_HM ds XD_XH = (- RH (snd XD_XH), cop_F ds (snd XD_XH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cop_F_HM ds XD_XH = (- Rf CH (snd XD_XH), cop_F ds (snd XD_XH))", "unfolding cop_F_HM_def cop_F_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- Rf CH (snd XD_XH),\n     snd XD_XH \\<union> CD_on ds (- Rf CH (snd XD_XH))) =\n    (- Rf CH (snd XD_XH), snd XD_XH \\<union> CD_on ds (- Rf CH (snd XD_XH)))", "by simp"], ["", "lemma cop_F_increasing:\n  shows \"x \\<le> cop_F ds x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq> cop_F ds x", "unfolding %invisible cop_F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq> x \\<union> CD_on ds (- Rf CH x)", "by simp"], ["", "text\\<open>\n\nWe have the following straightforward case distinction principles:\n\n\\<close>"], ["", "lemma cop_F_cases:\n  assumes \"x \\<in> cop_F ds fp\"\n  obtains (fp) \"x \\<in> fp\" | (CD_on) \"x \\<in> CD_on ds (-RH fp) - fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> fp \\<Longrightarrow> thesis;\n     x \\<in> CD_on ds (- Rf CH fp) - fp \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> cop_F ds fp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> fp \\<Longrightarrow> thesis;\n     x \\<in> CD_on ds (- Rf CH fp) - fp \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding cop_F_def"], ["proof (prove)\nusing this:\n  x \\<in> fp \\<union> CD_on ds (- Rf CH fp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> fp \\<Longrightarrow> thesis;\n     x \\<in> CD_on ds (- Rf CH fp) - fp \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma CH_cop_F_cases:\n  assumes \"x \\<in> CH (cop_F ds fp)\"\n  obtains (CH) \"x \\<in> CH fp\" | (RH_fp) \"x \\<in> RH fp\" | (CD_on) \"x \\<in> CD_on ds (-RH fp) - fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> CH fp \\<Longrightarrow> thesis;\n     x \\<in> Rf CH fp \\<Longrightarrow> thesis;\n     x \\<in> CD_on ds (- Rf CH fp) - fp \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms CH_range cop_F_def"], ["proof (prove)\nusing this:\n  x \\<in> CH (cop_F ds fp)\n  CH ?A \\<subseteq> ?A\n  cop_F ?ds ?XH = ?XH \\<union> CD_on ?ds (- Rf CH ?XH)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> CH fp \\<Longrightarrow> thesis;\n     x \\<in> Rf CH fp \\<Longrightarrow> thesis;\n     x \\<in> CD_on ds (- Rf CH fp) - fp \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "text\\<open>\n\nThe existence of fixed points for our earlier definitions\n(\\S\\ref{sec:contracts-algorithmics}) was guaranteed by the\nTarski-Knaster theorem, which relies on the monotonicity of the\ndefining functional. As @{const \"cop_F\"} lacks this property, we\nappeal instead to the Bourbaki-Witt theorem for increasing\nfunctions.\n\n\\<close>"], ["", "interpretation COP: bourbaki_witt_fixpoint Sup \"{(x, y). x \\<le> y}\" \"cop_F ds\" for ds"], ["proof (prove)\ngoal (1 subgoal):\n 1. bourbaki_witt_fixpoint \\<Union> {(x, y). x \\<subseteq> y} (cop_F ds)", "by %invisible (rule bourbaki_witt_fixpoint_complete_latticeI[OF cop_F_increasing])"], ["", "definition fp_cop_F :: \"'d set \\<Rightarrow> 'x set\" where\n  \"fp_cop_F ds = COP.fixp_above ds {}\""], ["", "abbreviation \"cop ds \\<equiv> CH (fp_cop_F ds)\""], ["", "(*<*)"], ["", "lemmas fp_cop_F_unfold = COP.fixp_above_unfold[where a=\"{}\", folded fp_cop_F_def, simplified Field_def, simplified]"], ["", "lemmas fp_cop_F_code = COP.fixp_above_conv_while[where a=\"{}\", folded fp_cop_F_def, simplified Field_def, simplified]"], ["", "(*>*)"], ["", "text\\<open>\n\nGiven that the set of contracts is finite, we avoid continuity and\nadmissibility issues; we have the following straightforward induction\nprinciple:\n\n\\<close>"], ["", "lemma fp_cop_F_induct[case_names base step]:\n  assumes \"P {}\"\n  assumes \"\\<And>fp. P fp \\<Longrightarrow> P (cop_F ds fp)\"\n  shows \"P (fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (fp_cop_F ds)", "using %invisible assms"], ["proof (prove)\nusing this:\n  P {}\n  P ?fp \\<Longrightarrow> P (cop_F ds ?fp)\n\ngoal (1 subgoal):\n 1. P (fp_cop_F ds)", "by (induct rule: COP.fixp_above_induct[where a=\"{}\", folded fp_cop_F_def])\n   (fastforce intro: admissible_chfin)+"], ["", "text\\<open>\n\nAn alternative is to use the @{const \"while\"} combinator, which is\nequivalent to the above by @{thm [source] COP.fixp_above_conv_while}.\n\nIn any case, invariant reasoning is essential to verifying the\nproperties of the COP, no matter how we phrase it. We develop a small\nprogram logic to ease the reuse of the invariants we\nprove.\n\n\\<close>"], ["", "definition\n  valid :: \"'d set \\<Rightarrow> ('d set \\<Rightarrow> 'x set \\<Rightarrow> bool) \\<Rightarrow> ('d set \\<Rightarrow> 'x set \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere\n  \"valid ds P Q = (Q ds {} \\<and> (\\<forall>fp. P ds fp \\<and> Q ds fp \\<longrightarrow> Q ds (cop_F ds fp)))\""], ["", "abbreviation\n  invariant :: \"'d set \\<Rightarrow> ('d set \\<Rightarrow> 'x set \\<Rightarrow> bool) \\<Rightarrow> bool\"\nwhere\n  \"invariant ds P \\<equiv> valid ds (\\<lambda>_ _. True) P\""], ["", "text\\<open>\n\nIntuitively @{term \"valid ds P Q\"} asserts that the COP satisfies\n@{term \"Q\"} assuming that it satisfies @{term \"P\"}. This allows us to\ndecompose our invariant proofs. By setting the precondition to @{term\n\"True\"}, @{term \"invariant ds P\"} captures the proof obligations of\n@{term \"fp_cop_F_induct\"} exactly.\n\nThe following lemmas ease the syntactic manipulation of these facts.\n\n\\<close>"], ["", "lemma validI[case_names base step]:\n  assumes \"Q ds {}\"\n  assumes \"\\<And>fp. \\<lbrakk>P ds fp; Q ds fp\\<rbrakk> \\<Longrightarrow> Q ds (cop_F ds fp)\"\n  shows \"valid ds P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid ds P Q", "using %invisible assms"], ["proof (prove)\nusing this:\n  Q ds {}\n  \\<lbrakk>P ds ?fp; Q ds ?fp\\<rbrakk> \\<Longrightarrow> Q ds (cop_F ds ?fp)\n\ngoal (1 subgoal):\n 1. valid ds P Q", "unfolding valid_def"], ["proof (prove)\nusing this:\n  Q ds {}\n  \\<lbrakk>P ds ?fp; Q ds ?fp\\<rbrakk> \\<Longrightarrow> Q ds (cop_F ds ?fp)\n\ngoal (1 subgoal):\n 1. Q ds {} \\<and>\n    (\\<forall>fp.\n        P ds fp \\<and> Q ds fp \\<longrightarrow> Q ds (cop_F ds fp))", "by blast"], ["", "lemma invariant_cop_FD:\n  assumes \"invariant ds P\"\n  assumes \"P ds fp\"\n  shows \"P ds (cop_F ds fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ds (cop_F ds fp)", "using %invisible assms"], ["proof (prove)\nusing this:\n  invariant ds P\n  P ds fp\n\ngoal (1 subgoal):\n 1. P ds (cop_F ds fp)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  P ds {} \\<and>\n  (\\<forall>fp. True \\<and> P ds fp \\<longrightarrow> P ds (cop_F ds fp))\n  P ds fp\n\ngoal (1 subgoal):\n 1. P ds (cop_F ds fp)", "by blast"], ["", "lemma invariantD:\n  assumes \"invariant ds P\"\n  shows \"P ds (fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P ds (fp_cop_F ds)", "using %invisible assms fp_cop_F_induct"], ["proof (prove)\nusing this:\n  invariant ds P\n  \\<lbrakk>?P {};\n   \\<And>fp. ?P fp \\<Longrightarrow> ?P (cop_F ?ds fp)\\<rbrakk>\n  \\<Longrightarrow> ?P (fp_cop_F ?ds)\n\ngoal (1 subgoal):\n 1. P ds (fp_cop_F ds)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  P ds {} \\<and>\n  (\\<forall>fp. True \\<and> P ds fp \\<longrightarrow> P ds (cop_F ds fp))\n  \\<lbrakk>?P {};\n   \\<And>fp. ?P fp \\<Longrightarrow> ?P (cop_F ?ds fp)\\<rbrakk>\n  \\<Longrightarrow> ?P (fp_cop_F ?ds)\n\ngoal (1 subgoal):\n 1. P ds (fp_cop_F ds)", "by blast"], ["", "lemma valid_pre:\n  assumes \"valid ds P' Q\"\n  assumes \"\\<And>fp. P ds fp \\<Longrightarrow> P' ds fp\"\n  shows \"valid ds P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid ds P Q", "using %invisible assms"], ["proof (prove)\nusing this:\n  valid ds P' Q\n  P ds ?fp \\<Longrightarrow> P' ds ?fp\n\ngoal (1 subgoal):\n 1. valid ds P Q", "unfolding valid_def"], ["proof (prove)\nusing this:\n  Q ds {} \\<and>\n  (\\<forall>fp.\n      P' ds fp \\<and> Q ds fp \\<longrightarrow> Q ds (cop_F ds fp))\n  P ds ?fp \\<Longrightarrow> P' ds ?fp\n\ngoal (1 subgoal):\n 1. Q ds {} \\<and>\n    (\\<forall>fp.\n        P ds fp \\<and> Q ds fp \\<longrightarrow> Q ds (cop_F ds fp))", "by blast"], ["", "lemma valid_invariant:\n  assumes \"valid ds P Q\"\n  assumes \"invariant ds P\"\n  shows \"invariant ds (\\<lambda> ds fp. P ds fp \\<and> Q ds fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant ds (\\<lambda>ds fp. P ds fp \\<and> Q ds fp)", "using %invisible assms"], ["proof (prove)\nusing this:\n  valid ds P Q\n  invariant ds P\n\ngoal (1 subgoal):\n 1. invariant ds (\\<lambda>ds fp. P ds fp \\<and> Q ds fp)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  Q ds {} \\<and>\n  (\\<forall>fp. P ds fp \\<and> Q ds fp \\<longrightarrow> Q ds (cop_F ds fp))\n  P ds {} \\<and>\n  (\\<forall>fp. True \\<and> P ds fp \\<longrightarrow> P ds (cop_F ds fp))\n\ngoal (1 subgoal):\n 1. (P ds {} \\<and> Q ds {}) \\<and>\n    (\\<forall>fp.\n        True \\<and> P ds fp \\<and> Q ds fp \\<longrightarrow>\n        P ds (cop_F ds fp) \\<and> Q ds (cop_F ds fp))", "by blast"], ["", "lemma valid_conj:\n  assumes \"valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) P\"\n  assumes \"valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) Q\"\n  shows \"valid ds R (\\<lambda> ds fp. P ds fp \\<and> Q ds fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid ds R (\\<lambda>ds fp. P ds fp \\<and> Q ds fp)", "using %invisible assms"], ["proof (prove)\nusing this:\n  valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) P\n  valid ds (\\<lambda>ds fp. R ds fp \\<and> P ds fp \\<and> Q ds fp) Q\n\ngoal (1 subgoal):\n 1. valid ds R (\\<lambda>ds fp. P ds fp \\<and> Q ds fp)", "unfolding valid_def"], ["proof (prove)\nusing this:\n  P ds {} \\<and>\n  (\\<forall>fp.\n      (R ds fp \\<and> P ds fp \\<and> Q ds fp) \\<and>\n      P ds fp \\<longrightarrow>\n      P ds (cop_F ds fp))\n  Q ds {} \\<and>\n  (\\<forall>fp.\n      (R ds fp \\<and> P ds fp \\<and> Q ds fp) \\<and>\n      Q ds fp \\<longrightarrow>\n      Q ds (cop_F ds fp))\n\ngoal (1 subgoal):\n 1. (P ds {} \\<and> Q ds {}) \\<and>\n    (\\<forall>fp.\n        R ds fp \\<and> P ds fp \\<and> Q ds fp \\<longrightarrow>\n        P ds (cop_F ds fp) \\<and> Q ds (cop_F ds fp))", "by blast"], ["", "end"], ["", "text (in ContractsWithSubstitutes) \\<open>\n\n\\citet[Theorem~15]{HatfieldMilgrom:2005} assert that @{const\n\"fp_cop_F\"} is equivalent to the doctor-offering algorithm @{const\n\"gfp_F\"}, assuming @{const \"substitutes\"}. (Note that the fixed points\ngenerated by increasing functions do not necessarily form a lattice,\nso there is not necessarily a hospital-optimal match, and indeed in\ngeneral these do not exist.)  Our proof is eased by the decomposition\nlemma @{thm [source] gfp_F_lfp_F} and the standard properties of fixed\npoints in a lattice.\n\n\\<close>"], ["", "context ContractsWithSubstitutes\nbegin"], ["", "lemma lfp_F2_o_F1_fp_cop_F:\n  shows \"lfp (F2 ds \\<circ> F1) = fp_cop_F ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (F2 ds \\<circ> F1) = fp_cop_F ds", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp (F2 ds \\<circ> F1) \\<subseteq> fp_cop_F ds\n 2. fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)", "have \"(F2 ds \\<circ> F1) (fp_cop_F ds) \\<subseteq> cop_F ds (fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F2 ds \\<circ> F1) (fp_cop_F ds) \\<subseteq> cop_F ds (fp_cop_F ds)", "by (clarsimp simp: F2_def F1_def cop_F_def)"], ["proof (state)\nthis:\n  (F2 ds \\<circ> F1) (fp_cop_F ds) \\<subseteq> cop_F ds (fp_cop_F ds)\n\ngoal (2 subgoals):\n 1. lfp (F2 ds \\<circ> F1) \\<subseteq> fp_cop_F ds\n 2. fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)", "then"], ["proof (chain)\npicking this:\n  (F2 ds \\<circ> F1) (fp_cop_F ds) \\<subseteq> cop_F ds (fp_cop_F ds)", "show \"lfp (F2 ds \\<circ> F1) \\<subseteq> fp_cop_F ds\""], ["proof (prove)\nusing this:\n  (F2 ds \\<circ> F1) (fp_cop_F ds) \\<subseteq> cop_F ds (fp_cop_F ds)\n\ngoal (1 subgoal):\n 1. lfp (F2 ds \\<circ> F1) \\<subseteq> fp_cop_F ds", "by (simp add: lfp_lowerbound fp_cop_F_unfold[symmetric])"], ["proof (state)\nthis:\n  lfp (F2 ds \\<circ> F1) \\<subseteq> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)", "show \"fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)", "proof(induct rule: fp_cop_F_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> lfp (F2 ds \\<circ> F1)\n 2. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {} \\<subseteq> lfp (F2 ds \\<circ> F1)\n 2. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> lfp (F2 ds \\<circ> F1)", "by simp"], ["proof (state)\nthis:\n  {} \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "case (step fp)"], ["proof (state)\nthis:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "note IH = \\<open>fp \\<subseteq> lfp (F2 ds \\<circ> F1)\\<close>"], ["proof (state)\nthis:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "then"], ["proof (chain)\npicking this:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "have \"CD_on ds (- RH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)\""], ["proof (prove)\nusing this:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)", "by (subst lfp_unfold[OF F2_o_F1_mono])\n         (metis (no_types, lifting) Compl_Diff_eq F1_antimono F2_antimono F1_def F2_def Un_subset_iff antimonoD comp_apply)"], ["proof (state)\nthis:\n  CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. \\<And>fp.\n       fp \\<subseteq> lfp (F2 ds \\<circ> F1) \\<Longrightarrow>\n       cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "with IH"], ["proof (chain)\npicking this:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n  CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)", "show ?case"], ["proof (prove)\nusing this:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n  CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)", "unfolding cop_F_def"], ["proof (prove)\nusing this:\n  fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n  CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal (1 subgoal):\n 1. fp \\<union> CD_on ds (- Rf CH fp) \\<subseteq> lfp (F2 ds \\<circ> F1)", "by blast"], ["proof (state)\nthis:\n  cop_F ds fp \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fp_cop_F ds \\<subseteq> lfp (F2 ds \\<circ> F1)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Theorem_15:\n  shows \"gfp_F ds = (- RH (fp_cop_F ds), fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp_F ds = (- Rf CH (fp_cop_F ds), fp_cop_F ds)", "using lfp_F2_o_F1_fp_cop_F"], ["proof (prove)\nusing this:\n  lfp (F2 ?ds \\<circ> F1) = fp_cop_F ?ds\n\ngoal (1 subgoal):\n 1. gfp_F ds = (- Rf CH (fp_cop_F ds), fp_cop_F ds)", "unfolding gfp_F_lfp_F F1_def"], ["proof (prove)\nusing this:\n  lfp (F2 ?ds \\<circ> (\\<lambda>X'. - Rf CH X')) = fp_cop_F ?ds\n\ngoal (1 subgoal):\n 1. (- Rf CH (lfp (F2 ds \\<circ> (\\<lambda>X'. - Rf CH X'))),\n     lfp (F2 ds \\<circ> (\\<lambda>X'. - Rf CH X'))) =\n    (- Rf CH (fp_cop_F ds), fp_cop_F ds)", "by simp"], ["", "theorem Theorem_15_match:\n  shows \"match (gfp_F ds) = CH (fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match (gfp_F ds) = cop ds", "using Theorem_15"], ["proof (prove)\nusing this:\n  gfp_F ?ds = (- Rf CH (fp_cop_F ?ds), fp_cop_F ?ds)\n\ngoal (1 subgoal):\n 1. match (gfp_F ds) = cop ds", "by (fastforce dest: subsetD[OF CH_range])"], ["", "end"], ["", "text\\<open>\n\n\\label{sec:contracts-codegen-fp_cop_F}\n\nWith some auxiliary definitions, we can evaluate the COP on the\nexample from \\S\\ref{sec:contracts-codegen-gfp_F}.\n\n\\<close>"], ["", "(*<*)"], ["", "definition \"P920_example_cop_F = P920_example.cop_F\""], ["", "definition \"P920_example_fp_cop_F = P920_example.fp_cop_F\""], ["", "lemmas P920_example_cop_F_code[code] = P920_example.cop_F_def[folded P920_example_cop_F_def]"], ["", "lemmas P920_example_fp_cop_F_code[code] = P920_example.fp_cop_F_code[folded P920_example_fp_cop_F_def P920_example_cop_F_def]"], ["", "(*>*)"], ["", "lemma P920_example_fp_cop_F_value:\n  shows \"P920_example_CH (P920_example_fp_cop_F UNIV) = {(D1, H1), (D2, H2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P920_example_CH (P920_example_fp_cop_F UNIV) = {(D1, H1), (D2, H2)}", "by eval"], ["", "text\\<open>\n\n\\citet[Theorem~16]{HatfieldMilgrom:2005} assert that this process\nyields a stable match when we have a single hospital (now called an\nauctioneer) with unrestricted preferences. As before, this holds\nprovided the auctioneer's preferences satisfy @{const \"irc\"}.\n\nWe begin by establishing two obvious invariants of the COP that\nhold in general.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "lemma %invisible CH_Ch_singular:\n  assumes \"(UNIV::'h set) = {h}\"\n  shows \"CH A = Ch h A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH A = Ch h A", "unfolding CH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) = Ch h A", "using assms"], ["proof (prove)\nusing this:\n  UNIV = {h}\n\ngoal (1 subgoal):\n 1. (\\<Union>h. Ch h A) = Ch h A", "by auto"], ["", "definition cop_F_range_inv :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"cop_F_range_inv ds fp \\<longleftrightarrow> (\\<forall>x\\<in>fp. x \\<in> Field (Pd (Xd x)) \\<and> Xd x \\<in> ds)\""], ["", "definition cop_F_closed_inv :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> bool\" where\n  \"cop_F_closed_inv ds fp \\<longleftrightarrow> (\\<forall>x\\<in>fp. above (Pd (Xd x)) x \\<subseteq> fp)\""], ["", "text\\<open>\n\nThe first, @{const \"cop_F_range_inv\"}, simply states that the result\nof the COP respects the structural conditions for doctors. The second\n@{const \"cop_F_closed_inv\"} states that the COP is upwards-closed with\nrespect to the doctors' preferences.\n\n\\<close>"], ["", "lemma cop_F_range_inv:\n  shows \"invariant ds cop_F_range_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant ds cop_F_range_inv", "unfolding valid_def cop_F_range_inv_def cop_F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{}.\n        x \\<in> Field (Pd (Xd x)) \\<and> Xd x \\<in> ds) \\<and>\n    (\\<forall>fp.\n        True \\<and>\n        (\\<forall>x\\<in>fp.\n            x \\<in> Field (Pd (Xd x)) \\<and>\n            Xd x \\<in> ds) \\<longrightarrow>\n        (\\<forall>x\\<in>fp \\<union> CD_on ds (- Rf CH fp).\n            x \\<in> Field (Pd (Xd x)) \\<and> Xd x \\<in> ds))", "by (fastforce simp: mem_CD_on_Cd dest: Cd_range')"], ["", "lemma cop_F_closed_inv:\n  shows \"invariant ds cop_F_closed_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant ds cop_F_closed_inv", "unfolding valid_def cop_F_closed_inv_def cop_F_def above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{}. {b. (x, b) \\<in> Pd (Xd x)} \\<subseteq> {}) \\<and>\n    (\\<forall>fp.\n        True \\<and>\n        (\\<forall>x\\<in>fp.\n            {b. (x, b) \\<in> Pd (Xd x)} \\<subseteq> fp) \\<longrightarrow>\n        (\\<forall>x\\<in>fp \\<union> CD_on ds (- Rf CH fp).\n            {b. (x, b) \\<in> Pd (Xd x)}\n            \\<subseteq> fp \\<union> CD_on ds (- Rf CH fp)))", "by (clarsimp simp: subset_iff) (metis Cd_preferred ComplI Un_upper1 mem_CD_on_Cd subsetCE)"], ["", "lemmas fp_cop_F_range_inv = invariantD[OF cop_F_range_inv]"], ["", "lemmas fp_cop_F_range_inv' = fp_cop_F_range_inv[unfolded cop_F_range_inv_def, rule_format]"], ["", "lemmas fp_cop_F_closed_inv = invariantD[OF cop_F_closed_inv]"], ["", "lemmas fp_cop_F_closed_inv' = subsetD[OF bspec[OF invariantD[OF cop_F_closed_inv, unfolded cop_F_closed_inv_def, simplified]]]"], ["", "text\\<open>\n\nThe only challenge in showing that the COP yields a stable match is in\nestablishing @{const \"stable_no_blocking_on\"}. Our key lemma states\nthat that if @{const \"CH\"} rejects all contracts for doctor\n\\<open>d\\<close> in @{const \"fp_cop_F\"}, then all contracts for\n\\<open>d\\<close> are in @{const \"fp_cop_F\"}.\n\n\\<close>"], ["", "lemma cop_F_RH:\n  assumes \"d \\<in> ds\"\n  assumes \"x \\<in> Field (Pd d)\"\n  assumes \"aboveS (Pd d) x \\<subseteq> RH fp\"\n  shows \"x \\<in> cop_F ds fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cop_F ds fp", "using %invisible assms Pd_linear"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  x \\<in> Field (Pd d)\n  aboveS (Pd d) x \\<subseteq> Rf CH fp\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. x \\<in> cop_F ds fp", "unfolding cop_F_def"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  x \\<in> Field (Pd d)\n  aboveS (Pd d) x \\<subseteq> Rf CH fp\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. x \\<in> fp \\<union> CD_on ds (- Rf CH fp)", "by (clarsimp simp: mem_CD_on_Cd Cd_greatest greatest_def aboveS_def order_on_defs total_on_def subset_iff)\n   (metis Compl_Diff_eq Compl_iff Diff_iff IntE Pd_Xd refl_onD)"], ["", "lemma fp_cop_F_all:\n  assumes \"d \\<in> ds\"\n  assumes \"d \\<notin> Xd ` CH (fp_cop_F ds)\"\n  shows \"Field (Pd d) \\<subseteq> fp_cop_F ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd d) \\<subseteq> fp_cop_F ds", "proof %invisible (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Field (Pd d) \\<Longrightarrow> x \\<in> fp_cop_F ds", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Field (Pd d) \\<Longrightarrow> x \\<in> fp_cop_F ds", "assume \"x \\<in> Field (Pd d)\""], ["proof (state)\nthis:\n  x \\<in> Field (Pd d)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Field (Pd d) \\<Longrightarrow> x \\<in> fp_cop_F ds", "from spec[OF Pd_linear] this finite[of \"Pd d\"]"], ["proof (chain)\npicking this:\n  Linear_order (Pd ?x)\n  x \\<in> Field (Pd d)\n  finite (Pd d)", "show \"x \\<in> fp_cop_F ds\""], ["proof (prove)\nusing this:\n  Linear_order (Pd ?x)\n  x \\<in> Field (Pd d)\n  finite (Pd d)\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "proof(induct rule: finite_Linear_order_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Field (Pd d);\n        \\<And>y.\n           y \\<in> aboveS (Pd d) x \\<Longrightarrow>\n           y \\<in> fp_cop_F ds\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fp_cop_F ds", "case (step x)"], ["proof (state)\nthis:\n  x \\<in> Field (Pd d)\n  ?y \\<in> aboveS (Pd d) x \\<Longrightarrow> ?y \\<in> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Field (Pd d);\n        \\<And>y.\n           y \\<in> aboveS (Pd d) x \\<Longrightarrow>\n           y \\<in> fp_cop_F ds\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fp_cop_F ds", "with assms Pd_range Pd_Xd cop_F_RH[of d ds _ \"fp_cop_F ds\", unfolded fp_cop_F_unfold[symmetric]]"], ["proof (chain)\npicking this:\n  d \\<in> ds\n  d \\<notin> Xd ` cop ds\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  \\<lbrakk>d \\<in> ds; ?x \\<in> Field (Pd d);\n   aboveS (Pd d) ?x \\<subseteq> Rf CH (fp_cop_F ds)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> fp_cop_F ds\n  x \\<in> Field (Pd d)\n  ?y \\<in> aboveS (Pd d) x \\<Longrightarrow> ?y \\<in> fp_cop_F ds", "show ?case"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  d \\<notin> Xd ` cop ds\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  \\<lbrakk>d \\<in> ds; ?x \\<in> Field (Pd d);\n   aboveS (Pd d) ?x \\<subseteq> Rf CH (fp_cop_F ds)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> fp_cop_F ds\n  x \\<in> Field (Pd d)\n  ?y \\<in> aboveS (Pd d) x \\<Longrightarrow> ?y \\<in> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "unfolding aboveS_def"], ["proof (prove)\nusing this:\n  d \\<in> ds\n  d \\<notin> Xd ` cop ds\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  \\<lbrakk>d \\<in> ds; ?x \\<in> Field (Pd d);\n   {b. b \\<noteq> ?x \\<and> (?x, b) \\<in> Pd d}\n   \\<subseteq> Rf CH (fp_cop_F ds)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> fp_cop_F ds\n  x \\<in> Field (Pd d)\n  ?y \\<in> {b. b \\<noteq> x \\<and> (x, b) \\<in> Pd d} \\<Longrightarrow>\n  ?y \\<in> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "by (fastforce iff: image_iff)"], ["proof (state)\nthis:\n  x \\<in> fp_cop_F ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> fp_cop_F ds\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\n\\citet{AygunSonmez:2012-WP2} observe that any blocking contract must\nbe weakly preferred by its doctor to anything in the outcome of the\n@{const \"fp_cop_F\"}:\n\n\\<close>"], ["", "lemma fp_cop_F_preferred:\n  assumes \"y \\<in> CD_on ds (CH (fp_cop_F ds) \\<union> X'')\"\n  assumes \"x \\<in> CH (fp_cop_F ds)\"\n  assumes \"Xd x = Xd y\"\n  shows \"(x, y) \\<in> Pd (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> Pd (Xd x)", "using %invisible assms fp_cop_F_range_inv'[OF CH_range'[OF assms(2)]] Pd_Xd Pd_linear"], ["proof (prove)\nusing this:\n  y \\<in> CD_on ds (cop ds \\<union> X'')\n  x \\<in> cop ds\n  Xd x = Xd y\n  x \\<in> Field (Pd (Xd x)) \\<and> Xd x \\<in> ds\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  \\<forall>d. Linear_order (Pd d)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> Pd (Xd x)", "by (clarsimp simp: CD_on_def Cd_greatest greatest_def) (metis Int_iff Un_iff subset_refl underS_incl_iff)"], ["", "text\\<open>\n\nThe headline lemma cobbles these results together.\n\n\\<close>"], ["", "lemma X''_closed:\n  assumes \"X'' \\<subseteq> CD_on ds (CH (fp_cop_F ds) \\<union> X'')\"\n  shows \"X'' \\<subseteq> fp_cop_F ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X'' \\<subseteq> fp_cop_F ds", "proof(rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> fp_cop_F ds", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> fp_cop_F ds", "assume \"x \\<in> X''\""], ["proof (state)\nthis:\n  x \\<in> X''\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> fp_cop_F ds", "show \"x \\<in> fp_cop_F ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "proof(cases \"Xd x \\<in> Xd ` CH (fp_cop_F ds)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x \\<in> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds\n 2. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "case True"], ["proof (state)\nthis:\n  Xd x \\<in> Xd ` cop ds\n\ngoal (2 subgoals):\n 1. Xd x \\<in> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds\n 2. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "then"], ["proof (chain)\npicking this:\n  Xd x \\<in> Xd ` cop ds", "obtain y where \"Xd y = Xd x\" and \"y \\<in> CH (fp_cop_F ds)\""], ["proof (prove)\nusing this:\n  Xd x \\<in> Xd ` cop ds\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>Xd y = Xd x; y \\<in> cop ds\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  Xd y = Xd x\n  y \\<in> cop ds\n\ngoal (2 subgoals):\n 1. Xd x \\<in> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds\n 2. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "with assms \\<open>x \\<in> X''\\<close>"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd y = Xd x\n  y \\<in> cop ds", "show ?thesis"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd y = Xd x\n  y \\<in> cop ds\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "using CH_range fp_cop_F_closed_inv' fp_cop_F_preferred"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd y = Xd x\n  y \\<in> cop ds\n  CH ?A \\<subseteq> ?A\n  \\<lbrakk>?x \\<in> fp_cop_F ?ds; ?c \\<in> above (Pd (Xd ?x)) ?x\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> fp_cop_F ?ds\n  \\<lbrakk>?y \\<in> CD_on ?ds (cop ?ds \\<union> ?X''); ?x \\<in> cop ?ds;\n   Xd ?x = Xd ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> Pd (Xd ?x)\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "unfolding above_def"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd y = Xd x\n  y \\<in> cop ds\n  CH ?A \\<subseteq> ?A\n  \\<lbrakk>?x \\<in> fp_cop_F ?ds;\n   ?c \\<in> {b. (?x, b) \\<in> Pd (Xd ?x)}\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> fp_cop_F ?ds\n  \\<lbrakk>?y \\<in> CD_on ?ds (cop ?ds \\<union> ?X''); ?x \\<in> cop ?ds;\n   Xd ?x = Xd ?y\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> Pd (Xd ?x)\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "by blast"], ["proof (state)\nthis:\n  x \\<in> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "case False"], ["proof (state)\nthis:\n  Xd x \\<notin> Xd ` cop ds\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` cop ds \\<Longrightarrow> x \\<in> fp_cop_F ds", "with assms \\<open>x \\<in> X''\\<close>"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd x \\<notin> Xd ` cop ds", "show ?thesis"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n  x \\<in> X''\n  Xd x \\<notin> Xd ` cop ds\n\ngoal (1 subgoal):\n 1. x \\<in> fp_cop_F ds", "by (meson Cd_range' IntD2 fp_cop_F_all mem_CD_on_Cd rev_subsetD)"], ["proof (state)\nthis:\n  x \\<in> fp_cop_F ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> fp_cop_F ds\n\ngoal:\nNo subgoals!", "qed"], ["", "text (in Contracts) \\<open>\n\nThe @{const \"irc\"} constraint on the auctioneer's preferences is\nneeded for @{const \"stable_no_blocking\"} and their part of @{const\n\"individually_rational\"}.\n\n\\<close>"], ["", "end"], ["", "context ContractsWithIRC\nbegin"], ["", "lemma cop_stable_no_blocking_on:\n  shows \"stable_no_blocking_on ds (cop ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds (cop ds)", "proof(rule stable_no_blocking_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "fix h X''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume C: \"X'' = Ch h (CH (fp_cop_F ds) \\<union> X'')\""], ["proof (state)\nthis:\n  X'' = Ch h (cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume NE: \"X'' \\<noteq> Ch h (CH (fp_cop_F ds))\""], ["proof (state)\nthis:\n  X'' \\<noteq> Ch h (cop ds)\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "assume CD: \"X'' \\<subseteq> CD_on ds (CH (fp_cop_F ds) \\<union> X'')\""], ["proof (state)\nthis:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "from CD"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')", "have \"X'' \\<subseteq> fp_cop_F ds\""], ["proof (prove)\nusing this:\n  X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. X'' \\<subseteq> fp_cop_F ds", "by (rule X''_closed)"], ["proof (state)\nthis:\n  X'' \\<subseteq> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  X'' \\<subseteq> fp_cop_F ds", "have X: \"CH (fp_cop_F ds) \\<union> X'' \\<subseteq> fp_cop_F ds\""], ["proof (prove)\nusing this:\n  X'' \\<subseteq> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. cop ds \\<union> X'' \\<subseteq> fp_cop_F ds", "using CH_range"], ["proof (prove)\nusing this:\n  X'' \\<subseteq> fp_cop_F ds\n  CH ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. cop ds \\<union> X'' \\<subseteq> fp_cop_F ds", "by simp"], ["proof (state)\nthis:\n  cop ds \\<union> X'' \\<subseteq> fp_cop_F ds\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       \\<lbrakk>X'' = Ch h (cop ds \\<union> X'');\n        X'' \\<noteq> Ch h (cop ds);\n        X'' \\<subseteq> CD_on ds (cop ds \\<union> X'')\\<rbrakk>\n       \\<Longrightarrow> False", "from C NE Ch_CH_irc_idem[of h]"], ["proof (chain)\npicking this:\n  X'' = Ch h (cop ds \\<union> X'')\n  X'' \\<noteq> Ch h (cop ds)\n  Ch h (CH ?A) = Ch h ?A", "show False"], ["proof (prove)\nusing this:\n  X'' = Ch h (cop ds \\<union> X'')\n  X'' \\<noteq> Ch h (cop ds)\n  Ch h (CH ?A) = Ch h ?A\n\ngoal (1 subgoal):\n 1. False", "using consistency_onD[OF Ch_consistency _ X] CH_domain Ch_domain"], ["proof (prove)\nusing this:\n  X'' = Ch h (cop ds \\<union> X'')\n  X'' \\<noteq> Ch h (cop ds)\n  Ch h (CH ?A) = Ch h ?A\n  \\<lbrakk>fp_cop_F ds \\<subseteq> UNIV;\n   Ch ?h2 (fp_cop_F ds) \\<subseteq> cop ds \\<union> X''\\<rbrakk>\n  \\<Longrightarrow> Ch ?h2 (fp_cop_F ds) = Ch ?h2 (cop ds \\<union> X'')\n  CH ?A \\<inter> {x. Xh x = ?h} = Ch ?h (?A \\<inter> {x. Xh x = ?h})\n  Ch ?h (?A \\<inter> {x. Xh x = ?h}) = Ch ?h ?A\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Theorem_16:\n  assumes h: \"(UNIV::'c set) = {h}\"\n  shows \"stable_on ds (cop ds)\" (is \"stable_on ds ?fp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_on ds (cop ds)", "proof(rule stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. individually_rational_on ds (cop ds)\n 2. stable_no_blocking_on ds (cop ds)", "show \"individually_rational_on ds ?fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. individually_rational_on ds (cop ds)", "proof(rule individually_rational_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. CD_on ds (cop ds) = cop ds\n 2. CH (cop ds) = cop ds", "from h"], ["proof (chain)\npicking this:\n  UNIV = {h}", "have \"allocation ?fp\""], ["proof (prove)\nusing this:\n  UNIV = {h}\n\ngoal (1 subgoal):\n 1. inj_on Xd (cop ds)", "by (simp add: Ch_singular CH_Ch_singular)"], ["proof (state)\nthis:\n  inj_on Xd (cop ds)\n\ngoal (2 subgoals):\n 1. CD_on ds (cop ds) = cop ds\n 2. CH (cop ds) = cop ds", "then"], ["proof (chain)\npicking this:\n  inj_on Xd (cop ds)", "show \"CD_on ds ?fp = ?fp\""], ["proof (prove)\nusing this:\n  inj_on Xd (cop ds)\n\ngoal (1 subgoal):\n 1. CD_on ds (cop ds) = cop ds", "by (rule CD_on_closed) (blast dest: CH_range' fp_cop_F_range_inv')"], ["proof (state)\nthis:\n  CD_on ds (cop ds) = cop ds\n\ngoal (1 subgoal):\n 1. CH (cop ds) = cop ds", "show \"CH (CH (fp_cop_F ds)) = CH (fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH (cop ds) = cop ds", "by (simp add: CH_irc_idem)"], ["proof (state)\nthis:\n  CH (cop ds) = cop ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  individually_rational_on ds (cop ds)\n\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds (cop ds)", "show \"stable_no_blocking_on ds ?fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stable_no_blocking_on ds (cop ds)", "by (rule cop_stable_no_blocking_on)"], ["proof (state)\nthis:\n  stable_no_blocking_on ds (cop ds)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open> Concluding remarks \\<close>"], ["", "text\\<open>\n\nFrom \\citet{HatfieldMilgrom:2005}, we have not shown Theorems~2, 7, 13\nand~14, all of which are intended to position their results against\nprior work in this space. We delay establishing their strategic\nresults (Theorems~10, 11 and~12) to \\S\\ref{sec:strategic}, after we\nhave developed more useful invariants for the COP.\n\nBy assuming \\isa{irc}, \\citet{AygunSonmez:2012-WP2} are essentially\ntrading on Plott's path independence condition\n(\\S\\ref{sec:cf-path-independence}), as observed by\n\\citet{ChambersYenmez:2013}. The latter show that these results\ngeneralize naturally to many-to-many matches, where doctors also use\npath-independent choice functions; see also \\citet{Fleiner:2003}.\n\nFor many applications, however, @{const \"substitutes\"} proves to be\ntoo strong a condition. The COP of \\S\\ref{sec:contracts-cop} provides\na way forward, as we discuss in the next section.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}