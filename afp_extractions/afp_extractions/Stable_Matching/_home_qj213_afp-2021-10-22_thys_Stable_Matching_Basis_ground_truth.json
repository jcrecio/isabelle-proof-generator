{"file_name": "/home/qj213/afp-2021-10-22/thys/Stable_Matching/Basis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stable_Matching", "problem_names": ["lemma Above_union:\n  shows \"x \\<in> Above r (X \\<union> Y) \\<longleftrightarrow> x \\<in> Above r X \\<and> x \\<in> Above r Y\"", "lemma Above_Field:\n  assumes \"x \\<in> Above r X\"\n  shows \"x \\<in> Field r\"", "lemma AboveS_Field:\n  assumes \"x \\<in> AboveS r X\"\n  shows \"x \\<in> Field r\"", "lemma Above_Linear_singleton:\n  assumes \"x \\<in> Field r\"\n  assumes \"Linear_order r\"\n  shows \"x \\<in> Above r {x}\"", "lemma subseqs_set:\n  assumes \"y \\<in> set (subseqs xs)\"\n  shows \"set y \\<subseteq> set xs\"", "lemmas set_elem_equalityI = Set.equalityI[OF Set.subsetI Set.subsetI]", "lemmas total_onI = iffD2[OF total_on_def, rule_format]", "lemma partial_order_on_acyclic:\n  assumes \"partial_order_on A r\"\n  shows \"acyclic (r - Id)\"", "lemma finite_Linear_order_induct[consumes 3, case_names step]:\n  assumes \"Linear_order r\"\n  assumes \"x \\<in> Field r\"\n  assumes \"finite r\"\n  assumes step: \"\\<And>x. \\<lbrakk>x \\<in> Field r; \\<And>y. y \\<in> aboveS r x \\<Longrightarrow> P y\\<rbrakk> \\<Longrightarrow> P x\"\n  shows \"P x\"", "lemmas mono_onI = iffD2[OF mono_on_def, rule_format]", "lemmas mono_onD = iffD1[OF mono_on_def, rule_format]", "lemma mono_onE:\n  \"\\<lbrakk>mono_on A f; x \\<in> A; y \\<in> A; x \\<le> y; f x \\<le> f y \\<Longrightarrow> thesis\\<rbrakk> \\<Longrightarrow> thesis\"", "lemma mono_on_mono:\n  \"mono_on UNIV = mono\"", "lemma maxR_domain:\n  shows \"{x, y} \\<subseteq> A \\<Longrightarrow> maxR x y \\<in> A\"", "lemma maxR_range:\n  shows \"maxR x y \\<in> {x, y}\"", "lemma maxR_rangeD:\n  \"maxR x y \\<noteq> x \\<Longrightarrow> maxR x y = y\"\n  \"maxR x y \\<noteq> y \\<Longrightarrow> maxR x y = x\"", "lemma maxR_idem:\n  shows \"maxR x x = x\"", "lemma maxR_absorb2:\n  shows \"(x, y) \\<in> r \\<Longrightarrow> maxR x y = y\"", "lemma maxR_absorb1:\n  shows \"(y, x) \\<in> r \\<Longrightarrow> maxR x y = x\"", "lemma maxR_assoc:\n  shows \"{x,y,z} \\<subseteq> Field r \\<Longrightarrow> maxR (maxR x y) z = maxR x (maxR y z)\"", "lemma maxR_commute:\n  shows \"{x,y} \\<subseteq> Field r \\<Longrightarrow> maxR x y = maxR y x\"", "lemmas maxR_simps =\n  maxR_idem\n  maxR_absorb1\n  maxR_absorb2", "lemma empty [simp]:\n  shows \"MaxR_opt {} = None\"", "lemma\n  shows insert: \"MaxR_opt (insert x A) = (if x \\<in> Field r then Some (case MaxR_opt A of None \\<Rightarrow> x | Some y \\<Rightarrow> maxR x y) else MaxR_opt A)\"\n    and range_Some[rule_format]: \"MaxR_opt A = Some a \\<longrightarrow> a \\<in> A \\<inter> Field r\"", "lemma range_None:\n  assumes \"MaxR_opt A = None\"\n  shows \"A \\<inter> Field r = {}\"", "lemma domain_empty:\n  assumes \"A \\<inter> Field r = {}\"\n  shows \"MaxR_opt A = None\"", "lemma domain:\n  shows \"MaxR_opt (A \\<inter> Field r) = MaxR_opt A\"", "lemmas MaxR_opt_code = MaxR_opt_eq_fold'[where A=\"set A\", unfolded MaxR_f.fold_set_fold] for A", "lemma range:\n  shows \"MaxR_opt A \\<in> Some ` (A \\<inter> Field r) \\<union> {None}\"", "lemma union:\n  shows \"MaxR_opt (A \\<union> B) = (case MaxR_opt A of None \\<Rightarrow> MaxR_opt B | Some mA \\<Rightarrow> Some (case MaxR_opt B of None \\<Rightarrow> mA | Some mB \\<Rightarrow> maxR mA mB))\"", "lemma mono:\n  assumes \"MaxR_opt A = Some x\"\n  shows \"\\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r\"", "lemma MaxR_opt_is_greatest:\n  assumes \"MaxR_opt A = Some x\"\n  assumes \"y \\<in> A \\<inter> Field r\"\n  shows \"(y, x) \\<in> r\"", "lemma greatest_is_MaxR_opt:\n  assumes \"x \\<in> A \\<inter> Field r\"\n  assumes \"\\<forall>y \\<in> A \\<inter> Field r. (y, x) \\<in> r\"\n  shows \"MaxR_opt A = Some x\"", "lemma subset:\n  assumes \"set_option (MaxR_opt B) \\<subseteq> A\"\n  assumes \"A \\<subseteq> B\"\n  shows \"MaxR_opt B = MaxR_opt A\"", "lemma MaxR_r_domain [iff]:\n  assumes \"MaxR r\"\n  shows \"MaxR (Restr r A)\"", "lemma linord_of_list_linord_of_listP:\n  shows \"xy \\<in> linord_of_list xs \\<longleftrightarrow> linord_of_listP (fst xy) (snd xy) xs\"", "lemma linord_of_listP_linord_of_list:\n  shows \"linord_of_listP x y xs \\<longleftrightarrow> (x, y) \\<in> linord_of_list xs\"", "lemma linord_of_listP_empty:\n  shows \"(\\<forall>x y. \\<not>linord_of_listP x y xs) \\<longleftrightarrow> xs = []\"", "lemma linord_of_listP_domain:\n  assumes \"linord_of_listP x y xs\"\n  shows \"x \\<in> set xs \\<and> y \\<in> set xs\"", "lemma linord_of_list_empty[iff]:\n  \"linord_of_list [] = {}\"\n  \"linord_of_list xs = {} \\<longleftrightarrow> xs = []\"", "lemma linord_of_list_singleton:\n  \"(x, y) \\<in> linord_of_list [z] \\<longleftrightarrow> x = z \\<and> y = z\"", "lemma linord_of_list_range:\n  \"linord_of_list xs \\<subseteq> set xs \\<times> set xs\"", "lemma linord_of_list_Field [simp]:\n  \"Field (linord_of_list xs) = set xs\"", "lemma linord_of_listP_append:\n  \"linord_of_listP x y (xs @ ys) \\<longleftrightarrow> linord_of_listP x y xs \\<or> linord_of_listP x y ys \\<or> (y \\<in> set xs \\<and> x \\<in> set ys)\"", "lemma linord_of_list_append:\n  \"(x, y) \\<in> linord_of_list (xs @ ys) \\<longleftrightarrow> (x, y) \\<in> linord_of_list xs \\<or> (x, y) \\<in> linord_of_list ys \\<or> (y \\<in> set xs \\<and> x \\<in> set ys)\"", "lemma linord_of_list_refl_on:\n  shows \"refl_on (set xs) (linord_of_list xs)\"", "lemma linord_of_list_trans:\n  assumes \"distinct xs\"\n  shows \"trans (linord_of_list xs)\"", "lemma linord_of_list_antisym:\n  assumes \"distinct xs\"\n  shows \"antisym (linord_of_list xs)\"", "lemma linord_of_list_total_on:\n  shows \"total_on (set xs) (linord_of_list xs)\"", "lemma linord_of_list_Restr:\n  assumes \"x \\<notin> C\"\n  notes in_set_remove1[simp del] (* suppress warning *)\n  shows \"Restr (linord_of_list (remove1 x xs)) C = Restr (linord_of_list xs) C\"", "lemma linord_of_list_nth:\n  assumes \"(xs ! i, xs ! j) \\<in> linord_of_list xs\"\n  assumes \"i < length xs\" \"j < length xs\"\n  assumes \"distinct xs\"\n  shows \"j \\<le> i\"", "lemma linord_of_list_Linear_order:\n  assumes \"distinct xs\"\n  assumes \"ys = set xs\"\n  shows \"linear_order_on ys (linord_of_list xs)\"", "lemma sorted_on_single [iff]:\n  shows \"sorted_on r [x] \\<longleftrightarrow> x \\<in> Field r\"", "lemma sorted_on_many:\n  assumes \"(x, y) \\<in> r\"\n  assumes \"sorted_on r (y # zs)\"\n  shows \"sorted_on r (x # y # zs)\"", "lemma sorted_on_Cons:\n  shows \"sorted_on r (x # xs) \\<longleftrightarrow> (x \\<in> Field r \\<and> sorted_on r xs \\<and> (\\<forall>y\\<in>set xs. (x, y) \\<in> r))\"", "lemma sorted_on_distinct_set_unique:\n  assumes \"sorted_on r xs\" \"distinct xs\" \"sorted_on r ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\"", "lemma set_insort_on:\n  shows \"set (insort_key_on r f x xs) = insert x (set xs)\"", "lemma sort_key_on_simps [simp]:\n  shows \"sort_key_on r f [] = []\"\n        \"sort_key_on r f (x#xs) = insort_key_on r f x (sort_key_on r f xs)\"", "lemma set_sort_on [simp]:\n  shows \"set (sort_key_on r f xs) = set xs\"", "lemma distinct_insort_on:\n  shows \"distinct (insort_key_on r f x xs) = (x \\<notin> set xs \\<and> distinct xs)\"", "lemma distinct_sort_on [simp]:\n  shows \"distinct (sort_key_on r f xs) = distinct xs\"", "lemma sorted_on_insort_key_on:\n  assumes \"f ` set (x # xs) \\<subseteq> Field r\"\n  shows \"sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\"", "lemma sorted_on_insort_on:\n  assumes \"set (x # xs) \\<subseteq> Field r\"\n  shows \"sorted_on r (insort_on r x xs) = sorted_on r xs\"", "theorem sorted_on_sort_key_on [simp]:\n  assumes \"f ` set xs \\<subseteq> Field r\"\n  shows \"sorted_on r (map f (sort_key_on r f xs))\"", "theorem sorted_on_sort_on [simp]:\n  assumes \"set xs \\<subseteq> Field r\"\n  shows \"sorted_on r (sort_on r xs)\"", "lemma finite_sorted_on_distinct_unique:\n  assumes \"A \\<subseteq> Field r\"\n  assumes \"finite A\"\n  shows \"\\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs\"", "lemma sorted_on_linord_of_list_subseteq_r:\n  assumes \"Linear_order r\"\n  assumes \"sorted_on r xs\"\n  assumes \"distinct xs\"\n  shows \"linord_of_list (rev xs) \\<subseteq> r\"", "lemma sorted_on_linord_of_list:\n  assumes \"Linear_order r\"\n  assumes \"set xs = Field r\"\n  assumes \"sorted_on r xs\"\n  assumes \"distinct xs\"\n  shows \"linord_of_list (rev xs) = r\"", "lemma linord_of_listP_rev:\n  assumes \"z # zs \\<in> set (subseqs xs)\"\n  assumes \"y \\<in> set zs\"\n  shows \"linord_of_listP z y (rev xs)\"", "lemma linord_of_list_sorted_on_subseqs:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  assumes \"distinct xs\"\n  shows \"sorted_on (linord_of_list (rev xs)) ys\"", "lemma linord_of_list_sorted_on:\n  assumes \"distinct xs\"\n  shows \"sorted_on (linord_of_list (rev xs)) xs\"", "lemma linear_order_on_list:\n  assumes \"linear_order_on ys r\"\n  assumes \"ys = Field r\"\n  assumes \"finite ys\"\n  shows \"\\<exists>!xs. r = linord_of_list xs \\<and> distinct xs \\<and> set xs = ys\""], "translations": [["", "lemma Above_union:\n  shows \"x \\<in> Above r (X \\<union> Y) \\<longleftrightarrow> x \\<in> Above r X \\<and> x \\<in> Above r Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> Above r (X \\<union> Y)) =\n    (x \\<in> Above r X \\<and> x \\<in> Above r Y)", "unfolding Above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {b \\<in> Field r.\n              \\<forall>a\\<in>X \\<union> Y. (a, b) \\<in> r}) =\n    (x \\<in> {b \\<in> Field r. \\<forall>a\\<in>X. (a, b) \\<in> r} \\<and>\n     x \\<in> {b \\<in> Field r. \\<forall>a\\<in>Y. (a, b) \\<in> r})", "by blast"], ["", "lemma Above_Field:\n  assumes \"x \\<in> Above r X\"\n  shows \"x \\<in> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Above r X\n\ngoal (1 subgoal):\n 1. x \\<in> Field r", "unfolding Above_def"], ["proof (prove)\nusing this:\n  x \\<in> {b \\<in> Field r. \\<forall>a\\<in>X. (a, b) \\<in> r}\n\ngoal (1 subgoal):\n 1. x \\<in> Field r", "by blast"], ["", "lemma AboveS_Field:\n  assumes \"x \\<in> AboveS r X\"\n  shows \"x \\<in> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field r", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> AboveS r X\n\ngoal (1 subgoal):\n 1. x \\<in> Field r", "unfolding AboveS_def"], ["proof (prove)\nusing this:\n  x \\<in> {b \\<in> Field r.\n           \\<forall>a\\<in>X. b \\<noteq> a \\<and> (a, b) \\<in> r}\n\ngoal (1 subgoal):\n 1. x \\<in> Field r", "by blast"], ["", "lemma Above_Linear_singleton:\n  assumes \"x \\<in> Field r\"\n  assumes \"Linear_order r\"\n  shows \"x \\<in> Above r {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Above r {x}", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Field r\n  Linear_order r\n\ngoal (1 subgoal):\n 1. x \\<in> Above r {x}", "unfolding Above_def order_on_defs"], ["proof (prove)\nusing this:\n  x \\<in> Field r\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and> Total r\n\ngoal (1 subgoal):\n 1. x \\<in> {b \\<in> Field r. \\<forall>a\\<in>{x}. (a, b) \\<in> r}", "by (force dest: refl_onD)"], ["", "lemma subseqs_set:\n  assumes \"y \\<in> set (subseqs xs)\"\n  shows \"set y \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set y \\<subseteq> set xs", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set (subseqs xs)\n\ngoal (1 subgoal):\n 1. set y \\<subseteq> set xs", "by (metis Pow_iff image_eqI subseqs_powset)"], ["", "primrec map_of_default :: \"'v \\<Rightarrow> ('k \\<times> 'v) list \\<Rightarrow> 'k \\<Rightarrow> 'v\" where\n  \"map_of_default v0 [] k = v0\"\n| \"map_of_default v0 (kv # kvs) k = (if k = fst kv then snd kv else map_of_default v0 kvs k)\""], ["", "lemmas set_elem_equalityI = Set.equalityI[OF Set.subsetI Set.subsetI]"], ["", "lemmas total_onI = iffD2[OF total_on_def, rule_format]"], ["", "lemma partial_order_on_acyclic:\n  assumes \"partial_order_on A r\"\n  shows \"acyclic (r - Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (r - Id)", "by (metis acyclic_irrefl assms irrefl_diff_Id partial_order_on_def preorder_on_def trancl_id trans_diff_Id)"], ["", "lemma finite_Linear_order_induct[consumes 3, case_names step]:\n  assumes \"Linear_order r\"\n  assumes \"x \\<in> Field r\"\n  assumes \"finite r\"\n  assumes step: \"\\<And>x. \\<lbrakk>x \\<in> Field r; \\<And>y. y \\<in> aboveS r x \\<Longrightarrow> P y\\<rbrakk> \\<Longrightarrow> P x\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "using assms(2)"], ["proof (prove)\nusing this:\n  x \\<in> Field r\n\ngoal (1 subgoal):\n 1. P x", "proof(induct rule: wf_induct[of \"r\\<inverse> - Id\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (r\\<inverse> - Id)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n                   y \\<in> Field r \\<longrightarrow> P y;\n        x \\<in> Field r\\<rbrakk>\n       \\<Longrightarrow> P x", "from assms(1,3)"], ["proof (chain)\npicking this:\n  Linear_order r\n  finite r", "show \"wf (r\\<inverse> - Id)\""], ["proof (prove)\nusing this:\n  Linear_order r\n  finite r\n\ngoal (1 subgoal):\n 1. wf (r\\<inverse> - Id)", "using linear_order_on_well_order_on linear_order_on_converse"], ["proof (prove)\nusing this:\n  Linear_order r\n  finite r\n  finite ?r \\<Longrightarrow> linear_order_on ?A ?r = well_order_on ?A ?r\n  linear_order_on ?A (?r\\<inverse>) = linear_order_on ?A ?r\n\ngoal (1 subgoal):\n 1. wf (r\\<inverse> - Id)", "unfolding well_order_on_def"], ["proof (prove)\nusing this:\n  Linear_order r\n  finite r\n  finite ?r \\<Longrightarrow>\n  linear_order_on ?A ?r = (linear_order_on ?A ?r \\<and> wf (?r - Id))\n  linear_order_on ?A (?r\\<inverse>) = linear_order_on ?A ?r\n\ngoal (1 subgoal):\n 1. wf (r\\<inverse> - Id)", "by blast"], ["proof (state)\nthis:\n  wf (r\\<inverse> - Id)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n                   y \\<in> Field r \\<longrightarrow> P y;\n        x \\<in> Field r\\<rbrakk>\n       \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n                   y \\<in> Field r \\<longrightarrow> P y;\n        x \\<in> Field r\\<rbrakk>\n       \\<Longrightarrow> P x", "case (2 x)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n     y \\<in> Field r \\<longrightarrow> P y\n  x \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n                   y \\<in> Field r \\<longrightarrow> P y;\n        x \\<in> Field r\\<rbrakk>\n       \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n     y \\<in> Field r \\<longrightarrow> P y\n  x \\<in> Field r", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, x) \\<in> r\\<inverse> - Id \\<longrightarrow>\n     y \\<in> Field r \\<longrightarrow> P y\n  x \\<in> Field r\n\ngoal (1 subgoal):\n 1. P x", "by - (rule step; auto simp: aboveS_def intro: FieldI2)"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nWe sometimes want a notion of monotonicity over some set.\n\n\\<close>"], ["", "definition mono_on :: \"'a::order set \\<Rightarrow> ('a \\<Rightarrow> 'b::order) \\<Rightarrow> bool\" where\n  \"mono_on A f = (\\<forall>x\\<in>A. \\<forall>y\\<in>A. x \\<le> y \\<longrightarrow> f x \\<le> f y)\""], ["", "lemmas mono_onI = iffD2[OF mono_on_def, rule_format]"], ["", "lemmas mono_onD = iffD1[OF mono_on_def, rule_format]"], ["", "lemma mono_onE:\n  \"\\<lbrakk>mono_on A f; x \\<in> A; y \\<in> A; x \\<le> y; f x \\<le> f y \\<Longrightarrow> thesis\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Basis.mono_on A f; x \\<in> A; y \\<in> A; x \\<le> y;\n     f x \\<le> f y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using mono_onD"], ["proof (prove)\nusing this:\n  \\<lbrakk>Basis.mono_on ?A ?f; ?x \\<in> ?A; ?y \\<in> ?A;\n   ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?f ?x \\<le> ?f ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Basis.mono_on A f; x \\<in> A; y \\<in> A; x \\<le> y;\n     f x \\<le> f y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma mono_on_mono:\n  \"mono_on UNIV = mono\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis.mono_on UNIV = mono", "by (clarsimp simp: mono_on_def mono_def fun_eq_iff)"], ["", "(*>*)"], ["", "subsection\\<open> MaxR: maximum elements of linear orders \\<close>"], ["", "text\\<open>\n\nWe generalize the existing @{const \"max\"} and @{const \"Max\"} functions\nto work on orders defined over sets. See \\S\\ref{sec:cf-linear} for\nchoice-function related lemmas.\n\n\\<close>"], ["", "locale MaxR =\n  fixes r :: \"'a::finite rel\"\n  assumes r_Linear_order: \"Linear_order r\"\nbegin"], ["", "text\\<open>\n\nThe basic function chooses the largest of two elements:\n\n\\<close>"], ["", "definition maxR :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"maxR x y = (if (x, y) \\<in> r then y else x)\""], ["", "(*<*)"], ["", "lemma maxR_domain:\n  shows \"{x, y} \\<subseteq> A \\<Longrightarrow> maxR x y \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> A \\<Longrightarrow> maxR x y \\<in> A", "unfolding maxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> A \\<Longrightarrow>\n    (if (x, y) \\<in> r then y else x) \\<in> A", "by simp"], ["", "lemma maxR_range:\n  shows \"maxR x y \\<in> {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxR x y \\<in> {x, y}", "unfolding maxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (x, y) \\<in> r then y else x) \\<in> {x, y}", "by simp"], ["", "lemma maxR_rangeD:\n  \"maxR x y \\<noteq> x \\<Longrightarrow> maxR x y = y\"\n  \"maxR x y \\<noteq> y \\<Longrightarrow> maxR x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (maxR x y \\<noteq> x \\<Longrightarrow> maxR x y = y) &&&\n    (maxR x y \\<noteq> y \\<Longrightarrow> maxR x y = x)", "unfolding maxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if (x, y) \\<in> r then y else x) \\<noteq> x \\<Longrightarrow>\n     (if (x, y) \\<in> r then y else x) = y) &&&\n    ((if (x, y) \\<in> r then y else x) \\<noteq> y \\<Longrightarrow>\n     (if (x, y) \\<in> r then y else x) = x)", "by auto"], ["", "lemma maxR_idem:\n  shows \"maxR x x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maxR x x = x", "unfolding maxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (x, x) \\<in> r then x else x) = x", "by simp"], ["", "lemma maxR_absorb2:\n  shows \"(x, y) \\<in> r \\<Longrightarrow> maxR x y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow> maxR x y = y", "unfolding maxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r \\<Longrightarrow> (if (x, y) \\<in> r then y else x) = y", "by simp"], ["", "lemma maxR_absorb1:\n  shows \"(y, x) \\<in> r \\<Longrightarrow> maxR x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> maxR x y = x", "using r_Linear_order"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> maxR x y = x", "unfolding maxR_def"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> (if (x, y) \\<in> r then y else x) = x", "by (simp add: order_on_defs antisym_def)"], ["", "lemma maxR_assoc:\n  shows \"{x,y,z} \\<subseteq> Field r \\<Longrightarrow> maxR (maxR x y) z = maxR x (maxR y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y, z} \\<subseteq> Field r \\<Longrightarrow>\n    maxR (maxR x y) z = maxR x (maxR y z)", "using r_Linear_order"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. {x, y, z} \\<subseteq> Field r \\<Longrightarrow>\n    maxR (maxR x y) z = maxR x (maxR y z)", "unfolding maxR_def"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. {x, y, z} \\<subseteq> Field r \\<Longrightarrow>\n    (if (if (x, y) \\<in> r then y else x, z) \\<in> r then z\n     else if (x, y) \\<in> r then y else x) =\n    (if (x, if (y, z) \\<in> r then z else y) \\<in> r\n     then if (y, z) \\<in> r then z else y else x)", "by simp (metis order_on_defs(1-3) total_on_def trans_def)"], ["", "lemma maxR_commute:\n  shows \"{x,y} \\<subseteq> Field r \\<Longrightarrow> maxR x y = maxR y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> Field r \\<Longrightarrow> maxR x y = maxR y x", "using r_Linear_order"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> Field r \\<Longrightarrow> maxR x y = maxR y x", "unfolding maxR_def"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. {x, y} \\<subseteq> Field r \\<Longrightarrow>\n    (if (x, y) \\<in> r then y else x) = (if (y, x) \\<in> r then x else y)", "by (fastforce simp: order_on_defs antisym_def total_on_def)"], ["", "lemmas maxR_simps =\n  maxR_idem\n  maxR_absorb1\n  maxR_absorb2"], ["", "(*>*)"], ["", "text\\<open>\n\nWe hoist this to finite sets using the @{const \"Finite_Set.fold\"}\ncombinator. For code generation purposes it seems inevitable that we\nneed to fuse the fold and filter into a single total recursive\ndefinition.\n\n\\<close>"], ["", "definition MaxR_f :: \"'a \\<Rightarrow> 'a option \\<Rightarrow> 'a option\" where\n  \"MaxR_f x acc = (if x \\<in> Field r then Some (case acc of None \\<Rightarrow> x | Some y \\<Rightarrow> maxR x y) else acc)\""], ["", "interpretation MaxR_f: comp_fun_idem MaxR_f"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem MaxR_f", "using %invisible r_Linear_order"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. comp_fun_idem MaxR_f", "by unfold_locales (fastforce simp: fun_eq_iff maxR_def MaxR_f_def order_on_defs total_on_def antisymD elim: transE split: option.splits)+"], ["", "definition MaxR_opt :: \"'a set \\<Rightarrow> 'a option\" where\n  MaxR_opt_eq_fold': \"MaxR_opt A = Finite_Set.fold MaxR_f None A\""], ["", "(*<*)"], ["", "lemma empty [simp]:\n  shows \"MaxR_opt {} = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt {} = None", "by (simp add: MaxR_opt_eq_fold')"], ["", "lemma\n  shows insert: \"MaxR_opt (insert x A) = (if x \\<in> Field r then Some (case MaxR_opt A of None \\<Rightarrow> x | Some y \\<Rightarrow> maxR x y) else MaxR_opt A)\"\n    and range_Some[rule_format]: \"MaxR_opt A = Some a \\<longrightarrow> a \\<in> A \\<inter> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt (insert x A) =\n    (if x \\<in> Field r\n     then Some\n           (case MaxR_opt A of None \\<Rightarrow> x\n            | Some y \\<Rightarrow> maxR x y)\n     else MaxR_opt A) &&&\n    MaxR_opt A = Some a \\<longrightarrow> a \\<in> A \\<inter> Field r", "using finite[of A]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. MaxR_opt (insert x A) =\n    (if x \\<in> Field r\n     then Some\n           (case MaxR_opt A of None \\<Rightarrow> x\n            | Some y \\<Rightarrow> maxR x y)\n     else MaxR_opt A) &&&\n    MaxR_opt A = Some a \\<longrightarrow> a \\<in> A \\<inter> Field r", "by induct (auto simp: MaxR_opt_eq_fold' maxR_def MaxR_f_def split: option.splits)"], ["", "lemma range_None:\n  assumes \"MaxR_opt A = None\"\n  shows \"A \\<inter> Field r = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> Field r = {}", "using assms"], ["proof (prove)\nusing this:\n  MaxR_opt A = None\n\ngoal (1 subgoal):\n 1. A \\<inter> Field r = {}", "by (metis Int_iff insert all_not_in_conv insert_absorb option.simps(3))"], ["", "lemma domain_empty:\n  assumes \"A \\<inter> Field r = {}\"\n  shows \"MaxR_opt A = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt A = None", "using assms"], ["proof (prove)\nusing this:\n  A \\<inter> Field r = {}\n\ngoal (1 subgoal):\n 1. MaxR_opt A = None", "by (metis empty_iff option.exhaust range_Some)"], ["", "lemma domain:\n  shows \"MaxR_opt (A \\<inter> Field r) = MaxR_opt A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt (A \\<inter> Field r) = MaxR_opt A", "using finite[of A]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. MaxR_opt (A \\<inter> Field r) = MaxR_opt A", "by induct (simp_all add: insert)"], ["", "lemmas MaxR_opt_code = MaxR_opt_eq_fold'[where A=\"set A\", unfolded MaxR_f.fold_set_fold] for A"], ["", "lemma range:\n  shows \"MaxR_opt A \\<in> Some ` (A \\<inter> Field r) \\<union> {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt A \\<in> Some ` (A \\<inter> Field r) \\<union> {None}", "using range_Some notin_range_Some"], ["proof (prove)\nusing this:\n  MaxR_opt ?A = Some ?a \\<Longrightarrow> ?a \\<in> ?A \\<inter> Field r\n  (?x \\<notin> range Some) = (?x = None)\n\ngoal (1 subgoal):\n 1. MaxR_opt A \\<in> Some ` (A \\<inter> Field r) \\<union> {None}", "by fastforce"], ["", "lemma union:\n  shows \"MaxR_opt (A \\<union> B) = (case MaxR_opt A of None \\<Rightarrow> MaxR_opt B | Some mA \\<Rightarrow> Some (case MaxR_opt B of None \\<Rightarrow> mA | Some mB \\<Rightarrow> maxR mA mB))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt (A \\<union> B) =\n    (case MaxR_opt A of None \\<Rightarrow> MaxR_opt B\n     | Some mA \\<Rightarrow>\n         Some\n          (case MaxR_opt B of None \\<Rightarrow> mA\n           | Some mB \\<Rightarrow> maxR mA mB))", "using finite[of A]"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. MaxR_opt (A \\<union> B) =\n    (case MaxR_opt A of None \\<Rightarrow> MaxR_opt B\n     | Some mA \\<Rightarrow>\n         Some\n          (case MaxR_opt B of None \\<Rightarrow> mA\n           | Some mB \\<Rightarrow> maxR mA mB))", "by induct (auto simp: maxR_assoc insert dest!: range_Some split: option.splits)"], ["", "lemma mono:\n  assumes \"MaxR_opt A = Some x\"\n  shows \"\\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r", "using finite[of B]"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y. MaxR_opt (A \\<union> {}) = Some y \\<and> (x, y) \\<in> r\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>y. MaxR_opt (A \\<union> {}) = Some y \\<and> (x, y) \\<in> r\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "with assms"], ["proof (chain)\npicking this:\n  MaxR_opt A = Some x", "show ?case"], ["proof (prove)\nusing this:\n  MaxR_opt A = Some x\n\ngoal (1 subgoal):\n 1. \\<exists>y. MaxR_opt (A \\<union> {}) = Some y \\<and> (x, y) \\<in> r", "using range_Some underS_incl_iff[OF r_Linear_order]"], ["proof (prove)\nusing this:\n  MaxR_opt A = Some x\n  MaxR_opt ?A = Some ?a \\<Longrightarrow> ?a \\<in> ?A \\<inter> Field r\n  \\<lbrakk>?a \\<in> Field r; ?b \\<in> Field r\\<rbrakk>\n  \\<Longrightarrow> (underS r ?a \\<subseteq> underS r ?b) =\n                    ((?a, ?b) \\<in> r)\n\ngoal (1 subgoal):\n 1. \\<exists>y. MaxR_opt (A \\<union> {}) = Some y \\<and> (x, y) \\<in> r", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>y. MaxR_opt (A \\<union> {}) = Some y \\<and> (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "note ins = insert"], ["proof (state)\nthis:\n  MaxR_opt (insert ?x ?A) =\n  (if ?x \\<in> Field r\n   then Some\n         (case MaxR_opt ?A of None \\<Rightarrow> ?x\n          | Some y \\<Rightarrow> maxR ?x y)\n   else MaxR_opt ?A)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "case (insert b B)"], ["proof (state)\nthis:\n  finite B\n  b \\<notin> B\n  \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<exists>y.\n           MaxR_opt (A \\<union> F) = Some y \\<and> (x, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            MaxR_opt (A \\<union> insert xa F) =\n                            Some y \\<and>\n                            (x, y) \\<in> r", "with assms r_Linear_order"], ["proof (chain)\npicking this:\n  MaxR_opt A = Some x\n  Linear_order r\n  finite B\n  b \\<notin> B\n  \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r", "show ?case"], ["proof (prove)\nusing this:\n  MaxR_opt A = Some x\n  Linear_order r\n  finite B\n  b \\<notin> B\n  \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       MaxR_opt (A \\<union> insert b B) = Some y \\<and> (x, y) \\<in> r", "unfolding order_on_defs total_on_def"], ["proof (prove)\nusing this:\n  MaxR_opt A = Some x\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and>\n  (\\<forall>x\\<in>Field r.\n      \\<forall>y\\<in>Field r.\n         x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r)\n  finite B\n  b \\<notin> B\n  \\<exists>y. MaxR_opt (A \\<union> B) = Some y \\<and> (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       MaxR_opt (A \\<union> insert b B) = Some y \\<and> (x, y) \\<in> r", "by (fastforce simp: ins maxR_def elim: transE intro: FieldI1)"], ["proof (state)\nthis:\n  \\<exists>y.\n     MaxR_opt (A \\<union> insert b B) = Some y \\<and> (x, y) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[simproc del: eliminate_false_implies]]"], ["", "lemma MaxR_opt_is_greatest:\n  assumes \"MaxR_opt A = Some x\"\n  assumes \"y \\<in> A \\<inter> Field r\"\n  shows \"(y, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using finite[of A] assms"], ["proof (prove)\nusing this:\n  finite A\n  MaxR_opt A = Some x\n  y \\<in> A \\<inter> Field r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "proof(induct arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>MaxR_opt {} = Some x; y \\<in> {} \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>MaxR_opt F = Some x; y \\<in> F \\<inter> Field r\\<rbrakk>\n           \\<Longrightarrow> (y, x) \\<in> r;\n        MaxR_opt (insert x F) = Some xa;\n        y \\<in> insert x F \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, xa) \\<in> r", "note ins = insert"], ["proof (state)\nthis:\n  MaxR_opt (insert ?x ?A) =\n  (if ?x \\<in> Field r\n   then Some\n         (case MaxR_opt ?A of None \\<Rightarrow> ?x\n          | Some y \\<Rightarrow> maxR ?x y)\n   else MaxR_opt ?A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>MaxR_opt {} = Some x; y \\<in> {} \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>MaxR_opt F = Some x; y \\<in> F \\<inter> Field r\\<rbrakk>\n           \\<Longrightarrow> (y, x) \\<in> r;\n        MaxR_opt (insert x F) = Some xa;\n        y \\<in> insert x F \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, xa) \\<in> r", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>MaxR_opt {} = Some x; y \\<in> {} \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> r\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>MaxR_opt F = Some x; y \\<in> F \\<inter> Field r\\<rbrakk>\n           \\<Longrightarrow> (y, x) \\<in> r;\n        MaxR_opt (insert x F) = Some xa;\n        y \\<in> insert x F \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, xa) \\<in> r", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> (y, x) \\<in> r\n 2. y \\<noteq> x \\<Longrightarrow> (y, x) \\<in> r", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow> (y, x) \\<in> r\n 2. y \\<noteq> x \\<Longrightarrow> (y, x) \\<in> r", "thus \"(y, x) \\<in> r\""], ["proof (prove)\nusing this:\n  y = x\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using r_Linear_order insert"], ["proof (prove)\nusing this:\n  y = x\n  Linear_order r\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by (auto simp: order_on_defs refl_on_def)"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> (y, x) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> (y, x) \\<in> r", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow> (y, x) \\<in> r", "show \"(y, x) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "assume \"(y, x) \\<notin> r\""], ["proof (state)\nthis:\n  (y, x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "from insert"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r", "have \"x \\<in> Field r\" \"y \\<in> Field r\""], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r\n\ngoal (1 subgoal):\n 1. x \\<in> Field r &&& y \\<in> Field r", "by (auto simp: maxR_def ins dest!: range_None range_Some split: if_splits option.splits)"], ["proof (state)\nthis:\n  x \\<in> Field r\n  y \\<in> Field r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "from \\<open>(y, x) \\<notin> r\\<close> and \\<open>y \\<noteq> x\\<close> and insert"], ["proof (chain)\npicking this:\n  (y, x) \\<notin> r\n  y \\<noteq> x\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r", "obtain z where z: \"(x, z) \\<notin> r\" \"(y, z) \\<in> r\" \"z \\<in> Field r\""], ["proof (prove)\nusing this:\n  (y, x) \\<notin> r\n  y \\<noteq> x\n  finite A\n  a \\<notin> A\n  \\<lbrakk>MaxR_opt A = Some ?x; y \\<in> A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (y, ?x) \\<in> r\n  MaxR_opt (insert a A) = Some x\n  y \\<in> insert a A \\<inter> Field r\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(x, z) \\<notin> r; (y, z) \\<in> r; z \\<in> Field r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: maxR_def ins dest!: range_None range_Some split: if_splits option.splits)"], ["proof (state)\nthis:\n  (x, z) \\<notin> r\n  (y, z) \\<in> r\n  z \\<in> Field r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "have \"(x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r", "using r_Linear_order \\<open>(y, x) \\<notin> r\\<close> \\<open>x \\<in> Field r\\<close> \\<open>y \\<in> Field r\\<close> \\<open>y \\<noteq> x\\<close>"], ["proof (prove)\nusing this:\n  Linear_order r\n  (y, x) \\<notin> r\n  x \\<in> Field r\n  y \\<in> Field r\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r", "by (auto simp: order_on_defs total_on_def)"], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "have \"trans r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans r", "using r_Linear_order"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. trans r", "by (auto simp: order_on_defs)"], ["proof (state)\nthis:\n  trans r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "from this and \\<open>(x, y) \\<in> r\\<close> and \\<open>(y, z) \\<in> r\\<close>"], ["proof (chain)\npicking this:\n  trans r\n  (x, y) \\<in> r\n  (y, z) \\<in> r", "have \"(x, z) \\<in> r\""], ["proof (prove)\nusing this:\n  trans r\n  (x, y) \\<in> r\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r", "by (rule transD)"], ["proof (state)\nthis:\n  (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r \\<Longrightarrow> False", "with \\<open>(x, z) \\<notin> r\\<close>"], ["proof (chain)\npicking this:\n  (x, z) \\<notin> r\n  (x, z) \\<in> r", "show False"], ["proof (prove)\nusing this:\n  (x, z) \\<notin> r\n  (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>MaxR_opt {} = Some x; y \\<in> {} \\<inter> Field r\\<rbrakk>\n       \\<Longrightarrow> (y, x) \\<in> r", "qed simp"], ["", "lemma greatest_is_MaxR_opt:\n  assumes \"x \\<in> A \\<inter> Field r\"\n  assumes \"\\<forall>y \\<in> A \\<inter> Field r. (y, x) \\<in> r\"\n  shows \"MaxR_opt A = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt A = Some x", "using finite[of A] assms"], ["proof (prove)\nusing this:\n  finite A\n  x \\<in> A \\<inter> Field r\n  \\<forall>y\\<in>A \\<inter> Field r. (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. MaxR_opt A = Some x", "proof(induct arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {} \\<inter> Field r;\n        \\<forall>y\\<in>{} \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt {} = Some x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>x \\<in> F \\<inter> Field r;\n            \\<forall>y\\<in>F \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n           \\<Longrightarrow> MaxR_opt F = Some x;\n        xa \\<in> insert x F \\<inter> Field r;\n        \\<forall>y\\<in>insert x F \\<inter> Field r. (y, xa) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt (insert x F) = Some xa", "note ins = insert"], ["proof (state)\nthis:\n  MaxR_opt (insert ?x ?A) =\n  (if ?x \\<in> Field r\n   then Some\n         (case MaxR_opt ?A of None \\<Rightarrow> ?x\n          | Some y \\<Rightarrow> maxR ?x y)\n   else MaxR_opt ?A)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {} \\<inter> Field r;\n        \\<forall>y\\<in>{} \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt {} = Some x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>x \\<in> F \\<inter> Field r;\n            \\<forall>y\\<in>F \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n           \\<Longrightarrow> MaxR_opt F = Some x;\n        xa \\<in> insert x F \\<inter> Field r;\n        \\<forall>y\\<in>insert x F \\<inter> Field r. (y, xa) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt (insert x F) = Some xa", "case (insert a A)"], ["proof (state)\nthis:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>?x \\<in> A \\<inter> Field r;\n   \\<forall>y\\<in>A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt A = Some ?x\n  x \\<in> insert a A \\<inter> Field r\n  \\<forall>y\\<in>insert a A \\<inter> Field r. (y, x) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {} \\<inter> Field r;\n        \\<forall>y\\<in>{} \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt {} = Some x\n 2. \\<And>x F xa.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>x.\n           \\<lbrakk>x \\<in> F \\<inter> Field r;\n            \\<forall>y\\<in>F \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n           \\<Longrightarrow> MaxR_opt F = Some x;\n        xa \\<in> insert x F \\<inter> Field r;\n        \\<forall>y\\<in>insert x F \\<inter> Field r. (y, xa) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt (insert x F) = Some xa", "then"], ["proof (chain)\npicking this:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>?x \\<in> A \\<inter> Field r;\n   \\<forall>y\\<in>A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt A = Some ?x\n  x \\<in> insert a A \\<inter> Field r\n  \\<forall>y\\<in>insert a A \\<inter> Field r. (y, x) \\<in> r", "show ?case"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>?x \\<in> A \\<inter> Field r;\n   \\<forall>y\\<in>A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt A = Some ?x\n  x \\<in> insert a A \\<inter> Field r\n  \\<forall>y\\<in>insert a A \\<inter> Field r. (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. MaxR_opt (insert a A) = Some x", "using maxR_absorb1 maxR_absorb2"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> A\n  \\<lbrakk>?x \\<in> A \\<inter> Field r;\n   \\<forall>y\\<in>A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt A = Some ?x\n  x \\<in> insert a A \\<inter> Field r\n  \\<forall>y\\<in>insert a A \\<inter> Field r. (y, x) \\<in> r\n  (?y, ?x) \\<in> r \\<Longrightarrow> maxR ?x ?y = ?x\n  (?x, ?y) \\<in> r \\<Longrightarrow> maxR ?x ?y = ?y\n\ngoal (1 subgoal):\n 1. MaxR_opt (insert a A) = Some x", "by (fastforce simp: maxR_def ins dest: range_None range_Some split: option.splits)"], ["proof (state)\nthis:\n  MaxR_opt (insert a A) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {} \\<inter> Field r;\n        \\<forall>y\\<in>{} \\<inter> Field r. (y, x) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> MaxR_opt {} = Some x", "qed simp"], ["", "lemma subset:\n  assumes \"set_option (MaxR_opt B) \\<subseteq> A\"\n  assumes \"A \\<subseteq> B\"\n  shows \"MaxR_opt B = MaxR_opt A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR_opt B = MaxR_opt A", "using union[where A=A and B=\"B-A\"] range[of \"B - A\"] assms"], ["proof (prove)\nusing this:\n  MaxR_opt (A \\<union> (B - A)) =\n  (case MaxR_opt A of None \\<Rightarrow> MaxR_opt (B - A)\n   | Some mA \\<Rightarrow>\n       Some\n        (case MaxR_opt (B - A) of None \\<Rightarrow> mA\n         | Some mB \\<Rightarrow> maxR mA mB))\n  MaxR_opt (B - A) \\<in> Some ` ((B - A) \\<inter> Field r) \\<union> {None}\n  set_option (MaxR_opt B) \\<subseteq> A\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. MaxR_opt B = MaxR_opt A", "by (auto simp: Un_absorb1 finite_subset maxR_def split: option.splits)"], ["", "(*>*)"], ["", "end"], ["", "interpretation MaxR_empty: MaxR \"{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR {}", "by unfold_locales simp"], ["", "interpretation MaxR_singleton: MaxR \"{(x,x)}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR {(x, x)}", "by unfold_locales simp"], ["", "lemma MaxR_r_domain [iff]:\n  assumes \"MaxR r\"\n  shows \"MaxR (Restr r A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR (Restr r A)", "using assms Linear_order_Restr"], ["proof (prove)\nusing this:\n  MaxR r\n  Linear_order ?r \\<Longrightarrow> Linear_order (Restr ?r ?A)\n\ngoal (1 subgoal):\n 1. MaxR (Restr r A)", "unfolding MaxR_def"], ["proof (prove)\nusing this:\n  Linear_order r\n  Linear_order ?r \\<Longrightarrow> Linear_order (Restr ?r ?A)\n\ngoal (1 subgoal):\n 1. Linear_order (Restr r A)", "by blast"], ["", "subsection\\<open> Linear orders from lists \\<close>"], ["", "text\\<open>\n\nOften the easiest way to specify a concrete linear order is with a\nlist. Here these run from greatest to least.\n\n\\<close>"], ["", "primrec linord_of_listP :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"linord_of_listP x y [] \\<longleftrightarrow> False\"\n| \"linord_of_listP x y (z # zs) \\<longleftrightarrow> (z = y \\<and> x \\<in> set (z # zs)) \\<or> linord_of_listP x y zs\""], ["", "definition linord_of_list :: \"'a list \\<Rightarrow> 'a rel\" where\n  \"linord_of_list xs \\<equiv> {(x, y). linord_of_listP x y xs}\""], ["", "(*<*)"], ["", "lemma linord_of_list_linord_of_listP:\n  shows \"xy \\<in> linord_of_list xs \\<longleftrightarrow> linord_of_listP (fst xy) (snd xy) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xy \\<in> linord_of_list xs) = linord_of_listP (fst xy) (snd xy) xs", "unfolding linord_of_list_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xy \\<in> {p. linord_of_listP (fst p) (snd p) xs}) =\n    linord_of_listP (fst xy) (snd xy) xs", "by simp"], ["", "lemma linord_of_listP_linord_of_list:\n  shows \"linord_of_listP x y xs \\<longleftrightarrow> (x, y) \\<in> linord_of_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_listP x y xs = ((x, y) \\<in> linord_of_list xs)", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_listP x y xs = ((x, y) \\<in> {(x, y). linord_of_listP x y xs})", "by simp"], ["", "lemma linord_of_listP_empty:\n  shows \"(\\<forall>x y. \\<not>linord_of_listP x y xs) \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. \\<not> linord_of_listP x y xs) = (xs = [])", "by (metis linord_of_listP.simps list.exhaust list.set_intros(1))"], ["", "lemma linord_of_listP_domain:\n  assumes \"linord_of_listP x y xs\"\n  shows \"x \\<in> set xs \\<and> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<and> y \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  linord_of_listP x y xs\n\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<and> y \\<in> set xs", "by (induct xs) auto"], ["", "lemma linord_of_list_empty[iff]:\n  \"linord_of_list [] = {}\"\n  \"linord_of_list xs = {} \\<longleftrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_list [] = {} &&& (linord_of_list xs = {}) = (xs = [])", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). linord_of_listP x y []} = {} &&&\n    ({(x, y). linord_of_listP x y xs} = {}) = (xs = [])", "by (simp_all add: linord_of_listP_empty)"], ["", "lemma linord_of_list_singleton:\n  \"(x, y) \\<in> linord_of_list [z] \\<longleftrightarrow> x = z \\<and> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> linord_of_list [z]) = (x = z \\<and> y = z)", "by (force simp: linord_of_list_linord_of_listP)"], ["", "lemma linord_of_list_range:\n  \"linord_of_list xs \\<subseteq> set xs \\<times> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_list xs \\<subseteq> set xs \\<times> set xs", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). linord_of_listP x y xs} \\<subseteq> set xs \\<times> set xs", "by (induct xs) auto"], ["", "lemma linord_of_list_Field [simp]:\n  \"Field (linord_of_list xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (linord_of_list xs) = set xs", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Field {(x, y). linord_of_listP x y xs} = set xs", "by (induct xs) (auto simp: Field_def)"], ["", "lemma linord_of_listP_append:\n  \"linord_of_listP x y (xs @ ys) \\<longleftrightarrow> linord_of_listP x y xs \\<or> linord_of_listP x y ys \\<or> (y \\<in> set xs \\<and> x \\<in> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_listP x y (xs @ ys) =\n    (linord_of_listP x y xs \\<or>\n     linord_of_listP x y ys \\<or> y \\<in> set xs \\<and> x \\<in> set ys)", "by (induct xs) auto"], ["", "lemma linord_of_list_append:\n  \"(x, y) \\<in> linord_of_list (xs @ ys) \\<longleftrightarrow> (x, y) \\<in> linord_of_list xs \\<or> (x, y) \\<in> linord_of_list ys \\<or> (y \\<in> set xs \\<and> x \\<in> set ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> linord_of_list (xs @ ys)) =\n    ((x, y) \\<in> linord_of_list xs \\<or>\n     (x, y) \\<in> linord_of_list ys \\<or>\n     y \\<in> set xs \\<and> x \\<in> set ys)", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> {(x, y). linord_of_listP x y (xs @ ys)}) =\n    ((x, y) \\<in> {(x, y). linord_of_listP x y xs} \\<or>\n     (x, y) \\<in> {(x, y). linord_of_listP x y ys} \\<or>\n     y \\<in> set xs \\<and> x \\<in> set ys)", "by (simp add: linord_of_listP_append)"], ["", "lemma linord_of_list_refl_on:\n  shows \"refl_on (set xs) (linord_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (set xs) (linord_of_list xs)", "unfolding linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (set xs) {(x, y). linord_of_listP x y xs}", "by (induct xs) (auto intro!: refl_onI simp: refl_onD1 refl_onD2 dest: refl_onD subsetD[OF linord_of_list_range])"], ["", "lemma linord_of_list_trans:\n  assumes \"distinct xs\"\n  shows \"trans (linord_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (linord_of_list xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. trans (linord_of_list xs)", "unfolding linord_of_list_def"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. trans {(x, y). linord_of_listP x y xs}", "by (induct xs) (auto intro!: transI dest: linord_of_listP_domain elim: transE)"], ["", "lemma linord_of_list_antisym:\n  assumes \"distinct xs\"\n  shows \"antisym (linord_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisym (linord_of_list xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. antisym (linord_of_list xs)", "unfolding linord_of_list_def"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. antisym {(x, y). linord_of_listP x y xs}", "by (induct xs) (auto intro!: antisymI dest: linord_of_listP_domain simp: antisymD)"], ["", "lemma linord_of_list_total_on:\n  shows \"total_on (set xs) (linord_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on (set xs) (linord_of_list xs)", "unfolding total_on_def linord_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       \\<forall>y\\<in>set xs.\n          x \\<noteq> y \\<longrightarrow>\n          (x, y) \\<in> {(x, y). linord_of_listP x y xs} \\<or>\n          (y, x) \\<in> {(x, y). linord_of_listP x y xs}", "by (induct xs) auto"], ["", "lemma linord_of_list_Restr:\n  assumes \"x \\<notin> C\"\n  notes in_set_remove1[simp del] (* suppress warning *)\n  shows \"Restr (linord_of_list (remove1 x xs)) C = Restr (linord_of_list xs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr (linord_of_list (remove1 x xs)) C = Restr (linord_of_list xs) C", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> C\n\ngoal (1 subgoal):\n 1. Restr (linord_of_list (remove1 x xs)) C = Restr (linord_of_list xs) C", "unfolding linord_of_list_def"], ["proof (prove)\nusing this:\n  x \\<notin> C\n\ngoal (1 subgoal):\n 1. Restr {(xa, y). linord_of_listP xa y (remove1 x xs)} C =\n    Restr {(x, y). linord_of_listP x y xs} C", "by (induct xs) (auto iff: in_set_remove1)"], ["", "lemma linord_of_list_nth:\n  assumes \"(xs ! i, xs ! j) \\<in> linord_of_list xs\"\n  assumes \"i < length xs\" \"j < length xs\"\n  assumes \"distinct xs\"\n  shows \"j \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> i", "using %invisible assms"], ["proof (prove)\nusing this:\n  (xs ! i, xs ! j) \\<in> linord_of_list xs\n  i < length xs\n  j < length xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. j \\<le> i", "proof(induct xs arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>([] ! i, [] ! j) \\<in> linord_of_list []; i < length [];\n        j < length []; distinct []\\<rbrakk>\n       \\<Longrightarrow> j \\<le> i\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>(xs ! i, xs ! j) \\<in> linord_of_list xs;\n                    i < length xs; j < length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> j \\<le> i;\n        ((a # xs) ! i, (a # xs) ! j) \\<in> linord_of_list (a # xs);\n        i < length (a # xs); j < length (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> j \\<le> i", "case (Cons x xs i j)"], ["proof (state)\nthis:\n  \\<lbrakk>(xs ! ?i, xs ! ?j) \\<in> linord_of_list xs; ?i < length xs;\n   ?j < length xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  ((x # xs) ! i, (x # xs) ! j) \\<in> linord_of_list (x # xs)\n  i < length (x # xs)\n  j < length (x # xs)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>([] ! i, [] ! j) \\<in> linord_of_list []; i < length [];\n        j < length []; distinct []\\<rbrakk>\n       \\<Longrightarrow> j \\<le> i\n 2. \\<And>a xs i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>(xs ! i, xs ! j) \\<in> linord_of_list xs;\n                    i < length xs; j < length xs; distinct xs\\<rbrakk>\n                   \\<Longrightarrow> j \\<le> i;\n        ((a # xs) ! i, (a # xs) ! j) \\<in> linord_of_list (a # xs);\n        i < length (a # xs); j < length (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> j \\<le> i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> i", "proof(cases \"i < length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> j \\<le> i\n 2. \\<not> i < length xs \\<Longrightarrow> j \\<le> i", "case True"], ["proof (state)\nthis:\n  i < length xs\n\ngoal (2 subgoals):\n 1. i < length xs \\<Longrightarrow> j \\<le> i\n 2. \\<not> i < length xs \\<Longrightarrow> j \\<le> i", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(xs ! ?i, xs ! ?j) \\<in> linord_of_list xs; ?i < length xs;\n   ?j < length xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  ((x # xs) ! i, (x # xs) ! j) \\<in> linord_of_list (x # xs)\n  i < length (x # xs)\n  j < length (x # xs)\n  distinct (x # xs)\n  i < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(xs ! ?i, xs ! ?j) \\<in> linord_of_list xs; ?i < length xs;\n   ?j < length xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  ((x # xs) ! i, (x # xs) ! j) \\<in> linord_of_list (x # xs)\n  i < length (x # xs)\n  j < length (x # xs)\n  distinct (x # xs)\n  i < length xs\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by (auto simp: linord_of_list_linord_of_listP nth_equal_first_eq less_Suc_eq_0_disj linord_of_listP_domain)"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> j \\<le> i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> j \\<le> i", "case False"], ["proof (state)\nthis:\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. \\<not> i < length xs \\<Longrightarrow> j \\<le> i", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(xs ! ?i, xs ! ?j) \\<in> linord_of_list xs; ?i < length xs;\n   ?j < length xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  ((x # xs) ! i, (x # xs) ! j) \\<in> linord_of_list (x # xs)\n  i < length (x # xs)\n  j < length (x # xs)\n  distinct (x # xs)\n  \\<not> i < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(xs ! ?i, xs ! ?j) \\<in> linord_of_list xs; ?i < length xs;\n   ?j < length xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n  ((x # xs) ! i, (x # xs) ! j) \\<in> linord_of_list (x # xs)\n  i < length (x # xs)\n  j < length (x # xs)\n  distinct (x # xs)\n  \\<not> i < length xs\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by fastforce"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>([] ! i, [] ! j) \\<in> linord_of_list []; i < length [];\n        j < length []; distinct []\\<rbrakk>\n       \\<Longrightarrow> j \\<le> i", "qed simp"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma linord_of_list_Linear_order:\n  assumes \"distinct xs\"\n  assumes \"ys = set xs\"\n  shows \"linear_order_on ys (linord_of_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_order_on ys (linord_of_list xs)", "using %invisible assms linord_of_list_range linord_of_list_refl_on linord_of_list_trans linord_of_list_antisym linord_of_list_total_on"], ["proof (prove)\nusing this:\n  distinct xs\n  ys = set xs\n  linord_of_list ?xs \\<subseteq> set ?xs \\<times> set ?xs\n  refl_on (set ?xs) (linord_of_list ?xs)\n  distinct ?xs \\<Longrightarrow> trans (linord_of_list ?xs)\n  distinct ?xs \\<Longrightarrow> antisym (linord_of_list ?xs)\n  total_on (set ?xs) (linord_of_list ?xs)\n\ngoal (1 subgoal):\n 1. linear_order_on ys (linord_of_list xs)", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  distinct xs\n  ys = set xs\n  linord_of_list ?xs \\<subseteq> set ?xs \\<times> set ?xs\n  refl_on (set ?xs) (linord_of_list ?xs)\n  distinct ?xs \\<Longrightarrow> trans (linord_of_list ?xs)\n  distinct ?xs \\<Longrightarrow> antisym (linord_of_list ?xs)\n  total_on (set ?xs) (linord_of_list ?xs)\n\ngoal (1 subgoal):\n 1. ((refl_on ys (linord_of_list xs) \\<and>\n      trans (linord_of_list xs)) \\<and>\n     antisym (linord_of_list xs)) \\<and>\n    total_on ys (linord_of_list xs)", "by force"], ["", "text\\<open>\n\nEvery finite linear order is generated by a list.\n\n\\<close>"], ["", "(*<*)"], ["", "inductive sorted_on :: \"'a rel \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  Nil [iff]: \"sorted_on r []\"\n| Cons [intro!]: \"\\<lbrakk>x \\<in> Field r; \\<forall>y\\<in>set xs. (x, y) \\<in> r; sorted_on r xs\\<rbrakk> \\<Longrightarrow> sorted_on r (x # xs)\""], ["", "inductive_cases sorted_on_inv[elim!]:\n  \"sorted_on r []\"\n  \"sorted_on r (x # xs)\""], ["", "primrec insort_key_on :: \"'a rel \\<Rightarrow> ('b \\<Rightarrow> 'a) \\<Rightarrow> 'b \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"insort_key_on r f x [] = [x]\"\n| \"insort_key_on r f x (y # ys) =\n    (if (f x, f y) \\<in> r then (x # y # ys) else y # insort_key_on r f x ys)\""], ["", "definition sort_key_on :: \"'a rel \\<Rightarrow> ('b \\<Rightarrow> 'a) \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"sort_key_on r f xs = foldr (insort_key_on r f) xs []\""], ["", "definition insort_insert_key_on :: \"'a rel \\<Rightarrow> ('b \\<Rightarrow> 'a) \\<Rightarrow> 'b \\<Rightarrow> 'b list \\<Rightarrow> 'b list\" where\n  \"insort_insert_key_on r f x xs =\n    (if f x \\<in> f ` set xs then xs else insort_key_on r f x xs)\""], ["", "abbreviation \"sort_on r \\<equiv> sort_key_on r (\\<lambda>x. x)\""], ["", "abbreviation \"insort_on r \\<equiv> insort_key_on r (\\<lambda>x. x)\""], ["", "abbreviation \"insort_insert_on r \\<equiv> insort_insert_key_on r (\\<lambda>x. x)\""], ["", "context\n  fixes r :: \"'a rel\"\n  assumes \"Linear_order r\"\nbegin"], ["", "lemma sorted_on_single [iff]:\n  shows \"sorted_on r [x] \\<longleftrightarrow> x \\<in> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r [x] = (x \\<in> Field r)", "by (metis empty_iff list.distinct(1) list.set(1) nth_Cons_0 sorted_on.simps)"], ["", "lemma sorted_on_many:\n  assumes \"(x, y) \\<in> r\"\n  assumes \"sorted_on r (y # zs)\"\n  shows \"sorted_on r (x # y # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (x # y # zs)", "using assms \\<open>Linear_order r\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  sorted_on r (y # zs)\n  Linear_order r\n\ngoal (1 subgoal):\n 1. sorted_on r (x # y # zs)", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  sorted_on r (y # zs)\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and> Total r\n\ngoal (1 subgoal):\n 1. sorted_on r (x # y # zs)", "by (auto elim: transE intro: FieldI1)"], ["", "lemma sorted_on_Cons:\n  shows \"sorted_on r (x # xs) \\<longleftrightarrow> (x \\<in> Field r \\<and> sorted_on r xs \\<and> (\\<forall>y\\<in>set xs. (x, y) \\<in> r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (x # xs) =\n    (x \\<in> Field r \\<and>\n     sorted_on r xs \\<and> (\\<forall>y\\<in>set xs. (x, y) \\<in> r))", "using \\<open>Linear_order r\\<close>"], ["proof (prove)\nusing this:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. sorted_on r (x # xs) =\n    (x \\<in> Field r \\<and>\n     sorted_on r xs \\<and> (\\<forall>y\\<in>set xs. (x, y) \\<in> r))", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and> Total r\n\ngoal (1 subgoal):\n 1. sorted_on r (x # xs) =\n    (x \\<in> Field r \\<and>\n     sorted_on r xs \\<and> (\\<forall>y\\<in>set xs. (x, y) \\<in> r))", "by (induct xs arbitrary: x) (auto elim: transE)"], ["", "lemma sorted_on_distinct_set_unique:\n  assumes \"sorted_on r xs\" \"distinct xs\" \"sorted_on r ys\" \"distinct ys\" \"set xs = set ys\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys", "from assms"], ["proof (chain)\npicking this:\n  sorted_on r xs\n  distinct xs\n  sorted_on r ys\n  distinct ys\n  set xs = set ys", "have 1: \"length xs = length ys\""], ["proof (prove)\nusing this:\n  sorted_on r xs\n  distinct xs\n  sorted_on r ys\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (auto dest!: distinct_card)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. xs = ys", "from assms"], ["proof (chain)\npicking this:\n  sorted_on r xs\n  distinct xs\n  sorted_on r ys\n  distinct ys\n  set xs = set ys", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_on r xs\n  distinct xs\n  sorted_on r ys\n  distinct ys\n  set xs = set ys\n\ngoal (1 subgoal):\n 1. xs = ys", "proof(induct rule: list_induct2[OF 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_on r []; distinct []; sorted_on r []; distinct [];\n     set [] = set []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n         set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_on r (x # xs); distinct (x # xs); sorted_on r (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (2 x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n   set xs = set ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  sorted_on r (y # ys)\n  distinct (y # ys)\n  set (x # xs) = set (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_on r []; distinct []; sorted_on r []; distinct [];\n     set [] = set []\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n         set xs = set ys\\<rbrakk>\n        \\<Longrightarrow> xs = ys;\n        sorted_on r (x # xs); distinct (x # xs); sorted_on r (y # ys);\n        distinct (y # ys); set (x # xs) = set (y # ys)\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "with \\<open>Linear_order r\\<close>"], ["proof (chain)\npicking this:\n  Linear_order r\n  length xs = length ys\n  \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n   set xs = set ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  sorted_on r (y # ys)\n  distinct (y # ys)\n  set (x # xs) = set (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  Linear_order r\n  length xs = length ys\n  \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n   set xs = set ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  sorted_on r (y # ys)\n  distinct (y # ys)\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and> Total r\n  length xs = length ys\n  \\<lbrakk>sorted_on r xs; distinct xs; sorted_on r ys; distinct ys;\n   set xs = set ys\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  sorted_on r (y # ys)\n  distinct (y # ys)\n  set (x # xs) = set (y # ys)\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by (simp add: sorted_on_Cons) (metis antisymD insertI1 insert_eq_iff)"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_on r []; distinct []; sorted_on r []; distinct [];\n     set [] = set []\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_insort_on:\n  shows \"set (insort_key_on r f x xs) = insert x (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insort_key_on r f x xs) = insert x (set xs)", "by (induct xs) auto"], ["", "lemma sort_key_on_simps [simp]:\n  shows \"sort_key_on r f [] = []\"\n        \"sort_key_on r f (x#xs) = insort_key_on r f x (sort_key_on r f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_key_on r f [] = [] &&&\n    sort_key_on r f (x # xs) = insort_key_on r f x (sort_key_on r f xs)", "by (simp_all add: sort_key_on_def)"], ["", "lemma set_sort_on [simp]:\n  shows \"set (sort_key_on r f xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sort_key_on r f xs) = set xs", "by (induct xs) (simp_all add: set_insort_on)"], ["", "lemma distinct_insort_on:\n  shows \"distinct (insort_key_on r f x xs) = (x \\<notin> set xs \\<and> distinct xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insort_key_on r f x xs) =\n    (x \\<notin> set xs \\<and> distinct xs)", "by(induct xs) (auto simp: set_insort_on)"], ["", "lemma distinct_sort_on [simp]:\n  shows \"distinct (sort_key_on r f xs) = distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (sort_key_on r f xs) = distinct xs", "by (induct xs) (simp_all add: distinct_insort_on)"], ["", "lemma sorted_on_insort_key_on:\n  assumes \"f ` set (x # xs) \\<subseteq> Field r\"\n  shows \"sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)", "using assms"], ["proof (prove)\nusing this:\n  f ` set (x # xs) \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. f ` set [x] \\<subseteq> Field r \\<Longrightarrow>\n    sorted_on r (map f (insort_key_on r f x [])) = sorted_on r (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n                sorted_on r (map f (insort_key_on r f x xs)) =\n                sorted_on r (map f xs);\n        f ` set (x # a # xs) \\<subseteq> Field r\\<rbrakk>\n       \\<Longrightarrow> sorted_on r\n                          (map f (insort_key_on r f x (a # xs))) =\n                         sorted_on r (map f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\n  f ` set (x # x # xs) \\<subseteq> Field r\n\ngoal (2 subgoals):\n 1. f ` set [x] \\<subseteq> Field r \\<Longrightarrow>\n    sorted_on r (map f (insort_key_on r f x [])) = sorted_on r (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n                sorted_on r (map f (insort_key_on r f x xs)) =\n                sorted_on r (map f xs);\n        f ` set (x # a # xs) \\<subseteq> Field r\\<rbrakk>\n       \\<Longrightarrow> sorted_on r\n                          (map f (insort_key_on r f x (a # xs))) =\n                         sorted_on r (map f (a # xs))", "with \\<open>Linear_order r\\<close>"], ["proof (chain)\npicking this:\n  Linear_order r\n  f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\n  f ` set (x # x # xs) \\<subseteq> Field r", "show ?case"], ["proof (prove)\nusing this:\n  Linear_order r\n  f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\n  f ` set (x # x # xs) \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (map f (insort_key_on r f x (x # xs))) =\n    sorted_on r (map f (x # xs))", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl r \\<and> trans r) \\<and> antisym r) \\<and> Total r\n  f ` set (x # xs) \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map f (insort_key_on r f x xs)) = sorted_on r (map f xs)\n  f ` set (x # x # xs) \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (map f (insort_key_on r f x (x # xs))) =\n    sorted_on r (map f (x # xs))", "by (auto 4 4 simp: sorted_on_Cons sorted_on_many set_insort_on refl_on_def total_on_def elim: transE)"], ["proof (state)\nthis:\n  sorted_on r (map f (insort_key_on r f x (x # xs))) =\n  sorted_on r (map f (x # xs))\n\ngoal (1 subgoal):\n 1. f ` set [x] \\<subseteq> Field r \\<Longrightarrow>\n    sorted_on r (map f (insort_key_on r f x [])) = sorted_on r (map f [])", "qed simp"], ["", "lemma sorted_on_insort_on:\n  assumes \"set (x # xs) \\<subseteq> Field r\"\n  shows \"sorted_on r (insort_on r x xs) = sorted_on r xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (insort_on r x xs) = sorted_on r xs", "using sorted_on_insort_key_on[where f=\"\\<lambda>x. x\"] assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x) ` set (?x # ?xs) \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map (\\<lambda>x. x) (insort_on r ?x ?xs)) =\n  sorted_on r (map (\\<lambda>x. x) ?xs)\n  set (x # xs) \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (insort_on r x xs) = sorted_on r xs", "by simp"], ["", "theorem sorted_on_sort_key_on [simp]:\n  assumes \"f ` set xs \\<subseteq> Field r\"\n  shows \"sorted_on r (map f (sort_key_on r f xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (map f (sort_key_on r f xs))", "using assms"], ["proof (prove)\nusing this:\n  f ` set xs \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (map f (sort_key_on r f xs))", "by (induct xs) (simp_all add: sorted_on_insort_key_on)"], ["", "theorem sorted_on_sort_on [simp]:\n  assumes \"set xs \\<subseteq> Field r\"\n  shows \"sorted_on r (sort_on r xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on r (sort_on r xs)", "using sorted_on_sort_key_on[where f=\"\\<lambda>x. x\"] assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x) ` set ?xs \\<subseteq> Field r \\<Longrightarrow>\n  sorted_on r (map (\\<lambda>x. x) (sort_on r ?xs))\n  set xs \\<subseteq> Field r\n\ngoal (1 subgoal):\n 1. sorted_on r (sort_on r xs)", "by simp"], ["", "lemma finite_sorted_on_distinct_unique:\n  assumes \"A \\<subseteq> Field r\"\n  assumes \"finite A\"\n  shows \"\\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs", "from \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  finite A", "obtain xs where \"set xs = A \\<and> distinct xs\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        set xs = A \\<and> distinct xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finite_distinct_list"], ["proof (prove)\nusing this:\n  finite A\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        set xs = A \\<and> distinct xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs", "with \\<open>A \\<subseteq> Field r\\<close>"], ["proof (chain)\npicking this:\n  A \\<subseteq> Field r\n  set xs = A \\<and> distinct xs", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> Field r\n  set xs = A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs", "by (fastforce intro!: ex1I[where a=\"sort_on r xs\"] simp: sorted_on_distinct_set_unique)"], ["proof (state)\nthis:\n  \\<exists>!xs. set xs = A \\<and> sorted_on r xs \\<and> distinct xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma sorted_on_linord_of_list_subseteq_r:\n  assumes \"Linear_order r\"\n  assumes \"sorted_on r xs\"\n  assumes \"distinct xs\"\n  shows \"linord_of_list (rev xs) \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) \\<subseteq> r", "using assms"], ["proof (prove)\nusing this:\n  Linear_order r\n  sorted_on r xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) \\<subseteq> r", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Linear_order r; sorted_on r []; distinct []\\<rbrakk>\n    \\<Longrightarrow> linord_of_list (rev []) \\<subseteq> r\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>Linear_order r; sorted_on r xs;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r;\n        Linear_order r; sorted_on r (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> linord_of_list (rev (a # xs)) \\<subseteq> r", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>Linear_order r; sorted_on r xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r\n  Linear_order r\n  sorted_on r (x # xs)\n  distinct (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Linear_order r; sorted_on r []; distinct []\\<rbrakk>\n    \\<Longrightarrow> linord_of_list (rev []) \\<subseteq> r\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>Linear_order r; sorted_on r xs;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r;\n        Linear_order r; sorted_on r (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> linord_of_list (rev (a # xs)) \\<subseteq> r", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Linear_order r; sorted_on r xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r\n  Linear_order r\n  sorted_on r (x # xs)\n  distinct (x # xs)", "have \"linord_of_list (rev xs) \\<subseteq> r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Linear_order r; sorted_on r xs; distinct xs\\<rbrakk>\n  \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r\n  Linear_order r\n  sorted_on r (x # xs)\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) \\<subseteq> r", "by (simp add: sorted_on_Cons)"], ["proof (state)\nthis:\n  linord_of_list (rev xs) \\<subseteq> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Linear_order r; sorted_on r []; distinct []\\<rbrakk>\n    \\<Longrightarrow> linord_of_list (rev []) \\<subseteq> r\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>Linear_order r; sorted_on r xs;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> linord_of_list (rev xs) \\<subseteq> r;\n        Linear_order r; sorted_on r (a # xs); distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> linord_of_list (rev (a # xs)) \\<subseteq> r", "with Cons.prems"], ["proof (chain)\npicking this:\n  Linear_order r\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  linord_of_list (rev xs) \\<subseteq> r", "show ?case"], ["proof (prove)\nusing this:\n  Linear_order r\n  sorted_on r (x # xs)\n  distinct (x # xs)\n  linord_of_list (rev xs) \\<subseteq> r\n\ngoal (1 subgoal):\n 1. linord_of_list (rev (x # xs)) \\<subseteq> r", "by (clarsimp simp: linord_of_list_append linord_of_list_singleton sorted_on_Cons)\n       (meson contra_subsetD subsetI underS_incl_iff)"], ["proof (state)\nthis:\n  linord_of_list (rev (x # xs)) \\<subseteq> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Linear_order r; sorted_on r []; distinct []\\<rbrakk>\n    \\<Longrightarrow> linord_of_list (rev []) \\<subseteq> r", "qed simp"], ["", "lemma sorted_on_linord_of_list:\n  assumes \"Linear_order r\"\n  assumes \"set xs = Field r\"\n  assumes \"sorted_on r xs\"\n  assumes \"distinct xs\"\n  shows \"linord_of_list (rev xs) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) = r", "proof(rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. linord_of_list (rev xs) \\<subseteq> r\n 2. r \\<subseteq> linord_of_list (rev xs)", "from assms"], ["proof (chain)\npicking this:\n  Linear_order r\n  set xs = Field r\n  sorted_on r xs\n  distinct xs", "show \"linord_of_list (rev xs) \\<subseteq> r\""], ["proof (prove)\nusing this:\n  Linear_order r\n  set xs = Field r\n  sorted_on r xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) \\<subseteq> r", "using sorted_on_linord_of_list_subseteq_r"], ["proof (prove)\nusing this:\n  Linear_order r\n  set xs = Field r\n  sorted_on r xs\n  distinct xs\n  \\<lbrakk>Linear_order ?r; sorted_on ?r ?xs; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> linord_of_list (rev ?xs) \\<subseteq> ?r\n\ngoal (1 subgoal):\n 1. linord_of_list (rev xs) \\<subseteq> r", "by blast"], ["proof (state)\nthis:\n  linord_of_list (rev xs) \\<subseteq> r\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "assume xy: \"(x, y) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "with \\<open>Linear_order r\\<close>"], ["proof (chain)\npicking this:\n  Linear_order r\n  (x, y) \\<in> r", "have \"(y, x) \\<notin> r - Id\""], ["proof (prove)\nusing this:\n  Linear_order r\n  (x, y) \\<in> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r - Id", "using Linear_order_in_diff_Id"], ["proof (prove)\nusing this:\n  Linear_order r\n  (x, y) \\<in> r\n  \\<lbrakk>Linear_order ?r; ?a \\<in> Field ?r; ?b \\<in> Field ?r\\<rbrakk>\n  \\<Longrightarrow> ((?a, ?b) \\<in> ?r) = ((?b, ?a) \\<notin> ?r - Id)\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r - Id", "by (fastforce intro: FieldI1)"], ["proof (state)\nthis:\n  (y, x) \\<notin> r - Id\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "with linord_of_list_Linear_order[of \"rev xs\" \"Field r\"] assms xy"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (rev xs); Field r = set (rev xs)\\<rbrakk>\n  \\<Longrightarrow> linear_order_on (Field r) (linord_of_list (rev xs))\n  Linear_order r\n  set xs = Field r\n  sorted_on r xs\n  distinct xs\n  (x, y) \\<in> r\n  (y, x) \\<notin> r - Id", "have \"(x, y) \\<in> linord_of_list (rev xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (rev xs); Field r = set (rev xs)\\<rbrakk>\n  \\<Longrightarrow> linear_order_on (Field r) (linord_of_list (rev xs))\n  Linear_order r\n  set xs = Field r\n  sorted_on r xs\n  distinct xs\n  (x, y) \\<in> r\n  (y, x) \\<notin> r - Id\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> linord_of_list (rev xs)", "by simp (metis Diff_subset FieldI1 FieldI2 Linear_order_in_diff_Id linord_of_list_Field set_rev sorted_on_linord_of_list_subseteq_r subset_eq)"], ["proof (state)\nthis:\n  (x, y) \\<in> linord_of_list (rev xs)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "}"], ["proof (state)\nthis:\n  (?x2, ?y2) \\<in> r \\<Longrightarrow>\n  (?x2, ?y2) \\<in> linord_of_list (rev xs)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "then"], ["proof (chain)\npicking this:\n  (?x2, ?y2) \\<in> r \\<Longrightarrow>\n  (?x2, ?y2) \\<in> linord_of_list (rev xs)", "show \"r \\<subseteq> linord_of_list (rev xs)\""], ["proof (prove)\nusing this:\n  (?x2, ?y2) \\<in> r \\<Longrightarrow>\n  (?x2, ?y2) \\<in> linord_of_list (rev xs)\n\ngoal (1 subgoal):\n 1. r \\<subseteq> linord_of_list (rev xs)", "by clarsimp"], ["proof (state)\nthis:\n  r \\<subseteq> linord_of_list (rev xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linord_of_listP_rev:\n  assumes \"z # zs \\<in> set (subseqs xs)\"\n  assumes \"y \\<in> set zs\"\n  shows \"linord_of_listP z y (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linord_of_listP z y (rev xs)", "using assms"], ["proof (prove)\nusing this:\n  z # zs \\<in> set (subseqs xs)\n  y \\<in> set zs\n\ngoal (1 subgoal):\n 1. linord_of_listP z y (rev xs)", "by (induct xs) (auto simp: Let_def linord_of_listP_append dest: subseqs_set)"], ["", "lemma linord_of_list_sorted_on_subseqs:\n  assumes \"ys \\<in> set (subseqs xs)\"\n  assumes \"distinct xs\"\n  shows \"sorted_on (linord_of_list (rev xs)) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on (linord_of_list (rev xs)) ys", "using assms"], ["proof (prove)\nusing this:\n  ys \\<in> set (subseqs xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. sorted_on (linord_of_list (rev xs)) ys", "proof(induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n                \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys;\n        a # ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n       \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n  \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys\n  y # ys \\<in> set (subseqs xs)\n  distinct xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n                \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys;\n        a # ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n       \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) (a # ys)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n  \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys\n  y # ys \\<in> set (subseqs xs)\n  distinct xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n  \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys\n  y # ys \\<in> set (subseqs xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. sorted_on (linord_of_list (rev xs)) (y # ys)", "using linord_of_list_Linear_order[where xs=\"rev xs\" and ys=\"Field (linord_of_list (rev xs))\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n  \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) ys\n  y # ys \\<in> set (subseqs xs)\n  distinct xs\n  \\<lbrakk>distinct (rev xs);\n   Field (linord_of_list (rev xs)) = set (rev xs)\\<rbrakk>\n  \\<Longrightarrow> Linear_order (linord_of_list (rev xs))\n\ngoal (1 subgoal):\n 1. sorted_on (linord_of_list (rev xs)) (y # ys)", "by (force simp: Cons_in_subseqsD sorted_on_Cons linord_of_list_linord_of_listP linord_of_listP_rev dest: subseqs_set)"], ["proof (state)\nthis:\n  sorted_on (linord_of_list (rev xs)) (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<in> set (subseqs xs); distinct xs\\<rbrakk>\n    \\<Longrightarrow> sorted_on (linord_of_list (rev xs)) []", "qed simp"], ["", "lemma linord_of_list_sorted_on:\n  assumes \"distinct xs\"\n  shows \"sorted_on (linord_of_list (rev xs)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_on (linord_of_list (rev xs)) xs", "by (rule linord_of_list_sorted_on_subseqs[OF subseqs_refl \\<open>distinct xs\\<close>])"], ["", "(*>*)"], ["", "lemma linear_order_on_list:\n  assumes \"linear_order_on ys r\"\n  assumes \"ys = Field r\"\n  assumes \"finite ys\"\n  shows \"\\<exists>!xs. r = linord_of_list xs \\<and> distinct xs \\<and> set xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       r = linord_of_list xs \\<and> distinct xs \\<and> set xs = ys", "using %invisible finite_sorted_on_distinct_unique[of r ys] sorted_on_linord_of_list[of r] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Linear_order r; ys \\<subseteq> Field r; finite ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!xs.\n                       set xs = ys \\<and> sorted_on r xs \\<and> distinct xs\n  \\<lbrakk>Linear_order r; set ?xs = Field r; sorted_on r ?xs;\n   distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> linord_of_list (rev ?xs) = r\n  linear_order_on ys r\n  ys = Field r\n  finite ys\n\ngoal (1 subgoal):\n 1. \\<exists>!xs.\n       r = linord_of_list xs \\<and> distinct xs \\<and> set xs = ys", "by simp (metis distinct_rev linord_of_list_sorted_on rev_rev_ident set_rev)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}