{"file_name": "/home/qj213/afp-2021-10-22/thys/Stable_Matching/Choice_Functions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stable_Matching", "problem_names": ["lemma f_range_onI:\n  \"(\\<And>B. B \\<subseteq> A \\<Longrightarrow> f B \\<subseteq> B) \\<Longrightarrow> f_range_on A f\"", "lemmas f_range_onD = iffD1[OF f_range_on_def, rule_format]", "lemmas f_range_onD' = subsetD[OF f_range_onD, rotated -1]", "lemma f_range_on_antimono:\n  assumes \"f_range_on B f\"\n  assumes \"A \\<subseteq> B\"\n  shows \"f_range_on A f\"", "lemmas decisive_onD = iffD1[OF decisive_on_def, rule_format]", "lemmas decisive_onI = iffD2[OF decisive_on_def, rule_format]", "lemma decisive_on_empty:\n  shows \"decisive_on {} f\"", "lemma decisive_on_mono:\n  assumes \"decisive_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"decisive_on B f\"", "lemma resolute_on_decisive_on:\n  assumes \"resolute_on A f\"\n  shows \"decisive_on A f\"", "lemma substitutes_on_def2[simplified]:\n  \"substitutes_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>a\\<in>A. \\<forall>b\\<in>A. b \\<notin> f (B \\<union> {b}) \\<longrightarrow> b \\<notin> f (B \\<union> {a, b}))\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemmas substitutes_onI = iffD2[OF substitutes_on_def2, rule_format, simplified]", "lemmas substitutes_onD = iffD1[OF substitutes_on_def2, rule_format, simplified]", "lemmas substitutesD = substitutes_onD[where A=UNIV, simplified]", "lemma substitutes_on_union:\n  assumes \"a \\<notin> f (B \\<union> {a})\"\n  assumes \"substitutes_on (A \\<union> B \\<union> {a}) f\"\n  assumes \"finite A\"\n  shows \"a \\<notin> f (A \\<union> B \\<union> {a})\"", "lemma substitutes_on_antimono:\n  assumes \"substitutes_on B f\"\n  assumes \"A \\<subseteq> B\"\n  shows \"substitutes_on A f\"", "lemma substitutes_on_Rf_mono_on:\n  assumes \"substitutes_on A f\"\n  assumes \"finite A\"\n  shows \"mono_on (Pow A) (Rf f)\"", "lemma Rf_mono_on_substitutes:\n  assumes \"mono_on (Pow A) (Rf f)\"\n  shows \"substitutes_on A f\"", "lemmas %invisible iia_onI = iffD2[OF iia_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible iia_onD = iffD1[OF iia_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemma Rf_mono_on_iia_on:\n  shows \"mono_on (Pow A) (Rf f) \\<longleftrightarrow> iia_on A f\"", "lemma Rf_mono_iia:\n  shows \"mono (Rf f) \\<longleftrightarrow> iia f\"", "lemma substitutes_iia:\n  assumes \"finite A\"\n  shows \"substitutes_on A f \\<longleftrightarrow> iia_on A f\"", "lemma iia_f_idem:\n  assumes \"f_range_on A f\"\n  assumes \"iia_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"f (f B) = f B\"", "lemmas %invisible substitutable_preferences_onI = iffD2[OF substitutable_preferences_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemma substitutable_preferences_on_substitutes_on:\n  shows \"substitutable_preferences_on A f \\<longleftrightarrow> substitutes_on A f\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemmas Chernoff_onI = iffD2[OF Chernoff_on_def, rule_format]", "lemmas Chernoff_def = Chernoff_on_def[where A=UNIV, simplified]", "lemma Chernoff_on_iia_on:\n  shows \"Chernoff_on A f \\<longleftrightarrow> iia_on A f\"", "lemma Chernoff_on_union:\n  assumes \"Chernoff_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"B \\<subseteq> A\" \"C \\<subseteq> A\"\n  shows \"f (B \\<union> C) \\<subseteq> f B \\<union> f C\"", "lemma Chernoff_a:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f B \\<union> C)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma Chernoff_b: \\<comment> \\<open>essentially the converse of @{thm [source] Chernoff_on_union}\\<close>\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f B \\<union> f C)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma Chernoff_c:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f (f B \\<union> C))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma Chernoff_d:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f (f B \\<union> f C))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemmas %invisible irc_onI = iffD2[OF irc_on_def, rule_format, simplified]", "lemmas %invisible irc_onD = iffD1[OF irc_on_def, rule_format, simplified]", "lemmas %invisible irc_def = irc_on_def[where A=UNIV, simplified]", "lemmas %invisible ircI = iffD2[OF irc_def, rule_format, simplified]", "lemmas %invisible ircD = iffD1[OF irc_def, rule_format, simplified]", "lemma irc_on_discard:\n  assumes \"irc_on A f\"\n  assumes \"finite C\"\n  assumes \"B \\<union> C \\<subseteq> A\"\n  assumes \"f (B \\<union> C) \\<inter> C = {}\"\n  shows \"f (B \\<union> C) = f B\"", "lemmas %invisible consistency_onI = iffD2[OF consistency_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible consistency_onD = iffD1[OF consistency_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible consistency_def = consistency_on_def[where A=UNIV, simplified]", "lemmas %invisible consistencyD = iffD1[OF consistency_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemma irc_on_consistency_on:\n  assumes \"irc_on A f\"\n  assumes \"finite A\"\n  shows \"consistency_on A f\"", "lemma consistency_on_irc_on:\n  assumes \"f_range_on A f\"\n  assumes \"consistency_on A f\"\n  shows \"irc_on A f\"", "lemma consistency_on_f_idem:\n  assumes \"f_range_on A f\"\n  assumes \"consistency_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"f (f B) = f B\"", "lemmas %invisible Aizerman_onI = iffD2[OF Aizerman_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible Aizerman_onD = iffD1[OF Aizerman_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible Aizerman_def = Aizerman_on_def[where A=UNIV, simplified]", "lemma consistency_on_Aizerman_on:\n  assumes \"consistency_on A f\"\n  shows \"Aizerman_on A f\"", "lemma Aizerman_on_idem_on_consistency_on:\n  assumes \"Aizerman_on A f\"\n  assumes \"\\<forall>B\\<subseteq>A. f (f B) = f B\"\n  shows \"consistency_on A f\"", "lemma lad_onD:\n  assumes \"lad_on A f\"\n  assumes \"C \\<subseteq> B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"card (f C) \\<le> card (f B)\"", "lemma ladD:\n  assumes \"lad f\"\n  assumes \"\\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> B\"\n  shows \"card (f C) \\<le> card (f B)\"", "lemma lad_on_substitutes_on_irc_on:\n  assumes \"f_range_on A f\"\n  assumes \"substitutes_on A f\"\n  assumes \"lad_on A f\"\n  shows \"irc_on A f\"", "lemmas %invisible expansion_onI = iffD2[OF expansion_on_def, rule_format]", "lemmas %invisible expansion_onD = iffD1[OF expansion_on_def, rule_format, THEN subsetD, simplified, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible expansion_gamma_onI = iffD2[OF expansion_gamma_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible expansion_gamma_onE = iffD1[OF expansion_gamma_on_def, rule_format, THEN subsetD, simplified, unfolded conj_imp_eq_imp_imp]", "lemma expansion_gamma_expansion:\n  assumes \"\\<forall>As. expansion_gamma_on A As f\"\n  shows \"expansion_on A f\"", "lemma expansion_expansion_gamma:\n  assumes \"expansion_on A f\"\n  assumes \"finite As\"\n  shows \"expansion_gamma_on A As f\"", "lemma (in MaxR) greatest:\n  shows \"set_option (MaxR_opt X) = greatest r (X \\<inter> Field r)\"", "lemma greatest_r_mono:\n  assumes \"Above r X \\<subseteq> Above r' X\"\n  shows \"greatest r X \\<subseteq> greatest r' X\"", "lemmas greatest_r_mono' = subsetD[OF greatest_r_mono, rotated]", "lemma greatest_Above:\n  shows \"greatest r X = Above r X \\<inter> X\"", "lemma %invisible rationalizes_onI:\n  assumes \"f_range_on A f\"\n  assumes \"\\<And>B x y. \\<lbrakk>B \\<subseteq> A; x \\<in> f B; y \\<in> B\\<rbrakk> \\<Longrightarrow> (y, x) \\<in> r\"\n  assumes \"\\<And>B x. \\<lbrakk>B \\<subseteq> A; x \\<in> B; \\<forall>y\\<in>B. (y, x) \\<in> r\\<rbrakk> \\<Longrightarrow> x \\<in> f B\"\n  shows \"rationalizes_on A f r\"", "lemma %invisible rwp_on_Field:\n  assumes \"f_range_on A f\"\n  shows \"Field (rwp_on A f) \\<subseteq> A\"", "lemma rwp_on_refl_on:\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"refl_on A (rwp_on A f)\"", "lemma rationalizes_on_f_range_on_V_axiom_on:\n  assumes \"rationalizes_on A f r\"\n  shows \"f_range_on A f\"\n    and \"V_axiom_on A f\"", "lemma f_range_on_V_axiom_on_rationalizes_on:\n  assumes \"f_range_on A f\"\n  assumes \"V_axiom_on A f\"\n  shows \"rationalizes_on A f (rwp_on A f)\"", "theorem V_axiom_on_rationalizes_on:\n  shows \"(f_range_on A f \\<and> V_axiom_on A f) \\<longleftrightarrow> (\\<exists>r. rationalizes_on A f r)\"", "lemma %invisible rationalizable_binary_onI:\n  assumes \"f_range_on A f\"\n  assumes \"\\<And>B x y. \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk> \\<Longrightarrow> y \\<in> f {x, y}\"\n  assumes \"\\<And>B y. \\<lbrakk>B \\<subseteq> A; y \\<in> B; \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk> \\<Longrightarrow> y \\<in> f B\"\n  shows \"rationalizable_binary_on A f\"", "theorem V_axiom_realizable_binary:\n  assumes \"f_range_on A f\"\n  shows \"V_axiom_on A f \\<longleftrightarrow> rationalizable_binary_on A f\"\n(*<*)\n(is \"?lhs = ?rhs\")", "lemma rationalizable_binary_on_iia_on:\n  assumes \"f_range_on A f\"\n  assumes \"rationalizable_binary_on A f\"\n  shows \"iia_on A f\"", "lemma rationalizable_binary_on_expansion_on:\n  assumes \"f_range_on A f\"\n  assumes \"rationalizable_binary_on A f\"\n  shows \"expansion_on A f\"", "lemma rationalizable_binary_on_converse:\n  fixes f :: \"'a::finite cfun\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  assumes \"iia_on A f\"\n  assumes \"expansion_on A f\"\n  shows \"rationalizable_binary_on A f\"", "lemma %invisible rsp_on_range:\n  assumes \"f_range_on A f\"\n  shows \"rsp_on A f \\<subseteq> A \\<times> A\"", "lemma %invisible sarp_onI:\n  assumes \"\\<And>x y. (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow> (y, x) \\<notin> rwp_on A f\"\n  shows \"sarp_on A f\"", "lemma sarp_on_warp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  assumes \"sarp_on A f\"\n  shows \"warp_on A f\"", "lemma rsp_on_irrefl:\n  \"A \\<noteq> {} \\<Longrightarrow> irrefl (rsp_on A f)\"", "lemma %invisible wca_onI:\n  assumes \"\\<And>B x y. \\<lbrakk> B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B; y \\<in> B \\<rbrakk> \\<Longrightarrow> y \\<in> f B\"\n  shows \"wca_on A f\"", "lemma wca_on_V_axiom_on:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"V_axiom_on A f\"", "lemma wca_on_total_on:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"total_on A (rwp_on A f)\"", "lemma rwp_on_trans:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"trans (rwp_on A f)\"", "lemma wca_on_V_axiom_on_preorder_on: \\<comment> \\<open>\\citet[T.1, T.3 part]{Sen:1970}\\<close>\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"wca_on A f \\<longleftrightarrow> V_axiom_on A f \\<and> preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma wca_on_rwp_on_rspR_on: \\<comment> \\<open>\\citet[T.2]{Sen:1970}\\<close>\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"rwp_on A f = rspR_on A f\"\n(*<*)\n(is \"?lhs = ?rhs\")", "lemma rwp_on_rspR_on_wca_on: \\<comment> \\<open>\\citet[T.2]{Sen:1970}\\<close>\n  assumes \"rwp_on A f = rspR_on A f\"\n  shows \"wca_on A f\"", "lemma wca_on_warp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  shows \"wca_on A f \\<longleftrightarrow> warp_on A f\"", "lemma warp_on_sarp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  assumes \"warp_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"sarp_on A f\"", "lemma %invisible mwc_sarpI:\n  assumes \"\\<And>Xs. \\<lbrakk>length Xs > 1; distinct (map f Xs); \\<forall>i. f (Xs!%i) \\<subset> Xs!%i \\<inter> Xs!%(i+1)\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"mwc_sarp f\"", "lemma iia_consistency_mwc_sarp:\n  assumes \"f_range f\"\n  assumes \"iia f\" \\<comment> \\<open>@{const \"substitutes\"}\\<close>\n  assumes \"consistency f\" \\<comment> \\<open>@{const \"irc\"}\\<close>\n  shows \"mwc_sarp f\"", "lemmas maxR_code = MaxR.maxR_def", "lemmas MaxR_f_code = MaxR.MaxR_f_def", "lemma code:\n  shows \"linear_cf (set X) = set_option (fold MaxR.MaxR_f X None)\"", "lemma simps [nitpick_simp]:\n  shows \"linear_cf {} = {}\"\n        \"linear_cf (insert x X) = (if x \\<in> Field r then if linear_cf X = {} then {x} else {MaxR.maxR x y |y. y \\<in> linear_cf X} else linear_cf X)\"", "lemma range:\n  shows \"linear_cf X \\<subseteq> X \\<inter> Field r\"", "lemmas range' = rev_subsetD[OF _ range, of x] for x", "lemma singleton:\n  shows \"x \\<in> linear_cf X \\<longleftrightarrow> linear_cf X = {x}\"", "lemma subset:\n  assumes \"linear_cf Y \\<subseteq> X\"\n  assumes \"X \\<subseteq> Y\"\n  shows \"linear_cf Y = linear_cf X\"", "lemma union:\n  shows \"linear_cf (X \\<union> Y) = (if linear_cf X = {} then linear_cf Y else if linear_cf Y = {} then linear_cf X else {MaxR.maxR x y |x y. x \\<in> linear_cf X \\<and> y \\<in> linear_cf Y})\"", "lemma mono:\n  assumes \"x \\<in> linear_cf X\"\n  shows \"\\<exists>y \\<in> linear_cf (X \\<union> Y). (x, y) \\<in> r\"", "lemmas greatest = MaxR.greatest[folded linear_cf_def]", "lemma preferred:\n  assumes \"(x, y) \\<in> r\"\n  assumes \"x \\<in> linear_cf X\"\n  assumes \"y \\<in> X\"\n  shows \"y = x\"", "lemma card_le:\n  shows \"card (linear_cf X) \\<le> 1\"", "lemma card:\n  shows \"card (linear_cf X) = (if X \\<inter> Field r = {} then 0 else 1)\"", "lemma f_range:\n  shows \"f_range_on X linear_cf\"", "lemma domain:\n  shows \"linear_cf (X \\<inter> Field r) = linear_cf X\"", "lemma decisive_on:\n  shows \"decisive_on (Field r) linear_cf\"", "lemma resolute_on:\n  shows \"resolute_on (Field r) linear_cf\"", "lemma Rf_mono_on:\n  shows \"mono_on X (Rf linear_cf)\"", "lemmas iia = iffD1[OF Rf_mono_on_iia_on Rf_mono_on]", "lemma Chernoff:\n  shows \"Chernoff_on X linear_cf\"", "lemma irc:\n  shows \"irc_on X linear_cf\"", "lemma consistency:\n  shows \"consistency_on X linear_cf\"", "lemma lad:\n  shows \"lad_on X linear_cf\"", "lemmas path_independent_onI = iffD2[OF path_independent_on_def, rule_format]", "lemmas path_independent_onD = iffD1[OF path_independent_on_def, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas path_independent_def = path_independent_on_def[where A=UNIV, simplified]", "lemma path_independent_on_symmetric:\n  assumes \"f_range_on A f\"\n  shows \"path_independent_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) = f (f B \\<union> f C))\"", "lemmas %invisible path_independent_on_symmetricI = iffD2[OF path_independent_on_symmetric, rule_format, unfolded conj_imp_eq_imp_imp]", "lemmas %invisible path_independent_on_symmetricD = iffD1[OF path_independent_on_symmetric, rule_format, unfolded conj_imp_eq_imp_imp]", "lemma path_independent_on_Chernoff_on:\n  assumes \"path_independent_on A f\"\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f\"", "lemma path_independent_on_consistency_on:\n  assumes \"path_independent_on A f\"\n  shows \"consistency_on A f\"", "lemma Chernoff_on_consistency_on_path_independent_on:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<and> consistency_on A f \\<longleftrightarrow> path_independent_on A f\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemmas path_independent_onI2 =\n  iffD1[OF Chernoff_on_consistency_on_path_independent_on, unfolded conj_imp_eq_imp_imp]", "lemma (in linear_cf) path_independent:\n  shows \"path_independent linear_cf\"", "lemma pseudo_rationalizable_on_def2:\n  \"pseudo_rationalizable_on A Rs f\n     \\<longleftrightarrow> (\\<forall>r\\<in>Rs. Linear_order r) \\<and> (\\<forall>B\\<subseteq>A. f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\"", "lemmas %invisible pseudo_rationalizable_onI = iffD2[OF pseudo_rationalizable_on_def2, unfolded conj_imp_eq_imp_imp, rule_format]", "lemma Aizerman_on_Chernoff_on_path_independent_on:\n  assumes \"f_range_on A f\"\n  shows \"Aizerman_on A f \\<and> Chernoff_on A f \\<longleftrightarrow> path_independent_on A f\"", "lemma pseudo_rationalizable_on_path_independent_on:\n  assumes \"pseudo_rationalizable_on A Rs f\"\n  shows \"path_independent_on A f\"", "lemma mk_linear_orders_termination:\n  assumes \"B \\<subseteq> A\"\n  shows \"mk_linear_orders_dom (C, B)\"", "lemma mk_linear_orders_induct[consumes 2, case_names base step1 step2]:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes base: \"\\<And>C B. \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk> \\<Longrightarrow> P C B []\"\n  assumes step1: \"\\<And>C B b cs. \\<lbrakk>B \\<subseteq> A; cs \\<in> mk_linear_orders {} (B - {b}); b \\<in> f B; f B \\<subseteq> C; P {} (B - {b}) cs\\<rbrakk>\n                          \\<Longrightarrow> P C B (b # cs)\"\n  assumes step2: \"\\<And>C B b cs. \\<lbrakk>B \\<subseteq> A; cs \\<in> mk_linear_orders C (B - {SOME x. x \\<in> f B - C}); b \\<in> f B; b \\<notin> C; P C (B - {SOME x. x \\<in> f B - C}) cs\\<rbrakk>\n                          \\<Longrightarrow> P C B ((SOME x. x \\<in> f B - C) # cs)\"\n  shows \"P C B r\"", "lemma mk_linear_orders_non_empty:\n  assumes \"B \\<subseteq> A\"\n  shows \"\\<exists>r. r \\<in> mk_linear_orders C B\"", "lemma mk_linear_orders_range:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"set r \\<subseteq> B\"", "lemma mk_linear_orders_nth:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"i < length r\"\n  shows \"r ! i \\<in> f (B - set (take i r))\"", "lemma mk_linear_orders_distinct:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"distinct r\"", "lemma mk_linear_orders_Linear_order:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  shows \"Linear_order (linord_of_list r)\"", "lemma mk_linear_orders_decisive_on_set_r:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"decisive_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"set r = B\"", "lemma mk_linear_orders_decisive_on_refl_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"decisive_on A f\"\n  shows \"refl_on A (linord_of_list r)\"", "lemma mk_linear_orders_decisive_on_total_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"decisive_on A f\"\n  shows \"total_on A (linord_of_list r)\"", "lemma mk_linear_orders_set_r_decisive_on:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"B \\<subseteq> set r\"\n  assumes \"iia_on A f\"\n  shows \"decisive_on B f\"", "lemma mk_linear_orders_total_on_decisive_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"A \\<subseteq> set r\"\n  assumes \"iia_on A f\"\n  shows \"decisive_on A f\"", "lemma mk_linear_orders_MaxR_opt_f:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"MaxR.MaxR_opt (linord_of_list r) D = Some x\"\n  assumes \"iia_on A f\"\n  assumes \"D \\<subseteq> A\"\n  shows \"x \\<in> f D\"", "lemma mk_linear_orders_f_MaxR_opt:\n  assumes \"x \\<in> f C\"\n  assumes \"consistency_on A f\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"C \\<subseteq> B\"\n  shows \"\\<exists>r\\<in>mk_linear_orders C B. MaxR.MaxR_opt (linord_of_list r) C = Some x\"", "lemma path_independent_on_pseudo_rationalizable_on:\n  fixes f :: \"'a::finite cfun\"\n  assumes \"path_independent_on A f\"\n  assumes \"f_range_on A f\"\n  assumes Rs_def[simp]: \"Rs = (\\<Union>C\\<in>Pow A. linord_of_list ` mk_linear_orders f C A)\"\n  shows \"pseudo_rationalizable_on A Rs f \\<and> (\\<forall>r\\<in>Rs. refl_on A r \\<and> total_on A r \\<longleftrightarrow> decisive_on A f)\"", "theorem pseudo_rationalizable:\n  assumes \"f_range_on A f\"\n  shows \"path_independent_on A f\n           \\<longleftrightarrow> (\\<exists>Rs. pseudo_rationalizable_on A Rs f \\<and> (\\<forall>r\\<in>Rs. refl_on A r \\<and> total_on A r \\<longleftrightarrow> decisive_on A f))\""], "translations": [["", "lemma f_range_onI:\n  \"(\\<And>B. B \\<subseteq> A \\<Longrightarrow> f B \\<subseteq> B) \\<Longrightarrow> f_range_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        B \\<subseteq> A \\<Longrightarrow>\n        f B \\<subseteq> B) \\<Longrightarrow>\n    f_range_on A f", "unfolding f_range_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        B \\<subseteq> A \\<Longrightarrow>\n        f B \\<subseteq> B) \\<Longrightarrow>\n    \\<forall>B\\<subseteq>A. f B \\<subseteq> B", "by blast"], ["", "lemmas f_range_onD = iffD1[OF f_range_on_def, rule_format]"], ["", "lemmas f_range_onD' = subsetD[OF f_range_onD, rotated -1]"], ["", "lemma f_range_on_antimono:\n  assumes \"f_range_on B f\"\n  assumes \"A \\<subseteq> B\"\n  shows \"f_range_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_range_on A f", "using assms"], ["proof (prove)\nusing this:\n  f_range_on B f\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. f_range_on A f", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>Ba\\<subseteq>B. f Ba \\<subseteq> Ba\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A. f B \\<subseteq> B", "by blast"], ["", "(*>*)"], ["", "text\\<open>\n\nEconomists typically assume that the universe is finite, and @{term\n\"f\"} is @{emph \\<open>decisive\\<close>}, i.e., yields non-empty sets when given\nnon-empty sets.\n\n\\<close>"], ["", "definition decisive_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"decisive_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {})\""], ["", "abbreviation decisive :: \"'a cfun \\<Rightarrow> bool\" where\n  \"decisive \\<equiv> decisive_on UNIV\""], ["", "(*<*)"], ["", "lemmas decisive_onD = iffD1[OF decisive_on_def, rule_format]"], ["", "lemmas decisive_onI = iffD2[OF decisive_on_def, rule_format]"], ["", "lemma decisive_on_empty:\n  shows \"decisive_on {} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on {} f", "unfolding decisive_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>{}. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}", "by simp"], ["", "lemma decisive_on_mono:\n  assumes \"decisive_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"decisive_on B f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on B f", "using assms order_trans"], ["proof (prove)\nusing this:\n  decisive_on A f\n  B \\<subseteq> A\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. decisive_on B f", "unfolding decisive_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  B \\<subseteq> A\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<forall>Ba\\<subseteq>B.\n       Ba \\<noteq> {} \\<longrightarrow> f Ba \\<noteq> {}", "by auto"], ["", "(*>*)"], ["", "text\\<open>\n\nOften we can mildly generalise existing results by not requiring that\n@{term \"f\"} be @{const \"decisive\"}, and by dropping the finiteness\nhypothesis. We make essential use of the former generalization in\n\\S\\ref{sec:contracts}.\n\nSome choice functions, such as those arising from linear orders\n(\\S\\ref{sec:cf-linear}), are @{emph \\<open>resolute\\<close>}: these always yield a\nsingle choice.\n\n\\<close>"], ["", "definition resolute_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"resolute_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> (\\<exists>a. f B = {a}))\""], ["", "abbreviation resolute :: \"'a cfun \\<Rightarrow> bool\" where\n  \"resolute \\<equiv> resolute_on UNIV\""], ["", "lemma resolute_on_decisive_on:\n  assumes \"resolute_on A f\"\n  shows \"decisive_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  resolute_on A f\n\ngoal (1 subgoal):\n 1. decisive_on A f", "unfolding resolute_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     B \\<noteq> {} \\<longrightarrow> (\\<exists>a. f B = {a})\n\ngoal (1 subgoal):\n 1. decisive_on A f", "by - (rule decisive_onI; auto)"], ["", "text\\<open>\n\nOften we talk about the choices that are rejected by \\<open>f\\<close>:\n\n\\label{sec:cf-rf}\n\n\\<close>"], ["", "abbreviation Rf :: \"'a cfun \\<Rightarrow> 'a cfun\" where\n  \"Rf f X \\<equiv> X - f X\""], ["", "text\\<open>\n\nTypically there are many (almost-)equivalent formulations of each\nproperty in the literature. We try to formulate our rules in terms of\nthe most general of these.\n\n\\<close>"], ["", "subsection\\<open> The @{emph \\<open>substitutes\\<close>} condition, AKA @{emph \\<open>independence of irrelevant alternatives\\<close>} \\label{sec:cf-substitutes} AKA @{emph \\<open>Chernoff\\<close>} \\<close>"], ["", "text\\<open>\n\nLoosely speaking, the @{emph \\<open>substitutes\\<close>} condition asserts that an\nalternative that is rejected from @{term \"A\"} shall remain rejected\nwhen there is ``increased competition,'' i.e., from all sets that\ncontain @{term \"A\"}.\n\n\\citet{HatfieldMilgrom:2005} define this property as simply the\nmonotonicity of @{const \"Rf\"}. \\citet{AygunSonmez:2012-WP2} instead\nuse the complicated condition shown here. Condition\n\\<open>\\<alpha>\\<close>, due to \\citet[p17, see below]{Sen:1970}, is\nthe most general and arguably the most perspicuous.\n\n\\<close>"], ["", "definition substitutes_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"substitutes_on A f \\<longleftrightarrow> \\<not>(\\<exists>B\\<subseteq>A. \\<exists>a b. {a, b} \\<subseteq> A - B \\<and> b \\<notin> f (B \\<union> {b}) \\<and> b \\<in> f (B \\<union> {a, b}))\""], ["", "abbreviation substitutes :: \"'a cfun \\<Rightarrow> bool\" where\n  \"substitutes \\<equiv> substitutes_on UNIV\""], ["", "lemma substitutes_on_def2[simplified]:\n  \"substitutes_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>a\\<in>A. \\<forall>b\\<in>A. b \\<notin> f (B \\<union> {b}) \\<longrightarrow> b \\<notin> f (B \\<union> {a, b}))\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes_on A f =\n    (\\<forall>B\\<subseteq>A.\n        \\<forall>a\\<in>A.\n           \\<forall>b\\<in>A.\n              b \\<notin> f (B \\<union> {b}) \\<longrightarrow>\n              b \\<notin> f (B \\<union> {a, b}))", "proof (rule iffI, clarsimp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B a b.\n       \\<lbrakk>substitutes_on A f; B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B);\n        b \\<in> f (insert a (insert b B))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>B\\<subseteq>A.\n       \\<forall>a\\<in>A.\n          \\<forall>b\\<in>A.\n             b \\<notin> f (B \\<union> {b}) \\<longrightarrow>\n             b \\<notin> f (B \\<union> {a, b}) \\<Longrightarrow>\n    substitutes_on A f", "fix B a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B a b.\n       \\<lbrakk>substitutes_on A f; B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B);\n        b \\<in> f (insert a (insert b B))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>B\\<subseteq>A.\n       \\<forall>a\\<in>A.\n          \\<forall>b\\<in>A.\n             b \\<notin> f (B \\<union> {b}) \\<longrightarrow>\n             b \\<notin> f (B \\<union> {a, b}) \\<Longrightarrow>\n    substitutes_on A f", "assume lhs: ?lhs and XXX: \"B \\<subseteq> A\" \"a \\<in> A\" \"b \\<in> A\" \"b \\<notin> f (insert b B)\" \"b \\<in> f (insert a (insert b B))\""], ["proof (state)\nthis:\n  substitutes_on A f\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n\ngoal (2 subgoals):\n 1. \\<And>B a b.\n       \\<lbrakk>substitutes_on A f; B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B);\n        b \\<in> f (insert a (insert b B))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>B\\<subseteq>A.\n       \\<forall>a\\<in>A.\n          \\<forall>b\\<in>A.\n             b \\<notin> f (B \\<union> {b}) \\<longrightarrow>\n             b \\<notin> f (B \\<union> {a, b}) \\<Longrightarrow>\n    substitutes_on A f", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"a \\<in> B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> B \\<Longrightarrow> False\n 2. a \\<notin> B \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  a \\<in> B\n\ngoal (2 subgoals):\n 1. a \\<in> B \\<Longrightarrow> False\n 2. a \\<notin> B \\<Longrightarrow> False", "with XXX"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n  a \\<in> B", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n  a \\<in> B\n\ngoal (1 subgoal):\n 1. False", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a \\<notin> B \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> B \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. a \\<notin> B \\<Longrightarrow> False", "with lhs XXX"], ["proof (chain)\npicking this:\n  substitutes_on A f\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n  a \\<notin> B", "show ?thesis"], ["proof (prove)\nusing this:\n  substitutes_on A f\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. False", "unfolding substitutes_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>B\\<subseteq>A.\n             \\<exists>a b.\n                {a, b} \\<subseteq> A - B \\<and>\n                b \\<notin> f (B \\<union> {b}) \\<and>\n                b \\<in> f (B \\<union> {a, b}))\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  b \\<in> f (insert a (insert b B))\n  a \\<notin> B\n\ngoal (1 subgoal):\n 1. False", "by (cases \"b \\<in> B\") (fastforce dest: spec[where x=\"B - {a, b}\"] simp: insert_commute insert_absorb)+"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       \\<forall>a\\<in>A.\n          \\<forall>b\\<in>A.\n             b \\<notin> f (B \\<union> {b}) \\<longrightarrow>\n             b \\<notin> f (B \\<union> {a, b}) \\<Longrightarrow>\n    substitutes_on A f", "qed (fastforce simp: substitutes_on_def)"], ["", "lemmas substitutes_onI = iffD2[OF substitutes_on_def2, rule_format, simplified]"], ["", "lemmas substitutes_onD = iffD1[OF substitutes_on_def2, rule_format, simplified]"], ["", "lemmas substitutesD = substitutes_onD[where A=UNIV, simplified]"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma substitutes_on_union:\n  assumes \"a \\<notin> f (B \\<union> {a})\"\n  assumes \"substitutes_on (A \\<union> B \\<union> {a}) f\"\n  assumes \"finite A\"\n  shows \"a \\<notin> f (A \\<union> B \\<union> {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> f (A \\<union> B \\<union> {a})", "using %invisible assms(3,1-2)"], ["proof (prove)\nusing this:\n  finite A\n  a \\<notin> f (B \\<union> {a})\n  substitutes_on (A \\<union> B \\<union> {a}) f\n\ngoal (1 subgoal):\n 1. a \\<notin> f (A \\<union> B \\<union> {a})", "by induct (simp_all add: insert_commute substitutes_on_def2 le_iff_sup)"], ["", "lemma substitutes_on_antimono:\n  assumes \"substitutes_on B f\"\n  assumes \"A \\<subseteq> B\"\n  shows \"substitutes_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  substitutes_on B f\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. substitutes_on A f", "unfolding substitutes_on_def2"], ["proof (prove)\nusing this:\n  \\<forall>Ba\\<subseteq>B.\n     \\<forall>a\\<in>B.\n        \\<forall>b\\<in>B.\n           b \\<notin> f (insert b Ba) \\<longrightarrow>\n           b \\<notin> f (insert a (insert b Ba))\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       \\<forall>a\\<in>A.\n          \\<forall>b\\<in>A.\n             b \\<notin> f (insert b B) \\<longrightarrow>\n             b \\<notin> f (insert a (insert b B))", "by auto"], ["", "text\\<open>\n\nThe equivalence with the monotonicity of alternative-rejection\nrequires a finiteness constraint.\n\n\\<close>"], ["", "lemma substitutes_on_Rf_mono_on:\n  assumes \"substitutes_on A f\"\n  assumes \"finite A\"\n  shows \"mono_on (Pow A) (Rf f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis.mono_on (Pow A) (Rf f)", "proof %invisible (rule mono_onI, rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; x \\<subseteq> y;\n        xa \\<in> Rf f x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> Rf f y", "fix B C x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; x \\<subseteq> y;\n        xa \\<in> Rf f x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> Rf f y", "assume \"B \\<in> Pow A\" \"C \\<in> Pow A\" \"B \\<subseteq> C\" \"x \\<in> Rf f B\""], ["proof (state)\nthis:\n  B \\<in> Pow A\n  C \\<in> Pow A\n  B \\<subseteq> C\n  x \\<in> Rf f B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x \\<in> Pow A; y \\<in> Pow A; x \\<subseteq> y;\n        xa \\<in> Rf f x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> Rf f y", "with assms substitutes_on_union[where a=x and A=C and B=B and f=f]"], ["proof (chain)\npicking this:\n  substitutes_on A f\n  finite A\n  \\<lbrakk>x \\<notin> f (B \\<union> {x});\n   substitutes_on (C \\<union> B \\<union> {x}) f; finite C\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> f (C \\<union> B \\<union> {x})\n  B \\<in> Pow A\n  C \\<in> Pow A\n  B \\<subseteq> C\n  x \\<in> Rf f B", "show \"x \\<in> Rf f C\""], ["proof (prove)\nusing this:\n  substitutes_on A f\n  finite A\n  \\<lbrakk>x \\<notin> f (B \\<union> {x});\n   substitutes_on (C \\<union> B \\<union> {x}) f; finite C\\<rbrakk>\n  \\<Longrightarrow> x \\<notin> f (C \\<union> B \\<union> {x})\n  B \\<in> Pow A\n  C \\<in> Pow A\n  B \\<subseteq> C\n  x \\<in> Rf f B\n\ngoal (1 subgoal):\n 1. x \\<in> Rf f C", "by (clarsimp simp: insert_absorb) (metis rev_finite_subset subsetCE substitutes_on_antimono sup.orderE)"], ["proof (state)\nthis:\n  x \\<in> Rf f C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Rf_mono_on_substitutes:\n  assumes \"mono_on (Pow A) (Rf f)\"\n  shows \"substitutes_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes_on A f", "proof %invisible (rule substitutes_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> f (insert a (insert b B))", "fix B a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> f (insert a (insert b B))", "assume \"B \\<subseteq> A\" \"a \\<in> A\" \"b \\<in> A\" \"b \\<notin> f (insert b B)\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A; b \\<in> A;\n        b \\<notin> f (insert b B)\\<rbrakk>\n       \\<Longrightarrow> b \\<notin> f (insert a (insert b B))", "with assms"], ["proof (chain)\npicking this:\n  Basis.mono_on (Pow A) (Rf f)\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)", "show \"b \\<notin> f (insert a (insert b B))\""], ["proof (prove)\nusing this:\n  Basis.mono_on (Pow A) (Rf f)\n  B \\<subseteq> A\n  a \\<in> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. b \\<notin> f (insert a (insert b B))", "by (auto elim: mono_onE[where x=\"insert b B\" and y=\"insert a (insert b B)\"])"], ["proof (state)\nthis:\n  b \\<notin> f (insert a (insert b B))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe above substitutes condition is equivalent to the\n@{emph \\<open>independence of irrelevant alternatives\\<close>}, AKA condition\n\\<open>\\<alpha>\\<close> due to \\citet{Sen:1970}. Intuitively if\n\\<open>a\\<close> is chosen from a set \\<open>A\\<close>, then it must\nbe chosen from every subset of \\<open>A\\<close> that it belongs\nto. Note the lack of finiteness assumptions here.\n\n\\<close>"], ["", "definition iia_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"iia_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>B. \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C)\""], ["", "abbreviation iia :: \"'a cfun \\<Rightarrow> bool\" where\n  \"iia \\<equiv> iia_on UNIV\""], ["", "lemmas %invisible iia_onI = iffD2[OF iia_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible iia_onD = iffD1[OF iia_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemma Rf_mono_on_iia_on:\n  shows \"mono_on (Pow A) (Rf f) \\<longleftrightarrow> iia_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis.mono_on (Pow A) (Rf f) = iia_on A f", "unfolding %invisible iia_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis.mono_on (Pow A) (Rf f) =\n    (\\<forall>B\\<subseteq>A.\n        \\<forall>C\\<subseteq>B.\n           \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C)", "by (rule iffI) (blast elim: mono_onE intro!: mono_onI)+"], ["", "lemma Rf_mono_iia:\n  shows \"mono (Rf f) \\<longleftrightarrow> iia f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Rf f) = iia f", "using %invisible Rf_mono_on_iia_on[of UNIV f] mono_on_mono"], ["proof (prove)\nusing this:\n  Basis.mono_on (Pow UNIV) (Rf f) = iia f\n  Basis.mono_on UNIV = mono\n\ngoal (1 subgoal):\n 1. mono (Rf f) = iia f", "by (simp add: fun_eq_iff) blast"], ["", "lemma substitutes_iia:\n  assumes \"finite A\"\n  shows \"substitutes_on A f \\<longleftrightarrow> iia_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutes_on A f = iia_on A f", "using %invisible Rf_mono_on_iia_on Rf_mono_on_substitutes substitutes_on_Rf_mono_on[OF _ assms]"], ["proof (prove)\nusing this:\n  Basis.mono_on (Pow ?A) (Rf ?f) = iia_on ?A ?f\n  Basis.mono_on (Pow ?A) (Rf ?f) \\<Longrightarrow> substitutes_on ?A ?f\n  substitutes_on A ?f \\<Longrightarrow> Basis.mono_on (Pow A) (Rf ?f)\n\ngoal (1 subgoal):\n 1. substitutes_on A f = iia_on A f", "by blast"], ["", "text\\<open>\n\nOne key result is that the choice function must be idempotent if it\nsatisfies @{const \"iia\"} or any of the equivalent conditions.\n\n\\<close>"], ["", "lemma iia_f_idem:\n  assumes \"f_range_on A f\"\n  assumes \"iia_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"f (f B) = f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f B) = f B", "using %invisible assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  iia_on A f\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (f B) = f B", "unfolding iia_on_def"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<forall>B\\<subseteq>A.\n     \\<forall>C\\<subseteq>B.\n        \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (f B) = f B", "by (meson f_range_onD f_range_on_antimono subset_antisym subset_eq)"], ["", "text\\<open>\n\n\\citet[p914, bottom right]{HatfieldMilgrom:2005} claim that the\n@{const \"substitutes\"} condition coincides with the\n@{emph \\<open>substitutable preferences\\<close>} condition for the college admissions\nproblem of \\citet[Definition~6.2]{RothSotomayor:1990}, which is\nsimilar to @{const \"iia\"}:\n\n\\<close>"], ["", "definition substitutable_preferences_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"substitutable_preferences_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>a\\<in>B. \\<forall>b\\<in>B. a \\<noteq> b \\<and> a \\<in> f B \\<longrightarrow> a \\<in> f (B - {b}))\""], ["", "lemmas %invisible substitutable_preferences_onI = iffD2[OF substitutable_preferences_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemma substitutable_preferences_on_substitutes_on:\n  shows \"substitutable_preferences_on A f \\<longleftrightarrow> substitutes_on A f\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutable_preferences_on A f = substitutes_on A f", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. substitutable_preferences_on A f \\<Longrightarrow> substitutes_on A f\n 2. substitutes_on A f \\<Longrightarrow> substitutable_preferences_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  substitutable_preferences_on A f\n\ngoal (2 subgoals):\n 1. substitutable_preferences_on A f \\<Longrightarrow> substitutes_on A f\n 2. substitutes_on A f \\<Longrightarrow> substitutable_preferences_on A f", "then"], ["proof (chain)\npicking this:\n  substitutable_preferences_on A f", "show ?rhs"], ["proof (prove)\nusing this:\n  substitutable_preferences_on A f\n\ngoal (1 subgoal):\n 1. substitutes_on A f", "unfolding substitutable_preferences_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>a\\<in>B.\n        \\<forall>b\\<in>B.\n           a \\<noteq> b \\<and> a \\<in> f B \\<longrightarrow>\n           a \\<in> f (B - {b})\n\ngoal (1 subgoal):\n 1. substitutes_on A f", "by - (rule substitutes_onI; metis Diff_insert_absorb insertCI insert_absorb insert_subset)"], ["proof (state)\nthis:\n  substitutes_on A f\n\ngoal (1 subgoal):\n 1. substitutes_on A f \\<Longrightarrow> substitutable_preferences_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. substitutes_on A f \\<Longrightarrow> substitutable_preferences_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  substitutes_on A f\n\ngoal (1 subgoal):\n 1. substitutes_on A f \\<Longrightarrow> substitutable_preferences_on A f", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. substitutable_preferences_on A f", "proof(rule substitutable_preferences_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> B; b \\<in> B; a \\<noteq> b;\n        a \\<in> f B\\<rbrakk>\n       \\<Longrightarrow> a \\<in> f (B - {b})", "fix B a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> B; b \\<in> B; a \\<noteq> b;\n        a \\<in> f B\\<rbrakk>\n       \\<Longrightarrow> a \\<in> f (B - {b})", "assume XXX: \"B \\<subseteq> A\" \"a \\<in> B\" \"b \\<in> B\" \"a \\<noteq> b\" \"a \\<in> f B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B\n\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> B; b \\<in> B; a \\<noteq> b;\n        a \\<in> f B\\<rbrakk>\n       \\<Longrightarrow> a \\<in> f (B - {b})", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B", "have \"a \\<in> A\" \"b \\<in> A\" \"B - {b} - {a} \\<subseteq> A\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B\n\ngoal (1 subgoal):\n 1. a \\<in> A &&& b \\<in> A &&& B - {b} - {a} \\<subseteq> A", "by blast+"], ["proof (state)\nthis:\n  a \\<in> A\n  b \\<in> A\n  B - {b} - {a} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B a b.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> B; b \\<in> B; a \\<noteq> b;\n        a \\<in> f B\\<rbrakk>\n       \\<Longrightarrow> a \\<in> f (B - {b})", "with \\<open>?rhs\\<close> XXX"], ["proof (chain)\npicking this:\n  substitutes_on A f\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B\n  a \\<in> A\n  b \\<in> A\n  B - {b} - {a} \\<subseteq> A", "show \"a \\<in> f (B - {b})\""], ["proof (prove)\nusing this:\n  substitutes_on A f\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B\n  a \\<in> A\n  b \\<in> A\n  B - {b} - {a} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. a \\<in> f (B - {b})", "unfolding substitutes_on_def2"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>a\\<in>A.\n        \\<forall>b\\<in>A.\n           b \\<notin> f (insert b B) \\<longrightarrow>\n           b \\<notin> f (insert a (insert b B))\n  B \\<subseteq> A\n  a \\<in> B\n  b \\<in> B\n  a \\<noteq> b\n  a \\<in> f B\n  a \\<in> A\n  b \\<in> A\n  B - {b} - {a} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. a \\<in> f (B - {b})", "by (metis insertE insert_Diff)"], ["proof (state)\nthis:\n  a \\<in> f (B - {b})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  substitutable_preferences_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\n\\citet[p152]{Moulin:1985} defines an equivalent @{emph \\<open>Chernoff\\<close>}\ncondition. Intuitively this captures the idea that ``a best choice in\nsome issue [set of alternatives] is still best if the issue shrinks.''\n\n\\<close>"], ["", "definition Chernoff_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>B. f B \\<inter> C \\<subseteq> f C)\""], ["", "abbreviation Chernoff :: \"'a cfun \\<Rightarrow> bool\" where\n  \"Chernoff \\<equiv> Chernoff_on UNIV\""], ["", "lemmas Chernoff_onI = iffD2[OF Chernoff_on_def, rule_format]"], ["", "lemmas Chernoff_def = Chernoff_on_def[where A=UNIV, simplified]"], ["", "lemma Chernoff_on_iia_on:\n  shows \"Chernoff_on A f \\<longleftrightarrow> iia_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f = iia_on A f", "unfolding %invisible Chernoff_on_def iia_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>B\\<subseteq>A.\n        \\<forall>C\\<subseteq>B. f B \\<inter> C \\<subseteq> f C) =\n    (\\<forall>B\\<subseteq>A.\n        \\<forall>C\\<subseteq>B.\n           \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C)", "by blast"], ["", "lemma Chernoff_on_union:\n  assumes \"Chernoff_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"B \\<subseteq> A\" \"C \\<subseteq> A\"\n  shows \"f (B \\<union> C) \\<subseteq> f B \\<union> f C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f B \\<union> f C", "using %invisible assms"], ["proof (prove)\nusing this:\n  Chernoff_on A f\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f B \\<union> f C", "unfolding Chernoff_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>C\\<subseteq>B. f B \\<inter> C \\<subseteq> f C\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  B \\<subseteq> A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f B \\<union> f C", "by clarsimp (metis (mono_tags, lifting) Int_iff Un_iff Un_subset_iff contra_subsetD inf_sup_ord(3,4))"], ["", "text\\<open>\n\n\\citet[p159]{Moulin:1985} states a series of equivalent formulations\nof the @{const \"Chernoff\"} condition. He also claims that these hold\nif the two sets are disjoint.\n\n\\<close>"], ["", "lemma Chernoff_a:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f B \\<union> C)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) \\<subseteq> f B \\<union> C)", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C \\<Longrightarrow>\n    Chernoff_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C \\<Longrightarrow>\n    Chernoff_on A f", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  Chernoff_on A f", "show ?rhs"], ["proof (prove)\nusing this:\n  f_range_on A f\n  Chernoff_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C", "by (auto dest: f_range_onD' Chernoff_on_union)"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C \\<Longrightarrow>\n    Chernoff_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C \\<Longrightarrow>\n    Chernoff_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> C \\<Longrightarrow>\n    Chernoff_on A f", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f", "proof(rule Chernoff_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "fix B C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "assume \"B \\<subseteq> A\" \"C \\<subseteq> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "with spec[OF spec[OF \\<open>?rhs\\<close>, where x=\"C\"], where x=\"B - C\"]"], ["proof (chain)\npicking this:\n  C \\<subseteq> A \\<and> B - C \\<subseteq> A \\<longrightarrow>\n  f (C \\<union> (B - C)) \\<subseteq> f C \\<union> (B - C)\n  B \\<subseteq> A\n  C \\<subseteq> B", "show \"f B \\<inter> C \\<subseteq> f C\""], ["proof (prove)\nusing this:\n  C \\<subseteq> A \\<and> B - C \\<subseteq> A \\<longrightarrow>\n  f (C \\<union> (B - C)) \\<subseteq> f C \\<union> (B - C)\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. f B \\<inter> C \\<subseteq> f C", "by (fastforce simp add: Un_absorb1)"], ["proof (state)\nthis:\n  f B \\<inter> C \\<subseteq> f C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Chernoff_b: \\<comment> \\<open>essentially the converse of @{thm [source] Chernoff_on_union}\\<close>\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f B \\<union> f C)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) \\<subseteq> f B \\<union> f C)", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C \\<Longrightarrow>\n    Chernoff_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C \\<Longrightarrow>\n    Chernoff_on A f", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  Chernoff_on A f", "show ?rhs"], ["proof (prove)\nusing this:\n  f_range_on A f\n  Chernoff_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C", "using Chernoff_on_union"], ["proof (prove)\nusing this:\n  f_range_on A f\n  Chernoff_on A f\n  \\<lbrakk>Chernoff_on ?A ?f; f_range_on ?A ?f; ?B \\<subseteq> ?A;\n   ?C \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f (?B \\<union> ?C) \\<subseteq> ?f ?B \\<union> ?f ?C\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C", "by blast"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f B \\<union> f C\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C \\<Longrightarrow>\n    Chernoff_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C \\<Longrightarrow>\n    Chernoff_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f B \\<union> f C\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f B \\<union> f C \\<Longrightarrow>\n    Chernoff_on A f", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f", "proof(rule Chernoff_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "fix B C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "assume \"B \\<subseteq> A\" \"C \\<subseteq> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> f B \\<inter> C \\<subseteq> f C", "with \\<open>f_range_on A f\\<close> spec[OF spec[OF \\<open>?rhs\\<close>, where x=\"C\"], where x=\"B - C\"]"], ["proof (chain)\npicking this:\n  f_range_on A f\n  C \\<subseteq> A \\<and> B - C \\<subseteq> A \\<longrightarrow>\n  f (C \\<union> (B - C)) \\<subseteq> f C \\<union> f (B - C)\n  B \\<subseteq> A\n  C \\<subseteq> B", "show \"f B \\<inter> C \\<subseteq> f C\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  C \\<subseteq> A \\<and> B - C \\<subseteq> A \\<longrightarrow>\n  f (C \\<union> (B - C)) \\<subseteq> f C \\<union> f (B - C)\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. f B \\<inter> C \\<subseteq> f C", "by (clarsimp simp: Un_absorb1) (blast dest: f_range_onD')"], ["proof (state)\nthis:\n  f B \\<inter> C \\<subseteq> f C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Chernoff_c:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f (f B \\<union> C))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) \\<subseteq> f (f B \\<union> C))", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C) \\<Longrightarrow>\n    Chernoff_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C) \\<Longrightarrow>\n    Chernoff_on A f", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C)", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "fix B C x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "assume B: \"B \\<subseteq> A\" and C: \"C \\<subseteq> A\" and x: \"x \\<in> f (B \\<union> C)\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "from B C"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  C \\<subseteq> A", "have \"f (B \\<union> C) \\<subseteq> f B \\<union> f C\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f B \\<union> f C", "by (rule Chernoff_on_union[OF \\<open>?lhs\\<close> \\<open>f_range_on A f\\<close>])"], ["proof (state)\nthis:\n  f (B \\<union> C) \\<subseteq> f B \\<union> f C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "with \\<open>f_range_on A f\\<close> C x"], ["proof (chain)\npicking this:\n  f_range_on A f\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n  f (B \\<union> C) \\<subseteq> f B \\<union> f C", "have \"x \\<in> f B \\<union> C\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n  f (B \\<union> C) \\<subseteq> f B \\<union> f C\n\ngoal (1 subgoal):\n 1. x \\<in> f B \\<union> C", "by (blast dest: f_range_onD)"], ["proof (state)\nthis:\n  x \\<in> f B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "moreover"], ["proof (state)\nthis:\n  x \\<in> f B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "from \\<open>f_range_on A f\\<close> B"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A", "have \"f B \\<union> C \\<subseteq> B \\<union> C\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f B \\<union> C \\<subseteq> B \\<union> C", "by (blast dest: f_range_onD)"], ["proof (state)\nthis:\n  f B \\<union> C \\<subseteq> B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "moreover"], ["proof (state)\nthis:\n  f B \\<union> C \\<subseteq> B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "note B C x"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>x \\<in> f (B \\<union> C); B \\<subseteq> A;\n        C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (f B \\<union> C)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> f B \\<union> C\n  f B \\<union> C \\<subseteq> B \\<union> C\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)", "show \"x \\<in> f (f B \\<union> C)\""], ["proof (prove)\nusing this:\n  x \\<in> f B \\<union> C\n  f B \\<union> C \\<subseteq> B \\<union> C\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. x \\<in> f (f B \\<union> C)", "using iia_onD[OF iffD1[OF Chernoff_on_iia_on \\<open>?lhs\\<close>]]"], ["proof (prove)\nusing this:\n  x \\<in> f B \\<union> C\n  f B \\<union> C \\<subseteq> B \\<union> C\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f (B \\<union> C)\n  \\<lbrakk>?B \\<subseteq> A; ?C \\<subseteq> ?B; ?a \\<in> ?C;\n   ?a \\<in> f ?B\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> f ?C\n\ngoal (1 subgoal):\n 1. x \\<in> f (f B \\<union> C)", "by (metis Un_subset_iff)"], ["proof (state)\nthis:\n  x \\<in> f (f B \\<union> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C) \\<Longrightarrow>\n    Chernoff_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C) \\<Longrightarrow>\n    Chernoff_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> C) \\<Longrightarrow>\n    Chernoff_on A f", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)", "show ?lhs"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "by (clarsimp simp: Chernoff_a[OF \\<open>f_range_on A f\\<close>])\n       (metis (no_types, lifting) Un_iff Un_subset_iff rev_subsetD subset_trans)"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Chernoff_d:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) \\<subseteq> f (f B \\<union> f C))\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) \\<subseteq> f (f B \\<union> f C))", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C) \\<Longrightarrow>\n    Chernoff_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<Longrightarrow>\n    \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n 2. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C) \\<Longrightarrow>\n    Chernoff_on A f", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "proof(intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<Longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "fix B C x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<Longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "assume BC: \"B \\<subseteq> A \\<and> C \\<subseteq> A\""], ["proof (state)\nthis:\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<Longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "with \\<open>f_range_on A f\\<close> \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  Chernoff_on A f\n  B \\<subseteq> A \\<and> C \\<subseteq> A", "have \"f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  Chernoff_on A f\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f (f B \\<union> C)", "by (metis Chernoff_c Un_commute)"], ["proof (state)\nthis:\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<Longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "with \\<open>f_range_on A f\\<close> BC"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> C)", "show \"f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "using iffD1[OF Chernoff_c[OF \\<open>f_range_on A f\\<close>] \\<open>?lhs\\<close>]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  B \\<subseteq> A \\<and> C \\<subseteq> A\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> C)\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "by (metis Un_commute inf.absorb_iff2 le_infI1)"], ["proof (state)\nthis:\n  f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C) \\<Longrightarrow>\n    Chernoff_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C) \\<Longrightarrow>\n    Chernoff_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n\ngoal (1 subgoal):\n 1. \\<forall>B C.\n       B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n       f (B \\<union> C) \\<subseteq> f (f B \\<union> f C) \\<Longrightarrow>\n    Chernoff_on A f", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)", "show ?lhs"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) \\<subseteq> f (f B \\<union> f C)\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "by (clarsimp simp: Chernoff_a[OF assms])\n       (metis (no_types, lifting) Un_iff Un_subset_iff rev_subsetD subset_trans)"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open> The @{emph \\<open>irrelevance of rejected contracts\\<close>} condition AKA @{emph \\<open>consistency\\<close>} AKA @{emph \\<open>Aizerman\\<close>} \\label{sec:cf-irc} \\<close>"], ["", "text\\<open>\n\n\\citet[\\S4]{AygunSonmez:2012-WP2} propose to repair the results of\n\\citet{HatfieldMilgrom:2005} by imposing the @{emph \\<open>irrelevance of\nrejected contracts\\<close>} (IRC) condition. Intuitively this requires the\nchoice function @{term \"f\"} to ignore unchosen alternatives.\n\n\\<close>"], ["", "definition irc_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"irc_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>a\\<in>A. a \\<notin> f (B \\<union> {a}) \\<longrightarrow> f (B \\<union> {a}) = f B)\""], ["", "abbreviation irc :: \"'a cfun \\<Rightarrow> bool\" where\n  \"irc \\<equiv> irc_on UNIV\""], ["", "lemmas %invisible irc_onI = iffD2[OF irc_on_def, rule_format, simplified]"], ["", "lemmas %invisible irc_onD = iffD1[OF irc_on_def, rule_format, simplified]"], ["", "lemmas %invisible irc_def = irc_on_def[where A=UNIV, simplified]"], ["", "lemmas %invisible ircI = iffD2[OF irc_def, rule_format, simplified]"], ["", "lemmas %invisible ircD = iffD1[OF irc_def, rule_format, simplified]"], ["", "lemma irc_on_discard:\n  assumes \"irc_on A f\"\n  assumes \"finite C\"\n  assumes \"B \\<union> C \\<subseteq> A\"\n  assumes \"f (B \\<union> C) \\<inter> C = {}\"\n  shows \"f (B \\<union> C) = f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (B \\<union> C) = f B", "using %invisible assms(2,3,4)"], ["proof (prove)\nusing this:\n  finite C\n  B \\<union> C \\<subseteq> A\n  f (B \\<union> C) \\<inter> C = {}\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) = f B", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>B \\<union> {} \\<subseteq> A;\n     f (B \\<union> {}) \\<inter> {} = {}\\<rbrakk>\n    \\<Longrightarrow> f (B \\<union> {}) = f B\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>B \\<union> F \\<subseteq> A;\n         f (B \\<union> F) \\<inter> F = {}\\<rbrakk>\n        \\<Longrightarrow> f (B \\<union> F) = f B;\n        B \\<union> insert x F \\<subseteq> A;\n        f (B \\<union> insert x F) \\<inter> insert x F = {}\\<rbrakk>\n       \\<Longrightarrow> f (B \\<union> insert x F) = f B", "case (insert c C)"], ["proof (state)\nthis:\n  finite C\n  c \\<notin> C\n  \\<lbrakk>B \\<union> C \\<subseteq> A;\n   f (B \\<union> C) \\<inter> C = {}\\<rbrakk>\n  \\<Longrightarrow> f (B \\<union> C) = f B\n  B \\<union> insert c C \\<subseteq> A\n  f (B \\<union> insert c C) \\<inter> insert c C = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>B \\<union> {} \\<subseteq> A;\n     f (B \\<union> {}) \\<inter> {} = {}\\<rbrakk>\n    \\<Longrightarrow> f (B \\<union> {}) = f B\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>B \\<union> F \\<subseteq> A;\n         f (B \\<union> F) \\<inter> F = {}\\<rbrakk>\n        \\<Longrightarrow> f (B \\<union> F) = f B;\n        B \\<union> insert x F \\<subseteq> A;\n        f (B \\<union> insert x F) \\<inter> insert x F = {}\\<rbrakk>\n       \\<Longrightarrow> f (B \\<union> insert x F) = f B", "with assms(1)"], ["proof (chain)\npicking this:\n  irc_on A f\n  finite C\n  c \\<notin> C\n  \\<lbrakk>B \\<union> C \\<subseteq> A;\n   f (B \\<union> C) \\<inter> C = {}\\<rbrakk>\n  \\<Longrightarrow> f (B \\<union> C) = f B\n  B \\<union> insert c C \\<subseteq> A\n  f (B \\<union> insert c C) \\<inter> insert c C = {}", "show ?case"], ["proof (prove)\nusing this:\n  irc_on A f\n  finite C\n  c \\<notin> C\n  \\<lbrakk>B \\<union> C \\<subseteq> A;\n   f (B \\<union> C) \\<inter> C = {}\\<rbrakk>\n  \\<Longrightarrow> f (B \\<union> C) = f B\n  B \\<union> insert c C \\<subseteq> A\n  f (B \\<union> insert c C) \\<inter> insert c C = {}\n\ngoal (1 subgoal):\n 1. f (B \\<union> insert c C) = f B", "unfolding irc_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>a\\<in>A.\n        a \\<notin> f (B \\<union> {a}) \\<longrightarrow>\n        f (B \\<union> {a}) = f B\n  finite C\n  c \\<notin> C\n  \\<lbrakk>B \\<union> C \\<subseteq> A;\n   f (B \\<union> C) \\<inter> C = {}\\<rbrakk>\n  \\<Longrightarrow> f (B \\<union> C) = f B\n  B \\<union> insert c C \\<subseteq> A\n  f (B \\<union> insert c C) \\<inter> insert c C = {}\n\ngoal (1 subgoal):\n 1. f (B \\<union> insert c C) = f B", "by simp (metis Un_subset_iff)"], ["proof (state)\nthis:\n  f (B \\<union> insert c C) = f B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<union> {} \\<subseteq> A;\n     f (B \\<union> {}) \\<inter> {} = {}\\<rbrakk>\n    \\<Longrightarrow> f (B \\<union> {}) = f B", "qed simp"], ["", "text\\<open>\n\nAn equivalent condition is called @{emph \\<open>consistency\\<close>} by some\n(\\citet[Definition~2]{ChambersYenmez:2013},\n\\citet[Equation~(14)]{Fleiner:2002}). Like @{const \"iia\"}, this\nformulation generalizes to infinite universes.\n\n\\<close>"], ["", "definition consistency_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"consistency_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>B. f B \\<subseteq> C \\<longrightarrow> f B = f C)\""], ["", "abbreviation consistency :: \"'a cfun \\<Rightarrow> bool\" where\n  \"consistency \\<equiv> consistency_on UNIV\""], ["", "lemmas %invisible consistency_onI = iffD2[OF consistency_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible consistency_onD = iffD1[OF consistency_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible consistency_def = consistency_on_def[where A=UNIV, simplified]"], ["", "lemmas %invisible consistencyD = iffD1[OF consistency_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemma irc_on_consistency_on:\n  assumes \"irc_on A f\"\n  assumes \"finite A\"\n  shows \"consistency_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency_on A f", "proof %invisible (rule consistency_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> f B = f C", "fix B C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> f B = f C", "assume \"B \\<subseteq>A\" \"f B \\<subseteq> C\" \"C \\<subseteq> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  f B \\<subseteq> C\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> f B = f C", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  f B \\<subseteq> C\n  C \\<subseteq> B", "have \"C \\<union> (B - f B) = B\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  f B \\<subseteq> C\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. C \\<union> Rf f B = B", "by blast"], ["proof (state)\nthis:\n  C \\<union> Rf f B = B\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n       \\<Longrightarrow> f B = f C", "with \\<open>B \\<subseteq>A\\<close> \\<open>finite A\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  finite A\n  C \\<union> Rf f B = B", "show \"f B = f C\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  finite A\n  C \\<union> Rf f B = B\n\ngoal (1 subgoal):\n 1. f B = f C", "using irc_on_discard[OF assms(1), where B=C and C=\"B - f B\"]"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  finite A\n  C \\<union> Rf f B = B\n  \\<lbrakk>finite (Rf f B); C \\<union> Rf f B \\<subseteq> A;\n   f (C \\<union> Rf f B) \\<inter> Rf f B = {}\\<rbrakk>\n  \\<Longrightarrow> f (C \\<union> Rf f B) = f C\n\ngoal (1 subgoal):\n 1. f B = f C", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  f B = f C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma consistency_on_irc_on:\n  assumes \"f_range_on A f\"\n  assumes \"consistency_on A f\"\n  shows \"irc_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irc_on A f", "proof %invisible (rule irc_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) = f B", "fix B b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) = f B", "assume \"B \\<subseteq> A\" \"b \\<in> A\" \"b \\<notin> f (insert b B)\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) = f B", "with assms"], ["proof (chain)\npicking this:\n  f_range_on A f\n  consistency_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)", "show \"f (insert b B) = f B\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  consistency_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. f (insert b B) = f B", "by - (erule consistency_onD; blast dest: f_range_onD')"], ["proof (state)\nthis:\n  f (insert b B) = f B\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThese conditions imply that @{term \"f\"} is idempotent:\n\n\\<close>"], ["", "lemma consistency_on_f_idem:\n  assumes \"f_range_on A f\"\n  assumes \"consistency_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"f (f B) = f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (f B) = f B", "using %invisible assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  consistency_on A f\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (f B) = f B", "by (metis consistency_onD f_range_onD order_refl)"], ["", "text\\<open>\n\n\\citet[p154]{Moulin:1985} defines a similar but weaker property he\ncalls @{emph \\<open>Aizerman\\<close>}:\n\n\\<close>"], ["", "definition Aizerman_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"Aizerman_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>B. f B \\<subseteq> C \\<longrightarrow> f C \\<subseteq> f B)\""], ["", "abbreviation Aizerman :: \"'a cfun \\<Rightarrow> bool\" where\n  \"Aizerman \\<equiv> Aizerman_on UNIV\""], ["", "lemmas %invisible Aizerman_onI = iffD2[OF Aizerman_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible Aizerman_onD = iffD1[OF Aizerman_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible Aizerman_def = Aizerman_on_def[where A=UNIV, simplified]"], ["", "lemma consistency_on_Aizerman_on:\n  assumes \"consistency_on A f\"\n  shows \"Aizerman_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aizerman_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  consistency_on A f\n\ngoal (1 subgoal):\n 1. Aizerman_on A f", "by (metis Aizerman_onI consistency_onD order_refl)"], ["", "text\\<open>\n\nThe converse requires @{term \"f\"} to be idempotent\n\\citep[p157]{Moulin:1985}:\n\n\\<close>"], ["", "lemma Aizerman_on_idem_on_consistency_on:\n  assumes \"Aizerman_on A f\"\n  assumes \"\\<forall>B\\<subseteq>A. f (f B) = f B\"\n  shows \"consistency_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency_on A f", "by %invisible (rule consistency_onI) (metis inf.coboundedI2 le_iff_inf set_eq_subset Aizerman_onD[OF assms(1)] assms(2))"], ["", "subsection\\<open> The @{emph \\<open>law of aggregate demand\\<close>} condition aka @{emph \\<open>size monotonicity\\<close>} \\label{sec:cf-lad} \\<close>"], ["", "text\\<open>\n\n\\citet[{\\S}III]{HatfieldMilgrom:2005} impose the @{emph \\<open>law of\naggregate demand\\<close>} (aka @{emph \\<open>size monotonicity\\<close>}) to obtain the rural\nhospitals theorem (\\S\\ref{sec:contracts-rh}). It captures the\nfollowing intuition:\n\\begin{quote}\n\n[...] Roughly, this law states that as the price falls, agents should\ndemand more of a good. Here, price falls correspond to more contracts\nbeing available, and more demand corresponds to taking on (weakly)\nmore contracts.\n\n\\end{quote}\n\nThe @{const \"card\"} function takes a finite set into its cardinality\n(as a natural number).\n\n\\<close>"], ["", "definition lad_on :: \"'a set \\<Rightarrow> 'a::finite cfun \\<Rightarrow> bool\" where\n  \"lad_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>B. card (f C) \\<le> card (f B))\""], ["", "abbreviation lad :: \"'a::finite cfun \\<Rightarrow> bool\" where\n  \"lad \\<equiv> lad_on UNIV\""], ["", "text\\<open>\n\nThis definition is identical amongst\n\\citet[{\\S}III]{HatfieldMilgrom:2005}, \\citet[(20)]{Fleiner:2002}, and\n\\citet[Definition~4]{AygunSonmez:2012-WP2}.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma lad_onD:\n  assumes \"lad_on A f\"\n  assumes \"C \\<subseteq> B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"card (f C) \\<le> card (f B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "using assms"], ["proof (prove)\nusing this:\n  lad_on A f\n  C \\<subseteq> B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "unfolding lad_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>C\\<subseteq>B. card (f C) \\<le> card (f B)\n  C \\<subseteq> B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "by blast"], ["", "lemma ladD:\n  assumes \"lad f\"\n  assumes \"\\<And>x. x \\<in> C \\<Longrightarrow> x \\<in> B\"\n  shows \"card (f C) \\<le> card (f B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "using assms"], ["proof (prove)\nusing this:\n  lad f\n  ?x \\<in> C \\<Longrightarrow> ?x \\<in> B\n\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "unfolding lad_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>UNIV.\n     \\<forall>C\\<subseteq>B. card (f C) \\<le> card (f B)\n  ?x \\<in> C \\<Longrightarrow> ?x \\<in> B\n\ngoal (1 subgoal):\n 1. card (f C) \\<le> card (f B)", "by (simp add: subsetI)"], ["", "(*>*)"], ["", "text\\<open>\n\n\\citet[\\S5, Proposition~1]{AygunSonmez:2012-WP2} show that @{const\n\"substitutes\"} and @{const \"lad\"} imply @{const \"irc\"}, which\ntherefore rescues many results in the matching-with-contracts\nliterature.\n\n\\<close>"], ["", "lemma lad_on_substitutes_on_irc_on:\n  assumes \"f_range_on A f\"\n  assumes \"substitutes_on A f\"\n  assumes \"lad_on A f\"\n  shows \"irc_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irc_on A f", "proof %invisible (rule irc_onI, rule card_seteq)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> finite (f B)\n 2. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) \\<subseteq> f B\n 3. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> card (f B) \\<le> card (f (insert a B))", "fix B b"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> finite (f B)\n 2. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) \\<subseteq> f B\n 3. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> card (f B) \\<le> card (f (insert a B))", "assume bB: \"B \\<subseteq> A\" \"b \\<in> A\" \"b \\<notin> f (insert b B)\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (3 subgoals):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> finite (f B)\n 2. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) \\<subseteq> f B\n 3. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> card (f B) \\<le> card (f (insert a B))", "show \"finite (f B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f B)", "by simp"], ["proof (state)\nthis:\n  finite (f B)\n\ngoal (2 subgoals):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> f (insert a B) \\<subseteq> f B\n 2. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> card (f B) \\<le> card (f (insert a B))", "show \"f (insert b B) \\<subseteq> f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (insert b B) \\<subseteq> f B", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f (insert b B) \\<Longrightarrow> x \\<in> f B", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f (insert b B) \\<Longrightarrow> x \\<in> f B", "assume x: \"x \\<in> f (insert b B)\""], ["proof (state)\nthis:\n  x \\<in> f (insert b B)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f (insert b B) \\<Longrightarrow> x \\<in> f B", "with \\<open>f_range_on A f\\<close> bB"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  x \\<in> f (insert b B)", "have \"insert x B = B \\<or> x = b\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  x \\<in> f (insert b B)\n\ngoal (1 subgoal):\n 1. insert x B = B \\<or> x = b", "by clarsimp (blast dest: f_range_onD')"], ["proof (state)\nthis:\n  insert x B = B \\<or> x = b\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f (insert b B) \\<Longrightarrow> x \\<in> f B", "with \\<open>substitutes_on A f\\<close> bB x"], ["proof (chain)\npicking this:\n  substitutes_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  x \\<in> f (insert b B)\n  insert x B = B \\<or> x = b", "show \"x \\<in> f B\""], ["proof (prove)\nusing this:\n  substitutes_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n  x \\<in> f (insert b B)\n  insert x B = B \\<or> x = b\n\ngoal (1 subgoal):\n 1. x \\<in> f B", "by (metis insert_subset substitutes_onD)"], ["proof (state)\nthis:\n  x \\<in> f B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (insert b B) \\<subseteq> f B\n\ngoal (1 subgoal):\n 1. \\<And>B a.\n       \\<lbrakk>B \\<subseteq> A; a \\<in> A;\n        a \\<notin> f (insert a B)\\<rbrakk>\n       \\<Longrightarrow> card (f B) \\<le> card (f (insert a B))", "from \\<open>lad_on A f\\<close> bB"], ["proof (chain)\npicking this:\n  lad_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)", "show \"card (f B) \\<le> card (f (insert b B))\""], ["proof (prove)\nusing this:\n  lad_on A f\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. card (f B) \\<le> card (f (insert b B))", "unfolding lad_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>C\\<subseteq>B. card (f C) \\<le> card (f B)\n  B \\<subseteq> A\n  b \\<in> A\n  b \\<notin> f (insert b B)\n\ngoal (1 subgoal):\n 1. card (f B) \\<le> card (f (insert b B))", "by (simp add: subset_insertI)"], ["proof (state)\nthis:\n  card (f B) \\<le> card (f (insert b B))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe converse does not hold.\n\n\\<close>"], ["", "subsection\\<open> The @{emph \\<open>expansion\\<close>} condition \\<close>"], ["", "text\\<open>\n\nAccording to \\citet[p152]{Moulin:1985}, a choice function satifies\n@{emph \\<open>expansion\\<close>} if an alternative chosen from two sets is also chosen\nfrom their union.\n\n\\<close>"], ["", "definition expansion_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"expansion_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>C\\<subseteq>A. f B \\<inter> f C \\<subseteq> f (B \\<union> C))\""], ["", "abbreviation expansion :: \"'a cfun \\<Rightarrow> bool\" where\n  \"expansion \\<equiv> expansion_on UNIV\""], ["", "lemmas %invisible expansion_onI = iffD2[OF expansion_on_def, rule_format]"], ["", "lemmas %invisible expansion_onD = iffD1[OF expansion_on_def, rule_format, THEN subsetD, simplified, unfolded conj_imp_eq_imp_imp]"], ["", "text\\<open>\n\nCondition \\<open>\\<gamma>\\<close> due to \\citet{Sen:1971} generalizes\n@{const \"expansion\"} to collections of sets of choices.\n\n\\<close>"], ["", "definition expansion_gamma_on :: \"'a set \\<Rightarrow> 'a set set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"expansion_gamma_on A As f \\<longleftrightarrow> (\\<Union>As\\<subseteq>A \\<and> As \\<noteq> {} \\<longrightarrow> (\\<Inter>A\\<in>As. f A) \\<subseteq> f (\\<Union>As))\""], ["", "definition expansion_gamma :: \"'a set set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"expansion_gamma \\<equiv> expansion_gamma_on UNIV\""], ["", "lemmas %invisible expansion_gamma_onI = iffD2[OF expansion_gamma_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible expansion_gamma_onE = iffD1[OF expansion_gamma_on_def, rule_format, THEN subsetD, simplified, unfolded conj_imp_eq_imp_imp]"], ["", "lemma expansion_gamma_expansion:\n  assumes \"\\<forall>As. expansion_gamma_on A As f\"\n  shows \"expansion_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expansion_on A f", "proof %invisible (rule expansion_onI, rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A;\n        x \\<in> f B \\<inter> f C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (B \\<union> C)", "fix B C x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A;\n        x \\<in> f B \\<inter> f C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (B \\<union> C)", "assume \"B \\<subseteq> A\" \"C \\<subseteq> A\" \"x \\<in> f B \\<inter> f C\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f B \\<inter> f C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A;\n        x \\<in> f B \\<inter> f C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (B \\<union> C)", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f B \\<inter> f C", "show \"x \\<in> f (B \\<union> C)\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f B \\<inter> f C\n\ngoal (1 subgoal):\n 1. x \\<in> f (B \\<union> C)", "using expansion_gamma_onE[OF spec[OF assms], where As=\"{B,C}\"]"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> A\n  x \\<in> f B \\<inter> f C\n  \\<lbrakk>\\<Union> {B, C} \\<subseteq> A; {B, C} \\<noteq> {};\n   \\<forall>x\\<in>{B, C}. ?c \\<in> f x\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> f (\\<Union> {B, C})\n\ngoal (1 subgoal):\n 1. x \\<in> f (B \\<union> C)", "by simp"], ["proof (state)\nthis:\n  x \\<in> f (B \\<union> C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma expansion_expansion_gamma:\n  assumes \"expansion_on A f\"\n  assumes \"finite As\"\n  shows \"expansion_gamma_on A As f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expansion_gamma_on A As f", "proof %invisible (rule expansion_gamma_onI[OF subsetI])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<Union> As \\<subseteq> A; As \\<noteq> {};\n        x \\<in> \\<Inter> (f ` As)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (\\<Union> As)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<Union> As \\<subseteq> A; As \\<noteq> {};\n        x \\<in> \\<Inter> (f ` As)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (\\<Union> As)", "assume \"\\<Union>As \\<subseteq> A\" \"As \\<noteq> {}\" \"x \\<in> (\\<Inter>A\\<in>As. f A)\""], ["proof (state)\nthis:\n  \\<Union> As \\<subseteq> A\n  As \\<noteq> {}\n  x \\<in> \\<Inter> (f ` As)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<Union> As \\<subseteq> A; As \\<noteq> {};\n        x \\<in> \\<Inter> (f ` As)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (\\<Union> As)", "from \\<open>finite As\\<close> this"], ["proof (chain)\npicking this:\n  finite As\n  \\<Union> As \\<subseteq> A\n  As \\<noteq> {}\n  x \\<in> \\<Inter> (f ` As)", "show \"x \\<in> f (\\<Union>As)\""], ["proof (prove)\nusing this:\n  finite As\n  \\<Union> As \\<subseteq> A\n  As \\<noteq> {}\n  x \\<in> \\<Inter> (f ` As)\n\ngoal (1 subgoal):\n 1. x \\<in> f (\\<Union> As)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Union> {} \\<subseteq> A; {} \\<noteq> {};\n     x \\<in> \\<Inter> (f ` {})\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f (\\<Union> {})\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<lbrakk>\\<Union> F \\<subseteq> A; F \\<noteq> {};\n         x \\<in> \\<Inter> (f ` F)\\<rbrakk>\n        \\<Longrightarrow> x \\<in> f (\\<Union> F);\n        \\<Union> (insert xa F) \\<subseteq> A; insert xa F \\<noteq> {};\n        x \\<in> \\<Inter> (f ` insert xa F)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (\\<Union> (insert xa F))", "case (insert b B)"], ["proof (state)\nthis:\n  finite B\n  b \\<notin> B\n  \\<lbrakk>\\<Union> B \\<subseteq> A; B \\<noteq> {};\n   x \\<in> \\<Inter> (f ` B)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> f (\\<Union> B)\n  \\<Union> (insert b B) \\<subseteq> A\n  insert b B \\<noteq> {}\n  x \\<in> \\<Inter> (f ` insert b B)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Union> {} \\<subseteq> A; {} \\<noteq> {};\n     x \\<in> \\<Inter> (f ` {})\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f (\\<Union> {})\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        \\<lbrakk>\\<Union> F \\<subseteq> A; F \\<noteq> {};\n         x \\<in> \\<Inter> (f ` F)\\<rbrakk>\n        \\<Longrightarrow> x \\<in> f (\\<Union> F);\n        \\<Union> (insert xa F) \\<subseteq> A; insert xa F \\<noteq> {};\n        x \\<in> \\<Inter> (f ` insert xa F)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f (\\<Union> (insert xa F))", "with assms"], ["proof (chain)\npicking this:\n  expansion_on A f\n  finite As\n  finite B\n  b \\<notin> B\n  \\<lbrakk>\\<Union> B \\<subseteq> A; B \\<noteq> {};\n   x \\<in> \\<Inter> (f ` B)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> f (\\<Union> B)\n  \\<Union> (insert b B) \\<subseteq> A\n  insert b B \\<noteq> {}\n  x \\<in> \\<Inter> (f ` insert b B)", "show ?case"], ["proof (prove)\nusing this:\n  expansion_on A f\n  finite As\n  finite B\n  b \\<notin> B\n  \\<lbrakk>\\<Union> B \\<subseteq> A; B \\<noteq> {};\n   x \\<in> \\<Inter> (f ` B)\\<rbrakk>\n  \\<Longrightarrow> x \\<in> f (\\<Union> B)\n  \\<Union> (insert b B) \\<subseteq> A\n  insert b B \\<noteq> {}\n  x \\<in> \\<Inter> (f ` insert b B)\n\ngoal (1 subgoal):\n 1. x \\<in> f (\\<Union> (insert b B))", "by (cases \"B = {}\") (auto dest: expansion_onD)"], ["proof (state)\nthis:\n  x \\<in> f (\\<Union> (insert b B))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Union> {} \\<subseteq> A; {} \\<noteq> {};\n     x \\<in> \\<Inter> (f ` {})\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f (\\<Union> {})", "qed simp"], ["proof (state)\nthis:\n  x \\<in> f (\\<Union> As)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe @{const \"expansion\"} condition plays a major role in the study of\nthe @{emph \\<open>rationalizability\\<close>} of choice functions, which we explore\nnext.\n\n\\<close>"], ["", "subsection\\<open> Axioms of revealed preference \\label{sec:cf-revealed_preference} \\<close>"], ["", "text\\<open>\n\nWe digress from our taxonomy of conditions on choice functions to\ndiscuss @{emph \\<open>rationalizability\\<close>}. A choice function is\n@{emph \\<open>rationalizable\\<close>} if there exists some binary relation that generates\nit, typically by taking the @{emph \\<open>greatest\\<close>} or @{emph \\<open>maximal\\<close>} elements\nof the given set of alternatives:\n\n\\<close>"], ["", "definition greatest :: \"'a rel \\<Rightarrow> 'a cfun\" where\n  \"greatest r X = {x\\<in>X. \\<forall>y\\<in>X. (y, x) \\<in> r}\""], ["", "definition maximal :: \"'a rel \\<Rightarrow> 'a cfun\" where\n  \"maximal r X = {x\\<in>X. \\<forall>y\\<in>X. \\<not>(x, y) \\<in> r}\""], ["", "lemma (in MaxR) greatest:\n  shows \"set_option (MaxR_opt X) = greatest r (X \\<inter> Field r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (MaxR_opt X) = greatest r (X \\<inter> Field r)", "using %invisible greatest_is_MaxR_opt MaxR_opt_is_greatest"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?A \\<inter> Field r;\n   \\<forall>y\\<in>?A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt ?A = Some ?x\n  \\<lbrakk>MaxR_opt ?A = Some ?x; ?y \\<in> ?A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n\ngoal (1 subgoal):\n 1. set_option (MaxR_opt X) = greatest r (X \\<inter> Field r)", "unfolding greatest_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?A \\<inter> Field r;\n   \\<forall>y\\<in>?A \\<inter> Field r. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> MaxR_opt ?A = Some ?x\n  \\<lbrakk>MaxR_opt ?A = Some ?x; ?y \\<in> ?A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n\ngoal (1 subgoal):\n 1. set_option (MaxR_opt X) =\n    {x \\<in> X \\<inter> Field r.\n     \\<forall>y\\<in>X \\<inter> Field r. (y, x) \\<in> r}", "by (blast dest: range_Some)"], ["", "(*<*)"], ["", "lemma greatest_r_mono:\n  assumes \"Above r X \\<subseteq> Above r' X\"\n  shows \"greatest r X \\<subseteq> greatest r' X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. greatest r X \\<subseteq> greatest r' X", "using assms"], ["proof (prove)\nusing this:\n  Above r X \\<subseteq> Above r' X\n\ngoal (1 subgoal):\n 1. greatest r X \\<subseteq> greatest r' X", "unfolding greatest_def Above_def"], ["proof (prove)\nusing this:\n  {b \\<in> Field r. \\<forall>a\\<in>X. (a, b) \\<in> r}\n  \\<subseteq> {b \\<in> Field r'. \\<forall>a\\<in>X. (a, b) \\<in> r'}\n\ngoal (1 subgoal):\n 1. {x \\<in> X. \\<forall>y\\<in>X. (y, x) \\<in> r}\n    \\<subseteq> {x \\<in> X. \\<forall>y\\<in>X. (y, x) \\<in> r'}", "by (fast intro: FieldI1)"], ["", "lemmas greatest_r_mono' = subsetD[OF greatest_r_mono, rotated]"], ["", "lemma greatest_Above:\n  shows \"greatest r X = Above r X \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. greatest r X = Above r X \\<inter> X", "unfolding greatest_def Above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. \\<forall>y\\<in>X. (y, x) \\<in> r} =\n    {b \\<in> Field r. \\<forall>a\\<in>X. (a, b) \\<in> r} \\<inter> X", "by (blast intro: FieldI1)"], ["", "(*>*)"], ["", "text\\<open>\n\nNote that @{const \"greatest\"} requires the relation to be reflexive\nand total, and @{const \"maximal\"} requires it to be irreflexive, for\nthe choice functions to ever yield non-empty sets.\n\nThis game of uncovering the preference relations (if any) underlying a\nchoice function goes by the name of @{emph \\<open>revealed preference\\<close>}. (In\ncontrast, later we show how these conditions guarantee the existence\nof stable many-to-one matches.) See \\citet{Moulin:1985} and\n\\citet{Border:2012} for background, intuition and critique, and\n\\citet{Sen:1971} for further classical results and proofs.\n\nWe adopt the following notion here:\n\n\\<close>"], ["", "definition rationalizes_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> 'a rel \\<Rightarrow> bool\" where\n  \"rationalizes_on A f r \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. f B = greatest r B)\""], ["", "abbreviation rationalizes :: \"'a cfun \\<Rightarrow> 'a rel \\<Rightarrow> bool\" where\n  \"rationalizes \\<equiv> rationalizes_on UNIV\""], ["", "lemma %invisible rationalizes_onI:\n  assumes \"f_range_on A f\"\n  assumes \"\\<And>B x y. \\<lbrakk>B \\<subseteq> A; x \\<in> f B; y \\<in> B\\<rbrakk> \\<Longrightarrow> (y, x) \\<in> r\"\n  assumes \"\\<And>B x. \\<lbrakk>B \\<subseteq> A; x \\<in> B; \\<forall>y\\<in>B. (y, x) \\<in> r\\<rbrakk> \\<Longrightarrow> x \\<in> f B\"\n  shows \"rationalizes_on A f r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rationalizes_on A f r", "using assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<lbrakk>?B \\<subseteq> A; ?x \\<in> f ?B; ?y \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n  \\<lbrakk>?B \\<subseteq> A; ?x \\<in> ?B;\n   \\<forall>y\\<in>?B. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> f ?B\n\ngoal (1 subgoal):\n 1. rationalizes_on A f r", "unfolding rationalizes_on_def greatest_def"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<lbrakk>?B \\<subseteq> A; ?x \\<in> f ?B; ?y \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n  \\<lbrakk>?B \\<subseteq> A; ?x \\<in> ?B;\n   \\<forall>y\\<in>?B. (y, ?x) \\<in> r\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> f ?B\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       f B = {x \\<in> B. \\<forall>y\\<in>B. (y, x) \\<in> r}", "by (auto dest: f_range_onD)"], ["", "text\\<open>\n\nIn words, relation @{term \"r\"} rationalizes the choice function @{term\n\"f\"} over universe @{term \"A\"} if @{term \"f B\"} picks out the @{term\n\"greatest\"} elements of @{term \"B \\<subseteq> A\"} with respect to\n@{term \"r\"}. At this point @{term \"r\"} can be any relation that does\nthe job, but soon enough we will ask that it satisfy some familiar\nordering properties.\n\nThe analysis begins by determining under what constraints @{term \"f\"}\ncan be rationalized, continues by establishing some properties of all\nrationalizable choice functions, and concludes by considering what it\ntakes to establish stronger properties.\n\nFollowing \\citet[\\S5, Definition~2]{Border:2012} and\n\\citet[Definition~2]{Sen:1971}, we can generate the @{emph \\<open>revealed\nweakly preferred\\<close>} relation for the choice function @{term \"f\"}:\n\n\\<close>"], ["", "definition rwp_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> 'a rel\" where\n  \"rwp_on A f = {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\""], ["", "abbreviation rwp :: \"'a cfun \\<Rightarrow> 'a rel\" where\n  \"rwp \\<equiv> rwp_on UNIV\""], ["", "lemma %invisible rwp_on_Field:\n  assumes \"f_range_on A f\"\n  shows \"Field (rwp_on A f) \\<subseteq> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (rwp_on A f) \\<subseteq> A", "using assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n\ngoal (1 subgoal):\n 1. Field (rwp_on A f) \\<subseteq> A", "unfolding f_range_on_def rwp_on_def Field_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. Domain\n     {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B} \\<union>\n    Range {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n    \\<subseteq> A", "by auto"], ["", "lemma rwp_on_refl_on:\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"refl_on A (rwp_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on A (rwp_on A f)", "proof %invisible (rule refl_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. rwp_on A f \\<subseteq> A \\<times> A\n 2. \\<And>x. x \\<in> A \\<Longrightarrow> (x, x) \\<in> rwp_on A f", "from \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f", "show \"rwp_on A f \\<subseteq> A \\<times> A\""], ["proof (prove)\nusing this:\n  f_range_on A f\n\ngoal (1 subgoal):\n 1. rwp_on A f \\<subseteq> A \\<times> A", "unfolding rwp_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n    \\<subseteq> A \\<times> A", "by blast"], ["proof (state)\nthis:\n  rwp_on A f \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> (x, x) \\<in> rwp_on A f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> (x, x) \\<in> rwp_on A f", "assume \"x \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> (x, x) \\<in> rwp_on A f", "with assms"], ["proof (chain)\npicking this:\n  f_range_on A f\n  decisive_on A f\n  x \\<in> A", "show \"(x, x) \\<in> rwp_on A f\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  decisive_on A f\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> rwp_on A f", "unfolding rwp_on_def decisive_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (x, x)\n    \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by (fast dest: spec[where x=\"{x}\"] intro: exI[where x=\"{x}\"])"], ["proof (state)\nthis:\n  (x, x) \\<in> rwp_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nIn words, if it is ever possible that @{term \"x \\<in> B\"} is available\nand @{term \"f B\"} chooses @{term \"y\"}, then @{term \"y\"} is taken to\nalways be at least as good as @{term \"x\"}.\n\nThe @{emph \\<open>V-axiom\\<close>} asserts that whatever is revealed to be at least as\ngood as anything else on offer is chosen:\n\n\\<close>"], ["", "definition V_axiom_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"V_axiom_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. \\<forall>y\\<in>B. (\\<forall>x \\<in> B. (x, y) \\<in> rwp_on A f) \\<longrightarrow> y \\<in> f B)\""], ["", "abbreviation V_axiom :: \"'a cfun \\<Rightarrow> bool\" where\n  \"V_axiom \\<equiv> V_axiom_on UNIV\""], ["", "text\\<open>\n\nThis axiom characterizes rationality; see\n\\citet[Theorem~7]{Border:2012}. \\citet[\\S3]{Sen:1971} calls a decisive\nchoice function that satisfies @{const \"V_axiom\"} @{emph \\<open>normal\\<close>}.\n\n\\<close>"], ["", "lemma rationalizes_on_f_range_on_V_axiom_on:\n  assumes \"rationalizes_on A f r\"\n  shows \"f_range_on A f\"\n    and \"V_axiom_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_range_on A f &&& V_axiom_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  rationalizes_on A f r\n\ngoal (1 subgoal):\n 1. f_range_on A f &&& V_axiom_on A f", "unfolding V_axiom_on_def rationalizes_on_def greatest_def f_range_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     f B = {x \\<in> B. \\<forall>y\\<in>B. (y, x) \\<in> r}\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A. f B \\<subseteq> B &&&\n    \\<forall>B\\<subseteq>A.\n       \\<forall>y\\<in>B.\n          (\\<forall>x\\<in>B.\n              (x, y)\n              \\<in> {(x, y).\n                     \\<exists>B\\<subseteq>A.\n                        x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n          y \\<in> f B", "by simp_all blast+"], ["", "lemma f_range_on_V_axiom_on_rationalizes_on:\n  assumes \"f_range_on A f\"\n  assumes \"V_axiom_on A f\"\n  shows \"rationalizes_on A f (rwp_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rationalizes_on A f (rwp_on A f)", "using %invisible assms rwp_on_Field[OF assms(1)]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  V_axiom_on A f\n  Field (rwp_on A f) \\<subseteq> A\n\ngoal (1 subgoal):\n 1. rationalizes_on A f (rwp_on A f)", "unfolding V_axiom_on_def rationalizes_on_def greatest_def f_range_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B\\<subseteq>A.\n     \\<forall>y\\<in>B.\n        (\\<forall>x\\<in>B.\n            (x, y)\n            \\<in> {(x, y).\n                   \\<exists>B\\<subseteq>A.\n                      x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n        y \\<in> f B\n  Field {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n  \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       f B =\n       {x \\<in> B.\n        \\<forall>y\\<in>B.\n           (y, x)\n           \\<in> {(x, y).\n                  \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}}", "by auto"], ["", "theorem V_axiom_on_rationalizes_on:\n  shows \"(f_range_on A f \\<and> V_axiom_on A f) \\<longleftrightarrow> (\\<exists>r. rationalizes_on A f r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f_range_on A f \\<and> V_axiom_on A f) =\n    (\\<exists>r. rationalizes_on A f r)", "using %invisible rationalizes_on_f_range_on_V_axiom_on f_range_on_V_axiom_on_rationalizes_on"], ["proof (prove)\nusing this:\n  rationalizes_on ?A ?f ?r \\<Longrightarrow> f_range_on ?A ?f\n  rationalizes_on ?A ?f ?r \\<Longrightarrow> V_axiom_on ?A ?f\n  \\<lbrakk>f_range_on ?A ?f; V_axiom_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> rationalizes_on ?A ?f (rwp_on ?A ?f)\n\ngoal (1 subgoal):\n 1. (f_range_on A f \\<and> V_axiom_on A f) =\n    (\\<exists>r. rationalizes_on A f r)", "by blast"], ["", "text\\<open>\n\nWe could also ask that @{term \"f\"} be determined directly by how it\nbehaves on pairs (\\citet{Sen:1971}, \\citet[p151]{Moulin:1985}), which\nturns out to be equivalent:\n\n\\<close>"], ["", "definition rationalizable_binary_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"rationalizable_binary_on A f \\<longleftrightarrow> (\\<forall>B\\<subseteq>A. f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}})\""], ["", "abbreviation rationalizable_binary :: \"'a cfun \\<Rightarrow> bool\" where\n  \"rationalizable_binary \\<equiv> rationalizable_binary_on UNIV\""], ["", "lemma %invisible rationalizable_binary_onI:\n  assumes \"f_range_on A f\"\n  assumes \"\\<And>B x y. \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk> \\<Longrightarrow> y \\<in> f {x, y}\"\n  assumes \"\\<And>B y. \\<lbrakk>B \\<subseteq> A; y \\<in> B; \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk> \\<Longrightarrow> y \\<in> f B\"\n  shows \"rationalizable_binary_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f", "unfolding rationalizable_binary_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}}", "using assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<lbrakk>?B \\<subseteq> A; ?y \\<in> f ?B; ?x \\<in> ?B;\n   ?y \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> f {?x, ?y}\n  \\<lbrakk>?B \\<subseteq> A; ?y \\<in> ?B;\n   \\<forall>x\\<in>?B. ?y \\<in> f {x, ?y}\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> f ?B\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}}", "by (blast dest: f_range_onD' intro: FieldI1)"], ["", "theorem V_axiom_realizable_binary:\n  assumes \"f_range_on A f\"\n  shows \"V_axiom_on A f \\<longleftrightarrow> rationalizable_binary_on A f\"\n(*<*)\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. V_axiom_on A f = rationalizable_binary_on A f", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. V_axiom_on A f \\<Longrightarrow> rationalizable_binary_on A f\n 2. rationalizable_binary_on A f \\<Longrightarrow> V_axiom_on A f", "assume lhs: ?lhs"], ["proof (state)\nthis:\n  V_axiom_on A f\n\ngoal (2 subgoals):\n 1. V_axiom_on A f \\<Longrightarrow> rationalizable_binary_on A f\n 2. rationalizable_binary_on A f \\<Longrightarrow> V_axiom_on A f", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f", "proof(rule rationalizable_binary_onI[OF assms])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "fix B x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "assume \"B \\<subseteq> A\" \"y \\<in> f B\" \"x \\<in> B\" \"y \\<in> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with lhs"], ["proof (chain)\npicking this:\n  V_axiom_on A f\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B", "show \"y \\<in> f {x, y}\""], ["proof (prove)\nusing this:\n  V_axiom_on A f\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<in> f {x, y}", "unfolding V_axiom_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>y\\<in>B.\n        (\\<forall>x\\<in>B.\n            (x, y)\n            \\<in> {(x, y).\n                   \\<exists>B\\<subseteq>A.\n                      x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n        y \\<in> f B\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<in> f {x, y}", "by (auto dest: spec[where x=\"{x, y}\"])"], ["proof (state)\nthis:\n  y \\<in> f {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "fix B y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "assume \"B \\<subseteq> A\" \"y \\<in> B\" \"\\<forall>x\\<in>B. y \\<in> f {x, y}\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with lhs"], ["proof (chain)\npicking this:\n  V_axiom_on A f\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}", "show \"y \\<in> f B\""], ["proof (prove)\nusing this:\n  V_axiom_on A f\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n\ngoal (1 subgoal):\n 1. y \\<in> f B", "unfolding V_axiom_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>y\\<in>B.\n        (\\<forall>x\\<in>B.\n            (x, y)\n            \\<in> {(x, y).\n                   \\<exists>B\\<subseteq>A.\n                      x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n        y \\<in> f B\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n\ngoal (1 subgoal):\n 1. y \\<in> f B", "by clarsimp (metis Un_subset_iff insertI1 insert_is_Un mk_disjoint_insert)"], ["proof (state)\nthis:\n  y \\<in> f B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rationalizable_binary_on A f\n\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f \\<Longrightarrow> V_axiom_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f \\<Longrightarrow> V_axiom_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  rationalizable_binary_on A f\n\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f \\<Longrightarrow> V_axiom_on A f", "then"], ["proof (chain)\npicking this:\n  rationalizable_binary_on A f", "show ?lhs"], ["proof (prove)\nusing this:\n  rationalizable_binary_on A f\n\ngoal (1 subgoal):\n 1. V_axiom_on A f", "unfolding V_axiom_on_def rwp_on_def rationalizable_binary_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}}\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       \\<forall>y\\<in>B.\n          (\\<forall>x\\<in>B.\n              (x, y)\n              \\<in> {(x, y).\n                     \\<exists>B\\<subseteq>A.\n                        x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n          y \\<in> f B", "by force"], ["proof (state)\nthis:\n  V_axiom_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nAll rationalizable choice functions satisfy @{const \"iia\"} and @{const\n\"expansion\"} (\\citet{Sen:1971}, \\citet[p152]{Moulin:1985}).\n\n\\<close>"], ["", "lemma rationalizable_binary_on_iia_on:\n  assumes \"f_range_on A f\"\n  assumes \"rationalizable_binary_on A f\"\n  shows \"iia_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iia_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  rationalizable_binary_on A f\n\ngoal (1 subgoal):\n 1. iia_on A f", "unfolding iia_on_def rationalizable_binary_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B\\<subseteq>A.\n     f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}}\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       \\<forall>C\\<subseteq>B.\n          \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C", "by simp (meson contra_subsetD)"], ["", "lemma rationalizable_binary_on_expansion_on:\n  assumes \"f_range_on A f\"\n  assumes \"rationalizable_binary_on A f\"\n  shows \"expansion_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expansion_on A f", "using  %invisible assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n  rationalizable_binary_on A f\n\ngoal (1 subgoal):\n 1. expansion_on A f", "unfolding rationalizable_binary_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B\\<subseteq>A.\n     f B = {y \\<in> B. \\<forall>x\\<in>B. y \\<in> f {x, y}}\n\ngoal (1 subgoal):\n 1. expansion_on A f", "by - (rule expansion_onI; auto)"], ["", "text\\<open>\n\nThe converse requires the set of alternatives to be finite, and\nmoreover fails if the choice function is not @{const \"decisive\"}.\n\n\\<close>"], ["", "lemma rationalizable_binary_on_converse:\n  fixes f :: \"'a::finite cfun\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  assumes \"iia_on A f\"\n  assumes \"expansion_on A f\"\n  shows \"rationalizable_binary_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rationalizable_binary_on A f", "proof %invisible (rule rationalizable_binary_onI[OF assms(1)])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "fix B x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "assume \"B \\<subseteq> A\" \"y \\<in> f B\" \"x \\<in> B\" \"y \\<in> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> f B; x \\<in> B; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f {x, y}\n 2. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with \\<open>iia_on A f\\<close>"], ["proof (chain)\npicking this:\n  iia_on A f\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B", "show \"y \\<in> f {x, y}\""], ["proof (prove)\nusing this:\n  iia_on A f\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<in> f {x, y}", "unfolding iia_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A.\n     \\<forall>C\\<subseteq>B.\n        \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C\n  B \\<subseteq> A\n  y \\<in> f B\n  x \\<in> B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. y \\<in> f {x, y}", "by fastforce"], ["proof (state)\nthis:\n  y \\<in> f {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "fix B y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "assume XXX: \"y \\<in> B\" and YYY: \"\\<forall>x\\<in>B. y \\<in> f {x, y}\" \"B \\<subseteq> A\""], ["proof (state)\nthis:\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "have \"y \\<in> f (insert y C)\" if \"C \\<subseteq> B\" for C"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> f (insert y C)", "using finite[of C] that XXX YYY"], ["proof (prove)\nusing this:\n  finite C\n  C \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. y \\<in> f (insert y C)", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> B; y \\<in> B;\n     \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> y \\<in> f {y}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> B; y \\<in> B;\n         \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> y \\<in> f (insert y F);\n        insert x F \\<subseteq> B; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f (insert y (insert x F))", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{} \\<subseteq> B; y \\<in> B;\n     \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> y \\<in> f {y}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> B; y \\<in> B;\n         \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> y \\<in> f (insert y F);\n        insert x F \\<subseteq> B; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f (insert y (insert x F))", "with \\<open>decisive_on A f\\<close>"], ["proof (chain)\npicking this:\n  decisive_on A f\n  {} \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A", "show ?case"], ["proof (prove)\nusing this:\n  decisive_on A f\n  {} \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. y \\<in> f {y}", "unfolding decisive_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  {} \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. y \\<in> f {y}", "by force"], ["proof (state)\nthis:\n  y \\<in> f {y}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> B; y \\<in> B;\n         \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> y \\<in> f (insert y F);\n        insert x F \\<subseteq> B; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f (insert y (insert x F))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> B; y \\<in> B;\n         \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> y \\<in> f (insert y F);\n        insert x F \\<subseteq> B; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f (insert y (insert x F))", "case (insert b C)"], ["proof (state)\nthis:\n  finite C\n  b \\<notin> C\n  \\<lbrakk>C \\<subseteq> B; y \\<in> B; \\<forall>x\\<in>B. y \\<in> f {x, y};\n   B \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> y \\<in> f (insert y C)\n  insert b C \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<lbrakk>F \\<subseteq> B; y \\<in> B;\n         \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> y \\<in> f (insert y F);\n        insert x F \\<subseteq> B; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f (insert y (insert x F))", "with \\<open>expansion_on A f\\<close>"], ["proof (chain)\npicking this:\n  expansion_on A f\n  finite C\n  b \\<notin> C\n  \\<lbrakk>C \\<subseteq> B; y \\<in> B; \\<forall>x\\<in>B. y \\<in> f {x, y};\n   B \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> y \\<in> f (insert y C)\n  insert b C \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A", "show ?case"], ["proof (prove)\nusing this:\n  expansion_on A f\n  finite C\n  b \\<notin> C\n  \\<lbrakk>C \\<subseteq> B; y \\<in> B; \\<forall>x\\<in>B. y \\<in> f {x, y};\n   B \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> y \\<in> f (insert y C)\n  insert b C \\<subseteq> B\n  y \\<in> B\n  \\<forall>x\\<in>B. y \\<in> f {x, y}\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. y \\<in> f (insert y (insert b C))", "by (force dest!: expansion_onD[where C=\"{b, y}\" and B=\"insert y C\"] simp: insert_commute)"], ["proof (state)\nthis:\n  y \\<in> f (insert y (insert b C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?C \\<subseteq> B \\<Longrightarrow> y \\<in> f (insert y ?C)\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "note this[OF subset_refl]"], ["proof (state)\nthis:\n  y \\<in> f (insert y B)\n\ngoal (1 subgoal):\n 1. \\<And>B y.\n       \\<lbrakk>B \\<subseteq> A; y \\<in> B;\n        \\<forall>x\\<in>B. y \\<in> f {x, y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with XXX"], ["proof (chain)\npicking this:\n  y \\<in> B\n  y \\<in> f (insert y B)", "show \"y \\<in> f B\""], ["proof (prove)\nusing this:\n  y \\<in> B\n  y \\<in> f (insert y B)\n\ngoal (1 subgoal):\n 1. y \\<in> f B", "by (simp add: insert_absorb)"], ["proof (state)\nthis:\n  y \\<in> f B\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThat settles the issue of existence, but it is not clear that the\nrelation is really ``rational'' (for instance, @{term \"rwp_on A f\"}\nneed not be transitive). Therefore the analysis continues by further\nconstraining the choice function so that it is rationalized by\nfamiliar ordering relations.\n\nFor instance, the following shows that the @{emph \\<open>axioms of revealed\npreference\\<close>} are rationalized by total preorders \\citep[Definitions~8\nand~13]{Sen:1971}\\footnote{For \\citet[p9]{Sen:1970}, an ordering is\ncomplete (total), reflexive, and transitive. Alternative names are:\ncomplete pre-ordering, complete quasi-ordering, and weak\nordering.}. These are alo equivalent to some congruence axioms due to\nSamuelson \\citep{Border:2012}.\n\nWe define @{term \"x\"} to be @{emph \\<open>strictly revealed-preferred to\\<close>}\n@{term \"y\"} if there is a situation where both are on offer and only\n@{term \"y\"} is chosen:\n\n\\<close>"], ["", "definition rsp_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> 'a rel\" where \\<comment> \\<open>\\citep[Definition~8]{Sen:1971}\\<close>\n  \"rsp_on A f = {(x, y). \\<exists>B\\<subseteq>A. x \\<in> Rf f B \\<and> y \\<in> f B}\""], ["", "abbreviation rsp :: \"'a cfun \\<Rightarrow> 'a rel\" where\n  \"rsp \\<equiv> rsp_on UNIV\""], ["", "text\\<open>\n\nThis relation is typically denoted by @{term \"P\"}, for strict\npreference. The not-worse-than relation @{term \"R\"} is recovered by:\n\n\\<close>"], ["", "definition rspR_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> 'a rel\" where \\<comment> \\<open>\\citep[Definition~9]{Sen:1971}\\<close>\n  \"rspR_on A f = {(x, y). {x, y} \\<subseteq> A \\<and> (y, x) \\<notin> rsp_on A f}\""], ["", "abbreviation rspR :: \"'a cfun \\<Rightarrow> 'a rel\" where\n  \"rspR \\<equiv> rspR_on UNIV\""], ["", "lemma %invisible rsp_on_range:\n  assumes \"f_range_on A f\"\n  shows \"rsp_on A f \\<subseteq> A \\<times> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsp_on A f \\<subseteq> A \\<times> A", "using assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n\ngoal (1 subgoal):\n 1. rsp_on A f \\<subseteq> A \\<times> A", "unfolding rsp_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. {(x, y). \\<exists>B\\<subseteq>A. x \\<in> Rf f B \\<and> y \\<in> f B}\n    \\<subseteq> A \\<times> A", "by blast"], ["", "text\\<open>\n\n\\citet[p309]{Sen:1971} defines the @{emph \\<open>weak axiom of revealed\npreference\\<close>} (WARP) as follows:\n\n\\<close>"], ["", "definition warp_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"warp_on A f \\<longleftrightarrow> (\\<forall>(x, y)\\<in>rsp_on A f. (y, x) \\<notin> rwp_on A f)\""], ["", "abbreviation warp :: \"'a cfun \\<Rightarrow> bool\" where\n  \"warp \\<equiv> warp_on UNIV\""], ["", "text\\<open>\n\nThe @{emph \\<open>strong axiom of revealed preference\\<close>} (SARP) is essentially\nthe transitive closure of @{const \"warp\"} \\citep[p309]{Sen:1971}:\n\n\\<close>"], ["", "definition sarp_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"sarp_on A f \\<longleftrightarrow> (\\<forall>(x, y)\\<in>(rsp_on A f)\\<^sup>+. (y, x) \\<notin> rwp_on A f)\""], ["", "abbreviation sarp :: \"'a cfun \\<Rightarrow> bool\" where\n  \"sarp \\<equiv> sarp_on UNIV\""], ["", "lemma %invisible sarp_onI:\n  assumes \"\\<And>x y. (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow> (y, x) \\<notin> rwp_on A f\"\n  shows \"sarp_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sarp_on A f", "using assms"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n  (?y, ?x) \\<notin> rwp_on A f\n\ngoal (1 subgoal):\n 1. sarp_on A f", "unfolding sarp_on_def"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n  (?y, ?x) \\<notin> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>(rsp_on A f)\\<^sup>+. (y, x) \\<notin> rwp_on A f", "by blast"], ["", "lemma sarp_on_warp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  assumes \"sarp_on A f\"\n  shows \"warp_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. warp_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  sarp_on A f\n\ngoal (1 subgoal):\n 1. warp_on A f", "unfolding sarp_on_def warp_on_def rwp_on_def rsp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A.\n                    x \\<in> Rf f B \\<and> y \\<in> f B}\\<^sup>+.\n     (y, x)\n     \\<notin> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\n             \\<in>{(x, y).\n                   \\<exists>B\\<subseteq>A.\n                      x \\<in> Rf f B \\<and> y \\<in> f B}.\n       (y, x)\n       \\<notin> {(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by blast"], ["", "lemma rsp_on_irrefl:\n  \"A \\<noteq> {} \\<Longrightarrow> irrefl (rsp_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> irrefl (rsp_on A f)", "unfolding %invisible rsp_on_def irrefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<forall>a.\n       (a, a)\n       \\<notin> {(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> Rf f B \\<and> y \\<in> f B}", "by fastforce"], ["", "text\\<open>\n\nFor decisive choice functions, @{const \"warp\"} implies @{const\n\"sarp\"}. We show this following \\citet{Sen:1971}, via the @{emph \\<open>weak\ncongruence axiom\\<close>} (WCA): if @{term \"f\"} chooses @{term \"x\"} from some\nset @{term \"B\"} and @{term \"y\"} is revealed to be weakly preferred,\nthen @{term \"f\"} must choose @{term \"y\"} from @{term \"B\"} as well.\n\n\\<close>"], ["", "definition wca_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"wca_on A f \\<longleftrightarrow> (\\<forall>(x, y)\\<in>rwp_on A f. \\<forall>B\\<subseteq>A. x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B)\""], ["", "abbreviation wca :: \"'a cfun \\<Rightarrow> bool\" where\n  \"wca \\<equiv> wca_on UNIV\""], ["", "lemma %invisible wca_onI:\n  assumes \"\\<And>B x y. \\<lbrakk> B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B; y \\<in> B \\<rbrakk> \\<Longrightarrow> y \\<in> f B\"\n  shows \"wca_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wca_on A f", "unfolding wca_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>rwp_on A f.\n       \\<forall>B\\<subseteq>A.\n          x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?B \\<subseteq> A; (?x, ?y) \\<in> rwp_on A f; ?x \\<in> f ?B;\n   ?y \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> f ?B\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>rwp_on A f.\n       \\<forall>B\\<subseteq>A.\n          x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B", "by blast"], ["", "text\\<open>\n\nDecisive choice functions that satisfy @{const \"wca\"} are rationalized\nby total preorders, in particular @{const \"rwp\"}, and the converse\nobtains if they are normal.\n\n\\<close>"], ["", "lemma wca_on_V_axiom_on:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"V_axiom_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_axiom_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n\ngoal (1 subgoal):\n 1. V_axiom_on A f", "unfolding V_axiom_on_def wca_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  f_range_on A f\n  decisive_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A.\n       \\<forall>y\\<in>B.\n          (\\<forall>x\\<in>B.\n              (x, y)\n              \\<in> {(x, y).\n                     \\<exists>B\\<subseteq>A.\n                        x \\<in> B \\<and> y \\<in> f B}) \\<longrightarrow>\n          y \\<in> f B", "by clarsimp (metis (mono_tags) ex_in_conv f_range_onD'[where A=A and f=f] decisive_onD[where A=A and f=f])"], ["", "lemma wca_on_total_on:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"total_on A (rwp_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A (rwp_on A f)", "proof %invisible(rule total_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> rwp_on A f \\<or>\n                         (y, x) \\<in> rwp_on A f", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> rwp_on A f \\<or>\n                         (y, x) \\<in> rwp_on A f", "assume \"x \\<in> A\" \"y \\<in> A\" \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> rwp_on A f \\<or>\n                         (y, x) \\<in> rwp_on A f", "with assms"], ["proof (chain)\npicking this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y", "show \"(x, y) \\<in> rwp_on A f \\<or> (y, x) \\<in> rwp_on A f\""], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> rwp_on A f \\<or> (y, x) \\<in> rwp_on A f", "unfolding wca_on_def decisive_on_def rwp_on_def total_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  x \\<in> A\n  y \\<in> A\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {(x, y).\n           \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B} \\<or>\n    (y, x)\n    \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by (fast dest: spec[where x=\"{x,y}\"] intro: exI[where x=\"{x,y}\"])"], ["proof (state)\nthis:\n  (x, y) \\<in> rwp_on A f \\<or> (y, x) \\<in> rwp_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rwp_on_trans:\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"trans (rwp_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (rwp_on A f)", "proof %invisible (rule transI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "assume \"(x, y) \\<in> rwp_on A f\" \"(y, z) \\<in> rwp_on A f\""], ["proof (state)\nthis:\n  (x, y) \\<in> rwp_on A f\n  (y, z) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> rwp_on A f\n  (y, z) \\<in> rwp_on A f", "obtain B C where \"B \\<union> C \\<subseteq> A\" \"x \\<in> B\" \"y \\<in> f B\" \"y \\<in> C\" \"z \\<in> f C\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> rwp_on A f\n  (y, z) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        \\<lbrakk>B \\<union> C \\<subseteq> A; x \\<in> B; y \\<in> f B;\n         y \\<in> C; z \\<in> f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rwp_on_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n  (y, z)\n  \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}\n\ngoal (1 subgoal):\n 1. (\\<And>B C.\n        \\<lbrakk>B \\<union> C \\<subseteq> A; x \\<in> B; y \\<in> f B;\n         y \\<in> C; z \\<in> f C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B \\<union> C \\<subseteq> A\n  x \\<in> B\n  y \\<in> f B\n  y \\<in> C\n  z \\<in> f C\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "from \\<open>x \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> B", "have \"x \\<in> B \\<union> C\""], ["proof (prove)\nusing this:\n  x \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<union> C", "by blast"], ["proof (state)\nthis:\n  x \\<in> B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "moreover"], ["proof (state)\nthis:\n  x \\<in> B \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "have \"z \\<in> f (B \\<union> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> f (B \\<union> C)", "proof(cases \"y \\<in> f (B \\<union> C)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)\n 2. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "case True"], ["proof (state)\nthis:\n  y \\<in> f (B \\<union> C)\n\ngoal (2 subgoals):\n 1. y \\<in> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)\n 2. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "with \\<open>wca_on A f\\<close> \\<open>f_range_on A f\\<close> \\<open>y \\<in> C\\<close> \\<open>z \\<in> f C\\<close> \\<open>B \\<union> C \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  wca_on A f\n  f_range_on A f\n  y \\<in> C\n  z \\<in> f C\n  B \\<union> C \\<subseteq> A\n  y \\<in> f (B \\<union> C)", "show ?thesis"], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  y \\<in> C\n  z \\<in> f C\n  B \\<union> C \\<subseteq> A\n  y \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. z \\<in> f (B \\<union> C)", "unfolding wca_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  f_range_on A f\n  y \\<in> C\n  z \\<in> f C\n  B \\<union> C \\<subseteq> A\n  y \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. z \\<in> f (B \\<union> C)", "by simp (meson \\<open>B \\<union> C \\<subseteq> A\\<close> f_range_onD' inf_sup_ord(4) subsetCE)"], ["proof (state)\nthis:\n  z \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "case False"], ["proof (state)\nthis:\n  y \\<notin> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "with assms \\<open>B \\<union> C \\<subseteq> A\\<close> \\<open>y \\<in> f B\\<close> \\<open>z \\<in> f C\\<close>"], ["proof (chain)\npicking this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  B \\<union> C \\<subseteq> A\n  y \\<in> f B\n  z \\<in> f C\n  y \\<notin> f (B \\<union> C)", "obtain w where \"w \\<in> f (B \\<union> C) \\<and> w \\<in> C\""], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  B \\<union> C \\<subseteq> A\n  y \\<in> f B\n  z \\<in> f C\n  y \\<notin> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> f (B \\<union> C) \\<and> w \\<in> C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding wca_on_def decisive_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  f_range_on A f\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  B \\<union> C \\<subseteq> A\n  y \\<in> f B\n  z \\<in> f C\n  y \\<notin> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<in> f (B \\<union> C) \\<and> w \\<in> C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: ex_in_conv[symmetric] dest!: spec[where x=\"B \\<union> C\"])\n         (metis Un_iff \\<open>B \\<union> C \\<subseteq> A\\<close> f_range_onD')"], ["proof (state)\nthis:\n  w \\<in> f (B \\<union> C) \\<and> w \\<in> C\n\ngoal (1 subgoal):\n 1. y \\<notin> f (B \\<union> C) \\<Longrightarrow> z \\<in> f (B \\<union> C)", "with \\<open>wca_on A f\\<close> \\<open>f_range_on A f\\<close> \\<open>B \\<union> C \\<subseteq> A\\<close> \\<open>z \\<in> f C\\<close>"], ["proof (chain)\npicking this:\n  wca_on A f\n  f_range_on A f\n  B \\<union> C \\<subseteq> A\n  z \\<in> f C\n  w \\<in> f (B \\<union> C) \\<and> w \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  B \\<union> C \\<subseteq> A\n  z \\<in> f C\n  w \\<in> f (B \\<union> C) \\<and> w \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> f (B \\<union> C)", "unfolding wca_on_def rwp_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  f_range_on A f\n  B \\<union> C \\<subseteq> A\n  z \\<in> f C\n  w \\<in> f (B \\<union> C) \\<and> w \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> f (B \\<union> C)", "by simp (meson \\<open>B \\<union> C \\<subseteq> A\\<close> f_range_onD' inf_sup_ord(4) subsetCE)"], ["proof (state)\nthis:\n  z \\<in> f (B \\<union> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "moreover"], ["proof (state)\nthis:\n  z \\<in> f (B \\<union> C)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "note \\<open>B \\<union> C \\<subseteq> A\\<close>"], ["proof (state)\nthis:\n  B \\<union> C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> rwp_on A f; (y, z) \\<in> rwp_on A f\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> rwp_on A f", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> B \\<union> C\n  z \\<in> f (B \\<union> C)\n  B \\<union> C \\<subseteq> A", "show \"(x, z) \\<in> rwp_on A f\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<union> C\n  z \\<in> f (B \\<union> C)\n  B \\<union> C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> rwp_on A f", "unfolding rwp_on_def"], ["proof (prove)\nusing this:\n  x \\<in> B \\<union> C\n  z \\<in> f (B \\<union> C)\n  B \\<union> C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (x, z)\n    \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by blast"], ["proof (state)\nthis:\n  (x, z) \\<in> rwp_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wca_on_V_axiom_on_preorder_on: \\<comment> \\<open>\\citet[T.1, T.3 part]{Sen:1970}\\<close>\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"wca_on A f \\<longleftrightarrow> V_axiom_on A f \\<and> preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wca_on A f =\n    (V_axiom_on A f \\<and>\n     preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f))", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. wca_on A f \\<Longrightarrow>\n    V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n 2. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and>\n    total_on A (rwp_on A f) \\<Longrightarrow>\n    wca_on A f", "assume ?lhs"], ["proof (state)\nthis:\n  wca_on A f\n\ngoal (2 subgoals):\n 1. wca_on A f \\<Longrightarrow>\n    V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n 2. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and>\n    total_on A (rwp_on A f) \\<Longrightarrow>\n    wca_on A f", "with rwp_on_refl_on rwp_on_trans wca_on_V_axiom_on wca_on_total_on assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> refl_on ?A (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> trans (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> V_axiom_on ?A ?f\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> total_on ?A (rwp_on ?A ?f)\n  f_range_on A f\n  decisive_on A f\n  wca_on A f", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> refl_on ?A (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> trans (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> V_axiom_on ?A ?f\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> total_on ?A (rwp_on ?A ?f)\n  f_range_on A f\n  decisive_on A f\n  wca_on A f\n\ngoal (1 subgoal):\n 1. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)", "unfolding preorder_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> refl_on ?A (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> trans (rwp_on ?A ?f)\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> V_axiom_on ?A ?f\n  \\<lbrakk>wca_on ?A ?f; f_range_on ?A ?f; decisive_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> total_on ?A (rwp_on ?A ?f)\n  f_range_on A f\n  decisive_on A f\n  wca_on A f\n\ngoal (1 subgoal):\n 1. V_axiom_on A f \\<and>\n    (refl_on A (rwp_on A f) \\<and> trans (rwp_on A f)) \\<and>\n    total_on A (rwp_on A f)", "by blast"], ["proof (state)\nthis:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n\ngoal (1 subgoal):\n 1. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and>\n    total_on A (rwp_on A f) \\<Longrightarrow>\n    wca_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and>\n    total_on A (rwp_on A f) \\<Longrightarrow>\n    wca_on A f", "assume rhs: ?rhs"], ["proof (state)\nthis:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n\ngoal (1 subgoal):\n 1. V_axiom_on A f \\<and>\n    preorder_on A (rwp_on A f) \\<and>\n    total_on A (rwp_on A f) \\<Longrightarrow>\n    wca_on A f", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. wca_on A f", "proof(rule wca_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "fix B x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "assume \"B \\<subseteq> A\" \"(x, y) \\<in> rwp_on A f\" \"x \\<in> f B\" \"y \\<in> B\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  (x, y) \\<in> rwp_on A f\n  x \\<in> f B\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "from \\<open>B \\<subseteq> A\\<close> \\<open>x \\<in> f B\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  x \\<in> f B", "have \"\\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> f B\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f", "unfolding rwp_on_def"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> f B\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B.\n       (z, x)\n       \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by blast"], ["proof (state)\nthis:\n  \\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with rhs \\<open>(x, y) \\<in> rwp_on A f\\<close>"], ["proof (chain)\npicking this:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n  (x, y) \\<in> rwp_on A f\n  \\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f", "have \"\\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f\""], ["proof (prove)\nusing this:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n  (x, y) \\<in> rwp_on A f\n  \\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f", "unfolding preorder_on_def"], ["proof (prove)\nusing this:\n  V_axiom_on A f \\<and>\n  (refl_on A (rwp_on A f) \\<and> trans (rwp_on A f)) \\<and>\n  total_on A (rwp_on A f)\n  (x, y) \\<in> rwp_on A f\n  \\<forall>z\\<in>B. (z, x) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f", "by (blast elim: transE)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. \\<And>B x y.\n       \\<lbrakk>B \\<subseteq> A; (x, y) \\<in> rwp_on A f; x \\<in> f B;\n        y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> y \\<in> f B", "with rhs \\<open>B \\<subseteq> A\\<close> \\<open>y \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f", "show \"y \\<in> f B\""], ["proof (prove)\nusing this:\n  V_axiom_on A f \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. y \\<in> f B", "unfolding V_axiom_on_def"], ["proof (prove)\nusing this:\n  (\\<forall>B\\<subseteq>A.\n      \\<forall>y\\<in>B.\n         (\\<forall>x\\<in>B. (x, y) \\<in> rwp_on A f) \\<longrightarrow>\n         y \\<in> f B) \\<and>\n  preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f)\n  B \\<subseteq> A\n  y \\<in> B\n  \\<forall>z\\<in>B. (z, y) \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. y \\<in> f B", "by blast"], ["proof (state)\nthis:\n  y \\<in> f B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wca_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma wca_on_rwp_on_rspR_on: \\<comment> \\<open>\\citet[T.2]{Sen:1970}\\<close>\n  assumes \"wca_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"rwp_on A f = rspR_on A f\"\n(*<*)\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rwp_on A f = rspR_on A f", "proof(rule set_elem_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> rwp_on A f \\<Longrightarrow> x \\<in> rspR_on A f\n 2. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> rwp_on A f \\<Longrightarrow> x \\<in> rspR_on A f\n 2. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "assume \"x \\<in> ?lhs\""], ["proof (state)\nthis:\n  x \\<in> rwp_on A f\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> rwp_on A f \\<Longrightarrow> x \\<in> rspR_on A f\n 2. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "with \\<open>wca_on A f\\<close> rwp_on_refl_on[OF assms(2,3)]"], ["proof (chain)\npicking this:\n  wca_on A f\n  refl_on A (rwp_on A f)\n  x \\<in> rwp_on A f", "show \"x \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  wca_on A f\n  refl_on A (rwp_on A f)\n  x \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. x \\<in> rspR_on A f", "unfolding wca_on_def rsp_on_def rspR_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\\<in>rwp_on A f.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  refl_on A (rwp_on A f)\n  x \\<in> rwp_on A f\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y).\n             {x, y} \\<subseteq> A \\<and>\n             (y, x)\n             \\<notin> {(x, y).\n                       \\<exists>B\\<subseteq>A.\n                          x \\<in> Rf f B \\<and> y \\<in> f B}}", "by (force dest: refl_onD1 refl_onD2)"], ["proof (state)\nthis:\n  x \\<in> rspR_on A f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> rspR_on A f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rspR_on A f \\<Longrightarrow> x \\<in> rwp_on A f", "with assms"], ["proof (chain)\npicking this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  x \\<in> rspR_on A f", "show \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  wca_on A f\n  f_range_on A f\n  decisive_on A f\n  x \\<in> rspR_on A f\n\ngoal (1 subgoal):\n 1. x \\<in> rwp_on A f", "unfolding wca_on_def rsp_on_def rspR_on_def rwp_on_def decisive_on_def"], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\n           \\<in>{(x, y).\n                 \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n     \\<forall>B\\<subseteq>A.\n        x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B\n  f_range_on A f\n  \\<forall>B\\<subseteq>A. B \\<noteq> {} \\<longrightarrow> f B \\<noteq> {}\n  x \\<in> {(x, y).\n           {x, y} \\<subseteq> A \\<and>\n           (y, x)\n           \\<notin> {(x, y).\n                     \\<exists>B\\<subseteq>A.\n                        x \\<in> Rf f B \\<and> y \\<in> f B}}\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}", "by (auto 3 0 simp: split_def\n               intro!: exI[where x=\"{fst x, snd x}\"]\n                dest!: spec[where x=\"{fst x, snd x}\"]\n                 dest: f_range_onD')"], ["proof (state)\nthis:\n  x \\<in> rwp_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma rwp_on_rspR_on_wca_on: \\<comment> \\<open>\\citet[T.2]{Sen:1970}\\<close>\n  assumes \"rwp_on A f = rspR_on A f\"\n  shows \"wca_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wca_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  rwp_on A f = rspR_on A f\n\ngoal (1 subgoal):\n 1. wca_on A f", "unfolding wca_on_def rsp_on_def rspR_on_def"], ["proof (prove)\nusing this:\n  rwp_on A f =\n  {(x, y).\n   {x, y} \\<subseteq> A \\<and>\n   (y, x)\n   \\<notin> {(x, y).\n             \\<exists>B\\<subseteq>A. x \\<in> Rf f B \\<and> y \\<in> f B}}\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>rwp_on A f.\n       \\<forall>B\\<subseteq>A.\n          x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B", "by blast"], ["", "lemma wca_on_warp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  shows \"wca_on A f \\<longleftrightarrow> warp_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wca_on A f = warp_on A f", "unfolding %invisible warp_on_def wca_on_def rsp_on_def rwp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(x, y)\n              \\<in>{(x, y).\n                    \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B}.\n        \\<forall>B\\<subseteq>A.\n           x \\<in> f B \\<and> y \\<in> B \\<longrightarrow> y \\<in> f B) =\n    (\\<forall>(x, y)\n              \\<in>{(x, y).\n                    \\<exists>B\\<subseteq>A.\n                       x \\<in> Rf f B \\<and> y \\<in> f B}.\n        (y, x)\n        \\<notin> {(x, y).\n                  \\<exists>B\\<subseteq>A. x \\<in> B \\<and> y \\<in> f B})", "by blast"], ["", "lemma warp_on_sarp_on: \\<comment> \\<open>\\citet[T.3 part]{Sen:1970}\\<close>\n  assumes \"warp_on A f\"\n  assumes \"f_range_on A f\"\n  assumes \"decisive_on A f\"\n  shows \"sarp_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sarp_on A f", "proof(rule sarp_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "from \\<open>warp_on A f\\<close>"], ["proof (chain)\npicking this:\n  warp_on A f", "have \"wca_on A f\""], ["proof (prove)\nusing this:\n  warp_on A f\n\ngoal (1 subgoal):\n 1. wca_on A f", "unfolding wca_on_warp_on"], ["proof (prove)\nusing this:\n  warp_on A f\n\ngoal (1 subgoal):\n 1. warp_on A f", "."], ["proof (state)\nthis:\n  wca_on A f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "then"], ["proof (chain)\npicking this:\n  wca_on A f", "have XXX: \"rwp_on A f = rspR_on A f\"\n        and YYY: \"preorder_on A (rspR_on A f)\"\n        and ZZZ: \"total_on A (rspR_on A f)\""], ["proof (prove)\nusing this:\n  wca_on A f\n\ngoal (1 subgoal):\n 1. rwp_on A f = rspR_on A f &&&\n    preorder_on A (rspR_on A f) &&& total_on A (rspR_on A f)", "using %invisible wca_on_rwp_on_rspR_on[OF _ assms(2,3)] wca_on_V_axiom_on_preorder_on[OF assms(2,3)] wca_on_total_on[OF _ assms(2,3)]"], ["proof (prove)\nusing this:\n  wca_on A f\n  wca_on A f \\<Longrightarrow> rwp_on A f = rspR_on A f\n  wca_on A f =\n  (V_axiom_on A f \\<and>\n   preorder_on A (rwp_on A f) \\<and> total_on A (rwp_on A f))\n  wca_on A f \\<Longrightarrow> total_on A (rwp_on A f)\n\ngoal (1 subgoal):\n 1. rwp_on A f = rspR_on A f &&&\n    preorder_on A (rspR_on A f) &&& total_on A (rspR_on A f)", "by fastforce+"], ["proof (state)\nthis:\n  rwp_on A f = rspR_on A f\n  preorder_on A (rspR_on A f)\n  total_on A (rspR_on A f)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "assume \"(a, b) \\<in> (rsp_on A f)\\<^sup>+\""], ["proof (state)\nthis:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+", "have \"{a, b} \\<subseteq> A\" and \"(b, a) \\<notin> rspR_on A f\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n\ngoal (1 subgoal):\n 1. {a, b} \\<subseteq> A &&& (b, a) \\<notin> rspR_on A f", "proof(induct a b)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> {a, b} \\<subseteq> A\n 2. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 4. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case (r_into_trancl a b)"], ["proof (state)\nthis:\n  (a, b) \\<in> rsp_on A f\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> {a, b} \\<subseteq> A\n 2. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 4. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "{"], ["proof (state)\nthis:\n  (a, b) \\<in> rsp_on A f\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> {a, b} \\<subseteq> A\n 2. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 4. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> {a, b} \\<subseteq> A\n 2. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 4. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "from r_into_trancl rsp_on_range[OF assms(2)]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. {a, b} \\<subseteq> A", "by blast"], ["proof (state)\nthis:\n  {a, b} \\<subseteq> A\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "}"], ["proof (state)\nthis:\n  {a, b} \\<subseteq> A\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "{"], ["proof (state)\nthis:\n  {a, b} \\<subseteq> A\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> rsp_on A f \\<Longrightarrow> (b, a) \\<notin> rspR_on A f\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 3. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "from r_into_trancl"], ["proof (chain)\npicking this:\n  (a, b) \\<in> rsp_on A f", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> rsp_on A f\n\ngoal (1 subgoal):\n 1. (b, a) \\<notin> rspR_on A f", "by (simp add: rspR_on_def)"], ["proof (state)\nthis:\n  (b, a) \\<notin> rspR_on A f\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "}"], ["proof (state)\nthis:\n  (b, a) \\<notin> rspR_on A f\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case (trancl_into_trancl a b c)"], ["proof (state)\nthis:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "{"], ["proof (state)\nthis:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> {a, c} \\<subseteq> A\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "from trancl_into_trancl rsp_on_range[OF assms(2)]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A\n\ngoal (1 subgoal):\n 1. {a, c} \\<subseteq> A", "by blast"], ["proof (state)\nthis:\n  {a, c} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "}"], ["proof (state)\nthis:\n  {a, c} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "{"], ["proof (state)\nthis:\n  {a, c} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> (rsp_on A f)\\<^sup>+; {a, b} \\<subseteq> A;\n        (b, a) \\<notin> rspR_on A f; (b, c) \\<in> rsp_on A f\\<rbrakk>\n       \\<Longrightarrow> (c, a) \\<notin> rspR_on A f", "from trancl_into_trancl rsp_on_range[OF assms(2)] YYY ZZZ"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A\n  preorder_on A (rspR_on A f)\n  total_on A (rspR_on A f)", "show ?case"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A\n  preorder_on A (rspR_on A f)\n  total_on A (rspR_on A f)\n\ngoal (1 subgoal):\n 1. (c, a) \\<notin> rspR_on A f", "unfolding total_on_def preorder_on_def"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (rsp_on A f)\\<^sup>+\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n  (b, c) \\<in> rsp_on A f\n  rsp_on A f \\<subseteq> A \\<times> A\n  refl_on A (rspR_on A f) \\<and> trans (rspR_on A f)\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A.\n        x \\<noteq> y \\<longrightarrow>\n        (x, y) \\<in> rspR_on A f \\<or> (y, x) \\<in> rspR_on A f\n\ngoal (1 subgoal):\n 1. (c, a) \\<notin> rspR_on A f", "by clarsimp (metis (no_types, lifting) case_prodD mem_Collect_eq rspR_on_def transD)"], ["proof (state)\nthis:\n  (c, a) \\<notin> rspR_on A f\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (c, a) \\<notin> rspR_on A f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x, y) \\<in> (rsp_on A f)\\<^sup>+ \\<Longrightarrow>\n       (y, x) \\<notin> rwp_on A f", "with XXX"], ["proof (chain)\npicking this:\n  rwp_on A f = rspR_on A f\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f", "show \"(b, a) \\<notin> rwp_on A f\""], ["proof (prove)\nusing this:\n  rwp_on A f = rspR_on A f\n  {a, b} \\<subseteq> A\n  (b, a) \\<notin> rspR_on A f\n\ngoal (1 subgoal):\n 1. (b, a) \\<notin> rwp_on A f", "by simp"], ["proof (state)\nthis:\n  (b, a) \\<notin> rwp_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe @{const \"decisive\"} constraint here is necessary: consider a\nCondorcet cycle over @{term \"{x, y, z}\"}: forcing @{term \"f {x, y,\nz}\"} to be non-empty resolves this.\n\n\\citet{Sen:1971} proves that these and other conditions on choice\nfunctions are equivalent (under the @{const \"decisive\"} hypothesis).\n\n\\<close>"], ["", "subsubsection\\<open> The @{emph \\<open>strong axiom of revealed preference\\<close>} ala \\citet{AygunSonmez:2012-WP2} \\<close>"], ["", "text\\<open>\n\n\\citet[\\S6]{AygunSonmez:2012-WP2} adopt a different definition for a\n@{emph \\<open>strong axiom of revealed preference\\<close>} and show that it holds for\nall choice functions that satisfy @{const \"iia\"} and @{const\n\"consistency\"}.\n\n\\<close>"], ["", "abbreviation nth_mod :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a\" (infixl \"!%\" 100) where\n  \"xs !% i \\<equiv> xs ! (i mod length xs)\""], ["", "definition mwc_sarp :: \"'a cfun \\<Rightarrow> bool\" where\n  \"mwc_sarp f \\<longleftrightarrow>\n    \\<not>(\\<exists>Xs. length Xs > 1 \\<and> distinct (map f Xs) \\<and> (\\<forall>i. f (Xs!%i) \\<subset> Xs!%i \\<inter> Xs!%(i+1)))\""], ["", "lemma %invisible mwc_sarpI:\n  assumes \"\\<And>Xs. \\<lbrakk>length Xs > 1; distinct (map f Xs); \\<forall>i. f (Xs!%i) \\<subset> Xs!%i \\<inter> Xs!%(i+1)\\<rbrakk> \\<Longrightarrow> False\"\n  shows \"mwc_sarp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwc_sarp f", "unfolding mwc_sarp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Xs.\n       1 < length Xs \\<and>\n       distinct (map f Xs) \\<and>\n       (\\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < length ?Xs; distinct (map f ?Xs);\n   \\<forall>i.\n      f (?Xs !% i) \\<subset> ?Xs !% i \\<inter> ?Xs !% (i + 1)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<nexists>Xs.\n       1 < length Xs \\<and>\n       distinct (map f Xs) \\<and>\n       (\\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1))", "by blast"], ["", "lemma iia_consistency_mwc_sarp:\n  assumes \"f_range f\"\n  assumes \"iia f\" \\<comment> \\<open>@{const \"substitutes\"}\\<close>\n  assumes \"consistency f\" \\<comment> \\<open>@{const \"irc\"}\\<close>\n  shows \"mwc_sarp f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mwc_sarp f", "proof(rule mwc_sarpI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "fix Xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "assume LLL: \"length Xs > 1\"\n     and EEE: \"distinct (map f Xs)\"\n     and AAA: \"\\<forall>i. f (Xs!%i) \\<subset> Xs!%i \\<inter> Xs!%(i+1)\""], ["proof (state)\nthis:\n  1 < length Xs\n  distinct (map f Xs)\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "have 6: \"f (\\<Union>(set Xs)) \\<subseteq> (\\<Inter>X\\<in>set Xs. f X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "have 4: \"x \\<notin> f (\\<Union>(set Xs))\" if \"x \\<in> \\<Union>(set Xs) - (\\<Union>X\\<in>set Xs. f X)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "using that \\<open>iia f\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs)\n  iia f\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "unfolding iia_on_def"], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs)\n  \\<forall>B\\<subseteq>UNIV.\n     \\<forall>C\\<subseteq>B.\n        \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "by simp blast"], ["proof (state)\nthis:\n  ?x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "have 5: \"x \\<notin> f (\\<Union>(set Xs))\" if \"x \\<in> (\\<Union>X\\<in>set Xs. f X) - (\\<Inter>X\\<in>set Xs. f X)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "from that"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs)", "obtain j k where \"x \\<in> f (Xs ! j)\" \"x \\<notin> f (Xs ! k)\" \"j < length Xs\" \"k < length Xs\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>x \\<in> f (Xs ! j); x \\<notin> f (Xs ! k); j < length Xs;\n         k < length Xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  x \\<in> f (Xs ! j)\n  x \\<notin> f (Xs ! k)\n  j < length Xs\n  k < length Xs\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "with AAA LLL ex_least_nat_le[where n=\"k + length Xs - j\" and P=\"\\<lambda>i. x \\<notin> f (Xs !% (i + j))\"]"], ["proof (chain)\npicking this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n  1 < length Xs\n  \\<lbrakk>x \\<notin> f (Xs !% (k + length Xs - j + j));\n   \\<not> x \\<notin> f (Xs !% (0 + j))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ka\\<le>k + length Xs - j.\n                       (\\<forall>i<ka.\n                           \\<not> x \\<notin> f (Xs !% (i + j))) \\<and>\n                       x \\<notin> f (Xs !% (ka + j))\n  x \\<in> f (Xs ! j)\n  x \\<notin> f (Xs ! k)\n  j < length Xs\n  k < length Xs", "obtain i where \"x \\<in> f (Xs !% i) - f (Xs !% (i+1))\""], ["proof (prove)\nusing this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n  1 < length Xs\n  \\<lbrakk>x \\<notin> f (Xs !% (k + length Xs - j + j));\n   \\<not> x \\<notin> f (Xs !% (0 + j))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ka\\<le>k + length Xs - j.\n                       (\\<forall>i<ka.\n                           \\<not> x \\<notin> f (Xs !% (i + j))) \\<and>\n                       x \\<notin> f (Xs !% (ka + j))\n  x \\<in> f (Xs ! j)\n  x \\<notin> f (Xs ! k)\n  j < length Xs\n  k < length Xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x \\<in> f (Xs !% i) - f (Xs !% (i + 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by %invisible auto (metis One_nat_def add_eq_if diff_diff_cancel diff_is_0_eq' lessI mod_less nat_le_linear zero_less_diff)"], ["proof (state)\nthis:\n  x \\<in> f (Xs !% i) - f (Xs !% (i + 1))\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "with AAA"], ["proof (chain)\npicking this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n  x \\<in> f (Xs !% i) - f (Xs !% (i + 1))", "have \"x \\<in> Rf f (Xs!%(i+1))\""], ["proof (prove)\nusing this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n  x \\<in> f (Xs !% i) - f (Xs !% (i + 1))\n\ngoal (1 subgoal):\n 1. x \\<in> Rf f (Xs !% (i + 1))", "by auto"], ["proof (state)\nthis:\n  x \\<in> Rf f (Xs !% (i + 1))\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "with LLL"], ["proof (chain)\npicking this:\n  1 < length Xs\n  x \\<in> Rf f (Xs !% (i + 1))", "show \"x \\<notin> f (\\<Union>(set Xs))\""], ["proof (prove)\nusing this:\n  1 < length Xs\n  x \\<in> Rf f (Xs !% (i + 1))\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "using \\<open>iia f\\<close>"], ["proof (prove)\nusing this:\n  1 < length Xs\n  x \\<in> Rf f (Xs !% (i + 1))\n  iia f\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "unfolding iia_on_def"], ["proof (prove)\nusing this:\n  1 < length Xs\n  x \\<in> Rf f (Xs !% (i + 1))\n  \\<forall>B\\<subseteq>UNIV.\n     \\<forall>C\\<subseteq>B.\n        \\<forall>a\\<in>C. a \\<in> f B \\<longrightarrow> a \\<in> f C\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "by clarsimp (meson Suc_lessD Sup_upper mod_less_divisor nth_mem)"], ["proof (state)\nthis:\n  x \\<notin> f (\\<Union> (set Xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "from 4 5"], ["proof (chain)\npicking this:\n  ?x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n  ?x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))", "have \"x \\<notin> f (\\<Union>(set Xs))\" if \"x \\<in> (\\<Union>(set Xs)) - (\\<Inter>X\\<in>set Xs. f X)\" for x"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n  ?x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<Union> (set Xs) - \\<Union> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n  ?x \\<in> \\<Union> (f ` set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n  x \\<in> \\<Union> (set Xs) - \\<Inter> (f ` set Xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> f (\\<Union> (set Xs))", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> \\<Union> (set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "with \\<open>f_range f\\<close>"], ["proof (chain)\npicking this:\n  f_range f\n  ?x \\<in> \\<Union> (set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  f_range f\n  ?x \\<in> \\<Union> (set Xs) - \\<Inter> (f ` set Xs) \\<Longrightarrow>\n  ?x \\<notin> f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)", "by (blast dest: f_range_onD)"], ["proof (state)\nthis:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<forall>i. (\\<Inter>X\\<in>set Xs. f X) \\<subset> f (Xs!%i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "from \\<open>f_range f\\<close> LLL"], ["proof (chain)\npicking this:\n  f_range f\n  1 < length Xs", "have \"\\<Inter>(f ` set Xs) \\<subseteq> Xs ! 1\""], ["proof (prove)\nusing this:\n  f_range f\n  1 < length Xs\n\ngoal (1 subgoal):\n 1. \\<Inter> (f ` set Xs) \\<subseteq> Xs ! 1", "using nth_mem f_range_onD"], ["proof (prove)\nusing this:\n  f_range f\n  1 < length Xs\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  \\<lbrakk>f_range_on ?A ?f; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?B \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. \\<Inter> (f ` set Xs) \\<subseteq> Xs ! 1", "by fastforce"], ["proof (state)\nthis:\n  \\<Inter> (f ` set Xs) \\<subseteq> Xs ! 1\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "with \\<open>consistency f\\<close> LLL 6"], ["proof (chain)\npicking this:\n  consistency f\n  1 < length Xs\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<Inter> (f ` set Xs) \\<subseteq> Xs ! 1", "have f4: \"f (\\<Union>(set Xs)) = f (Xs ! 1)\""], ["proof (prove)\nusing this:\n  consistency f\n  1 < length Xs\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<Inter> (f ` set Xs) \\<subseteq> Xs ! 1\n\ngoal (1 subgoal):\n 1. f (\\<Union> (set Xs)) = f (Xs ! 1)", "by - (rule consistencyD[where f=f], force+)"], ["proof (state)\nthis:\n  f (\\<Union> (set Xs)) = f (Xs ! 1)\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "with \\<open>f_range f\\<close> LLL 6"], ["proof (chain)\npicking this:\n  f_range f\n  1 < length Xs\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  f (\\<Union> (set Xs)) = f (Xs ! 1)", "have \"f (Xs ! 1) \\<subseteq> Xs ! 0\""], ["proof (prove)\nusing this:\n  f_range f\n  1 < length Xs\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  f (\\<Union> (set Xs)) = f (Xs ! 1)\n\ngoal (1 subgoal):\n 1. f (Xs ! 1) \\<subseteq> Xs ! 0", "using f_range_onD"], ["proof (prove)\nusing this:\n  f_range f\n  1 < length Xs\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  f (\\<Union> (set Xs)) = f (Xs ! 1)\n  \\<lbrakk>f_range_on ?A ?f; ?B \\<subseteq> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?B \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. f (Xs ! 1) \\<subseteq> Xs ! 0", "by (metis INT_lower One_nat_def Suc_lessD subset_trans nth_mem top.extremum)"], ["proof (state)\nthis:\n  f (Xs ! 1) \\<subseteq> Xs ! 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "with \\<open>consistency f\\<close> EEE LLL f4"], ["proof (chain)\npicking this:\n  consistency f\n  distinct (map f Xs)\n  1 < length Xs\n  f (\\<Union> (set Xs)) = f (Xs ! 1)\n  f (Xs ! 1) \\<subseteq> Xs ! 0", "show ?thesis"], ["proof (prove)\nusing this:\n  consistency f\n  distinct (map f Xs)\n  1 < length Xs\n  f (\\<Union> (set Xs)) = f (Xs ! 1)\n  f (Xs ! 1) \\<subseteq> Xs ! 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "by (metis One_nat_def Suc_lessD Sup_upper consistencyD length_map nth_eq_iff_index_eq nth_map nth_mem zero_neq_one)"], ["proof (state)\nthis:\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<forall>i. f (Xs!%i) = f (\\<Union>(set Xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "from AAA"], ["proof (chain)\npicking this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)", "have \"\\<forall>i. f (Xs!%i) \\<subseteq> Xs!%i\""], ["proof (prove)\nusing this:\n  \\<forall>i. f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) \\<subseteq> Xs !% i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. f (Xs !% i) \\<subseteq> Xs !% i\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. f (Xs !% i) \\<subseteq> Xs !% i\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "from LLL"], ["proof (chain)\npicking this:\n  1 < length Xs", "have \"\\<forall>i. Xs!%i \\<subseteq> \\<Union>(set Xs)\""], ["proof (prove)\nusing this:\n  1 < length Xs\n\ngoal (1 subgoal):\n 1. \\<forall>i. Xs !% i \\<subseteq> \\<Union> (set Xs)", "by (metis One_nat_def Suc_lessD Sup_upper mod_less_divisor nth_mem)"], ["proof (state)\nthis:\n  \\<forall>i. Xs !% i \\<subseteq> \\<Union> (set Xs)\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. Xs !% i \\<subseteq> \\<Union> (set Xs)\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "note 6 \\<open>\\<forall>i. (\\<Inter>X\\<in>set Xs. f X) \\<subset> f (Xs !% i)\\<close>"], ["proof (state)\nthis:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i. f (Xs !% i) \\<subseteq> Xs !% i\n  \\<forall>i. Xs !% i \\<subseteq> \\<Union> (set Xs)\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)", "show \"\\<forall>i. f (Xs!%i) = f (\\<Union>(set Xs))\""], ["proof (prove)\nusing this:\n  \\<forall>i. f (Xs !% i) \\<subseteq> Xs !% i\n  \\<forall>i. Xs !% i \\<subseteq> \\<Union> (set Xs)\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n\ngoal (1 subgoal):\n 1. \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "by - (clarsimp; rule consistencyD[OF \\<open>consistency f\\<close>, symmetric]; meson dual_order.trans psubsetE)"], ["proof (state)\nthis:\n  \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. \\<And>Xs.\n       \\<lbrakk>1 < length Xs; distinct (map f Xs);\n        \\<forall>i.\n           f (Xs !% i) \\<subset> Xs !% i \\<inter> Xs !% (i + 1)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n  \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))", "show False"], ["proof (prove)\nusing this:\n  f (\\<Union> (set Xs)) \\<subseteq> \\<Inter> (f ` set Xs)\n  \\<forall>i. \\<Inter> (f ` set Xs) \\<subset> f (Xs !% i)\n  \\<forall>i. f (Xs !% i) = f (\\<Union> (set Xs))\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open> Choice functions arising from linear orders \\label{sec:cf-linear} \\<close>"], ["", "text\\<open>\n\nAn obvious way to construct a choice function is to derive one from a\nlinear order, i.e., a list of strict preferences. We allow such\nrankings to omit some alternatives, which means the resulting function\nis not decisive.\n\nWe work with a finite universe here.\n\n\\<close>"], ["", "locale linear_cf =\n  fixes r :: \"'a::finite rel\"\n  fixes linear_cf :: \"'a cfun\"\n  assumes r_linear: \"Linear_order r\"\n  assumes linear_cf_def: \"linear_cf X \\<equiv> set_option (MaxR.MaxR_opt r X)\"\nbegin"], ["", "interpretation MaxR: MaxR r"], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR r", "by unfold_locales (rule r_linear)"], ["", "(*<*)"], ["", "lemmas maxR_code = MaxR.maxR_def"], ["", "lemmas MaxR_f_code = MaxR.MaxR_f_def"], ["", "lemma code:\n  shows \"linear_cf (set X) = set_option (fold MaxR.MaxR_f X None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf (set X) = set_option (fold local.MaxR.MaxR_f X None)", "unfolding linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt (set X)) =\n    set_option (fold local.MaxR.MaxR_f X None)", "using MaxR.MaxR_opt_code"], ["proof (prove)\nusing this:\n  local.MaxR.MaxR_opt (set ?A) = fold local.MaxR.MaxR_f ?A None\n\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt (set X)) =\n    set_option (fold local.MaxR.MaxR_f X None)", "by simp"], ["", "lemma simps [nitpick_simp]:\n  shows \"linear_cf {} = {}\"\n        \"linear_cf (insert x X) = (if x \\<in> Field r then if linear_cf X = {} then {x} else {MaxR.maxR x y |y. y \\<in> linear_cf X} else linear_cf X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf {} = {} &&&\n    linear_cf (insert x X) =\n    (if x \\<in> Field r\n     then if linear_cf X = {} then {x}\n          else {local.MaxR.maxR x y |y. y \\<in> linear_cf X}\n     else linear_cf X)", "unfolding linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt {}) = {} &&&\n    set_option (local.MaxR.MaxR_opt (insert x X)) =\n    (if x \\<in> Field r\n     then if set_option (local.MaxR.MaxR_opt X) = {} then {x}\n          else {local.MaxR.maxR x y |y.\n                y \\<in> set_option (local.MaxR.MaxR_opt X)}\n     else set_option (local.MaxR.MaxR_opt X))", "by (simp_all add: MaxR.insert split: option.splits)"], ["", "(*>*)"], ["", "lemma range:\n  shows \"linear_cf X \\<subseteq> X \\<inter> Field r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf X \\<subseteq> X \\<inter> Field r", "unfolding %invisible linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt X) \\<subseteq> X \\<inter> Field r", "using MaxR.range[of X] finite[of X]"], ["proof (prove)\nusing this:\n  local.MaxR.MaxR_opt X \\<in> Some ` (X \\<inter> Field r) \\<union> {None}\n  finite X\n\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt X) \\<subseteq> X \\<inter> Field r", "by fastforce"], ["", "lemmas range' = rev_subsetD[OF _ range, of x] for x"], ["", "lemma singleton:\n  shows \"x \\<in> linear_cf X \\<longleftrightarrow> linear_cf X = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> linear_cf X) = (linear_cf X = {x})", "unfolding %invisible linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_option (local.MaxR.MaxR_opt X)) =\n    (set_option (local.MaxR.MaxR_opt X) = {x})", "by fastforce"], ["", "lemma subset:\n  assumes \"linear_cf Y \\<subseteq> X\"\n  assumes \"X \\<subseteq> Y\"\n  shows \"linear_cf Y = linear_cf X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf Y = linear_cf X", "using %invisible assms MaxR.subset"], ["proof (prove)\nusing this:\n  linear_cf Y \\<subseteq> X\n  X \\<subseteq> Y\n  \\<lbrakk>set_option (local.MaxR.MaxR_opt ?B) \\<subseteq> ?A;\n   ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> local.MaxR.MaxR_opt ?B = local.MaxR.MaxR_opt ?A\n\ngoal (1 subgoal):\n 1. linear_cf Y = linear_cf X", "unfolding linear_cf_def"], ["proof (prove)\nusing this:\n  set_option (local.MaxR.MaxR_opt Y) \\<subseteq> X\n  X \\<subseteq> Y\n  \\<lbrakk>set_option (local.MaxR.MaxR_opt ?B) \\<subseteq> ?A;\n   ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> local.MaxR.MaxR_opt ?B = local.MaxR.MaxR_opt ?A\n\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt Y) = set_option (local.MaxR.MaxR_opt X)", "by simp"], ["", "lemma union:\n  shows \"linear_cf (X \\<union> Y) = (if linear_cf X = {} then linear_cf Y else if linear_cf Y = {} then linear_cf X else {MaxR.maxR x y |x y. x \\<in> linear_cf X \\<and> y \\<in> linear_cf Y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf (X \\<union> Y) =\n    (if linear_cf X = {} then linear_cf Y\n     else if linear_cf Y = {} then linear_cf X\n          else {local.MaxR.maxR x y |x y.\n                x \\<in> linear_cf X \\<and> y \\<in> linear_cf Y})", "unfolding %invisible linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_option (local.MaxR.MaxR_opt (X \\<union> Y)) =\n    (if set_option (local.MaxR.MaxR_opt X) = {}\n     then set_option (local.MaxR.MaxR_opt Y)\n     else if set_option (local.MaxR.MaxR_opt Y) = {}\n          then set_option (local.MaxR.MaxR_opt X)\n          else {local.MaxR.maxR x y |x y.\n                x \\<in> set_option (local.MaxR.MaxR_opt X) \\<and>\n                y \\<in> set_option (local.MaxR.MaxR_opt Y)})", "by (auto simp: MaxR.union)"], ["", "lemma mono:\n  assumes \"x \\<in> linear_cf X\"\n  shows \"\\<exists>y \\<in> linear_cf (X \\<union> Y). (x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>linear_cf (X \\<union> Y). (x, y) \\<in> r", "using %invisible MaxR.mono assms"], ["proof (prove)\nusing this:\n  local.MaxR.MaxR_opt ?A = Some ?x \\<Longrightarrow>\n  \\<exists>y.\n     local.MaxR.MaxR_opt (?A \\<union> ?B) = Some y \\<and> (?x, y) \\<in> r\n  x \\<in> linear_cf X\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>linear_cf (X \\<union> Y). (x, y) \\<in> r", "unfolding linear_cf_def"], ["proof (prove)\nusing this:\n  local.MaxR.MaxR_opt ?A = Some ?x \\<Longrightarrow>\n  \\<exists>y.\n     local.MaxR.MaxR_opt (?A \\<union> ?B) = Some y \\<and> (?x, y) \\<in> r\n  x \\<in> set_option (local.MaxR.MaxR_opt X)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>set_option (local.MaxR.MaxR_opt (X \\<union> Y)).\n       (x, y) \\<in> r", "by (metis elem_set)"], ["", "lemmas greatest = MaxR.greatest[folded linear_cf_def]"], ["", "lemma preferred:\n  assumes \"(x, y) \\<in> r\"\n  assumes \"x \\<in> linear_cf X\"\n  assumes \"y \\<in> X\"\n  shows \"y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = x", "using %invisible assms FieldI2 MaxR.MaxR_opt_is_greatest MaxR.maxR_absorb1 maxR_code"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  x \\<in> linear_cf X\n  y \\<in> X\n  (?i, ?j) \\<in> ?R \\<Longrightarrow> ?j \\<in> Field ?R\n  \\<lbrakk>local.MaxR.MaxR_opt ?A = Some ?x;\n   ?y \\<in> ?A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n  (?y, ?x) \\<in> r \\<Longrightarrow> local.MaxR.maxR ?x ?y = ?x\n  local.MaxR.maxR ?x ?y = (if (?x, ?y) \\<in> r then ?y else ?x)\n\ngoal (1 subgoal):\n 1. y = x", "unfolding linear_cf_def"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\n  x \\<in> set_option (local.MaxR.MaxR_opt X)\n  y \\<in> X\n  (?i, ?j) \\<in> ?R \\<Longrightarrow> ?j \\<in> Field ?R\n  \\<lbrakk>local.MaxR.MaxR_opt ?A = Some ?x;\n   ?y \\<in> ?A \\<inter> Field r\\<rbrakk>\n  \\<Longrightarrow> (?y, ?x) \\<in> r\n  (?y, ?x) \\<in> r \\<Longrightarrow> local.MaxR.maxR ?x ?y = ?x\n  local.MaxR.maxR ?x ?y = (if (?x, ?y) \\<in> r then ?y else ?x)\n\ngoal (1 subgoal):\n 1. y = x", "by fastforce"], ["", "lemma card_le:\n  shows \"card (linear_cf X) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (linear_cf X) \\<le> 1", "unfolding %invisible linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set_option (local.MaxR.MaxR_opt X)) \\<le> 1", "by (cases \"MaxR.MaxR_opt X\") simp_all"], ["", "lemma card:\n  shows \"card (linear_cf X) = (if X \\<inter> Field r = {} then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (linear_cf X) = (if X \\<inter> Field r = {} then 0 else 1)", "unfolding %invisible linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set_option (local.MaxR.MaxR_opt X)) =\n    (if X \\<inter> Field r = {} then 0 else 1)", "by (cases \"MaxR.MaxR_opt X\") (auto dest: MaxR.range_None MaxR.range_Some)"], ["", "lemma f_range:\n  shows \"f_range_on X linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_range_on X linear_cf", "unfolding %invisible f_range_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>X. linear_cf B \\<subseteq> B", "using range"], ["proof (prove)\nusing this:\n  linear_cf ?X \\<subseteq> ?X \\<inter> Field r\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>X. linear_cf B \\<subseteq> B", "by blast"], ["", "lemma domain:\n  shows \"linear_cf (X \\<inter> Field r) = linear_cf X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_cf (X \\<inter> Field r) = linear_cf X", "by %invisible (metis inf.cobounded1 range subset)"], ["", "lemma decisive_on:\n  shows \"decisive_on (Field r) linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on (Field r) linear_cf", "unfolding %invisible decisive_on_def linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>Field r.\n       B \\<noteq> {} \\<longrightarrow>\n       set_option (local.MaxR.MaxR_opt B) \\<noteq> {}", "by (metis Int_absorb2 empty_subsetI MaxR.range_None MaxR.empty MaxR.subset)"], ["", "lemma resolute_on:\n  shows \"resolute_on (Field r) linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolute_on (Field r) linear_cf", "unfolding %invisible resolute_on_def linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>Field r.\n       B \\<noteq> {} \\<longrightarrow>\n       (\\<exists>a. set_option (local.MaxR.MaxR_opt B) = {a})", "using mk_disjoint_insert"], ["proof (prove)\nusing this:\n  ?a \\<in> ?A \\<Longrightarrow>\n  \\<exists>B. ?A = insert ?a B \\<and> ?a \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>Field r.\n       B \\<noteq> {} \\<longrightarrow>\n       (\\<exists>a. set_option (local.MaxR.MaxR_opt B) = {a})", "by (force simp: MaxR.insert)"], ["", "lemma Rf_mono_on:\n  shows \"mono_on X (Rf linear_cf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis.mono_on X (Rf linear_cf)", "by %invisible (rule mono_onI) (clarsimp; metis contra_subsetD empty_subsetI insert_subset singleton subset)"], ["", "lemmas iia = iffD1[OF Rf_mono_on_iia_on Rf_mono_on]"], ["", "lemma Chernoff:\n  shows \"Chernoff_on X linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on X linear_cf", "using %invisible Rf_mono_on range Rf_mono_on_iia_on[of X linear_cf, symmetric] Chernoff_on_iia_on"], ["proof (prove)\nusing this:\n  Basis.mono_on ?X (Rf linear_cf)\n  linear_cf ?X \\<subseteq> ?X \\<inter> Field r\n  iia_on X linear_cf = Basis.mono_on (Pow X) (Rf linear_cf)\n  Chernoff_on ?A ?f = iia_on ?A ?f\n\ngoal (1 subgoal):\n 1. Chernoff_on X linear_cf", "by blast"], ["", "lemma irc:\n  shows \"irc_on X linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irc_on X linear_cf", "unfolding %invisible irc_on_def linear_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>X.\n       \\<forall>a\\<in>X.\n          a \\<notin> set_option\n                      (local.MaxR.MaxR_opt\n                        (B \\<union> {a})) \\<longrightarrow>\n          set_option (local.MaxR.MaxR_opt (B \\<union> {a})) =\n          set_option (local.MaxR.MaxR_opt B)", "by (clarsimp simp: MaxR.insert dest!: MaxR.maxR_rangeD split: option.splits)"], ["", "lemma consistency:\n  shows \"consistency_on X linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency_on X linear_cf", "using %invisible irc"], ["proof (prove)\nusing this:\n  irc_on ?X linear_cf\n\ngoal (1 subgoal):\n 1. consistency_on X linear_cf", "by (rule irc_on_consistency_on) simp"], ["", "lemma lad:\n  shows \"lad_on X linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lad_on X linear_cf", "unfolding %invisible lad_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>X.\n       \\<forall>C\\<subseteq>B. card (linear_cf C) \\<le> card (linear_cf B)", "by (cases \"X \\<inter> Field r = {}\") (auto simp: card)"], ["", "end"], ["", "subsection\\<open> Plott's @{emph \\<open>path independence\\<close>} condition \\label{sec:cf-path-independence}\\<close>"], ["", "text\\<open>\n\nAs recognised by \\citet[\\S4]{Fleiner:2002} and\n\\citet{ChambersYenmez:2013} in the context of matching with contracts,\nthe @{const \"irc\"} and @{const \"substitutes\"} conditions together are\nequivalent to @{emph \\<open>path independence\\<close>}, a condition introduced to the\nsocial choice setting by\n\\citet{Plott:1973}. \\citet[Lemma~6]{Moulin:1985} ascribes this\nequivalence result to \\citet{AizermanMalishevski:1981}.\n\n\\<close>"], ["", "definition path_independent_on :: \"'a set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"path_independent_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) = f (B \\<union> f C))\""], ["", "abbreviation path_independent :: \"'a cfun \\<Rightarrow> bool\" where\n  \"path_independent \\<equiv> path_independent_on UNIV\""], ["", "(*<*)"], ["", "lemmas path_independent_onI = iffD2[OF path_independent_on_def, rule_format]"], ["", "lemmas path_independent_onD = iffD1[OF path_independent_on_def, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas path_independent_def = path_independent_on_def[where A=UNIV, simplified]"], ["", "(*>*)"], ["", "text\\<open>\n\nIntuitively a choice function satisfying this condition ignores the\norder in which choices are made in the following sense:\n\n\\<close>"], ["", "lemma path_independent_on_symmetric:\n  assumes \"f_range_on A f\"\n  shows \"path_independent_on A f \\<longleftrightarrow> (\\<forall>B C. B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow> f (B \\<union> C) = f (f B \\<union> f C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) = f (f B \\<union> f C))", "using %invisible assms"], ["proof (prove)\nusing this:\n  f_range_on A f\n\ngoal (1 subgoal):\n 1. path_independent_on A f =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) = f (f B \\<union> f C))", "unfolding path_independent_on_def f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) = f (B \\<union> f C)) =\n    (\\<forall>B C.\n        B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n        f (B \\<union> C) = f (f B \\<union> f C))", "by - (rule iffI, metis subset_trans Un_commute, metis (full_types) Un_subset_iff empty_subsetI sup.orderE Un_commute)"], ["", "lemmas %invisible path_independent_on_symmetricI = iffD2[OF path_independent_on_symmetric, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemmas %invisible path_independent_on_symmetricD = iffD1[OF path_independent_on_symmetric, rule_format, unfolded conj_imp_eq_imp_imp]"], ["", "lemma path_independent_on_Chernoff_on:\n  assumes \"path_independent_on A f\"\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Chernoff_on A f", "proof %invisible (rule Chernoff_onI[OF subsetI])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B;\n        x \\<in> f B \\<inter> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f C", "fix B C x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B;\n        x \\<in> f B \\<inter> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f C", "assume XXX: \"B \\<subseteq> A\" \"C \\<subseteq> B\" \"x \\<in> f B \\<inter> C\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B;\n        x \\<in> f B \\<inter> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f C", "from \\<open>f_range_on A f\\<close> XXX"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C", "have \"f C \\<subseteq> B\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n\ngoal (1 subgoal):\n 1. f C \\<subseteq> B", "by - (erule subset_trans[OF f_range_onD], simp_all)"], ["proof (state)\nthis:\n  f C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B;\n        x \\<in> f B \\<inter> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f C", "with \\<open>f_range_on A f\\<close> XXX"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n  f C \\<subseteq> B", "have YYY: \"f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n  f C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C", "by (fastforce elim!: f_range_onD)"], ["proof (state)\nthis:\n  f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C\n\ngoal (1 subgoal):\n 1. \\<And>B C x.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B;\n        x \\<in> f B \\<inter> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> f C", "from XXX YYY path_independent_onD[OF \\<open>path_independent_on A f\\<close>, where B=\"B - C\" and C=\"C\"] \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n  f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C\n  \\<lbrakk>B - C \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> f (B - C \\<union> C) = f (B - C \\<union> f C)\n  f_range_on A f", "show \"x \\<in> f C\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n  f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C\n  \\<lbrakk>B - C \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> f (B - C \\<union> C) = f (B - C \\<union> f C)\n  f_range_on A f\n\ngoal (1 subgoal):\n 1. x \\<in> f C", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f B \\<inter> C\n  f (B - C \\<union> f C) \\<subseteq> B - C \\<union> f C\n  \\<lbrakk>B - C \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> f (B - C \\<union> C) = f (B - C \\<union> f C)\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. x \\<in> f C", "by (auto simp: Un_absorb2)"], ["proof (state)\nthis:\n  x \\<in> f C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_independent_on_consistency_on:\n  assumes \"path_independent_on A f\"\n  shows \"consistency_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency_on A f", "using %invisible assms"], ["proof (prove)\nusing this:\n  path_independent_on A f\n\ngoal (1 subgoal):\n 1. consistency_on A f", "unfolding path_independent_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B C.\n     B \\<subseteq> A \\<and> C \\<subseteq> A \\<longrightarrow>\n     f (B \\<union> C) = f (B \\<union> f C)\n\ngoal (1 subgoal):\n 1. consistency_on A f", "by - (rule consistency_onI; metis Un_subset_iff le_iff_sup sup_commute)"], ["", "lemma Chernoff_on_consistency_on_path_independent_on:\n  assumes \"f_range_on A f\"\n  shows \"Chernoff_on A f \\<and> consistency_on A f \\<longleftrightarrow> path_independent_on A f\"\n(*<*)\n(is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Chernoff_on A f \\<and> consistency_on A f) = path_independent_on A f", "proof %invisible (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<and> consistency_on A f \\<Longrightarrow>\n    path_independent_on A f\n 2. path_independent_on A f \\<Longrightarrow>\n    Chernoff_on A f \\<and> consistency_on A f", "assume LHS: ?lhs"], ["proof (state)\nthis:\n  Chernoff_on A f \\<and> consistency_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f \\<and> consistency_on A f \\<Longrightarrow>\n    path_independent_on A f\n 2. path_independent_on A f \\<Longrightarrow>\n    Chernoff_on A f \\<and> consistency_on A f", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent_on A f", "proof(rule path_independent_on_symmetricI[OF assms])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> f (B \\<union> C) = f (f B \\<union> f C)", "fix B C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> f (B \\<union> C) = f (f B \\<union> f C)", "assume BC: \"B \\<subseteq> A\" \"C \\<subseteq> A\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>B \\<subseteq> A; C \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> f (B \\<union> C) = f (f B \\<union> f C)", "with LHS assms"], ["proof (chain)\npicking this:\n  Chernoff_on A f \\<and> consistency_on A f\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> A", "show \"f (B \\<union> C) = f (f B \\<union> f C)\""], ["proof (prove)\nusing this:\n  Chernoff_on A f \\<and> consistency_on A f\n  f_range_on A f\n  B \\<subseteq> A\n  C \\<subseteq> A\n\ngoal (1 subgoal):\n 1. f (B \\<union> C) = f (f B \\<union> f C)", "by - (rule consistency_onD[where A=A and f=f, OF _ _ _ Chernoff_on_union[OF _ assms]];\n            blast dest: f_range_onD)"], ["proof (state)\nthis:\n  f (B \\<union> C) = f (f B \\<union> f C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_independent_on A f\n\ngoal (1 subgoal):\n 1. path_independent_on A f \\<Longrightarrow>\n    Chernoff_on A f \\<and> consistency_on A f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path_independent_on A f \\<Longrightarrow>\n    Chernoff_on A f \\<and> consistency_on A f", "assume ?rhs"], ["proof (state)\nthis:\n  path_independent_on A f\n\ngoal (1 subgoal):\n 1. path_independent_on A f \\<Longrightarrow>\n    Chernoff_on A f \\<and> consistency_on A f", "with assms path_independent_on_Chernoff_on path_independent_on_consistency_on"], ["proof (chain)\npicking this:\n  f_range_on A f\n  \\<lbrakk>path_independent_on ?A ?f; f_range_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> Chernoff_on ?A ?f\n  path_independent_on ?A ?f \\<Longrightarrow> consistency_on ?A ?f\n  path_independent_on A f", "show ?lhs"], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<lbrakk>path_independent_on ?A ?f; f_range_on ?A ?f\\<rbrakk>\n  \\<Longrightarrow> Chernoff_on ?A ?f\n  path_independent_on ?A ?f \\<Longrightarrow> consistency_on ?A ?f\n  path_independent_on A f\n\ngoal (1 subgoal):\n 1. Chernoff_on A f \\<and> consistency_on A f", "by blast"], ["proof (state)\nthis:\n  Chernoff_on A f \\<and> consistency_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas path_independent_onI2 =\n  iffD1[OF Chernoff_on_consistency_on_path_independent_on, unfolded conj_imp_eq_imp_imp]"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma (in linear_cf) path_independent:\n  shows \"path_independent linear_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent linear_cf", "using %invisible f_range Chernoff consistency"], ["proof (prove)\nusing this:\n  f_range_on ?X linear_cf\n  Chernoff_on ?X linear_cf\n  consistency_on ?X linear_cf\n\ngoal (1 subgoal):\n 1. path_independent linear_cf", "by (blast intro: path_independent_onI2)"], ["", "subsubsection\\<open> Path independence and decomposition into orderings \\label{sec:cf-path-independence-orderings} \\<close>"], ["", "text\\<open>\n\nWe now show that a choice function over a finite universe satisfying\n@{const \"path_independent\"} is characterized by taking the maximum\nelements of some finite set of orderings.\n\n\\citet[Definition~12]{Moulin:1985} says that a choice function is\n@{emph \\<open>pseudo-rationalized\\<close>} by the orderings @{term \"Rs\"} if @{term\n\"f\"} chooses all of the @{term \"greatest r\"} elements of @{term \"B\"}\nfor each @{term \"r \\<in> Rs\"}:\n\n\\<close>"], ["", "definition pseudo_rationalizable_on :: \"'a::finite set \\<Rightarrow> 'a rel set \\<Rightarrow> 'a cfun \\<Rightarrow> bool\" where\n  \"pseudo_rationalizable_on A Rs f\n     \\<longleftrightarrow> (\\<forall>r\\<in>Rs. Linear_order r) \\<and> (\\<forall>B\\<subseteq>A. f B = (\\<Union>r\\<in>Rs. greatest r (B \\<inter> Field r)))\""], ["", "lemma pseudo_rationalizable_on_def2:\n  \"pseudo_rationalizable_on A Rs f\n     \\<longleftrightarrow> (\\<forall>r\\<in>Rs. Linear_order r) \\<and> (\\<forall>B\\<subseteq>A. f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f =\n    ((\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n     (\\<forall>B\\<subseteq>A.\n         f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))))", "unfolding %invisible pseudo_rationalizable_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n     (\\<forall>B\\<subseteq>A.\n         f B = (\\<Union>r\\<in>Rs. greatest r (B \\<inter> Field r)))) =\n    ((\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n     (\\<forall>B\\<subseteq>A.\n         f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))))", "by (metis (no_types, lifting) MaxR.greatest MaxR.intro SUP_cong)"], ["", "lemmas %invisible pseudo_rationalizable_onI = iffD2[OF pseudo_rationalizable_on_def2, unfolded conj_imp_eq_imp_imp, rule_format]"], ["", "text\\<open>\n\nWe deviate from \\citeauthor{Moulin:1985} in using non-total linear\norders, where his are total, asymmetric, and transitive; in other\nwords, strict total linear orders. This allows us to treat\nnon-decisive choice functions, and we later show that the choice\nfunction is decisive iff the orders are total.\n\n\\citet[Theorem~5]{Moulin:1985} assumes @{const \"Aizerman\"} and @{const\n\"Chernoff\"}, which are equivalent to @{const \"path_independent\"}.\n\n\\<close>"], ["", "lemma Aizerman_on_Chernoff_on_path_independent_on:\n  assumes \"f_range_on A f\"\n  shows \"Aizerman_on A f \\<and> Chernoff_on A f \\<longleftrightarrow> path_independent_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Aizerman_on A f \\<and> Chernoff_on A f) = path_independent_on A f", "using %invisible Chernoff_on_consistency_on_path_independent_on[OF assms] consistency_on_Aizerman_on Aizerman_on_idem_on_consistency_on iia_f_idem[OF assms] Chernoff_on_iia_on"], ["proof (prove)\nusing this:\n  (Chernoff_on A f \\<and> consistency_on A f) = path_independent_on A f\n  consistency_on ?A ?f \\<Longrightarrow> Aizerman_on ?A ?f\n  \\<lbrakk>Aizerman_on ?A ?f;\n   \\<forall>B\\<subseteq>?A. ?f (?f B) = ?f B\\<rbrakk>\n  \\<Longrightarrow> consistency_on ?A ?f\n  \\<lbrakk>iia_on A f; ?B \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> f (f ?B) = f ?B\n  Chernoff_on ?A ?f = iia_on ?A ?f\n\ngoal (1 subgoal):\n 1. (Aizerman_on A f \\<and> Chernoff_on A f) = path_independent_on A f", "by blast"], ["", "text\\<open>\n\nIt is straightforward to show that pseudo-rationalizable choice\nfunctions satisfy @{const \"path_independent\"} using the properties of\n@{const \"MaxR.MaxR_opt\"}:\n\n\\<close>"], ["", "lemma pseudo_rationalizable_on_path_independent_on:\n  assumes \"pseudo_rationalizable_on A Rs f\"\n  shows \"path_independent_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent_on A f", "proof %invisible (rule path_independent_onI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. f_range_on A f\n 2. Chernoff_on A f\n 3. consistency_on A f", "from assms"], ["proof (chain)\npicking this:\n  pseudo_rationalizable_on A Rs f", "show \"f_range_on A f\""], ["proof (prove)\nusing this:\n  pseudo_rationalizable_on A Rs f\n\ngoal (1 subgoal):\n 1. f_range_on A f", "unfolding f_range_on_def pseudo_rationalizable_on_def2"], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n  (\\<forall>B\\<subseteq>A.\n      f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A. f B \\<subseteq> B", "using MaxR.range_Some[unfolded MaxR_def]"], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n  (\\<forall>B\\<subseteq>A.\n      f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\n  Linear_order ?r \\<Longrightarrow>\n  MaxR.MaxR_opt ?r ?A = Some ?a \\<longrightarrow>\n  ?a \\<in> ?A \\<inter> Field ?r\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<subseteq>A. f B \\<subseteq> B", "by fastforce"], ["proof (state)\nthis:\n  f_range_on A f\n\ngoal (2 subgoals):\n 1. Chernoff_on A f\n 2. consistency_on A f", "from assms"], ["proof (chain)\npicking this:\n  pseudo_rationalizable_on A Rs f", "show \"Chernoff_on A f\""], ["proof (prove)\nusing this:\n  pseudo_rationalizable_on A Rs f\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "unfolding pseudo_rationalizable_on_def2"], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n  (\\<forall>B\\<subseteq>A.\n      f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\n\ngoal (1 subgoal):\n 1. Chernoff_on A f", "by - (rule Chernoff_onI; clarsimp; metis MaxR.intro MaxR.subset empty_subsetI insert_subset option.simps(15))"], ["proof (state)\nthis:\n  Chernoff_on A f\n\ngoal (1 subgoal):\n 1. consistency_on A f", "from assms"], ["proof (chain)\npicking this:\n  pseudo_rationalizable_on A Rs f", "show \"consistency_on A f\""], ["proof (prove)\nusing this:\n  pseudo_rationalizable_on A Rs f\n\ngoal (1 subgoal):\n 1. consistency_on A f", "unfolding pseudo_rationalizable_on_def2"], ["proof (prove)\nusing this:\n  (\\<forall>r\\<in>Rs. Linear_order r) \\<and>\n  (\\<forall>B\\<subseteq>A.\n      f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B)))\n\ngoal (1 subgoal):\n 1. consistency_on A f", "by - (rule consistency_onI; simp; metis (no_types, lifting) MaxR.intro MaxR.subset SUP_cong SUP_le_iff)"], ["proof (state)\nthis:\n  consistency_on A f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe converse requires that we construct a suitable set of orderings\nthat rationalize @{term \"f C\"} for each @{term \"C \\<subseteq> A\"}. We\ndo this by finding a set @{term \"B \\<subseteq> A\"} where @{term \"f B\n\\<subseteq> C\"} by successively removing elements in @{term \"f A - f\nC\"}. (As these elements are chosen by @{term \"f\"} from supersets of\n@{term \"B\"}, we rank these above all of those in @{term \"f B\"}.)  By\n@{const \"consistency\"} (\\S\\ref{sec:cf-irc}), @{term \"f C = f B\"}. We\ngenerate one order for each element of @{term \"f C\"}. Some extra care\ntakes care of @{const \"decisive\"} choice functions.\n\nTermination is guaranteed by the finiteness of @{term \"A\"} and the\n@{const \"f_range_on\"} hypothesis.\n\n\\<close>"], ["", "context\n  fixes A :: \"'a::finite set\"\n  fixes f :: \"'a cfun\"\n  notes conj_cong[fundef_cong]\nbegin"], ["", "function (domintros) mk_linear_orders :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a list set\" where\n  \"mk_linear_orders C B =\n   (if f B = {} then {[]}\n    else if f B \\<subseteq> C\n         then {b # cs |b cs. b \\<in> f B \\<and> cs \\<in> mk_linear_orders {} (B - {b})}\n         else let b = SOME x. x \\<in> f B - C in {b # cs |cs. cs \\<in> mk_linear_orders C (B - {b})})\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>C B. x = (C, B) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>C B Ca Ba.\n       (C, B) = (Ca, Ba) \\<Longrightarrow>\n       (if f B = {} then {[]}\n        else if f B \\<subseteq> C\n             then {b # cs |b cs.\n                   b \\<in> f B \\<and>\n                   cs \\<in> mk_linear_orders_sumC ({}, B - {b})}\n             else let b = SOME x. x \\<in> f B - C\n                  in {b # cs |cs.\n                      cs \\<in> mk_linear_orders_sumC (C, B - {b})}) =\n       (if f Ba = {} then {[]}\n        else if f Ba \\<subseteq> Ca\n             then {b # cs |b cs.\n                   b \\<in> f Ba \\<and>\n                   cs \\<in> mk_linear_orders_sumC ({}, Ba - {b})}\n             else let b = SOME x. x \\<in> f Ba - Ca\n                  in {b # cs |cs.\n                      cs \\<in> mk_linear_orders_sumC (Ca, Ba - {b})})", "by %invisible pat_completeness auto"], ["", "context\n  assumes \"f_range_on A f\"\nbegin"], ["", "(*<*)\n\nprivate"], ["", "lemma mk_linear_orders_termination:\n  assumes \"B \\<subseteq> A\"\n  shows \"mk_linear_orders_dom (C, B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B)", "using \\<open>B \\<subseteq> A\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B)", "proof(induct t \\<equiv> \"card B\" arbitrary: B C)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B C.\n       \\<lbrakk>0 = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)\n 2. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "case (0 B)"], ["proof (state)\nthis:\n  0 = card B\n  B \\<subseteq> A\n\ngoal (2 subgoals):\n 1. \\<And>B C.\n       \\<lbrakk>0 = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)\n 2. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  0 = card B\n  B \\<subseteq> A", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  0 = card B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B)", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  0 = card B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B)", "by (auto intro: mk_linear_orders.domintros)"], ["proof (state)\nthis:\n  local.mk_linear_orders_dom (C, B)\n\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "case (Suc i B)"], ["proof (state)\nthis:\n  \\<lbrakk>i = card ?B; ?B \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom (?C, ?B)\n  Suc i = card B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "have \"mk_linear_orders_dom ({}, B - {b})\" if \"b \\<in> f B\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom ({}, B - {b})", "using \\<open>f_range_on A f\\<close> Suc.hyps(2) Suc.prems Suc.hyps(1)[where B=\"B - {b}\" and C=\"{}\"] finite[of B] that"], ["proof (prove)\nusing this:\n  f_range_on A f\n  Suc i = card B\n  B \\<subseteq> A\n  \\<lbrakk>i = card (B - {b}); B - {b} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {b})\n  finite B\n  b \\<in> f B\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom ({}, B - {b})", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  Suc i = card B\n  B \\<subseteq> A\n  \\<lbrakk>i = card (B - {b}); B - {b} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {b})\n  finite B\n  b \\<in> f B\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom ({}, B - {b})", "by (metis Diff_subset card_Diff_singleton contra_subsetD diff_Suc_1 subset_trans)"], ["proof (state)\nthis:\n  ?b \\<in> f B \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {?b})\n\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "moreover"], ["proof (state)\nthis:\n  ?b \\<in> f B \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {?b})\n\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "have \"mk_linear_orders_dom (C, B - {SOME x. x \\<in> f B - C})\" if \"b \\<in> f B\" and \"b \\<notin> C\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B - {SOME x. x \\<in> f B - C})", "using \\<open>f_range_on A f\\<close> Suc.hyps(2) Suc.prems Suc.hyps(1)[where B=\"B - {SOME x. x \\<in> f B - C}\" and C=\"C\"] that"], ["proof (prove)\nusing this:\n  f_range_on A f\n  Suc i = card B\n  B \\<subseteq> A\n  \\<lbrakk>i = card (B - {SOME x. x \\<in> f B - C});\n   B - {SOME x. x \\<in> f B - C} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom\n                     (C, B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B - {SOME x. x \\<in> f B - C})", "by (clarsimp simp: card_Diff_singleton_if) (metis (mono_tags, lifting) contra_subsetD diff_Suc_1 f_range_onD someI subset_insertI2 subset_insert_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?b \\<in> f B; ?b \\<notin> C\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom\n                     (C, B - {SOME x. x \\<in> f B - C})\n\ngoal (1 subgoal):\n 1. \\<And>t B C.\n       \\<lbrakk>\\<And>B C.\n                   \\<lbrakk>t = card B; B \\<subseteq> A\\<rbrakk>\n                   \\<Longrightarrow> local.mk_linear_orders_dom (C, B);\n        Suc t = card B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> local.mk_linear_orders_dom (C, B)", "ultimately"], ["proof (chain)\npicking this:\n  ?b \\<in> f B \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {?b})\n  \\<lbrakk>?b \\<in> f B; ?b \\<notin> C\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom\n                     (C, B - {SOME x. x \\<in> f B - C})", "show ?case"], ["proof (prove)\nusing this:\n  ?b \\<in> f B \\<Longrightarrow> local.mk_linear_orders_dom ({}, B - {?b})\n  \\<lbrakk>?b \\<in> f B; ?b \\<notin> C\\<rbrakk>\n  \\<Longrightarrow> local.mk_linear_orders_dom\n                     (C, B - {SOME x. x \\<in> f B - C})\n\ngoal (1 subgoal):\n 1. local.mk_linear_orders_dom (C, B)", "by (auto intro: mk_linear_orders.domintros)"], ["proof (state)\nthis:\n  local.mk_linear_orders_dom (C, B)\n\ngoal:\nNo subgoals!", "(* the simplifier has made a mess of the rule *)"], ["proof (state)\nthis:\n  local.mk_linear_orders_dom (C, B)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma mk_linear_orders_induct[consumes 2, case_names base step1 step2]:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes base: \"\\<And>C B. \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk> \\<Longrightarrow> P C B []\"\n  assumes step1: \"\\<And>C B b cs. \\<lbrakk>B \\<subseteq> A; cs \\<in> mk_linear_orders {} (B - {b}); b \\<in> f B; f B \\<subseteq> C; P {} (B - {b}) cs\\<rbrakk>\n                          \\<Longrightarrow> P C B (b # cs)\"\n  assumes step2: \"\\<And>C B b cs. \\<lbrakk>B \\<subseteq> A; cs \\<in> mk_linear_orders C (B - {SOME x. x \\<in> f B - C}); b \\<in> f B; b \\<notin> C; P C (B - {SOME x. x \\<in> f B - C}) cs\\<rbrakk>\n                          \\<Longrightarrow> P C B ((SOME x. x \\<in> f B - C) # cs)\"\n  shows \"P C B r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P C B r", "using mk_linear_orders_termination[OF \\<open>B \\<subseteq> A\\<close>, where C=C] assms(1,2)"], ["proof (prove)\nusing this:\n  local.mk_linear_orders_dom (C, B)\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. P C B r", "proof(induct arbitrary: r rule: mk_linear_orders.pinduct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C B r.\n       \\<lbrakk>local.mk_linear_orders_dom (C, B);\n        \\<And>x xa xb r.\n           \\<lbrakk>f B \\<noteq> {}; f B \\<subseteq> C; x = xa # xb;\n            xa \\<in> f B; r \\<in> local.mk_linear_orders {} (B - {xa});\n            B - {xa} \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> P {} (B - {xa}) r;\n        \\<And>x xa xb r.\n           \\<lbrakk>f B \\<noteq> {}; \\<not> f B \\<subseteq> C;\n            x = (SOME x. x \\<in> f B - C); xa = x # xb;\n            r \\<in> local.mk_linear_orders C (B - {x});\n            B - {x} \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> P C (B - {x}) r;\n        r \\<in> local.mk_linear_orders C B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> P C B r", "case (1 C B r)"], ["proof (state)\nthis:\n  local.mk_linear_orders_dom (C, B)\n  \\<lbrakk>f B \\<noteq> {}; f B \\<subseteq> C; ?x = ?xa # ?xb;\n   ?xa \\<in> f B; ?r \\<in> local.mk_linear_orders {} (B - {?xa});\n   B - {?xa} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P {} (B - {?xa}) ?r\n  \\<lbrakk>f B \\<noteq> {}; \\<not> f B \\<subseteq> C;\n   ?x = (SOME x. x \\<in> f B - C); ?xa = ?x # ?xb;\n   ?r \\<in> local.mk_linear_orders C (B - {?x});\n   B - {?x} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P C (B - {?x}) ?r\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>C B r.\n       \\<lbrakk>local.mk_linear_orders_dom (C, B);\n        \\<And>x xa xb r.\n           \\<lbrakk>f B \\<noteq> {}; f B \\<subseteq> C; x = xa # xb;\n            xa \\<in> f B; r \\<in> local.mk_linear_orders {} (B - {xa});\n            B - {xa} \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> P {} (B - {xa}) r;\n        \\<And>x xa xb r.\n           \\<lbrakk>f B \\<noteq> {}; \\<not> f B \\<subseteq> C;\n            x = (SOME x. x \\<in> f B - C); xa = x # xb;\n            r \\<in> local.mk_linear_orders C (B - {x});\n            B - {x} \\<subseteq> A\\<rbrakk>\n           \\<Longrightarrow> P C (B - {x}) r;\n        r \\<in> local.mk_linear_orders C B; B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> P C B r", "then"], ["proof (chain)\npicking this:\n  local.mk_linear_orders_dom (C, B)\n  \\<lbrakk>f B \\<noteq> {}; f B \\<subseteq> C; ?x = ?xa # ?xb;\n   ?xa \\<in> f B; ?r \\<in> local.mk_linear_orders {} (B - {?xa});\n   B - {?xa} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P {} (B - {?xa}) ?r\n  \\<lbrakk>f B \\<noteq> {}; \\<not> f B \\<subseteq> C;\n   ?x = (SOME x. x \\<in> f B - C); ?xa = ?x # ?xb;\n   ?r \\<in> local.mk_linear_orders C (B - {?x});\n   B - {?x} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P C (B - {?x}) ?r\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A", "show ?case"], ["proof (prove)\nusing this:\n  local.mk_linear_orders_dom (C, B)\n  \\<lbrakk>f B \\<noteq> {}; f B \\<subseteq> C; ?x = ?xa # ?xb;\n   ?xa \\<in> f B; ?r \\<in> local.mk_linear_orders {} (B - {?xa});\n   B - {?xa} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P {} (B - {?xa}) ?r\n  \\<lbrakk>f B \\<noteq> {}; \\<not> f B \\<subseteq> C;\n   ?x = (SOME x. x \\<in> f B - C); ?xa = ?x # ?xb;\n   ?r \\<in> local.mk_linear_orders C (B - {?x});\n   B - {?x} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> P C (B - {?x}) ?r\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. P C B r", "by (fastforce simp: mk_linear_orders.psimps Let_def base split: if_splits\n                intro!: step1 step2[simplified] 1)"], ["proof (state)\nthis:\n  P C B r\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma mk_linear_orders_non_empty:\n  assumes \"B \\<subseteq> A\"\n  shows \"\\<exists>r. r \\<in> mk_linear_orders C B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. r \\<in> local.mk_linear_orders C B", "using %invisible assms"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>r. r \\<in> local.mk_linear_orders C B", "proof(induct t \\<equiv> \"card B\" arbitrary: B C rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "case (1 B C)"], ["proof (state)\nthis:\n  \\<forall>m<card B.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        x \\<subseteq> A \\<longrightarrow>\n        (\\<forall>xa. \\<exists>r. r \\<in> local.mk_linear_orders xa x)\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "{"], ["proof (state)\nthis:\n  \\<forall>m<card B.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        x \\<subseteq> A \\<longrightarrow>\n        (\\<forall>xa. \\<exists>r. r \\<in> local.mk_linear_orders xa x)\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "assume \"f B \\<subseteq> C\" \"f B \\<noteq> {}\""], ["proof (state)\nthis:\n  f B \\<subseteq> C\n  f B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "with \\<open>f_range_on A f\\<close> 1"], ["proof (chain)\npicking this:\n  f_range_on A f\n  \\<forall>m<card B.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        x \\<subseteq> A \\<longrightarrow>\n        (\\<forall>xa. \\<exists>r. r \\<in> local.mk_linear_orders xa x)\n  B \\<subseteq> A\n  f B \\<subseteq> C\n  f B \\<noteq> {}", "have \"\\<exists>b. b \\<in> f B \\<and> (\\<exists>cs. cs \\<in> local.mk_linear_orders {} (B - {b}))\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  \\<forall>m<card B.\n     \\<forall>x.\n        m = card x \\<longrightarrow>\n        x \\<subseteq> A \\<longrightarrow>\n        (\\<forall>xa. \\<exists>r. r \\<in> local.mk_linear_orders xa x)\n  B \\<subseteq> A\n  f B \\<subseteq> C\n  f B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<in> f B \\<and>\n       (\\<exists>cs. cs \\<in> local.mk_linear_orders {} (B - {b}))", "by safe (metis Diff_subset card_Diff1_less dual_order.trans finite f_range_onD')"], ["proof (state)\nthis:\n  \\<exists>b.\n     b \\<in> f B \\<and>\n     (\\<exists>cs. cs \\<in> local.mk_linear_orders {} (B - {b}))\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<in> f B \\<and>\n                       (\\<exists>cs.\n                           cs \\<in> local.mk_linear_orders {} (B - {b}))\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<in> f B \\<and>\n                       (\\<exists>cs.\n                           cs \\<in> local.mk_linear_orders {} (B - {b}))\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "{"], ["proof (state)\nthis:\n  \\<lbrakk>f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<in> f B \\<and>\n                       (\\<exists>cs.\n                           cs \\<in> local.mk_linear_orders {} (B - {b}))\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "assume \"\\<not> f B \\<subseteq> C\" \"f B \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<not> f B \\<subseteq> C\n  f B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "with \\<open>f_range_on A f\\<close> \"1.prems\""], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  \\<not> f B \\<subseteq> C\n  f B \\<noteq> {}", "have \"(SOME x. x \\<in> f B - C) \\<in> B \\<and> B - {SOME a. a \\<in> f B - C} \\<subseteq> A\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  \\<not> f B \\<subseteq> C\n  f B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> f B - C) \\<in> B \\<and>\n    B - {SOME a. a \\<in> f B - C} \\<subseteq> A", "using someI[where P=\"\\<lambda>x. x \\<in> f B - C\"]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  \\<not> f B \\<subseteq> C\n  f B \\<noteq> {}\n  ?x \\<in> f B - C \\<Longrightarrow> (SOME x. x \\<in> f B - C) \\<in> f B - C\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> f B - C) \\<in> B \\<and>\n    B - {SOME a. a \\<in> f B - C} \\<subseteq> A", "by (auto dest: f_range_onD')"], ["proof (state)\nthis:\n  (SOME x. x \\<in> f B - C) \\<in> B \\<and>\n  B - {SOME a. a \\<in> f B - C} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "with \"1.hyps\"[rule_format, where x=\"B - {SOME x. x \\<in> f B - C}\" and xa=C, OF _ refl]"], ["proof (chain)\npicking this:\n  \\<lbrakk>card (B - {SOME x. x \\<in> f B - C}) < card B;\n   B - {SOME x. x \\<in> f B - C} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       r \\<in> local.mk_linear_orders C\n                                (B - {SOME x. x \\<in> f B - C})\n  (SOME x. x \\<in> f B - C) \\<in> B \\<and>\n  B - {SOME a. a \\<in> f B - C} \\<subseteq> A", "have \"\\<exists>cs. cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B \\<and> x \\<notin> C})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>card (B - {SOME x. x \\<in> f B - C}) < card B;\n   B - {SOME x. x \\<in> f B - C} \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       r \\<in> local.mk_linear_orders C\n                                (B - {SOME x. x \\<in> f B - C})\n  (SOME x. x \\<in> f B - C) \\<in> B \\<and>\n  B - {SOME a. a \\<in> f B - C} \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       cs \\<in> local.mk_linear_orders C\n                 (B - {SOME x. x \\<in> f B \\<and> x \\<notin> C})", "by clarsimp (metis card_gt_0_iff diff_Suc_less equals0D finite)"], ["proof (state)\nthis:\n  \\<exists>cs.\n     cs \\<in> local.mk_linear_orders C\n               (B - {SOME x. x \\<in> f B \\<and> x \\<notin> C})\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs.\n                       cs \\<in> local.mk_linear_orders C\n                                 (B -\n                                  {SOME x. x \\<in> f B \\<and> x \\<notin> C})\n\ngoal (1 subgoal):\n 1. \\<And>B C.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>x.\n                      m = card x \\<longrightarrow>\n                      x \\<subseteq> A \\<longrightarrow>\n                      (\\<forall>xa.\n                          \\<exists>r. r \\<in> local.mk_linear_orders xa x);\n        B \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r. r \\<in> local.mk_linear_orders C B", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<in> f B \\<and>\n                       (\\<exists>cs.\n                           cs \\<in> local.mk_linear_orders {} (B - {b}))\n  \\<lbrakk>\\<not> f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs.\n                       cs \\<in> local.mk_linear_orders C\n                                 (B -\n                                  {SOME x. x \\<in> f B \\<and> x \\<notin> C})", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>b.\n                       b \\<in> f B \\<and>\n                       (\\<exists>cs.\n                           cs \\<in> local.mk_linear_orders {} (B - {b}))\n  \\<lbrakk>\\<not> f B \\<subseteq> C; f B \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs.\n                       cs \\<in> local.mk_linear_orders C\n                                 (B -\n                                  {SOME x. x \\<in> f B \\<and> x \\<notin> C})\n\ngoal (1 subgoal):\n 1. \\<exists>r. r \\<in> local.mk_linear_orders C B", "by (clarsimp simp: mk_linear_orders.psimps[OF mk_linear_orders_termination[OF \\<open>B \\<subseteq>A\\<close>]] Let_def)"], ["proof (state)\nthis:\n  \\<exists>r. r \\<in> local.mk_linear_orders C B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_linear_orders_range:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"set r \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set r \\<subseteq> B", "using %invisible assms"], ["proof (prove)\nusing this:\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set r \\<subseteq> B", "proof(induct rule: mk_linear_orders_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs \\<subseteq> B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) \\<subseteq> B\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "case (base C B)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  f B = {}\n\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs \\<subseteq> B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) \\<subseteq> B\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  f B = {}", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  f B = {}\n\ngoal (1 subgoal):\n 1. set [] \\<subseteq> B", "by (simp add: f_range_on_def)"], ["proof (state)\nthis:\n  set [] \\<subseteq> B\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs \\<subseteq> B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) \\<subseteq> B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs \\<subseteq> B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) \\<subseteq> B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "case (step1 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs \\<subseteq> B - {b}\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs \\<subseteq> B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) \\<subseteq> B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs \\<subseteq> B - {b}", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs \\<subseteq> B - {b}\n\ngoal (1 subgoal):\n 1. set (b # cs) \\<subseteq> B", "by (auto dest: f_range_onD)"], ["proof (state)\nthis:\n  set (b # cs) \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "case (step2 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs \\<subseteq> B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B", "by clarsimp (metis (mono_tags, lifting) Diff_subset someI_ex subset_eq f_range_onD)"], ["proof (state)\nthis:\n  set ((SOME x. x \\<in> f B - C) # cs) \\<subseteq> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_linear_orders_nth:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"i < length r\"\n  shows \"r ! i \\<in> f (B - set (take i r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r ! i \\<in> f (B - set (take i r))", "using %invisible assms"], ["proof (prove)\nusing this:\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n  i < length r\n\ngoal (1 subgoal):\n 1. r ! i \\<in> f (B - set (take i r))", "proof(induct arbitrary: i rule: mk_linear_orders_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))\n 2. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {b} - set (take i cs));\n        i < length (b # cs)\\<rbrakk>\n       \\<Longrightarrow> (b # cs) ! i \\<in> f (B - set (take i (b # cs)))\n 3. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take i cs));\n        i < length ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> ((SOME x. x \\<in> f B - C) # cs) ! i\n                         \\<in> f (B -\n                                  set (take i\n  ((SOME x. x \\<in> f B - C) # cs)))", "case (step1 C B b cs i)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {b} - set (take ?i cs))\n  i < length (b # cs)\n\ngoal (3 subgoals):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))\n 2. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {b} - set (take i cs));\n        i < length (b # cs)\\<rbrakk>\n       \\<Longrightarrow> (b # cs) ! i \\<in> f (B - set (take i (b # cs)))\n 3. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take i cs));\n        i < length ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> ((SOME x. x \\<in> f B - C) # cs) ! i\n                         \\<in> f (B -\n                                  set (take i\n  ((SOME x. x \\<in> f B - C) # cs)))", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {b} - set (take ?i cs))\n  i < length (b # cs)", "show ?case"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {b} - set (take ?i cs))\n  i < length (b # cs)\n\ngoal (1 subgoal):\n 1. (b # cs) ! i \\<in> f (B - set (take i (b # cs)))", "by (cases i) (simp_all add: Diff_insert2[symmetric])"], ["proof (state)\nthis:\n  (b # cs) ! i \\<in> f (B - set (take i (b # cs)))\n\ngoal (2 subgoals):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))\n 2. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take i cs));\n        i < length ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> ((SOME x. x \\<in> f B - C) # cs) ! i\n                         \\<in> f (B -\n                                  set (take i\n  ((SOME x. x \\<in> f B - C) # cs)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))\n 2. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take i cs));\n        i < length ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> ((SOME x. x \\<in> f B - C) # cs) ! i\n                         \\<in> f (B -\n                                  set (take i\n  ((SOME x. x \\<in> f B - C) # cs)))", "case (step2 C B b cs i)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take ?i cs))\n  i < length ((SOME x. x \\<in> f B - C) # cs)\n\ngoal (2 subgoals):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))\n 2. \\<And>C B b cs i.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        \\<And>i.\n           i < length cs \\<Longrightarrow>\n           cs ! i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take i cs));\n        i < length ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> ((SOME x. x \\<in> f B - C) # cs) ! i\n                         \\<in> f (B -\n                                  set (take i\n  ((SOME x. x \\<in> f B - C) # cs)))", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take ?i cs))\n  i < length ((SOME x. x \\<in> f B - C) # cs)", "show ?case"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  ?i < length cs \\<Longrightarrow>\n  cs ! ?i \\<in> f (B - {SOME x. x \\<in> f B - C} - set (take ?i cs))\n  i < length ((SOME x. x \\<in> f B - C) # cs)\n\ngoal (1 subgoal):\n 1. ((SOME x. x \\<in> f B - C) # cs) ! i\n    \\<in> f (B - set (take i ((SOME x. x \\<in> f B - C) # cs)))", "by (cases i) (auto simp: Diff_insert2[symmetric] intro: someI2)"], ["proof (state)\nthis:\n  ((SOME x. x \\<in> f B - C) # cs) ! i\n  \\<in> f (B - set (take i ((SOME x. x \\<in> f B - C) # cs)))\n\ngoal (1 subgoal):\n 1. \\<And>C B i.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; i < length []\\<rbrakk>\n       \\<Longrightarrow> [] ! i \\<in> f (B - set (take i []))", "qed simp"], ["", "lemma mk_linear_orders_distinct:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  shows \"distinct r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct r", "using %invisible assms"], ["proof (prove)\nusing this:\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. distinct r", "proof(induct rule: mk_linear_orders_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct (b # cs)\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct ((SOME x. x \\<in> f B - C) # cs)", "case (step1 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  distinct cs\n\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct (b # cs)\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct ((SOME x. x \\<in> f B - C) # cs)", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  distinct cs", "show ?case"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  distinct cs\n\ngoal (1 subgoal):\n 1. distinct (b # cs)", "by simp (metis Diff_eq_empty_iff Diff_subset Diff_subset_conv le_iff_sup mk_linear_orders_range subset_Diff_insert)"], ["proof (state)\nthis:\n  distinct (b # cs)\n\ngoal (2 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct ((SOME x. x \\<in> f B - C) # cs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct ((SOME x. x \\<in> f B - C) # cs)", "case (step2 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  distinct cs\n\ngoal (2 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C; distinct cs\\<rbrakk>\n       \\<Longrightarrow> distinct ((SOME x. x \\<in> f B - C) # cs)", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  distinct cs", "show ?case"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  distinct cs\n\ngoal (1 subgoal):\n 1. distinct ((SOME x. x \\<in> f B - C) # cs)", "by simp (meson Diff_subset order.trans mk_linear_orders_range subset_Diff_insert)"], ["proof (state)\nthis:\n  distinct ((SOME x. x \\<in> f B - C) # cs)\n\ngoal (1 subgoal):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> distinct []", "qed simp"], ["", "lemma mk_linear_orders_Linear_order:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  shows \"Linear_order (linord_of_list r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (linord_of_list r)", "using %invisible mk_linear_orders_distinct[OF assms(1)] linord_of_list_Linear_order"], ["proof (prove)\nusing this:\n  A \\<subseteq> A \\<Longrightarrow> distinct r\n  \\<lbrakk>distinct ?xs; ?ys = set ?xs\\<rbrakk>\n  \\<Longrightarrow> linear_order_on ?ys (linord_of_list ?xs)\n\ngoal (1 subgoal):\n 1. Linear_order (linord_of_list r)", "by fastforce"], ["", "lemma mk_linear_orders_decisive_on_set_r:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"decisive_on A f\"\n  assumes \"B \\<subseteq> A\"\n  shows \"set r = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set r = B", "using %invisible assms(1,3)"], ["proof (prove)\nusing this:\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. set r = B", "proof(induct rule: mk_linear_orders_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> set [] = B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs = B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) = B\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "case (base C B)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  f B = {}\n\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}\\<rbrakk>\n       \\<Longrightarrow> set [] = B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs = B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) = B\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "with \\<open>decisive_on A f\\<close>"], ["proof (chain)\npicking this:\n  decisive_on A f\n  B \\<subseteq> A\n  f B = {}", "show ?case"], ["proof (prove)\nusing this:\n  decisive_on A f\n  B \\<subseteq> A\n  f B = {}\n\ngoal (1 subgoal):\n 1. set [] = B", "by (auto dest: decisive_onD)"], ["proof (state)\nthis:\n  set [] = B\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs = B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) = B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs = B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) = B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "case (step1 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs = B - {b}\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C; set cs = B - {b}\\<rbrakk>\n       \\<Longrightarrow> set (b # cs) = B\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs = B - {b}", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  set cs = B - {b}\n\ngoal (1 subgoal):\n 1. set (b # cs) = B", "by (auto dest: f_range_onD)"], ["proof (state)\nthis:\n  set (b # cs) = B\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "case (step2 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs = B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        set cs = B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n       \\<Longrightarrow> set ((SOME x. x \\<in> f B - C) # cs) = B", "with \\<open>f_range_on A f\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs = B - {SOME x. x \\<in> f B - C}", "show ?case"], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs = B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. set ((SOME x. x \\<in> f B - C) # cs) = B", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  set cs = B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. set ((SOME x. x \\<in> f B - C) # cs) = B", "by clarsimp (metis (no_types, lifting) Un_iff insert_Diff insert_Diff_single someI subset_Un_eq)"], ["proof (state)\nthis:\n  set ((SOME x. x \\<in> f B - C) # cs) = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_linear_orders_decisive_on_refl_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"decisive_on A f\"\n  shows \"refl_on A (linord_of_list r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on A (linord_of_list r)", "using %invisible linord_of_list_refl_on mk_linear_orders_decisive_on_set_r[OF assms]"], ["proof (prove)\nusing this:\n  refl_on (set ?xs) (linord_of_list ?xs)\n  A \\<subseteq> A \\<Longrightarrow> set r = A\n\ngoal (1 subgoal):\n 1. refl_on A (linord_of_list r)", "by blast"], ["", "lemma mk_linear_orders_decisive_on_total_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"decisive_on A f\"\n  shows \"total_on A (linord_of_list r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total_on A (linord_of_list r)", "using %invisible linord_of_list_total_on mk_linear_orders_decisive_on_set_r[OF assms]"], ["proof (prove)\nusing this:\n  total_on (set ?xs) (linord_of_list ?xs)\n  A \\<subseteq> A \\<Longrightarrow> set r = A\n\ngoal (1 subgoal):\n 1. total_on A (linord_of_list r)", "by blast"], ["", "lemma mk_linear_orders_set_r_decisive_on:\n  assumes \"r \\<in> mk_linear_orders C B\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"B \\<subseteq> set r\"\n  assumes \"iia_on A f\"\n  shows \"decisive_on B f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on B f", "using %invisible assms(1-3)"], ["proof (prove)\nusing this:\n  r \\<in> local.mk_linear_orders C B\n  B \\<subseteq> A\n  B \\<subseteq> set r\n\ngoal (1 subgoal):\n 1. decisive_on B f", "proof(induct rule: mk_linear_orders_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; B \\<subseteq> set []\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "case (base C B)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  f B = {}\n  B \\<subseteq> set []\n\ngoal (3 subgoals):\n 1. \\<And>C B.\n       \\<lbrakk>B \\<subseteq> A; f B = {}; B \\<subseteq> set []\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 3. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "with decisive_on_empty[of f]"], ["proof (chain)\npicking this:\n  decisive_on {} f\n  B \\<subseteq> A\n  f B = {}\n  B \\<subseteq> set []", "show ?case"], ["proof (prove)\nusing this:\n  decisive_on {} f\n  B \\<subseteq> A\n  f B = {}\n  B \\<subseteq> set []\n\ngoal (1 subgoal):\n 1. decisive_on B f", "by simp"], ["proof (state)\nthis:\n  decisive_on B f\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "case (step1 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  B - {b} \\<subseteq> set cs \\<Longrightarrow> decisive_on (B - {b}) f\n  B \\<subseteq> set (b # cs)\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "with mk_linear_orders_range[OF step1.hyps(2)]"], ["proof (chain)\npicking this:\n  B - {b} \\<subseteq> A \\<Longrightarrow> set cs \\<subseteq> B - {b}\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  B - {b} \\<subseteq> set cs \\<Longrightarrow> decisive_on (B - {b}) f\n  B \\<subseteq> set (b # cs)", "have \"set cs \\<subseteq> B - {b}\" \"decisive_on (B - {b}) f\""], ["proof (prove)\nusing this:\n  B - {b} \\<subseteq> A \\<Longrightarrow> set cs \\<subseteq> B - {b}\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  B - {b} \\<subseteq> set cs \\<Longrightarrow> decisive_on (B - {b}) f\n  B \\<subseteq> set (b # cs)\n\ngoal (1 subgoal):\n 1. set cs \\<subseteq> B - {b} &&& decisive_on (B - {b}) f", "by fastforce+"], ["proof (state)\nthis:\n  set cs \\<subseteq> B - {b}\n  decisive_on (B - {b}) f\n\ngoal (2 subgoals):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders {} (B - {b}); b \\<in> f B;\n        f B \\<subseteq> C;\n        B - {b} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {b}) f;\n        B \\<subseteq> set (b # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f\n 2. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "with step1 \\<open>iia_on A f\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  B - {b} \\<subseteq> set cs \\<Longrightarrow> decisive_on (B - {b}) f\n  B \\<subseteq> set (b # cs)\n  iia_on A f\n  set cs \\<subseteq> B - {b}\n  decisive_on (B - {b}) f", "show ?case"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders {} (B - {b})\n  b \\<in> f B\n  f B \\<subseteq> C\n  B - {b} \\<subseteq> set cs \\<Longrightarrow> decisive_on (B - {b}) f\n  B \\<subseteq> set (b # cs)\n  iia_on A f\n  set cs \\<subseteq> B - {b}\n  decisive_on (B - {b}) f\n\ngoal (1 subgoal):\n 1. decisive_on B f", "by - (rule decisive_onI; metis (no_types, lifting) Diff_empty Diff_insert0 insert_Diff insert_not_empty subset_insert_iff decisive_onD iia_onD)"], ["proof (state)\nthis:\n  decisive_on B f\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "case (step2 C B b cs)"], ["proof (state)\nthis:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)", "have XXX: \"decisive_on (B - {SOME x. x \\<in> f B - C}) f\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\n\ngoal (1 subgoal):\n 1. decisive_on (B - {SOME x. x \\<in> f B - C}) f", "by force"], ["proof (state)\nthis:\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n\ngoal (1 subgoal):\n 1. \\<And>C B b cs.\n       \\<lbrakk>B \\<subseteq> A;\n        cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C});\n        b \\<in> f B; b \\<notin> C;\n        B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n        decisive_on (B - {SOME x. x \\<in> f B - C}) f;\n        B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\\<rbrakk>\n       \\<Longrightarrow> decisive_on B f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on B f", "proof(rule decisive_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<subseteq> B; B \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f B \\<noteq> {}", "fix D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<subseteq> B; B \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f B \\<noteq> {}", "assume \"D \\<subseteq> B\" \"D \\<noteq> {}\""], ["proof (state)\nthis:\n  D \\<subseteq> B\n  D \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>B \\<subseteq> B; B \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f B \\<noteq> {}", "with \\<open>iia_on A f\\<close> step2 XXX"], ["proof (chain)\npicking this:\n  iia_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  D \\<subseteq> B\n  D \\<noteq> {}", "show \"f D \\<noteq> {}\""], ["proof (prove)\nusing this:\n  iia_on A f\n  B \\<subseteq> A\n  cs \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  b \\<in> f B\n  b \\<notin> C\n  B - {SOME x. x \\<in> f B - C} \\<subseteq> set cs \\<Longrightarrow>\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  B \\<subseteq> set ((SOME x. x \\<in> f B - C) # cs)\n  decisive_on (B - {SOME x. x \\<in> f B - C}) f\n  D \\<subseteq> B\n  D \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f D \\<noteq> {}", "by (cases \"(SOME x. x \\<in> f B - C) \\<in> D\")\n         (simp_all, metis (no_types, lifting) emptyE iia_onD someI_ex, blast dest: decisive_onD)"], ["proof (state)\nthis:\n  f D \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decisive_on B f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_linear_orders_total_on_decisive_on:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"A \\<subseteq> set r\"\n  assumes \"iia_on A f\"\n  shows \"decisive_on A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisive_on A f", "using %invisible mk_linear_orders_set_r_decisive_on[OF assms(1) _ _ assms(3)] linord_of_list_Field[of r] \\<open>A \\<subseteq> set r\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<subseteq> A; A \\<subseteq> set r\\<rbrakk>\n  \\<Longrightarrow> decisive_on A f\n  Field (linord_of_list r) = set r\n  A \\<subseteq> set r\n\ngoal (1 subgoal):\n 1. decisive_on A f", "by simp"], ["", "lemma mk_linear_orders_MaxR_opt_f:\n  assumes \"r \\<in> mk_linear_orders C A\"\n  assumes \"MaxR.MaxR_opt (linord_of_list r) D = Some x\"\n  assumes \"iia_on A f\"\n  assumes \"D \\<subseteq> A\"\n  shows \"x \\<in> f D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f D", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> f D", "from linord_of_list_Linear_order[OF mk_linear_orders_distinct[OF assms(1) subset_refl]]"], ["proof (chain)\npicking this:\n  ?ys = set r \\<Longrightarrow> linear_order_on ?ys (linord_of_list r)", "have \"MaxR (linord_of_list r)\""], ["proof (prove)\nusing this:\n  ?ys = set r \\<Longrightarrow> linear_order_on ?ys (linord_of_list r)\n\ngoal (1 subgoal):\n 1. MaxR (linord_of_list r)", "by (rule MaxR.intro) simp"], ["proof (state)\nthis:\n  MaxR (linord_of_list r)\n\ngoal (1 subgoal):\n 1. x \\<in> f D", "with assms(2)"], ["proof (chain)\npicking this:\n  MaxR.MaxR_opt (linord_of_list r) D = Some x\n  MaxR (linord_of_list r)", "have \"x \\<in> greatest (linord_of_list r) (D \\<inter> Field (linord_of_list r))\""], ["proof (prove)\nusing this:\n  MaxR.MaxR_opt (linord_of_list r) D = Some x\n  MaxR (linord_of_list r)\n\ngoal (1 subgoal):\n 1. x \\<in> greatest (linord_of_list r)\n             (D \\<inter> Field (linord_of_list r))", "using MaxR.greatest elem_set"], ["proof (prove)\nusing this:\n  MaxR.MaxR_opt (linord_of_list r) D = Some x\n  MaxR (linord_of_list r)\n  MaxR ?r \\<Longrightarrow>\n  set_option (MaxR.MaxR_opt ?r ?X) = greatest ?r (?X \\<inter> Field ?r)\n  (?x \\<in> set_option ?xo) = (?xo = Some ?x)\n\ngoal (1 subgoal):\n 1. x \\<in> greatest (linord_of_list r)\n             (D \\<inter> Field (linord_of_list r))", "by blast"], ["proof (state)\nthis:\n  x \\<in> greatest (linord_of_list r) (D \\<inter> Field (linord_of_list r))\n\ngoal (1 subgoal):\n 1. x \\<in> f D", "then"], ["proof (chain)\npicking this:\n  x \\<in> greatest (linord_of_list r) (D \\<inter> Field (linord_of_list r))", "obtain i where \"x = r ! i\" and \"i < length r\" and \"\\<forall>j<i. r ! j \\<notin> D\""], ["proof (prove)\nusing this:\n  x \\<in> greatest (linord_of_list r) (D \\<inter> Field (linord_of_list r))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = r ! i; i < length r;\n         \\<forall>j<i. r ! j \\<notin> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding greatest_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> D \\<inter> Field (linord_of_list r).\n           \\<forall>y\\<in>D \\<inter> Field (linord_of_list r).\n              (y, x) \\<in> linord_of_list r}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = r ! i; i < length r;\n         \\<forall>j<i. r ! j \\<notin> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mk_linear_orders_distinct[OF assms(1) subset_refl] linord_of_list_nth[where xs=r]"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> D \\<inter> Field (linord_of_list r).\n           \\<forall>y\\<in>D \\<inter> Field (linord_of_list r).\n              (y, x) \\<in> linord_of_list r}\n  distinct r\n  \\<lbrakk>(r ! ?i, r ! ?j) \\<in> linord_of_list r; ?i < length r;\n   ?j < length r; distinct r\\<rbrakk>\n  \\<Longrightarrow> ?j \\<le> ?i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = r ! i; i < length r;\n         \\<forall>j<i. r ! j \\<notin> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (clarsimp simp: set_conv_nth; metis IntI less_trans not_le nth_mem set_conv_nth)"], ["proof (state)\nthis:\n  x = r ! i\n  i < length r\n  \\<forall>j<i. r ! j \\<notin> D\n\ngoal (1 subgoal):\n 1. x \\<in> f D", "with \\<open>iia_on A f\\<close> \\<open>D \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  iia_on A f\n  D \\<subseteq> A\n  x = r ! i\n  i < length r\n  \\<forall>j<i. r ! j \\<notin> D", "show ?thesis"], ["proof (prove)\nusing this:\n  iia_on A f\n  D \\<subseteq> A\n  x = r ! i\n  i < length r\n  \\<forall>j<i. r ! j \\<notin> D\n\ngoal (1 subgoal):\n 1. x \\<in> f D", "using mk_linear_orders_nth[OF assms(1), where i=i]\n          iia_onD[of A f, where B=\"A - set (take i r)\" and C=D and a=x]\n          MaxR.range_Some[rule_format, OF \\<open>MaxR (linord_of_list r)\\<close> assms(2)]"], ["proof (prove)\nusing this:\n  iia_on A f\n  D \\<subseteq> A\n  x = r ! i\n  i < length r\n  \\<forall>j<i. r ! j \\<notin> D\n  \\<lbrakk>A \\<subseteq> A; i < length r\\<rbrakk>\n  \\<Longrightarrow> r ! i \\<in> f (A - set (take i r))\n  \\<lbrakk>iia_on A f; A - set (take i r) \\<subseteq> A;\n   D \\<subseteq> A - set (take i r); x \\<in> D;\n   x \\<in> f (A - set (take i r))\\<rbrakk>\n  \\<Longrightarrow> x \\<in> f D\n  x \\<in> D \\<inter> Field (linord_of_list r)\n\ngoal (1 subgoal):\n 1. x \\<in> f D", "by (fastforce simp: nth_image[symmetric])"], ["proof (state)\nthis:\n  x \\<in> f D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_linear_orders_f_MaxR_opt:\n  assumes \"x \\<in> f C\"\n  assumes \"consistency_on A f\"\n  assumes \"B \\<subseteq> A\"\n  assumes \"C \\<subseteq> B\"\n  shows \"\\<exists>r\\<in>mk_linear_orders C B. MaxR.MaxR_opt (linord_of_list r) C = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "using %invisible \\<open>B \\<subseteq> A\\<close> \\<open>C \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "proof(induct t \\<equiv> \"card B\" arbitrary: B rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>xa.\n                      m = card xa \\<longrightarrow>\n                      xa \\<subseteq> A \\<longrightarrow>\n                      C \\<subseteq> xa \\<longrightarrow>\n                      (\\<exists>r\\<in>local.mk_linear_orders C xa.\n                          MaxR.MaxR_opt (linord_of_list r) C = Some x);\n        B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>local.mk_linear_orders C B.\n                            MaxR.MaxR_opt (linord_of_list r) C = Some x", "case (1 B)"], ["proof (state)\nthis:\n  \\<forall>m<card B.\n     \\<forall>xa.\n        m = card xa \\<longrightarrow>\n        xa \\<subseteq> A \\<longrightarrow>\n        C \\<subseteq> xa \\<longrightarrow>\n        (\\<exists>r\\<in>local.mk_linear_orders C xa.\n            MaxR.MaxR_opt (linord_of_list r) C = Some x)\n  B \\<subseteq> A\n  C \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       \\<lbrakk>\\<forall>m<card B.\n                   \\<forall>xa.\n                      m = card xa \\<longrightarrow>\n                      xa \\<subseteq> A \\<longrightarrow>\n                      C \\<subseteq> xa \\<longrightarrow>\n                      (\\<exists>r\\<in>local.mk_linear_orders C xa.\n                          MaxR.MaxR_opt (linord_of_list r) C = Some x);\n        B \\<subseteq> A; C \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r\\<in>local.mk_linear_orders C B.\n                            MaxR.MaxR_opt (linord_of_list r) C = Some x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "proof(cases \"f B = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f B = {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. f B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "case True"], ["proof (state)\nthis:\n  f B = {}\n\ngoal (2 subgoals):\n 1. f B = {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. f B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "with consistency_onD[OF assms(2), where B=B and C=C] \"1.prems\" \\<open>x \\<in> f C\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> f B = f C\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n  f B = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> f B = f C\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n  f B = {}\n\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "by simp"], ["proof (state)\nthis:\n  \\<exists>r\\<in>local.mk_linear_orders C B.\n     MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal (1 subgoal):\n 1. f B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "case False"], ["proof (state)\nthis:\n  f B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "proof(cases \"f B \\<subseteq> C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "case True"], ["proof (state)\nthis:\n  f B \\<subseteq> C\n\ngoal (2 subgoals):\n 1. f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "from \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A", "obtain r where r: \"r \\<in> mk_linear_orders {} (B - {x})\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> local.mk_linear_orders {} (B - {x}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using mk_linear_orders_non_empty"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  ?B \\<subseteq> A \\<Longrightarrow>\n  \\<exists>r. r \\<in> local.mk_linear_orders ?C ?B\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<in> local.mk_linear_orders {} (B - {x}) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson Diff_subset_conv le_supI2)"], ["proof (state)\nthis:\n  r \\<in> local.mk_linear_orders {} (B - {x})\n\ngoal (2 subgoals):\n 1. f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "from True consistency_onD[OF assms(2), where B=B and C=C] \"1.prems\" \\<open>x \\<in> f C\\<close>"], ["proof (chain)\npicking this:\n  f B \\<subseteq> C\n  \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> f B = f C\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C", "have x: \"x \\<in> f B\""], ["proof (prove)\nusing this:\n  f B \\<subseteq> C\n  \\<lbrakk>B \\<subseteq> A; C \\<subseteq> B; f B \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> f B = f C\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n\ngoal (1 subgoal):\n 1. x \\<in> f B", "by blast"], ["proof (state)\nthis:\n  x \\<in> f B\n\ngoal (2 subgoals):\n 1. f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "from \\<open>f B \\<noteq> {}\\<close> True \\<open>B \\<subseteq> A\\<close> r x"], ["proof (chain)\npicking this:\n  f B \\<noteq> {}\n  f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B", "have XXX: \"x # r \\<in> mk_linear_orders C B\""], ["proof (prove)\nusing this:\n  f B \\<noteq> {}\n  f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n\ngoal (1 subgoal):\n 1. x # r \\<in> local.mk_linear_orders C B", "using mk_linear_orders_termination[of B C]"], ["proof (prove)\nusing this:\n  f B \\<noteq> {}\n  f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n  B \\<subseteq> A \\<Longrightarrow> local.mk_linear_orders_dom (C, B)\n\ngoal (1 subgoal):\n 1. x # r \\<in> local.mk_linear_orders C B", "by (simp add: mk_linear_orders.psimps card_eq_0_iff split: if_splits)"], ["proof (state)\nthis:\n  x # r \\<in> local.mk_linear_orders C B\n\ngoal (2 subgoals):\n 1. f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x\n 2. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "proof(rule bexI[OF _ XXX])"], ["proof (state)\ngoal (1 subgoal):\n 1. MaxR.MaxR_opt (linord_of_list (x # r)) C = Some x", "from \\<open>f_range_on A f\\<close> True r x \\<open>B \\<subseteq> A\\<close> \\<open>C \\<subseteq> B\\<close>  \\<open>x \\<in> f C\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  f B \\<subseteq> C\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C", "show \"MaxR.MaxR_opt (linord_of_list (x # r)) C = Some x\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  f B \\<subseteq> C\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n\ngoal (1 subgoal):\n 1. MaxR.MaxR_opt (linord_of_list (x # r)) C = Some x", "using linord_of_list_Linear_order[OF mk_linear_orders_distinct[OF XXX \\<open>B \\<subseteq> A\\<close>]]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  f B \\<subseteq> C\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n  ?ys = set (x # r) \\<Longrightarrow>\n  linear_order_on ?ys (linord_of_list (x # r))\n\ngoal (1 subgoal):\n 1. MaxR.MaxR_opt (linord_of_list (x # r)) C = Some x", "unfolding Option.elem_set[symmetric]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  f B \\<subseteq> C\n  r \\<in> local.mk_linear_orders {} (B - {x})\n  x \\<in> f B\n  B \\<subseteq> A\n  C \\<subseteq> B\n  x \\<in> f C\n  ?ys = set (x # r) \\<Longrightarrow>\n  linear_order_on ?ys (linord_of_list (x # r))\n\ngoal (1 subgoal):\n 1. x \\<in> set_option (MaxR.MaxR_opt (linord_of_list (x # r)) C)", "by (auto simp: MaxR.greatest MaxR_def greatest_def linord_of_list_linord_of_listP dest: f_range_onD)"], ["proof (state)\nthis:\n  MaxR.MaxR_opt (linord_of_list (x # r)) C = Some x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r\\<in>local.mk_linear_orders C B.\n     MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "case False"], ["proof (state)\nthis:\n  \\<not> f B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "let ?b = \"SOME x. x \\<in> f B - C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "let ?B' = \"B - {?b}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "from False \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  \\<not> f B \\<subseteq> C\n  B \\<subseteq> A", "obtain a where \"a \\<in> f B - C\""], ["proof (prove)\nusing this:\n  \\<not> f B \\<subseteq> C\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> f B - C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> f B - C\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "with \\<open>f_range_on A f\\<close> \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  B \\<subseteq> A\n  a \\<in> f B - C", "have \"card ?B' < card B\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  B \\<subseteq> A\n  a \\<in> f B - C\n\ngoal (1 subgoal):\n 1. card (B - {SOME x. x \\<in> f B - C}) < card B", "unfolding f_range_on_def"], ["proof (prove)\nusing this:\n  \\<forall>B\\<subseteq>A. f B \\<subseteq> B\n  B \\<subseteq> A\n  a \\<in> f B - C\n\ngoal (1 subgoal):\n 1. card (B - {SOME x. x \\<in> f B - C}) < card B", "by (clarsimp simp: card_Diff_singleton_if) (metis (no_types, lifting) One_nat_def card_Diff1_less card_Diff_singleton finite someI_ex subsetCE)"], ["proof (state)\nthis:\n  card (B - {SOME x. x \\<in> f B - C}) < card B\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "from \\<open>C \\<subseteq> B\\<close> \\<open>a \\<in> f B - C\\<close>"], ["proof (chain)\npicking this:\n  C \\<subseteq> B\n  a \\<in> f B - C", "have \"C \\<subseteq> B - {SOME x. x \\<in> f B - C}\""], ["proof (prove)\nusing this:\n  C \\<subseteq> B\n  a \\<in> f B - C\n\ngoal (1 subgoal):\n 1. C \\<subseteq> B - {SOME x. x \\<in> f B - C}", "by (metis Diff_empty Diff_iff someI subset_Diff_insert)"], ["proof (state)\nthis:\n  C \\<subseteq> B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "with 1(1)[rule_format, OF \\<open>card ?B' < card B\\<close> refl] \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>B - {SOME x. x \\<in> f B - C} \\<subseteq> A;\n   C \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r\\<in>local.mk_linear_orders C\n                                    (B - {SOME x. x \\<in> f B - C}).\n                       MaxR.MaxR_opt (linord_of_list r) C = Some x\n  B \\<subseteq> A\n  C \\<subseteq> B - {SOME x. x \\<in> f B - C}", "obtain r where r: \"r \\<in> mk_linear_orders C ?B'\" \"MaxR.MaxR_opt (linord_of_list r) C = Some x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>B - {SOME x. x \\<in> f B - C} \\<subseteq> A;\n   C \\<subseteq> B - {SOME x. x \\<in> f B - C}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r\\<in>local.mk_linear_orders C\n                                    (B - {SOME x. x \\<in> f B - C}).\n                       MaxR.MaxR_opt (linord_of_list r) C = Some x\n  B \\<subseteq> A\n  C \\<subseteq> B - {SOME x. x \\<in> f B - C}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> local.mk_linear_orders C\n                          (B - {SOME x. x \\<in> f B - C});\n         MaxR.MaxR_opt (linord_of_list r) C = Some x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "with \\<open>f B \\<noteq> {}\\<close> False \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  f B \\<noteq> {}\n  \\<not> f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x", "have \"?b # r \\<in> mk_linear_orders C B\""], ["proof (prove)\nusing this:\n  f B \\<noteq> {}\n  \\<not> f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B", "using mk_linear_orders_termination[of B C]"], ["proof (prove)\nusing this:\n  f B \\<noteq> {}\n  \\<not> f B \\<subseteq> C\n  B \\<subseteq> A\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  B \\<subseteq> A \\<Longrightarrow> local.mk_linear_orders_dom (C, B)\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B", "by (simp add: mk_linear_orders.psimps Let_def card_eq_0_iff split: if_splits)"], ["proof (state)\nthis:\n  (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "moreover"], ["proof (state)\nthis:\n  (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "have \"MaxR.MaxR_opt (linord_of_list (?b # r)) C = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MaxR.MaxR_opt (linord_of_list ((SOME x. x \\<in> f B - C) # r)) C =\n    Some x", "proof(rule MaxR.greatest_is_MaxR_opt)"], ["proof (state)\ngoal (3 subgoals):\n 1. MaxR (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n 2. x \\<in> C \\<inter>\n            Field (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n 3. \\<forall>y\\<in>C \\<inter>\n                   Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n       (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)", "from linord_of_list_Linear_order[OF mk_linear_orders_distinct[OF \\<open>?b # r \\<in> mk_linear_orders C B\\<close> \\<open>B \\<subseteq> A\\<close>]]"], ["proof (chain)\npicking this:\n  ?ys = set ((SOME x. x \\<in> f B - C) # r) \\<Longrightarrow>\n  linear_order_on ?ys (linord_of_list ((SOME x. x \\<in> f B - C) # r))", "show \"MaxR (linord_of_list (?b # r))\""], ["proof (prove)\nusing this:\n  ?ys = set ((SOME x. x \\<in> f B - C) # r) \\<Longrightarrow>\n  linear_order_on ?ys (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n\ngoal (1 subgoal):\n 1. MaxR (linord_of_list ((SOME x. x \\<in> f B - C) # r))", "by (simp add: MaxR.intro)"], ["proof (state)\nthis:\n  MaxR (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n\ngoal (2 subgoals):\n 1. x \\<in> C \\<inter>\n            Field (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n 2. \\<forall>y\\<in>C \\<inter>\n                   Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n       (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)", "from \\<open>f_range_on A f\\<close> r \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  B \\<subseteq> A", "show \"x \\<in> C \\<inter> Field (linord_of_list (?b # r))\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. x \\<in> C \\<inter>\n            Field (linord_of_list ((SOME x. x \\<in> f B - C) # r))", "by clarsimp (metis (no_types, lifting) Choice_Functions.mk_linear_orders_Linear_order Diff_subset IntD2 Int_iff MaxR.intro MaxR.range_Some f_range_on_antimono linord_of_list_Field)"], ["proof (state)\nthis:\n  x \\<in> C \\<inter> Field (linord_of_list ((SOME x. x \\<in> f B - C) # r))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>C \\<inter>\n                   Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n       (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)", "from \\<open>f_range_on A f\\<close> r \\<open>a \\<in> f B - C\\<close> \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  f_range_on A f\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  a \\<in> f B - C\n  B \\<subseteq> A", "show \"\\<forall>y\\<in>C \\<inter> Field (linord_of_list (?b # r)). (y, x) \\<in> linord_of_list (?b # r)\""], ["proof (prove)\nusing this:\n  f_range_on A f\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  a \\<in> f B - C\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>C \\<inter>\n                   Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n       (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)", "using someI[where P=\"\\<lambda>x. x \\<in> f B - C\"]"], ["proof (prove)\nusing this:\n  f_range_on A f\n  r \\<in> local.mk_linear_orders C (B - {SOME x. x \\<in> f B - C})\n  MaxR.MaxR_opt (linord_of_list r) C = Some x\n  a \\<in> f B - C\n  B \\<subseteq> A\n  ?x \\<in> f B - C \\<Longrightarrow> (SOME x. x \\<in> f B - C) \\<in> f B - C\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>C \\<inter>\n                   Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n       (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)", "by (auto simp: linord_of_list_linord_of_listP intro: MaxR.intro intro: f_range_on_antimono dest!: MaxR.MaxR_opt_is_greatest[rotated] Choice_Functions.mk_linear_orders_Linear_order[rotated])"], ["proof (state)\nthis:\n  \\<forall>y\\<in>C \\<inter>\n                 Field (linord_of_list ((SOME x. x \\<in> f B - C) # r)).\n     (y, x) \\<in> linord_of_list ((SOME x. x \\<in> f B - C) # r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MaxR.MaxR_opt (linord_of_list ((SOME x. x \\<in> f B - C) # r)) C = Some x\n\ngoal (1 subgoal):\n 1. \\<not> f B \\<subseteq> C \\<Longrightarrow>\n    \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "ultimately"], ["proof (chain)\npicking this:\n  (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B\n  MaxR.MaxR_opt (linord_of_list ((SOME x. x \\<in> f B - C) # r)) C = Some x", "show ?thesis"], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> f B - C) # r \\<in> local.mk_linear_orders C B\n  MaxR.MaxR_opt (linord_of_list ((SOME x. x \\<in> f B - C) # r)) C = Some x\n\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>local.mk_linear_orders C B.\n       MaxR.MaxR_opt (linord_of_list r) C = Some x", "by blast"], ["proof (state)\nthis:\n  \\<exists>r\\<in>local.mk_linear_orders C B.\n     MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r\\<in>local.mk_linear_orders C B.\n     MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r\\<in>local.mk_linear_orders C B.\n     MaxR.MaxR_opt (linord_of_list r) C = Some x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma path_independent_on_pseudo_rationalizable_on:\n  fixes f :: \"'a::finite cfun\"\n  assumes \"path_independent_on A f\"\n  assumes \"f_range_on A f\"\n  assumes Rs_def[simp]: \"Rs = (\\<Union>C\\<in>Pow A. linord_of_list ` mk_linear_orders f C A)\"\n  shows \"pseudo_rationalizable_on A Rs f \\<and> (\\<forall>r\\<in>Rs. refl_on A r \\<and> total_on A r \\<longleftrightarrow> decisive_on A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "proof %invisible -"], ["proof (state)\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "have \"pseudo_rationalizable_on A Rs f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f", "proof(rule pseudo_rationalizable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r. r \\<in> Rs \\<Longrightarrow> Linear_order r\n 2. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "fix r"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r. r \\<in> Rs \\<Longrightarrow> Linear_order r\n 2. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "assume \"r \\<in> Rs\""], ["proof (state)\nthis:\n  r \\<in> Rs\n\ngoal (2 subgoals):\n 1. \\<And>r. r \\<in> Rs \\<Longrightarrow> Linear_order r\n 2. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "then"], ["proof (chain)\npicking this:\n  r \\<in> Rs", "show \"Linear_order r\""], ["proof (prove)\nusing this:\n  r \\<in> Rs\n\ngoal (1 subgoal):\n 1. Linear_order r", "using mk_linear_orders_Linear_order[OF \\<open>f_range_on A f\\<close>]"], ["proof (prove)\nusing this:\n  r \\<in> Rs\n  ?r \\<in> mk_linear_orders f ?C A \\<Longrightarrow>\n  Linear_order (linord_of_list ?r)\n\ngoal (1 subgoal):\n 1. Linear_order r", "by clarsimp"], ["proof (state)\nthis:\n  Linear_order r\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "assume \"B \\<subseteq> A\""], ["proof (state)\nthis:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       B \\<subseteq> A \\<Longrightarrow>\n       f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "show \"f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "proof(rule set_elem_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f B \\<Longrightarrow>\n       x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n 2. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f B \\<Longrightarrow>\n       x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n 2. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "assume \"x \\<in> ?lhs\""], ["proof (state)\nthis:\n  x \\<in> f B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f B \\<Longrightarrow>\n       x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n 2. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "with \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  x \\<in> f B", "show \"x \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> f B\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "using path_independent_on_consistency_on[OF assms(1)]\n              mk_linear_orders_f_MaxR_opt[OF \\<open>f_range_on A f\\<close>]"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> f B\n  consistency_on A f\n  \\<lbrakk>?x \\<in> f ?C; consistency_on A f; ?B \\<subseteq> A;\n   ?C \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r\\<in>mk_linear_orders f ?C ?B.\n                       MaxR.MaxR_opt (linord_of_list r) ?C = Some ?x\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>r\\<in>Rs.\n                   set_option (MaxR.MaxR_opt r B)) \\<Longrightarrow>\n       x \\<in> f B", "with \\<open>B \\<subseteq> A\\<close>"], ["proof (chain)\npicking this:\n  B \\<subseteq> A\n  x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))", "show \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n\ngoal (1 subgoal):\n 1. x \\<in> f B", "using path_independent_on_Chernoff_on[OF assms(1,2)] Chernoff_on_iia_on\n              mk_linear_orders_MaxR_opt_f[OF \\<open>f_range_on A f\\<close>]"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n  x \\<in> (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n  Chernoff_on A f\n  Chernoff_on ?A ?f = iia_on ?A ?f\n  \\<lbrakk>?r \\<in> mk_linear_orders f ?C A;\n   MaxR.MaxR_opt (linord_of_list ?r) ?D = Some ?x; iia_on A f;\n   ?D \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> f ?D\n\ngoal (1 subgoal):\n 1. x \\<in> f B", "by simp blast"], ["proof (state)\nthis:\n  x \\<in> f B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f B = (\\<Union>r\\<in>Rs. set_option (MaxR.MaxR_opt r B))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pseudo_rationalizable_on A Rs f\n\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "moreover"], ["proof (state)\nthis:\n  pseudo_rationalizable_on A Rs f\n\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "from path_independent_on_Chernoff_on[OF assms(1,2)] Chernoff_on_iia_on"], ["proof (chain)\npicking this:\n  Chernoff_on A f\n  Chernoff_on ?A ?f = iia_on ?A ?f", "have \"iia_on A f\""], ["proof (prove)\nusing this:\n  Chernoff_on A f\n  Chernoff_on ?A ?f = iia_on ?A ?f\n\ngoal (1 subgoal):\n 1. iia_on A f", "by blast"], ["proof (state)\nthis:\n  iia_on A f\n\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "then"], ["proof (chain)\npicking this:\n  iia_on A f", "have \"\\<forall>r\\<in>Rs. refl_on A r \\<and> total_on A r \\<longleftrightarrow> decisive_on A f\""], ["proof (prove)\nusing this:\n  iia_on A f\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f", "using mk_linear_orders_total_on_decisive_on[OF assms(2)]\n          mk_linear_orders_decisive_on_refl_on[OF assms(2)]\n          mk_linear_orders_decisive_on_total_on[OF assms(2)]"], ["proof (prove)\nusing this:\n  iia_on A f\n  \\<lbrakk>?r \\<in> mk_linear_orders f ?C A; A \\<subseteq> set ?r;\n   iia_on A f\\<rbrakk>\n  \\<Longrightarrow> decisive_on A f\n  \\<lbrakk>?r \\<in> mk_linear_orders f ?C A; decisive_on A f\\<rbrakk>\n  \\<Longrightarrow> refl_on A (linord_of_list ?r)\n  \\<lbrakk>?r \\<in> mk_linear_orders f ?C A; decisive_on A f\\<rbrakk>\n  \\<Longrightarrow> total_on A (linord_of_list ?r)\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f", "by clarsimp (meson linord_of_list_refl_on refl_onD refl_onD1 subsetI)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f\n\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "ultimately"], ["proof (chain)\npicking this:\n  pseudo_rationalizable_on A Rs f\n  \\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f", "show ?thesis"], ["proof (prove)\nusing this:\n  pseudo_rationalizable_on A Rs f\n  \\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f\n\ngoal (1 subgoal):\n 1. pseudo_rationalizable_on A Rs f \\<and>\n    (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)", "by blast"], ["proof (state)\nthis:\n  pseudo_rationalizable_on A Rs f \\<and>\n  (\\<forall>r\\<in>Rs. (refl_on A r \\<and> total_on A r) = decisive_on A f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nOur top-level theorem is essentially \\citet[Theorem~5]{Moulin:1985}:\n\n\\<close>"], ["", "theorem pseudo_rationalizable:\n  assumes \"f_range_on A f\"\n  shows \"path_independent_on A f\n           \\<longleftrightarrow> (\\<exists>Rs. pseudo_rationalizable_on A Rs f \\<and> (\\<forall>r\\<in>Rs. refl_on A r \\<and> total_on A r \\<longleftrightarrow> decisive_on A f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_independent_on A f =\n    (\\<exists>Rs.\n        pseudo_rationalizable_on A Rs f \\<and>\n        (\\<forall>r\\<in>Rs.\n            (refl_on A r \\<and> total_on A r) = decisive_on A f))", "using %invisible pseudo_rationalizable_on_path_independent_on path_independent_on_pseudo_rationalizable_on[OF _ assms]"], ["proof (prove)\nusing this:\n  pseudo_rationalizable_on ?A ?Rs ?f \\<Longrightarrow>\n  path_independent_on ?A ?f\n  \\<lbrakk>path_independent_on A f;\n   ?Rs =\n   (\\<Union>C\\<in>Pow A. linord_of_list ` mk_linear_orders f C A)\\<rbrakk>\n  \\<Longrightarrow> pseudo_rationalizable_on A ?Rs f \\<and>\n                    (\\<forall>r\\<in>?Rs.\n                        (refl_on A r \\<and> total_on A r) = decisive_on A f)\n\ngoal (1 subgoal):\n 1. path_independent_on A f =\n    (\\<exists>Rs.\n        pseudo_rationalizable_on A Rs f \\<and>\n        (\\<forall>r\\<in>Rs.\n            (refl_on A r \\<and> total_on A r) = decisive_on A f))", "by fastforce"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}