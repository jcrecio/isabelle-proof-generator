{"file_name": "/home/qj213/afp-2021-10-22/thys/Stable_Matching/Strategic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stable_Matching", "problem_names": ["lemma PdXXX_linear:\n  shows \"Linear_order (Pd' d)\"", "lemma PdXXX_range:\n  shows \"Field (Pd' d) \\<subseteq> {x. Xd x = d}\"", "lemmas PdXXX_range' = subsetD[OF PdXXX_range, simplified, of x] for x", "theorem Pd_above_irrelevant:\n  assumes d'_Field: \"dX X d' \\<subseteq> Field (Pd' d')\"\n  assumes d'_Above: \"Above (Pd' d') (dX X d') \\<subseteq> Above (Pd d') (dX X d')\"\n  assumes \"x \\<in> X\"\n  assumes \"stable_on ds X\"\n  shows \"\\<exists>y \\<in> PdXXX.cop ds. (x, y) \\<in> Pd' (Xd x)\"", "lemma Pd_singletons_for_ds_range:\n  shows \"Field (Pd_singletons_for_ds X ds d) \\<subseteq> {x. Xd x = d}\"", "lemma Pd_singletons_for_ds_linear:\n  assumes \"allocation X\"\n  shows \"Linear_order (Pd_singletons_for_ds X ds d)\"", "lemma Pd_singletons_for_ds_simps:\n  shows \"d \\<in> ds \\<Longrightarrow> Pd_singletons_for_ds X ds d = dX X d \\<times> dX X d\"\n    and \"d \\<notin> ds \\<Longrightarrow> Pd_singletons_for_ds X ds d = Pd d\"", "theorem Theorem_10_fp_cop_F:\n  assumes \"x \\<in> X\"\n  shows \"\\<exists>y \\<in> Singleton_for_d.cop d ds. (x, y) \\<in> Pd_singletons_for_ds X {d} (Xd x)\"", "theorem Theorem_10:\n  assumes \"x \\<in> match (gfp_F ds)\"\n  shows \"\\<exists>y \\<in> match (Singleton_for_d.gfp_F ds d ds). (x, y) \\<in> Pd_singletons_for_ds (match (gfp_F ds)) {d} (Xd x)\"", "lemma Pd'_linear:\n  shows \"Linear_order (Pd' d)\"", "lemma Pd'_range:\n  shows \"Field (Pd' d) \\<subseteq> {x. Xd x = d}\"", "lemma Pd'_tax_linear:\n  shows \"Linear_order (Pd'_tax d)\"", "lemma Pd'_tax_Pd':\n  shows \"Pd'_tax d \\<subseteq> Pd' d\"", "lemma Pd'_tax_range:\n  shows \"Field (Pd'_tax d) \\<subseteq> {x. Xd x = d}\"", "lemma Pd'_tax_x:\n  shows \"x \\<in> Field (Pd'_tax (Xd x))\"", "lemma Pd'_Above:\n  assumes \"Y \\<subseteq> above (Pd' (Xd x)) x\"\n  assumes \"Y \\<noteq> {}\"\n  shows \"Above (Pd' d) Y \\<subseteq> Above (Pd'_tax d) Y\"", "lemma Xd_x_ds:\n  shows \"Xd x \\<in> ds\"", "lemma TruePref_tax_Cd_not_x:\n  assumes \"d \\<noteq> Xd x\"\n  shows \"TruePref_tax.Cd d = Singleton_for_d.Cd d\"", "lemma Theorem_11_Pd'_tax:\n  shows \"\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x)\"", "theorem Theorem_11_fp_cop_F:\n  shows \"\\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)\"", "theorem Theorem_11:\n  shows \"\\<exists>y\\<in>match (TruePref.gfp_F ds). (x, y) \\<in> Pd' (Xd x)\"", "lemma strategy_proofI:\n  assumes \"\\<And>Pd Pd' Ch d y. \\<lbrakk> mechanism_domain Pd Ch; mechanism_domain (Pd(d:=Pd')) Ch; d \\<in> ds;\n                             y \\<in> \\<phi> (Pd(d := Pd')) Ch ds; y \\<in> Field (Pd d);\n                             \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d. x \\<noteq> y \\<and> (x, y) \\<in> Pd d \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"strategy_proof ds \\<phi>\"", "theorem fp_cop_F_strategy_proof:\n  shows \"strategy_proof ds Contracts.cop\" (is \"strategy_proof _ ?\\<phi>\")", "lemma group_strategy_proofI:\n  assumes \"\\<And>Pd Pd' Ch ds'. \\<lbrakk> mechanism_domain Pd Ch; mechanism_domain (override_on Pd Pd' ds') Ch; ds' \\<subseteq> ds; ds' \\<noteq> {};\n                             \\<forall>d\\<in>ds'. \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch ds. y \\<in> AboveS (Pd d) (dX (\\<phi> Pd Ch ds) d) \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"group_strategy_proof ds \\<phi>\"", "lemmas group_strategy_proofD = iffD1[OF group_strategy_proof_def, simplified, unfolded disj_imp, simplified, rule_format]", "lemma group_strategy_proof_strategy_proof:\n  assumes \"group_strategy_proof ds \\<phi>\"\n  shows \"strategy_proof ds \\<phi>\"", "lemma shuffle_to_top_Field:\n  assumes \"allocation Y\"\n  shows \"Field (shuffle_to_top Y d) = Field (Pd d) \\<union> dX Y d\"", "lemma shuffle_to_top_Total:\n  assumes \"allocation Y\"\n  shows \"Total (shuffle_to_top Y d)\"", "lemma shuffle_to_top_linear:\n  assumes \"allocation Y\"\n  shows \"Linear_order (shuffle_to_top Y d)\"", "lemma shuffle_to_top_range:\n  shows \"Field (shuffle_to_top Y d) \\<subseteq> {x. Xd x = d}\"", "lemma shuffle_to_top_range':\n  assumes \"(x, y) \\<in> shuffle_to_top Y d\"\n  shows \"x \\<in> Field (Pd d) \\<union> dX Y d \\<and> y \\<in> Field (Pd d) \\<union> dX Y d\"", "lemma Pd_shuffle_to_top_linear:\n  assumes \"allocation Y\"\n  shows \"Linear_order (Pd_shuffle_to_top ds' Y d)\"", "lemma Pd_shuffle_to_top_range:\n  shows \"Field (Pd_shuffle_to_top ds' Y d) \\<subseteq> {x. Xd x = d}\"", "lemma Pd_shuffle_to_top_simps:\n  shows \"Pd_shuffle_to_top (insert d ds') Y = (Pd_shuffle_to_top ds' Y)(d := shuffle_to_top Y d)\"\n    and \"d \\<in> ds' \\<Longrightarrow> Pd_shuffle_to_top ds' Y d = shuffle_to_top Y d\"\n    and \"d \\<notin> ds' \\<Longrightarrow> Pd_shuffle_to_top ds' Y d = Pd d\"", "lemma Pd_shuffle_to_top_Field:\n  assumes \"allocation Y\"\n  shows \"Field (Pd_shuffle_to_top ds' Y d) = Field (Pd d) \\<union> (if d \\<in> ds' then dX Y d else {})\"", "lemma Above_shuffle_to_top:\n  assumes \"x \\<in> Above (shuffle_to_top Y (Xd x)) X\"\n  assumes \"y \\<in> Y\"\n  assumes \"allocation Y\"\n  assumes \"y \\<in> X\"\n  shows \"x = y\"", "lemma Lemma_1:\n  assumes \"allocation Y\"\n  assumes III: \"\\<forall>d\\<in>ds''. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)\"\n  shows \"cop ds = Contracts.cop (Pd_shuffle_to_top ds'' Y) Ch ds\"", "theorem fp_cop_F_group_strategy_proof:\n  shows \"group_strategy_proof ds Contracts.cop\"\n        (is \"group_strategy_proof _ ?\\<phi>\")", "theorem Corollary_2:\n  assumes \"ds \\<noteq> {}\"\n  shows \"\\<not>(\\<exists>Y. individually_rational_on ds Y\n        \\<and> (\\<forall>d\\<in>ds. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)))\""], "translations": [["", "lemma PdXXX_linear:\n  shows \"Linear_order (Pd' d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (Pd' d)", "using Pd_linear Pd'_d'_linear Pd'"], ["proof (prove)\nusing this:\n  \\<forall>d. Linear_order (Pd d)\n  Linear_order (Pd' d')\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n\ngoal (1 subgoal):\n 1. Linear_order (Pd' d)", "by (cases \"d = d'\") simp_all"], ["", "lemma PdXXX_range:\n  shows \"Field (Pd' d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd' d) \\<subseteq> {x. Xd x = d}", "using Pd_range Pd'_d'_range Pd'"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (Pd' d') \\<subseteq> {y. Xd y = d'}\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n\ngoal (1 subgoal):\n 1. Field (Pd' d) \\<subseteq> {x. Xd x = d}", "by (cases \"d = d'\") simp_all"], ["", "lemmas PdXXX_range' = subsetD[OF PdXXX_range, simplified, of x] for x"], ["", "(*>*)"], ["", "interpretation PdXXX: ContractsWithUnilateralSubstitutesAndIRC Xd Xh Pd' Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRC Xd Xh Pd' Ch", "using %invisible PdXXX_linear PdXXX_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRC Xd Xh Pd' Ch", "by unfold_locales blast+"], ["", "theorem Pd_above_irrelevant:\n  assumes d'_Field: \"dX X d' \\<subseteq> Field (Pd' d')\"\n  assumes d'_Above: \"Above (Pd' d') (dX X d') \\<subseteq> Above (Pd d') (dX X d')\"\n  assumes \"x \\<in> X\"\n  assumes \"stable_on ds X\"\n  shows \"\\<exists>y \\<in> PdXXX.cop ds. (x, y) \\<in> Pd' (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>PdXXX.cop ds. (x, y) \\<in> Pd' (Xd x)", "proof(rule PdXXX.Theorem_5[OF ccontr \\<open>x \\<in> X\\<close>])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_on ds X \\<Longrightarrow> False", "assume \"\\<not>PdXXX.stable_on ds X\""], ["proof (state)\nthis:\n  \\<not> PdXXX.stable_on ds X\n\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_on ds X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> PdXXX.stable_on ds X", "show False"], ["proof (prove)\nusing this:\n  \\<not> PdXXX.stable_on ds X\n\ngoal (1 subgoal):\n 1. False", "proof(cases rule: PdXXX.not_stable_on_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> PdXXX.individually_rational_on ds X \\<Longrightarrow> False\n 2. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "case not_individually_rational"], ["proof (state)\nthis:\n  \\<not> PdXXX.individually_rational_on ds X\n\ngoal (2 subgoals):\n 1. \\<not> PdXXX.individually_rational_on ds X \\<Longrightarrow> False\n 2. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "from Pd' \\<open>stable_on ds X\\<close> d'_Field"], ["proof (chain)\npicking this:\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n  stable_on ds X\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')", "have \"x \\<in> PdXXX.Cd (Xd x) X\" if \"x \\<in> X\" for x"], ["proof (prove)\nusing this:\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n  stable_on ds X\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n\ngoal (1 subgoal):\n 1. x \\<in> PdXXX.Cd (Xd x) X", "using that"], ["proof (prove)\nusing this:\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n  stable_on ds X\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> PdXXX.Cd (Xd x) X", "unfolding dX_def"], ["proof (prove)\nusing this:\n  \\<forall>d. d \\<noteq> d' \\<longrightarrow> Pd' d = Pd d\n  stable_on ds X\n  {x \\<in> X. Xd x = d'} \\<subseteq> Field (Pd' d')\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> PdXXX.Cd (Xd x) X", "by (force simp: stable_on_range' stable_on_allocation PdXXX.Cd_single)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> ?x \\<in> PdXXX.Cd (Xd ?x) X\n\ngoal (2 subgoals):\n 1. \\<not> PdXXX.individually_rational_on ds X \\<Longrightarrow> False\n 2. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "with \\<open>stable_on ds X\\<close> not_individually_rational"], ["proof (chain)\npicking this:\n  stable_on ds X\n  \\<not> PdXXX.individually_rational_on ds X\n  ?x \\<in> X \\<Longrightarrow> ?x \\<in> PdXXX.Cd (Xd ?x) X", "show False"], ["proof (prove)\nusing this:\n  stable_on ds X\n  \\<not> PdXXX.individually_rational_on ds X\n  ?x \\<in> X \\<Longrightarrow> ?x \\<in> PdXXX.Cd (Xd ?x) X\n\ngoal (1 subgoal):\n 1. False", "unfolding PdXXX.individually_rational_on_def"], ["proof (prove)\nusing this:\n  stable_on ds X\n  \\<not> (PdXXX.CD_on ds X = X \\<and> PdXXX.CH X = X)\n  ?x \\<in> X \\<Longrightarrow> ?x \\<in> PdXXX.Cd (Xd ?x) X\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: PdXXX.mem_CD_on_Cd stable_on_Xd dest: stable_on_CH PdXXX.CD_on_range')"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "case not_no_blocking"], ["proof (state)\nthis:\n  \\<not> PdXXX.stable_no_blocking_on ds X\n\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> PdXXX.stable_no_blocking_on ds X", "obtain h X'' where \"PdXXX.blocking_on ds X h X''\""], ["proof (prove)\nusing this:\n  \\<not> PdXXX.stable_no_blocking_on ds X\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        PdXXX.blocking_on ds X h X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding PdXXX.stable_no_blocking_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>h X'. \\<not> PdXXX.blocking_on ds X h X')\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        PdXXX.blocking_on ds X h X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  PdXXX.blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "have \"blocking_on ds X h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blocking_on ds X h X''", "proof(rule blocking_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h X\n 2. X'' = Ch h (X \\<union> X'')\n 3. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h X\n 2. X'' = Ch h (X \\<union> X'')\n 3. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "assume \"x \\<in> X''\""], ["proof (state)\nthis:\n  x \\<in> X''\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h X\n 2. X'' = Ch h (X \\<union> X'')\n 3. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "note Pbos = PdXXX.blocking_on_Field[OF \\<open>PdXXX.blocking_on ds X h X''\\<close>]\n                  PdXXX.blocking_on_allocation[OF \\<open>PdXXX.blocking_on ds X h X''\\<close>]\n                  PdXXX.blocking_on_CD_on'[OF \\<open>PdXXX.blocking_on ds X h X''\\<close> \\<open>x \\<in> X''\\<close>]"], ["proof (state)\nthis:\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h X\n 2. X'' = Ch h (X \\<union> X'')\n 3. \\<And>x. x \\<in> X'' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "show \"x \\<in> CD_on ds (X \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "proof(cases \"Xd x = d'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "case True"], ["proof (state)\nthis:\n  Xd x = d'\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "from Pd_linear' d'_Field d'_Above \\<open>x \\<in> X''\\<close> \\<open>Xd x = d'\\<close> Pbos"], ["proof (chain)\npicking this:\n  Linear_order (Pd ?d)\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  Above (Pd' d') (PdXXX.dX X d') \\<subseteq> Above (Pd d') (PdXXX.dX X d')\n  x \\<in> X''\n  Xd x = d'\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')", "have \"dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  Linear_order (Pd ?d)\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  Above (Pd' d') (PdXXX.dX X d') \\<subseteq> Above (Pd d') (PdXXX.dX X d')\n  x \\<in> X''\n  Xd x = d'\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. PdXXX.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))", "by (force simp: PdXXX.mem_CD_on_Cd PdXXX.Cd_Above PdXXX.dX_Int_Field_Pd Above_union\n                          Int_Un_distrib2 dX_singular intro: Above_Field)"], ["proof (state)\nthis:\n  PdXXX.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  PdXXX.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "from \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  stable_on ds X", "have \"dX X (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. PdXXX.dX X (Xd x) \\<subseteq> Field (Pd (Xd x))", "by (force dest: dX_range' stable_on_range')"], ["proof (state)\nthis:\n  PdXXX.dX X (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  PdXXX.dX X (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "note Pd_linear' Pd_range PdXXX_range d'_Field d'_Above \\<open>x \\<in> X''\\<close> \\<open>Xd x = d'\\<close> Pbos"], ["proof (state)\nthis:\n  Linear_order (Pd ?d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  Above (Pd' d') (PdXXX.dX X d') \\<subseteq> Above (Pd d') (PdXXX.dX X d')\n  x \\<in> X''\n  Xd x = d'\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n\ngoal (2 subgoals):\n 1. Xd x = d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')\n 2. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "ultimately"], ["proof (chain)\npicking this:\n  PdXXX.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  PdXXX.dX X (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Linear_order (Pd ?d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  Above (Pd' d') (PdXXX.dX X d') \\<subseteq> Above (Pd d') (PdXXX.dX X d')\n  x \\<in> X''\n  Xd x = d'\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')", "show ?thesis"], ["proof (prove)\nusing this:\n  PdXXX.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  PdXXX.dX X (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Linear_order (Pd ?d)\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  PdXXX.dX X d' \\<subseteq> Field (Pd' d')\n  Above (Pd' d') (PdXXX.dX X d') \\<subseteq> Above (Pd d') (PdXXX.dX X d')\n  x \\<in> X''\n  Xd x = d'\n  PdXXX.dX X'' ?d \\<subseteq> Field (Pd' ?d)\n  inj_on Xd X''\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "by (clarsimp simp: PdXXX.mem_CD_on_Cd PdXXX.Cd_Above_dX mem_CD_on_Cd Cd_Above_dX\n                             Above_union dX_union Int_Un_distrib2)\n             (fastforce simp: dX_singular intro: Above_Linear_singleton)"], ["proof (state)\nthis:\n  x \\<in> CD_on ds (X \\<union> X'')\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "case False"], ["proof (state)\nthis:\n  Xd x \\<noteq> d'\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d' \\<Longrightarrow> x \\<in> CD_on ds (X \\<union> X'')", "with \\<open>x \\<in> PdXXX.CD_on ds (X \\<union> X'')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n  Xd x \\<noteq> d'", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> PdXXX.CD_on ds (X \\<union> X'')\n  Xd x \\<noteq> d'\n\ngoal (1 subgoal):\n 1. x \\<in> CD_on ds (X \\<union> X'')", "by (clarsimp simp: Pd' PdXXX.mem_CD_on_Cd mem_CD_on_Cd PdXXX.Cd_greatest Cd_greatest)"], ["proof (state)\nthis:\n  x \\<in> CD_on ds (X \\<union> X'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> CD_on ds (X \\<union> X'')\n\ngoal (2 subgoals):\n 1. X'' \\<noteq> Ch h X\n 2. X'' = Ch h (X \\<union> X'')", "qed (use \\<open>PdXXX.blocking_on ds X h X''\\<close> in \\<open>simp_all add: PdXXX.blocking_on_def\\<close>)"], ["proof (state)\nthis:\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. \\<not> PdXXX.stable_no_blocking_on ds X \\<Longrightarrow> False", "with \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  stable_on ds X\n  blocking_on ds X h X''", "show False"], ["proof (prove)\nusing this:\n  stable_on ds X\n  blocking_on ds X h X''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: blocking_on_imp_not_stable)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "text\\<open>\n\nWe now specialize this lemma to Theorem~10 by defining a preference\norder for the doctors where distinguished doctors @{term \"ds\"} submit\nsingle preferences for the contracts they receive in the\ndoctor-optimal match.\n\nThe function @{thm \"override_on_def\"} denotes function update at\nseveral points.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition Pd_singletons_for_ds :: \"'x set \\<Rightarrow> 'd set \\<Rightarrow> 'd \\<Rightarrow> 'x rel\" where\n  \"Pd_singletons_for_ds X ds \\<equiv> override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds\""], ["", "(*<*)"], ["", "lemma Pd_singletons_for_ds_range:\n  shows \"Field (Pd_singletons_for_ds X ds d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd_singletons_for_ds X ds d) \\<subseteq> {x. Xd x = d}", "using Pd_range dX_range"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<forall>d. dX ?X d \\<subseteq> {x. Xd x = d}\n\ngoal (1 subgoal):\n 1. Field (Pd_singletons_for_ds X ds d) \\<subseteq> {x. Xd x = d}", "unfolding Pd_singletons_for_ds_def"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<forall>d. dX ?X d \\<subseteq> {x. Xd x = d}\n\ngoal (1 subgoal):\n 1. Field (override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds d)\n    \\<subseteq> {x. Xd x = d}", "by (clarsimp simp: Field_def override_on_def) blast"], ["", "lemma Pd_singletons_for_ds_linear:\n  assumes \"allocation X\"\n  shows \"Linear_order (Pd_singletons_for_ds X ds d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (Pd_singletons_for_ds X ds d)", "unfolding Pd_singletons_for_ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds d)", "using Pd_linear dX_linear[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>d. Linear_order (Pd d)\n  Linear_order (dX X ?d \\<times> dX X ?d)\n\ngoal (1 subgoal):\n 1. Linear_order (override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds d)", "by (simp add: override_on_def)"], ["", "lemma Pd_singletons_for_ds_simps:\n  shows \"d \\<in> ds \\<Longrightarrow> Pd_singletons_for_ds X ds d = dX X d \\<times> dX X d\"\n    and \"d \\<notin> ds \\<Longrightarrow> Pd_singletons_for_ds X ds d = Pd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d \\<in> ds \\<Longrightarrow>\n     Pd_singletons_for_ds X ds d = dX X d \\<times> dX X d) &&&\n    (d \\<notin> ds \\<Longrightarrow> Pd_singletons_for_ds X ds d = Pd d)", "unfolding Pd_singletons_for_ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (d \\<in> ds \\<Longrightarrow>\n     override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds d =\n     dX X d \\<times> dX X d) &&&\n    (d \\<notin> ds \\<Longrightarrow>\n     override_on Pd (\\<lambda>d. dX X d \\<times> dX X d) ds d = Pd d)", "by simp_all"], ["", "(*>*)"], ["", "end"], ["", "text\\<open>\n\nWe interpret our @{const \"ContractsWithUnilateralSubstitutesAndIRC\"}\nlocale with respect to this updated preference order, which gives us\nthe stable match and properties of it.\n\n\\<close>"], ["", "context ContractsWithUnilateralSubstitutesAndIRC\nbegin"], ["", "context\n  fixes ds :: \"'b set\"\n  fixes X :: \"'a set\"\n  assumes \"stable_on ds X\"\nbegin"], ["", "interpretation\n  Singleton_for_d: ContractsWithUnilateralSubstitutesAndIRC Xd Xh \"Pd_singletons_for_ds X {d}\" Ch for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRC Xd Xh\n     (Pd_singletons_for_ds X {d}) Ch", "using %invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc\n                 stable_on_allocation[OF \\<open>stable_on ds X\\<close>]"], ["proof (prove)\nusing this:\n  inj_on Xd ?X \\<Longrightarrow>\n  Linear_order (Pd_singletons_for_ds ?X ?ds ?d)\n  Field (Pd_singletons_for_ds ?X ?ds ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRC Xd Xh\n     (Pd_singletons_for_ds X {d}) Ch", "by unfold_locales blast+"], ["", "text\\<open>\n\nOur version of \\citet[Theorem~10]{HatfieldMilgrom:2005} (for the COP)\nstates that if a doctor submits a preference order containing just\n@{term \"x\"}, where @{term \"x\"} is their contract in some stable match\n@{term \"X\"}, then that doctor receives exactly @{term \"x\"} in the\ndoctor-optimal match and all other doctors do at least as well.\n\n\\<close>"], ["", "theorem Theorem_10_fp_cop_F:\n  assumes \"x \\<in> X\"\n  shows \"\\<exists>y \\<in> Singleton_for_d.cop d ds. (x, y) \\<in> Pd_singletons_for_ds X {d} (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Singleton_for_d.cop d ds.\n       (x, y) \\<in> Pd_singletons_for_ds X {d} (Xd x)", "proof(rule Pd_above_irrelevant[where ds=ds and d'=d and X=X])"], ["proof (state)\ngoal (7 subgoals):\n 1. Linear_order (Pd_singletons_for_ds X {d} d)\n 2. Field (Pd_singletons_for_ds X {d} d) \\<subseteq> {y. Xd y = d}\n 3. \\<forall>da.\n       da \\<noteq> d \\<longrightarrow> Pd_singletons_for_ds X {d} da = Pd da\n 4. Singleton_for_d.dX X d \\<subseteq> Field (Pd_singletons_for_ds X {d} d)\n 5. Above (Pd_singletons_for_ds X {d} d) (Singleton_for_d.dX X d)\n    \\<subseteq> Above (Pd d) (Singleton_for_d.dX X d)\n 6. x \\<in> X\n 7. stable_on ds X", "from stable_on_allocation \\<open>stable_on ds X\\<close>"], ["proof (chain)\npicking this:\n  stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  stable_on ds X", "show \"Above (Pd_singletons_for_ds X {d} d) (Singleton_for_d.dX X d) \\<subseteq> Above (Pd d) (Singleton_for_d.dX X d)\""], ["proof (prove)\nusing this:\n  stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. Above (Pd_singletons_for_ds X {d} d) (Singleton_for_d.dX X d)\n    \\<subseteq> Above (Pd d) (Singleton_for_d.dX X d)", "by (clarsimp simp: Above_def Pd_singletons_for_ds_simps dX_def) (metis inj_on_eq_iff stable_on_range' Pd_refl)"], ["proof (state)\nthis:\n  Above (Pd_singletons_for_ds X {d} d) (Singleton_for_d.dX X d)\n  \\<subseteq> Above (Pd d) (Singleton_for_d.dX X d)\n\ngoal (6 subgoals):\n 1. Linear_order (Pd_singletons_for_ds X {d} d)\n 2. Field (Pd_singletons_for_ds X {d} d) \\<subseteq> {y. Xd y = d}\n 3. \\<forall>da.\n       da \\<noteq> d \\<longrightarrow> Pd_singletons_for_ds X {d} da = Pd da\n 4. Singleton_for_d.dX X d \\<subseteq> Field (Pd_singletons_for_ds X {d} d)\n 5. x \\<in> X\n 6. stable_on ds X", "qed (use stable_on_allocation \\<open>stable_on ds X\\<close> Pd_singletons_for_ds_linear Pd_singletons_for_ds_range assms\n     in \\<open>simp_all, simp_all add: Pd_singletons_for_ds_simps dX_def\\<close>)"], ["", "end"], ["", "end"], ["", "text (in ContractsWithSubstitutesAndIRC) \\<open>\n\nWe can recover the original Theorem~10 by specializing this result to\n@{const \"gfp_F\"}.\n\n\\<close>"], ["", "context ContractsWithSubstitutesAndIRC\nbegin"], ["", "interpretation\n  Singleton_for_d: ContractsWithSubstitutesAndIRC Xd Xh \"Pd_singletons_for_ds (match (gfp_F ds)) {d}\" Ch\nfor ds d"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC Xd Xh\n     (Pd_singletons_for_ds (match (gfp_F ds)) {d}) Ch", "using %invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_substitutes Ch_irc gfp_F_stable_on\n                 stable_on_allocation[OF gfp_F_stable_on[of ds]]"], ["proof (prove)\nusing this:\n  inj_on Xd ?X \\<Longrightarrow>\n  Linear_order (Pd_singletons_for_ds ?X ?ds ?d)\n  Field (Pd_singletons_for_ds ?X ?ds ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. substitutes (Ch h)\n  \\<forall>h. irc (Ch h)\n  stable_on ?ds (match (gfp_F ?ds))\n  inj_on Xd (match (gfp_F ds))\n\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndIRC Xd Xh\n     (Pd_singletons_for_ds (match (gfp_F ds)) {d}) Ch", "by unfold_locales blast+"], ["", "theorem Theorem_10:\n  assumes \"x \\<in> match (gfp_F ds)\"\n  shows \"\\<exists>y \\<in> match (Singleton_for_d.gfp_F ds d ds). (x, y) \\<in> Pd_singletons_for_ds (match (gfp_F ds)) {d} (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Singleton_for_d.match (Singleton_for_d.gfp_F ds d ds).\n       (x, y)\n       \\<in> Pd_singletons_for_ds (Singleton_for_d.match (gfp_F ds)) {d}\n              (Xd x)", "using Theorem_10_fp_cop_F Singleton_for_d.Theorem_15_match Theorem_15_match gfp_F_stable_on assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_on ?ds ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>Singleton_for_d.CH\n                                    (Contracts.fp_cop_F\n(Pd_singletons_for_ds ?X {?d}) Ch ?ds).\n                       (?x, y) \\<in> Pd_singletons_for_ds ?X {?d} (Xd ?x)\n  Singleton_for_d.match (Singleton_for_d.gfp_F ?dsa ?d ?ds) =\n  Singleton_for_d.cop ?dsa ?d ?ds\n  Singleton_for_d.match (gfp_F ?ds) = cop ?ds\n  stable_on ?ds (Singleton_for_d.match (gfp_F ?ds))\n  x \\<in> Singleton_for_d.match (gfp_F ds)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Singleton_for_d.match (Singleton_for_d.gfp_F ds d ds).\n       (x, y)\n       \\<in> Pd_singletons_for_ds (Singleton_for_d.match (gfp_F ds)) {d}\n              (Xd x)", "by simp"], ["", "corollary Theorem_10_d:\n  assumes \"x \\<in> match (gfp_F ds)\"\n  shows \"x \\<in> match (Singleton_for_d.gfp_F ds (Xd x) ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Singleton_for_d.match (Singleton_for_d.gfp_F ds (Xd x) ds)", "using gfp_F_stable_on[of ds] Theorem_10[OF assms(1), of \"Xd x\"] assms"], ["proof (prove)\nusing this:\n  stable_on ds (Singleton_for_d.match (gfp_F ds))\n  \\<exists>y\\<in>Singleton_for_d.match (Singleton_for_d.gfp_F ds (Xd x) ds).\n     (x, y)\n     \\<in> Pd_singletons_for_ds (Singleton_for_d.match (gfp_F ds)) {Xd x}\n            (Xd x)\n  x \\<in> Singleton_for_d.match (gfp_F ds)\n\ngoal (1 subgoal):\n 1. x \\<in> Singleton_for_d.match (Singleton_for_d.gfp_F ds (Xd x) ds)", "by (clarsimp simp: Pd_singletons_for_ds_simps dX_def inj_on_eq_iff dest!: stable_on_allocation)"], ["", "end"], ["", "text (in ContractsWithSubstitutes) \\<open>\n\nThe second theorem \\citep[Theorem~11]{HatfieldMilgrom:2005} depends on\nboth Theorem~10 and the rural hospitals theorem\n(\\S\\ref{sec:contracts-rh}, \\S\\ref{sec:cop-rh}). It shows that,\nassuming everything else is fixed, if doctor @{term \"d'\"} obtains\ncontract @{term \"x\"} with (manipulated) preferences @{term \"Pd d'\"} in\nthe doctor-optimal match, then they will obtain a contract at least as\ngood by submitting their true preferences @{term \"Pd' d'\"} (with\nrespect to these true preferences).\n\n\\<close>"], ["", "locale TruePrefs = Contracts +\n  fixes x :: \"'a\"\n  fixes X :: \"'a set\"\n  fixes ds :: \"'b set\"\n  fixes Pd' :: \"'b \\<Rightarrow> 'a rel\"\n  assumes x: \"x \\<in> X\"\n  assumes X: \"stable_on ds X\"\n  assumes Pd'_d'_x: \"x \\<in> Field (Pd' (Xd x))\"\n  assumes Pd'_d'_linear: \"Linear_order (Pd' (Xd x))\"\n  assumes Pd'_d'_range: \"Field (Pd' (Xd x)) \\<subseteq> {y. Xd y = Xd x}\"\n  assumes Pd': \"\\<forall>d. d\\<noteq>Xd x \\<longrightarrow> Pd' d = Pd d\"\n\n(*<*)\n\nbegin"], ["", "lemma Pd'_linear:\n  shows \"Linear_order (Pd' d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (Pd' d)", "using Pd_linear Pd'_d'_linear Pd'"], ["proof (prove)\nusing this:\n  \\<forall>d. Linear_order (Pd d)\n  Linear_order (Pd' (Xd x))\n  \\<forall>d. d \\<noteq> Xd x \\<longrightarrow> Pd' d = Pd d\n\ngoal (1 subgoal):\n 1. Linear_order (Pd' d)", "by (cases \"d = Xd x\") simp_all"], ["", "lemma Pd'_range:\n  shows \"Field (Pd' d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd' d) \\<subseteq> {x. Xd x = d}", "using Pd_range Pd'_d'_range Pd'"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (Pd' (Xd x)) \\<subseteq> {y. Xd y = Xd x}\n  \\<forall>d. d \\<noteq> Xd x \\<longrightarrow> Pd' d = Pd d\n\ngoal (1 subgoal):\n 1. Field (Pd' d) \\<subseteq> {x. Xd x = d}", "by (cases \"d = Xd x\") simp_all"], ["", "definition Pd'_tax :: \"'b \\<Rightarrow> 'a rel\" where\n  \"Pd'_tax = (Pd'(Xd x := Restr (Pd' (Xd x)) (above (Pd' (Xd x)) x)))\""], ["", "lemma Pd'_tax_linear:\n  shows \"Linear_order (Pd'_tax d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (Pd'_tax d)", "using Pd'_linear Pd'_d'_linear Linear_order_Restr"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  Linear_order (Pd' (Xd x))\n  Linear_order ?r \\<Longrightarrow> Linear_order (Restr ?r ?A)\n\ngoal (1 subgoal):\n 1. Linear_order (Pd'_tax d)", "unfolding Pd'_tax_def"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  Linear_order (Pd' (Xd x))\n  Linear_order ?r \\<Longrightarrow> Linear_order (Restr ?r ?A)\n\ngoal (1 subgoal):\n 1. Linear_order\n     ((Pd'(Xd x := Restr (Pd' (Xd x)) (above (Pd' (Xd x)) x))) d)", "by auto"], ["", "lemma Pd'_tax_Pd':\n  shows \"Pd'_tax d \\<subseteq> Pd' d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pd'_tax d \\<subseteq> Pd' d", "unfolding Pd'_tax_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Pd'(Xd x := Restr (Pd' (Xd x)) (above (Pd' (Xd x)) x))) d\n    \\<subseteq> Pd' d", "by simp"], ["", "lemma Pd'_tax_range:\n  shows \"Field (Pd'_tax d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd'_tax d) \\<subseteq> {x. Xd x = d}", "using Pd'_range Pd'_tax_Pd'"], ["proof (prove)\nusing this:\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  Pd'_tax ?d \\<subseteq> Pd' ?d\n\ngoal (1 subgoal):\n 1. Field (Pd'_tax d) \\<subseteq> {x. Xd x = d}", "by (meson mono_Field subset_trans)"], ["", "lemma Pd'_tax_x:\n  shows \"x \\<in> Field (Pd'_tax (Xd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd'_tax (Xd x))", "using Pd'_d'_x Pd'_d'_linear"], ["proof (prove)\nusing this:\n  x \\<in> Field (Pd' (Xd x))\n  Linear_order (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd'_tax (Xd x))", "unfolding Pd'_tax_def above_def order_on_defs"], ["proof (prove)\nusing this:\n  x \\<in> Field (Pd' (Xd x))\n  ((Refl (Pd' (Xd x)) \\<and> trans (Pd' (Xd x))) \\<and>\n   antisym (Pd' (Xd x))) \\<and>\n  Total (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. x \\<in> Field\n             ((Pd'(Xd x := Restr (Pd' (Xd x)) {b. (x, b) \\<in> Pd' (Xd x)}))\n               (Xd x))", "by (fastforce intro: FieldI2 dest: refl_onD)"], ["", "lemma Pd'_Above:\n  assumes \"Y \\<subseteq> above (Pd' (Xd x)) x\"\n  assumes \"Y \\<noteq> {}\"\n  shows \"Above (Pd' d) Y \\<subseteq> Above (Pd'_tax d) Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Above (Pd' d) Y \\<subseteq> Above (Pd'_tax d) Y", "using Pd'_d'_linear assms"], ["proof (prove)\nusing this:\n  Linear_order (Pd' (Xd x))\n  Y \\<subseteq> above (Pd' (Xd x)) x\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Above (Pd' d) Y \\<subseteq> Above (Pd'_tax d) Y", "unfolding Above_def Pd'_tax_def above_def order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl (Pd' (Xd x)) \\<and> trans (Pd' (Xd x))) \\<and>\n   antisym (Pd' (Xd x))) \\<and>\n  Total (Pd' (Xd x))\n  Y \\<subseteq> {b. (x, b) \\<in> Pd' (Xd x)}\n  Y \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {b \\<in> Field (Pd' d). \\<forall>a\\<in>Y. (a, b) \\<in> Pd' d}\n    \\<subseteq> {b \\<in> Field\n                          ((Pd'(Xd x :=\n                                  Restr (Pd' (Xd x))\n                                   {b. (x, b) \\<in> Pd' (Xd x)}))\n                            d).\n                 \\<forall>a\\<in>Y.\n                    (a, b)\n                    \\<in> (Pd'(Xd x :=\n                                 Restr (Pd' (Xd x))\n                                  {b. (x, b) \\<in> Pd' (Xd x)}))\n                           d}", "by (auto simp: Refl_Field_Restr subset_eq elim: transE)"], ["", "end"], ["", "(*>*)"], ["", "locale ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs =\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD + TruePrefs\nbegin"], ["", "interpretation TruePref: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd' Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd' Ch", "using %invisible Pd'_linear Pd'_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd' Ch", "by unfold_locales blast+"], ["", "interpretation TruePref_tax: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd'_tax Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd'_tax Ch", "using %invisible Pd'_tax_linear Pd'_tax_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad"], ["proof (prove)\nusing this:\n  Linear_order (Pd'_tax ?d)\n  Field (Pd'_tax ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. TruePref.unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd'_tax Ch", "by unfold_locales blast+"], ["", "interpretation\n  Singleton_for_d: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh \"Pd_singletons_for_ds X {Xd x}\" Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_singletons_for_ds X {Xd x}) Ch", "using %invisible Pd_singletons_for_ds_linear Pd_singletons_for_ds_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad X stable_on_allocation[OF X]"], ["proof (prove)\nusing this:\n  inj_on Xd ?X \\<Longrightarrow>\n  Linear_order (Pd_singletons_for_ds ?X ?ds ?d)\n  Field (Pd_singletons_for_ds ?X ?ds ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. TruePref_tax.unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n  stable_on ds X\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_singletons_for_ds X {Xd x}) Ch", "by unfold_locales blast+"], ["", "(*<*)"], ["", "lemma Xd_x_ds:\n  shows \"Xd x \\<in> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "using %invisible X stable_on_Xd x"], ["proof (prove)\nusing this:\n  stable_on ds X\n  \\<lbrakk>stable_on ?ds ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> Xd ?x \\<in> ?ds\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds", "by blast"], ["", "lemma TruePref_tax_Cd_not_x:\n  assumes \"d \\<noteq> Xd x\"\n  shows \"TruePref_tax.Cd d = Singleton_for_d.Cd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TruePref_tax.Cd d = Singleton_for_d.Cd d", "using assms spec[OF Pd', of d] stable_on_allocation[OF X]"], ["proof (prove)\nusing this:\n  d \\<noteq> Xd x\n  d \\<noteq> Xd x \\<longrightarrow> Pd' d = Pd d\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. TruePref_tax.Cd d = Singleton_for_d.Cd d", "unfolding TruePref_tax.Cd_def Singleton_for_d.Cd_def"], ["proof (prove)\nusing this:\n  d \\<noteq> Xd x\n  d \\<noteq> Xd x \\<longrightarrow> Pd' d = Pd d\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. set_option \\<circ> MaxR.MaxR_opt (Pd'_tax d) =\n    set_option \\<circ> MaxR.MaxR_opt (Pd_singletons_for_ds X {Xd x} d)", "by (simp add: Pd'_tax_def Pd_singletons_for_ds_simps)"], ["", "(*>*)"], ["", "lemma Theorem_11_Pd'_tax:\n  shows \"\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds.\n               (x, y) \\<in> Pd'_tax (Xd x)) \\<Longrightarrow>\n    False", "let ?Z = \"TruePref_tax.cop ds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds.\n               (x, y) \\<in> Pd'_tax (Xd x)) \\<Longrightarrow>\n    False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds.\n               (x, y) \\<in> Pd'_tax (Xd x)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x))", "have \"Xd x \\<notin> Xd ` ?Z\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x))\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` TruePref_tax.cop ds", "using Pd'_range Pd'_linear[of \"Xd x\"] Pd'_d'_x"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x))\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  Linear_order (Pd' (Xd x))\n  x \\<in> Field (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` TruePref_tax.cop ds", "unfolding order_on_defs"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x))\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  ((Refl (Pd' (Xd x)) \\<and> trans (Pd' (Xd x))) \\<and>\n   antisym (Pd' (Xd x))) \\<and>\n  Total (Pd' (Xd x))\n  x \\<in> Field (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> Xd ` TruePref_tax.cop ds", "by - (clarsimp, drule (1) bspec,\n          fastforce simp: Pd'_tax_def above_def Refl_Field_Restr dest: refl_onD\n                   dest!: CH_range' TruePref_tax.fp_cop_F_range_inv')"], ["proof (state)\nthis:\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>y\\<in>TruePref_tax.cop ds.\n               (x, y) \\<in> Pd'_tax (Xd x)) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"Singleton_for_d.stable_on ds ?Z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "from Theorem_10_fp_cop_F[OF X x, of \"Xd x\"] X"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>Singleton_for_d.cop ds.\n     (x, y) \\<in> Pd_singletons_for_ds X {Xd x} (Xd x)\n  stable_on ds X", "have \"x \\<in> CH (Singleton_for_d.fp_cop_F ds)\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>Singleton_for_d.cop ds.\n     (x, y) \\<in> Pd_singletons_for_ds X {Xd x} (Xd x)\n  stable_on ds X\n\ngoal (1 subgoal):\n 1. x \\<in> Singleton_for_d.cop ds", "by (force simp: Pd_singletons_for_ds_simps dX_def dest: inj_onD stable_on_allocation)"], ["proof (state)\nthis:\n  x \\<in> Singleton_for_d.cop ds\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "with Singleton_for_d.fp_cop_F_allocation"], ["proof (chain)\npicking this:\n  inj_on Xd (Singleton_for_d.cop ?ds)\n  x \\<in> Singleton_for_d.cop ds", "have \"Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}\""], ["proof (prove)\nusing this:\n  inj_on Xd (Singleton_for_d.cop ?ds)\n  x \\<in> Singleton_for_d.cop ds\n\ngoal (1 subgoal):\n 1. Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}", "by (meson Singleton_for_d.Cd_single Singleton_for_d.Cd_singleton Singleton_for_d.fp_cop_F_range_inv'\n                TruePref_tax.CH_range')"], ["proof (state)\nthis:\n  Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "with Singleton_for_d.Theorem_1[of ds]"], ["proof (chain)\npicking this:\n  Singleton_for_d.stable_on ds (Singleton_for_d.cop ds)\n  Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}", "have \"x \\<in> Y\" if \"Singleton_for_d.stable_on ds Y\" for Y"], ["proof (prove)\nusing this:\n  Singleton_for_d.stable_on ds (Singleton_for_d.cop ds)\n  Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}\n\ngoal (1 subgoal):\n 1. x \\<in> Y", "using Singleton_for_d.Theorem_6_fp_cop_F(1)[where ds=\"ds\" and X=\"Y\" and d=\"Xd x\"] that Xd_x_ds x\n            card_Suc_eq[where A=\"Singleton_for_d.Cd (Xd x) Y\" and k=0] stable_on_allocation[OF X]"], ["proof (prove)\nusing this:\n  Singleton_for_d.stable_on ds (Singleton_for_d.cop ds)\n  Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds) = {x}\n  \\<lbrakk>Singleton_for_d.stable_on ds Y; Xd x \\<in> ds\\<rbrakk>\n  \\<Longrightarrow> card (Singleton_for_d.Cd (Xd x) Y) =\n                    card\n                     (Singleton_for_d.Cd (Xd x) (Singleton_for_d.cop ds))\n  Singleton_for_d.stable_on ds Y\n  Xd x \\<in> ds\n  x \\<in> X\n  (card (Singleton_for_d.Cd (Xd x) Y) = Suc 0) =\n  (\\<exists>b B.\n      Singleton_for_d.Cd (Xd x) Y = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = 0 \\<and> (0 = 0 \\<longrightarrow> B = {}))\n  inj_on Xd X\n\ngoal (1 subgoal):\n 1. x \\<in> Y", "by (fastforce simp: Singleton_for_d.Cd_singleton[symmetric] Pd_singletons_for_ds_simps dX_def\n                    dest: Singleton_for_d.Cd_range' inj_onD)"], ["proof (state)\nthis:\n  Singleton_for_d.stable_on ds ?Y \\<Longrightarrow> x \\<in> ?Y\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Singleton_for_d.stable_on ds ?Y \\<Longrightarrow> x \\<in> ?Y\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "note \\<open>Xd x \\<notin> Xd ` ?Z\\<close>"], ["proof (state)\nthis:\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n\ngoal (2 subgoals):\n 1. Singleton_for_d.stable_on ds (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n  Singleton_for_d.stable_on ds ?Y \\<Longrightarrow> x \\<in> ?Y\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds", "show False"], ["proof (prove)\nusing this:\n  Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n  Singleton_for_d.stable_on ds ?Y \\<Longrightarrow> x \\<in> ?Y\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  \\<not> Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "note \\<open>\\<not>Singleton_for_d.stable_on ds ?Z\\<close>"], ["proof (state)\nthis:\n  \\<not> Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> Singleton_for_d.stable_on ds (TruePref_tax.cop ds)", "show False"], ["proof (prove)\nusing this:\n  \\<not> Singleton_for_d.stable_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. False", "proof(cases rule: Singleton_for_d.not_stable_on_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> Singleton_for_d.individually_rational_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "case not_individually_rational"], ["proof (state)\nthis:\n  \\<not> Singleton_for_d.individually_rational_on ds (TruePref_tax.cop ds)\n\ngoal (2 subgoals):\n 1. \\<not> Singleton_for_d.individually_rational_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False\n 2. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "with TruePref_tax.Theorem_1[of ds] \\<open>Xd x \\<notin> Xd ` ?Z\\<close>"], ["proof (chain)\npicking this:\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  \\<not> Singleton_for_d.individually_rational_on ds (TruePref_tax.cop ds)", "show False"], ["proof (prove)\nusing this:\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  \\<not> Singleton_for_d.individually_rational_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. False", "unfolding TruePref_tax.stable_on_def Singleton_for_d.individually_rational_on_def\n                  TruePref_tax.individually_rational_on_def Singleton_for_d.CD_on_def"], ["proof (prove)\nusing this:\n  (TruePref_tax.CD_on ds (TruePref_tax.cop ds) = TruePref_tax.cop ds \\<and>\n   Singleton_for_d.CH (TruePref_tax.cop ds) = TruePref_tax.cop ds) \\<and>\n  TruePref_tax.stable_no_blocking_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  \\<not> ((\\<Union>d\\<in>ds. Singleton_for_d.Cd d (TruePref_tax.cop ds)) =\n          TruePref_tax.cop ds \\<and>\n          Singleton_for_d.CH (TruePref_tax.cop ds) = TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: Singleton_for_d.Cd_range')\n           (metis TruePref_tax.mem_CD_on_Cd TruePref_tax_Cd_not_x image_eqI)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "case not_no_blocking"], ["proof (state)\nthis:\n  \\<not> Singleton_for_d.stable_no_blocking_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> Singleton_for_d.stable_no_blocking_on ds (TruePref_tax.cop ds)", "obtain h X'' where \"Singleton_for_d.blocking_on ds ?Z h X''\""], ["proof (prove)\nusing this:\n  \\<not> Singleton_for_d.stable_no_blocking_on ds (TruePref_tax.cop ds)\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h\n         X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Singleton_for_d.stable_no_blocking_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>h X'.\n             \\<not> Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h\n                     X')\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h\n         X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "have \"TruePref_tax.blocking_on ds ?Z h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TruePref_tax.blocking_on ds (TruePref_tax.cop ds) h X''", "proof(rule TruePref_tax.blocking_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (TruePref_tax.cop ds)\n 2. X'' = Ch h (TruePref_tax.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (TruePref_tax.cop ds)\n 2. X'' = Ch h (TruePref_tax.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "assume \"y \\<in> X''\""], ["proof (state)\nthis:\n  y \\<in> X''\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (TruePref_tax.cop ds)\n 2. X'' = Ch h (TruePref_tax.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "with \\<open>Singleton_for_d.blocking_on ds ?Z h X''\\<close>"], ["proof (chain)\npicking this:\n  Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h X''\n  y \\<in> X''", "have YYY: \"y \\<in> Singleton_for_d.CD_on ds (?Z \\<union> X'')\""], ["proof (prove)\nusing this:\n  Singleton_for_d.blocking_on ds (TruePref_tax.cop ds) h X''\n  y \\<in> X''\n\ngoal (1 subgoal):\n 1. y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "unfolding Singleton_for_d.blocking_on_def"], ["proof (prove)\nusing this:\n  X'' \\<noteq> Ch h (TruePref_tax.cop ds) \\<and>\n  X'' = Ch h (TruePref_tax.cop ds \\<union> X'') \\<and>\n  X''\n  \\<subseteq> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n  y \\<in> X''\n\ngoal (1 subgoal):\n 1. y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "by blast"], ["proof (state)\nthis:\n  y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (TruePref_tax.cop ds)\n 2. X'' = Ch h (TruePref_tax.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "show \"y \\<in> TruePref_tax.CD_on ds (?Z \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "proof(cases \"Xd y = Xd x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd y = Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n 2. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "case True"], ["proof (state)\nthis:\n  Xd y = Xd x\n\ngoal (2 subgoals):\n 1. Xd y = Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n 2. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "with inj_on_eq_iff[OF stable_on_allocation x] X YYY"], ["proof (chain)\npicking this:\n  \\<lbrakk>stable_on ?ds2 X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (Xd x = Xd ?y) = (x = ?y)\n  stable_on ds X\n  y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n  Xd y = Xd x", "have \"y = x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>stable_on ?ds2 X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> (Xd x = Xd ?y) = (x = ?y)\n  stable_on ds X\n  y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n  Xd y = Xd x\n\ngoal (1 subgoal):\n 1. y = x", "by (fastforce simp: Singleton_for_d.mem_CD_on_Cd Pd_singletons_for_ds_simps dX_def\n                          dest: Singleton_for_d.Cd_range')"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. Xd y = Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n 2. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "with X Xd_x_ds TruePref_tax.Theorem_1[of ds] \\<open>Xd x \\<notin> Xd ` ?Z\\<close> \\<open>y \\<in> X''\\<close>"], ["proof (chain)\npicking this:\n  stable_on ds X\n  Xd x \\<in> ds\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  y \\<in> X''\n  y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  stable_on ds X\n  Xd x \\<in> ds\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  y \\<in> X''\n  y = x\n\ngoal (1 subgoal):\n 1. y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "using Singleton_for_d.blocking_on_allocation[OF \\<open>Singleton_for_d.blocking_on ds ?Z h X''\\<close>]"], ["proof (prove)\nusing this:\n  stable_on ds X\n  Xd x \\<in> ds\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  Xd x \\<notin> Xd ` TruePref_tax.cop ds\n  y \\<in> X''\n  y = x\n  inj_on Xd X''\n\ngoal (1 subgoal):\n 1. y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "by (clarsimp simp: TruePref_tax.mem_CD_on_Cd TruePref_tax.Cd_greatest greatest_def Pd'_tax_x)\n               (metis TruePref_tax.Pd_range' image_eqI inj_on_contraD TruePref_tax.Pd_refl)"], ["proof (state)\nthis:\n  y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "case False"], ["proof (state)\nthis:\n  Xd y \\<noteq> Xd x\n\ngoal (1 subgoal):\n 1. Xd y \\<noteq> Xd x \\<Longrightarrow>\n    y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "with YYY"], ["proof (chain)\npicking this:\n  y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n  Xd y \\<noteq> Xd x", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> Singleton_for_d.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n  Xd y \\<noteq> Xd x\n\ngoal (1 subgoal):\n 1. y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')", "by (simp add: Singleton_for_d.mem_CD_on_Cd TruePref_tax.mem_CD_on_Cd TruePref_tax_Cd_not_x)"], ["proof (state)\nthis:\n  y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> TruePref_tax.CD_on ds (TruePref_tax.cop ds \\<union> X'')\n\ngoal (2 subgoals):\n 1. X'' \\<noteq> Ch h (TruePref_tax.cop ds)\n 2. X'' = Ch h (TruePref_tax.cop ds \\<union> X'')", "qed (use \\<open>Singleton_for_d.blocking_on ds ?Z h X''\\<close> in \\<open>simp_all add: Singleton_for_d.blocking_on_def\\<close>)"], ["proof (state)\nthis:\n  TruePref_tax.blocking_on ds (TruePref_tax.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<not> Singleton_for_d.stable_no_blocking_on ds\n            (TruePref_tax.cop ds) \\<Longrightarrow>\n    False", "with TruePref_tax.Theorem_1[of ds]"], ["proof (chain)\npicking this:\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  TruePref_tax.blocking_on ds (TruePref_tax.cop ds) h X''", "show False"], ["proof (prove)\nusing this:\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  TruePref_tax.blocking_on ds (TruePref_tax.cop ds) h X''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: TruePref_tax.blocking_on_imp_not_stable)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Theorem_11_fp_cop_F:\n  shows \"\\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "from Theorem_11_Pd'_tax"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x)", "obtain y where y: \"y \\<in> CH (TruePref_tax.fp_cop_F ds)\"\n            and xy: \"(x, y) \\<in> Pd'_tax (Xd x)\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>TruePref_tax.cop ds. (x, y) \\<in> Pd'_tax (Xd x)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> TruePref_tax.cop ds;\n         (x, y) \\<in> Pd'_tax (Xd x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y \\<in> TruePref_tax.cop ds\n  (x, y) \\<in> Pd'_tax (Xd x)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "from TruePref_tax.stable_on_range'[OF TruePref_tax.Theorem_1]"], ["proof (chain)\npicking this:\n  ?x \\<in> TruePref_tax.cop ?ds \\<Longrightarrow>\n  ?x \\<in> Field (Pd'_tax (Xd ?x))", "have \"dX (CH (TruePref_tax.fp_cop_F ds)) (Xd x) \\<subseteq> Field (Pd' (Xd x))\""], ["proof (prove)\nusing this:\n  ?x \\<in> TruePref_tax.cop ?ds \\<Longrightarrow>\n  ?x \\<in> Field (Pd'_tax (Xd ?x))\n\ngoal (1 subgoal):\n 1. Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x)\n    \\<subseteq> Field (Pd' (Xd x))", "by (clarsimp simp: dX_def) (metis (no_types, hide_lams) Pd'_tax_Pd' contra_subsetD mono_Field)"], ["proof (state)\nthis:\n  Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x)\n  \\<subseteq> Field (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "moreover"], ["proof (state)\nthis:\n  Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x)\n  \\<subseteq> Field (Pd' (Xd x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "from TruePref_tax.fp_cop_F_allocation[of ds] Pd'_tax_Pd' y xy"], ["proof (chain)\npicking this:\n  inj_on Xd (TruePref_tax.cop ds)\n  Pd'_tax ?d \\<subseteq> Pd' ?d\n  y \\<in> TruePref_tax.cop ds\n  (x, y) \\<in> Pd'_tax (Xd x)", "have \"Above (Pd' (Xd x)) (dX (CH (TruePref_tax.fp_cop_F ds)) (Xd x))\n     \\<subseteq> Above (Pd'_tax (Xd x)) (dX (CH (TruePref_tax.fp_cop_F ds)) (Xd x))\""], ["proof (prove)\nusing this:\n  inj_on Xd (TruePref_tax.cop ds)\n  Pd'_tax ?d \\<subseteq> Pd' ?d\n  y \\<in> TruePref_tax.cop ds\n  (x, y) \\<in> Pd'_tax (Xd x)\n\ngoal (1 subgoal):\n 1. Above (Pd' (Xd x)) (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n    \\<subseteq> Above (Pd'_tax (Xd x))\n                 (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))", "by - (rule Pd'_Above; fastforce simp: dX_singular above_def dest: TruePref_tax.Pd_Xd)"], ["proof (state)\nthis:\n  Above (Pd' (Xd x)) (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  \\<subseteq> Above (Pd'_tax (Xd x))\n               (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "moreover"], ["proof (state)\nthis:\n  Above (Pd' (Xd x)) (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  \\<subseteq> Above (Pd'_tax (Xd x))\n               (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "note Pd'_linear Pd'_range TruePref_tax.Theorem_1[of ds] y"], ["proof (state)\nthis:\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  y \\<in> TruePref_tax.cop ds\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "ultimately"], ["proof (chain)\npicking this:\n  Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x)\n  \\<subseteq> Field (Pd' (Xd x))\n  Above (Pd' (Xd x)) (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  \\<subseteq> Above (Pd'_tax (Xd x))\n               (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  y \\<in> TruePref_tax.cop ds", "have z: \"\\<exists>z\\<in>CH (TruePref.fp_cop_F ds). (y, z) \\<in> Pd' (Xd y)\""], ["proof (prove)\nusing this:\n  Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x)\n  \\<subseteq> Field (Pd' (Xd x))\n  Above (Pd' (Xd x)) (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  \\<subseteq> Above (Pd'_tax (Xd x))\n               (Singleton_for_d.dX (TruePref_tax.cop ds) (Xd x))\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  TruePref_tax.stable_on ds (TruePref_tax.cop ds)\n  y \\<in> TruePref_tax.cop ds\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>TruePref.cop ds. (y, z) \\<in> Pd' (Xd y)", "by - (rule TruePref_tax.Pd_above_irrelevant[where d'=\"Xd x\" and X=\"CH (TruePref_tax.fp_cop_F ds)\"];\n          simp add: Pd'_tax_def)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>TruePref.cop ds. (y, z) \\<in> Pd' (Xd y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "from Pd'_linear xy z"], ["proof (chain)\npicking this:\n  Linear_order (Pd' ?d)\n  (x, y) \\<in> Pd'_tax (Xd x)\n  \\<exists>z\\<in>TruePref.cop ds. (y, z) \\<in> Pd' (Xd y)", "show ?thesis"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  (x, y) \\<in> Pd'_tax (Xd x)\n  \\<exists>z\\<in>TruePref.cop ds. (y, z) \\<in> Pd' (Xd y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "unfolding Pd'_tax_def order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl (Pd' ?d) \\<and> trans (Pd' ?d)) \\<and> antisym (Pd' ?d)) \\<and>\n  Total (Pd' ?d)\n  (x, y)\n  \\<in> (Pd'(Xd x := Restr (Pd' (Xd x)) (above (Pd' (Xd x)) x))) (Xd x)\n  \\<exists>z\\<in>TruePref.cop ds. (y, z) \\<in> Pd' (Xd y)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)", "by clarsimp (metis TruePref.Pd_Xd transE)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale ContractsWithSubstitutesAndLADAndTruePrefs =\n  ContractsWithSubstitutesAndLAD + TruePrefs"], ["", "sublocale ContractsWithSubstitutesAndLADAndTruePrefs\n        < ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh Pd Ch x\n     X ds Pd'", "by %invisible unfold_locales"], ["", "context ContractsWithSubstitutesAndLADAndTruePrefs\nbegin"], ["", "interpretation TruePref: ContractsWithSubstitutesAndLAD Xd Xh Pd' Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndLAD Xd Xh Pd' Ch", "using %invisible Pd'_linear Pd'_range Ch_range Ch_singular Ch_substitutes Ch_irc Ch_lad"], ["proof (prove)\nusing this:\n  Linear_order (Pd' ?d)\n  Field (Pd' ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. substitutes (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithSubstitutesAndLAD Xd Xh Pd' Ch", "by unfold_locales blast+"], ["", "theorem Theorem_11:\n  shows \"\\<exists>y\\<in>match (TruePref.gfp_F ds). (x, y) \\<in> Pd' (Xd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.match (TruePref.gfp_F ds).\n       (x, y) \\<in> Pd' (Xd x)", "using Theorem_11_fp_cop_F TruePref.Theorem_15_match"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>TruePref.cop ds. (x, y) \\<in> Pd' (Xd x)\n  TruePref.match (TruePref.gfp_F ?ds) = TruePref.cop ?ds\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>TruePref.match (TruePref.gfp_F ds).\n       (x, y) \\<in> Pd' (Xd x)", "by simp"], ["", "end"], ["", "text\\<open>\n\nNote that this theorem depends on the hypotheses introduced by the\n@{const \"TruePrefs\"} locale, and only applies to doctor @{term \"Xd\nx\"}. The following sections show more general and syntactically\nself-contained results.\n\nWe omit \\citet[Theorem~12]{HatfieldMilgrom:2005}, which demonstrates\nthe almost-necessity of LAD for truth revelation to be the dominant\nstrategy for doctors.\n\n\\<close>"], ["", "subsection\\<open> \\citet{HatfieldKojima:2009,HatfieldKojima:2010}: The doctor-optimal match is group strategy-proof \\label{sec:strategic-gsp} \\<close>"], ["", "text \\<open>\n\n\\citet[Theorem~7]{HatfieldKojima:2010} assert that the COP is group\nstrategy-proof, which we define below. We begin by focusing on a\nsingle agent \\citep{HatfieldKojima:2009}: \\begin{quote}\n\nA mechanism @{term \"\\<phi>\"} is @{emph \\<open>strategy-proof\\<close>} if, for any\npreference profile @{term \"Pd\"}, there is no doctor @{term \"d\"} and\npreferences @{term \"Pd'\"} such that @{term \"d\"} strictly prefers\n@{term \"y\\<^sub>d\"} to @{term \"x\\<^sub>d\"} according to @{term \"Pd\nd\"}, where @{term \"x\\<^sub>d\"} and @{term \"y\\<^sub>d\"} are the\n(possibly null) contracts for @{term \"d\"} in @{term \"\\<phi> Pd\"} and\n\\<open>\\<phi> Pd(d := Pd')\\<close>, respectively.\n\n\\end{quote}\n\nThe syntax @{thm \"fun_upd_def\"} denotes function update at a point.\n\nWe make this definition in the \\<open>Contracts\\<close> locale to\navail ourselves of some types and the \\<open>Xd\\<close> and\n\\<open>Xh\\<close> constants. We also restrict hospital preferences to\nthose that guarantee our earlier strategic results.  As @{term\n\"gfp_F\"} requires these to satisfy the stronger @{const \"substitutes\"}\nconstraint for stable matches to exist, we now deal purely with the\nCOP.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "abbreviation (input) mechanism_domain :: \"('d \\<Rightarrow> 'x rel) \\<Rightarrow> ('h \\<Rightarrow> 'x cfun) \\<Rightarrow> bool\" where\n  \"mechanism_domain \\<equiv> ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\""], ["", "definition strategy_proof :: \"'d set \\<Rightarrow> ('d, 'h, 'x) mechanism \\<Rightarrow> bool\" where\n  \"strategy_proof ds \\<phi> \\<longleftrightarrow>\n    (\\<forall>Pd Ch. mechanism_domain Pd Ch \\<longrightarrow>\n     \\<not>(\\<exists>d\\<in>ds. \\<exists>Pd'. mechanism_domain (Pd(d:=Pd')) Ch\n       \\<and> (\\<exists>y\\<in>\\<phi> (Pd(d:=Pd')) Ch ds. y \\<in> AboveS (Pd d) (dX (\\<phi> Pd Ch ds) d))))\""], ["", "(*<*)"], ["", "lemma strategy_proofI:\n  assumes \"\\<And>Pd Pd' Ch d y. \\<lbrakk> mechanism_domain Pd Ch; mechanism_domain (Pd(d:=Pd')) Ch; d \\<in> ds;\n                             y \\<in> \\<phi> (Pd(d := Pd')) Ch ds; y \\<in> Field (Pd d);\n                             \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d. x \\<noteq> y \\<and> (x, y) \\<in> Pd d \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"strategy_proof ds \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_proof ds \\<phi>", "unfolding strategy_proof_def AboveS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Pd Ch.\n       ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd\n        Ch \\<longrightarrow>\n       \\<not> (\\<exists>d\\<in>ds.\n                  \\<exists>Pd'.\n                     ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n                      (Pd(d := Pd')) Ch \\<and>\n                     (\\<exists>y\\<in>\\<phi> (Pd(d := Pd')) Ch ds.\n                         y \\<in> {b \\<in> Field (Pd d).\n                                  \\<forall>a\\<in>dX (\\<phi> Pd Ch ds) d.\n                                     b \\<noteq> a \\<and>\n                                     (a, b) \\<in> Pd d}))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh ?Pd ?Ch;\n   ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (?Pd(?d := ?Pd'))\n    ?Ch;\n   ?d \\<in> ds; ?y \\<in> \\<phi> (?Pd(?d := ?Pd')) ?Ch ds;\n   ?y \\<in> Field (?Pd ?d);\n   \\<forall>x\\<in>dX (\\<phi> ?Pd ?Ch ds) ?d.\n      x \\<noteq> ?y \\<and> (x, ?y) \\<in> ?Pd ?d\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>Pd Ch.\n       ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd\n        Ch \\<longrightarrow>\n       \\<not> (\\<exists>d\\<in>ds.\n                  \\<exists>Pd'.\n                     ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n                      (Pd(d := Pd')) Ch \\<and>\n                     (\\<exists>y\\<in>\\<phi> (Pd(d := Pd')) Ch ds.\n                         y \\<in> {b \\<in> Field (Pd d).\n                                  \\<forall>a\\<in>dX (\\<phi> Pd Ch ds) d.\n                                     b \\<noteq> a \\<and>\n                                     (a, b) \\<in> Pd d}))", "by blast"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "theorem fp_cop_F_strategy_proof:\n  shows \"strategy_proof ds Contracts.cop\" (is \"strategy_proof _ ?\\<phi>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_proof ds\n     (\\<lambda>Pd Ch ds. Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))", "proof %invisible (rule strategy_proofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "fix Pd Pd' Ch d y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"mechanism_domain Pd Ch\" and B: \"mechanism_domain (Pd(d:=Pd')) Ch\"\n     and y: \"y \\<in> ?\\<phi> (Pd(d := Pd')) Ch ds\" \"y \\<in> Field (Pd d)\" \"\\<forall>x\\<in>dX (?\\<phi> Pd Ch ds) d. x \\<noteq> y \\<and> (x, y) \\<in> Pd d\""], ["proof (state)\nthis:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds)\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "from A"], ["proof (chain)\npicking this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch", "interpret TruePref: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch"], ["proof (prove)\nusing this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>TruePref.dX\n                        (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "from B"], ["proof (chain)\npicking this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch", "interpret ManiPref: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh \"Pd(d := Pd')\" Ch"], ["proof (prove)\nusing this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>ManiPref.dX\n                        (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "from B y"], ["proof (chain)\npicking this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  y \\<in> ManiPref.cop ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>ManiPref.dX (TruePref.cop ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d", "interpret ManiPref: ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh \"Pd(d := Pd')\" Ch y \"?\\<phi> (Pd(d := Pd')) Ch ds\" ds Pd"], ["proof (prove)\nusing this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  y \\<in> ManiPref.cop ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>ManiPref.dX (TruePref.cop ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh\n     (Pd(d := Pd')) Ch y (ManiPref.cop ds) ds Pd", "by unfold_locales (simp_all add: FieldI2 TruePref.Pd_Xd TruePref.Pd_linear TruePref.Pd_range' subsetI ManiPref.Theorem_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>ManiPref.dX\n                        (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "from ManiPref.Theorem_11_fp_cop_F"], ["proof (chain)\npicking this:\n  \\<exists>ya\\<in>TruePref.cop ds. (y, ya) \\<in> Pd (Xd y)", "obtain z where \"z \\<in> TruePref.cop ds\" \"(y, z) \\<in> Pd (Xd y)\""], ["proof (prove)\nusing this:\n  \\<exists>ya\\<in>TruePref.cop ds. (y, ya) \\<in> Pd (Xd y)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> TruePref.cop ds; (y, z) \\<in> Pd (Xd y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  z \\<in> TruePref.cop ds\n  (y, z) \\<in> Pd (Xd y)\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds;\n        y \\<in> Contracts.CH Ch (Contracts.fp_cop_F (Pd(d := Pd')) Ch ds);\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>ManiPref.dX\n                        (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "with TruePref.Pd_linear TruePref.stable_on_allocation[OF TruePref.Theorem_1[of ds]] TruePref.Pd_Xd TruePref.Pd_range' y"], ["proof (chain)\npicking this:\n  \\<forall>d. Linear_order (Pd d)\n  inj_on Xd (TruePref.cop ds)\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  y \\<in> ManiPref.cop ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>ManiPref.dX (TruePref.cop ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n  z \\<in> TruePref.cop ds\n  (y, z) \\<in> Pd (Xd y)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>d. Linear_order (Pd d)\n  inj_on Xd (TruePref.cop ds)\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  y \\<in> ManiPref.cop ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>ManiPref.dX (TruePref.cop ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n  z \\<in> TruePref.cop ds\n  (y, z) \\<in> Pd (Xd y)\n\ngoal (1 subgoal):\n 1. False", "unfolding order_on_defs antisym_def dX_def"], ["proof (prove)\nusing this:\n  \\<forall>d.\n     ((Refl (Pd d) \\<and> trans (Pd d)) \\<and>\n      (\\<forall>x y.\n          (x, y) \\<in> Pd d \\<longrightarrow>\n          (y, x) \\<in> Pd d \\<longrightarrow> x = y)) \\<and>\n     Total (Pd d)\n  inj_on Xd (TruePref.cop ds)\n  (?x, ?y) \\<in> Pd ?d \\<Longrightarrow> Xd ?x = ?d \\<and> Xd ?y = ?d\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n  y \\<in> ManiPref.cop ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>{x \\<in> TruePref.cop ds. Xd x = d}.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n  z \\<in> TruePref.cop ds\n  (y, z) \\<in> Pd (Xd y)\n\ngoal (1 subgoal):\n 1. False", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\nThe adaptation to groups is straightforward\n\\citep{HatfieldKojima:2009,HatfieldKojima:2010}:\n\\begin{quote}\n\nA mechanism @{term \"\\<phi>\"} is @{emph \\<open>group strategy-proof\\<close>} if, for\nany preference profile @{term \"Pd\"}, there is no group of doctors\n@{term \"ds' \\<subseteq> ds\"} and a preference profile @{term \"Pd'\"}\nsuch that every @{term \"d \\<in> ds'\"} strictly prefers @{term\n\"y\\<^sub>d\"} to @{term \"x\\<^sub>d\"} according to @{term \"Pd d\"}, where\n@{term \"x\\<^sub>d\"} and @{term \"y\\<^sub>d\"} are the (possibly null)\ncontracts for @{term \"d\"} in @{term \"\\<phi> Pd\"} and \\<open>\\<phi>\nPd(d\\<^sub>1 := Pd' d\\<^sub>1, \\<dots>, d\\<^sub>n := Pd' d\\<^sub>n)\\<close>,\nrespectively.\n\n\\end{quote}\n\nThis definition requires all doctors in the coalition to strictly\nprefer the outcome with manipulated preferences, as\n\\citeauthor{Kojima:2010}'s bossiness results (see\n\\S\\ref{sec:bossiness}) show that a doctor may influence other doctors'\nallocations without affecting their own. See\n\\citet[\\S3]{HatfieldKojima:2009} for discussion, and also\n\\citet[Chapter~4]{RothSotomayor:1990}; in particular their \\S4.3.1\ndiscusses the robustness of these results and exogenous transfers.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition group_strategy_proof :: \"'d set \\<Rightarrow> ('d, 'h, 'x) mechanism \\<Rightarrow> bool\" where\n  \"group_strategy_proof ds \\<phi> \\<longleftrightarrow>\n    (\\<forall>Pd Ch. mechanism_domain Pd Ch \\<longrightarrow>\n     \\<not>(\\<exists>ds'\\<subseteq>ds. ds' \\<noteq> {} \\<and> (\\<exists>Pd'. mechanism_domain (override_on Pd Pd' ds') Ch\n       \\<and> (\\<forall>d\\<in>ds'. \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch ds. y \\<in> AboveS (Pd d) (dX (\\<phi> Pd Ch ds) d)))))\""], ["", "(*<*)"], ["", "lemma group_strategy_proofI:\n  assumes \"\\<And>Pd Pd' Ch ds'. \\<lbrakk> mechanism_domain Pd Ch; mechanism_domain (override_on Pd Pd' ds') Ch; ds' \\<subseteq> ds; ds' \\<noteq> {};\n                             \\<forall>d\\<in>ds'. \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch ds. y \\<in> AboveS (Pd d) (dX (\\<phi> Pd Ch ds) d) \\<rbrakk> \\<Longrightarrow> False\"\n  shows \"group_strategy_proof ds \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_strategy_proof ds \\<phi>", "unfolding group_strategy_proof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Pd Ch.\n       ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd\n        Ch \\<longrightarrow>\n       \\<not> (\\<exists>ds'\\<subseteq>ds.\n                  ds' \\<noteq> {} \\<and>\n                  (\\<exists>Pd'.\n                      ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n                       (override_on Pd Pd' ds') Ch \\<and>\n                      (\\<forall>d\\<in>ds'.\n                          \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch\n    ds.\n                             y \\<in> AboveS (Pd d)\n(dX (\\<phi> Pd Ch ds) d))))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh ?Pd ?Ch;\n   ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n    (override_on ?Pd ?Pd' ?ds') ?Ch;\n   ?ds' \\<subseteq> ds; ?ds' \\<noteq> {};\n   \\<forall>d\\<in>?ds'.\n      \\<exists>y\\<in>\\<phi> (override_on ?Pd ?Pd' ?ds') ?Ch ds.\n         y \\<in> AboveS (?Pd d) (dX (\\<phi> ?Pd ?Ch ds) d)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>Pd Ch.\n       ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd\n        Ch \\<longrightarrow>\n       \\<not> (\\<exists>ds'\\<subseteq>ds.\n                  ds' \\<noteq> {} \\<and>\n                  (\\<exists>Pd'.\n                      ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n                       (override_on Pd Pd' ds') Ch \\<and>\n                      (\\<forall>d\\<in>ds'.\n                          \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch\n    ds.\n                             y \\<in> AboveS (Pd d)\n(dX (\\<phi> Pd Ch ds) d))))", "by blast"], ["", "lemmas group_strategy_proofD = iffD1[OF group_strategy_proof_def, simplified, unfolded disj_imp, simplified, rule_format]"], ["", "(*>*)"], ["", "lemma group_strategy_proof_strategy_proof:\n  assumes \"group_strategy_proof ds \\<phi>\"\n  shows \"strategy_proof ds \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_proof ds \\<phi>", "proof %invisible (rule strategy_proofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds; y \\<in> \\<phi> (Pd(d := Pd')) Ch ds;\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "fix Pd Pd' Ch d y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds; y \\<in> \\<phi> (Pd(d := Pd')) Ch ds;\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"mechanism_domain Pd Ch\" \"mechanism_domain (Pd(d := Pd')) Ch\" \"d \\<in> ds\"\n         \"y \\<in> \\<phi> (Pd(d := Pd')) Ch ds\" \"y \\<in> Field (Pd d)\" \"\\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d. x \\<noteq> y \\<and> (x, y) \\<in> Pd d\""], ["proof (state)\nthis:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  d \\<in> ds\n  y \\<in> \\<phi> (Pd(d := Pd')) Ch ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch d y.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd'))\n         Ch;\n        d \\<in> ds; y \\<in> \\<phi> (Pd(d := Pd')) Ch ds;\n        y \\<in> Field (Pd d);\n        \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n           x \\<noteq> y \\<and> (x, y) \\<in> Pd d\\<rbrakk>\n       \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  group_strategy_proof ds \\<phi>\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  d \\<in> ds\n  y \\<in> \\<phi> (Pd(d := Pd')) Ch ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d", "show False"], ["proof (prove)\nusing this:\n  group_strategy_proof ds \\<phi>\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  d \\<in> ds\n  y \\<in> \\<phi> (Pd(d := Pd')) Ch ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. False", "unfolding group_strategy_proof_def"], ["proof (prove)\nusing this:\n  \\<forall>Pd Ch.\n     ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd\n      Ch \\<longrightarrow>\n     \\<not> (\\<exists>ds'\\<subseteq>ds.\n                ds' \\<noteq> {} \\<and>\n                (\\<exists>Pd'.\n                    ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n                     (override_on Pd Pd' ds') Ch \\<and>\n                    (\\<forall>d\\<in>ds'.\n                        \\<exists>y\\<in>\\<phi> (override_on Pd Pd' ds') Ch\n  ds.\n                           y \\<in> AboveS (Pd d) (dX (\\<phi> Pd Ch ds) d))))\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh (Pd(d := Pd')) Ch\n  d \\<in> ds\n  y \\<in> \\<phi> (Pd(d := Pd')) Ch ds\n  y \\<in> Field (Pd d)\n  \\<forall>x\\<in>dX (\\<phi> Pd Ch ds) d.\n     x \\<noteq> y \\<and> (x, y) \\<in> Pd d\n\ngoal (1 subgoal):\n 1. False", "by (clarsimp dest!: spec[where x=Pd] spec[where x=Ch])\n       (fastforce simp: override_on_insert AboveS_def dest!: spec[where x=\"{d}\"])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\n\\label{sec:strategic-hk2010-lemma1}\n\nPerhaps surprisingly, \\citet[Lemma~1, for a single\ndoctor]{HatfieldKojima:2010} assert that shuffling any contract above\nthe doctor-optimal one to the top of a doctor's preference order\npreserves exactly the doctor-optimal match, which on the face of it\nseems to contradict the bossiness result of \\S\\ref{sec:bossiness}: by\nthe earlier strategy-proofness results, this cannot affect the outcome\nfor that particular doctor, but by bossiness it may affect others.\nThe key observation is that this manipulation preserves blocking\ncoalitions in the presence of @{const \"lad\"}.\n\nThis result is central to showing the group-strategy-proofness of the\nCOP.\n\n\\<close>"], ["", "context Contracts\nbegin"], ["", "definition shuffle_to_top :: \"'x set \\<Rightarrow> 'd \\<Rightarrow> 'x rel\" where\n  \"shuffle_to_top Y = (\\<lambda>d. Pd d - dX Y d \\<times> UNIV \\<union> (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)\""], ["", "definition Pd_shuffle_to_top :: \"'d set \\<Rightarrow> 'x set \\<Rightarrow> 'd \\<Rightarrow> 'x rel\" where\n  \"Pd_shuffle_to_top ds' Y = override_on Pd (shuffle_to_top Y) ds'\""], ["", "(*<*)"], ["", "lemma shuffle_to_top_Field:\n  assumes \"allocation Y\"\n  shows \"Field (shuffle_to_top Y d) = Field (Pd d) \\<union> dX Y d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (shuffle_to_top Y d) = Field (Pd d) \\<union> dX Y d", "unfolding shuffle_to_top_def Field_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d) \\<union>\n    Range\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d) =\n    Domain (Pd d) \\<union> Range (Pd d) \\<union> dX Y d", "using dX_empty_or_singleton[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>d. dX Y d = {} \\<or> (\\<exists>x. dX Y d = {x})\n\ngoal (1 subgoal):\n 1. Domain\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d) \\<union>\n    Range\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d) =\n    Domain (Pd d) \\<union> Range (Pd d) \\<union> dX Y d", "by (auto simp: Domain.simps; meson FieldI2 equalityE Pd_refl)"], ["", "lemma shuffle_to_top_Total:\n  assumes \"allocation Y\"\n  shows \"Total (shuffle_to_top Y d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Total (shuffle_to_top Y d)", "using Pd_linear'[of d] dX_empty_or_singleton[OF assms]"], ["proof (prove)\nusing this:\n  Linear_order (Pd d)\n  \\<forall>d. dX Y d = {} \\<or> (\\<exists>x. dX Y d = {x})\n\ngoal (1 subgoal):\n 1. Total (shuffle_to_top Y d)", "unfolding order_on_defs total_on_def shuffle_to_top_Field[OF assms]"], ["proof (prove)\nusing this:\n  ((Refl (Pd d) \\<and> trans (Pd d)) \\<and> antisym (Pd d)) \\<and>\n  (\\<forall>x\\<in>Field (Pd d).\n      \\<forall>y\\<in>Field (Pd d).\n         x \\<noteq> y \\<longrightarrow>\n         (x, y) \\<in> Pd d \\<or> (y, x) \\<in> Pd d)\n  \\<forall>d. dX Y d = {} \\<or> (\\<exists>x. dX Y d = {x})\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>Field (Pd d) \\<union> dX Y d.\n       \\<forall>y\\<in>Field (Pd d) \\<union> dX Y d.\n          x \\<noteq> y \\<longrightarrow>\n          (x, y) \\<in> shuffle_to_top Y d \\<or>\n          (y, x) \\<in> shuffle_to_top Y d", "by (auto simp: shuffle_to_top_def Domain.simps dest: refl_onD)"], ["", "lemma shuffle_to_top_linear:\n  assumes \"allocation Y\"\n  shows \"Linear_order (shuffle_to_top Y d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (shuffle_to_top Y d)", "using Pd_linear'[of d] dX_empty_or_singleton[OF assms] shuffle_to_top_Total[OF assms]"], ["proof (prove)\nusing this:\n  Linear_order (Pd d)\n  \\<forall>d. dX Y d = {} \\<or> (\\<exists>x. dX Y d = {x})\n  Total (shuffle_to_top Y ?d)\n\ngoal (1 subgoal):\n 1. Linear_order (shuffle_to_top Y d)", "unfolding shuffle_to_top_def order_on_defs"], ["proof (prove)\nusing this:\n  ((Refl (Pd d) \\<and> trans (Pd d)) \\<and> antisym (Pd d)) \\<and>\n  Total (Pd d)\n  \\<forall>d. dX Y d = {} \\<or> (\\<exists>x. dX Y d = {x})\n  Total\n   (Pd ?d - dX Y ?d \\<times> UNIV \\<union>\n    (Domain (Pd ?d) \\<union> dX Y ?d) \\<times> dX Y ?d)\n\ngoal (1 subgoal):\n 1. ((Refl\n       (Pd d - dX Y d \\<times> UNIV \\<union>\n        (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d) \\<and>\n      trans\n       (Pd d - dX Y d \\<times> UNIV \\<union>\n        (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)) \\<and>\n     antisym\n      (Pd d - dX Y d \\<times> UNIV \\<union>\n       (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)) \\<and>\n    Total\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)", "by (auto simp: Field_def intro!: antisymI refl_onI transI dest: refl_onD antisymD elim: transE)"], ["", "lemma shuffle_to_top_range:\n  shows \"Field (shuffle_to_top Y d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (shuffle_to_top Y d) \\<subseteq> {x. Xd x = d}", "unfolding shuffle_to_top_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Field\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)\n    \\<subseteq> {x. Xd x = d}", "using Pd_range dX_range"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  \\<forall>d. dX ?X d \\<subseteq> {x. Xd x = d}\n\ngoal (1 subgoal):\n 1. Field\n     (Pd d - dX Y d \\<times> UNIV \\<union>\n      (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d)\n    \\<subseteq> {x. Xd x = d}", "by (force simp: Field_def)"], ["", "lemma shuffle_to_top_range':\n  assumes \"(x, y) \\<in> shuffle_to_top Y d\"\n  shows \"x \\<in> Field (Pd d) \\<union> dX Y d \\<and> y \\<in> Field (Pd d) \\<union> dX Y d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd d) \\<union> dX Y d \\<and>\n    y \\<in> Field (Pd d) \\<union> dX Y d", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> shuffle_to_top Y d\n\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd d) \\<union> dX Y d \\<and>\n    y \\<in> Field (Pd d) \\<union> dX Y d", "unfolding shuffle_to_top_def"], ["proof (prove)\nusing this:\n  (x, y)\n  \\<in> Pd d - dX Y d \\<times> UNIV \\<union>\n        (Domain (Pd d) \\<union> dX Y d) \\<times> dX Y d\n\ngoal (1 subgoal):\n 1. x \\<in> Field (Pd d) \\<union> dX Y d \\<and>\n    y \\<in> Field (Pd d) \\<union> dX Y d", "by (auto intro: FieldI1 FieldI2)"], ["", "lemma Pd_shuffle_to_top_linear:\n  assumes \"allocation Y\"\n  shows \"Linear_order (Pd_shuffle_to_top ds' Y d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (Pd_shuffle_to_top ds' Y d)", "unfolding Pd_shuffle_to_top_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Linear_order (override_on Pd (shuffle_to_top Y) ds' d)", "using Pd_linear shuffle_to_top_linear[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>d. Linear_order (Pd d)\n  Linear_order (shuffle_to_top Y ?d)\n\ngoal (1 subgoal):\n 1. Linear_order (override_on Pd (shuffle_to_top Y) ds' d)", "by (cases \"d \\<in> ds'\") simp_all"], ["", "lemma Pd_shuffle_to_top_range:\n  shows \"Field (Pd_shuffle_to_top ds' Y d) \\<subseteq> {x. Xd x = d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd_shuffle_to_top ds' Y d) \\<subseteq> {x. Xd x = d}", "unfolding Pd_shuffle_to_top_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (override_on Pd (shuffle_to_top Y) ds' d)\n    \\<subseteq> {x. Xd x = d}", "using Pd_range shuffle_to_top_range"], ["proof (prove)\nusing this:\n  \\<forall>d. Field (Pd d) \\<subseteq> {x. Xd x = d}\n  Field (shuffle_to_top ?Y ?d) \\<subseteq> {x. Xd x = ?d}\n\ngoal (1 subgoal):\n 1. Field (override_on Pd (shuffle_to_top Y) ds' d)\n    \\<subseteq> {x. Xd x = d}", "by (cases \"d \\<in> ds'\") simp_all"], ["", "lemma Pd_shuffle_to_top_simps:\n  shows \"Pd_shuffle_to_top (insert d ds') Y = (Pd_shuffle_to_top ds' Y)(d := shuffle_to_top Y d)\"\n    and \"d \\<in> ds' \\<Longrightarrow> Pd_shuffle_to_top ds' Y d = shuffle_to_top Y d\"\n    and \"d \\<notin> ds' \\<Longrightarrow> Pd_shuffle_to_top ds' Y d = Pd d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pd_shuffle_to_top (insert d ds') Y = (Pd_shuffle_to_top ds' Y)\n    (d := shuffle_to_top Y d) &&&\n    (d \\<in> ds' \\<Longrightarrow>\n     Pd_shuffle_to_top ds' Y d = shuffle_to_top Y d) &&&\n    (d \\<notin> ds' \\<Longrightarrow> Pd_shuffle_to_top ds' Y d = Pd d)", "unfolding Pd_shuffle_to_top_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. override_on Pd (shuffle_to_top Y) (insert d ds') =\n    (override_on Pd (shuffle_to_top Y) ds')(d := shuffle_to_top Y d) &&&\n    (d \\<in> ds' \\<Longrightarrow>\n     override_on Pd (shuffle_to_top Y) ds' d = shuffle_to_top Y d) &&&\n    (d \\<notin> ds' \\<Longrightarrow>\n     override_on Pd (shuffle_to_top Y) ds' d = Pd d)", "by (simp_all add: override_on_insert)"], ["", "lemma Pd_shuffle_to_top_Field:\n  assumes \"allocation Y\"\n  shows \"Field (Pd_shuffle_to_top ds' Y d) = Field (Pd d) \\<union> (if d \\<in> ds' then dX Y d else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field (Pd_shuffle_to_top ds' Y d) =\n    Field (Pd d) \\<union> (if d \\<in> ds' then dX Y d else {})", "by (simp add: Pd_shuffle_to_top_simps shuffle_to_top_Field[OF assms])"], ["", "lemma Above_shuffle_to_top:\n  assumes \"x \\<in> Above (shuffle_to_top Y (Xd x)) X\"\n  assumes \"y \\<in> Y\"\n  assumes \"allocation Y\"\n  assumes \"y \\<in> X\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Above (shuffle_to_top Y (Xd x)) X\n  y \\<in> Y\n  inj_on Xd Y\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. x = y", "unfolding Above_def shuffle_to_top_def"], ["proof (prove)\nusing this:\n  x \\<in> {b \\<in> Field\n                    (Pd (Xd x) - dX Y (Xd x) \\<times> UNIV \\<union>\n                     (Domain (Pd (Xd x)) \\<union> dX Y (Xd x)) \\<times>\n                     dX Y (Xd x)).\n           \\<forall>a\\<in>X.\n              (a, b)\n              \\<in> Pd (Xd x) - dX Y (Xd x) \\<times> UNIV \\<union>\n                    (Domain (Pd (Xd x)) \\<union> dX Y (Xd x)) \\<times>\n                    dX Y (Xd x)}\n  y \\<in> Y\n  inj_on Xd Y\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. x = y", "by (fastforce simp: dX_singular dest: Pd_Xd dX_range' Pd_range' inj_onD)"], ["", "(*>*)"], ["", "end"], ["", "context ContractsWithUnilateralSubstitutesAndIRCAndLAD\nbegin"], ["", "lemma Lemma_1:\n  assumes \"allocation Y\"\n  assumes III: \"\\<forall>d\\<in>ds''. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)\"\n  shows \"cop ds = Contracts.cop (Pd_shuffle_to_top ds'' Y) Ch ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds'' Y) Ch ds)", "using finite[of ds''] subset_refl"], ["proof (prove)\nusing this:\n  finite ds''\n  ?A \\<subseteq> ?A\n\ngoal (1 subgoal):\n 1. cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds'' Y) Ch ds)", "proof(induct ds'' rule: finite_subset_induct')"], ["proof (state)\ngoal (2 subgoals):\n 1. cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top {} Y) Ch ds)\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         CH (Contracts.fp_cop_F\n                              (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top {} Y) Ch ds)\n 2. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         CH (Contracts.fp_cop_F\n                              (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top {} Y) Ch ds)", "by (simp add: Pd_shuffle_to_top_simps)"], ["proof (state)\nthis:\n  cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top {} Y) Ch ds)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         CH (Contracts.fp_cop_F\n                              (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         CH (Contracts.fp_cop_F\n                              (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "case (insert d ds')"], ["proof (state)\nthis:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds' Y) Ch ds)\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         CH (Contracts.fp_cop_F\n                              (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "from insert"], ["proof (chain)\npicking this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds' Y) Ch ds)", "interpret Pds': ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh \"Pd_shuffle_to_top ds' Y\" Ch"], ["proof (prove)\nusing this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds' Y) Ch ds)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_shuffle_to_top ds' Y) Ch", "using %invisible Pd_shuffle_to_top_linear[OF \\<open>allocation Y\\<close>] Pd_shuffle_to_top_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad"], ["proof (prove)\nusing this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = CH (Contracts.fp_cop_F (Pd_shuffle_to_top ds' Y) Ch ds)\n  Linear_order (Pd_shuffle_to_top ?ds' Y ?d)\n  Field (Pd_shuffle_to_top ?ds' ?Y ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_shuffle_to_top ds' Y) Ch", "by unfold_locales simp_all"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "let ?Z = \"CH (Pds'.fp_cop_F ds)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "note IH = \\<open>cop ds = ?Z\\<close>"], ["proof (state)\nthis:\n  cop ds = Pds'.cop ds\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "let ?Pd_shuffle_to_top = \"Pd_shuffle_to_top (insert d ds') Y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "from insert"], ["proof (chain)\npicking this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = Pds'.cop ds", "interpret Pdds': ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh ?Pd_shuffle_to_top Ch"], ["proof (prove)\nusing this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = Pds'.cop ds\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_shuffle_to_top (insert d ds') Y) Ch", "using %invisible Pd_shuffle_to_top_linear[OF \\<open>allocation Y\\<close>] Pd_shuffle_to_top_range Ch_range Ch_singular Ch_unilateral_substitutes Ch_irc Ch_lad"], ["proof (prove)\nusing this:\n  finite ds'\n  d \\<in> ds''\n  ds' \\<subseteq> ds''\n  d \\<notin> ds'\n  cop ds = Pds'.cop ds\n  Linear_order (Pd_shuffle_to_top ?ds' Y ?d)\n  Field (Pd_shuffle_to_top ?ds' ?Y ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  \\<forall>h. Pds'.unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_shuffle_to_top (insert d ds') Y) Ch", "by unfold_locales (simp_all add: Pd_shuffle_to_top_simps(1)[symmetric])\n  \\<comment> \\<open>\\citet[Lemma~1, for a single doctor]{HatfieldKojima:2010}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pdds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pdds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "have XXX: \"?Z = CH (Pdds'.fp_cop_F ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pds'.cop ds = Pdds'.cop ds", "proof(rule Pdds'.doctor_optimal_match_unique[OF Pdds'.doctor_optimal_matchI Pdds'.fp_cop_F_doctor_optimal_match])"], ["proof (state)\ngoal (2 subgoals):\n 1. Pdds'.stable_on ds (Pds'.cop ds)\n 2. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "show \"Pdds'.stable_on ds ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.stable_on ds (Pds'.cop ds)", "proof(rule Pdds'.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Pdds'.individually_rational_on ds (Pds'.cop ds)\n 2. Pdds'.stable_no_blocking_on ds (Pds'.cop ds)", "show \"Pdds'.individually_rational_on ds ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.individually_rational_on ds (Pds'.cop ds)", "proof(rule Pdds'.individually_rational_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Pdds'.CD_on ds (Pds'.cop ds) = Pds'.cop ds\n 2. Pdds'.CH (Pds'.cop ds) = Pds'.cop ds", "show \"Pdds'.CD_on ds ?Z = ?Z\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.CD_on ds (Pds'.cop ds) = Pds'.cop ds", "proof(rule set_elem_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds) \\<Longrightarrow>\n       x \\<in> Pds'.cop ds\n 2. \\<And>x.\n       x \\<in> Pds'.cop ds \\<Longrightarrow>\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds) \\<Longrightarrow>\n       x \\<in> Pds'.cop ds\n 2. \\<And>x.\n       x \\<in> Pds'.cop ds \\<Longrightarrow>\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds)", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> Pds'.cop ds\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds) \\<Longrightarrow>\n       x \\<in> Pds'.cop ds\n 2. \\<And>x.\n       x \\<in> Pds'.cop ds \\<Longrightarrow>\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds)", "with \\<open>allocation Y\\<close> IH Pds'.Theorem_1[of ds] \\<open>d \\<notin> ds'\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  cop ds = Pds'.cop ds\n  Pds'.stable_on ds (Pds'.cop ds)\n  d \\<notin> ds'\n  x \\<in> Pds'.cop ds", "show \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  cop ds = Pds'.cop ds\n  Pds'.stable_on ds (Pds'.cop ds)\n  d \\<notin> ds'\n  x \\<in> Pds'.cop ds\n\ngoal (1 subgoal):\n 1. x \\<in> Pdds'.CD_on ds (Pds'.cop ds)", "by (clarsimp simp: Pds'.stable_on_Xd Pdds'.mem_CD_on_Cd Pdds'.Cd_greatest greatest_def\n                               Pd_shuffle_to_top_Field[OF \\<open>allocation Y\\<close>],\n                simp add: Pd_shuffle_to_top_simps shuffle_to_top_def dX_def Set.Ball_def,\n                metis stable_on_range'[OF Theorem_1[of ds]] inj_on_contraD[OF Pds'.fp_cop_F_allocation[of ds]]\n                      fp_cop_F_worst[of _ ds] Pd_range' Pds'.CH_range')"], ["proof (state)\nthis:\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Pdds'.CD_on ds (Pds'.cop ds) \\<Longrightarrow>\n       x \\<in> Pds'.cop ds", "qed (meson IntE Pdds'.CD_on_range')"], ["proof (state)\nthis:\n  Pdds'.CD_on ds (Pds'.cop ds) = Pds'.cop ds\n\ngoal (1 subgoal):\n 1. Pdds'.CH (Pds'.cop ds) = Pds'.cop ds", "show \"CH ?Z = ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.CH (Pds'.cop ds) = Pds'.cop ds", "by (simp add: CH_irc_idem)"], ["proof (state)\nthis:\n  Pdds'.CH (Pds'.cop ds) = Pds'.cop ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pdds'.individually_rational_on ds (Pds'.cop ds)\n\ngoal (1 subgoal):\n 1. Pdds'.stable_no_blocking_on ds (Pds'.cop ds)", "show \"Pdds'.stable_no_blocking_on ds ?Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.stable_no_blocking_on ds (Pds'.cop ds)", "proof(rule Pdds'.stable_no_blocking_onI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       Pdds'.blocking_on ds (Pds'.cop ds) h X'' \\<Longrightarrow> False", "fix h X''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       Pdds'.blocking_on ds (Pds'.cop ds) h X'' \\<Longrightarrow> False", "assume Pbo: \"Pdds'.blocking_on ds ?Z h X''\""], ["proof (state)\nthis:\n  Pdds'.blocking_on ds (Pds'.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       Pdds'.blocking_on ds (Pds'.cop ds) h X'' \\<Longrightarrow> False", "have \"Pds'.blocking_on ds ?Z h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pds'.blocking_on ds (Pds'.cop ds) h X''", "proof(rule Pds'.blocking_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (Pds'.cop ds)\n 2. X'' = Ch h (Pds'.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (Pds'.cop ds)\n 2. X'' = Ch h (Pds'.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "assume \"x \\<in> X''\""], ["proof (state)\nthis:\n  x \\<in> X''\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (Pds'.cop ds)\n 2. X'' = Ch h (Pds'.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "note Pbos = Pdds'.blocking_on_allocation[OF \\<open>Pdds'.blocking_on ds ?Z h X''\\<close>]\n                      Pdds'.blocking_on_CD_on'[OF \\<open>Pdds'.blocking_on ds ?Z h X''\\<close> \\<open>x \\<in> X''\\<close>]\n                      Pdds'.blocking_on_Cd[OF \\<open>Pdds'.blocking_on ds ?Z h X''\\<close>, where d=\"Xd x\"]"], ["proof (state)\nthis:\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (Pds'.cop ds)\n 2. X'' = Ch h (Pds'.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "show \"x \\<in> Pds'.CD_on ds (?Z \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "proof(cases \"Xd x = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "case True"], ["proof (state)\nthis:\n  Xd x = d\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "from \\<open>allocation Y\\<close> III \\<open>d \\<in> ds''\\<close> \\<open>Xd x = d\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  Xd x = d", "have \"dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  Xd x = d\n\ngoal (1 subgoal):\n 1. Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))", "by clarsimp (metis AboveS_Pd_Xd AboveS_Field dX_range' inj_on_eq_iff)"], ["proof (state)\nthis:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "with \\<open>allocation Y\\<close> \\<open>d \\<notin> ds'\\<close>\n                          Pdds'.blocking_on_Field[OF \\<open>Pdds'.blocking_on ds ?Z h X''\\<close>, where d=d] \\<open>Xd x = d\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  d \\<notin> ds'\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top (insert d ds') Y d)\n  Xd x = d\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))", "have \"dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  d \\<notin> ds'\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top (insert d ds') Y d)\n  Xd x = d\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (1 subgoal):\n 1. Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))", "by (force simp: Pd_shuffle_to_top_simps shuffle_to_top_Field)"], ["proof (state)\nthis:\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "note \\<open>allocation Y\\<close> bspec[OF III[unfolded IH] \\<open>d \\<in> ds''\\<close>] \\<open>d \\<notin> ds'\\<close> \\<open>x \\<in> X''\\<close> \\<open>Xd x = d\\<close>\n                          Pds'.stable_on_allocation[OF Pds'.Theorem_1] Pbos"], ["proof (state)\nthis:\n  inj_on Xd Y\n  \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  d \\<notin> ds'\n  x \\<in> X''\n  Xd x = d\n  inj_on Xd (Pds'.cop ?ds)\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "ultimately"], ["proof (chain)\npicking this:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  inj_on Xd Y\n  \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  d \\<notin> ds'\n  x \\<in> X''\n  Xd x = d\n  inj_on Xd (Pds'.cop ?ds)\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')", "show ?thesis"], ["proof (prove)\nusing this:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  inj_on Xd Y\n  \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  d \\<notin> ds'\n  x \\<in> X''\n  Xd x = d\n  inj_on Xd (Pds'.cop ?ds)\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "by (clarsimp simp: Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_Above Pdds'.Cd_Above\n                                 Int_Un_distrib2 Pd_shuffle_to_top_Field)\n                 (clarsimp simp: Pd_shuffle_to_top_simps dX_singular dX_Int_Field_Pd;\n                  fastforce simp: Above_def AboveS_def Pd_refl shuffle_to_top_def dX_def intro: FieldI1 dest: Pd_range' iff: inj_on_eq_iff)"], ["proof (state)\nthis:\n  x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "case False"], ["proof (state)\nthis:\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "from Pbos \\<open>Xd x \\<noteq> d\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')\n  Xd x \\<noteq> d", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Xd X''\n  x \\<in> Pdds'.CD_on ds (Pds'.cop ds \\<union> X'')\n  Pdds'.dX X'' (Xd x) \\<subseteq> Pdds'.Cd (Xd x) (Pds'.cop ds \\<union> X'')\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')", "by (simp add: Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_greatest Pdds'.Cd_greatest)\n                 (simp add: Pd_shuffle_to_top_simps)"], ["proof (state)\nthis:\n  x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Pds'.CD_on ds (Pds'.cop ds \\<union> X'')\n\ngoal (2 subgoals):\n 1. X'' \\<noteq> Ch h (Pds'.cop ds)\n 2. X'' = Ch h (Pds'.cop ds \\<union> X'')", "qed (use \\<open>Pdds'.blocking_on ds ?Z h X''\\<close> in \\<open>simp_all add: Pdds'.blocking_on_def\\<close>)"], ["proof (state)\nthis:\n  Pds'.blocking_on ds (Pds'.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       Pdds'.blocking_on ds (Pds'.cop ds) h X'' \\<Longrightarrow> False", "with Pds'.Theorem_1[of ds]"], ["proof (chain)\npicking this:\n  Pds'.stable_on ds (Pds'.cop ds)\n  Pds'.blocking_on ds (Pds'.cop ds) h X''", "show False"], ["proof (prove)\nusing this:\n  Pds'.stable_on ds (Pds'.cop ds)\n  Pds'.blocking_on ds (Pds'.cop ds) h X''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Pds'.blocking_on_imp_not_stable)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pdds'.stable_no_blocking_on ds (Pds'.cop ds)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pdds'.stable_on ds (Pds'.cop ds)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "fix W w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "assume \"Pdds'.stable_on ds W\" \"w \\<in> W\""], ["proof (state)\nthis:\n  Pdds'.stable_on ds W\n  w \\<in> W\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "from III \\<open>d \\<in> ds''\\<close> IH"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  cop ds = Pds'.cop ds", "obtain y where Y: \"y \\<in> Y\" \"y \\<in> AboveS (Pd d) (dX (Pds'.cop ds) d)\" \"Xd y = d\""], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  cop ds = Pds'.cop ds\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> Y;\n         y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d); Xd y = d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis AboveS_Pd_Xd)"], ["proof (state)\nthis:\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Pdds'.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Pds'.cop ds.\n                            (x, y)\n                            \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd x)", "show \"\\<exists>z\\<in>Pds'.cop ds. (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "proof(cases \"y \\<in> W\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case True"], ["proof (state)\nthis:\n  y \\<in> W\n\ngoal (2 subgoals):\n 1. y \\<in> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "note \\<open>y \\<in> W\\<close>"], ["proof (state)\nthis:\n  y \\<in> W\n\ngoal (2 subgoals):\n 1. y \\<in> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "from \\<open>d \\<notin> ds'\\<close> \\<open>Pdds'.stable_on ds W\\<close> Y \\<open>y \\<in> W\\<close>"], ["proof (chain)\npicking this:\n  d \\<notin> ds'\n  Pdds'.stable_on ds W\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  y \\<in> W", "interpret Pdds': ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs\n                           Xd Xh \"Pd_shuffle_to_top (insert d ds') Y\" Ch y W ds \"Pd_shuffle_to_top ds' Y\""], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  Pdds'.stable_on ds W\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  y \\<in> W\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh\n     (Pd_shuffle_to_top (insert d ds') Y) Ch y W ds\n     (Pd_shuffle_to_top ds' Y)", "using %invisible Pds'.Pd_linear Pds'.Pd_range Pd_shuffle_to_top_simps Pd_range'"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  Pdds'.stable_on ds W\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  y \\<in> W\n  \\<forall>d. Linear_order (Pd_shuffle_to_top ds' Y d)\n  \\<forall>d. Field (Pd_shuffle_to_top ds' Y d) \\<subseteq> {x. Xd x = d}\n  Pd_shuffle_to_top (insert ?d ?ds') ?Y = (Pd_shuffle_to_top ?ds' ?Y)\n  (?d := shuffle_to_top ?Y ?d)\n  ?d \\<in> ?ds' \\<Longrightarrow>\n  Pd_shuffle_to_top ?ds' ?Y ?d = shuffle_to_top ?Y ?d\n  ?d \\<notin> ?ds' \\<Longrightarrow> Pd_shuffle_to_top ?ds' ?Y ?d = Pd ?d\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh\n     (Pd_shuffle_to_top (insert d ds') Y) Ch y W ds\n     (Pd_shuffle_to_top ds' Y)", "unfolding AboveS_def"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  Pdds'.stable_on ds W\n  y \\<in> Y\n  y \\<in> {b \\<in> Field (Pd d).\n           \\<forall>a\\<in>Pdds'.dX (Pds'.cop ds) d.\n              b \\<noteq> a \\<and> (a, b) \\<in> Pd d}\n  Xd y = d\n  y \\<in> W\n  \\<forall>d. Linear_order (Pd_shuffle_to_top ds' Y d)\n  \\<forall>d. Field (Pd_shuffle_to_top ds' Y d) \\<subseteq> {x. Xd x = d}\n  Pd_shuffle_to_top (insert ?d ?ds') ?Y = (Pd_shuffle_to_top ?ds' ?Y)\n  (?d := shuffle_to_top ?Y ?d)\n  ?d \\<in> ?ds' \\<Longrightarrow>\n  Pd_shuffle_to_top ?ds' ?Y ?d = shuffle_to_top ?Y ?d\n  ?d \\<notin> ?ds' \\<Longrightarrow> Pd_shuffle_to_top ?ds' ?Y ?d = Pd ?d\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLADAndTruePrefs Xd Xh\n     (Pd_shuffle_to_top (insert d ds') Y) Ch y W ds\n     (Pd_shuffle_to_top ds' Y)", "by unfold_locales auto"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "from \\<open>d \\<notin> ds'\\<close> Y Pdds'.Theorem_11_fp_cop_F"], ["proof (chain)\npicking this:\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  \\<exists>ya\\<in>Pds'.cop ds. (y, ya) \\<in> Pd_shuffle_to_top ds' Y (Xd y)", "have False"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  \\<exists>ya\\<in>Pds'.cop ds. (y, ya) \\<in> Pd_shuffle_to_top ds' Y (Xd y)\n\ngoal (1 subgoal):\n 1. False", "using Pds'.stable_on_allocation[OF Pds'.Theorem_1[of ds]] Pd_linear Pd_range'"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  \\<exists>ya\\<in>Pds'.cop ds. (y, ya) \\<in> Pd_shuffle_to_top ds' Y (Xd y)\n  inj_on Xd (Pds'.cop ds)\n  \\<forall>d. Linear_order (Pd d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. False", "unfolding order_on_defs antisym_def AboveS_def dX_def"], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> {b \\<in> Field (Pd d).\n           \\<forall>a\\<in>{x \\<in> Pds'.cop ds. Xd x = d}.\n              b \\<noteq> a \\<and> (a, b) \\<in> Pd d}\n  Xd y = d\n  \\<exists>ya\\<in>Pds'.cop ds. (y, ya) \\<in> Pd_shuffle_to_top ds' Y (Xd y)\n  inj_on Xd (Pds'.cop ds)\n  \\<forall>d.\n     ((Refl (Pd d) \\<and> trans (Pd d)) \\<and>\n      (\\<forall>x y.\n          (x, y) \\<in> Pd d \\<longrightarrow>\n          (y, x) \\<in> Pd d \\<longrightarrow> x = y)) \\<and>\n     Total (Pd d)\n  ?x \\<in> Field (Pd ?d) \\<Longrightarrow> Xd ?x = ?d\n\ngoal (1 subgoal):\n 1. False", "by (clarsimp simp: Pd_shuffle_to_top_simps) (blast dest: Pd_Xd)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. y \\<in> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", ".."], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal (1 subgoal):\n 1. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case False"], ["proof (state)\nthis:\n  y \\<notin> W\n\ngoal (1 subgoal):\n 1. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "note \\<open>y \\<notin> W\\<close>"], ["proof (state)\nthis:\n  y \\<notin> W\n\ngoal (1 subgoal):\n 1. y \\<notin> W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "proof (cases \"Pds'.stable_on ds W\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case True"], ["proof (state)\nthis:\n  Pds'.stable_on ds W\n\ngoal (2 subgoals):\n 1. Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "note \\<open>Pds'.stable_on ds W\\<close>"], ["proof (state)\nthis:\n  Pds'.stable_on ds W\n\ngoal (2 subgoals):\n 1. Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "with \\<open>allocation Y\\<close> \\<open>d \\<notin> ds'\\<close> Y \\<open>w \\<in> W\\<close> \\<open>y \\<notin> W\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  w \\<in> W\n  y \\<notin> W\n  Pds'.stable_on ds W", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  w \\<in> W\n  y \\<notin> W\n  Pds'.stable_on ds W\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "using Pds'.Theorem_5[OF \\<open>Pds'.stable_on ds W\\<close> \\<open>w \\<in> W\\<close>]"], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<in> Y\n  y \\<in> AboveS (Pd d) (Pdds'.dX (Pds'.cop ds) d)\n  Xd y = d\n  w \\<in> W\n  y \\<notin> W\n  Pds'.stable_on ds W\n  \\<exists>y\\<in>Pds'.cop ds. (w, y) \\<in> Pd_shuffle_to_top ds' Y (Xd w)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "by (auto 0 2 simp: Pd_shuffle_to_top_simps shuffle_to_top_def dX_def AboveS_def dest: Pd_range' inj_onD)"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case False"], ["proof (state)\nthis:\n  \\<not> Pds'.stable_on ds W\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "note \\<open>\\<not>Pds'.stable_on ds W\\<close>"], ["proof (state)\nthis:\n  \\<not> Pds'.stable_on ds W\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "then"], ["proof (chain)\npicking this:\n  \\<not> Pds'.stable_on ds W", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Pds'.stable_on ds W\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "proof(cases rule: Pds'.not_stable_on_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> Pds'.individually_rational_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case not_individually_rational"], ["proof (state)\nthis:\n  \\<not> Pds'.individually_rational_on ds W\n\ngoal (2 subgoals):\n 1. \\<not> Pds'.individually_rational_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "note Psos = Pdds'.stable_on_allocation[OF \\<open>Pdds'.stable_on ds W\\<close>]\n                        Pdds'.stable_on_CH[OF \\<open>Pdds'.stable_on ds W\\<close>]\n                        Pdds'.stable_on_Xd[OF \\<open>Pdds'.stable_on ds W\\<close>]"], ["proof (state)\nthis:\n  inj_on Xd W\n  Pdds'.CH W = W\n  ?x \\<in> W \\<Longrightarrow> Xd ?x \\<in> ds\n\ngoal (2 subgoals):\n 1. \\<not> Pds'.individually_rational_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "have \"x \\<in> Pds'.Cd (Xd x) W\" if \"x \\<in> W\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Pds'.Cd (Xd x) W", "proof(cases \"Xd x = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W\n 2. Xd x \\<noteq> d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W", "case True"], ["proof (state)\nthis:\n  Xd x = d\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W\n 2. Xd x \\<noteq> d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W", "with \\<open>allocation Y\\<close> \\<open>allocation W\\<close> Y(1,3) \\<open>y \\<notin> W\\<close>\n                   Pdds'.stable_on_range'[OF \\<open>Pdds'.stable_on ds W\\<close> \\<open>x \\<in> W\\<close>] \\<open>x \\<in> W\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  inj_on Xd W\n  y \\<in> Y\n  Xd y = d\n  y \\<notin> W\n  x \\<in> Field (Pd_shuffle_to_top (insert d ds') Y (Xd x))\n  x \\<in> W\n  Xd x = d", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  inj_on Xd W\n  y \\<in> Y\n  Xd y = d\n  y \\<notin> W\n  x \\<in> Field (Pd_shuffle_to_top (insert d ds') Y (Xd x))\n  x \\<in> W\n  Xd x = d\n\ngoal (1 subgoal):\n 1. x \\<in> Pds'.Cd (Xd x) W", "by (force simp: Pd_shuffle_to_top_Field dest: dX_range' inj_onD intro: Pds'.Cd_single)"], ["proof (state)\nthis:\n  x \\<in> Pds'.Cd (Xd x) W\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W", "case False"], ["proof (state)\nthis:\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow> x \\<in> Pds'.Cd (Xd x) W", "with \\<open>allocation Y\\<close> \\<open>allocation W\\<close> Pdds'.stable_on_range'[OF \\<open>Pdds'.stable_on ds W\\<close> \\<open>x \\<in> W\\<close>] \\<open>x \\<in> W\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  inj_on Xd W\n  x \\<in> Field (Pd_shuffle_to_top (insert d ds') Y (Xd x))\n  x \\<in> W\n  Xd x \\<noteq> d", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  inj_on Xd W\n  x \\<in> Field (Pd_shuffle_to_top (insert d ds') Y (Xd x))\n  x \\<in> W\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. x \\<in> Pds'.Cd (Xd x) W", "by (auto simp: Pd_shuffle_to_top_Field intro!: Pds'.Cd_single)"], ["proof (state)\nthis:\n  x \\<in> Pds'.Cd (Xd x) W\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> W \\<Longrightarrow> ?x \\<in> Pds'.Cd (Xd ?x) W\n\ngoal (2 subgoals):\n 1. \\<not> Pds'.individually_rational_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n 2. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "with not_individually_rational \\<open>Pdds'.CH W = W\\<close> Psos(3)"], ["proof (chain)\npicking this:\n  \\<not> Pds'.individually_rational_on ds W\n  Pdds'.CH W = W\n  ?x \\<in> W \\<Longrightarrow> Xd ?x \\<in> ds\n  ?x \\<in> W \\<Longrightarrow> ?x \\<in> Pds'.Cd (Xd ?x) W", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Pds'.individually_rational_on ds W\n  Pdds'.CH W = W\n  ?x \\<in> W \\<Longrightarrow> Xd ?x \\<in> ds\n  ?x \\<in> W \\<Longrightarrow> ?x \\<in> Pds'.Cd (Xd ?x) W\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "unfolding Pds'.individually_rational_on_def"], ["proof (prove)\nusing this:\n  \\<not> (Pds'.CD_on ds W = W \\<and> Pdds'.CH W = W)\n  Pdds'.CH W = W\n  ?x \\<in> W \\<Longrightarrow> Xd ?x \\<in> ds\n  ?x \\<in> W \\<Longrightarrow> ?x \\<in> Pds'.Cd (Xd ?x) W\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "by (auto simp: Pds'.mem_CD_on_Cd dest: Pds'.Cd_range')"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "case not_no_blocking"], ["proof (state)\nthis:\n  \\<not> Pds'.stable_no_blocking_on ds W\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "then"], ["proof (chain)\npicking this:\n  \\<not> Pds'.stable_no_blocking_on ds W", "obtain h X'' where Pbo: \"Pds'.blocking_on ds W h X''\""], ["proof (prove)\nusing this:\n  \\<not> Pds'.stable_no_blocking_on ds W\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        Pds'.blocking_on ds W h X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Pds'.stable_no_blocking_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>h X'. \\<not> Pds'.blocking_on ds W h X')\n\ngoal (1 subgoal):\n 1. (\\<And>h X''.\n        Pds'.blocking_on ds W h X'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Pds'.blocking_on ds W h X''\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "have \"Pdds'.blocking_on ds W h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pdds'.blocking_on ds W h X''", "proof(rule Pdds'.blocking_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h W\n 2. X'' = Ch h (W \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h W\n 2. X'' = Ch h (W \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "assume \"x \\<in> X''\""], ["proof (state)\nthis:\n  x \\<in> X''\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h W\n 2. X'' = Ch h (W \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "note Pbos = Pds'.blocking_on_allocation[OF \\<open>Pds'.blocking_on ds W h X''\\<close>]\n                        Pds'.blocking_on_CD_on'[OF \\<open>Pds'.blocking_on ds W h X''\\<close> \\<open>x \\<in> X''\\<close>]\n                        Pds'.blocking_on_Field[OF \\<open>Pds'.blocking_on ds W h X''\\<close>, where d=d]"], ["proof (state)\nthis:\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h W\n 2. X'' = Ch h (W \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "show \"x \\<in> Pdds'.CD_on ds (W \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "proof(cases \"Xd x = d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "case True"], ["proof (state)\nthis:\n  Xd x = d\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "from \\<open>allocation Y\\<close> III \\<open>d \\<in> ds''\\<close>  \\<open>Xd x = d\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd Y\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  Xd x = d", "have \"dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  inj_on Xd Y\n  \\<forall>d\\<in>ds''.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Pdds'.dX (cop ds) d)\n  d \\<in> ds''\n  Xd x = d\n\ngoal (1 subgoal):\n 1. Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))", "by clarsimp (metis AboveS_Pd_Xd AboveS_Field dX_range' inj_on_eq_iff)"], ["proof (state)\nthis:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "with \\<open>d \\<notin> ds'\\<close> \\<open>Xd x = d\\<close> Pbos"], ["proof (chain)\npicking this:\n  d \\<notin> ds'\n  Xd x = d\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))", "have \"dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\""], ["proof (prove)\nusing this:\n  d \\<notin> ds'\n  Xd x = d\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (1 subgoal):\n 1. Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))", "by (clarsimp simp: Pd_shuffle_to_top_simps)"], ["proof (state)\nthis:\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "note \\<open>allocation Y\\<close> \\<open>d \\<notin> ds'\\<close> \\<open>y \\<notin> W\\<close> \\<open>Xd y = d\\<close> \\<open>x \\<in> X''\\<close> Pbos"], ["proof (state)\nthis:\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<notin> W\n  Xd y = d\n  x \\<in> X''\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n\ngoal (2 subgoals):\n 1. Xd x = d \\<Longrightarrow> x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n 2. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "ultimately"], ["proof (chain)\npicking this:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<notin> W\n  Xd y = d\n  x \\<in> X''\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)", "show ?thesis"], ["proof (prove)\nusing this:\n  Pdds'.dX Y (Xd x) \\<subseteq> Field (Pd (Xd x))\n  Pdds'.dX X'' (Xd x) \\<subseteq> Field (Pd (Xd x))\n  inj_on Xd Y\n  d \\<notin> ds'\n  y \\<notin> W\n  Xd y = d\n  x \\<in> X''\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n\ngoal (1 subgoal):\n 1. x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "by (clarsimp simp: Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_Above Pdds'.Cd_Above\n                                   Int_Un_distrib2)\n                   (clarsimp simp: Pd_shuffle_to_top_simps shuffle_to_top_Field dX_singular dX_Int_Field_Pd Un_absorb2,\n                    force simp: \\<open>y \\<in> Y\\<close> shuffle_to_top_def dX_def Above_def dest: inj_onD intro: FieldI1)"], ["proof (state)\nthis:\n  x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "case False"], ["proof (state)\nthis:\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. Xd x \\<noteq> d \\<Longrightarrow>\n    x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "from Pbos \\<open>Xd x \\<noteq> d\\<close>"], ["proof (chain)\npicking this:\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n  Xd x \\<noteq> d", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Xd X''\n  x \\<in> Pds'.CD_on ds (W \\<union> X'')\n  Pdds'.dX X'' d \\<subseteq> Field (Pd_shuffle_to_top ds' Y d)\n  Xd x \\<noteq> d\n\ngoal (1 subgoal):\n 1. x \\<in> Pdds'.CD_on ds (W \\<union> X'')", "by (simp add: Pdds'.mem_CD_on_Cd Pds'.mem_CD_on_Cd Pds'.Cd_greatest Pdds'.Cd_greatest)\n                   (simp add: Pd_shuffle_to_top_simps)"], ["proof (state)\nthis:\n  x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Pdds'.CD_on ds (W \\<union> X'')\n\ngoal (2 subgoals):\n 1. X'' \\<noteq> Ch h W\n 2. X'' = Ch h (W \\<union> X'')", "qed (use \\<open>Pds'.blocking_on ds W h X''\\<close> in \\<open>simp_all add: Pds'.blocking_on_def\\<close>)"], ["proof (state)\nthis:\n  Pdds'.blocking_on ds W h X''\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "with \\<open>Pdds'.stable_on ds W\\<close>"], ["proof (chain)\npicking this:\n  Pdds'.stable_on ds W\n  Pdds'.blocking_on ds W h X''", "have False"], ["proof (prove)\nusing this:\n  Pdds'.stable_on ds W\n  Pdds'.blocking_on ds W h X''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: Pdds'.blocking_on_imp_not_stable)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> Pds'.stable_no_blocking_on ds W \\<Longrightarrow>\n    \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>Pds'.cop ds.\n       (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)", ".."], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<in>Pds'.cop ds.\n     (w, z) \\<in> Pd_shuffle_to_top (insert d ds') Y (Xd w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pds'.cop ds = Pdds'.cop ds\n\ngoal (1 subgoal):\n 1. \\<And>a F.\n       \\<lbrakk>finite F; a \\<in> ds''; F \\<subseteq> ds''; a \\<notin> F;\n        cop ds =\n        Pdds'.CH (Contracts.fp_cop_F (Pd_shuffle_to_top F Y) Ch ds)\\<rbrakk>\n       \\<Longrightarrow> cop ds =\n                         Pdds'.CH\n                          (Contracts.fp_cop_F\n                            (Pd_shuffle_to_top (insert a F) Y) Ch ds)", "from \\<open>?Z = CH (Pdds'.fp_cop_F ds)\\<close> IH"], ["proof (chain)\npicking this:\n  Pds'.cop ds = Pdds'.cop ds\n  cop ds = Pds'.cop ds", "show \"cop ds = Pdds'.cop ds\""], ["proof (prove)\nusing this:\n  Pds'.cop ds = Pdds'.cop ds\n  cop ds = Pds'.cop ds\n\ngoal (1 subgoal):\n 1. cop ds = Pdds'.cop ds", "by simp"], ["proof (state)\nthis:\n  cop ds = Pdds'.cop ds\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n\nThe top-level theorem states that the COP is group strategy proof. To\naccount for the quantification over preferences, we directly use the\nraw constants from the @{const \"Contracts\"} locale.\n\n\\<close>"], ["", "theorem fp_cop_F_group_strategy_proof:\n  shows \"group_strategy_proof ds Contracts.cop\"\n        (is \"group_strategy_proof _ ?\\<phi>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. group_strategy_proof ds\n     (\\<lambda>Pd Ch ds. Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))", "proof(rule group_strategy_proofI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "fix Pd Pds' Ch ds'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "assume XXX: \"mechanism_domain Pd Ch\" \"mechanism_domain (override_on Pd Pds' ds') Ch\"\n     and YYY: \"ds' \\<subseteq> ds\" \"ds' \\<noteq> {}\"\n     and ZZZ: \"\\<forall>d\\<in>ds'. \\<exists>y\\<in>?\\<phi> (override_on Pd Pds' ds') Ch ds. y \\<in> AboveS (Pd d) (dX (?\\<phi> Pd Ch ds) d)\""], ["proof (state)\nthis:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n   (override_on Pd Pds' ds') Ch\n  ds' \\<subseteq> ds\n  ds' \\<noteq> {}\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>Contracts.CH Ch\n                     (Contracts.fp_cop_F (override_on Pd Pds' ds') Ch ds).\n        y \\<in> AboveS (Pd d)\n                 (dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds)) d)\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (dX (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "from XXX(1)"], ["proof (chain)\npicking this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch", "interpret TruePref: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch"], ["proof (prove)\nusing this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (TruePref.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "from XXX(2)"], ["proof (chain)\npicking this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n   (override_on Pd Pds' ds') Ch", "interpret\n    ManiPref: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh \"override_on Pd Pds' ds'\" Ch"], ["proof (prove)\nusing this:\n  ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n   (override_on Pd Pds' ds') Ch\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (override_on Pd Pds' ds') Ch", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Y = \"ManiPref.cop ds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Z = \"TruePref.cop ds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Pd_shuffle_to_top = \"TruePref.Pd_shuffle_to_top ds' ?Y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "interpret ManiPref': ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh ?Pd_shuffle_to_top Ch"], ["proof (prove)\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds)) Ch", "using TruePref.Ch_unilateral_substitutes TruePref.Ch_irc TruePref.Ch_lad TruePref.Ch_range TruePref.Ch_singular\n          TruePref.Pd_shuffle_to_top_linear ManiPref.stable_on_allocation[OF ManiPref.Theorem_1[of ds]]\n          TruePref.Pd_shuffle_to_top_range ManiPref.dX_range"], ["proof (prove)\nusing this:\n  \\<forall>h. ManiPref.unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  inj_on Xd ?Y \\<Longrightarrow>\n  Linear_order (TruePref.Pd_shuffle_to_top ?ds' ?Y ?d)\n  inj_on Xd (ManiPref.cop ds)\n  Field (TruePref.Pd_shuffle_to_top ?ds' ?Y ?d) \\<subseteq> {x. Xd x = ?d}\n  \\<forall>d. ManiPref.dX ?X d \\<subseteq> {x. Xd x = d}\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds)) Ch", "by unfold_locales simp_all"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "let ?Y' = \"ManiPref'.cop ds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"ManiPref'.stable_on ds ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref'.stable_on ds (ManiPref.cop ds)", "proof(rule ManiPref'.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ManiPref'.individually_rational_on ds (ManiPref.cop ds)\n 2. ManiPref'.stable_no_blocking_on ds (ManiPref.cop ds)", "show \"ManiPref'.individually_rational_on ds ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref'.individually_rational_on ds (ManiPref.cop ds)", "proof(rule ManiPref'.individually_rational_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ManiPref'.CD_on ds (ManiPref.cop ds) = ManiPref.cop ds\n 2. ManiPref'.CH (ManiPref.cop ds) = ManiPref.cop ds", "show \"ManiPref'.CD_on ds ?Y = ?Y\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref'.CD_on ds (ManiPref.cop ds) = ManiPref.cop ds", "proof(rule set_elem_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds) \\<Longrightarrow>\n       x \\<in> ManiPref.cop ds\n 2. \\<And>x.\n       x \\<in> ManiPref.cop ds \\<Longrightarrow>\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds) \\<Longrightarrow>\n       x \\<in> ManiPref.cop ds\n 2. \\<And>x.\n       x \\<in> ManiPref.cop ds \\<Longrightarrow>\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)", "assume \"x \\<in> ?rhs\""], ["proof (state)\nthis:\n  x \\<in> ManiPref.cop ds\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds) \\<Longrightarrow>\n       x \\<in> ManiPref.cop ds\n 2. \\<And>x.\n       x \\<in> ManiPref.cop ds \\<Longrightarrow>\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)", "then"], ["proof (chain)\npicking this:\n  x \\<in> ManiPref.cop ds", "have \"Xd x \\<in> ds \\<and> (Xd x \\<notin> ds' \\<longrightarrow> x \\<in> Field (Pd (Xd x)))\""], ["proof (prove)\nusing this:\n  x \\<in> ManiPref.cop ds\n\ngoal (1 subgoal):\n 1. Xd x \\<in> ds \\<and>\n    (Xd x \\<notin> ds' \\<longrightarrow> x \\<in> Field (Pd (Xd x)))", "by (metis ManiPref.fp_cop_F_range_inv' TruePref.CH_range' override_on_apply_notin)"], ["proof (state)\nthis:\n  Xd x \\<in> ds \\<and>\n  (Xd x \\<notin> ds' \\<longrightarrow> x \\<in> Field (Pd (Xd x)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds) \\<Longrightarrow>\n       x \\<in> ManiPref.cop ds\n 2. \\<And>x.\n       x \\<in> ManiPref.cop ds \\<Longrightarrow>\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)", "with ManiPref.Theorem_1[of ds] \\<open>x \\<in> ?rhs\\<close>"], ["proof (chain)\npicking this:\n  ManiPref.stable_on ds (ManiPref.cop ds)\n  x \\<in> ManiPref.cop ds\n  Xd x \\<in> ds \\<and>\n  (Xd x \\<notin> ds' \\<longrightarrow> x \\<in> Field (Pd (Xd x)))", "show \"x \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  ManiPref.stable_on ds (ManiPref.cop ds)\n  x \\<in> ManiPref.cop ds\n  Xd x \\<in> ds \\<and>\n  (Xd x \\<notin> ds' \\<longrightarrow> x \\<in> Field (Pd (Xd x)))\n\ngoal (1 subgoal):\n 1. x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)", "by (fastforce dest: ManiPref.stable_on_allocation\n                    simp: ManiPref'.Cd_single ManiPref'.mem_CD_on_Cd TruePref.Pd_shuffle_to_top_Field dX_def)"], ["proof (state)\nthis:\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds) \\<Longrightarrow>\n       x \\<in> ManiPref.cop ds", "qed (meson IntE ManiPref'.CD_on_range')"], ["proof (state)\nthis:\n  ManiPref'.CD_on ds (ManiPref.cop ds) = ManiPref.cop ds\n\ngoal (1 subgoal):\n 1. ManiPref'.CH (ManiPref.cop ds) = ManiPref.cop ds", "show \"ManiPref'.CH ?Y = ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref'.CH (ManiPref.cop ds) = ManiPref.cop ds", "by (simp add: ManiPref'.CH_irc_idem)"], ["proof (state)\nthis:\n  ManiPref'.CH (ManiPref.cop ds) = ManiPref.cop ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ManiPref'.individually_rational_on ds (ManiPref.cop ds)\n\ngoal (1 subgoal):\n 1. ManiPref'.stable_no_blocking_on ds (ManiPref.cop ds)", "show \"ManiPref'.stable_no_blocking_on ds ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref'.stable_no_blocking_on ds (ManiPref.cop ds)", "proof(rule ManiPref'.stable_no_blocking_onI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       ManiPref'.blocking_on ds (ManiPref.cop ds) h X'' \\<Longrightarrow>\n       False", "fix h X''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       ManiPref'.blocking_on ds (ManiPref.cop ds) h X'' \\<Longrightarrow>\n       False", "assume \"ManiPref'.blocking_on ds ?Y h X''\""], ["proof (state)\nthis:\n  ManiPref'.blocking_on ds (ManiPref.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       ManiPref'.blocking_on ds (ManiPref.cop ds) h X'' \\<Longrightarrow>\n       False", "have \"ManiPref.blocking_on ds ?Y h X''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ManiPref.blocking_on ds (ManiPref.cop ds) h X''", "proof(rule ManiPref.blocking_onI)"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (ManiPref.cop ds)\n 2. X'' = Ch h (ManiPref.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (ManiPref.cop ds)\n 2. X'' = Ch h (ManiPref.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "assume \"x \\<in> X''\""], ["proof (state)\nthis:\n  x \\<in> X''\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (ManiPref.cop ds)\n 2. X'' = Ch h (ManiPref.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "note Pbos = ManiPref'.blocking_on_Field[OF \\<open>ManiPref'.blocking_on ds ?Y h X''\\<close>, where d=\"Xd x\"]\n                    ManiPref'.blocking_on_allocation[OF \\<open>ManiPref'.blocking_on ds ?Y h X''\\<close>]\n                    ManiPref'.blocking_on_CD_on'[OF \\<open>ManiPref'.blocking_on ds ?Y h X''\\<close> \\<open>x \\<in> X''\\<close>]\n                    ManiPref'.blocking_on_Cd[OF \\<open>ManiPref'.blocking_on ds ?Y h X''\\<close>, where d=\"Xd x\"]"], ["proof (state)\nthis:\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n\ngoal (3 subgoals):\n 1. X'' \\<noteq> Ch h (ManiPref.cop ds)\n 2. X'' = Ch h (ManiPref.cop ds \\<union> X'')\n 3. \\<And>x.\n       x \\<in> X'' \\<Longrightarrow>\n       x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "show \"x \\<in> ManiPref.CD_on ds (?Y \\<union> X'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "proof(cases \"Xd x \\<in> ds'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "case True"], ["proof (state)\nthis:\n  Xd x \\<in> ds'\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "from ManiPref.fp_cop_F_allocation[of ds] \\<open>x \\<in> X''\\<close> \\<open>Xd x \\<in> ds'\\<close> Pbos bspec[OF ZZZ \\<open>Xd x \\<in> ds'\\<close>]"], ["proof (chain)\npicking this:\n  inj_on Xd (ManiPref.cop ds)\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))", "have \"dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\""], ["proof (prove)\nusing this:\n  inj_on Xd (ManiPref.cop ds)\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))\n\ngoal (1 subgoal):\n 1. ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))", "by (clarsimp simp: dX_singular ManiPref'.mem_CD_on_Cd ManiPref'.Cd_Above TruePref.Pd_shuffle_to_top_Field)\n               (fastforce simp: TruePref.Pd_shuffle_to_top_simps dX_singular dest: TruePref.AboveS_Pd_Xd\n                          dest: ManiPref.fp_cop_F_range_inv' ManiPref.CH_range' TruePref.Above_shuffle_to_top)"], ["proof (state)\nthis:\n  ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "from ManiPref.stable_on_range'[OF ManiPref.Theorem_1] \\<open>Xd x \\<in> ds'\\<close>"], ["proof (chain)\npicking this:\n  ?x \\<in> ManiPref.cop ?ds \\<Longrightarrow>\n  ?x \\<in> Field (override_on Pd Pds' ds' (Xd ?x))\n  Xd x \\<in> ds'", "have \"dX ?Y (Xd x) \\<subseteq> Field (Pds' (Xd x))\""], ["proof (prove)\nusing this:\n  ?x \\<in> ManiPref.cop ?ds \\<Longrightarrow>\n  ?x \\<in> Field (override_on Pd Pds' ds' (Xd ?x))\n  Xd x \\<in> ds'\n\ngoal (1 subgoal):\n 1. ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))", "by (metis dX_range' override_on_apply_in subsetI)"], ["proof (state)\nthis:\n  ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "moreover"], ["proof (state)\nthis:\n  ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "note bspec[OF ZZZ \\<open>Xd x \\<in> ds'\\<close>] \\<open>x \\<in> X''\\<close> \\<open>Xd x \\<in> ds'\\<close> Pbos"], ["proof (state)\nthis:\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n\ngoal (2 subgoals):\n 1. Xd x \\<in> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n 2. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "ultimately"], ["proof (chain)\npicking this:\n  ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')", "show ?thesis"], ["proof (prove)\nusing this:\n  ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "using ManiPref.Pd_linear'[of \"Xd x\"] ManiPref.fp_cop_F_allocation[of ds]\n                  ManiPref'.fp_cop_F_allocation[of ds]"], ["proof (prove)\nusing this:\n  ManiPref'.dX X'' (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  ManiPref'.dX (ManiPref.cop ds) (Xd x) \\<subseteq> Field (Pds' (Xd x))\n  \\<exists>y\\<in>ManiPref.cop ds.\n     y \\<in> AboveS (Pd (Xd x)) (ManiPref'.dX (TruePref.cop ds) (Xd x))\n  x \\<in> X''\n  Xd x \\<in> ds'\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n  Linear_order (override_on Pd Pds' ds' (Xd x))\n  inj_on Xd (ManiPref.cop ds)\n  inj_on Xd (ManiPref'.cop ds)\n\ngoal (1 subgoal):\n 1. x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "by (clarsimp simp: ManiPref'.mem_CD_on_Cd ManiPref'.Cd_Above_dX ManiPref.mem_CD_on_Cd\n                               ManiPref.Cd_Above_dX dX_union dX_singular\n                               TruePref.Pd_shuffle_to_top_Field TruePref.AboveS_Pd_Xd)\n               (force simp: TruePref.Pd_shuffle_to_top_simps insert_absorb elim: Above_Linear_singleton\n                     dest!: TruePref.Above_shuffle_to_top)"], ["proof (state)\nthis:\n  x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "case False"], ["proof (state)\nthis:\n  Xd x \\<notin> ds'\n\ngoal (1 subgoal):\n 1. Xd x \\<notin> ds' \\<Longrightarrow>\n    x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "with Pbos"], ["proof (chain)\npicking this:\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n  Xd x \\<notin> ds'", "show ?thesis"], ["proof (prove)\nusing this:\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> Field\n               (TruePref.Pd_shuffle_to_top ds' (ManiPref.cop ds) (Xd x))\n  inj_on Xd X''\n  x \\<in> ManiPref'.CD_on ds (ManiPref.cop ds \\<union> X'')\n  ManiPref'.dX X'' (Xd x)\n  \\<subseteq> ManiPref'.Cd (Xd x) (ManiPref.cop ds \\<union> X'')\n  Xd x \\<notin> ds'\n\ngoal (1 subgoal):\n 1. x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')", "by (fastforce simp: ManiPref'.mem_CD_on_Cd ManiPref'.Cd_greatest ManiPref.mem_CD_on_Cd\n                                ManiPref.Cd_greatest TruePref.Pd_shuffle_to_top_simps)"], ["proof (state)\nthis:\n  x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> ManiPref.CD_on ds (ManiPref.cop ds \\<union> X'')\n\ngoal (2 subgoals):\n 1. X'' \\<noteq> Ch h (ManiPref.cop ds)\n 2. X'' = Ch h (ManiPref.cop ds \\<union> X'')", "qed (use \\<open>ManiPref'.blocking_on ds ?Y h X''\\<close> in \\<open>simp_all add: ManiPref'.blocking_on_def\\<close>)"], ["proof (state)\nthis:\n  ManiPref.blocking_on ds (ManiPref.cop ds) h X''\n\ngoal (1 subgoal):\n 1. \\<And>h X''.\n       ManiPref'.blocking_on ds (ManiPref.cop ds) h X'' \\<Longrightarrow>\n       False", "with ManiPref.Theorem_1[of ds]"], ["proof (chain)\npicking this:\n  ManiPref.stable_on ds (ManiPref.cop ds)\n  ManiPref.blocking_on ds (ManiPref.cop ds) h X''", "show False"], ["proof (prove)\nusing this:\n  ManiPref.stable_on ds (ManiPref.cop ds)\n  ManiPref.blocking_on ds (ManiPref.cop ds) h X''\n\ngoal (1 subgoal):\n 1. False", "by (simp add: ManiPref.blocking_on_imp_not_stable)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ManiPref'.stable_no_blocking_on ds (ManiPref.cop ds)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ManiPref'.stable_on ds (ManiPref.cop ds)\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "with ManiPref'.stable_on_allocation"], ["proof (chain)\npicking this:\n  ManiPref'.stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  ManiPref'.stable_on ds (ManiPref.cop ds)", "have \"{x \\<in> ?Y. Xd x \\<in> ds'} \\<subseteq> {x \\<in> ?Y'. Xd x \\<in> ds'}\""], ["proof (prove)\nusing this:\n  ManiPref'.stable_on ?ds ?X \\<Longrightarrow> inj_on Xd ?X\n  ManiPref'.stable_on ds (ManiPref.cop ds)\n\ngoal (1 subgoal):\n 1. {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n    \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}", "by (force dest: ManiPref'.Theorem_5[of ds]\n              simp: TruePref.Pd_shuffle_to_top_simps TruePref.shuffle_to_top_def dX_def dest: inj_onD)"], ["proof (state)\nthis:\n  {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n  \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n  \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "from ManiPref.stable_on_allocation[OF ManiPref.Theorem_1] ZZZ"], ["proof (chain)\npicking this:\n  inj_on Xd (ManiPref.cop ?ds)\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> AboveS (Pd d) (ManiPref'.dX (TruePref.cop ds) d)", "have \"?Z = ?Y'\""], ["proof (prove)\nusing this:\n  inj_on Xd (ManiPref.cop ?ds)\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> AboveS (Pd d) (ManiPref'.dX (TruePref.cop ds) d)\n\ngoal (1 subgoal):\n 1. TruePref.cop ds = ManiPref'.cop ds", "by (rule TruePref.Lemma_1)"], ["proof (state)\nthis:\n  TruePref.cop ds = ManiPref'.cop ds\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  TruePref.cop ds = ManiPref'.cop ds\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "note YYY ZZZ"], ["proof (state)\nthis:\n  ds' \\<subseteq> ds\n  ds' \\<noteq> {}\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> AboveS (Pd d) (ManiPref'.dX (TruePref.cop ds) d)\n\ngoal (1 subgoal):\n 1. \\<And>Pd Pd' Ch ds'.\n       \\<lbrakk>ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh Pd Ch;\n        ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n         (override_on Pd Pd' ds') Ch;\n        ds' \\<subseteq> ds; ds' \\<noteq> {};\n        \\<forall>d\\<in>ds'.\n           \\<exists>y\\<in>Contracts.CH Ch\n                           (Contracts.fp_cop_F (override_on Pd Pd' ds') Ch\n                             ds).\n              y \\<in> AboveS (Pd d)\n                       (ManiPref'.dX\n                         (Contracts.CH Ch (Contracts.fp_cop_F Pd Ch ds))\n                         d)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n  \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}\n  TruePref.cop ds = ManiPref'.cop ds\n  ds' \\<subseteq> ds\n  ds' \\<noteq> {}\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> AboveS (Pd d) (ManiPref'.dX (TruePref.cop ds) d)", "show False"], ["proof (prove)\nusing this:\n  {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n  \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}\n  TruePref.cop ds = ManiPref'.cop ds\n  ds' \\<subseteq> ds\n  ds' \\<noteq> {}\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> AboveS (Pd d) (ManiPref'.dX (TruePref.cop ds) d)\n\ngoal (1 subgoal):\n 1. False", "unfolding AboveS_def dX_def"], ["proof (prove)\nusing this:\n  {x \\<in> ManiPref.cop ds. Xd x \\<in> ds'}\n  \\<subseteq> {x \\<in> ManiPref'.cop ds. Xd x \\<in> ds'}\n  TruePref.cop ds = ManiPref'.cop ds\n  ds' \\<subseteq> ds\n  ds' \\<noteq> {}\n  \\<forall>d\\<in>ds'.\n     \\<exists>y\\<in>ManiPref.cop ds.\n        y \\<in> {b \\<in> Field (Pd d).\n                 \\<forall>a\\<in>{x \\<in> TruePref.cop ds. Xd x = d}.\n                    b \\<noteq> a \\<and> (a, b) \\<in> Pd d}\n\ngoal (1 subgoal):\n 1. False", "by (fastforce simp: ex_in_conv[symmetric] dest: TruePref.Pd_range')"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text (in ContractsWithSubstitutes) \\<open>\n\nAgain, this result does not directly apply to @{term \"gfp_F\"} due to\nthe mechanism domain hypothesis.\n\nFinally, \\citet[Corollary~2]{HatfieldKojima:2010} (respectively,\n\\citet[Corollary~1]{HatfieldKojima:2009}) assert that the COP (@{const\n\"gfp_F\"}) is ``weakly Pareto optimal'', i.e., that there is no @{const\n\"individually_rational\"} allocation that every doctor strictly prefers\nto the doctor-optimal match.\n\n\\<close>"], ["", "context ContractsWithUnilateralSubstitutesAndIRCAndLAD\nbegin"], ["", "theorem Corollary_2:\n  assumes \"ds \\<noteq> {}\"\n  shows \"\\<not>(\\<exists>Y. individually_rational_on ds Y\n        \\<and> (\\<forall>d\\<in>ds. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>Y.\n       individually_rational_on ds Y \\<and>\n       (\\<forall>d\\<in>ds.\n           \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d))", "proof(unfold individually_rational_on_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d);\n        CD_on ds Y = Y; CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d);\n        CD_on ds Y = Y; CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"CD_on ds Y = Y\" \"CH Y = Y\"\n           and Z: \"\\<forall>d\\<in>ds. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)\""], ["proof (state)\nthis:\n  CD_on ds Y = Y\n  CH Y = Y\n  \\<forall>d\\<in>ds. \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d);\n        CD_on ds Y = Y; CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CD_on ds Y = Y\\<close>"], ["proof (chain)\npicking this:\n  CD_on ds Y = Y", "have \"allocation Y\""], ["proof (prove)\nusing this:\n  CD_on ds Y = Y\n\ngoal (1 subgoal):\n 1. inj_on Xd Y", "by (metis CD_on_inj_on_Xd)"], ["proof (state)\nthis:\n  inj_on Xd Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (dX (cop ds) d);\n        CD_on ds Y = Y; CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>CD_on ds Y = Y\\<close>"], ["proof (chain)\npicking this:\n  CD_on ds Y = Y", "interpret Y: ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh \"Pd_singletons_for_ds Y ds\" Ch"], ["proof (prove)\nusing this:\n  CD_on ds Y = Y\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_singletons_for_ds Y ds) Ch", "using Ch_unilateral_substitutes Ch_irc Ch_lad Ch_range Ch_singular Pd_singletons_for_ds_range\n          Pd_singletons_for_ds_linear[OF CD_on_inj_on_Xd]"], ["proof (prove)\nusing this:\n  CD_on ds Y = Y\n  \\<forall>h. unilateral_substitutes_on UNIV (Ch h)\n  \\<forall>h. irc (Ch h)\n  \\<forall>h. lad (Ch h)\n  \\<forall>h X. Ch h X \\<subseteq> {x \\<in> X. Xh x = h}\n  \\<forall>h X. inj_on Xd (Ch h X)\n  Field (Pd_singletons_for_ds ?X ?ds ?d) \\<subseteq> {x. Xd x = ?d}\n  Linear_order (Pd_singletons_for_ds (CD_on ?ds1 ?X1) ?ds ?d)\n\ngoal (1 subgoal):\n 1. ContractsWithUnilateralSubstitutesAndIRCAndLAD Xd Xh\n     (Pd_singletons_for_ds Y ds) Ch", "by unfold_locales (simp_all, metis)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y.\n                      y \\<in> AboveS (Pd d) (Y.dX (cop ds) d);\n        CD_on ds Y = Y; Y.CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "from Y.fp_cop_F_doctor_optimal_match Y.doctor_optimal_matchI"], ["proof (chain)\npicking this:\n  Y.doctor_optimal_match ?ds (Y.cop ?ds)\n  \\<lbrakk>Y.stable_on ?ds ?Y;\n   \\<And>X x.\n      \\<lbrakk>x \\<in> X; Y.stable_on ?ds X\\<rbrakk>\n      \\<Longrightarrow> \\<exists>y\\<in>?Y.\n                           (x, y)\n                           \\<in> Pd_singletons_for_ds Y ds (Xd x)\\<rbrakk>\n  \\<Longrightarrow> Y.doctor_optimal_match ?ds ?Y", "have \"CH (Y.fp_cop_F ds) = Y\""], ["proof (prove)\nusing this:\n  Y.doctor_optimal_match ?ds (Y.cop ?ds)\n  \\<lbrakk>Y.stable_on ?ds ?Y;\n   \\<And>X x.\n      \\<lbrakk>x \\<in> X; Y.stable_on ?ds X\\<rbrakk>\n      \\<Longrightarrow> \\<exists>y\\<in>?Y.\n                           (x, y)\n                           \\<in> Pd_singletons_for_ds Y ds (Xd x)\\<rbrakk>\n  \\<Longrightarrow> Y.doctor_optimal_match ?ds ?Y\n\ngoal (1 subgoal):\n 1. Y.cop ds = Y", "proof(rule Y.doctor_optimal_match_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. Y.stable_on ds Y\n 2. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Y.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Y.\n                            (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "show \"Y.stable_on ds Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y.stable_on ds Y", "proof(rule Y.stable_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Y.individually_rational_on ds Y\n 2. Y.stable_no_blocking_on ds Y", "show \"Y.individually_rational_on ds Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y.individually_rational_on ds Y", "proof(rule Y.individually_rational_onI)"], ["proof (state)\ngoal (2 subgoals):\n 1. Y.CD_on ds Y = Y\n 2. Y.CH Y = Y", "from \\<open>CD_on ds Y = Y\\<close> CD_on_Xd[where A=Y and ds=ds]"], ["proof (chain)\npicking this:\n  CD_on ds Y = Y\n  ?x \\<in> CD_on ds Y \\<Longrightarrow> Xd ?x \\<in> ds", "show \"Y.CD_on ds Y = Y\""], ["proof (prove)\nusing this:\n  CD_on ds Y = Y\n  ?x \\<in> CD_on ds Y \\<Longrightarrow> Xd ?x \\<in> ds\n\ngoal (1 subgoal):\n 1. Y.CD_on ds Y = Y", "unfolding Y.CD_on_def CD_on_def"], ["proof (prove)\nusing this:\n  (\\<Union>d\\<in>ds. Cd d Y) = Y\n  ?x \\<in> (\\<Union>d\\<in>ds. Cd d Y) \\<Longrightarrow> Xd ?x \\<in> ds\n\ngoal (1 subgoal):\n 1. (\\<Union>d\\<in>ds. Y.Cd d Y) = Y", "by (force simp: Y.Cd_greatest Cd_greatest greatest_def Pd_singletons_for_ds_simps dX_def)"], ["proof (state)\nthis:\n  Y.CD_on ds Y = Y\n\ngoal (1 subgoal):\n 1. Y.CH Y = Y", "from \\<open>CH Y = Y\\<close>"], ["proof (chain)\npicking this:\n  Y.CH Y = Y", "show \"Y.CH Y = Y\""], ["proof (prove)\nusing this:\n  Y.CH Y = Y\n\ngoal (1 subgoal):\n 1. Y.CH Y = Y", "."], ["proof (state)\nthis:\n  Y.CH Y = Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Y.individually_rational_on ds Y\n\ngoal (1 subgoal):\n 1. Y.stable_no_blocking_on ds Y", "show \"Y.stable_no_blocking_on ds Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y.stable_no_blocking_on ds Y", "by (rule Y.stable_no_blocking_onI,\n            drule subset_trans[OF _ Y.CD_on_range],\n            clarsimp simp: Pd_singletons_for_ds_def dX_def Un_absorb1 subset_eq sup_commute)"], ["proof (state)\nthis:\n  Y.stable_no_blocking_on ds Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Y.stable_on ds Y\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Y.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Y.\n                            (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Y.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Y.\n                            (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "fix x X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Y.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Y.\n                            (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "assume \"x \\<in> X\" \"Y.stable_on ds X\""], ["proof (state)\nthis:\n  x \\<in> X\n  Y.stable_on ds X\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> X; Y.stable_on ds X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>Y.\n                            (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "with Y.Theorem_5[of ds X x] Pd_singletons_for_ds_linear[OF \\<open>allocation Y\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Y.stable_on ds X; x \\<in> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>Y.cop ds.\n                       (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)\n  Linear_order (Pd_singletons_for_ds Y ?ds ?d)\n  x \\<in> X\n  Y.stable_on ds X", "show \"\\<exists>y\\<in>Y. (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Y.stable_on ds X; x \\<in> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>Y.cop ds.\n                       (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)\n  Linear_order (Pd_singletons_for_ds Y ?ds ?d)\n  x \\<in> X\n  Y.stable_on ds X\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>Y. (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)", "by (fastforce simp: Pd_singletons_for_ds_simps Y.stable_on_Xd dX_def)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>Y. (x, y) \\<in> Pd_singletons_for_ds Y ds (Xd x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Y.cop ds = Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>d\\<in>ds.\n                   \\<exists>y\\<in>Y.\n                      y \\<in> AboveS (Pd d) (Y.dX (cop ds) d);\n        CD_on ds Y = Y; Y.CH Y = Y\\<rbrakk>\n       \\<Longrightarrow> False", "from Z \\<open>CH (Y.fp_cop_F ds) = Y\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>d\\<in>ds.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Y.dX (cop ds) d)\n  Y.cop ds = Y", "show False"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>ds.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Y.dX (cop ds) d)\n  Y.cop ds = Y\n\ngoal (1 subgoal):\n 1. False", "using group_strategy_proofD[OF\n      fp_cop_F_group_strategy_proof\n      ContractsWithUnilateralSubstitutesAndIRCAndLAD_axioms subset_refl\n      \\<open>ds \\<noteq> {}\\<close>\n      Y.ContractsWithUnilateralSubstitutesAndIRCAndLAD_axioms[unfolded Pd_singletons_for_ds_def]]"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>ds.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Y.dX (cop ds) d)\n  Y.cop ds = Y\n  \\<exists>d\\<in>ds.\n     \\<forall>y\\<in>Y.CH\n                     (Contracts.fp_cop_F\n                       (override_on Pd\n                         (\\<lambda>d. Y.dX Y d \\<times> Y.dX Y d) ds)\n                       Ch ds).\n        y \\<notin> AboveS (Pd d) (Y.dX (cop ds) d)\n\ngoal (1 subgoal):\n 1. False", "unfolding Pd_singletons_for_ds_def"], ["proof (prove)\nusing this:\n  \\<forall>d\\<in>ds.\n     \\<exists>y\\<in>Y. y \\<in> AboveS (Pd d) (Y.dX (cop ds) d)\n  Y.CH\n   (Contracts.fp_cop_F\n     (override_on Pd (\\<lambda>d. Y.dX Y d \\<times> Y.dX Y d) ds) Ch ds) =\n  Y\n  \\<exists>d\\<in>ds.\n     \\<forall>y\\<in>Y.CH\n                     (Contracts.fp_cop_F\n                       (override_on Pd\n                         (\\<lambda>d. Y.dX Y d \\<times> Y.dX Y d) ds)\n                       Ch ds).\n        y \\<notin> AboveS (Pd d) (Y.dX (cop ds) d)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n\n\\citet[\\S4.4]{RothSotomayor:1990} discuss how the non-proposing agents\ncan strategise to improve their outcomes in one-to-one matches.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}