{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Order_Lattice_Props.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma ord_embed_alt: \"ord_embed f = (mono f \\<and> (\\<forall>x y. f x \\<le> f y \\<longrightarrow> x \\<le> y))\"", "lemma ord_embed_homset: \"ord_embed f \\<Longrightarrow> f \\<in> ord_homset\"", "lemma ord_embed_inj: \"ord_embed f \\<Longrightarrow> inj f\"", "lemma ord_iso_ord_embed: \"ord_iso f \\<Longrightarrow> ord_embed f\"", "lemma ord_iso_alt: \"ord_iso f = (ord_embed f \\<and> surj f)\"", "lemma ord_iso_the_inv: \"ord_iso f \\<Longrightarrow> mono (the_inv f)\"", "lemma ord_iso_inv1: \"ord_iso f \\<Longrightarrow> (the_inv f) \\<circ> f = id\"", "lemma ord_iso_inv2: \"ord_iso f \\<Longrightarrow> f \\<circ> (the_inv f) = id\"", "lemma retraction_prop: \"f \\<circ> f = f \\<Longrightarrow> f x = x \\<longleftrightarrow> x \\<in> range f\"", "lemma retraction_prop_fix: \"f \\<circ> f = f \\<Longrightarrow> range f = Fix f\"", "lemma Fix_map_dual: \"Fix \\<circ> \\<partial>\\<^sub>F = (`) \\<partial> \\<circ> Fix\"", "lemma Fix_map_dual_var: \"Fix (\\<partial>\\<^sub>F f) = \\<partial> ` (Fix f)\"", "lemma gfp_dual: \"(\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F\"", "lemma gfp_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"\\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)\"", "lemma gfp_to_lfp: \"gfp = (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> lfp \\<circ> \\<partial>\\<^sub>F\"", "lemma gfp_to_lfp_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"gfp f = \\<partial> (lfp (\\<partial>\\<^sub>F f))\"", "lemma lfp_dual: \"(\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> lfp = gfp \\<circ> \\<partial>\\<^sub>F\"", "lemma lfp_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"\\<partial> (lfp f) = gfp (map_dual f)\"", "lemma lfp_to_gfp: \"lfp = (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> gfp \\<circ> \\<partial>\\<^sub>F\"", "lemma lfp_to_gfp_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"lfp f = \\<partial> (gfp (\\<partial>\\<^sub>F f))\"", "lemma lfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> lfp f \\<in> Fix f\"", "lemma gfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> gfp f \\<in> Fix f\"", "lemma nonempty_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> Fix f \\<noteq> {}\"", "lemma min_max_set_dual: \"(`) \\<partial> \\<circ> min_set = max_set \\<circ> (`) \\<partial>\"", "lemma min_max_set_dual_var: \"\\<partial> ` (min_set X) = max_set (\\<partial> ` X)\"", "lemma max_min_set_dual: \"(`) \\<partial> \\<circ> max_set = min_set \\<circ> (`) \\<partial>\"", "lemma min_to_max_set: \"min_set = (`) \\<partial> \\<circ> max_set \\<circ> (`) \\<partial>\"", "lemma max_min_set_dual_var: \"\\<partial> ` (max_set X) = min_set (\\<partial> ` X)\"", "lemma min_to_max_set_var: \"min_set X = \\<partial> ` (max_set (\\<partial> ` X))\"", "lemma filtered_directed_dual: \"filtered \\<circ> (`) \\<partial> = directed\"", "lemma directed_filtered_dual: \"directed \\<circ> (`) \\<partial> = filtered\"", "lemma filtered_to_directed: \"filtered X = directed (\\<partial> ` X)\"", "lemma downset_set_upset_set_dual: \"(`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\"", "lemma upset_set_downset_set_dual: \"(`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>\"", "lemma upset_set_to_downset_set: \"\\<Up> = (`) \\<partial> \\<circ> \\<Down> \\<circ> (`) \\<partial>\"", "lemma upset_set_to_downset_set2: \"\\<Up> X = \\<partial> ` (\\<Down> (\\<partial> ` X))\"", "lemma downset_upset_dual: \"(`) \\<partial> \\<circ> \\<down> = \\<up> \\<circ> \\<partial>\"", "lemma upset_to_downset: \"(`) \\<partial> \\<circ> \\<up> = \\<down> \\<circ> \\<partial>\"", "lemma upset_to_downset2: \"\\<up> = (`) \\<partial> \\<circ> \\<down> \\<circ> \\<partial>\"", "lemma upset_to_downset3: \"\\<up> x = \\<partial> ` (\\<down> (\\<partial> x))\"", "lemma downsets_upsets_dual: \"(X \\<in> downsets) = (\\<partial> ` X \\<in> upsets)\"", "lemma downset_setp_upset_setp_dual: \"upclosed_set \\<circ> (`) \\<partial> = downclosed_set\"", "lemma upsets_to_downsets: \"(X \\<in> upsets) = (\\<partial> ` X \\<in> downsets)\"", "lemma upset_setp_downset_setp_dual: \"downclosed_set \\<circ> (`) \\<partial> = upclosed_set\"", "lemma ideals_filters_dual: \"(X \\<in> ideals) = ((\\<partial> ` X) \\<in> filters)\"", "lemma idealp_filterp_dual: \"idealp = filterp \\<circ> (`) \\<partial>\"", "lemma filters_to_ideals: \"(X \\<in> filters) = ((\\<partial> ` X) \\<in> ideals)\"", "lemma filterp_idealp_dual: \"filterp = idealp \\<circ> (`) \\<partial>\"", "lemma directed_nonempty: \"directed X \\<Longrightarrow> X \\<noteq> {}\"", "lemma directed_ub: \"directed X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z)\"", "lemma downset_set_prop: \"\\<Down> = Union \\<circ> (`) \\<down>\"", "lemma downset_set_prop_var: \"\\<Down>X = (\\<Union>x \\<in> X. \\<down>x)\"", "lemma downset_prop: \"\\<down>x = {y. y \\<le> x}\"", "lemma downset_prop2: \"y \\<le> x \\<Longrightarrow> y \\<in> \\<down>x\"", "lemma ideals_downsets: \"X \\<in> ideals \\<Longrightarrow> X \\<in> downsets\"", "lemma ideals_directed: \"X \\<in> ideals \\<Longrightarrow> directed X\"", "lemma directed_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow> directed X\"", "lemma directed_alt: \"directed X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z))\"", "lemma downset_set_prop_var2: \"x \\<in> \\<Down>X \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<in> \\<Down>X\"", "lemma downclosed_set_iff: \"downclosed_set X = (\\<forall>x \\<in> X. \\<forall>y. y \\<le> x \\<longrightarrow> y \\<in> X)\"", "lemma downclosed_downset_set: \"downclosed_set (\\<Down>X)\"", "lemma downclosed_downset: \"downclosed_set (\\<down>x)\"", "lemma downset_set_ext: \"id \\<le> \\<Down>\"", "lemma downset_set_iso: \"mono \\<Down>\"", "lemma downset_set_idem [simp]: \"\\<Down> \\<circ> \\<Down> = \\<Down>\"", "lemma downset_faithful: \"\\<down>x \\<subseteq> \\<down>y \\<Longrightarrow> x \\<le> y\"", "lemma downset_iso_iff: \"(\\<down>x \\<subseteq> \\<down>y) = (x \\<le> y)\"", "lemma downset_directed_downset_var [simp]: \"directed (\\<Down>X) = directed X\"", "lemma downset_directed_downset [simp]: \"directed \\<circ> \\<Down> = directed\"", "lemma directed_downset_ideals: \"directed (\\<Down>X) = (\\<Down>X \\<in> ideals)\"", "lemma downclosed_Fix: \"downclosed_set X = (\\<Down>X = X)\"", "lemma downset_iso: \"mono (\\<down>::'a::order \\<Rightarrow> 'a set)\"", "lemma mono_downclosed: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y)\"", "lemma\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. downclosed_set X \\<longrightarrow> downclosed_set (f ` X)\"", "lemma downclosed_mono:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y)\"\n  shows \"mono f\"", "lemma mono_downclosed_iff: \"mono f = (\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y))\"", "lemma downset_inj: \"inj \\<down>\"", "lemma \"(X \\<subseteq> Y) = (\\<Down>X \\<subseteq> \\<Down>Y)\"", "lemma lat_ideals: \"X \\<in> ideals = (X \\<noteq> {} \\<and> X \\<in> downsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<squnion> y \\<in> X))\"", "lemma bot_ideal: \"X \\<in> ideals \\<Longrightarrow> \\<bottom> \\<in> X\"", "lemma Sup_downset_id [simp]: \"Sup \\<circ> \\<down> = id\"", "lemma downset_Sup_id: \"id \\<le> \\<down> \\<circ> Sup\"", "lemma Inf_Sup_var: \"\\<Squnion>(\\<Inter>x \\<in> X. \\<down>x) = \\<Sqinter>X\"", "lemma Inf_pres_downset_var: \"(\\<Inter>x \\<in> X. \\<down>x) = \\<down>(\\<Sqinter>X)\"", "lemma filtered_nonempty: \"filtered X \\<Longrightarrow> X \\<noteq> {}\"", "lemma filtered_lb: \"filtered X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y)\"", "lemma upset_set_prop_var: \"\\<Up>X = (\\<Union>x \\<in> X. \\<up>x)\"", "lemma upset_set_prop: \"\\<Up> = Union \\<circ> (`) \\<up>\"", "lemma upset_prop: \"\\<up>x = {y. x \\<le> y}\"", "lemma upset_prop2: \"x \\<le> y \\<Longrightarrow> y \\<in> \\<up>x\"", "lemma filters_upsets: \"X \\<in> filters \\<Longrightarrow> X \\<in> upsets\"", "lemma filters_filtered: \"X \\<in> filters \\<Longrightarrow> filtered X\"", "lemma filtered_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y) \\<Longrightarrow> filtered X\"", "lemma filtered_alt: \"filtered X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y))\"", "lemma up_set_prop_var2: \"x \\<in> \\<Up>X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> y \\<in> \\<Up>X\"", "lemma upclosed_set_iff: \"upclosed_set X = (\\<forall>x \\<in> X. \\<forall>y. x \\<le> y \\<longrightarrow> y \\<in> X)\"", "lemma upclosed_upset_set: \"upclosed_set (\\<Up>X)\"", "lemma upclosed_upset: \"upclosed_set (\\<up>x)\"", "lemma upset_set_ext: \"id \\<le> \\<Up>\"", "lemma upset_set_anti: \"mono \\<Up>\"", "lemma up_set_idem [simp]: \"\\<Up> \\<circ> \\<Up> = \\<Up>\"", "lemma upset_faithful: \"\\<up>x \\<subseteq> \\<up>y \\<Longrightarrow> y \\<le> x\"", "lemma upset_anti_iff: \"(\\<up>y \\<subseteq> \\<up>x) = (x \\<le> y)\"", "lemma upset_filtered_upset [simp]: \"filtered \\<circ> \\<Up> = filtered\"", "lemma filtered_upset_filters: \"filtered (\\<Up>X) = (\\<Up>X \\<in> filters)\"", "lemma upclosed_Fix: \"upclosed_set X = (\\<Up>X = X)\"", "lemma upset_anti: \"antimono (\\<up>::'a::order_with_dual \\<Rightarrow> 'a set)\"", "lemma mono_upclosed: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y)\"", "lemma mono_upclosed: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. upclosed_set X \\<longrightarrow> upclosed_set (f ` X)\"", "lemma upclosed_mono:\n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y)\"\n  shows \"mono f\"", "lemma mono_upclosed_iff: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  shows \"mono f = (\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y))\"", "lemma upset_inj: \"inj \\<up>\"", "lemma \"(X \\<subseteq> Y) = (\\<Up>Y \\<subseteq> \\<Up>X)\"", "lemma lat_filters: \"X \\<in> filters = (X \\<noteq> {} \\<and> X \\<in> upsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<sqinter> y \\<in> X))\"", "lemma top_filter: \"X \\<in> filters \\<Longrightarrow> \\<top> \\<in> X\"", "lemma Inf_upset_id [simp]: \"Inf \\<circ> \\<up> = id\"", "lemma upset_Inf_id: \"id \\<le> \\<up> \\<circ> Inf\"", "lemma Sup_Inf_var: \" \\<Sqinter>(\\<Inter>x \\<in> X. \\<up>x) = \\<Squnion>X\"", "lemma Sup_dual_upset_var: \"(\\<Inter>x \\<in> X. \\<up>x) = \\<up>(\\<Squnion>X)\"", "lemma shunt1: \"(x \\<sqinter> y \\<le> z) = (x \\<le> -y \\<squnion> z)\"", "lemma shunt2: \"(x \\<sqinter> -y \\<le> z) = (x \\<le> y \\<squnion> z)\"", "lemma meet_shunt: \"(x \\<sqinter> y = \\<bottom>) = (x \\<le> -y)\"", "lemma join_shunt: \"(x \\<squnion> y = \\<top>) = (-x \\<le> y)\"", "lemma meet_shunt_var: \"(x - y = \\<bottom>) = (x \\<le> y)\"", "lemma join_shunt_var: \"(x \\<longrightarrow> y = \\<top>) = (x \\<le> y)\"", "lemma sup_Sup: \"x \\<squnion> y = \\<Squnion>{x,y}\"", "lemma inf_Inf: \"x \\<sqinter> y = \\<Sqinter>{x,y}\"", "lemma fSup_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = (\\<Squnion>n. f n)\"", "lemma fInf_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = (\\<Sqinter>n. f n)\"", "lemma Sup_sup_closed: \"Sup_closed_set (X::'a::complete_lattice set) \\<Longrightarrow> sup_closed_set X\"", "lemma Inf_inf_closed: \"Inf_closed_set (X::'a::complete_lattice set) \\<Longrightarrow> inf_closed_set X\"", "lemma Inf_pres_map_dual_var: \n  \"Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)\"\n  for f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"", "lemma Inf_pres_map_dual: \"Inf_pres = Sup_pres \\<circ> (\\<partial>\\<^sub>F::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> 'a \\<Rightarrow> 'b)\"", "lemma Sup_pres_map_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"Sup_pres f = Inf_pres (\\<partial>\\<^sub>F f)\"", "lemma Sup_pres_map_dual: \"Sup_pres = Inf_pres \\<circ> (\\<partial>\\<^sub>F::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> 'a \\<Rightarrow> 'b)\"", "lemma fun_isol: \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\"", "lemma fun_isor: \"mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)\"", "lemma Sup_sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> sup_pres f\"", "lemma Inf_inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows\"Inf_pres f \\<Longrightarrow> inf_pres f\"", "lemma Sup_bot_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> bot_pres f\"", "lemma Inf_top_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> top_pres f\"", "lemma Sup_sup_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_dual f \\<Longrightarrow> sup_dual f\"", "lemma Inf_inf_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_dual f \\<Longrightarrow> inf_dual f\"", "lemma Sup_bot_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_dual f \\<Longrightarrow> bot_dual f\"", "lemma Inf_top_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_dual f \\<Longrightarrow> top_dual f\"", "lemma\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> top_pres f\"", "lemma  \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> bot_pres f\"", "lemma iso_Inf_subdistl: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow>f \\<circ> Inf \\<le> Inf \\<circ> (`) f\"", "lemma iso_Sup_supdistl: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\" \n  shows \"mono f \\<Longrightarrow> Sup \\<circ> (`) f \\<le> f \\<circ> Sup\"", "lemma Inf_subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f\"", "lemma Sup_supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f\"", "lemma supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f\"", "lemma subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f\"", "lemma ord_iso_Inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf\"", "lemma ord_iso_Sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup\"", "lemma fSup_distr: \"Sup_pres (\\<lambda>x. x \\<circ> f)\"", "lemma fSup_distr_var: \"\\<Squnion>F \\<circ> g = (\\<Squnion>f \\<in> F. f \\<circ> g)\"", "lemma fInf_distr: \"Inf_pres (\\<lambda>x. x \\<circ> f)\"", "lemma fInf_distr_var: \"\\<Sqinter>F \\<circ> g = (\\<Sqinter>f \\<in> F. f \\<circ> g)\"", "lemma fSup_subdistl: \n  assumes \"mono (f::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup\"", "lemma fSup_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<Squnion>g \\<in> G. f \\<circ> g) \\<le> f \\<circ> \\<Squnion>G\"", "lemma fInf_subdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)\"", "lemma fInf_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> \\<Sqinter>G \\<le> (\\<Sqinter>g \\<in> G. f \\<circ> g)\"", "lemma fSup_distl: \"Sup_pres f \\<Longrightarrow> Sup_pres ((\\<circ>) f)\"", "lemma fSup_distl_var: \"Sup_pres f \\<Longrightarrow> f \\<circ> \\<Squnion>G = (\\<Squnion>g \\<in> G. f \\<circ> g)\"", "lemma fInf_distl: \"Inf_pres f \\<Longrightarrow> Inf_pres ((\\<circ>) f)\"", "lemma fInf_distl_var: \"Inf_pres f \\<Longrightarrow> f \\<circ> \\<Sqinter>G = (\\<Sqinter>g \\<in> G. f \\<circ> g)\"", "lemma Inf_pres_downset: \"Inf_pres (\\<down>::'a::complete_lattice_with_dual \\<Rightarrow> 'a set)\"", "lemma Sup_dual_upset: \"Sup_dual (\\<up>::'a::complete_lattice_with_dual \\<Rightarrow> 'a set)\"", "lemma Sup_pres_Sup_closed: \"Sup_pres f \\<Longrightarrow> Sup_closed_set (range f)\"", "lemma Inf_pres_Inf_closed: \"Inf_pres f \\<Longrightarrow> Inf_closed_set (range f)\"", "lemma de_morgan1: \"-(\\<Squnion>X) = (\\<Sqinter>x \\<in> X. -x)\"", "lemma de_morgan2: \"-(\\<Sqinter>X) = (\\<Squnion>x \\<in> X. -x)\"", "lemma atom_map_def_var: \"atom_map x = \\<down>x \\<inter> Collect atom\"", "lemma atom_map_atoms: \"\\<Union>(range atom_map) = Collect atom\"", "lemma atom_neg: \"atom x \\<Longrightarrow> x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. x \\<le> y \\<or> x \\<le> -y)\"", "lemma atom_sup: \"(\\<forall>y. x \\<le> y \\<or> x \\<le> -y) \\<Longrightarrow> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z))\"", "lemma sup_atom: \"x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)) \\<Longrightarrow> atom x\"", "lemma atom_sup_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)))\"", "lemma atom_neg_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. x \\<le> y \\<or> x \\<le> -y))\"", "lemma atom_map_bot_pres: \"atom_map \\<bottom> = {}\"", "lemma atom_map_top_pres: \"atom_map \\<top> = Collect atom\"", "lemma atom_Sup: \"\\<And>Y. x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>y. x \\<le> y \\<or> x \\<le> -y) \\<Longrightarrow> ((\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y))\"", "lemma Sup_atom: \"x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>Y. (\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y)) \\<Longrightarrow> atom x\"", "lemma atom_Sup_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>Y. (\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y)))\""], "translations": [["", "lemma ord_embed_alt: \"ord_embed f = (mono f \\<and> (\\<forall>x y. f x \\<le> f y \\<longrightarrow> x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_embed f =\n    (mono f \\<and>\n     (\\<forall>x y. f x \\<le> f y \\<longrightarrow> x \\<le> y))", "using mono_def ord_embed_def"], ["proof (prove)\nusing this:\n  mono ?f = (\\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y)\n  ord_embed ?f = (\\<forall>x y. (?f x \\<le> ?f y) = (x \\<le> y))\n\ngoal (1 subgoal):\n 1. ord_embed f =\n    (mono f \\<and>\n     (\\<forall>x y. f x \\<le> f y \\<longrightarrow> x \\<le> y))", "by auto"], ["", "lemma ord_embed_homset: \"ord_embed f \\<Longrightarrow> f \\<in> ord_homset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_embed f \\<Longrightarrow> f \\<in> ord_homset", "by (simp add: mono_def ord_embed_def ord_homset_def)"], ["", "lemma ord_embed_inj: \"ord_embed f \\<Longrightarrow> inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_embed f \\<Longrightarrow> inj f", "unfolding ord_embed_def inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> f y) = (x \\<le> y) \\<Longrightarrow>\n    \\<forall>x y. f x = f y \\<longrightarrow> x = y", "by (simp add: eq_iff)"], ["", "lemma ord_iso_ord_embed: \"ord_iso f \\<Longrightarrow> ord_embed f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> ord_embed f", "unfolding ord_iso_def ord_embed_def bij_def inj_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>f.\n         (\\<forall>x y. f x = f y \\<longrightarrow> x = y) \\<and>\n         surj f) \\<sqinter>\n     (\\<lambda>f.\n         \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<sqinter>\n     ((\\<lambda>f.\n          \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<circ>\n      the_inv))\n     f \\<Longrightarrow>\n    \\<forall>x y. (f x \\<le> f y) = (x \\<le> y)", "by (clarsimp, metis inj_def the_inv_f_f)"], ["", "lemma ord_iso_alt: \"ord_iso f = (ord_embed f \\<and> surj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f = (ord_embed f \\<and> surj f)", "unfolding ord_iso_def ord_embed_def surj_def bij_def inj_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>f.\n         (\\<forall>x y. f x = f y \\<longrightarrow> x = y) \\<and>\n         (\\<forall>y. \\<exists>x. y = f x)) \\<sqinter>\n     (\\<lambda>f.\n         \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<sqinter>\n     ((\\<lambda>f.\n          \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<circ>\n      the_inv))\n     f =\n    ((\\<forall>x y. (f x \\<le> f y) = (x \\<le> y)) \\<and>\n     (\\<forall>y. \\<exists>x. y = f x))", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>((\\<lambda>f.\n                     \\<forall>x y.\n                        x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<circ>\n                 the_inv)\n                 f;\n        \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n        \\<forall>x y. f x = f y \\<longrightarrow> x = y;\n        \\<forall>y. \\<exists>x. y = f x; f x \\<le> f y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<And>x y.\n       \\<lbrakk>((\\<lambda>f.\n                     \\<forall>x y.\n                        x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<circ>\n                 the_inv)\n                 f;\n        \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n        \\<forall>x y. f x = f y \\<longrightarrow> x = y;\n        \\<forall>y. \\<exists>x. y = f x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f y\n 3. \\<And>x y.\n       \\<lbrakk>\\<forall>x y. (f x \\<le> f y) = (x \\<le> y);\n        \\<forall>y. \\<exists>x. y = f x; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       \\<lbrakk>\\<forall>x y. (f x \\<le> f y) = (x \\<le> y);\n        \\<forall>y. \\<exists>x. y = f x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> f x \\<le> f y\n 5. \\<lbrakk>\\<forall>x y. (f x \\<le> f y) = (x \\<le> y);\n     \\<forall>y. \\<exists>x. y = f x\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>f.\n                           \\<forall>x y.\n                              x \\<le> y \\<longrightarrow>\n                              f x \\<le> f y) \\<circ>\n                       the_inv)\n                       f", "by simp_all (metis eq_iff inj_def the_inv_f_f)+"], ["", "lemma ord_iso_the_inv: \"ord_iso f \\<Longrightarrow> mono (the_inv f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> mono (the_inv f)", "by (simp add: ord_iso_def)"], ["", "lemma ord_iso_inv1: \"ord_iso f \\<Longrightarrow> (the_inv f) \\<circ> f = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> the_inv f \\<circ> f = id", "using ord_embed_inj ord_iso_ord_embed the_inv_into_f_f"], ["proof (prove)\nusing this:\n  ord_embed ?f \\<Longrightarrow> inj ?f\n  ord_iso ?f \\<Longrightarrow> ord_embed ?f\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> the_inv_into ?A ?f (?f ?x) = ?x\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> the_inv f \\<circ> f = id", "by fastforce"], ["", "lemma ord_iso_inv2: \"ord_iso f \\<Longrightarrow> f \\<circ> (the_inv f) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> f \\<circ> the_inv f = id", "using f_the_inv_into_f ord_embed_inj ord_iso_alt"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f ?A; ?y \\<in> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> ?f (the_inv_into ?A ?f ?y) = ?y\n  ord_embed ?f \\<Longrightarrow> inj ?f\n  ord_iso ?f = (ord_embed ?f \\<and> surj ?f)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> f \\<circ> the_inv f = id", "by fastforce"], ["", "typedef (overloaded) ('a,'b) ord_homset = \"ord_homset::('a::order \\<Rightarrow> 'b::order) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> ord_homset", "by (force simp: ord_homset_def mono_def)"], ["", "setup_lifting type_definition_ord_homset"], ["", "text \\<open>The next definition is for the set of fixpoints of a given function. It is important in the context of orders,\nfor instance for proving Tarski's fixpoint theorem, but does not really belong here.\\<close>"], ["", "definition Fix :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'a set\" where \n  \"Fix f = {x. f x = x}\""], ["", "lemma retraction_prop: \"f \\<circ> f = f \\<Longrightarrow> f x = x \\<longleftrightarrow> x \\<in> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> f = f \\<Longrightarrow> (f x = x) = (x \\<in> range f)", "by (metis comp_apply f_inv_into_f rangeI)"], ["", "lemma retraction_prop_fix: \"f \\<circ> f = f \\<Longrightarrow> range f = Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> f = f \\<Longrightarrow> range f = Fix f", "unfolding Fix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> f = f \\<Longrightarrow> range f = {x. f x = x}", "using retraction_prop"], ["proof (prove)\nusing this:\n  ?f \\<circ> ?f = ?f \\<Longrightarrow> (?f ?x = ?x) = (?x \\<in> range ?f)\n\ngoal (1 subgoal):\n 1. f \\<circ> f = f \\<Longrightarrow> range f = {x. f x = x}", "by fastforce"], ["", "lemma Fix_map_dual: \"Fix \\<circ> \\<partial>\\<^sub>F = (`) \\<partial> \\<circ> Fix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fix \\<circ> \\<partial>\\<^sub>F = (`) \\<partial> \\<circ> Fix", "unfolding Fix_def map_dual_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {xa. \\<partial> (x (\\<partial> xa)) = xa} =\n       \\<partial> ` {xa. x xa = xa}", "by (smt Collect_cong invol_dual pointfree_idE setcompr_eq_image)"], ["", "lemma Fix_map_dual_var: \"Fix (\\<partial>\\<^sub>F f) = \\<partial> ` (Fix f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fix (\\<partial>\\<^sub>F f) = \\<partial> ` Fix f", "by (metis Fix_map_dual o_def)"], ["", "lemma gfp_dual: \"(\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "fix f:: \"'a \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "have \"\\<partial> (gfp f) = \\<partial> (\\<Squnion>{u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (gfp f) = \\<partial> (\\<Squnion> {u. u \\<le> f u})", "by (simp add: gfp_def)"], ["proof (state)\nthis:\n  \\<partial> (gfp f) = \\<partial> (\\<Squnion> {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "also"], ["proof (state)\nthis:\n  \\<partial> (gfp f) = \\<partial> (\\<Squnion> {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "have \"... = \\<Sqinter>(\\<partial> ` {u. u \\<le> f u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (\\<Squnion> {u. u \\<le> f u}) =\n    \\<Sqinter> (\\<partial> ` {u. u \\<le> f u})", "by (simp add: Sup_dual_def_var)"], ["proof (state)\nthis:\n  \\<partial> (\\<Squnion> {u. u \\<le> f u}) =\n  \\<Sqinter> (\\<partial> ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "also"], ["proof (state)\nthis:\n  \\<partial> (\\<Squnion> {u. u \\<le> f u}) =\n  \\<Sqinter> (\\<partial> ` {u. u \\<le> f u})\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "have \"... = \\<Sqinter>{\\<partial> u |u. u \\<le> f u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (\\<partial> ` {u. u \\<le> f u}) =\n    \\<Sqinter> {\\<partial> u |u. u \\<le> f u}", "by (simp add: setcompr_eq_image)"], ["proof (state)\nthis:\n  \\<Sqinter> (\\<partial> ` {u. u \\<le> f u}) =\n  \\<Sqinter> {\\<partial> u |u. u \\<le> f u}\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "also"], ["proof (state)\nthis:\n  \\<Sqinter> (\\<partial> ` {u. u \\<le> f u}) =\n  \\<Sqinter> {\\<partial> u |u. u \\<le> f u}\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "have \"... = \\<Sqinter>{u |u. (\\<partial>\\<^sub>F f) u \\<le> u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {\\<partial> u |u. u \\<le> f u} =\n    \\<Sqinter> {u |u. \\<partial>\\<^sub>F f u \\<le> u}", "by (metis (no_types, hide_lams) dual_dual_ord dual_iff map_dual_def o_def)"], ["proof (state)\nthis:\n  \\<Sqinter> {\\<partial> u |u. u \\<le> f u} =\n  \\<Sqinter> {u |u. \\<partial>\\<^sub>F f u \\<le> u}\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "finally"], ["proof (chain)\npicking this:\n  \\<partial> (gfp f) = \\<Sqinter> {u |u. \\<partial>\\<^sub>F f u \\<le> u}", "have \"\\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)\""], ["proof (prove)\nusing this:\n  \\<partial> (gfp f) = \\<Sqinter> {u |u. \\<partial>\\<^sub>F f u \\<le> u}\n\ngoal (1 subgoal):\n 1. \\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)", "by (metis lfp_def)"], ["proof (state)\nthis:\n  \\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "}"], ["proof (state)\nthis:\n  \\<partial> (gfp ?f2) = lfp (\\<partial>\\<^sub>F ?f2)\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<partial> (gfp ?f2) = lfp (\\<partial>\\<^sub>F ?f2)\n\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F", "by auto"], ["proof (state)\nthis:\n  \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gfp_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"\\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)", "using comp_eq_elim gfp_dual"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<circ> ?b = ?c \\<circ> ?d;\n   (\\<And>v. ?a (?b v) = ?c (?d v)) \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  \\<partial> \\<circ> gfp = lfp \\<circ> \\<partial>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<partial> (gfp f) = lfp (\\<partial>\\<^sub>F f)", "by blast"], ["", "lemma gfp_to_lfp: \"gfp = (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> lfp \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp = \\<partial> \\<circ> lfp \\<circ> \\<partial>\\<^sub>F", "by (simp add: comp_assoc fun_dual2 gfp_dual)"], ["", "lemma gfp_to_lfp_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"gfp f = \\<partial> (lfp (\\<partial>\\<^sub>F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfp f = \\<partial> (lfp (\\<partial>\\<^sub>F f))", "by (metis gfp_dual_var invol_dual_var)"], ["", "lemma lfp_dual: \"(\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> lfp = gfp \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> lfp = gfp \\<circ> \\<partial>\\<^sub>F", "by (simp add: comp_assoc gfp_to_lfp map_dual_invol)"], ["", "lemma lfp_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"\\<partial> (lfp f) = gfp (map_dual f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (lfp f) = gfp (\\<partial>\\<^sub>F f)", "using comp_eq_dest_lhs lfp_dual"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<Longrightarrow> ?a (?b ?v) = ?c ?v\n  \\<partial> \\<circ> lfp = gfp \\<circ> \\<partial>\\<^sub>F\n\ngoal (1 subgoal):\n 1. \\<partial> (lfp f) = gfp (\\<partial>\\<^sub>F f)", "by fastforce"], ["", "lemma lfp_to_gfp: \"lfp = (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> gfp \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp = \\<partial> \\<circ> gfp \\<circ> \\<partial>\\<^sub>F", "by (simp add: comp_assoc gfp_dual map_dual_invol)"], ["", "lemma lfp_to_gfp_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"lfp f = \\<partial> (gfp (\\<partial>\\<^sub>F f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = \\<partial> (gfp (\\<partial>\\<^sub>F f))", "by (metis invol_dual_var lfp_dual_var)"], ["", "lemma lfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> lfp f \\<in> Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> lfp f \\<in> Fix f", "by (metis (mono_tags, lifting) Fix_def lfp_unfold mem_Collect_eq)"], ["", "lemma gfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> gfp f \\<in> Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> gfp f \\<in> Fix f", "by (metis (mono_tags, lifting) Fix_def gfp_unfold mem_Collect_eq)"], ["", "lemma nonempty_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> Fix f \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Fix f \\<noteq> {}", "using lfp_in_Fix"], ["proof (prove)\nusing this:\n  mono ?f \\<Longrightarrow> lfp ?f \\<in> Fix ?f\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Fix f \\<noteq> {}", "by fastforce"], ["", "text \\<open>Next the minimal and maximal elements of an ordering are defined.\\<close>"], ["", "context ord\nbegin"], ["", "definition min_set :: \"'a set \\<Rightarrow> 'a set\" where \n  \"min_set X = {y \\<in> X. \\<forall>x \\<in> X. x \\<le> y \\<longrightarrow> x = y}\""], ["", "definition max_set :: \"'a set \\<Rightarrow> 'a set\" where \n  \"max_set X = {x \\<in> X. \\<forall>y \\<in> X. x \\<le> y \\<longrightarrow> x = y}\""], ["", "end"], ["", "context ord_with_dual\nbegin"], ["", "lemma min_max_set_dual: \"(`) \\<partial> \\<circ> min_set = max_set \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> min_set = max_set \\<circ> (`) \\<partial>", "unfolding max_set_def min_set_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<partial> `\n       {y \\<in> x. \\<forall>x\\<in>x. x \\<le> y \\<longrightarrow> x = y} =\n       {xa \\<in> \\<partial> ` x.\n        \\<forall>y\\<in>\\<partial> ` x. xa \\<le> y \\<longrightarrow> xa = y}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> x;\n        \\<forall>x\\<in>x. x \\<le> xb \\<longrightarrow> x = xb\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb \\<in> \\<partial> ` x\n 2. \\<And>x xa xb y xc.\n       \\<lbrakk>xb \\<in> x;\n        \\<forall>x\\<in>x. x \\<le> xb \\<longrightarrow> x = xb; xc \\<in> x;\n        \\<partial> xb \\<le> \\<partial> xc\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb = \\<partial> xc\n 3. \\<And>x xa xb.\n       \\<lbrakk>\\<forall>y\\<in>\\<partial> ` x.\n                   \\<partial> xb \\<le> y \\<longrightarrow>\n                   \\<partial> xb = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb\n                         \\<in> \\<partial> `\n                               {y \\<in> x.\n                                \\<forall>x\\<in>x.\n                                   x \\<le> y \\<longrightarrow> x = y}", "using dual_dual_ord inj_dual_iff"], ["proof (prove)\nusing this:\n  (\\<partial> ?x \\<le> \\<partial> ?y) = (?y \\<le> ?x)\n  (\\<partial> ?x = \\<partial> ?y) = (?x = ?y)\n\ngoal (3 subgoals):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xb \\<in> x;\n        \\<forall>x\\<in>x. x \\<le> xb \\<longrightarrow> x = xb\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb \\<in> \\<partial> ` x\n 2. \\<And>x xa xb y xc.\n       \\<lbrakk>xb \\<in> x;\n        \\<forall>x\\<in>x. x \\<le> xb \\<longrightarrow> x = xb; xc \\<in> x;\n        \\<partial> xb \\<le> \\<partial> xc\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb = \\<partial> xc\n 3. \\<And>x xa xb.\n       \\<lbrakk>\\<forall>y\\<in>\\<partial> ` x.\n                   \\<partial> xb \\<le> y \\<longrightarrow>\n                   \\<partial> xb = y;\n        xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> \\<partial> xb\n                         \\<in> \\<partial> `\n                               {y \\<in> x.\n                                \\<forall>x\\<in>x.\n                                   x \\<le> y \\<longrightarrow> x = y}", "by auto"], ["", "lemma min_max_set_dual_var: \"\\<partial> ` (min_set X) = max_set (\\<partial> ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> ` min_set X = max_set (\\<partial> ` X)", "using comp_eq_dest min_max_set_dual"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<circ> ?d \\<Longrightarrow> ?a (?b ?v) = ?c (?d ?v)\n  (`) \\<partial> \\<circ> min_set = max_set \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. \\<partial> ` min_set X = max_set (\\<partial> ` X)", "by fastforce"], ["", "lemma max_min_set_dual: \"(`) \\<partial> \\<circ> max_set = min_set \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> max_set = min_set \\<circ> (`) \\<partial>", "by (metis (no_types, hide_lams) comp_id fun.map_comp id_comp image_dual min_max_set_dual)"], ["", "lemma min_to_max_set: \"min_set = (`) \\<partial> \\<circ> max_set \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_set = (`) \\<partial> \\<circ> max_set \\<circ> (`) \\<partial>", "by (metis comp_id image_dual max_min_set_dual o_assoc)"], ["", "lemma max_min_set_dual_var: \"\\<partial> ` (max_set X) = min_set (\\<partial> ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> ` max_set X = min_set (\\<partial> ` X)", "using comp_eq_dest max_min_set_dual"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<circ> ?d \\<Longrightarrow> ?a (?b ?v) = ?c (?d ?v)\n  (`) \\<partial> \\<circ> max_set = min_set \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. \\<partial> ` max_set X = min_set (\\<partial> ` X)", "by fastforce"], ["", "lemma min_to_max_set_var: \"min_set X = \\<partial> ` (max_set (\\<partial> ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_set X = \\<partial> ` max_set (\\<partial> ` X)", "by (simp add: max_min_set_dual_var pointfree_idE)"], ["", "end"], ["", "text \\<open>Next, directed and filtered sets, upsets, downsets, filters and ideals in posets are defined.\\<close>"], ["", "context ord\nbegin"], ["", "definition directed :: \"'a set \\<Rightarrow> bool\" where\n \"directed X = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x))\""], ["", "definition filtered :: \"'a set \\<Rightarrow> bool\" where\n \"filtered X = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. x \\<le> y))\""], ["", "definition downset_set :: \"'a set \\<Rightarrow> 'a set\" (\"\\<Down>\") where\n  \"\\<Down>X = {y. \\<exists>x \\<in> X. y \\<le> x}\""], ["", "definition upset_set :: \"'a set \\<Rightarrow> 'a set\" (\"\\<Up>\") where\n \"\\<Up>X = {y. \\<exists>x \\<in> X. x \\<le> y}\""], ["", "definition downset :: \"'a \\<Rightarrow> 'a set\" (\"\\<down>\") where \n  \"\\<down> = \\<Down> \\<circ> \\<eta>\""], ["", "definition upset :: \"'a \\<Rightarrow> 'a set\" (\"\\<up>\") where \n  \"\\<up> = \\<Up> \\<circ> \\<eta>\""], ["", "definition downsets :: \"'a set set\" where  \n  \"downsets = Fix \\<Down>\""], ["", "definition upsets :: \"'a set set\" where\n  \"upsets = Fix \\<Up>\""], ["", "definition \"downclosed_set X = (X \\<in> downsets)\""], ["", "definition \"upclosed_set X = (X \\<in> upsets)\""], ["", "definition ideals :: \"'a set set\" where\n  \"ideals = {X. X \\<noteq> {} \\<and> downclosed_set X \\<and> directed X}\""], ["", "definition filters :: \"'a set set\" where\n  \"filters = {X. X \\<noteq> {} \\<and> upclosed_set X \\<and> filtered X}\""], ["", "abbreviation \"idealp X \\<equiv> X \\<in> ideals\""], ["", "abbreviation \"filterp X \\<equiv> X \\<in> filters\""], ["", "end"], ["", "text \\<open>These notions are pair-wise dual.\\<close>"], ["", "text \\<open>Filtered and directed sets are dual.\\<close>"], ["", "context ord_with_dual\nbegin"], ["", "lemma filtered_directed_dual: \"filtered \\<circ> (`) \\<partial> = directed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "unfolding filtered_def directed_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<forall>Y.\n           finite Y \\<and> Y \\<subseteq> \\<partial> ` x \\<longrightarrow>\n           (\\<exists>x\\<in>\\<partial> ` x. Ball Y ((\\<le>) x))) =\n       (\\<forall>Y.\n           finite Y \\<and> Y \\<subseteq> x \\<longrightarrow>\n           (\\<exists>x\\<in>x. \\<forall>y\\<in>Y. y \\<le> x))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>Y.\n           finite Y \\<and> Y \\<subseteq> \\<partial> ` x \\<longrightarrow>\n           (\\<exists>x\\<in>x. \\<forall>xa\\<in>Y. \\<partial> x \\<le> xa)) =\n       (\\<forall>Y.\n           finite Y \\<and> Y \\<subseteq> x \\<longrightarrow>\n           (\\<exists>x\\<in>x. \\<forall>y\\<in>Y. y \\<le> x))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x Y.\n       \\<lbrakk>\\<forall>Y.\n                   finite Y \\<and>\n                   Y \\<subseteq> \\<partial> ` x \\<longrightarrow>\n                   (\\<exists>x\\<in>x.\n                       \\<forall>xa\\<in>Y. \\<partial> x \\<le> xa);\n        finite Y; Y \\<subseteq> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>x. \\<forall>y\\<in>Y. y \\<le> x\n 2. \\<And>x Y.\n       \\<lbrakk>\\<forall>Y.\n                   finite Y \\<and> Y \\<subseteq> x \\<longrightarrow>\n                   (\\<exists>x\\<in>x. \\<forall>y\\<in>Y. y \\<le> x);\n        finite Y; Y \\<subseteq> \\<partial> ` x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>x.\n                            \\<forall>xa\\<in>Y. \\<partial> x \\<le> xa", "apply (meson finite_imageI imageI image_mono dual_dual_ord)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<lbrakk>\\<forall>Y.\n                   finite Y \\<and> Y \\<subseteq> x \\<longrightarrow>\n                   (\\<exists>x\\<in>x. \\<forall>y\\<in>Y. y \\<le> x);\n        finite Y; Y \\<subseteq> \\<partial> ` x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>x.\n                            \\<forall>xa\\<in>Y. \\<partial> x \\<le> xa", "by (smt finite_subset_image imageE ord_dual)"], ["", "lemma directed_filtered_dual: \"directed \\<circ> (`) \\<partial> = filtered\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "using filtered_directed_dual"], ["proof (prove)\nusing this:\n  filtered \\<circ> (`) \\<partial> = directed\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "by (metis comp_id image_dual o_assoc)"], ["", "lemma filtered_to_directed: \"filtered X = directed (\\<partial> ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X = directed (\\<partial> ` X)", "by (metis comp_apply directed_filtered_dual)"], ["", "text \\<open>Upsets and downsets are dual.\\<close>"], ["", "lemma downset_set_upset_set_dual: \"(`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "unfolding downset_set_def upset_set_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<partial> ` {y. Bex x ((\\<le>) y)} =\n       {y. \\<exists>x\\<in>\\<partial> ` x. x \\<le> y}", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb xc.\n       \\<lbrakk>xc \\<in> x; xb \\<le> xc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>\\<partial> ` x.\n                            x \\<le> \\<partial> xb\n 2. \\<And>x xa xb xc.\n       \\<lbrakk>\\<partial> xc \\<le> xa; xc \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<partial> ` {y. Bex x ((\\<le>) y)}", "apply (meson image_eqI ord_dual)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       \\<lbrakk>\\<partial> xc \\<le> xa; xc \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<partial> ` {y. Bex x ((\\<le>) y)}", "by (clarsimp, metis (mono_tags, lifting) dual_iff image_iff mem_Collect_eq ord_dual)"], ["", "lemma upset_set_downset_set_dual: \"(`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>", "using downset_set_upset_set_dual"], ["proof (prove)\nusing this:\n  (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>", "by (metis (no_types, hide_lams) comp_id id_comp image_dual o_assoc)"], ["", "lemma upset_set_to_downset_set: \"\\<Up> = (`) \\<partial> \\<circ> \\<Down> \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> = (`) \\<partial> \\<circ> \\<Down> \\<circ> (`) \\<partial>", "by (simp add: comp_assoc downset_set_upset_set_dual)"], ["", "lemma upset_set_to_downset_set2: \"\\<Up> X = \\<partial> ` (\\<Down> (\\<partial> ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> X = \\<partial> ` \\<Down> (\\<partial> ` X)", "by (simp add: upset_set_to_downset_set)"], ["", "lemma downset_upset_dual: \"(`) \\<partial> \\<circ> \\<down> = \\<up> \\<circ> \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<down> = \\<up> \\<circ> \\<partial>", "using downset_def upset_def upset_set_to_downset_set"], ["proof (prove)\nusing this:\n  \\<down> = \\<Down> \\<circ> \\<eta>\n  \\<up> = \\<Up> \\<circ> \\<eta>\n  \\<Up> = (`) \\<partial> \\<circ> \\<Down> \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<down> = \\<up> \\<circ> \\<partial>", "by fastforce"], ["", "lemma upset_to_downset: \"(`) \\<partial> \\<circ> \\<up> = \\<down> \\<circ> \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<up> = \\<down> \\<circ> \\<partial>", "by (metis comp_assoc id_apply ord.downset_def ord.upset_def power_set_func_nat_trans upset_set_downset_set_dual)"], ["", "lemma upset_to_downset2: \"\\<up> = (`) \\<partial> \\<circ> \\<down> \\<circ> \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> = (`) \\<partial> \\<circ> \\<down> \\<circ> \\<partial>", "by (simp add: comp_assoc downset_upset_dual)"], ["", "lemma upset_to_downset3: \"\\<up> x = \\<partial> ` (\\<down> (\\<partial> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> x = \\<partial> ` \\<down> (\\<partial> x)", "by (simp add: upset_to_downset2)"], ["", "lemma downsets_upsets_dual: \"(X \\<in> downsets) = (\\<partial> ` X \\<in> upsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> downsets) = (\\<partial> ` X \\<in> upsets)", "unfolding downsets_def upsets_def Fix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> {x. \\<Down> x = x}) = (\\<partial> ` X \\<in> {x. \\<Up> x = x})", "by (smt comp_eq_dest downset_set_upset_set_dual image_inv_f_f inj_dual mem_Collect_eq)"], ["", "lemma downset_setp_upset_setp_dual: \"upclosed_set \\<circ> (`) \\<partial> = downclosed_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upclosed_set \\<circ> (`) \\<partial> = downclosed_set", "unfolding downclosed_set_def upclosed_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>X. X \\<in> upsets) \\<circ> (`) \\<partial> =\n    (\\<lambda>X. X \\<in> downsets)", "using downsets_upsets_dual"], ["proof (prove)\nusing this:\n  (?X \\<in> downsets) = (\\<partial> ` ?X \\<in> upsets)\n\ngoal (1 subgoal):\n 1. (\\<lambda>X. X \\<in> upsets) \\<circ> (`) \\<partial> =\n    (\\<lambda>X. X \\<in> downsets)", "by fastforce"], ["", "lemma upsets_to_downsets: \"(X \\<in> upsets) = (\\<partial> ` X \\<in> downsets)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> upsets) = (\\<partial> ` X \\<in> downsets)", "by (simp add: downsets_upsets_dual image_comp)"], ["", "lemma upset_setp_downset_setp_dual: \"downclosed_set \\<circ> (`) \\<partial> = upclosed_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set \\<circ> (`) \\<partial> = upclosed_set", "by (metis comp_id downset_setp_upset_setp_dual image_dual o_assoc)"], ["", "text \\<open>Filters and ideals are dual.\\<close>"], ["", "lemma ideals_filters_dual: \"(X \\<in> ideals) = ((\\<partial> ` X) \\<in> filters)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X = filterp (\\<partial> ` X)", "by (smt comp_eq_dest_lhs directed_filtered_dual image_inv_f_f image_is_empty inv_unique_comp filters_def ideals_def inj_dual invol_dual mem_Collect_eq upset_setp_downset_setp_dual)"], ["", "lemma idealp_filterp_dual: \"idealp = filterp \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp = filterp \\<circ> (`) \\<partial>", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. idealp x = (filterp \\<circ> (`) \\<partial>) x", "by (simp add: ideals_filters_dual)"], ["", "lemma filters_to_ideals: \"(X \\<in> filters) = ((\\<partial> ` X) \\<in> ideals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X = idealp (\\<partial> ` X)", "by (simp add: ideals_filters_dual image_comp)"], ["", "lemma filterp_idealp_dual: \"filterp = idealp \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp = idealp \\<circ> (`) \\<partial>", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. filterp x = (idealp \\<circ> (`) \\<partial>) x", "by (simp add: filters_to_ideals)"], ["", "end"], ["", "subsection \\<open>Properties of Orderings\\<close>"], ["", "context ord\nbegin"], ["", "lemma directed_nonempty: \"directed X \\<Longrightarrow> X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X \\<Longrightarrow> X \\<noteq> {}", "unfolding directed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n       (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x) \\<Longrightarrow>\n    X \\<noteq> {}", "by fastforce"], ["", "lemma directed_ub: \"directed X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z", "by (meson empty_subsetI directed_def finite.emptyI finite_insert insert_subset order_refl)"], ["", "lemma downset_set_prop: \"\\<Down> = Union \\<circ> (`) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> = \\<Union> \\<circ> (`) \\<down>", "unfolding downset_set_def downset_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {y. Bex x ((\\<le>) y)} =\n       (\\<Union> \\<circ>\n        (`) ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>))\n        x", "by fastforce"], ["", "lemma downset_set_prop_var: \"\\<Down>X = (\\<Union>x \\<in> X. \\<down>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> X = \\<Union> (\\<down> ` X)", "by (simp add: downset_set_prop)"], ["", "lemma downset_prop: \"\\<down>x = {y. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> x = {y. y \\<le> x}", "unfolding downset_def downset_set_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>) x = {y. y \\<le> x}", "by fastforce"], ["", "lemma downset_prop2: \"y \\<le> x \\<Longrightarrow> y \\<in> \\<down>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow> y \\<in> \\<down> x", "by (simp add: downset_prop)"], ["", "lemma ideals_downsets: \"X \\<in> ideals \\<Longrightarrow> X \\<in> downsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X \\<Longrightarrow> X \\<in> downsets", "by (simp add: downclosed_set_def ideals_def)"], ["", "lemma ideals_directed: \"X \\<in> ideals \\<Longrightarrow> directed X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X \\<Longrightarrow> directed X", "by (simp add: ideals_def)"], ["", "end"], ["", "context preorder\nbegin"], ["", "lemma directed_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow> directed X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "assume h1: \"X \\<noteq> {}\"\n  and h2: \"\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n  \\<forall>x\\<in>X.\n     \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "{"], ["proof (state)\nthis:\n  X \\<noteq> {}\n  \\<forall>x\\<in>X.\n     \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "have \"finite Y \\<Longrightarrow> Y \\<subseteq> X \\<Longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite Y; Y \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> X \\<Longrightarrow>\n    \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> X\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> X \\<Longrightarrow>\n    \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x", "using h1"], ["proof (prove)\nusing this:\n  {} \\<subseteq> X\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>X. \\<forall>y\\<in>insert x F. y \\<le> xa", "by (metis h2 insert_iff insert_subset order_trans)"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>X. \\<forall>y\\<in>insert x F. y \\<le> xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite Y; Y \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?Y2; ?Y2 \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y2. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y2; ?Y2 \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y2. y \\<le> x\n\ngoal (1 subgoal):\n 1. directed X", "by (simp add: directed_def)"], ["proof (state)\nthis:\n  directed X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma directed_alt: \"directed X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X =\n    (X \\<noteq> {} \\<and>\n     (\\<forall>x\\<in>X.\n         \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z))", "by (metis directed_prop directed_nonempty directed_ub)"], ["", "lemma downset_set_prop_var2: \"x \\<in> \\<Down>X \\<Longrightarrow> y \\<le> x \\<Longrightarrow> y \\<in> \\<Down>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<Down> X; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<in> \\<Down> X", "unfolding downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {y. Bex X ((\\<le>) y)}; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<in> {y. Bex X ((\\<le>) y)}", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {y. Bex X ((\\<le>) y)}; y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<in> {y. Bex X ((\\<le>) y)}", "by blast"], ["", "lemma downclosed_set_iff: \"downclosed_set X = (\\<forall>x \\<in> X. \\<forall>y. y \\<le> x \\<longrightarrow> y \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set X = (\\<forall>x\\<in>X. \\<forall>y\\<le>x. y \\<in> X)", "unfolding downclosed_set_def downsets_def Fix_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> {x. {y. Bex x ((\\<le>) y)} = x}) =\n    (\\<forall>x\\<in>X. \\<forall>y\\<le>x. y \\<in> X)", "by auto"], ["", "lemma downclosed_downset_set: \"downclosed_set (\\<Down>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set (\\<Down> X)", "by (simp add: downclosed_set_iff downset_set_prop_var2 downset_def)"], ["", "lemma downclosed_downset: \"downclosed_set (\\<down>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set (\\<down> x)", "by (simp add: downclosed_downset_set downset_def)"], ["", "lemma downset_set_ext: \"id \\<le> \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<Down>", "unfolding le_fun_def id_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<subseteq> {y. Bex x ((\\<le>) y)}", "by auto"], ["", "lemma downset_set_iso: \"mono \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<Down>", "unfolding mono_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       {y. Bex x ((\\<le>) y)} \\<subseteq> {ya. Bex y ((\\<le>) ya)}", "by blast"], ["", "lemma downset_set_idem [simp]: \"\\<Down> \\<circ> \\<Down> = \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> \\<circ> \\<Down> = \\<Down>", "unfolding fun_eq_iff downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ>\n        (\\<lambda>X. {y. Bex X ((\\<le>) y)}))\n        x =\n       {y. Bex x ((\\<le>) y)}", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ>\n        (\\<lambda>X. {y. Bex X ((\\<le>) y)}))\n        x =\n       {y. Bex x ((\\<le>) y)}", "by auto"], ["", "lemma downset_faithful: \"\\<down>x \\<subseteq> \\<down>y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> x \\<subseteq> \\<down> y \\<Longrightarrow> x \\<le> y", "by (simp add: downset_prop subset_eq)"], ["", "lemma downset_iso_iff: \"(\\<down>x \\<subseteq> \\<down>y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<down> x \\<subseteq> \\<down> y) = (x \\<le> y)", "using atMost_iff downset_prop order_trans"], ["proof (prove)\nusing this:\n  (?i \\<in> {..?k}) = (?i \\<le> ?k)\n  \\<down> ?x = {y. y \\<le> ?x}\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (\\<down> x \\<subseteq> \\<down> y) = (x \\<le> y)", "by blast"], ["", "text \\<open>The following proof uses the Axiom of Choice.\\<close>"], ["", "lemma downset_directed_downset_var [simp]: \"directed (\\<Down>X) = directed X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) = directed X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "assume h1: \"directed X\""], ["proof (state)\nthis:\n  directed X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "{"], ["proof (state)\nthis:\n  directed X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "fix Y"], ["proof (state)\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "assume h2: \"finite Y\" and h3: \"Y \\<subseteq> \\<Down>X\""], ["proof (state)\nthis:\n  finite Y\n  Y \\<subseteq> \\<Down> X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<forall>y. \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and>  y \\<le> x\""], ["proof (prove)\nusing this:\n  finite Y\n  Y \\<subseteq> \\<Down> X\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x", "by (force simp: downset_set_def)"], ["proof (state)\nthis:\n  \\<forall>y.\n     \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>f. \\<forall>y. y \\<in> Y \\<longrightarrow>  f y \\<in> X \\<and> y \\<le> f y\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>y.\n          y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y", "by (rule choice)"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>y. y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>f. finite (f ` Y) \\<and> f ` Y \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. y \\<le> f y)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>y. y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       finite (f ` Y) \\<and>\n       f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)", "by (metis finite_imageI h2 image_subsetI)"], ["proof (state)\nthis:\n  \\<exists>f.\n     finite (f ` Y) \\<and>\n     f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>Z. finite Z \\<and> Z \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. \\<exists> z \\<in> Z. y \\<le> z)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     finite (f ` Y) \\<and>\n     f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       finite Z \\<and>\n       Z \\<subseteq> X \\<and>\n       (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>Z. finite Z \\<and> Z \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. \\<exists> z \\<in> Z. y \\<le> z) \\<and> (\\<exists>x \\<in> X. \\<forall> z \\<in> Z. z \\<le> x)\""], ["proof (prove)\nusing this:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       finite Z \\<and>\n       Z \\<subseteq> X \\<and>\n       (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n       (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)", "by (metis directed_def h1)"], ["proof (state)\nthis:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and>\n     (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n     (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x\""], ["proof (prove)\nusing this:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and>\n     (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n     (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "by (meson order_trans)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?Y2; ?Y2 \\<subseteq> \\<Down> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y2. y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "thus \"directed (\\<Down>X)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y2; ?Y2 \\<subseteq> \\<Down> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y2. y \\<le> x\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X)", "unfolding directed_def downset_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y2; ?Y2 \\<subseteq> {y. Bex X ((\\<le>) y)}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y2. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and>\n       Y \\<subseteq> {y. Bex X ((\\<le>) y)} \\<longrightarrow>\n       (\\<exists>x\\<in>{y. Bex X ((\\<le>) y)}. \\<forall>y\\<in>Y. y \\<le> x)", "by fastforce"], ["proof (state)\nthis:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "assume \"directed (\\<Down>X)\""], ["proof (state)\nthis:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "thus \"directed X\""], ["proof (prove)\nusing this:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed X", "unfolding directed_def downset_set_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     finite Y \\<and> Y \\<subseteq> {y. Bex X ((\\<le>) y)} \\<longrightarrow>\n     (\\<exists>x\\<in>{y. Bex X ((\\<le>) y)}. \\<forall>y\\<in>Y. y \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n       (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>Y.\n                   finite Y \\<and>\n                   Y \\<subseteq> {y. \\<exists>x\\<in>X.\n  y \\<le> x} \\<longrightarrow>\n                   (\\<exists>x.\n                       (\\<exists>xa\\<in>X. x \\<le> xa) \\<and>\n                       (\\<forall>y\\<in>Y. y \\<le> x));\n        finite Y; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "by (smt Ball_Collect order_refl order_trans subsetCE)"], ["proof (state)\nthis:\n  directed X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma downset_directed_downset [simp]: \"directed \\<circ> \\<Down> = directed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed \\<circ> \\<Down> = directed", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (directed \\<circ> \\<Down>) x = directed x", "by simp"], ["", "lemma directed_downset_ideals: \"directed (\\<Down>X) = (\\<Down>X \\<in> ideals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) = idealp (\\<Down> X)", "by (metis (mono_tags, lifting) CollectI Fix_def directed_alt downset_set_idem downclosed_set_def downsets_def ideals_def o_def ord.ideals_directed)"], ["", "lemma downclosed_Fix: \"downclosed_set X = (\\<Down>X = X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set X = (\\<Down> X = X)", "by (metis (mono_tags, lifting) CollectD Fix_def downclosed_downset_set downclosed_set_def downsets_def)"], ["", "end"], ["", "lemma downset_iso: \"mono (\\<down>::'a::order \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<down>", "by (simp add: downset_iso_iff mono_def)"], ["", "lemma mono_downclosed: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y)", "by (simp add: assms downclosed_set_iff monoD)"], ["", "lemma\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. downclosed_set X \\<longrightarrow> downclosed_set (f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. downclosed_set X \\<longrightarrow> downclosed_set (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. downclosed_set X \\<longrightarrow> downclosed_set (f ` X)", "oops"], ["", "lemma downclosed_mono:\n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  assumes \"\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y)\"\n  shows \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "fix x y :: \"'a::order\""], ["proof (state)\ngoal (1 subgoal):\n 1. mono f", "assume h: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. mono f", "have \"downclosed_set (\\<down> (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downclosed_set (\\<down> (f y))", "unfolding downclosed_set_def downsets_def Fix_def downset_set_def downset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>) (f y)\n    \\<in> {x. {y. Bex x ((\\<le>) y)} = x}", "by auto"], ["proof (state)\nthis:\n  downclosed_set (\\<down> (f y))\n\ngoal (1 subgoal):\n 1. mono f", "hence \"downclosed_set (f -` (\\<down> (f y)))\""], ["proof (prove)\nusing this:\n  downclosed_set (\\<down> (f y))\n\ngoal (1 subgoal):\n 1. downclosed_set (f -` \\<down> (f y))", "by (simp add: assms)"], ["proof (state)\nthis:\n  downclosed_set (f -` \\<down> (f y))\n\ngoal (1 subgoal):\n 1. mono f", "hence \"downclosed_set {z. f z \\<le> f y}\""], ["proof (prove)\nusing this:\n  downclosed_set (f -` \\<down> (f y))\n\ngoal (1 subgoal):\n 1. downclosed_set {z. f z \\<le> f y}", "unfolding vimage_def downset_def downset_set_def"], ["proof (prove)\nusing this:\n  downclosed_set\n   {x. f x\n       \\<in> ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>) (f y)}\n\ngoal (1 subgoal):\n 1. downclosed_set {z. f z \\<le> f y}", "by auto"], ["proof (state)\nthis:\n  downclosed_set {z. f z \\<le> f y}\n\ngoal (1 subgoal):\n 1. mono f", "hence \"\\<forall>z w. (f z \\<le> f y \\<and> w \\<le> z) \\<longrightarrow> f w \\<le> f y\""], ["proof (prove)\nusing this:\n  downclosed_set {z. f z \\<le> f y}\n\ngoal (1 subgoal):\n 1. \\<forall>z w.\n       f z \\<le> f y \\<and> w \\<le> z \\<longrightarrow> f w \\<le> f y", "unfolding downclosed_set_def downclosed_set_def downsets_def Fix_def downset_set_def"], ["proof (prove)\nusing this:\n  {z. f z \\<le> f y} \\<in> {x. {y. Bex x ((\\<le>) y)} = x}\n\ngoal (1 subgoal):\n 1. \\<forall>z w.\n       f z \\<le> f y \\<and> w \\<le> z \\<longrightarrow> f w \\<le> f y", "by force"], ["proof (state)\nthis:\n  \\<forall>z w.\n     f z \\<le> f y \\<and> w \\<le> z \\<longrightarrow> f w \\<le> f y\n\ngoal (1 subgoal):\n 1. mono f", "hence \"f x \\<le> f y\""], ["proof (prove)\nusing this:\n  \\<forall>z w.\n     f z \\<le> f y \\<and> w \\<le> z \\<longrightarrow> f w \\<le> f y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y", "using h"], ["proof (prove)\nusing this:\n  \\<forall>z w.\n     f z \\<le> f y \\<and> w \\<le> z \\<longrightarrow> f w \\<le> f y\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. f x \\<le> f y", "by blast"], ["proof (state)\nthis:\n  f x \\<le> f y\n\ngoal (1 subgoal):\n 1. mono f", "}"], ["proof (state)\nthis:\n  ?x2 \\<le> ?y2 \\<Longrightarrow> f ?x2 \\<le> f ?y2\n\ngoal (1 subgoal):\n 1. mono f", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<le> ?y2 \\<Longrightarrow> f ?x2 \\<le> f ?y2\n\ngoal (1 subgoal):\n 1. mono f", ".."], ["proof (state)\nthis:\n  mono f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mono_downclosed_iff: \"mono f = (\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f =\n    (\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y))", "using mono_downclosed downclosed_mono"], ["proof (prove)\nusing this:\n  mono ?f \\<Longrightarrow>\n  \\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (?f -` Y)\n  \\<forall>Y.\n     downclosed_set Y \\<longrightarrow>\n     downclosed_set (?f -` Y) \\<Longrightarrow>\n  mono ?f\n\ngoal (1 subgoal):\n 1. mono f =\n    (\\<forall>Y. downclosed_set Y \\<longrightarrow> downclosed_set (f -` Y))", "by auto"], ["", "context order\nbegin"], ["", "lemma downset_inj: \"inj \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<down>", "by (metis injI downset_iso_iff eq_iff)"], ["", "lemma \"(X \\<subseteq> Y) = (\\<Down>X \\<subseteq> \\<Down>Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<Down> X \\<subseteq> \\<Down> Y)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<Down> X \\<subseteq> \\<Down> Y)", "oops"], ["", "end"], ["", "context lattice\nbegin"], ["", "lemma lat_ideals: \"X \\<in> ideals = (X \\<noteq> {} \\<and> X \\<in> downsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<squnion> y \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X =\n    (X \\<noteq> {} \\<and>\n     X \\<in> downsets \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<squnion> y \\<in> X))", "unfolding ideals_def directed_alt downsets_def Fix_def downset_set_def downclosed_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> {X. X \\<noteq> {} \\<and>\n                 X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n                 X \\<noteq> {} \\<and>\n                 (\\<forall>x\\<in>X.\n                     \\<forall>y\\<in>X.\n                        \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z)}) =\n    (X \\<noteq> {} \\<and>\n     X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<squnion> y \\<in> X))", "by (clarsimp, smt sup.cobounded1 sup.orderE sup.orderI sup_absorb2 sup_left_commute mem_Collect_eq)"], ["", "end"], ["", "context bounded_lattice\nbegin"], ["", "lemma bot_ideal: \"X \\<in> ideals \\<Longrightarrow> \\<bottom> \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X \\<Longrightarrow> \\<bottom> \\<in> X", "unfolding ideals_def downclosed_set_def downsets_def Fix_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> {X. X \\<noteq> {} \\<and>\n                X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n                directed X} \\<Longrightarrow>\n    \\<bottom> \\<in> X", "by fastforce"], ["", "end"], ["", "context complete_lattice\nbegin"], ["", "lemma Sup_downset_id [simp]: \"Sup \\<circ> \\<down> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> \\<down> = id", "using Sup_atMost atMost_def downset_prop"], ["proof (prove)\nusing this:\n  \\<Squnion> {..?y} = ?y\n  {..?u} \\<equiv> {x. x \\<le> ?u}\n  \\<down> ?x = {y. y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. Sup \\<circ> \\<down> = id", "by fastforce"], ["", "lemma downset_Sup_id: \"id \\<le> \\<down> \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<down> \\<circ> Sup", "by (simp add: Sup_upper downset_prop le_funI subsetI)"], ["", "lemma Inf_Sup_var: \"\\<Squnion>(\\<Inter>x \\<in> X. \\<down>x) = \\<Sqinter>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> \\<Inter> (\\<down> ` X) = \\<Sqinter> X", "unfolding downset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (\\<Inter>x\\<in>X. {y. y \\<le> x}) = \\<Sqinter> X", "by (simp add: Collect_ball_eq Inf_eq_Sup)"], ["", "lemma Inf_pres_downset_var: \"(\\<Inter>x \\<in> X. \\<down>x) = \\<down>(\\<Sqinter>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (\\<down> ` X) = \\<down> (\\<Sqinter> X)", "unfolding downset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>x\\<in>X. {y. y \\<le> x}) = {y. y \\<le> \\<Sqinter> X}", "by (safe, simp_all add: le_Inf_iff)"], ["", "end"], ["", "subsection \\<open>Dual Properties of Orderings\\<close>"], ["", "context ord_with_dual\nbegin"], ["", "lemma filtered_nonempty: \"filtered X \\<Longrightarrow> X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow> X \\<noteq> {}", "using filtered_to_directed ord.directed_nonempty"], ["proof (prove)\nusing this:\n  filtered ?X = directed (\\<partial> ` ?X)\n  ord.directed ?less_eq ?X \\<Longrightarrow> ?X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow> X \\<noteq> {}", "by auto"], ["", "lemma filtered_lb: \"filtered X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y", "using filtered_to_directed directed_ub dual_dual_ord"], ["proof (prove)\nusing this:\n  filtered ?X = directed (\\<partial> ` ?X)\n  directed ?X \\<Longrightarrow>\n  \\<forall>x\\<in>?X.\n     \\<forall>y\\<in>?X. \\<exists>z\\<in>?X. x \\<le> z \\<and> y \\<le> z\n  (\\<partial> ?x \\<le> \\<partial> ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y", "by fastforce"], ["", "lemma upset_set_prop_var: \"\\<Up>X = (\\<Union>x \\<in> X. \\<up>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> X = \\<Union> (\\<up> ` X)", "by (simp add: image_Union downset_set_prop_var upset_set_to_downset_set2 upset_to_downset2)"], ["", "lemma upset_set_prop: \"\\<Up> = Union \\<circ> (`) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> = \\<Union> \\<circ> (`) \\<up>", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Up> x = (\\<Union> \\<circ> (`) \\<up>) x", "by (simp add: upset_set_prop_var)"], ["", "lemma upset_prop: \"\\<up>x = {y. x \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> x = {y. x \\<le> y}", "unfolding upset_to_downset3 downset_prop image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{y. y \\<le> \\<partial> x}. y = \\<partial> x} =\n    {y. x \\<le> y}", "using dual_dual_ord"], ["proof (prove)\nusing this:\n  (\\<partial> ?x \\<le> \\<partial> ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{y. y \\<le> \\<partial> x}. y = \\<partial> x} =\n    {y. x \\<le> y}", "by fastforce"], ["", "lemma upset_prop2: \"x \\<le> y \\<Longrightarrow> y \\<in> \\<up>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> y \\<in> \\<up> x", "by (simp add: upset_prop)"], ["", "lemma filters_upsets: \"X \\<in> filters \\<Longrightarrow> X \\<in> upsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X \\<Longrightarrow> X \\<in> upsets", "by (simp add: upclosed_set_def filters_def)"], ["", "lemma filters_filtered: \"X \\<in> filters \\<Longrightarrow> filtered X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X \\<Longrightarrow> filtered X", "by (simp add: filters_def)"], ["", "end"], ["", "context preorder_with_dual\nbegin"], ["", "lemma filtered_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y) \\<Longrightarrow> filtered X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> filtered X", "unfolding filtered_to_directed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> directed (\\<partial> ` X)", "by (rule directed_prop, blast, metis (full_types) image_iff ord_dual)"], ["", "lemma filtered_alt: \"filtered X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X =\n    (X \\<noteq> {} \\<and>\n     (\\<forall>x\\<in>X.\n         \\<forall>y\\<in>X. \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y))", "by (metis image_empty directed_alt filtered_to_directed filtered_lb filtered_prop)"], ["", "lemma up_set_prop_var2: \"x \\<in> \\<Up>X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> y \\<in> \\<Up>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<Up> X; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> \\<Up> X", "using downset_set_prop_var2 dual_iff ord_dual upset_set_to_downset_set2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> \\<Down> ?X; ?y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> \\<Down> ?X\n  (\\<partial> ?x = ?y) = (?x = \\<partial> ?y)\n  ?x \\<le> ?y \\<Longrightarrow> \\<partial> ?y \\<le> \\<partial> ?x\n  \\<Up> ?X = \\<partial> ` \\<Down> (\\<partial> ` ?X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<Up> X; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> \\<Up> X", "by fastforce"], ["", "lemma upclosed_set_iff: \"upclosed_set X = (\\<forall>x \\<in> X. \\<forall>y. x \\<le> y \\<longrightarrow> y \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upclosed_set X = (\\<forall>x\\<in>X. \\<forall>y\\<ge>x. y \\<in> X)", "unfolding upclosed_set_def upsets_def Fix_def upset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> {x. {y. \\<exists>x\\<in>x. x \\<le> y} = x}) =\n    (\\<forall>x\\<in>X. \\<forall>y\\<ge>x. y \\<in> X)", "by auto"], ["", "lemma upclosed_upset_set: \"upclosed_set (\\<Up>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upclosed_set (\\<Up> X)", "using up_set_prop_var2 upclosed_set_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> \\<Up> ?X; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> \\<Up> ?X\n  upclosed_set ?X = (\\<forall>x\\<in>?X. \\<forall>y\\<ge>x. y \\<in> ?X)\n\ngoal (1 subgoal):\n 1. upclosed_set (\\<Up> X)", "by blast"], ["", "lemma upclosed_upset: \"upclosed_set (\\<up>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upclosed_set (\\<up> x)", "by (simp add: upset_def upclosed_upset_set)"], ["", "lemma upset_set_ext: \"id \\<le> \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<Up>", "by (smt comp_def comp_id image_mono le_fun_def downset_set_ext image_dual upset_set_to_downset_set2)"], ["", "lemma upset_set_anti: \"mono \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<Up>", "by (metis image_mono downset_set_iso upset_set_to_downset_set2 mono_def)"], ["", "lemma up_set_idem [simp]: \"\\<Up> \\<circ> \\<Up> = \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> \\<circ> \\<Up> = \\<Up>", "by (metis comp_assoc downset_set_idem upset_set_downset_set_dual upset_set_to_downset_set)"], ["", "lemma upset_faithful: \"\\<up>x \\<subseteq> \\<up>y \\<Longrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> x \\<subseteq> \\<up> y \\<Longrightarrow> y \\<le> x", "by (metis inj_image_subset_iff downset_faithful dual_dual_ord inj_dual upset_to_downset3)"], ["", "lemma upset_anti_iff: \"(\\<up>y \\<subseteq> \\<up>x) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> y \\<subseteq> \\<up> x) = (x \\<le> y)", "by (metis downset_iso_iff ord_dual upset_to_downset3 subset_image_iff upset_faithful)"], ["", "lemma upset_filtered_upset [simp]: \"filtered \\<circ> \\<Up> = filtered\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered \\<circ> \\<Up> = filtered", "by (metis comp_assoc directed_filtered_dual downset_directed_downset upset_set_downset_set_dual)"], ["", "lemma filtered_upset_filters: \"filtered (\\<Up>X) = (\\<Up>X \\<in> filters)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered (\\<Up> X) = filterp (\\<Up> X)", "by (metis comp_apply directed_downset_ideals filtered_to_directed filterp_idealp_dual upset_set_downset_set_dual)"], ["", "lemma upclosed_Fix: \"upclosed_set X = (\\<Up>X = X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upclosed_set X = (\\<Up> X = X)", "by (simp add: Fix_def upclosed_set_def upsets_def)"], ["", "end"], ["", "lemma upset_anti: \"antimono (\\<up>::'a::order_with_dual \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono \\<up>", "by (simp add: antimono_def upset_anti_iff)"], ["", "lemma mono_upclosed: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y)", "by (simp add: assms monoD upclosed_set_iff)"], ["", "lemma mono_upclosed: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"mono f\"\n  shows \"\\<forall>Y. upclosed_set X \\<longrightarrow> upclosed_set (f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. upclosed_set X \\<longrightarrow> upclosed_set (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y. upclosed_set X \\<longrightarrow> upclosed_set (f ` X)", "oops"], ["", "lemma upclosed_mono:\n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  assumes \"\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y)\"\n  shows \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f", "by (metis (mono_tags, lifting) assms dual_order.refl mem_Collect_eq monoI order.trans upclosed_set_iff vimageE vimageI2)"], ["", "lemma mono_upclosed_iff: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"\n  shows \"mono f = (\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f =\n    (\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y))", "using mono_upclosed upclosed_mono"], ["proof (prove)\nusing this:\n  mono ?f \\<Longrightarrow>\n  \\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (?f -` Y)\n  \\<forall>Y.\n     upclosed_set Y \\<longrightarrow>\n     upclosed_set (?f -` Y) \\<Longrightarrow>\n  mono ?f\n\ngoal (1 subgoal):\n 1. mono f =\n    (\\<forall>Y. upclosed_set Y \\<longrightarrow> upclosed_set (f -` Y))", "by auto"], ["", "context order_with_dual\nbegin"], ["", "lemma upset_inj: \"inj \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<up>", "by (metis inj_compose inj_on_imageI2 downset_inj inj_dual upset_to_downset)"], ["", "lemma \"(X \\<subseteq> Y) = (\\<Up>Y \\<subseteq> \\<Up>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<Up> Y \\<subseteq> \\<Up> X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<Up> Y \\<subseteq> \\<Up> X)", "oops"], ["", "end"], ["", "context lattice_with_dual\nbegin"], ["", "lemma lat_filters: \"X \\<in> filters = (X \\<noteq> {} \\<and> X \\<in> upsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<sqinter> y \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X =\n    (X \\<noteq> {} \\<and>\n     X \\<in> upsets \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<sqinter> y \\<in> X))", "unfolding filters_to_ideals upsets_to_downsets inf_to_sup lat_ideals"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> ` X \\<noteq> {} \\<and>\n     \\<partial> ` X \\<in> downsets \\<and>\n     (\\<forall>x\\<in>\\<partial> ` X.\n         \\<forall>y\\<in>\\<partial> ` X.\n            x \\<squnion> y \\<in> \\<partial> ` X)) =\n    (X \\<noteq> {} \\<and>\n     \\<partial> ` X \\<in> downsets \\<and>\n     (\\<forall>x\\<in>X.\n         \\<forall>y\\<in>X.\n            \\<partial> (\\<partial> x \\<squnion> \\<partial> y) \\<in> X))", "by (smt image_iff image_inv_f_f image_is_empty inj_image_mem_iff inv_unique_comp inj_dual invol_dual)"], ["", "end"], ["", "context bounded_lattice_with_dual\nbegin"], ["", "lemma top_filter: \"X \\<in> filters \\<Longrightarrow> \\<top> \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X \\<Longrightarrow> \\<top> \\<in> X", "using bot_ideal inj_image_mem_iff inj_dual filters_to_ideals top_dual"], ["proof (prove)\nusing this:\n  idealp ?X \\<Longrightarrow> \\<bottom> \\<in> ?X\n  inj ?f \\<Longrightarrow> (?f ?a \\<in> ?f ` ?A) = (?a \\<in> ?A)\n  inj \\<partial>\n  filterp ?X = idealp (\\<partial> ` ?X)\n  \\<partial> \\<top> = \\<bottom>\n\ngoal (1 subgoal):\n 1. filterp X \\<Longrightarrow> \\<top> \\<in> X", "by fastforce"], ["", "end"], ["", "context complete_lattice_with_dual\nbegin"], ["", "lemma Inf_upset_id [simp]: \"Inf \\<circ> \\<up> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf \\<circ> \\<up> = id", "by (metis comp_assoc comp_id Sup_downset_id Sups_dual_def downset_upset_dual invol_dual)"], ["", "lemma upset_Inf_id: \"id \\<le> \\<up> \\<circ> Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<up> \\<circ> Inf", "by (simp add: Inf_lower le_funI subsetI upset_prop)"], ["", "lemma Sup_Inf_var: \" \\<Sqinter>(\\<Inter>x \\<in> X. \\<up>x) = \\<Squnion>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> \\<Inter> (\\<up> ` X) = \\<Squnion> X", "unfolding upset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (\\<Inter>x\\<in>X. Collect ((\\<le>) x)) = \\<Squnion> X", "by (simp add: Collect_ball_eq Sup_eq_Inf)"], ["", "lemma Sup_dual_upset_var: \"(\\<Inter>x \\<in> X. \\<up>x) = \\<up>(\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (\\<up> ` X) = \\<up> (\\<Squnion> X)", "unfolding upset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>x\\<in>X. Collect ((\\<le>) x)) =\n    Collect ((\\<le>) (\\<Squnion> X))", "by (safe, simp_all add: Sup_le_iff)"], ["", "end"], ["", "subsection \\<open>Shunting Laws\\<close>"], ["", "text \\<open>The first set of laws supplies so-called shunting laws for boolean algebras. \nSuch laws rather belong into Isabelle Main.\\<close>"], ["", "context boolean_algebra\nbegin"], ["", "lemma shunt1: \"(x \\<sqinter> y \\<le> z) = (x \\<le> -y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y \\<le> z) = (x \\<le> - y \\<squnion> z)", "proof standard"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "assume \"x \\<sqinter> y \\<le> z\""], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence  \"-y \\<squnion> (x \\<sqinter> y) \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> z\n\ngoal (1 subgoal):\n 1. - y \\<squnion> x \\<sqinter> y \\<le> - y \\<squnion> z", "using sup.mono"], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> z\n  \\<lbrakk>?c \\<le> ?a; ?d \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?c \\<squnion> ?d \\<le> ?a \\<squnion> ?b\n\ngoal (1 subgoal):\n 1. - y \\<squnion> x \\<sqinter> y \\<le> - y \\<squnion> z", "by blast"], ["proof (state)\nthis:\n  - y \\<squnion> x \\<sqinter> y \\<le> - y \\<squnion> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence \"-y \\<squnion> x \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  - y \\<squnion> x \\<sqinter> y \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. - y \\<squnion> x \\<le> - y \\<squnion> z", "by (simp add: sup_inf_distrib1)"], ["proof (state)\nthis:\n  - y \\<squnion> x \\<le> - y \\<squnion> z\n\ngoal (2 subgoals):\n 1. x \\<sqinter> y \\<le> z \\<Longrightarrow> x \\<le> - y \\<squnion> z\n 2. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "thus \"x \\<le> -y \\<squnion> z\""], ["proof (prove)\nusing this:\n  - y \\<squnion> x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z", "by simp"], ["proof (state)\nthis:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "assume \"x \\<le> -y \\<squnion> z\""], ["proof (state)\nthis:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "hence \"x \\<sqinter> y \\<le> (-y \\<squnion> z) \\<sqinter> y\""], ["proof (prove)\nusing this:\n  x \\<le> - y \\<squnion> z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> (- y \\<squnion> z) \\<sqinter> y", "using inf_mono"], ["proof (prove)\nusing this:\n  x \\<le> - y \\<squnion> z\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c \\<sqinter> ?d\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> (- y \\<squnion> z) \\<sqinter> y", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> (- y \\<squnion> z) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<squnion> z \\<Longrightarrow> x \\<sqinter> y \\<le> z", "thus  \"x \\<sqinter> y \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> (- y \\<squnion> z) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> z", "using inf.boundedE inf_sup_distrib2"], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<le> (- y \\<squnion> z) \\<sqinter> y\n  \\<lbrakk>?a \\<le> ?b \\<sqinter> ?c;\n   \\<lbrakk>?a \\<le> ?b; ?a \\<le> ?c\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> z", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shunt2: \"(x \\<sqinter> -y \\<le> z) = (x \\<le> y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y \\<le> z) = (x \\<le> y \\<squnion> z)", "by (simp add: shunt1)"], ["", "lemma meet_shunt: \"(x \\<sqinter> y = \\<bottom>) = (x \\<le> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y = \\<bottom>) = (x \\<le> - y)", "by (simp add: eq_iff shunt1)"], ["", "lemma join_shunt: \"(x \\<squnion> y = \\<top>) = (-x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y = \\<top>) = (- x \\<le> y)", "by (metis compl_sup compl_top_eq double_compl meet_shunt)"], ["", "lemma meet_shunt_var: \"(x - y = \\<bottom>) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - y = \\<bottom>) = (x \\<le> y)", "by (simp add: diff_eq meet_shunt)"], ["", "lemma join_shunt_var: \"(x \\<longrightarrow> y = \\<top>) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<longrightarrow> y = \\<top>) = (x \\<le> y)", "by simp"], ["", "end"], ["", "subsection \\<open>Properties of Complete Lattices\\<close>"], ["", "definition \"Inf_closed_set X = (\\<forall>Y \\<subseteq> X. \\<Sqinter>Y \\<in> X)\""], ["", "definition \"Sup_closed_set X = (\\<forall>Y \\<subseteq> X. \\<Squnion>Y \\<in> X)\""], ["", "definition \"inf_closed_set X = (\\<forall>x \\<in> X. \\<forall>y \\<in> X. x \\<sqinter> y \\<in> X)\""], ["", "definition \"sup_closed_set X = (\\<forall>x \\<in> X. \\<forall>y \\<in> X. x \\<squnion> y \\<in> X)\""], ["", "text \\<open>The following facts about complete lattices add to those in the Isabelle libraries.\\<close>"], ["", "context complete_lattice \nbegin"], ["", "text \\<open>The translation between sup and Sup could be improved. The sup-theorems should be direct\nconsequences of Sup-ones. In addition, duality between sup and inf is currently not exploited.\\<close>"], ["", "lemma sup_Sup: \"x \\<squnion> y = \\<Squnion>{x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = \\<Squnion> insert x (\\<eta> y)", "by simp"], ["", "lemma inf_Inf: \"x \\<sqinter> y = \\<Sqinter>{x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = \\<Sqinter> insert x (\\<eta> y)", "by simp"], ["", "text \\<open>The next two lemmas are about Sups and Infs of indexed families. These are interesting for\niterations and fixpoints.\\<close>"], ["", "lemma fSup_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = (\\<Squnion>n. f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = \\<Squnion> range f", "apply (intro antisym sup_least)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f 0 \\<le> \\<Squnion> range f\n 2. (\\<Squnion>n. f (Suc n)) \\<le> \\<Squnion> range f\n 3. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (rule Sup_upper, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Squnion>n. f (Suc n)) \\<le> \\<Squnion> range f\n 2. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (rule Sup_mono, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (safe intro!: Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       n \\<in> UNIV \\<Longrightarrow>\n       f n \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "by (case_tac n, simp_all add: Sup_upper le_supI2)"], ["", "lemma fInf_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = (\\<Sqinter>n. f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = \\<Sqinter> range f", "apply (intro antisym inf_greatest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> \\<Sqinter> range f\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (rule Inf_greatest, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x n.\n       n \\<in> UNIV \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>n \\<in> UNIV; n = 0\\<rbrakk>\n       \\<Longrightarrow> f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 2. \\<And>x n nat.\n       \\<lbrakk>n \\<in> UNIV; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 3. \\<Sqinter> range f \\<le> f 0\n 4. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n nat.\n       n = Suc nat \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f (Suc nat)\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "using Inf_lower inf.coboundedI2"], ["proof (prove)\nusing this:\n  ?x \\<in> ?A \\<Longrightarrow> \\<Sqinter> ?A \\<le> ?x\n  ?b \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n\ngoal (3 subgoals):\n 1. \\<And>n nat.\n       n = Suc nat \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f (Suc nat)\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Sqinter> range f \\<le> f 0\n 2. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (simp add: Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "by (auto intro: Inf_mono)"], ["", "end"], ["", "lemma Sup_sup_closed: \"Sup_closed_set (X::'a::complete_lattice set) \\<Longrightarrow> sup_closed_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_closed_set X \\<Longrightarrow> sup_closed_set X", "by (metis Sup_closed_set_def empty_subsetI insert_subsetI sup_Sup sup_closed_set_def)"], ["", "lemma Inf_inf_closed: \"Inf_closed_set (X::'a::complete_lattice set) \\<Longrightarrow> inf_closed_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_closed_set X \\<Longrightarrow> inf_closed_set X", "by (metis Inf_closed_set_def empty_subsetI inf_Inf inf_closed_set_def insert_subset)"], ["", "subsection \\<open>Sup- and Inf-Preservation\\<close>"], ["", "text \\<open>Next, important notation for morphism between posets and lattices is introduced: \nsup-preservation, inf-preservation and related properties.\\<close>"], ["", "abbreviation Sup_pres :: \"('a::Sup \\<Rightarrow> 'b::Sup) \\<Rightarrow> bool\" where\n  \"Sup_pres f \\<equiv> f \\<circ> Sup = Sup \\<circ> (`) f\""], ["", "abbreviation Inf_pres :: \"('a::Inf \\<Rightarrow> 'b::Inf) \\<Rightarrow> bool\" where\n  \"Inf_pres f \\<equiv> f \\<circ> Inf = Inf \\<circ> (`) f\""], ["", "abbreviation sup_pres :: \"('a::sup \\<Rightarrow> 'b::sup) \\<Rightarrow> bool\" where\n  \"sup_pres f \\<equiv> (\\<forall>x y. f (x \\<squnion> y) = f x \\<squnion> f y)\""], ["", "abbreviation inf_pres :: \"('a::inf \\<Rightarrow> 'b::inf) \\<Rightarrow> bool\" where\n \"inf_pres f \\<equiv> (\\<forall>x y. f (x \\<sqinter> y) = f x \\<sqinter> f y)\""], ["", "abbreviation bot_pres :: \"('a::bot \\<Rightarrow> 'b::bot) \\<Rightarrow> bool\" where\n  \"bot_pres f \\<equiv> f \\<bottom> = \\<bottom>\""], ["", "abbreviation top_pres :: \"('a::top \\<Rightarrow> 'b::top) \\<Rightarrow> bool\" where\n  \"top_pres f \\<equiv> f \\<top> = \\<top>\""], ["", "abbreviation Sup_dual :: \"('a::Sup \\<Rightarrow> 'b::Inf) \\<Rightarrow> bool\" where\n  \"Sup_dual f \\<equiv> f \\<circ> Sup = Inf \\<circ> (`) f\""], ["", "abbreviation Inf_dual :: \"('a::Inf \\<Rightarrow> 'b::Sup) \\<Rightarrow> bool\" where\n  \"Inf_dual f \\<equiv> f \\<circ> Inf = Sup \\<circ> (`) f\""], ["", "abbreviation sup_dual :: \"('a::sup \\<Rightarrow> 'b::inf) \\<Rightarrow> bool\" where\n  \"sup_dual f \\<equiv> (\\<forall>x y. f (x \\<squnion> y) = f x \\<sqinter> f y)\""], ["", "abbreviation inf_dual :: \"('a::inf \\<Rightarrow> 'b::sup) \\<Rightarrow> bool\" where\n \"inf_dual f \\<equiv> (\\<forall>x y. f (x \\<sqinter> y) = f x \\<squnion> f y)\""], ["", "abbreviation bot_dual :: \"('a::bot \\<Rightarrow> 'b::top) \\<Rightarrow> bool\" where \n \"bot_dual f \\<equiv> f \\<bottom> = \\<top>\""], ["", "abbreviation top_dual :: \"('a::top \\<Rightarrow> 'b::bot) \\<Rightarrow> bool\" where \n  \"top_dual f \\<equiv> f \\<top> = \\<bottom>\""], ["", "text \\<open>Inf-preservation and sup-preservation relate with duality.\\<close>"], ["", "lemma Inf_pres_map_dual_var: \n  \"Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)\"\n  for f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "fix x :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "assume \"\\<partial> (f (\\<Sqinter> (\\<partial> ` x))) = (\\<Squnion>y\\<in>x. \\<partial> (f (\\<partial> y)))\" for x"], ["proof (state)\nthis:\n  \\<partial> (f (\\<Sqinter> (\\<partial> ` ?x))) =\n  (\\<Squnion>y\\<in>?x. \\<partial> (f (\\<partial> y)))\n\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "then"], ["proof (chain)\npicking this:\n  \\<partial> (f (\\<Sqinter> (\\<partial> ` ?x))) =\n  (\\<Squnion>y\\<in>?x. \\<partial> (f (\\<partial> y)))", "have \"\\<Sqinter> (f ` \\<partial> ` A) = f (\\<partial> (\\<Squnion> A))\" for A"], ["proof (prove)\nusing this:\n  \\<partial> (f (\\<Sqinter> (\\<partial> ` ?x))) =\n  (\\<Squnion>y\\<in>?x. \\<partial> (f (\\<partial> y)))\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` \\<partial> ` A) = f (\\<partial> (\\<Squnion> A))", "by (metis (no_types) Sup_dual_def_var image_image invol_dual_var subset_dual)"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` \\<partial> ` ?A) = f (\\<partial> (\\<Squnion> ?A))\n\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "then"], ["proof (chain)\npicking this:\n  \\<Sqinter> (f ` \\<partial> ` ?A) = f (\\<partial> (\\<Squnion> ?A))", "have \"\\<Sqinter> (f ` x) = f (\\<Sqinter> x)\""], ["proof (prove)\nusing this:\n  \\<Sqinter> (f ` \\<partial> ` ?A) = f (\\<partial> (\\<Squnion> ?A))\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` x) = f (\\<Sqinter> x)", "by (metis Sup_dual_def_var subset_dual)"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` x) = f (\\<Sqinter> x)\n\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "}"], ["proof (state)\nthis:\n  (\\<And>x.\n      \\<partial> (f (\\<Sqinter> (\\<partial> ` x))) =\n      (\\<Squnion>y\\<in>x. \\<partial> (f (\\<partial> y)))) \\<Longrightarrow>\n  \\<Sqinter> (f ` ?x2) = f (\\<Sqinter> ?x2)\n\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "then"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<partial> (f (\\<Sqinter> (\\<partial> ` x))) =\n      (\\<Squnion>y\\<in>x. \\<partial> (f (\\<partial> y)))) \\<Longrightarrow>\n  \\<Sqinter> (f ` ?x2) = f (\\<Sqinter> ?x2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<partial> (f (\\<Sqinter> (\\<partial> ` x))) =\n      (\\<Squnion>y\\<in>x. \\<partial> (f (\\<partial> y)))) \\<Longrightarrow>\n  \\<Sqinter> (f ` ?x2) = f (\\<Sqinter> ?x2)\n\ngoal (1 subgoal):\n 1. Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)", "by (auto simp add: map_dual_def fun_eq_iff Inf_dual_var Sup_dual_def_var image_comp)"], ["proof (state)\nthis:\n  Inf_pres f = Sup_pres (\\<partial>\\<^sub>F f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Inf_pres_map_dual: \"Inf_pres = Sup_pres \\<circ> (\\<partial>\\<^sub>F::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> 'a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "fix f::\"'a \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "have \"Inf_pres f = (Sup_pres \\<circ> \\<partial>\\<^sub>F) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f = (Sup_pres \\<circ> \\<partial>\\<^sub>F) f", "by (simp add: Inf_pres_map_dual_var)"], ["proof (state)\nthis:\n  Inf_pres f = (Sup_pres \\<circ> \\<partial>\\<^sub>F) f\n\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "}"], ["proof (state)\nthis:\n  Inf_pres ?f2 = (Sup_pres \\<circ> \\<partial>\\<^sub>F) ?f2\n\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "thus ?thesis"], ["proof (prove)\nusing this:\n  Inf_pres ?f2 = (Sup_pres \\<circ> \\<partial>\\<^sub>F) ?f2\n\ngoal (1 subgoal):\n 1. Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F", "by force"], ["proof (state)\nthis:\n  Inf_pres = Sup_pres \\<circ> \\<partial>\\<^sub>F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_pres_map_dual_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"Sup_pres f = Inf_pres (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f = Inf_pres (\\<partial>\\<^sub>F f)", "by (metis Inf_pres_map_dual_var fun_dual5 map_dual_def)"], ["", "lemma Sup_pres_map_dual: \"Sup_pres = Inf_pres \\<circ> (\\<partial>\\<^sub>F::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> 'a \\<Rightarrow> 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres = Inf_pres \\<circ> \\<partial>\\<^sub>F", "by (simp add: Inf_pres_map_dual comp_assoc map_dual_invol)"], ["", "text \\<open>The following lemmas relate isotonicity of functions between complete lattices \nwith weak (left) preservation properties of sups and infs.\\<close>"], ["", "lemma fun_isol: \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono ((\\<circ>) f)", "by (simp add: le_fun_def mono_def)"], ["", "lemma fun_isor: \"mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)", "by (simp add: le_fun_def mono_def)"], ["", "lemma Sup_sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> sup_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> sup_pres f", "by (metis (no_types, hide_lams) Sup_empty Sup_insert comp_apply image_insert sup_bot.right_neutral)"], ["", "lemma Inf_inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows\"Inf_pres f \\<Longrightarrow> inf_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> inf_pres f", "by (smt INF_insert Inf_empty Inf_insert comp_eq_elim inf_top.right_neutral)"], ["", "lemma Sup_bot_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> bot_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> bot_pres f", "by (metis SUP_empty Sup_empty comp_eq_elim)"], ["", "lemma Inf_top_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> top_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> top_pres f", "by (metis INF_empty Inf_empty comp_eq_elim)"], ["", "lemma Sup_sup_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_dual f \\<Longrightarrow> sup_dual f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_dual f \\<Longrightarrow> sup_dual f", "by (smt comp_eq_elim image_empty image_insert inf_Inf sup_Sup)"], ["", "lemma Inf_inf_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_dual f \\<Longrightarrow> inf_dual f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_dual f \\<Longrightarrow> inf_dual f", "by (smt comp_eq_elim image_empty image_insert inf_Inf sup_Sup)"], ["", "lemma Sup_bot_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_dual f \\<Longrightarrow> bot_dual f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_dual f \\<Longrightarrow> bot_dual f", "by (metis INF_empty Sup_empty comp_eq_elim)"], ["", "lemma Inf_top_dual: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_dual f \\<Longrightarrow> top_dual f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_dual f \\<Longrightarrow> top_dual f", "by (metis Inf_empty SUP_empty comp_eq_elim)"], ["", "text \\<open>However, Inf-preservation does not imply top-preservation and \nSup-preservation does not imply bottom-preservation.\\<close>"], ["", "lemma\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> top_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> top_pres f", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> top_pres f", "oops"], ["", "lemma  \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> bot_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> bot_pres f", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> bot_pres f", "oops"], ["", "context complete_lattice\nbegin"], ["", "lemma iso_Inf_subdistl: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow>f \\<circ> Inf \\<le> Inf \\<circ> (`) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> f \\<circ> Inf \\<le> Inf \\<circ> (`) f", "by (simp add: complete_lattice_class.le_Inf_iff le_funI Inf_lower monoD)"], ["", "lemma iso_Sup_supdistl: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\" \n  shows \"mono f \\<Longrightarrow> Sup \\<circ> (`) f \\<le> f \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Sup \\<circ> (`) f \\<le> f \\<circ> Sup", "by (simp add: complete_lattice_class.Sup_le_iff le_funI Sup_upper monoD)"], ["", "lemma Inf_subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f", "unfolding mono_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. f (\\<Sqinter> x) \\<le> \\<Sqinter> (f ` x) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (metis complete_lattice_class.le_INF_iff Inf_atLeast atLeast_iff)"], ["", "lemma Sup_supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f", "unfolding mono_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Squnion> (f ` x) \\<le> f (\\<Squnion> x) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (metis complete_lattice_class.SUP_le_iff Sup_atMost atMost_iff)"], ["", "lemma supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f", "using Sup_supdistl_iso iso_Sup_supdistl"], ["proof (prove)\nusing this:\n  Sup \\<circ> (`) ?f \\<le> ?f \\<circ> Sup \\<Longrightarrow> mono ?f\n  mono ?f \\<Longrightarrow> Sup \\<circ> (`) ?f \\<le> ?f \\<circ> Sup\n\ngoal (1 subgoal):\n 1. (Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f", "by force"], ["", "lemma subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f", "using Inf_subdistl_iso iso_Inf_subdistl"], ["proof (prove)\nusing this:\n  ?f \\<circ> Inf \\<le> Inf \\<circ> (`) ?f \\<Longrightarrow> mono ?f\n  mono ?f \\<Longrightarrow> ?f \\<circ> Inf \\<le> Inf \\<circ> (`) ?f\n\ngoal (1 subgoal):\n 1. (f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f", "by force"], ["", "end"], ["", "lemma ord_iso_Inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "let ?g = \"the_inv f\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "assume h: \"ord_iso f\""], ["proof (state)\nthis:\n  ord_iso f\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "hence a: \"mono ?g\""], ["proof (prove)\nusing this:\n  ord_iso f\n\ngoal (1 subgoal):\n 1. mono (the_inv f)", "by (simp add: ord_iso_the_inv)"], ["proof (state)\nthis:\n  mono (the_inv f)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "{"], ["proof (state)\nthis:\n  mono (the_inv f)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "fix X :: \"'a::complete_lattice set\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "fix y :: \"'b::complete_lattice\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "have \"(y \\<le> f (\\<Sqinter>X)) = (?g y \\<le> \\<Sqinter>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<le> f (\\<Sqinter> X)) = (the_inv f y \\<le> \\<Sqinter> X)", "by (metis (mono_tags, lifting) UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt)"], ["proof (state)\nthis:\n  (y \\<le> f (\\<Sqinter> X)) = (the_inv f y \\<le> \\<Sqinter> X)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "also"], ["proof (state)\nthis:\n  (y \\<le> f (\\<Sqinter> X)) = (the_inv f y \\<le> \\<Sqinter> X)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "have \"... = (\\<forall>x \\<in> X. ?g y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_inv f y \\<le> \\<Sqinter> X) =\n    (\\<forall>x\\<in>X. the_inv f y \\<le> x)", "by (simp add: le_Inf_iff)"], ["proof (state)\nthis:\n  (the_inv f y \\<le> \\<Sqinter> X) = (\\<forall>x\\<in>X. the_inv f y \\<le> x)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "also"], ["proof (state)\nthis:\n  (the_inv f y \\<le> \\<Sqinter> X) = (\\<forall>x\\<in>X. the_inv f y \\<le> x)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "have \"... = (\\<forall>x \\<in> X. y \\<le> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. the_inv f y \\<le> x) =\n    (\\<forall>x\\<in>X. y \\<le> f x)", "by (metis (mono_tags, lifting) UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. the_inv f y \\<le> x) = (\\<forall>x\\<in>X. y \\<le> f x)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "also"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. the_inv f y \\<le> x) = (\\<forall>x\\<in>X. y \\<le> f x)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "have \"... = (y \\<le> \\<Sqinter> (f ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. y \\<le> f x) = (y \\<le> \\<Sqinter> (f ` X))", "by (simp add: le_INF_iff)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. y \\<le> f x) = (y \\<le> \\<Sqinter> (f ` X))\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "finally"], ["proof (chain)\npicking this:\n  (y \\<le> f (\\<Sqinter> X)) = (y \\<le> \\<Sqinter> (f ` X))", "have \"(y \\<le> f (\\<Sqinter>X)) = (y \\<le> \\<Sqinter> (f ` X))\""], ["proof (prove)\nusing this:\n  (y \\<le> f (\\<Sqinter> X)) = (y \\<le> \\<Sqinter> (f ` X))\n\ngoal (1 subgoal):\n 1. (y \\<le> f (\\<Sqinter> X)) = (y \\<le> \\<Sqinter> (f ` X))", "."], ["proof (state)\nthis:\n  (y \\<le> f (\\<Sqinter> X)) = (y \\<le> \\<Sqinter> (f ` X))\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "}"], ["proof (state)\nthis:\n  (?y2 \\<le> f (\\<Sqinter> X)) = (?y2 \\<le> \\<Sqinter> (f ` X))\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "hence \"f (\\<Sqinter>X) = \\<Sqinter> (f ` X)\""], ["proof (prove)\nusing this:\n  (?y2 \\<le> f (\\<Sqinter> X)) = (?y2 \\<le> \\<Sqinter> (f ` X))\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> X) = \\<Sqinter> (f ` X)", "by (meson dual_order.antisym order_refl)"], ["proof (state)\nthis:\n  f (\\<Sqinter> X) = \\<Sqinter> (f ` X)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "}"], ["proof (state)\nthis:\n  f (\\<Sqinter> ?X2) = \\<Sqinter> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Inf \\<circ> (`) f = f \\<circ> Inf", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (\\<Sqinter> ?X2) = \\<Sqinter> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. Inf \\<circ> (`) f = f \\<circ> Inf", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  f (\\<Sqinter> ?X2) = \\<Sqinter> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (Inf \\<circ> (`) f) x = (f \\<circ> Inf) x", "by simp"], ["proof (state)\nthis:\n  Inf \\<circ> (`) f = f \\<circ> Inf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_iso_Sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "let ?g = \"the_inv f\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "assume h: \"ord_iso f\""], ["proof (state)\nthis:\n  ord_iso f\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "hence a: \"mono ?g\""], ["proof (prove)\nusing this:\n  ord_iso f\n\ngoal (1 subgoal):\n 1. mono (the_inv f)", "by (simp add: ord_iso_the_inv)"], ["proof (state)\nthis:\n  mono (the_inv f)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "{"], ["proof (state)\nthis:\n  mono (the_inv f)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "fix X :: \"'a::complete_lattice set\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "fix y :: \"'b::complete_lattice\""], ["proof (state)\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "have \"(f (\\<Squnion>X) \\<le> y) = (\\<Squnion>X \\<le> ?g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> X \\<le> the_inv f y)", "by (metis (mono_tags, lifting) UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt)"], ["proof (state)\nthis:\n  (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> X \\<le> the_inv f y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "also"], ["proof (state)\nthis:\n  (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> X \\<le> the_inv f y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "have \"... = (\\<forall>x \\<in> X. x \\<le> ?g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> X \\<le> the_inv f y) =\n    (\\<forall>x\\<in>X. x \\<le> the_inv f y)", "by (simp add: Sup_le_iff)"], ["proof (state)\nthis:\n  (\\<Squnion> X \\<le> the_inv f y) = (\\<forall>x\\<in>X. x \\<le> the_inv f y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "also"], ["proof (state)\nthis:\n  (\\<Squnion> X \\<le> the_inv f y) = (\\<forall>x\\<in>X. x \\<le> the_inv f y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "have \"... = (\\<forall>x \\<in> X. f x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. x \\<le> the_inv f y) =\n    (\\<forall>x\\<in>X. f x \\<le> y)", "by (metis (mono_tags, lifting) UNIV_I f_the_inv_into_f h monoD ord_embed_alt ord_embed_inj ord_iso_alt)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. x \\<le> the_inv f y) = (\\<forall>x\\<in>X. f x \\<le> y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "also"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. x \\<le> the_inv f y) = (\\<forall>x\\<in>X. f x \\<le> y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "have \"... = (\\<Squnion> (f ` X) \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. f x \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)", "by (simp add: SUP_le_iff)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. f x \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "finally"], ["proof (chain)\npicking this:\n  (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)", "have \"(f (\\<Squnion>X) \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)\""], ["proof (prove)\nusing this:\n  (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)\n\ngoal (1 subgoal):\n 1. (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)", "."], ["proof (state)\nthis:\n  (f (\\<Squnion> X) \\<le> y) = (\\<Squnion> (f ` X) \\<le> y)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "}"], ["proof (state)\nthis:\n  (f (\\<Squnion> X) \\<le> ?y2) = (\\<Squnion> (f ` X) \\<le> ?y2)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "hence \"f (\\<Squnion>X) = \\<Squnion> (f ` X)\""], ["proof (prove)\nusing this:\n  (f (\\<Squnion> X) \\<le> ?y2) = (\\<Squnion> (f ` X) \\<le> ?y2)\n\ngoal (1 subgoal):\n 1. f (\\<Squnion> X) = \\<Squnion> (f ` X)", "by (meson dual_order.antisym order_refl)"], ["proof (state)\nthis:\n  f (\\<Squnion> X) = \\<Squnion> (f ` X)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "}"], ["proof (state)\nthis:\n  f (\\<Squnion> ?X2) = \\<Squnion> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. ord_iso f \\<Longrightarrow> Sup \\<circ> (`) f = f \\<circ> Sup", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (\\<Squnion> ?X2) = \\<Squnion> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) f = f \\<circ> Sup", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  f (\\<Squnion> ?X2) = \\<Squnion> (f ` ?X2)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (Sup \\<circ> (`) f) x = (f \\<circ> Sup) x", "by simp"], ["proof (state)\nthis:\n  Sup \\<circ> (`) f = f \\<circ> Sup\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Right preservation of sups and infs is trivial.\\<close>"], ["", "lemma fSup_distr: \"Sup_pres (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres (\\<lambda>x. x \\<circ> f)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       ((\\<lambda>x. x \\<circ> f) \\<circ> Sup) x xa =\n       (Sup \\<circ> (`) (\\<lambda>x. x \\<circ> f)) x xa", "by (simp add: image_comp)"], ["", "lemma fSup_distr_var: \"\\<Squnion>F \\<circ> g = (\\<Squnion>f \\<in> F. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> F \\<circ> g = (\\<Squnion>f\\<in>F. f \\<circ> g)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<Squnion> F \\<circ> g) x = (\\<Squnion>f\\<in>F. f \\<circ> g) x", "by (simp add: image_comp)"], ["", "lemma fInf_distr: \"Inf_pres (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres (\\<lambda>x. x \\<circ> f)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<Sqinter> x) (f xa) =\n       (\\<Sqinter>x\\<in>x. (\\<lambda>xa. x (f xa))) xa", "by (smt INF_apply Inf_fun_def Sup.SUP_cong)"], ["", "lemma fInf_distr_var: \"\\<Sqinter>F \\<circ> g = (\\<Sqinter>f \\<in> F. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> F \\<circ> g = (\\<Sqinter>f\\<in>F. f \\<circ> g)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<Sqinter> F) (g x) = (\\<Sqinter>f\\<in>F. (\\<lambda>x. f (g x))) x", "by (smt INF_apply INF_cong INF_image Inf_apply image_comp image_def image_image)"], ["", "text \\<open>The next set of lemma revisits the preservation properties in the function space.\\<close>"], ["", "lemma fSup_subdistl: \n  assumes \"mono (f::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup", "using assms"], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup", "by (simp add: fun_isol supdistl_iso)"], ["", "lemma fSup_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<Squnion>g \\<in> G. f \\<circ> g) \\<le> f \\<circ> \\<Squnion>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    \\<Squnion> ((\\<circ>) f ` G) \\<le> f \\<circ> \\<Squnion> G", "by (simp add: fun_isol mono_Sup)"], ["", "lemma fInf_subdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)", "by (simp add: fun_isol subdistl_iso)"], ["", "lemma fInf_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> \\<Sqinter>G \\<le> (\\<Sqinter>g \\<in> G. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    f \\<circ> \\<Sqinter> G \\<le> \\<Sqinter> ((\\<circ>) f ` G)", "by (simp add: fun_isol mono_Inf)"], ["", "lemma fSup_distl: \"Sup_pres f \\<Longrightarrow> Sup_pres ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> Sup_pres ((\\<circ>) f)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> Sup) x = (Sup \\<circ> (`) f) x \\<Longrightarrow>\n    \\<forall>x xa.\n       ((\\<circ>) f \\<circ> Sup) x xa = (Sup \\<circ> (`) ((\\<circ>) f)) x xa", "by (simp add: image_comp)"], ["", "lemma fSup_distl_var: \"Sup_pres f \\<Longrightarrow> f \\<circ> \\<Squnion>G = (\\<Squnion>g \\<in> G. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow>\n    f \\<circ> \\<Squnion> G = \\<Squnion> ((\\<circ>) f ` G)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> Sup) x = (Sup \\<circ> (`) f) x \\<Longrightarrow>\n    \\<forall>x.\n       (f \\<circ> \\<Squnion> G) x = (\\<Squnion> ((\\<circ>) f ` G)) x", "by (simp add: image_comp)"], ["", "lemma fInf_distl: \"Inf_pres f \\<Longrightarrow> Inf_pres ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> Inf_pres ((\\<circ>) f)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> Inf) x = (Inf \\<circ> (`) f) x \\<Longrightarrow>\n    \\<forall>x xa.\n       ((\\<circ>) f \\<circ> Inf) x xa = (Inf \\<circ> (`) ((\\<circ>) f)) x xa", "by (simp add: image_comp)"], ["", "lemma fInf_distl_var: \"Inf_pres f \\<Longrightarrow> f \\<circ> \\<Sqinter>G = (\\<Sqinter>g \\<in> G. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow>\n    f \\<circ> \\<Sqinter> G = \\<Sqinter> ((\\<circ>) f ` G)", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> Inf) x = (Inf \\<circ> (`) f) x \\<Longrightarrow>\n    \\<forall>x.\n       (f \\<circ> \\<Sqinter> G) x = (\\<Sqinter> ((\\<circ>) f ` G)) x", "by (simp add: image_comp)"], ["", "text \\<open>Downsets preserve infs whereas upsets preserve sups.\\<close>"], ["", "lemma Inf_pres_downset: \"Inf_pres (\\<down>::'a::complete_lattice_with_dual \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres \\<down>", "unfolding downset_prop fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. {y. y \\<le> x}) \\<circ> Inf) x =\n       (\\<Inter> \\<circ> (`) (\\<lambda>x. {y. y \\<le> x})) x", "by (safe, simp_all add: le_Inf_iff)"], ["", "lemma Sup_dual_upset: \"Sup_dual (\\<up>::'a::complete_lattice_with_dual \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_dual \\<up>", "unfolding upset_prop fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<lambda>x. Collect ((\\<le>) x)) \\<circ> Sup) x =\n       (\\<Inter> \\<circ> (`) (\\<lambda>x. Collect ((\\<le>) x))) x", "by (safe, simp_all add: Sup_le_iff)"], ["", "text \\<open>Images of Sup-morphisms are closed under Sups and images of Inf-morphisms are closed under Infs.\\<close>"], ["", "lemma Sup_pres_Sup_closed: \"Sup_pres f \\<Longrightarrow> Sup_closed_set (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> Sup_closed_set (range f)", "by (metis (mono_tags, lifting) Sup_closed_set_def comp_eq_elim range_eqI subset_image_iff)"], ["", "lemma Inf_pres_Inf_closed: \"Inf_pres f \\<Longrightarrow> Inf_closed_set (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> Inf_closed_set (range f)", "by (metis (mono_tags, lifting) Inf_closed_set_def comp_eq_elim range_eqI subset_image_iff)"], ["", "text \\<open>It is well known that functions into complete lattices form complete lattices. Here, such results are shown for\nthe subclasses of isotone functions, where additional closure conditions must be respected.\\<close>"], ["", "typedef (overloaded) 'a iso = \"{f::'a::order \\<Rightarrow> 'a::order. mono f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. mono f}", "by (metis Abs_ord_homset_cases ord_homset_def)"], ["", "setup_lifting type_definition_iso"], ["", "instantiation iso :: (complete_lattice) complete_lattice\nbegin"], ["", "lift_definition Inf_iso :: \"'a::complete_lattice iso set \\<Rightarrow> 'a iso\" is Sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x. x \\<in> set \\<Longrightarrow> mono x) \\<Longrightarrow>\n       mono (\\<Squnion> set)", "by (metis (mono_tags, lifting) SUP_subset_mono Sup_apply mono_def subsetI)"], ["", "lift_definition Sup_iso :: \"'a::complete_lattice iso set \\<Rightarrow> 'a iso\" is Inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x. x \\<in> set \\<Longrightarrow> mono x) \\<Longrightarrow>\n       mono (\\<Sqinter> set)", "by (smt INF_lower2 Inf_apply le_INF_iff mono_def)"], ["", "lift_definition bot_iso :: \"'a::complete_lattice iso\" is \"\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<top>", "by (simp add: monoI)"], ["", "lift_definition sup_iso :: \"'a::complete_lattice iso \\<Rightarrow> 'a iso \\<Rightarrow> 'a iso\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<sqinter> fun2)", "by (smt inf_apply inf_mono monoD monoI)"], ["", "lift_definition top_iso :: \"'a::complete_lattice iso\" is \"\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<bottom>", "by (simp add: mono_def)"], ["", "lift_definition inf_iso :: \"'a::complete_lattice iso \\<Rightarrow> 'a iso \\<Rightarrow> 'a iso\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<squnion> fun2)", "by (smt mono_def sup.mono sup_apply)"], ["", "lift_definition less_eq_iso :: \"'a::complete_lattice iso \\<Rightarrow> 'a iso \\<Rightarrow> bool\" is \"(\\<ge>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_iso :: \"'a::complete_lattice iso \\<Rightarrow> 'a iso \\<Rightarrow> bool\" is \"(>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iso, complete_lattice_class)", "by (intro_classes; transfer, simp_all add: less_fun_def Sup_upper Sup_least Inf_lower Inf_greatest)"], ["", "end"], ["", "text \\<open>Duality has been baked into this result because of its relevance for predicate transformers. A proof\nwhere Sups are mapped to Sups and Infs to Infs is certainly possible, but two instantiation of the same type\nand the same classes are unfortunately impossible. Interpretations could be used instead.\n\nA corresponding result for Inf-preseving functions and Sup-lattices, is proved in components on transformers,\nas more advanced properties about Inf-preserving functions are needed.\\<close>"], ["", "subsection \\<open>Alternative Definitions for Complete Boolean Algebras\\<close>"], ["", "text \\<open>The current definitions of complete boolean algebras deviates from that in most textbooks in that\na distributive law with infinite sups and infinite infs is used. There are interesting applications, for instance \nin topology, where weaker laws are needed --- for instance for frames and locales.\\<close>"], ["", "class complete_heyting_algebra = complete_lattice +\n  assumes ch_dist: \"x \\<sqinter> \\<Squnion>Y = (\\<Squnion>y \\<in> Y. x \\<sqinter> y)\""], ["", "text \\<open>Complete Heyting algebras are also known as frames or locales (they differ with respect to their morphisms).\\<close>"], ["", "class complete_co_heyting_algebra = complete_lattice +\n  assumes co_ch_dist: \"x \\<squnion> \\<Sqinter>Y = (\\<Sqinter>y \\<in> Y. x \\<squnion> y)\""], ["", "class complete_boolean_algebra_alt = complete_lattice + boolean_algebra"], ["", "instance set :: (type) complete_boolean_algebra_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, complete_boolean_algebra_alt_class)", ".."], ["", "context complete_boolean_algebra_alt\nbegin"], ["", "subclass complete_heyting_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_heyting_algebra Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "fix x Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "have \"(x \\<sqinter> \\<Squnion>Y \\<le> t) = (\\<Squnion>Y \\<le> -x \\<squnion> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n    (\\<Squnion> Y \\<le> - x \\<squnion> t)", "by (simp add: inf.commute shunt1[symmetric])"], ["proof (state)\nthis:\n  (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n  (\\<Squnion> Y \\<le> - x \\<squnion> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n  (\\<Squnion> Y \\<le> - x \\<squnion> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "have \"... = (\\<forall>y \\<in> Y. y \\<le> -x \\<squnion> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> Y \\<le> - x \\<squnion> t) =\n    (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t)", "using Sup_le_iff"], ["proof (prove)\nusing this:\n  (\\<Squnion> ?A \\<le> ?b) = (\\<forall>a\\<in>?A. a \\<le> ?b)\n\ngoal (1 subgoal):\n 1. (\\<Squnion> Y \\<le> - x \\<squnion> t) =\n    (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t)", "by blast"], ["proof (state)\nthis:\n  (\\<Squnion> Y \\<le> - x \\<squnion> t) =\n  (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "also"], ["proof (state)\nthis:\n  (\\<Squnion> Y \\<le> - x \\<squnion> t) =\n  (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "have \"... = (\\<forall>y \\<in> Y. x \\<sqinter> y \\<le> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t) =\n    (\\<forall>y\\<in>Y. x \\<sqinter> y \\<le> t)", "by (simp add: inf.commute shunt1)"], ["proof (state)\nthis:\n  (\\<forall>y\\<in>Y. y \\<le> - x \\<squnion> t) =\n  (\\<forall>y\\<in>Y. x \\<sqinter> y \\<le> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "finally"], ["proof (chain)\npicking this:\n  (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n  (\\<forall>y\\<in>Y. x \\<sqinter> y \\<le> t)", "have \"(x \\<sqinter> \\<Squnion>Y \\<le> t) = ((\\<Squnion>y\\<in>Y. x \\<sqinter> y) \\<le> t)\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n  (\\<forall>y\\<in>Y. x \\<sqinter> y \\<le> t)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n    (\\<Squnion> ((\\<sqinter>) x ` Y) \\<le> t)", "by (simp add: local.SUP_le_iff)"], ["proof (state)\nthis:\n  (x \\<sqinter> \\<Squnion> Y \\<le> t) =\n  (\\<Squnion> ((\\<sqinter>) x ` Y) \\<le> t)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "}"], ["proof (state)\nthis:\n  (x \\<sqinter> \\<Squnion> Y \\<le> ?t2) =\n  (\\<Squnion> ((\\<sqinter>) x ` Y) \\<le> ?t2)\n\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "thus \"x \\<sqinter> \\<Squnion>Y = (\\<Squnion>y\\<in>Y. x \\<sqinter> y)\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> \\<Squnion> Y \\<le> ?t2) =\n  (\\<Squnion> ((\\<sqinter>) x ` Y) \\<le> ?t2)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "using eq_iff"], ["proof (prove)\nusing this:\n  (x \\<sqinter> \\<Squnion> Y \\<le> ?t2) =\n  (\\<Squnion> ((\\<sqinter>) x ` Y) \\<le> ?t2)\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)", "by blast"], ["proof (state)\nthis:\n  x \\<sqinter> \\<Squnion> Y = \\<Squnion> ((\\<sqinter>) x ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subclass complete_co_heyting_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_co_heyting_algebra Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top>", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<squnion> \\<Sqinter> Y = \\<Sqinter> ((\\<squnion>) x ` Y)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x Y.\n       x \\<squnion> \\<Sqinter> Y \\<le> \\<Sqinter> ((\\<squnion>) x ` Y)\n 2. \\<And>x Y.\n       \\<Sqinter> ((\\<squnion>) x ` Y) \\<le> x \\<squnion> \\<Sqinter> Y", "apply (simp add: INF_greatest Inf_lower2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y.\n       \\<Sqinter> ((\\<squnion>) x ` Y) \\<le> x \\<squnion> \\<Sqinter> Y", "by (meson eq_refl le_INF_iff le_Inf_iff shunt2)"], ["", "lemma de_morgan1: \"-(\\<Squnion>X) = (\\<Sqinter>x \\<in> X. -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "have \"(y \\<le> -(\\<Squnion>X)) = (\\<Squnion>X \\<le> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<le> - \\<Squnion> X) = (\\<Squnion> X \\<le> - y)", "using compl_le_swap1"], ["proof (prove)\nusing this:\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n\ngoal (1 subgoal):\n 1. (y \\<le> - \\<Squnion> X) = (\\<Squnion> X \\<le> - y)", "by blast"], ["proof (state)\nthis:\n  (y \\<le> - \\<Squnion> X) = (\\<Squnion> X \\<le> - y)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "also"], ["proof (state)\nthis:\n  (y \\<le> - \\<Squnion> X) = (\\<Squnion> X \\<le> - y)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "have \"... = (\\<forall>x \\<in> X. x \\<le> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> X \\<le> - y) = (\\<forall>x\\<in>X. x \\<le> - y)", "by (simp add: Sup_le_iff)"], ["proof (state)\nthis:\n  (\\<Squnion> X \\<le> - y) = (\\<forall>x\\<in>X. x \\<le> - y)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "also"], ["proof (state)\nthis:\n  (\\<Squnion> X \\<le> - y) = (\\<forall>x\\<in>X. x \\<le> - y)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "have \"... = (\\<forall>x \\<in> X. y \\<le> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. x \\<le> - y) = (\\<forall>x\\<in>X. y \\<le> - x)", "using compl_le_swap1"], ["proof (prove)\nusing this:\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. x \\<le> - y) = (\\<forall>x\\<in>X. y \\<le> - x)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. x \\<le> - y) = (\\<forall>x\\<in>X. y \\<le> - x)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "also"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. x \\<le> - y) = (\\<forall>x\\<in>X. y \\<le> - x)\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "have \"... = (y \\<le> (\\<Sqinter>x \\<in> X. -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. y \\<le> - x) = (y \\<le> \\<Sqinter> (uminus ` X))", "using le_INF_iff"], ["proof (prove)\nusing this:\n  (?u \\<le> \\<Sqinter> (?f ` ?A)) = (\\<forall>i\\<in>?A. ?u \\<le> ?f i)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. y \\<le> - x) = (y \\<le> \\<Sqinter> (uminus ` X))", "by force"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>X. y \\<le> - x) = (y \\<le> \\<Sqinter> (uminus ` X))\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "finally"], ["proof (chain)\npicking this:\n  (y \\<le> - \\<Squnion> X) = (y \\<le> \\<Sqinter> (uminus ` X))", "have \"(y \\<le> -(\\<Squnion>X)) = (y \\<le>(\\<Sqinter>x \\<in> X. -x))\""], ["proof (prove)\nusing this:\n  (y \\<le> - \\<Squnion> X) = (y \\<le> \\<Sqinter> (uminus ` X))\n\ngoal (1 subgoal):\n 1. (y \\<le> - \\<Squnion> X) = (y \\<le> \\<Sqinter> (uminus ` X))", "."], ["proof (state)\nthis:\n  (y \\<le> - \\<Squnion> X) = (y \\<le> \\<Sqinter> (uminus ` X))\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "}"], ["proof (state)\nthis:\n  (?y2 \\<le> - \\<Squnion> X) = (?y2 \\<le> \\<Sqinter> (uminus ` X))\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?y2 \\<le> - \\<Squnion> X) = (?y2 \\<le> \\<Sqinter> (uminus ` X))\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "using antisym"], ["proof (prove)\nusing this:\n  (?y2 \\<le> - \\<Squnion> X) = (?y2 \\<le> \\<Sqinter> (uminus ` X))\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. - \\<Squnion> X = \\<Sqinter> (uminus ` X)", "by blast"], ["proof (state)\nthis:\n  - \\<Squnion> X = \\<Sqinter> (uminus ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma de_morgan2: \"-(\\<Sqinter>X) = (\\<Squnion>x \\<in> X. -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<Sqinter> X = \\<Squnion> (uminus ` X)", "by (metis de_morgan1 ba_dual.dual_iff ba_dual.image_dual pointfree_idE)"], ["", "end"], ["", "class complete_boolean_algebra_alt_with_dual = complete_lattice_with_dual + complete_boolean_algebra_alt"], ["", "instantiation set :: (type) complete_boolean_algebra_alt_with_dual\nbegin"], ["", "definition dual_set :: \"'a set \\<Rightarrow> 'a set\" where\n  \"dual_set = uminus\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a set, complete_boolean_algebra_alt_with_dual_class)", "by intro_classes (simp_all add: ba_dual.inj_dual dual_set_def comp_def uminus_Sup id_def)"], ["", "end"], ["", "context complete_boolean_algebra_alt\nbegin"], ["", "sublocale cba_dual: complete_boolean_algebra_alt_with_dual _ _ _ _ _ _ _ _ uminus _ _"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_boolean_algebra_alt_with_dual Inf Sup (\\<sqinter>)\n     (\\<le>) (<) (\\<squnion>) \\<bottom> \\<top> uminus (-) uminus", "by unfold_locales (auto simp: de_morgan2 de_morgan1)"], ["", "end"], ["", "subsection \\<open>Atomic Boolean Algebras\\<close>"], ["", "text \\<open>Next, atomic boolean algebras are defined.\\<close>"], ["", "context bounded_lattice\nbegin"], ["", "text \\<open>Atoms are covers of bottom.\\<close>"], ["", "definition \"atom x = (x \\<noteq> \\<bottom> \\<and> \\<not>(\\<exists>y. \\<bottom> < y \\<and> y < x))\""], ["", "definition \"atom_map x = {y. atom y \\<and> y \\<le> x}\""], ["", "lemma atom_map_def_var: \"atom_map x = \\<down>x \\<inter> Collect atom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map x = \\<down> x \\<inter> Collect atom", "unfolding atom_map_def downset_def downset_set_def comp_def atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. (y \\<noteq> \\<bottom> \\<and>\n         \\<not> (\\<exists>ya>\\<bottom>. ya < y)) \\<and>\n        y \\<le> x} =\n    {y. Bex (\\<eta> x) ((\\<le>) y)} \\<inter>\n    {x. x \\<noteq> \\<bottom> \\<and> \\<not> (\\<exists>y>\\<bottom>. y < x)}", "by fastforce"], ["", "lemma atom_map_atoms: \"\\<Union>(range atom_map) = Collect atom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range atom_map) = Collect atom", "unfolding atom_map_def atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x.\n        {y. (y \\<noteq> \\<bottom> \\<and>\n             \\<not> (\\<exists>ya>\\<bottom>. ya < y)) \\<and>\n            y \\<le> x}) =\n    {x. x \\<noteq> \\<bottom> \\<and> \\<not> (\\<exists>y>\\<bottom>. y < x)}", "by auto"], ["", "end"], ["", "typedef (overloaded) 'a atoms = \"range (atom_map::'a::bounded_lattice \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range atom_map", "by blast"], ["", "setup_lifting type_definition_atoms"], ["", "definition at_map :: \"'a::bounded_lattice \\<Rightarrow> 'a atoms\" where\n  \"at_map = Abs_atoms \\<circ> atom_map\""], ["", "class atomic_boolean_algebra = boolean_algebra +\n  assumes atomicity: \"x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<exists>y. atom y \\<and> y \\<le> x)\""], ["", "class complete_atomic_boolean_algebra = complete_lattice + atomic_boolean_algebra\n\nbegin"], ["", "subclass complete_boolean_algebra_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_boolean_algebra_alt Inf Sup (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top> (-) uminus", ".."], ["", "end"], ["", "text \\<open>Here are two equivalent definitions for atoms; first in boolean algebras, and then in complete \nboolean algebras.\\<close>"], ["", "context boolean_algebra\nbegin"], ["", "text \\<open>The following two conditions are taken from Koppelberg's book~\\cite{Koppelberg89}.\\<close>"], ["", "lemma atom_neg: \"atom x \\<Longrightarrow> x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. x \\<le> y \\<or> x \\<le> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow>\n    x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. x \\<le> y \\<or> x \\<le> - y)", "by (metis atom_def dual_order.order_iff_strict inf.cobounded1 inf.commute meet_shunt)"], ["", "lemma atom_sup: \"(\\<forall>y. x \\<le> y \\<or> x \\<le> -y) \\<Longrightarrow> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. x \\<le> y \\<or> x \\<le> - y \\<Longrightarrow>\n    \\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)", "by (metis inf.orderE le_supI1 shunt2)"], ["", "lemma sup_atom: \"x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)) \\<Longrightarrow> atom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>y z.\n        (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)\\<rbrakk>\n    \\<Longrightarrow> atom x", "unfolding atom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>y z.\n        (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)\\<rbrakk>\n    \\<Longrightarrow> x \\<noteq> \\<bottom> \\<and>\n                      \\<not> (\\<exists>y>\\<bottom>. y < x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        \\<forall>y z.\n           (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z);\n        \\<bottom> < y; y < x\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis bot_less inf.absorb2 less_le_not_le meet_shunt sup_compl_top)"], ["", "lemma atom_sup_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x =\n    (x \\<noteq> \\<bottom> \\<and>\n     (\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)))", "by  (standard, auto simp add: atom_neg atom_sup sup_atom)"], ["", "lemma atom_neg_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>y z. x \\<le> y \\<or> x \\<le> -y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x =\n    (x \\<noteq> \\<bottom> \\<and>\n     (\\<forall>y z. x \\<le> y \\<or> x \\<le> - y))", "by  (standard, auto simp add: atom_neg atom_sup sup_atom)"], ["", "lemma atom_map_bot_pres: \"atom_map \\<bottom> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map \\<bottom> = {}", "using atom_def atom_map_def le_bot"], ["proof (prove)\nusing this:\n  atom ?x =\n  (?x \\<noteq> \\<bottom> \\<and> \\<not> (\\<exists>y>\\<bottom>. y < ?x))\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n  ?a \\<le> \\<bottom> \\<Longrightarrow> ?a = \\<bottom>\n\ngoal (1 subgoal):\n 1. atom_map \\<bottom> = {}", "by auto"], ["", "lemma atom_map_top_pres: \"atom_map \\<top> = Collect atom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map \\<top> = Collect atom", "using atom_map_def"], ["proof (prove)\nusing this:\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. atom_map \\<top> = Collect atom", "by auto"], ["", "end"], ["", "context complete_boolean_algebra_alt\nbegin"], ["", "lemma atom_Sup: \"\\<And>Y. x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>y. x \\<le> y \\<or> x \\<le> -y) \\<Longrightarrow> ((\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        \\<forall>y. x \\<le> y \\<or> x \\<le> - y\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y\\<in>Y. x \\<le> y) =\n                         (x \\<le> \\<Squnion> Y)", "by (metis Sup_least Sup_upper2 compl_le_swap1 le_iff_inf meet_shunt)"], ["", "lemma Sup_atom: \"x \\<noteq> \\<bottom> \\<Longrightarrow> (\\<forall>Y. (\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y)) \\<Longrightarrow> atom x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>Y.\n        (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\\<rbrakk>\n    \\<Longrightarrow> atom x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>Y.\n        (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\\<rbrakk>\n    \\<Longrightarrow> atom x", "assume h1: \"x \\<noteq> \\<bottom>\"\n  and h2: \"\\<forall>Y. (\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y)\""], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  \\<forall>Y. (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>Y.\n        (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\\<rbrakk>\n    \\<Longrightarrow> atom x", "hence \"\\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)\""], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  \\<forall>Y. (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. \\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)", "by (smt insert_iff sup_Sup sup_bot.right_neutral)"], ["proof (state)\nthis:\n  \\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<bottom>;\n     \\<forall>Y.\n        (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)\\<rbrakk>\n    \\<Longrightarrow> atom x", "thus \"atom x\""], ["proof (prove)\nusing this:\n  \\<forall>y z. (x \\<le> y \\<or> x \\<le> z) = (x \\<le> y \\<squnion> z)\n\ngoal (1 subgoal):\n 1. atom x", "by (simp add: h1 sup_atom)"], ["proof (state)\nthis:\n  atom x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_Sup_iff: \"atom x = (x \\<noteq> \\<bottom> \\<and> (\\<forall>Y. (\\<exists>y \\<in> Y. x \\<le> y) = (x \\<le> \\<Squnion>Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x =\n    (x \\<noteq> \\<bottom> \\<and>\n     (\\<forall>Y. (\\<exists>y\\<in>Y. x \\<le> y) = (x \\<le> \\<Squnion> Y)))", "by standard (auto simp: atom_neg atom_Sup Sup_atom)"], ["", "end"], ["", "end"]]}