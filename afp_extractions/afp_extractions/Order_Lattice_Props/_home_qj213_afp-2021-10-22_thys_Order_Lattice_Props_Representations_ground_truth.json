{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Representations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma ds_SSup_inv: \"ds \\<circ> SSup = (id::'a::complete_lattice downset \\<Rightarrow> 'a downset)\"", "lemma SSup_ds_inv: \"SSup \\<circ> ds = (id::'a::complete_lattice \\<Rightarrow> 'a)\"", "lemma ds_iso: \"mono ds\"", "lemma ds_faithful: \"ds x \\<le> ds y \\<Longrightarrow> x \\<le> (y::'a::order)\"", "lemma ds_inj: \"inj (ds::'a::order \\<Rightarrow> 'a downset)\"", "lemma ds_surj: \"surj ds\"", "lemma ds_bij: \"bij (ds::'a::order \\<Rightarrow> 'a downset)\"", "lemma ds_ord_iso: \"ord_iso ds\"", "lemma map_ds_prop: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\" \n  shows \"map_ds f \\<circ> ds = ds \\<circ> f\"", "lemma map_ds_prop2: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"map_ds f \\<circ> ds = ds \\<circ> id f\"", "lemma map_ds_iso_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> mono (map_ds f)\"", "lemma map_SSup_iso_pres: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"mono F \\<Longrightarrow> mono (map_SSup F)\"", "lemma map_SSup_prop: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"ds \\<circ> map_SSup F = F \\<circ> ds\"", "lemma map_SSup_prop2: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"ds \\<circ> map_SSup F = id F \\<circ> ds\"", "lemma map_ds_func1: \"map_ds id = (id::'a::complete_lattice downset\\<Rightarrow> 'a downset)\"", "lemma map_ds_func2: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"map_ds (f \\<circ> g) = map_ds f \\<circ> map_ds g\"", "lemma map_SSup_func1: \"map_SSup (id::'a::complete_lattice downset\\<Rightarrow> 'a downset) = id\"", "lemma map_SSup_func2: \n  fixes F :: \"'c::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  and G :: \"'a::complete_lattice downset \\<Rightarrow> 'c downset\"\n  shows \"map_SSup (F \\<circ> G) = map_SSup F \\<circ> map_SSup G\"", "lemma map_SSup_map_ds_inv: \"map_SSup \\<circ> map_ds = (id::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma map_ds_map_SSup_inv: \"map_ds \\<circ> map_SSup = (id::('a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\"", "lemma inj_map_ds: \"inj (map_ds::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\"", "lemma inj_map_SSup: \"inj (map_SSup::('a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma map_ds_map_SSup_iff: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f = map_ds g) = (map_SSup f = g)\"", "lemma surj_map_ds: \"surj (map_ds::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\"", "lemma surj_map_SSup: \"surj (map_SSup::('a::complete_lattice_with_dual downset \\<Rightarrow> 'b::complete_lattice_with_dual downset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma us_ds: \"us = Abs_upset \\<circ> (`) \\<partial> \\<circ> Rep_downset \\<circ> ds \\<circ> (\\<partial>::'a::ord_with_dual \\<Rightarrow> 'a)\"", "lemma IInf_SSup: \"IInf = \\<partial> \\<circ> SSup \\<circ> Abs_downset \\<circ> (`) (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> Rep_upset\"", "lemma us_IInf_inv: \"us \\<circ> IInf = (id::'a::complete_lattice_with_dual upset \\<Rightarrow> 'a upset)\"", "lemma IInf_us_inv: \"IInf \\<circ> us = (id::'a::complete_lattice_with_dual \\<Rightarrow> 'a)\"", "lemma us_iso: \"x \\<le> y \\<Longrightarrow> us x \\<le> us (y::'a::order_with_dual)\"", "lemma us_faithful: \"us x \\<le> us y \\<Longrightarrow> x \\<le> (y::'a::order_with_dual)\"", "lemma us_inj: \"inj (us::'a::order_with_dual \\<Rightarrow> 'a upset)\"", "lemma us_surj: \"surj (us::'a::order_with_dual \\<Rightarrow> 'a upset)\"", "lemma us_bij: \"bij (us::'a::order_with_dual \\<Rightarrow> 'a upset)\"", "lemma us_ord_iso: \"ord_iso (us::'a::order_with_dual \\<Rightarrow> 'a upset)\"", "lemma map_us_prop: \"map_us f \\<circ> (us::'a::complete_lattice_with_dual \\<Rightarrow> 'a upset) = us \\<circ> id f\"", "lemma map_IInf_prop: \"(us::'a::complete_lattice_with_dual \\<Rightarrow> 'a upset) \\<circ> map_IInf F = id F \\<circ> us\"", "lemma map_us_func1: \"map_us id = (id::'a::complete_lattice_with_dual upset \\<Rightarrow> 'a upset)\"", "lemma map_us_func2: \n  fixes f :: \"'c::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  and g :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'c\"\n  shows \"map_us (f \\<circ> g) = map_us f \\<circ> map_us g\"", "lemma map_IInf_func1: \"map_IInf id = (id::'a::complete_lattice_with_dual \\<Rightarrow> 'a)\"", "lemma map_IInf_func2: \n  fixes F :: \"'c::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset\"\n  and G :: \"'a::complete_lattice_with_dual upset \\<Rightarrow> 'c upset\"\n  shows \"map_IInf (F \\<circ> G) = map_IInf F \\<circ> map_IInf G\"", "lemma map_IInf_map_us_inv: \"map_IInf \\<circ> map_us = (id::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma map_us_map_IInf_inv: \"map_us \\<circ> map_IInf = (id::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\"", "lemma inj_map_us: \"inj (map_us::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\"", "lemma inj_map_IInf: \"inj (map_IInf::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma map_us_map_IInf_iff: \n  fixes g :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\" \n  shows \"(f = map_us g) = (map_IInf f = g)\"", "lemma map_us_mono_pres: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"mono f \\<Longrightarrow> mono (map_us f)\"", "lemma map_IInf_mono_pres: \n  fixes F :: \"'a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset\"\n  shows \"mono F \\<Longrightarrow> mono (map_IInf F)\"", "lemma surj_map_us: \"surj (map_us::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\"", "lemma surj_map_IInf: \"surj (map_IInf::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\"", "lemma atom_map_compl_pres: \"atom_map (-x) = Collect atom - atom_map x\"", "lemma atom_map_sup_pres: \"atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y\"", "lemma atom_map_inf_pres: \"atom_map (x \\<sqinter> y) = atom_map x \\<inter> atom_map y\"", "lemma atom_map_minus_pres: \"atom_map (x - y) = atom_map x - atom_map y\"", "lemma at_map_bot_pres: \"at_map \\<bottom> = \\<bottom>\"", "lemma at_map_top_pres: \"at_map \\<top> = \\<top>\"", "lemma at_map_compl_pres: \"at_map \\<circ> uminus = uminus \\<circ> at_map\"", "lemma at_map_sup_pres: \"at_map (x \\<squnion> y) = at_map x \\<squnion> at_map y\"", "lemma at_map_inf_pres: \"at_map (x \\<sqinter> y) = at_map x \\<sqinter> at_map y\"", "lemma at_map_minus_pres: \"at_map (x - y) = at_map x - at_map y\"", "lemma inj_atom_map: \"inj atom_map\"", "lemma atom_map_atom_pres: \"atom x \\<Longrightarrow> atom_map x = {x}\"", "lemma atom_map_atom_pres2: \"atom x \\<Longrightarrow> atom (atom_map x)\"", "lemma inj_at_map: \"inj (at_map::'a::atomic_boolean_algebra \\<Rightarrow> 'a atoms)\"", "lemma at_map_atom_pres: \"atom (x::'a::atomic_boolean_algebra) \\<Longrightarrow> at_map x = Abs_atoms {x}\"", "lemma at_map_atom_pres2: \"atom (x::'a::atomic_boolean_algebra) \\<Longrightarrow> atom (at_map x)\"", "lemma surj_atom_map: \"Y \\<subseteq> Collect atom \\<Longrightarrow> Y = atom_map (\\<Squnion>Y)\"", "lemma atom_map_Sup_pres: \"atom_map (\\<Squnion>X) = (\\<Union>x \\<in> X. atom_map x)\"", "lemma atom_map_Sup_pres_var: \"atom_map \\<circ> Sup = Sup \\<circ> (`) atom_map\"", "lemma atom_map_Inf_pres: \"atom_map (\\<Sqinter>X) = Collect atom \\<inter> (\\<Inter>x \\<in> X. atom_map x)\"", "lemma  surj_at_map_var: \"at_map \\<circ> Sup \\<circ> Rep_atoms = (id::'a::complete_boolean_algebra_alt atoms \\<Rightarrow> 'a atoms)\"", "lemma surj_at_map: \"surj (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\"", "lemma at_map_Sup_pres: \"at_map \\<circ> Sup = Sup \\<circ> (`) (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\"", "lemma at_map_Sup_pres_var: \"at_map (\\<Squnion>X) = (\\<Squnion>(x::'a::complete_boolean_algebra_alt) \\<in> X. (at_map x))\"", "lemma at_map_Inf_pres: \"at_map (\\<Sqinter>X) = Abs_atoms (Collect atom \\<sqinter> (\\<Sqinter>x \\<in> X. (Rep_atoms (at_map (x::'a::complete_boolean_algebra_alt)))))\"", "lemma at_map_Inf_pres_var: \"at_map \\<circ> Inf = Inf \\<circ> (`) (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\"", "lemma \"Sup \\<circ> atom_map = (id::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a)\"", "lemma inj_at_map_var: \"Sup \\<circ> Rep_atoms \\<circ> at_map  = (id ::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a)\"", "lemma bij_at_map: \"bij (at_map::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a atoms)\""], "translations": [["", "lemma ds_SSup_inv: \"ds \\<circ> SSup = (id::'a::complete_lattice downset \\<Rightarrow> 'a downset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> SSup = id", "unfolding ds_def SSup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_downset \\<circ> \\<down> \\<circ> (Sup \\<circ> Rep_downset) = id", "by (smt Rep_downset Rep_downset_inverse cSup_atMost eq_id_iff imageE o_def ord_class.atMost_def ord_class.downset_prop)"], ["", "lemma SSup_ds_inv: \"SSup \\<circ> ds = (id::'a::complete_lattice \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SSup \\<circ> ds = id", "unfolding ds_def SSup_def fun_eq_iff id_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Squnion> Rep_downset (Abs_downset (\\<down> x)) = x", "by (simp add: Abs_downset_inverse pointfree_idE)"], ["", "instantiation downset :: (ord) order\nbegin"], ["", "lift_definition less_eq_downset :: \"'a downset \\<Rightarrow> 'a downset \\<Rightarrow> bool\" is \"(\\<lambda>X Y. Rep_downset X \\<subseteq> Rep_downset Y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_downset :: \"'a downset \\<Rightarrow> 'a downset \\<Rightarrow> bool\" is \"(\\<lambda>X Y. Rep_downset X \\<subset> Rep_downset Y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a downset, order_class)", "by (intro_classes, transfer, auto simp: Rep_downset_inject less_eq_downset_def)"], ["", "end"], ["", "lemma ds_iso: \"mono ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ds", "unfolding mono_def ds_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       Abs_downset (\\<down> x) \\<le> Abs_downset (\\<down> y)", "by (metis Abs_downset_inverse downset_iso_iff less_eq_downset.rep_eq rangeI)"], ["", "lemma ds_faithful: \"ds x \\<le> ds y \\<Longrightarrow> x \\<le> (y::'a::order)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds x \\<le> ds y \\<Longrightarrow> x \\<le> y", "by (simp add: Abs_downset_inverse downset_faithful ds_def less_eq_downset.rep_eq)"], ["", "lemma ds_inj: \"inj (ds::'a::order \\<Rightarrow> 'a downset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ds", "by (simp add: ds_faithful dual_order.antisym injI)"], ["", "lemma ds_surj: \"surj ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) ds)", "by (metis (no_types, hide_lams) Rep_downset Rep_downset_inverse ds_def image_iff o_apply surj_def)"], ["", "lemma ds_bij: \"bij (ds::'a::order \\<Rightarrow> 'a downset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij ds", "by (simp add: bijI ds_inj ds_surj)"], ["", "lemma ds_ord_iso: \"ord_iso ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso ds", "unfolding ord_iso_def comp_def inf_bool_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bij \\<sqinter> mono \\<sqinter> (\\<lambda>x. mono (the_inv x))) ds", "by (smt UNIV_I ds_bij ds_faithful ds_inj ds_iso ds_surj f_the_inv_into_f inf1I mono_def)"], ["", "text \\<open>The morphishms between orderings and downsets are isotone functions. One can define functors mapping back and forth between these.\\<close>"], ["", "definition map_ds :: \"('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset)\" where\n  \"map_ds f = ds \\<circ> f \\<circ> SSup\""], ["", "text \\<open>This definition is actually contrived. We have shown that a function f between posets P and Q is isotone if and only if the \ninverse image of f maps downclosed sets in Q to downclosed sets in P. There is the following duality: ds is a natural transformation \nbetween the identity functor and the preimage functor as a contravariant functor from P to Q. Hence orderings with isotone maps and \ndownsets with downset-preserving maps are dual, which is a first step towards Stone duality. I don't see a way of proving this with Isabelle, \nas the types of the preimage of f are the wrong way and I don't see how I could capture opposition with what I have.\\<close>"], ["", "(*lemma \"mono (f::'a::complete_lattice \\<Rightarrow> 'b::complete_lattimap_ds f = Abs_downset \\<circ> (-`) f \\<circ> Rep_downset\" doesn't work! *)"], ["", "lemma map_ds_prop: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\" \n  shows \"map_ds f \\<circ> ds = ds \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ds f \\<circ> ds = ds \\<circ> f", "unfolding map_ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> f \\<circ> SSup \\<circ> ds = ds \\<circ> f", "by (simp add: SSup_ds_inv comp_assoc)"], ["", "lemma map_ds_prop2: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"map_ds f \\<circ> ds = ds \\<circ> id f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ds f \\<circ> ds = ds \\<circ> id f", "unfolding map_ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> f \\<circ> SSup \\<circ> ds = ds \\<circ> id f", "by (simp add: SSup_ds_inv comp_assoc)"], ["", "text \\<open>This is part of showing that map-ds is naturally isomorphic to the identity functor, ds being the natural isomorphism.\\<close>"], ["", "definition map_SSup :: \"('a downset \\<Rightarrow> 'b downset) \\<Rightarrow> ('a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\" where\n  \"map_SSup F = SSup \\<circ> F \\<circ> ds\""], ["", "lemma map_ds_iso_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> mono (map_ds f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (map_ds f)", "unfolding fun_eq_iff mono_def map_ds_def ds_def SSup_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> f x \\<le> f y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       Abs_downset (\\<down> (f (\\<Squnion> Rep_downset x)))\n       \\<le> Abs_downset (\\<down> (f (\\<Squnion> Rep_downset y)))", "by (metis Abs_downset_inverse Sup_subset_mono downset_iso_iff less_eq_downset.rep_eq rangeI)"], ["", "lemma map_SSup_iso_pres: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"mono F \\<Longrightarrow> mono (map_SSup F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono F \\<Longrightarrow> mono (map_SSup F)", "unfolding fun_eq_iff mono_def map_SSup_def ds_def SSup_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> F x \\<le> F y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       \\<Squnion> Rep_downset (F (Abs_downset (\\<down> x)))\n       \\<le> \\<Squnion> Rep_downset (F (Abs_downset (\\<down> y)))", "by (metis Abs_downset_inverse Sup_subset_mono downset_iso_iff less_eq_downset.rep_eq rangeI)"], ["", "lemma map_SSup_prop: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"ds \\<circ> map_SSup F = F \\<circ> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> map_SSup F = F \\<circ> ds", "unfolding map_SSup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> (SSup \\<circ> F \\<circ> ds) = F \\<circ> ds", "by (metis ds_SSup_inv fun.map_id0 id_def rewriteL_comp_comp)"], ["", "lemma map_SSup_prop2: \n  fixes F :: \"'a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  shows \"ds \\<circ> map_SSup F = id F \\<circ> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ds \\<circ> map_SSup F = id F \\<circ> ds", "by (simp add: map_SSup_prop)"], ["", "lemma map_ds_func1: \"map_ds id = (id::'a::complete_lattice downset\\<Rightarrow> 'a downset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ds id = id", "by (simp add: ds_SSup_inv map_ds_def)"], ["", "lemma map_ds_func2: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"map_ds (f \\<circ> g) = map_ds f \\<circ> map_ds g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ds (f \\<circ> g) = map_ds f \\<circ> map_ds g", "unfolding map_ds_def fun_eq_iff comp_def ds_def SSup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Abs_downset (\\<down> (f (g (\\<Squnion> Rep_downset x)))) =\n       Abs_downset\n        (\\<down>\n          (f (\\<Squnion> Rep_downset\n                          (Abs_downset\n                            (\\<down> (g (\\<Squnion> Rep_downset x)))))))", "by (metis Abs_downset_inverse Sup_atMost atMost_def downset_prop rangeI)"], ["", "lemma map_SSup_func1: \"map_SSup (id::'a::complete_lattice downset\\<Rightarrow> 'a downset) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_SSup id = id", "by (simp add: SSup_ds_inv map_SSup_def)"], ["", "lemma map_SSup_func2: \n  fixes F :: \"'c::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset\"\n  and G :: \"'a::complete_lattice downset \\<Rightarrow> 'c downset\"\n  shows \"map_SSup (F \\<circ> G) = map_SSup F \\<circ> map_SSup G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_SSup (F \\<circ> G) = map_SSup F \\<circ> map_SSup G", "unfolding map_SSup_def fun_eq_iff comp_def id_def ds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       SSup (F (G (Abs_downset (\\<down> x)))) =\n       SSup (F (Abs_downset (\\<down> (SSup (G (Abs_downset (\\<down> x)))))))", "by (metis comp_apply ds_SSup_inv ds_def id_apply)"], ["", "lemma map_SSup_map_ds_inv: \"map_SSup \\<circ> map_ds = (id::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_SSup \\<circ> map_ds = id", "by (metis (no_types, hide_lams) SSup_ds_inv comp_def eq_id_iff fun.map_comp fun.map_id0 id_apply map_SSup_prop map_ds_prop)"], ["", "lemma map_ds_map_SSup_inv: \"map_ds \\<circ> map_SSup = (id::('a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ds \\<circ> map_SSup = id", "unfolding map_SSup_def map_ds_def SSup_def ds_def id_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       Abs_downset\n        (\\<down>\n          (\\<Squnion> Rep_downset\n                       (x (Abs_downset\n                            (\\<down> (\\<Squnion> Rep_downset xa)))))) =\n       x xa", "by (metis (no_types, lifting) Rep_downset Rep_downset_inverse Sup_downset_id image_iff pointfree_idE)"], ["", "lemma inj_map_ds: \"inj (map_ds::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj map_ds", "by (metis (no_types, lifting) SSup_ds_inv fun.map_id0 id_comp inj_def map_ds_prop rewriteR_comp_comp2)"], ["", "lemma inj_map_SSup: \"inj (map_SSup::('a::complete_lattice downset \\<Rightarrow> 'b::complete_lattice downset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj map_SSup", "by (metis inj_on_id inj_on_imageI2 map_ds_map_SSup_inv)"], ["", "lemma map_ds_map_SSup_iff: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f = map_ds g) = (map_SSup f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = map_ds g) = (map_SSup f = g)", "by (metis inj_eq inj_map_ds map_ds_map_SSup_inv pointfree_idE)"], ["", "text \\<open>This gives an isomorphism between categories.\\<close>"], ["", "lemma surj_map_ds: \"surj (map_ds::('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a downset \\<Rightarrow> 'b downset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) map_ds)", "by (simp add: map_ds_map_SSup_iff surj_def)"], ["", "lemma surj_map_SSup: \"surj (map_SSup::('a::complete_lattice_with_dual downset \\<Rightarrow> 'b::complete_lattice_with_dual downset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) map_SSup)", "by (metis map_ds_map_SSup_iff surjI)"], ["", "text \\<open>There is of course a dual result for upsets with the reverse inclusion ordering. Once again, it seems impossible to capture \nthe \"real\" duality that uses the inverse image functor.\\<close>"], ["", "typedef (overloaded) 'a upset = \"range (\\<up>::'a::ord \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range \\<up>", "by fastforce"], ["", "setup_lifting type_definition_upset"], ["", "definition us :: \"'a::ord \\<Rightarrow> 'a upset\" where \n  \"us = Abs_upset \\<circ> \\<up>\""], ["", "definition IInf :: \"'a::complete_lattice upset \\<Rightarrow> 'a\" where\n  \"IInf = Inf \\<circ> Rep_upset\""], ["", "lemma us_ds: \"us = Abs_upset \\<circ> (`) \\<partial> \\<circ> Rep_downset \\<circ> ds \\<circ> (\\<partial>::'a::ord_with_dual \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us =\n    Abs_upset \\<circ> (`) \\<partial> \\<circ> Rep_downset \\<circ> ds \\<circ>\n    \\<partial>", "unfolding us_def ds_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Abs_upset (\\<up> x) =\n       Abs_upset\n        (\\<partial> ` Rep_downset (Abs_downset (\\<down> (\\<partial> x))))", "by (simp add: Abs_downset_inverse upset_to_downset2)"], ["", "lemma IInf_SSup: \"IInf = \\<partial> \\<circ> SSup \\<circ> Abs_downset \\<circ> (`) (\\<partial>::'a::complete_lattice_with_dual \\<Rightarrow> 'a) \\<circ> Rep_upset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInf =\n    \\<partial> \\<circ> SSup \\<circ> Abs_downset \\<circ>\n    (`) \\<partial> \\<circ>\n    Rep_upset", "unfolding IInf_def SSup_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<Sqinter> Rep_upset x =\n       \\<partial>\n        (\\<Squnion> Rep_downset (Abs_downset (\\<partial> ` Rep_upset x)))", "by (metis (no_types, hide_lams) Abs_downset_inverse Rep_upset Sup_dual_def_var image_iff rangeI subset_dual upset_to_downset3)"], ["", "lemma us_IInf_inv: \"us \\<circ> IInf = (id::'a::complete_lattice_with_dual upset \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<circ> IInf = id", "unfolding us_def IInf_def fun_eq_iff id_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Abs_upset (\\<up> (\\<Sqinter> Rep_upset x)) = x", "by (metis (no_types, lifting) Inf_upset_id Rep_upset Rep_upset_inverse f_the_inv_into_f pointfree_idE upset_inj)"], ["", "lemma IInf_us_inv: \"IInf \\<circ> us = (id::'a::complete_lattice_with_dual \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IInf \\<circ> us = id", "unfolding us_def IInf_def fun_eq_iff id_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Sqinter> Rep_upset (Abs_upset (\\<up> x)) = x", "by (metis Abs_upset_inverse Sup_Inf_var Sup_atLeastAtMost Sup_dual_upset_var order_refl rangeI)"], ["", "instantiation upset :: (ord) order\nbegin"], ["", "lift_definition less_eq_upset :: \"'a upset \\<Rightarrow> 'a upset \\<Rightarrow> bool\" is \"(\\<lambda>X Y. Rep_upset X \\<supseteq> Rep_upset Y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_upset :: \"'a upset \\<Rightarrow> 'a upset \\<Rightarrow> bool\" is \"(\\<lambda>X Y. Rep_upset X \\<supset> Rep_upset Y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a upset, order_class)", "by (intro_classes, transfer, simp_all add: less_le_not_le less_eq_upset.rep_eq Rep_upset_inject)"], ["", "end"], ["", "lemma us_iso: \"x \\<le> y \\<Longrightarrow> us x \\<le> us (y::'a::order_with_dual)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> us x \\<le> us y", "by (simp add: Abs_upset_inverse less_eq_upset.rep_eq upset_anti_iff us_def)"], ["", "lemma us_faithful: \"us x \\<le> us y \\<Longrightarrow> x \\<le> (y::'a::order_with_dual)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us x \\<le> us y \\<Longrightarrow> x \\<le> y", "by (simp add: Abs_upset_inverse upset_faithful us_def less_eq_upset.rep_eq)"], ["", "lemma us_inj: \"inj (us::'a::order_with_dual \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj us", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. us x = us y \\<longrightarrow> x = y", "by (simp add: us_faithful dual_order.antisym)"], ["", "lemma us_surj: \"surj (us::'a::order_with_dual \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) us)", "unfolding surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = us x", "by (metis Rep_upset Rep_upset_inverse comp_def image_iff us_def)"], ["", "lemma us_bij: \"bij (us::'a::order_with_dual \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij us", "by (simp add: bij_def us_surj us_inj)"], ["", "lemma us_ord_iso: \"ord_iso (us::'a::order_with_dual \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_iso us", "unfolding ord_iso_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bij \\<sqinter> mono \\<sqinter> (mono \\<circ> the_inv)) us", "by (simp, metis (no_types, lifting) UNIV_I f_the_inv_into_f monoI us_iso us_bij us_faithful us_inj us_surj)"], ["", "definition map_us :: \"('a::complete_lattice \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset)\" where\n  \"map_us f = us \\<circ> f \\<circ> IInf\""], ["", "lemma map_us_prop: \"map_us f \\<circ> (us::'a::complete_lattice_with_dual \\<Rightarrow> 'a upset) = us \\<circ> id f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_us f \\<circ> us = us \\<circ> id f", "unfolding map_us_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<circ> f \\<circ> IInf \\<circ> us = us \\<circ> id f", "by (simp add: IInf_us_inv comp_assoc)"], ["", "definition map_IInf :: \"('a upset \\<Rightarrow> 'b upset) \\<Rightarrow> ('a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\" where\n  \"map_IInf F = IInf \\<circ> F \\<circ> us\""], ["", "lemma map_IInf_prop: \"(us::'a::complete_lattice_with_dual \\<Rightarrow> 'a upset) \\<circ> map_IInf F = id F \\<circ> us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<circ> map_IInf F = id F \\<circ> us", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. us \\<circ> map_IInf F = id F \\<circ> us", "have \"us \\<circ> map_IInf F = (us \\<circ> IInf) \\<circ> F \\<circ> us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<circ> map_IInf F = us \\<circ> IInf \\<circ> F \\<circ> us", "by (simp add: fun.map_comp map_IInf_def)"], ["proof (state)\nthis:\n  us \\<circ> map_IInf F = us \\<circ> IInf \\<circ> F \\<circ> us\n\ngoal (1 subgoal):\n 1. us \\<circ> map_IInf F = id F \\<circ> us", "thus ?thesis"], ["proof (prove)\nusing this:\n  us \\<circ> map_IInf F = us \\<circ> IInf \\<circ> F \\<circ> us\n\ngoal (1 subgoal):\n 1. us \\<circ> map_IInf F = id F \\<circ> us", "by (simp add: us_IInf_inv)"], ["proof (state)\nthis:\n  us \\<circ> map_IInf F = id F \\<circ> us\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_us_func1: \"map_us id = (id::'a::complete_lattice_with_dual upset \\<Rightarrow> 'a upset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_us id = id", "unfolding map_us_def fun_eq_iff comp_def us_def id_def IInf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Abs_upset (\\<up> (\\<Sqinter> Rep_upset x)) = x", "by (metis (no_types, lifting) Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE)"], ["", "lemma map_us_func2: \n  fixes f :: \"'c::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  and g :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'c\"\n  shows \"map_us (f \\<circ> g) = map_us f \\<circ> map_us g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_us (f \\<circ> g) = map_us f \\<circ> map_us g", "unfolding map_us_def fun_eq_iff comp_def us_def IInf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Abs_upset (\\<up> (f (g (\\<Sqinter> Rep_upset x)))) =\n       Abs_upset\n        (\\<up>\n          (f (\\<Sqinter> Rep_upset\n                          (Abs_upset\n                            (\\<up> (g (\\<Sqinter> Rep_upset x)))))))", "by (metis Abs_upset_inverse Sup_Inf_var Sup_atLeastAtMost Sup_dual_upset_var order_refl rangeI)"], ["", "lemma map_IInf_func1: \"map_IInf id = (id::'a::complete_lattice_with_dual \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_IInf id = id", "unfolding map_IInf_def fun_eq_iff comp_def id_def us_def IInf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Sqinter> Rep_upset (Abs_upset (\\<up> x)) = x", "by (simp add: Abs_upset_inverse pointfree_idE)"], ["", "lemma map_IInf_func2: \n  fixes F :: \"'c::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset\"\n  and G :: \"'a::complete_lattice_with_dual upset \\<Rightarrow> 'c upset\"\n  shows \"map_IInf (F \\<circ> G) = map_IInf F \\<circ> map_IInf G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_IInf (F \\<circ> G) = map_IInf F \\<circ> map_IInf G", "unfolding map_IInf_def fun_eq_iff comp_def id_def us_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       IInf (F (G (Abs_upset (\\<up> x)))) =\n       IInf (F (Abs_upset (\\<up> (IInf (G (Abs_upset (\\<up> x)))))))", "by (metis comp_apply id_apply us_IInf_inv us_def)"], ["", "lemma map_IInf_map_us_inv: \"map_IInf \\<circ> map_us = (id::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_IInf \\<circ> map_us = id", "unfolding map_IInf_def map_us_def IInf_def us_def id_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       \\<Sqinter> Rep_upset\n                   (Abs_upset\n                     (\\<up>\n                       (x (\\<Sqinter> Rep_upset (Abs_upset (\\<up> xa)))))) =\n       x xa", "by (simp add: Abs_upset_inverse pointfree_idE)"], ["", "lemma map_us_map_IInf_inv: \"map_us \\<circ> map_IInf = (id::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_us \\<circ> map_IInf = id", "unfolding map_IInf_def map_us_def IInf_def us_def id_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       Abs_upset\n        (\\<up>\n          (\\<Sqinter> Rep_upset\n                       (x (Abs_upset (\\<up> (\\<Sqinter> Rep_upset xa)))))) =\n       x xa", "by (metis (no_types, lifting) Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE)"], ["", "lemma inj_map_us: \"inj (map_us::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj map_us", "unfolding map_us_def us_def IInf_def inj_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa.\n           Abs_upset (\\<up> (x (\\<Sqinter> Rep_upset xa))) =\n           Abs_upset\n            (\\<up> (y (\\<Sqinter> Rep_upset xa)))) \\<longrightarrow>\n       (\\<forall>xa. x xa = y xa)", "by (metis (no_types, hide_lams) Abs_upset_inverse Inf_upset_id pointfree_idE rangeI)"], ["", "lemma inj_map_IInf: \"inj (map_IInf::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj map_IInf", "unfolding map_IInf_def fun_eq_iff inj_def comp_def IInf_def us_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa.\n           \\<Sqinter> Rep_upset (x (Abs_upset (\\<up> xa))) =\n           \\<Sqinter> Rep_upset\n                       (y (Abs_upset (\\<up> xa)))) \\<longrightarrow>\n       (\\<forall>xa. x xa = y xa)", "by (metis (no_types, hide_lams) Inf_upset_id Rep_upset Rep_upset_inverse image_iff pointfree_idE)"], ["", "lemma map_us_map_IInf_iff: \n  fixes g :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\" \n  shows \"(f = map_us g) = (map_IInf f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = map_us g) = (map_IInf f = g)", "by (metis inj_eq inj_map_us map_us_map_IInf_inv pointfree_idE)"], ["", "lemma map_us_mono_pres: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"mono f \\<Longrightarrow> mono (map_us f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (map_us f)", "unfolding mono_def map_us_def comp_def us_def IInf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> f x \\<le> f y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       Abs_upset (\\<up> (f (\\<Sqinter> Rep_upset x)))\n       \\<le> Abs_upset (\\<up> (f (\\<Sqinter> Rep_upset y)))", "by (metis Abs_upset_inverse Inf_superset_mono less_eq_upset.rep_eq rangeI upset_anti_iff)"], ["", "lemma map_IInf_mono_pres: \n  fixes F :: \"'a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset\"\n  shows \"mono F \\<Longrightarrow> mono (map_IInf F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono F \\<Longrightarrow> mono (map_IInf F)", "unfolding mono_def map_IInf_def comp_def us_def IInf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> F x \\<le> F y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       \\<Sqinter> Rep_upset (F (Abs_upset (\\<up> x)))\n       \\<le> \\<Sqinter> Rep_upset (F (Abs_upset (\\<up> y)))", "oops"], ["", "lemma surj_map_us: \"surj (map_us::('a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual) \\<Rightarrow> ('a upset \\<Rightarrow> 'b upset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) map_us)", "by (simp add: map_us_map_IInf_iff surj_def)"], ["", "lemma surj_map_IInf: \"surj (map_IInf::('a::complete_lattice_with_dual upset \\<Rightarrow> 'b::complete_lattice_with_dual upset) \\<Rightarrow> ('a \\<Rightarrow> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) map_IInf)", "by (metis map_us_map_IInf_iff surjI)"], ["", "text \\<open>Hence we have again an isomorphism --- or rather equivalence --- between categories. Here, however, duality is not consistently picked up.\\<close>"], ["", "subsection \\<open>Stone's Theorem in the Presence of Atoms\\<close>"], ["", "text \\<open>Atom-map is a boolean algebra morphism.\\<close>"], ["", "context boolean_algebra\nbegin"], ["", "lemma atom_map_compl_pres: \"atom_map (-x) = Collect atom - atom_map x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "have \"(y \\<in> atom_map (-x)) = (atom y \\<and> y \\<le> -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> atom_map (- x)) = (atom y \\<and> y \\<le> - x)", "by (simp add: atom_map_def)"], ["proof (state)\nthis:\n  (y \\<in> atom_map (- x)) = (atom y \\<and> y \\<le> - x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "also"], ["proof (state)\nthis:\n  (y \\<in> atom_map (- x)) = (atom y \\<and> y \\<le> - x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "have \"... = (atom y \\<and> \\<not>(y \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom y \\<and> y \\<le> - x) = (atom y \\<and> \\<not> y \\<le> x)", "by (metis atom_sup_iff inf.orderE meet_shunt sup_compl_top top.ordering_top_axioms ordering_top.extremum)"], ["proof (state)\nthis:\n  (atom y \\<and> y \\<le> - x) = (atom y \\<and> \\<not> y \\<le> x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "also"], ["proof (state)\nthis:\n  (atom y \\<and> y \\<le> - x) = (atom y \\<and> \\<not> y \\<le> x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "have \"... = (y \\<in> Collect atom - atom_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom y \\<and> \\<not> y \\<le> x) = (y \\<in> Collect atom - atom_map x)", "using atom_map_def"], ["proof (prove)\nusing this:\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. (atom y \\<and> \\<not> y \\<le> x) = (y \\<in> Collect atom - atom_map x)", "by auto"], ["proof (state)\nthis:\n  (atom y \\<and> \\<not> y \\<le> x) = (y \\<in> Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "finally"], ["proof (chain)\npicking this:\n  (y \\<in> atom_map (- x)) = (y \\<in> Collect atom - atom_map x)", "have \"(y \\<in> atom_map (-x)) = (y \\<in> Collect atom - atom_map x)\""], ["proof (prove)\nusing this:\n  (y \\<in> atom_map (- x)) = (y \\<in> Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. (y \\<in> atom_map (- x)) = (y \\<in> Collect atom - atom_map x)", "."], ["proof (state)\nthis:\n  (y \\<in> atom_map (- x)) = (y \\<in> Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "}"], ["proof (state)\nthis:\n  (?y2 \\<in> atom_map (- x)) = (?y2 \\<in> Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?y2 \\<in> atom_map (- x)) = (?y2 \\<in> Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (- x) = Collect atom - atom_map x", "by blast"], ["proof (state)\nthis:\n  atom_map (- x) = Collect atom - atom_map x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_map_sup_pres: \"atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "have \"(z \\<in> atom_map (x \\<squnion> y)) = (atom z \\<and> z \\<le> x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> atom_map (x \\<squnion> y)) =\n    (atom z \\<and> z \\<le> x \\<squnion> y)", "by (simp add: atom_map_def)"], ["proof (state)\nthis:\n  (z \\<in> atom_map (x \\<squnion> y)) =\n  (atom z \\<and> z \\<le> x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "also"], ["proof (state)\nthis:\n  (z \\<in> atom_map (x \\<squnion> y)) =\n  (atom z \\<and> z \\<le> x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "have \"... = (atom z \\<and> (z \\<le> x \\<or> z \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom z \\<and> z \\<le> x \\<squnion> y) =\n    (atom z \\<and> (z \\<le> x \\<or> z \\<le> y))", "using atom_sup_iff"], ["proof (prove)\nusing this:\n  atom ?x =\n  (?x \\<noteq> \\<bottom> \\<and>\n   (\\<forall>y z.\n       (?x \\<le> y \\<or> ?x \\<le> z) = (?x \\<le> y \\<squnion> z)))\n\ngoal (1 subgoal):\n 1. (atom z \\<and> z \\<le> x \\<squnion> y) =\n    (atom z \\<and> (z \\<le> x \\<or> z \\<le> y))", "by auto"], ["proof (state)\nthis:\n  (atom z \\<and> z \\<le> x \\<squnion> y) =\n  (atom z \\<and> (z \\<le> x \\<or> z \\<le> y))\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "also"], ["proof (state)\nthis:\n  (atom z \\<and> z \\<le> x \\<squnion> y) =\n  (atom z \\<and> (z \\<le> x \\<or> z \\<le> y))\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "have \"... = (z \\<in> atom_map x \\<union> atom_map y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom z \\<and> (z \\<le> x \\<or> z \\<le> y)) =\n    (z \\<in> atom_map x \\<union> atom_map y)", "using atom_map_def"], ["proof (prove)\nusing this:\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. (atom z \\<and> (z \\<le> x \\<or> z \\<le> y)) =\n    (z \\<in> atom_map x \\<union> atom_map y)", "by auto"], ["proof (state)\nthis:\n  (atom z \\<and> (z \\<le> x \\<or> z \\<le> y)) =\n  (z \\<in> atom_map x \\<union> atom_map y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "finally"], ["proof (chain)\npicking this:\n  (z \\<in> atom_map (x \\<squnion> y)) =\n  (z \\<in> atom_map x \\<union> atom_map y)", "have \"(z \\<in> atom_map (x \\<squnion> y)) = (z \\<in> atom_map x \\<union> atom_map y)\""], ["proof (prove)\nusing this:\n  (z \\<in> atom_map (x \\<squnion> y)) =\n  (z \\<in> atom_map x \\<union> atom_map y)\n\ngoal (1 subgoal):\n 1. (z \\<in> atom_map (x \\<squnion> y)) =\n    (z \\<in> atom_map x \\<union> atom_map y)", "by blast"], ["proof (state)\nthis:\n  (z \\<in> atom_map (x \\<squnion> y)) =\n  (z \\<in> atom_map x \\<union> atom_map y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "}"], ["proof (state)\nthis:\n  (?z2 \\<in> atom_map (x \\<squnion> y)) =\n  (?z2 \\<in> atom_map x \\<union> atom_map y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?z2 \\<in> atom_map (x \\<squnion> y)) =\n  (?z2 \\<in> atom_map x \\<union> atom_map y)\n\ngoal (1 subgoal):\n 1. atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y", "by blast"], ["proof (state)\nthis:\n  atom_map (x \\<squnion> y) = atom_map x \\<union> atom_map y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_map_inf_pres: \"atom_map (x \\<sqinter> y) = atom_map x \\<inter> atom_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (x \\<sqinter> y) = atom_map x \\<inter> atom_map y", "by (smt Diff_Un atom_map_compl_pres atom_map_sup_pres compl_inf double_compl)"], ["", "lemma atom_map_minus_pres: \"atom_map (x - y) = atom_map x - atom_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (x - y) = atom_map x - atom_map y", "using atom_map_compl_pres atom_map_def diff_eq"], ["proof (prove)\nusing this:\n  atom_map (- ?x) = Collect atom - atom_map ?x\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n  ?x - ?y = ?x \\<sqinter> - ?y\n\ngoal (1 subgoal):\n 1. atom_map (x - y) = atom_map x - atom_map y", "by auto"], ["", "end"], ["", "text \\<open>The homomorphic images of boolean algebras under atom-map are boolean algebras \n--- in fact powerset boolean algebras.\\<close>"], ["", "instantiation atoms :: (boolean_algebra) boolean_algebra\nbegin"], ["", "lift_definition minus_atoms :: \"'a atoms \\<Rightarrow> 'a atoms \\<Rightarrow> 'a atoms\" is \"\\<lambda>x y. Abs_atoms (Rep_atoms x - Rep_atoms y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uminus_atoms :: \"'a atoms \\<Rightarrow> 'a atoms\" is  \"\\<lambda>x. Abs_atoms (Collect atom - Rep_atoms x)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition bot_atoms :: \"'a atoms\" is \"Abs_atoms {}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition sup_atoms ::  \"'a atoms \\<Rightarrow> 'a atoms \\<Rightarrow> 'a atoms\" is \"\\<lambda>x y. Abs_atoms (Rep_atoms x \\<union> Rep_atoms y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition top_atoms :: \"'a atoms\" is \"Abs_atoms (Collect atom)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition inf_atoms ::  \"'a atoms \\<Rightarrow> 'a atoms \\<Rightarrow> 'a atoms\" is \"\\<lambda>x y. Abs_atoms (Rep_atoms x \\<inter> Rep_atoms y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_atoms :: \"'a atoms \\<Rightarrow> 'a atoms \\<Rightarrow> bool\" is \"(\\<lambda>x y. Rep_atoms x \\<subseteq> Rep_atoms y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_atoms :: \"'a atoms \\<Rightarrow> 'a atoms \\<Rightarrow> bool\" is \"(\\<lambda>x y. Rep_atoms x \\<subset> Rep_atoms y)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a atoms, boolean_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "apply (transfer, simp add: less_le_not_le)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>a. \\<bottom> \\<le> a\nA total of 15 subgoals...", "apply (transfer, simp)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>a. \\<bottom> \\<le> a\n 10. \\<And>a. a \\<le> \\<top>\nA total of 14 subgoals...", "apply (transfer, blast)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. \\<bottom> \\<le> a\n 9. \\<And>a. a \\<le> \\<top>\n 10. \\<And>x y z.\n        x \\<squnion> y \\<sqinter> z =\n        (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\nA total of 13 subgoals...", "apply (simp add: Rep_atoms_inject less_eq_atoms.abs_eq)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>a. \\<bottom> \\<le> a\n 8. \\<And>a. a \\<le> \\<top>\n 9. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 10. \\<And>x. x \\<sqinter> - x = \\<bottom>\nA total of 12 subgoals...", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff inf_le1 rangeI)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. \\<bottom> \\<le> a\n 7. \\<And>a. a \\<le> \\<top>\n 8. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 9. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 10. \\<And>x. x \\<squnion> - x = \\<top>\nA total of 11 subgoals...", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff inf_le2 rangeI)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. \\<bottom> \\<le> a\n 6. \\<And>a. a \\<le> \\<top>\n 7. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 8. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 9. \\<And>x. x \\<squnion> - x = \\<top>\n 10. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_inf_pres image_iff le_iff_sup rangeI sup_inf_distrib1)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 4. \\<And>a. \\<bottom> \\<le> a\n 5. \\<And>a. a \\<le> \\<top>\n 6. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 7. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 8. \\<And>x. x \\<squnion> - x = \\<top>\n 9. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_sup_pres image_iff image_iff inf.orderE inf_sup_aci(6) le_iff_sup order_refl rangeI rangeI)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 3. \\<And>a. \\<bottom> \\<le> a\n 4. \\<And>a. a \\<le> \\<top>\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 7. \\<And>x. x \\<squnion> - x = \\<top>\n 8. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_sup_pres image_iff inf_sup_aci(6) le_iff_sup rangeI sup.left_commute sup.right_idem)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 2. \\<And>a. \\<bottom> \\<le> a\n 3. \\<And>a. a \\<le> \\<top>\n 4. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 5. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 6. \\<And>x. x \\<squnion> - x = \\<top>\n 7. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, subst Abs_atoms_inverse, metis (no_types, lifting) Rep_atoms atom_map_sup_pres image_iff rangeI, simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. \\<bottom> \\<le> a\n 2. \\<And>a. a \\<le> \\<top>\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 5. \\<And>x. x \\<squnion> - x = \\<top>\n 6. \\<And>x y. x - y = x \\<sqinter> - y", "apply transfer"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. Rep_atoms (Abs_atoms {}) \\<subseteq> Rep_atoms a\n 2. \\<And>a. a \\<le> \\<top>\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 5. \\<And>x. x \\<squnion> - x = \\<top>\n 6. \\<And>x y. x - y = x \\<sqinter> - y", "using Abs_atoms_inverse atom_map_bot_pres"], ["proof (prove)\nusing this:\n  ?y \\<in> range atom_map \\<Longrightarrow> Rep_atoms (Abs_atoms ?y) = ?y\n  bot_pres atom_map\n\ngoal (6 subgoals):\n 1. \\<And>a. Rep_atoms (Abs_atoms {}) \\<subseteq> Rep_atoms a\n 2. \\<And>a. a \\<le> \\<top>\n 3. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 4. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 5. \\<And>x. x \\<squnion> - x = \\<top>\n 6. \\<And>x y. x - y = x \\<sqinter> - y", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. a \\<le> \\<top>\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 4. \\<And>x. x \\<squnion> - x = \\<top>\n 5. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, metis Abs_atoms_inverse Rep_atoms atom_map_compl_pres atom_map_top_pres diff_eq double_compl inf_le1 rangeE rangeI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 3. \\<And>x. x \\<squnion> - x = \\<top>\n 4. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, smt Abs_atoms_inverse Rep_atoms atom_map_inf_pres atom_map_sup_pres image_iff rangeI sup_inf_distrib1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, metis (no_types, hide_lams) Abs_atoms_inverse Diff_disjoint Rep_atoms atom_map_compl_pres rangeE rangeI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<squnion> - x = \\<top>\n 2. \\<And>x y. x - y = x \\<sqinter> - y", "apply (transfer, smt Abs_atoms_inverse uminus_atoms.abs_eq Rep_atoms Un_Diff_cancel atom_map_compl_pres atom_map_inf_pres atom_map_minus_pres atom_map_sup_pres atom_map_top_pres diff_eq double_compl inf_compl_bot_right rangeE rangeI sup_commute sup_compl_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x - y = x \\<sqinter> - y", "by transfer (smt Abs_atoms_inverse Rep_atoms atom_map_compl_pres atom_map_inf_pres atom_map_minus_pres diff_eq rangeE rangeI)"], ["", "end"], ["", "text \\<open>The homomorphism atom-map can then be restricted in its output type to the powerset boolean algebra.\\<close>"], ["", "lemma at_map_bot_pres: \"at_map \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_pres at_map", "by (simp add: at_map_def atom_map_bot_pres bot_atoms.transfer)"], ["", "lemma at_map_top_pres: \"at_map \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres at_map", "by (simp add: at_map_def atom_map_top_pres top_atoms.transfer)"], ["", "lemma at_map_compl_pres: \"at_map \\<circ> uminus = uminus \\<circ> at_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map \\<circ> uminus = uminus \\<circ> at_map", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (at_map \\<circ> uminus) x = (uminus \\<circ> at_map) x", "by (simp add: Abs_atoms_inverse at_map_def atom_map_compl_pres uminus_atoms.abs_eq)"], ["", "lemma at_map_sup_pres: \"at_map (x \\<squnion> y) = at_map x \\<squnion> at_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map (x \\<squnion> y) = at_map x \\<squnion> at_map y", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_atoms (atom_map (x \\<squnion> y)) =\n    Abs_atoms (atom_map x) \\<squnion> Abs_atoms (atom_map y)", "by (metis (mono_tags, lifting) Abs_atoms_inverse atom_map_sup_pres rangeI sup_atoms.transfer)"], ["", "lemma at_map_inf_pres: \"at_map (x \\<sqinter> y) = at_map x \\<sqinter> at_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map (x \\<sqinter> y) = at_map x \\<sqinter> at_map y", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_atoms (atom_map (x \\<sqinter> y)) =\n    Abs_atoms (atom_map x) \\<sqinter> Abs_atoms (atom_map y)", "by (metis (mono_tags, lifting) Abs_atoms_inverse atom_map_inf_pres inf_atoms.transfer rangeI)"], ["", "lemma at_map_minus_pres: \"at_map (x - y) = at_map x - at_map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map (x - y) = at_map x - at_map y", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_atoms (atom_map (x - y)) =\n    Abs_atoms (atom_map x) - Abs_atoms (atom_map y)", "by (simp add: Abs_atoms_inverse atom_map_minus_pres minus_atoms.abs_eq)"], ["", "context atomic_boolean_algebra\nbegin"], ["", "text \\<open>In atomic boolean algebras, atom-map is an embedding that maps atoms of the boolean algebra to \nthose of the powerset boolean algebra. Analogous properties hold for at-map.\\<close>"], ["", "lemma inj_atom_map: \"inj atom_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj atom_map", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inj atom_map", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. inj atom_map", "fix x y ::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. inj atom_map", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. inj atom_map", "hence \"x \\<sqinter> -y \\<noteq> \\<bottom> \\<or> -x \\<sqinter> y \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<noteq> \\<bottom> \\<or>\n    - x \\<sqinter> y \\<noteq> \\<bottom>", "by (auto simp: meet_shunt)"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<noteq> \\<bottom> \\<or>\n  - x \\<sqinter> y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. inj atom_map", "hence \"\\<exists>z. atom z \\<and> (z \\<le> x \\<sqinter> -y \\<or> z \\<le> -x \\<sqinter> y)\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<noteq> \\<bottom> \\<or>\n  - x \\<sqinter> y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       atom z \\<and>\n       (z \\<le> x \\<sqinter> - y \\<or> z \\<le> - x \\<sqinter> y)", "using atomicity"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<noteq> \\<bottom> \\<or>\n  - x \\<sqinter> y \\<noteq> \\<bottom>\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  \\<exists>y. atom y \\<and> y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       atom z \\<and>\n       (z \\<le> x \\<sqinter> - y \\<or> z \\<le> - x \\<sqinter> y)", "by blast"], ["proof (state)\nthis:\n  \\<exists>z.\n     atom z \\<and> (z \\<le> x \\<sqinter> - y \\<or> z \\<le> - x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. inj atom_map", "hence \"\\<exists>z. atom z \\<and> ((z \\<in> atom_map x \\<and> \\<not>(z \\<in> atom_map y)) \\<or> (\\<not>(z \\<in> atom_map x) \\<and> z \\<in> atom_map y))\""], ["proof (prove)\nusing this:\n  \\<exists>z.\n     atom z \\<and> (z \\<le> x \\<sqinter> - y \\<or> z \\<le> - x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       atom z \\<and>\n       (z \\<in> atom_map x \\<and> z \\<notin> atom_map y \\<or>\n        z \\<notin> atom_map x \\<and> z \\<in> atom_map y)", "unfolding atom_def atom_map_def"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     (z \\<noteq> \\<bottom> \\<and>\n      \\<not> (\\<exists>y>\\<bottom>. y < z)) \\<and>\n     (z \\<le> x \\<sqinter> - y \\<or> z \\<le> - x \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       (z \\<noteq> \\<bottom> \\<and>\n        \\<not> (\\<exists>y>\\<bottom>. y < z)) \\<and>\n       (z \\<in> {y. (y \\<noteq> \\<bottom> \\<and>\n                     \\<not> (\\<exists>ya>\\<bottom>. ya < y)) \\<and>\n                    y \\<le> x} \\<and>\n        z \\<notin> {ya.\n                    (ya \\<noteq> \\<bottom> \\<and>\n                     \\<not> (\\<exists>y>\\<bottom>. y < ya)) \\<and>\n                    ya \\<le> y} \\<or>\n        z \\<notin> {y. (y \\<noteq> \\<bottom> \\<and>\n                        \\<not> (\\<exists>ya>\\<bottom>. ya < y)) \\<and>\n                       y \\<le> x} \\<and>\n        z \\<in> {ya.\n                 (ya \\<noteq> \\<bottom> \\<and>\n                  \\<not> (\\<exists>y>\\<bottom>. y < ya)) \\<and>\n                 ya \\<le> y})", "by (clarsimp, metis diff_eq inf.orderE meet_shunt_var)"], ["proof (state)\nthis:\n  \\<exists>z.\n     atom z \\<and>\n     (z \\<in> atom_map x \\<and> z \\<notin> atom_map y \\<or>\n      z \\<notin> atom_map x \\<and> z \\<in> atom_map y)\n\ngoal (1 subgoal):\n 1. inj atom_map", "hence \"atom_map x \\<noteq> atom_map y\""], ["proof (prove)\nusing this:\n  \\<exists>z.\n     atom z \\<and>\n     (z \\<in> atom_map x \\<and> z \\<notin> atom_map y \\<or>\n      z \\<notin> atom_map x \\<and> z \\<in> atom_map y)\n\ngoal (1 subgoal):\n 1. atom_map x \\<noteq> atom_map y", "by blast"], ["proof (state)\nthis:\n  atom_map x \\<noteq> atom_map y\n\ngoal (1 subgoal):\n 1. inj atom_map", "}"], ["proof (state)\nthis:\n  ?x2 \\<noteq> ?y2 \\<Longrightarrow> atom_map ?x2 \\<noteq> atom_map ?y2\n\ngoal (1 subgoal):\n 1. inj atom_map", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x2 \\<noteq> ?y2 \\<Longrightarrow> atom_map ?x2 \\<noteq> atom_map ?y2\n\ngoal (1 subgoal):\n 1. inj atom_map", "by (meson injI)"], ["proof (state)\nthis:\n  inj atom_map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_map_atom_pres: \"atom x \\<Longrightarrow> atom_map x = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom_map x = \\<eta> x", "unfolding atom_def atom_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<and>\n    \\<not> (\\<exists>y>\\<bottom>. y < x) \\<Longrightarrow>\n    {y. (y \\<noteq> \\<bottom> \\<and>\n         \\<not> (\\<exists>ya>\\<bottom>. ya < y)) \\<and>\n        y \\<le> x} =\n    \\<eta> x", "by (auto simp: bot_less dual_order.order_iff_strict)"], ["", "lemma atom_map_atom_pres2: \"atom x \\<Longrightarrow> atom (atom_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (atom_map x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (atom_map x)", "assume \"atom x\""], ["proof (state)\nthis:\n  atom x\n\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (atom_map x)", "hence \"atom_map x = {x}\""], ["proof (prove)\nusing this:\n  atom x\n\ngoal (1 subgoal):\n 1. atom_map x = \\<eta> x", "by (simp add: atom_map_atom_pres)"], ["proof (state)\nthis:\n  atom_map x = \\<eta> x\n\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (atom_map x)", "thus \"atom (atom_map x)\""], ["proof (prove)\nusing this:\n  atom_map x = \\<eta> x\n\ngoal (1 subgoal):\n 1. atom (atom_map x)", "using bounded_lattice_class.atom_def"], ["proof (prove)\nusing this:\n  atom_map x = \\<eta> x\n  atom ?x =\n  (?x \\<noteq> \\<bottom> \\<and> \\<not> (\\<exists>y>\\<bottom>. y < ?x))\n\ngoal (1 subgoal):\n 1. atom (atom_map x)", "by auto"], ["proof (state)\nthis:\n  atom (atom_map x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma inj_at_map: \"inj (at_map::'a::atomic_boolean_algebra \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj at_map", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. Abs_atoms (atom_map x))", "by (metis (no_types, lifting) Abs_atoms_inverse inj_atom_map inj_def rangeI)"], ["", "lemma at_map_atom_pres: \"atom (x::'a::atomic_boolean_algebra) \\<Longrightarrow> at_map x = Abs_atoms {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> at_map x = Abs_atoms (\\<eta> x)", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> Abs_atoms (atom_map x) = Abs_atoms (\\<eta> x)", "by (simp add: atom_map_atom_pres)"], ["", "lemma at_map_atom_pres2: \"atom (x::'a::atomic_boolean_algebra) \\<Longrightarrow> atom (at_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (at_map x)", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<Longrightarrow> atom (Abs_atoms (atom_map x))", "by (metis Abs_atoms_inverse atom_def atom_map_atom_pres2 atom_map_bot_pres bot_atoms.abs_eq less_atoms.abs_eq rangeI)"], ["", "text \\<open>Homomorphic images of atomic boolean algebras under atom-map are therefore atomic (rather obviously).\\<close>"], ["", "instance atoms :: (atomic_boolean_algebra) atomic_boolean_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a atoms, atomic_boolean_algebra_class)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "fix x::\"'a atoms\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "assume \"x \\<noteq> \\<bottom>\""], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "hence \"\\<exists>y. x = at_map y \\<and> x \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = at_map y \\<and> x \\<noteq> \\<bottom>", "unfolding at_map_def comp_def"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = Abs_atoms (atom_map y) \\<and> x \\<noteq> \\<bottom>", "by (metis Abs_atoms_cases rangeE)"], ["proof (state)\nthis:\n  \\<exists>y. x = at_map y \\<and> x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "hence \"\\<exists>y. x = at_map y \\<and> (\\<exists>z. atom z \\<and> z \\<le> y)\""], ["proof (prove)\nusing this:\n  \\<exists>y. x = at_map y \\<and> x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = at_map y \\<and> (\\<exists>z. atom z \\<and> z \\<le> y)", "using at_map_bot_pres atomicity"], ["proof (prove)\nusing this:\n  \\<exists>y. x = at_map y \\<and> x \\<noteq> \\<bottom>\n  bot_pres at_map\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  \\<exists>y. atom y \\<and> y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>y. x = at_map y \\<and> (\\<exists>z. atom z \\<and> z \\<le> y)", "by force"], ["proof (state)\nthis:\n  \\<exists>y. x = at_map y \\<and> (\\<exists>z. atom z \\<and> z \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "hence \"\\<exists>y. x = at_map y \\<and> (\\<exists>z. atom (at_map z) \\<and> at_map z \\<le> at_map y)\""], ["proof (prove)\nusing this:\n  \\<exists>y. x = at_map y \\<and> (\\<exists>z. atom z \\<and> z \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       x = at_map y \\<and>\n       (\\<exists>z. atom (at_map z) \\<and> at_map z \\<le> at_map y)", "by (metis at_map_atom_pres2 at_map_sup_pres sup.orderE sup_ge2)"], ["proof (state)\nthis:\n  \\<exists>y.\n     x = at_map y \\<and>\n     (\\<exists>z. atom (at_map z) \\<and> at_map z \\<le> at_map y)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> \\<bottom> \\<Longrightarrow>\n       \\<exists>y. atom y \\<and> y \\<le> x", "thus \"\\<exists>y. atom y \\<and> y \\<le> x\""], ["proof (prove)\nusing this:\n  \\<exists>y.\n     x = at_map y \\<and>\n     (\\<exists>z. atom (at_map z) \\<and> at_map z \\<le> at_map y)\n\ngoal (1 subgoal):\n 1. \\<exists>y. atom y \\<and> y \\<le> x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>y. atom y \\<and> y \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "context complete_boolean_algebra_alt\nbegin"], ["", "text \\<open>In complete boolean algebras, atom-map is surjective; more precisely it is the left inverse\nof Sup, at least for sets of atoms. Below, this statement is made more explicit for at-map.\\<close>"], ["", "lemma surj_atom_map: \"Y \\<subseteq> Collect atom \\<Longrightarrow> Y = atom_map (\\<Squnion>Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow> Y = atom_map (\\<Squnion> Y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    Y \\<subseteq> atom_map (\\<Squnion> Y)\n 2. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "assume \"Y \\<subseteq> Collect atom\""], ["proof (state)\nthis:\n  Y \\<subseteq> Collect atom\n\ngoal (2 subgoals):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    Y \\<subseteq> atom_map (\\<Squnion> Y)\n 2. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "thus \"Y \\<subseteq> atom_map (\\<Squnion>Y)\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> Collect atom\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> atom_map (\\<Squnion> Y)", "using Sup_upper atom_map_def"], ["proof (prove)\nusing this:\n  Y \\<subseteq> Collect atom\n  ?x \\<in> ?A \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> atom_map (\\<Squnion> Y)", "by force"], ["proof (state)\nthis:\n  Y \\<subseteq> atom_map (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "assume \"Y \\<subseteq> Collect atom\""], ["proof (state)\nthis:\n  Y \\<subseteq> Collect atom\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "hence a: \"\\<forall>y. y \\<in> Y \\<longrightarrow> atom y\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> Collect atom\n\ngoal (1 subgoal):\n 1. \\<forall>y. y \\<in> Y \\<longrightarrow> atom y", "by blast"], ["proof (state)\nthis:\n  \\<forall>y. y \\<in> Y \\<longrightarrow> atom y\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "{"], ["proof (state)\nthis:\n  \\<forall>y. y \\<in> Y \\<longrightarrow> atom y\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "assume h: \"z \\<in> Collect atom - Y\""], ["proof (state)\nthis:\n  z \\<in> Collect atom - Y\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "hence \"\\<forall>y \\<in> Y. y \\<sqinter> z = \\<bottom>\""], ["proof (prove)\nusing this:\n  z \\<in> Collect atom - Y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>Y. y \\<sqinter> z = \\<bottom>", "by (metis DiffE a h atom_def dual_order.not_eq_order_implies_strict inf.absorb_iff2 inf_le2 meet_shunt mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>Y. y \\<sqinter> z = \\<bottom>\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "hence \"\\<Squnion>Y \\<sqinter> z = \\<bottom>\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>Y. y \\<sqinter> z = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<sqinter> z = \\<bottom>", "using Sup_least meet_shunt"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>Y. y \\<sqinter> z = \\<bottom>\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion> ?A \\<le> ?z\n  (?x \\<sqinter> ?y = \\<bottom>) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. \\<Squnion> Y \\<sqinter> z = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> Y \\<sqinter> z = \\<bottom>\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "hence \"z \\<notin> atom_map (\\<Squnion>Y)\""], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<sqinter> z = \\<bottom>\n\ngoal (1 subgoal):\n 1. z \\<notin> atom_map (\\<Squnion> Y)", "using atom_map_bot_pres atom_map_def"], ["proof (prove)\nusing this:\n  \\<Squnion> Y \\<sqinter> z = \\<bottom>\n  atom_map \\<bottom> = {}\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. z \\<notin> atom_map (\\<Squnion> Y)", "by force"], ["proof (state)\nthis:\n  z \\<notin> atom_map (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "}"], ["proof (state)\nthis:\n  ?z2 \\<in> Collect atom - Y \\<Longrightarrow>\n  ?z2 \\<notin> atom_map (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> Collect atom \\<Longrightarrow>\n    atom_map (\\<Squnion> Y) \\<subseteq> Y", "thus  \"atom_map (\\<Squnion>Y) \\<subseteq> Y\""], ["proof (prove)\nusing this:\n  ?z2 \\<in> Collect atom - Y \\<Longrightarrow>\n  ?z2 \\<notin> atom_map (\\<Squnion> Y)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> Y) \\<subseteq> Y", "using atom_map_def"], ["proof (prove)\nusing this:\n  ?z2 \\<in> Collect atom - Y \\<Longrightarrow>\n  ?z2 \\<notin> atom_map (\\<Squnion> Y)\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> Y) \\<subseteq> Y", "by force"], ["proof (state)\nthis:\n  atom_map (\\<Squnion> Y) \\<subseteq> Y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In this setting, atom-map is a complete boolean algebra morphism.\\<close>"], ["", "lemma atom_map_Sup_pres: \"atom_map (\\<Squnion>X) = (\\<Union>x \\<in> X. atom_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "have \"(z \\<in> atom_map (\\<Squnion>X)) = (atom z \\<and> z \\<le> \\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> atom_map (\\<Squnion> X)) = (atom z \\<and> z \\<le> \\<Squnion> X)", "by (simp add: atom_map_def)"], ["proof (state)\nthis:\n  (z \\<in> atom_map (\\<Squnion> X)) = (atom z \\<and> z \\<le> \\<Squnion> X)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  (z \\<in> atom_map (\\<Squnion> X)) = (atom z \\<and> z \\<le> \\<Squnion> X)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "have \"... = (atom z \\<and> (\\<exists>x \\<in> X. z \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom z \\<and> z \\<le> \\<Squnion> X) =\n    (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x))", "using atom_Sup_iff"], ["proof (prove)\nusing this:\n  atom ?x =\n  (?x \\<noteq> \\<bottom> \\<and>\n   (\\<forall>Y. (\\<exists>y\\<in>Y. ?x \\<le> y) = (?x \\<le> \\<Squnion> Y)))\n\ngoal (1 subgoal):\n 1. (atom z \\<and> z \\<le> \\<Squnion> X) =\n    (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x))", "by auto"], ["proof (state)\nthis:\n  (atom z \\<and> z \\<le> \\<Squnion> X) =\n  (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  (atom z \\<and> z \\<le> \\<Squnion> X) =\n  (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "have \"... = (z \\<in> (\\<Union>x \\<in> X. atom_map x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x)) =\n    (z \\<in> \\<Union> (atom_map ` X))", "using atom_map_def"], ["proof (prove)\nusing this:\n  atom_map ?x = {y. atom y \\<and> y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x)) =\n    (z \\<in> \\<Union> (atom_map ` X))", "by auto"], ["proof (state)\nthis:\n  (atom z \\<and> (\\<exists>x\\<in>X. z \\<le> x)) =\n  (z \\<in> \\<Union> (atom_map ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "finally"], ["proof (chain)\npicking this:\n  (z \\<in> atom_map (\\<Squnion> X)) = (z \\<in> \\<Union> (atom_map ` X))", "have \"(z \\<in> atom_map (\\<Squnion>X)) = (z \\<in> (\\<Union>x \\<in> X. atom_map x))\""], ["proof (prove)\nusing this:\n  (z \\<in> atom_map (\\<Squnion> X)) = (z \\<in> \\<Union> (atom_map ` X))\n\ngoal (1 subgoal):\n 1. (z \\<in> atom_map (\\<Squnion> X)) = (z \\<in> \\<Union> (atom_map ` X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> atom_map (\\<Squnion> X)) = (z \\<in> \\<Union> (atom_map ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "}"], ["proof (state)\nthis:\n  (?z2 \\<in> atom_map (\\<Squnion> X)) = (?z2 \\<in> \\<Union> (atom_map ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?z2 \\<in> atom_map (\\<Squnion> X)) = (?z2 \\<in> \\<Union> (atom_map ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)", "by blast"], ["proof (state)\nthis:\n  atom_map (\\<Squnion> X) = \\<Union> (atom_map ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma atom_map_Sup_pres_var: \"atom_map \\<circ> Sup = Sup \\<circ> (`) atom_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map \\<circ> Sup = \\<Union> \\<circ> (`) atom_map", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. atom_map (\\<Squnion> x) = \\<Union> (atom_map ` x)", "by (simp add: atom_map_Sup_pres)"], ["", "text \\<open>For Inf-preservation, it is important that Infs are restricted to homomorphic images; \nhence they need to be pushed into the set of all atoms.\\<close>"], ["", "lemma atom_map_Inf_pres: \"atom_map (\\<Sqinter>X) = Collect atom \\<inter> (\\<Inter>x \\<in> X. atom_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "have \"atom_map (\\<Sqinter>X) = atom_map (-(\\<Squnion>x \\<in> X. -x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = atom_map (- \\<Squnion> (uminus ` X))", "by (smt Collect_cong SUP_le_iff atom_map_def compl_le_compl_iff compl_le_swap1 le_Inf_iff)"], ["proof (state)\nthis:\n  atom_map (\\<Sqinter> X) = atom_map (- \\<Squnion> (uminus ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  atom_map (\\<Sqinter> X) = atom_map (- \\<Squnion> (uminus ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "have \"... = Collect atom - atom_map (\\<Squnion>x \\<in> X. -x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom_map (- \\<Squnion> (uminus ` X)) =\n    Collect atom - atom_map (\\<Squnion> (uminus ` X))", "using atom_map_compl_pres"], ["proof (prove)\nusing this:\n  atom_map (- ?x) = Collect atom - atom_map ?x\n\ngoal (1 subgoal):\n 1. atom_map (- \\<Squnion> (uminus ` X)) =\n    Collect atom - atom_map (\\<Squnion> (uminus ` X))", "by blast"], ["proof (state)\nthis:\n  atom_map (- \\<Squnion> (uminus ` X)) =\n  Collect atom - atom_map (\\<Squnion> (uminus ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  atom_map (- \\<Squnion> (uminus ` X)) =\n  Collect atom - atom_map (\\<Squnion> (uminus ` X))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "have \"... = Collect atom - (\\<Union>x \\<in> X. atom_map (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect atom - atom_map (\\<Squnion> (uminus ` X)) =\n    Collect atom - (\\<Union>x\\<in>X. atom_map (- x))", "by (simp add: atom_map_Sup_pres)"], ["proof (state)\nthis:\n  Collect atom - atom_map (\\<Squnion> (uminus ` X)) =\n  Collect atom - (\\<Union>x\\<in>X. atom_map (- x))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  Collect atom - atom_map (\\<Squnion> (uminus ` X)) =\n  Collect atom - (\\<Union>x\\<in>X. atom_map (- x))\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "have \"... = Collect atom - (\\<Union>x \\<in> X. Collect atom - atom_map (x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect atom - (\\<Union>x\\<in>X. atom_map (- x)) =\n    Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x)", "using atom_map_compl_pres"], ["proof (prove)\nusing this:\n  atom_map (- ?x) = Collect atom - atom_map ?x\n\ngoal (1 subgoal):\n 1. Collect atom - (\\<Union>x\\<in>X. atom_map (- x)) =\n    Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x)", "by blast"], ["proof (state)\nthis:\n  Collect atom - (\\<Union>x\\<in>X. atom_map (- x)) =\n  Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "also"], ["proof (state)\nthis:\n  Collect atom - (\\<Union>x\\<in>X. atom_map (- x)) =\n  Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "have \"... = Collect atom \\<inter> (\\<Inter>x \\<in> X. atom_map x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x) =\n    Collect atom \\<inter> \\<Inter> (atom_map ` X)", "by blast"], ["proof (state)\nthis:\n  Collect atom - (\\<Union>x\\<in>X. Collect atom - atom_map x) =\n  Collect atom \\<inter> \\<Inter> (atom_map ` X)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "finally"], ["proof (chain)\npicking this:\n  atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)\n\ngoal (1 subgoal):\n 1. atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)", "."], ["proof (state)\nthis:\n  atom_map (\\<Sqinter> X) = Collect atom \\<inter> \\<Inter> (atom_map ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>It follows that homomorphic images of complete boolean algebras under atom-map form\ncomplete boolean algebras.\\<close>"], ["", "instantiation atoms :: (complete_boolean_algebra_alt) complete_boolean_algebra_alt\nbegin"], ["", "lift_definition Inf_atoms :: \"'a::complete_boolean_algebra_alt atoms set \\<Rightarrow> 'a::complete_boolean_algebra_alt atoms\" is \"\\<lambda>X. Abs_atoms (Collect atom \\<inter> Inter ((`) Rep_atoms X))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition  Sup_atoms :: \"'a::complete_boolean_algebra_alt atoms set \\<Rightarrow> 'a::complete_boolean_algebra_alt atoms\" is \"\\<lambda>X. Abs_atoms (Union ((`) Rep_atoms X))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a atoms, complete_boolean_algebra_alt_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       Rep_atoms\n        (Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` A)))\n       \\<subseteq> Rep_atoms x\n 2. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms z \\<subseteq> Rep_atoms x) \\<Longrightarrow>\n       Rep_atoms z\n       \\<subseteq> Rep_atoms\n                    (Abs_atoms\n                      (Collect atom \\<inter> \\<Inter> (Rep_atoms ` A)))\n 3. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       Rep_atoms x\n       \\<subseteq> Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n 4. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms x \\<subseteq> Rep_atoms z) \\<Longrightarrow>\n       Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n       \\<subseteq> Rep_atoms z\n 5. Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` {})) =\n    Abs_atoms (Collect atom)\n 6. Abs_atoms (\\<Union> (Rep_atoms ` {})) = Abs_atoms {}", "apply (metis (no_types, hide_lams) Abs_atoms_inverse image_iff inf_le1 le_Inf_iff le_infI2 order_refl rangeI surj_atom_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms z \\<subseteq> Rep_atoms x) \\<Longrightarrow>\n       Rep_atoms z\n       \\<subseteq> Rep_atoms\n                    (Abs_atoms\n                      (Collect atom \\<inter> \\<Inter> (Rep_atoms ` A)))\n 2. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       Rep_atoms x\n       \\<subseteq> Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n 3. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms x \\<subseteq> Rep_atoms z) \\<Longrightarrow>\n       Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n       \\<subseteq> Rep_atoms z\n 4. Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` {})) =\n    Abs_atoms (Collect atom)\n 5. Abs_atoms (\\<Union> (Rep_atoms ` {})) = Abs_atoms {}", "apply (metis (no_types, lifting) Abs_atoms_inverse Int_subset_iff Rep_atoms Sup_upper atom_map_atoms inf_le1 le_INF_iff rangeI surj_atom_map)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x A.\n       x \\<in> A \\<Longrightarrow>\n       Rep_atoms x\n       \\<subseteq> Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n 2. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms x \\<subseteq> Rep_atoms z) \\<Longrightarrow>\n       Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n       \\<subseteq> Rep_atoms z\n 3. Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` {})) =\n    Abs_atoms (Collect atom)\n 4. Abs_atoms (\\<Union> (Rep_atoms ` {})) = Abs_atoms {}", "apply (metis Abs_atoms_inverse Rep_atoms SUP_least SUP_upper Sup_upper atom_map_atoms rangeI surj_atom_map)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x.\n           x \\<in> A \\<Longrightarrow>\n           Rep_atoms x \\<subseteq> Rep_atoms z) \\<Longrightarrow>\n       Rep_atoms (Abs_atoms (\\<Union> (Rep_atoms ` A)))\n       \\<subseteq> Rep_atoms z\n 2. Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` {})) =\n    Abs_atoms (Collect atom)\n 3. Abs_atoms (\\<Union> (Rep_atoms ` {})) = Abs_atoms {}", "apply (metis Abs_atoms_inverse Rep_atoms SUP_least Sup_upper atom_map_atoms rangeI surj_atom_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_atoms (Collect atom \\<inter> \\<Inter> (Rep_atoms ` {})) =\n    Abs_atoms (Collect atom)\n 2. Abs_atoms (\\<Union> (Rep_atoms ` {})) = Abs_atoms {}", "by simp_all"], ["", "end"], ["", "text \\<open>Once more, properties proved above can now be restricted to at-map.\\<close>"], ["", "lemma  surj_at_map_var: \"at_map \\<circ> Sup \\<circ> Rep_atoms = (id::'a::complete_boolean_algebra_alt atoms \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map \\<circ> Sup \\<circ> Rep_atoms = id", "unfolding at_map_def comp_def fun_eq_iff id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Abs_atoms (atom_map (\\<Squnion> Rep_atoms x)) = x", "by (metis Rep_atoms Rep_atoms_inverse Sup_upper atom_map_atoms surj_atom_map)"], ["", "lemma surj_at_map: \"surj (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) at_map)", "unfolding surj_def at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = Abs_atoms (atom_map x)", "by (metis Rep_atoms Rep_atoms_inverse image_iff)"], ["", "lemma at_map_Sup_pres: \"at_map \\<circ> Sup = Sup \\<circ> (`) (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres at_map", "unfolding fun_eq_iff at_map_def comp_def atom_map_Sup_pres"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Abs_atoms (\\<Union> (atom_map ` x)) =\n       (\\<Squnion>x\\<in>x. Abs_atoms (atom_map x))", "by (smt Abs_atoms_inverse Sup.SUP_cong Sup_atoms.transfer UN_extend_simps(10) rangeI)"], ["", "lemma at_map_Sup_pres_var: \"at_map (\\<Squnion>X) = (\\<Squnion>(x::'a::complete_boolean_algebra_alt) \\<in> X. (at_map x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map (\\<Squnion> X) = \\<Squnion> (at_map ` X)", "using at_map_Sup_pres comp_eq_elim"], ["proof (prove)\nusing this:\n  Sup_pres at_map\n  \\<lbrakk>?a \\<circ> ?b = ?c \\<circ> ?d;\n   (\\<And>v. ?a (?b v) = ?c (?d v)) \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. at_map (\\<Squnion> X) = \\<Squnion> (at_map ` X)", "by blast"], ["", "lemma at_map_Inf_pres: \"at_map (\\<Sqinter>X) = Abs_atoms (Collect atom \\<sqinter> (\\<Sqinter>x \\<in> X. (Rep_atoms (at_map (x::'a::complete_boolean_algebra_alt)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_map (\\<Sqinter> X) =\n    Abs_atoms\n     (Collect atom \\<inter> (\\<Inter>x\\<in>X. Rep_atoms (at_map x)))", "unfolding at_map_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_atoms (atom_map (\\<Sqinter> X)) =\n    Abs_atoms\n     (Collect atom \\<inter>\n      (\\<Inter>x\\<in>X. Rep_atoms (Abs_atoms (atom_map x))))", "by (metis (no_types, lifting) Abs_atoms_inverse Sup.SUP_cong atom_map_Inf_pres rangeI)"], ["", "lemma at_map_Inf_pres_var: \"at_map \\<circ> Inf = Inf \\<circ> (`) (at_map::'a::complete_boolean_algebra_alt \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres at_map", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. at_map (\\<Sqinter> x) = \\<Sqinter> (at_map ` x)", "by (metis Inf_atoms.abs_eq at_map_Inf_pres image_image)"], ["", "text \\<open>Finally, on complete atomic boolean algebras (CABAs), at-map is an isomorphism, that is, a bijection \nthat preserves the complete boolean algebra operations. Thus every CABA is isomorphic to a powerset boolean algebra\nand every powerset boolean algebra is a CABA. The bijective pair is given by at-map and Sup (defined on the powerset algebra).\nThis theorem is a little version of Stone's theorem. In the general case, ultrafilters play the role of atoms.\\<close>"], ["", "lemma \"Sup \\<circ> atom_map = (id::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> atom_map = id", "unfolding fun_eq_iff comp_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Squnion> atom_map x = x", "by (metis Union_upper atom_map_atoms inj_atom_map inj_def rangeI surj_atom_map)"], ["", "lemma inj_at_map_var: \"Sup \\<circ> Rep_atoms \\<circ> at_map  = (id ::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> Rep_atoms \\<circ> at_map = id", "unfolding at_map_def comp_def fun_eq_iff id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Squnion> Rep_atoms (Abs_atoms (atom_map x)) = x", "by (metis Abs_atoms_inverse Union_upper atom_map_atoms inj_atom_map inj_def rangeI surj_atom_map)"], ["", "lemma bij_at_map: \"bij (at_map::'a::complete_atomic_boolean_algebra \\<Rightarrow> 'a atoms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij at_map", "unfolding bij_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj at_map \\<and> top_pres ((`) at_map)", "by (simp add: inj_at_map surj_at_map)"], ["", "instance atoms :: (complete_atomic_boolean_algebra) complete_atomic_boolean_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a atoms, complete_atomic_boolean_algebra_class)", ".."], ["", "text \\<open>A full consideration of Stone duality is left for future work.\\<close>"], ["", "(* Failed attempt to prove Tarski's fixpoint theorem: The problem is that we want to use mono, but this has two type parameters. It doesn't work inside of the one-type-parameter typedef.\nYet isotonicity is needed to prove inhabitance of the type. I could develop a theory of isotone endos and prove the existence of \nlfps and gfps, duplicating the more general facts for mono. But that's not the point. Because of this I see no direct way of proving\nTarski's fixpoint theorem. Any way out?\n\nclass complete_lattice_with_iso = complete_lattice +\n  fixes f :: \"'a \\<Rightarrow> 'a\"\n(*  assumes isof: \"x \\<le> y \\<Longrightarrow> f x \\<le> f y\"*)\n\ntypedef (overloaded) 'a Fix = \"Fix (f::'a::complete_lattice_with_iso \\<Rightarrow> 'a)\" \n\n\nsetup_lifting type_definition_Fix\n\n*)"], ["", "end"]]}