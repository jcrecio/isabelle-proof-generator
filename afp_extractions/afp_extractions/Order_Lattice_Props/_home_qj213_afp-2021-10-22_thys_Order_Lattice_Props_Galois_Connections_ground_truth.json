{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Galois_Connections.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma ladj_radj_dual:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))\"", "lemma radj_ladj_dual: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"radj f x = \\<partial> (ladj (\\<partial>\\<^sub>F f) (\\<partial> x))\"", "lemma ladj_prop: \n  fixes g :: \"'b::Inf \\<Rightarrow> 'a::ord_with_dual\"\n  shows \"ladj g = Inf \\<circ> (-`) g \\<circ> \\<up>\"", "lemma radj_prop: \n  fixes f :: \"'b::Sup \\<Rightarrow> 'a::ord\"\n  shows \"radj f = Sup \\<circ> (-`) f \\<circ> \\<down>\"", "lemma adj_iso1: \"f \\<stileturn> g \\<Longrightarrow> mono f\"", "lemma adj_iso2: \"f \\<stileturn> g \\<Longrightarrow> mono g\"", "lemma adj_comp: \"f \\<stileturn> g \\<Longrightarrow> adj h k \\<Longrightarrow> (f \\<circ> h) \\<stileturn> (k \\<circ> g)\"", "lemma adj_dual: \n  fixes f :: \"'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"f \\<stileturn> g = (\\<partial>\\<^sub>F g) \\<stileturn> (\\<partial>\\<^sub>F f)\"", "lemma adj_cancel1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::ord\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> id\"", "lemma adj_cancel2: \n  fixes f :: \"'a::ord \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> id \\<le> g \\<circ> f\"", "lemma adj_prop: \n  fixes f :: \"'a::preorder \\<Rightarrow>'a\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> g \\<circ> f\"", "lemma adj_cancel_eq1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<circ> f = f\"", "lemma adj_cancel_eq2: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> g \\<circ> f \\<circ> g = g\"", "lemma adj_idem1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> (f \\<circ> g) \\<circ> (f \\<circ> g) = f \\<circ> g\"", "lemma adj_idem2: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> (g \\<circ> f) \\<circ> (g \\<circ> f) = g \\<circ> f\"", "lemma adj_iso3: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> mono (f \\<circ> g)\"", "lemma adj_iso4: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> mono (g \\<circ> f)\"", "lemma adj_canc1: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::ord\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((f \\<circ> g) x = (f \\<circ> g) y \\<longrightarrow> g x = g y)\"", "lemma adj_canc2: \n  fixes f :: \"'a::ord \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((g \\<circ> f) x = (g \\<circ> f) y \\<longrightarrow> f x = f y)\"", "lemma adj_sur_inv: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((surj f) = (f \\<circ> g = id))\"", "lemma adj_surj_inj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((surj f) = (inj g))\"", "lemma adj_inj_inv: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((inj f) = (g \\<circ> f = id))\"", "lemma adj_inj_surj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\" \n  shows \"f \\<stileturn> g \\<Longrightarrow> ((inj f) = (surj g))\"", "lemma surj_id_the_inv: \"surj f \\<Longrightarrow> g \\<circ> f = id \\<Longrightarrow> g = the_inv f\"", "lemma inj_id_the_inv: \"inj f \\<Longrightarrow> f \\<circ> g = id \\<Longrightarrow> f = the_inv g\"", "lemma radj_Inf_pres: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"(\\<exists>f. f \\<stileturn> g) \\<Longrightarrow> Inf_pres g\"", "lemma ladj_Sup_pres: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"(\\<exists>g. f \\<stileturn> g) \\<Longrightarrow> Sup_pres f\"", "lemma radj_adj: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> g = (radj f)\"", "lemma ladj_adj: \n  fixes g :: \"'b::complete_lattice_with_dual \\<Rightarrow> 'a::complete_lattice_with_dual\" \n  shows \"f \\<stileturn> g \\<Longrightarrow> f = (ladj g)\"", "lemma Inf_pres_radj_aux: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres g \\<Longrightarrow> (ladj g) \\<stileturn> g\"", "lemma Sup_pres_ladj_aux: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\" \n  shows \"Sup_pres f \\<Longrightarrow> f \\<stileturn> (radj f)\"", "lemma Inf_pres_radj: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"Inf_pres g \\<Longrightarrow> (\\<exists>f. f \\<stileturn> g)\"", "lemma Sup_pres_ladj: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"Sup_pres f \\<Longrightarrow> (\\<exists>g. f \\<stileturn> g)\"", "lemma Inf_pres_upper_adj_eq: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"(Inf_pres g) = (\\<exists>f. f \\<stileturn> g)\"", "lemma Sup_pres_ladj_eq:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows  \"(Sup_pres f) = (\\<exists>g. f \\<stileturn> g)\"", "lemma Sup_downset_adj: \"(Sup::'a::complete_lattice set \\<Rightarrow> 'a) \\<stileturn> \\<down>\"", "lemma Sup_downset_adj_var: \"(Sup (X::'a::complete_lattice set) \\<le> y) = (X \\<subseteq> \\<down>y)\""], "translations": [["", "lemma ladj_radj_dual:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "have \"ladj f x = \\<partial> (\\<Squnion>(\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladj f x =\n    \\<partial>\n     (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))", "unfolding ladj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {y. x \\<le> f y} =\n    \\<partial>\n     (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))", "by (metis (no_types, lifting) Collect_cong Inf_dual_var dual_dual_ord dual_iff)"], ["proof (state)\nthis:\n  ladj f x =\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\n\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "also"], ["proof (state)\nthis:\n  ladj f x =\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\n\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "have \"... =  \\<partial> (\\<Squnion>{\\<partial> y|y. \\<partial> (f y) \\<le> \\<partial> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\n     (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x})) =\n    \\<partial>\n     (\\<Squnion> {\\<partial> y |y. \\<partial> (f y) \\<le> \\<partial> x})", "by (simp add: setcompr_eq_image)"], ["proof (state)\nthis:\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x})) =\n  \\<partial>\n   (\\<Squnion> {\\<partial> y |y. \\<partial> (f y) \\<le> \\<partial> x})\n\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "ultimately"], ["proof (chain)\npicking this:\n  ladj f x =\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x})) =\n  \\<partial>\n   (\\<Squnion> {\\<partial> y |y. \\<partial> (f y) \\<le> \\<partial> x})", "show ?thesis"], ["proof (prove)\nusing this:\n  ladj f x =\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x})) =\n  \\<partial>\n   (\\<Squnion> {\\<partial> y |y. \\<partial> (f y) \\<le> \\<partial> x})\n\ngoal (1 subgoal):\n 1. ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))", "unfolding ladj_def radj_def map_dual_def comp_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> {y. x \\<le> f y} =\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x}))\n  \\<partial>\n   (\\<Squnion> (\\<partial> ` {y. \\<partial> (f y) \\<le> \\<partial> x})) =\n  \\<partial>\n   (\\<Squnion> {\\<partial> y |y. \\<partial> (f y) \\<le> \\<partial> x})\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {y. x \\<le> f y} =\n    \\<partial>\n     (\\<Squnion> {xa. \\<partial> (f (\\<partial> xa)) \\<le> \\<partial> x})", "by (smt Collect_cong invol_dual_var)"], ["proof (state)\nthis:\n  ladj f x = \\<partial> (radj (\\<partial>\\<^sub>F f) (\\<partial> x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radj_ladj_dual: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"radj f x = \\<partial> (ladj (\\<partial>\\<^sub>F f) (\\<partial> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radj f x = \\<partial> (ladj (\\<partial>\\<^sub>F f) (\\<partial> x))", "by (metis fun_dual5 invol_dual_var ladj_radj_dual map_dual_def)"], ["", "lemma ladj_prop: \n  fixes g :: \"'b::Inf \\<Rightarrow> 'a::ord_with_dual\"\n  shows \"ladj g = Inf \\<circ> (-`) g \\<circ> \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ladj g = Inf \\<circ> (-`) g \\<circ> \\<up>", "unfolding ladj_def vimage_def upset_prop fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<Sqinter> {y. x \\<le> g y} =\n       \\<Sqinter> {xa. g xa \\<in> Collect ((\\<le>) x)}", "by simp"], ["", "lemma radj_prop: \n  fixes f :: \"'b::Sup \\<Rightarrow> 'a::ord\"\n  shows \"radj f = Sup \\<circ> (-`) f \\<circ> \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radj f = Sup \\<circ> (-`) f \\<circ> \\<down>", "unfolding radj_def vimage_def downset_prop fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<Squnion> {xa. f xa \\<le> x} =\n       \\<Squnion> {xa. f xa \\<in> {y. y \\<le> x}}", "by simp"], ["", "text \\<open>The first set of properties holds without any sort assumptions.\\<close>"], ["", "lemma adj_iso1: \"f \\<stileturn> g \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> mono f", "unfolding adj_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (meson dual_order.refl dual_order.trans)"], ["", "lemma adj_iso2: \"f \\<stileturn> g \\<Longrightarrow> mono g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> mono g", "unfolding adj_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> g x \\<le> g y", "by (meson dual_order.refl dual_order.trans)"], ["", "lemma adj_comp: \"f \\<stileturn> g \\<Longrightarrow> adj h k \\<Longrightarrow> (f \\<circ> h) \\<stileturn> (k \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<stileturn> g; h \\<stileturn> k\\<rbrakk>\n    \\<Longrightarrow> (f \\<circ> h) \\<stileturn> (k \\<circ> g)", "by (simp add: adj_def)"], ["", "lemma adj_dual: \n  fixes f :: \"'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual\"\n  shows \"f \\<stileturn> g = (\\<partial>\\<^sub>F g) \\<stileturn> (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g =\n    \\<partial>\\<^sub>F g \\<stileturn> \\<partial>\\<^sub>F f", "unfolding adj_def map_dual_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. (f x \\<le> y) = (x \\<le> g y)) =\n    (\\<forall>x y.\n        (\\<partial> (g (\\<partial> x)) \\<le> y) =\n        (x \\<le> \\<partial> (f (\\<partial> y))))", "by (metis (mono_tags, hide_lams) dual_dual_ord invol_dual_var)"], ["", "subsection \\<open>Properties for (Pre)Orders\\<close>"], ["", "text \\<open>The next set of properties holds in preorders or orders.\\<close>"], ["", "lemma adj_cancel1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::ord\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> id", "by (simp add: adj_def le_funI)"], ["", "lemma adj_cancel2: \n  fixes f :: \"'a::ord \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> id \\<le> g \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> id \\<le> g \\<circ> f", "by (simp add: adj_def eq_iff le_funI)"], ["", "lemma adj_prop: \n  fixes f :: \"'a::preorder \\<Rightarrow>'a\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> g \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> g \\<circ> f", "using adj_cancel1 adj_cancel2 order_trans"], ["proof (prove)\nusing this:\n  ?f \\<stileturn> ?g \\<Longrightarrow> ?f \\<circ> ?g \\<le> id\n  ?f \\<stileturn> ?g \\<Longrightarrow> id \\<le> ?g \\<circ> ?f\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<le> g \\<circ> f", "by blast"], ["", "lemma adj_cancel_eq1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<circ> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> f \\<circ> g \\<circ> f = f", "unfolding adj_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    \\<forall>x. f (g (f x)) = f x", "by (meson eq_iff order_refl order_trans)"], ["", "lemma adj_cancel_eq2: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> g \\<circ> f \\<circ> g = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> g \\<circ> f \\<circ> g = g", "unfolding adj_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    \\<forall>x. g (f (g x)) = g x", "by (meson eq_iff order_refl order_trans)"], ["", "lemma adj_idem1: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> (f \\<circ> g) \\<circ> (f \\<circ> g) = f \\<circ> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow>\n    f \\<circ> g \\<circ> (f \\<circ> g) = f \\<circ> g", "by (simp add: adj_cancel_eq1 rewriteL_comp_comp)"], ["", "lemma adj_idem2: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::preorder\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> (g \\<circ> f) \\<circ> (g \\<circ> f) = g \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow>\n    g \\<circ> f \\<circ> (g \\<circ> f) = g \\<circ> f", "by (simp add: adj_cancel_eq2 rewriteL_comp_comp)"], ["", "lemma adj_iso3: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> mono (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> mono (f \\<circ> g)", "by (simp add: adj_iso1 adj_iso2 monoD monoI)"], ["", "lemma adj_iso4: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> mono (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> mono (g \\<circ> f)", "by (simp add: adj_iso1 adj_iso2 monoD monoI)"], ["", "lemma adj_canc1: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::ord\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((f \\<circ> g) x = (f \\<circ> g) y \\<longrightarrow> g x = g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow>\n    (f \\<circ> g) x = (f \\<circ> g) y \\<longrightarrow> g x = g y", "unfolding adj_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    f (g x) = f (g y) \\<longrightarrow> g x = g y", "by (metis eq_iff)"], ["", "lemma adj_canc2: \n  fixes f :: \"'a::ord \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((g \\<circ> f) x = (g \\<circ> f) y \\<longrightarrow> f x = f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow>\n    (g \\<circ> f) x = (g \\<circ> f) y \\<longrightarrow> f x = f y", "unfolding adj_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    g (f x) = g (f y) \\<longrightarrow> f x = f y", "by (metis eq_iff)"], ["", "lemma adj_sur_inv: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((surj f) = (f \\<circ> g = id))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> top_pres ((`) f) = (f \\<circ> g = id)", "unfolding adj_def surj_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    (\\<forall>y. \\<exists>x. y = f x) = ((\\<lambda>x. f (g x)) = id)", "by (metis eq_id_iff eq_iff order_refl order_trans)"], ["", "lemma adj_surj_inj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((surj f) = (inj g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> top_pres ((`) f) = inj g", "unfolding adj_def inj_def surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    (\\<forall>y. \\<exists>x. y = f x) =\n    (\\<forall>x y. g x = g y \\<longrightarrow> x = y)", "by (metis eq_iff order_trans)"], ["", "lemma adj_inj_inv: \n  fixes f :: \"'a::preorder \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> ((inj f) = (g \\<circ> f = id))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> inj f = (g \\<circ> f = id)", "by (metis adj_cancel_eq1 eq_id_iff inj_def o_apply)"], ["", "lemma adj_inj_surj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\" \n  shows \"f \\<stileturn> g \\<Longrightarrow> ((inj f) = (surj g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> inj f = top_pres ((`) g)", "unfolding adj_def inj_def surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    (\\<forall>x y. f x = f y \\<longrightarrow> x = y) =\n    (\\<forall>y. \\<exists>x. y = g x)", "by (metis eq_iff order_trans)"], ["", "lemma surj_id_the_inv: \"surj f \\<Longrightarrow> g \\<circ> f = id \\<Longrightarrow> g = the_inv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>top_pres ((`) f); g \\<circ> f = id\\<rbrakk>\n    \\<Longrightarrow> g = the_inv f", "by (metis comp_apply id_apply inj_on_id inj_on_imageI2 surj_fun_eq the_inv_f_f)"], ["", "lemma inj_id_the_inv: \"inj f \\<Longrightarrow> f \\<circ> g = id \\<Longrightarrow> f = the_inv g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; f \\<circ> g = id\\<rbrakk>\n    \\<Longrightarrow> f = the_inv g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; f \\<circ> g = id\\<rbrakk>\n    \\<Longrightarrow> f = the_inv g", "assume a1: \"inj f\""], ["proof (state)\nthis:\n  inj f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; f \\<circ> g = id\\<rbrakk>\n    \\<Longrightarrow> f = the_inv g", "assume \"f \\<circ> g = id\""], ["proof (state)\nthis:\n  f \\<circ> g = id\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; f \\<circ> g = id\\<rbrakk>\n    \\<Longrightarrow> f = the_inv g", "hence \"\\<forall>x. the_inv g x = f x\""], ["proof (prove)\nusing this:\n  f \\<circ> g = id\n\ngoal (1 subgoal):\n 1. \\<forall>x. the_inv g x = f x", "using a1"], ["proof (prove)\nusing this:\n  f \\<circ> g = id\n  inj f\n\ngoal (1 subgoal):\n 1. \\<forall>x. the_inv g x = f x", "by (metis (no_types) comp_apply eq_id_iff inj_on_id inj_on_imageI2 the_inv_f_f)"], ["proof (state)\nthis:\n  \\<forall>x. the_inv g x = f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inj f; f \\<circ> g = id\\<rbrakk>\n    \\<Longrightarrow> f = the_inv g", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. the_inv g x = f x\n\ngoal (1 subgoal):\n 1. f = the_inv g", "by presburger"], ["proof (state)\nthis:\n  f = the_inv g\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties for Complete Lattices\\<close>"], ["", "text \\<open>The next laws state that a function between complete lattices preserves infs \n  if and only if it has a lower adjoint.\\<close>"], ["", "lemma radj_Inf_pres: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"(\\<exists>f. f \\<stileturn> g) \\<Longrightarrow> Inf_pres g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. f \\<stileturn> g \\<Longrightarrow> Inf_pres g", "apply (rule antisym, simp_all add: le_fun_def adj_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x.\n       \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n       g (\\<Sqinter> x) \\<le> \\<Sqinter> (g ` x)\n 2. \\<And>f x.\n       \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n       \\<Sqinter> (g ` x) \\<le> g (\\<Sqinter> x)", "apply (meson INF_greatest Inf_lower dual_order.refl dual_order.trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n       \\<Sqinter> (g ` x) \\<le> g (\\<Sqinter> x)", "by (meson Inf_greatest dual_order.refl le_INF_iff)"], ["", "lemma ladj_Sup_pres: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"(\\<exists>g. f \\<stileturn> g) \\<Longrightarrow> Sup_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. f \\<stileturn> g \\<Longrightarrow> Sup_pres f", "using Sup_pres_map_dual_var adj_dual radj_Inf_pres"], ["proof (prove)\nusing this:\n  Sup_pres ?f = Inf_pres (\\<partial>\\<^sub>F ?f)\n  ?f \\<stileturn> ?g =\n  \\<partial>\\<^sub>F ?g \\<stileturn> \\<partial>\\<^sub>F ?f\n  \\<exists>f. f \\<stileturn> ?g \\<Longrightarrow> Inf_pres ?g\n\ngoal (1 subgoal):\n 1. \\<exists>g. f \\<stileturn> g \\<Longrightarrow> Sup_pres f", "by blast"], ["", "lemma radj_adj: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> g = (radj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> g = radj f", "unfolding adj_def radj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    g = (\\<lambda>y. \\<Squnion> {x. f x \\<le> y})", "by (metis (mono_tags, lifting) cSup_eq_maximum eq_iff mem_Collect_eq)"], ["", "lemma ladj_adj: \n  fixes g :: \"'b::complete_lattice_with_dual \\<Rightarrow> 'a::complete_lattice_with_dual\" \n  shows \"f \\<stileturn> g \\<Longrightarrow> f = (ladj g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> f = ladj g", "unfolding adj_def ladj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. (f x \\<le> y) = (x \\<le> g y) \\<Longrightarrow>\n    f = (\\<lambda>x. \\<Sqinter> {y. x \\<le> g y})", "by (metis (no_types, lifting) cInf_eq_minimum eq_iff mem_Collect_eq)"], ["", "lemma Inf_pres_radj_aux: \n  fixes g :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres g \\<Longrightarrow> (ladj g) \\<stileturn> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "assume a: \"Inf_pres g\""], ["proof (state)\nthis:\n  Inf_pres g\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "{"], ["proof (state)\nthis:\n  Inf_pres g\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "assume b: \"ladj g x \\<le> y\""], ["proof (state)\nthis:\n  ladj g x \\<le> y\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "hence \"g (ladj g x) \\<le> g y\""], ["proof (prove)\nusing this:\n  ladj g x \\<le> y\n\ngoal (1 subgoal):\n 1. g (ladj g x) \\<le> g y", "by (simp add: Inf_subdistl_iso a monoD)"], ["proof (state)\nthis:\n  g (ladj g x) \\<le> g y\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "hence \"\\<Sqinter>{g y |y. x \\<le> g y} \\<le> g y\""], ["proof (prove)\nusing this:\n  g (ladj g x) \\<le> g y\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {g y |y. x \\<le> g y} \\<le> g y", "by (metis a comp_eq_dest_lhs setcompr_eq_image ladj_def)"], ["proof (state)\nthis:\n  \\<Sqinter> {g y |y. x \\<le> g y} \\<le> g y\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "hence \"x \\<le> g y\""], ["proof (prove)\nusing this:\n  \\<Sqinter> {g y |y. x \\<le> g y} \\<le> g y\n\ngoal (1 subgoal):\n 1. x \\<le> g y", "using dual_order.trans le_Inf_iff"], ["proof (prove)\nusing this:\n  \\<Sqinter> {g y |y. x \\<le> g y} \\<le> g y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?b \\<le> \\<Sqinter> ?A) = (\\<forall>a\\<in>?A. ?b \\<le> a)\n\ngoal (1 subgoal):\n 1. x \\<le> g y", "by blast"], ["proof (state)\nthis:\n  x \\<le> g y\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "hence \"ladj g x \\<le> y \\<longrightarrow> x \\<le> g y\""], ["proof (prove)\nusing this:\n  x \\<le> g y\n\ngoal (1 subgoal):\n 1. ladj g x \\<le> y \\<longrightarrow> x \\<le> g y", "by simp"], ["proof (state)\nthis:\n  ladj g x \\<le> y \\<longrightarrow> x \\<le> g y\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "}"], ["proof (state)\nthis:\n  ladj g ?x2 \\<le> ?y2 \\<Longrightarrow>\n  ladj g ?x2 \\<le> ?y2 \\<longrightarrow> ?x2 \\<le> g ?y2\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> ladj g \\<stileturn> g", "thus ?thesis"], ["proof (prove)\nusing this:\n  ladj g ?x2 \\<le> ?y2 \\<Longrightarrow>\n  ladj g ?x2 \\<le> ?y2 \\<longrightarrow> ?x2 \\<le> g ?y2\n\ngoal (1 subgoal):\n 1. ladj g \\<stileturn> g", "unfolding adj_def ladj_def"], ["proof (prove)\nusing this:\n  \\<Sqinter> {y. ?x2 \\<le> g y} \\<le> ?y2 \\<Longrightarrow>\n  \\<Sqinter> {y. ?x2 \\<le> g y} \\<le> ?y2 \\<longrightarrow> ?x2 \\<le> g ?y2\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (\\<Sqinter> {y. x \\<le> g y} \\<le> y) = (x \\<le> g y)", "by (meson CollectI Inf_lower)"], ["proof (state)\nthis:\n  ladj g \\<stileturn> g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_pres_ladj_aux: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\" \n  shows \"Sup_pres f \\<Longrightarrow> f \\<stileturn> (radj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> f \\<stileturn> radj f", "by (metis (no_types, hide_lams) Inf_pres_radj_aux Sup_pres_map_dual_var adj_dual fun_dual5 map_dual_def radj_adj)"], ["", "lemma Inf_pres_radj: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"Inf_pres g \\<Longrightarrow> (\\<exists>f. f \\<stileturn> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> \\<exists>f. f \\<stileturn> g", "using Inf_pres_radj_aux"], ["proof (prove)\nusing this:\n  Inf_pres ?g \\<Longrightarrow> ladj ?g \\<stileturn> ?g\n\ngoal (1 subgoal):\n 1. Inf_pres g \\<Longrightarrow> \\<exists>f. f \\<stileturn> g", "by fastforce"], ["", "lemma Sup_pres_ladj: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows \"Sup_pres f \\<Longrightarrow> (\\<exists>g. f \\<stileturn> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> \\<exists>g. f \\<stileturn> g", "using Sup_pres_ladj_aux"], ["proof (prove)\nusing this:\n  Sup_pres ?f \\<Longrightarrow> ?f \\<stileturn> radj ?f\n\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> \\<exists>g. f \\<stileturn> g", "by fastforce"], ["", "lemma Inf_pres_upper_adj_eq: \n  fixes g :: \"'b::complete_lattice \\<Rightarrow> 'a::complete_lattice\"\n  shows \"(Inf_pres g) = (\\<exists>f. f \\<stileturn> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres g = (\\<exists>f. f \\<stileturn> g)", "using radj_Inf_pres Inf_pres_radj"], ["proof (prove)\nusing this:\n  \\<exists>f. f \\<stileturn> ?g \\<Longrightarrow> Inf_pres ?g\n  Inf_pres ?g \\<Longrightarrow> \\<exists>f. f \\<stileturn> ?g\n\ngoal (1 subgoal):\n 1. Inf_pres g = (\\<exists>f. f \\<stileturn> g)", "by blast"], ["", "lemma Sup_pres_ladj_eq:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  shows  \"(Sup_pres f) = (\\<exists>g. f \\<stileturn> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f = (\\<exists>g. f \\<stileturn> g)", "using Sup_pres_ladj ladj_Sup_pres"], ["proof (prove)\nusing this:\n  Sup_pres ?f \\<Longrightarrow> \\<exists>g. ?f \\<stileturn> g\n  \\<exists>g. ?f \\<stileturn> g \\<Longrightarrow> Sup_pres ?f\n\ngoal (1 subgoal):\n 1. Sup_pres f = (\\<exists>g. f \\<stileturn> g)", "by blast"], ["", "lemma Sup_downset_adj: \"(Sup::'a::complete_lattice set \\<Rightarrow> 'a) \\<stileturn> \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<stileturn> \\<down>", "unfolding adj_def downset_prop Sup_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>a\\<in>x. a \\<le> y) = (x \\<subseteq> {ya. ya \\<le> y})", "by force"], ["", "lemma Sup_downset_adj_var: \"(Sup (X::'a::complete_lattice set) \\<le> y) = (X \\<subseteq> \\<down>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion> X \\<le> y) = (X \\<subseteq> \\<down> y)", "using Sup_downset_adj adj_def"], ["proof (prove)\nusing this:\n  Sup \\<stileturn> \\<down>\n  ?f \\<stileturn> ?g = (\\<forall>x y. (?f x \\<le> y) = (x \\<le> ?g y))\n\ngoal (1 subgoal):\n 1. (\\<Squnion> X \\<le> y) = (X \\<subseteq> \\<down> y)", "by auto"], ["", "text \\<open>Once again many statements arise by duality, which Isabelle usually picks up.\\<close>"], ["", "end"]]}