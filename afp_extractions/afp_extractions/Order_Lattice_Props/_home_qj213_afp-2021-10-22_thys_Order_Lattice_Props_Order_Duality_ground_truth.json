{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Order_Duality.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma invol_dual_var [simp]: \"\\<partial> (\\<partial> x) = x\"", "lemma surj_dual: \"surj \\<partial>\"", "lemma bij_dual: \"bij \\<partial>\"", "lemma inj_dual_iff: \"(\\<partial> x = \\<partial> y) = (x = y)\"", "lemma dual_iff: \"(\\<partial> x = y) = (x = \\<partial> y)\"", "lemma the_inv_dual: \"the_inv \\<partial> = \\<partial>\"", "lemma map_dual_func1: \"\\<partial>\\<^sub>F (f \\<circ> g) = \\<partial>\\<^sub>F f \\<circ> \\<partial>\\<^sub>F g\"", "lemma map_dual_func2 [simp]: \"\\<partial>\\<^sub>F id = id\"", "lemma map_dual_nat_iso: \"\\<partial>\\<^sub>F f \\<circ> \\<partial> = \\<partial> \\<circ> id f\"", "lemma map_dual_invol [simp]: \"\\<partial>\\<^sub>F \\<circ> \\<partial>\\<^sub>F = id\"", "lemma eta_inj: \"inj \\<eta>\"", "lemma set_dual_prop: \"set_dual (\\<partial> x) = {x}\"", "lemma image_func1: \"(`) (f \\<circ> g) = (`) f \\<circ> (`) g\"", "lemma image_func2: \"(`) id = id\"", "lemma vimage_func1: \"(-`) (f \\<circ> g) = (-`) g \\<circ> (-`) f\"", "lemma vimage_func2: \"(-`) id = id\"", "lemma iso_image: \"mono ((`) f)\"", "lemma iso_preimage: \"mono ((-`) f)\"", "lemma image_dual [simp]: \"(`) \\<partial> \\<circ> (`) \\<partial> = id\"", "lemma vimage_dual [simp]: \"(-`) \\<partial> \\<circ> (-`) \\<partial> = id\"", "lemma power_set_func_nat_trans: \"\\<eta> \\<circ> id f = (`) f \\<circ> \\<eta>\"", "lemma dual_singleton: \"(`) \\<partial> \\<circ> \\<eta> = \\<eta> \\<circ> \\<partial>\"", "lemma finite_dual [simp]: \"finite \\<circ> (`) \\<partial> = finite\"", "lemma finite_dual_var [simp]: \"finite (\\<partial> ` X) = finite X\"", "lemma subset_dual: \"(X = \\<partial> ` Y) = (\\<partial> ` X = Y)\"", "lemma subset_dual1: \"(X \\<subseteq> Y) = (\\<partial> ` X \\<subseteq> \\<partial> ` Y)\"", "lemma dual_empty [simp]: \"\\<partial> ` {} = {}\"", "lemma dual_UNIV [simp]: \"\\<partial> ` UNIV = UNIV\"", "lemma fun_dual1: \"(f = g \\<circ> \\<partial>) = (f \\<circ> \\<partial> = g)\"", "lemma fun_dual2: \"(f = \\<partial> \\<circ> g) = (\\<partial> \\<circ> f = g)\"", "lemma fun_dual3: \"(f = g \\<circ> (`) \\<partial>) = (f \\<circ> (`) \\<partial> = g)\"", "lemma fun_dual4: \"(f = (`) \\<partial> \\<circ> g) = ((`) \\<partial> \\<circ> f = g)\"", "lemma fun_dual5: \"(f = \\<partial> \\<circ> g \\<circ> \\<partial>) = (\\<partial> \\<circ> f \\<circ> \\<partial> = g)\"", "lemma fun_dual6: \"(f = (`) \\<partial> \\<circ> g \\<circ> (`) \\<partial>) = ((`) \\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)\"", "lemma fun_dual7: \"(f = \\<partial> \\<circ> g \\<circ> (`) \\<partial>) = (\\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)\"", "lemma fun_dual8: \"(f = (`) \\<partial> \\<circ> g \\<circ> \\<partial>) = ((`) \\<partial> \\<circ> f \\<circ> \\<partial> = g)\"", "lemma map_dual_dual: \"(\\<partial>\\<^sub>F f = g) = (\\<partial>\\<^sub>F g = f)\"", "lemma dual_dual_ord: \"(\\<partial> x \\<le> \\<partial> y) = (y \\<le> x)\"", "lemma ord_pres_dual:\n  fixes f :: \"'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual\"   \n  shows \"ord_pres f \\<Longrightarrow> ord_pres (\\<partial>\\<^sub>F f)\"", "lemma map_dual_anti: \"(f::'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual) \\<le> g  \\<Longrightarrow> \\<partial>\\<^sub>F g \\<le> \\<partial>\\<^sub>F f\"", "lemma less_dual_def_var: \"(\\<partial> y < \\<partial> x) = (x < y)\"", "lemma iso_map_dual: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"   \n  shows \"mono f \\<Longrightarrow> mono (\\<partial>\\<^sub>F f)\"", "lemma inf_dual: \"\\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y\"", "lemma inf_to_sup: \"x \\<sqinter> y = \\<partial> (\\<partial> x \\<squnion> \\<partial> y)\"", "lemma sup_to_inf: \"x \\<squnion> y = \\<partial> (\\<partial> x \\<sqinter> \\<partial> y)\"", "lemma bot_dual: \"\\<partial> \\<bottom> = \\<top>\"", "lemma top_dual: \"\\<partial> \\<top> = \\<bottom>\"", "lemma Inf_dual: \"\\<partial> \\<circ> Inf = Sup \\<circ> (`) \\<partial>\"", "lemma Inf_dual_var: \"\\<partial> (\\<Sqinter>X) = \\<Squnion>(\\<partial> ` X)\"", "lemma Inf_to_Sup: \"Inf = \\<partial> \\<circ> Sup \\<circ> (`) \\<partial>\"", "lemma Inf_to_Sup_var: \"\\<Sqinter>X = \\<partial> (\\<Squnion>(\\<partial> ` X))\"", "lemma Sup_to_Inf: \"Sup = \\<partial> \\<circ> Inf \\<circ> (`) \\<partial>\"", "lemma Sup_to_Inf_var: \"\\<Squnion>X = \\<partial> (\\<Sqinter>(\\<partial> ` X))\"", "lemma Sup_dual_def_var: \"\\<partial> (\\<Squnion>X) = \\<Sqinter> (\\<partial> ` X)\"", "lemma bot_dual_def: \"\\<partial> \\<top> = \\<bottom>\"", "lemma top_dual_def: \"\\<partial> \\<bottom> = \\<top>\"", "lemma inf_dual2: \"\\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y\"", "lemma sup_dual: \"\\<partial> (x \\<squnion> y) = \\<partial> x \\<sqinter> \\<partial> y\""], "translations": [["", "lemma invol_dual_var [simp]: \"\\<partial> (\\<partial> x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (\\<partial> x) = x", "by (simp add: pointfree_idE)"], ["", "lemma surj_dual: \"surj \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj \\<partial>", "unfolding surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = \\<partial> x", "by (metis invol_dual_var)"], ["", "lemma bij_dual: \"bij \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<partial>", "by (simp add: bij_def inj_dual surj_dual)"], ["", "lemma inj_dual_iff: \"(\\<partial> x = \\<partial> y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> x = \\<partial> y) = (x = y)", "by (meson inj_dual injD)"], ["", "lemma dual_iff: \"(\\<partial> x = y) = (x = \\<partial> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> x = y) = (x = \\<partial> y)", "by auto"], ["", "lemma the_inv_dual: \"the_inv \\<partial> = \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv \\<partial> = \\<partial>", "by (metis comp_apply id_def invol_dual_var inj_dual surj_dual surj_fun_eq the_inv_f_o_f_id)"], ["", "end"], ["", "text \\<open>In boolean algebras, duality is of course De Morgan duality and can be expressed within the language.\\<close>"], ["", "sublocale boolean_algebra \\<subseteq> ba_dual: dual \"uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.dual uminus", "by (unfold_locales, simp_all add: inj_def)"], ["", "definition map_dual:: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a::dual \\<Rightarrow> 'b::dual\" (\"\\<partial>\\<^sub>F\") where \n  \"\\<partial>\\<^sub>F f = \\<partial> \\<circ> f \\<circ> \\<partial>\""], ["", "lemma map_dual_func1: \"\\<partial>\\<^sub>F (f \\<circ> g) = \\<partial>\\<^sub>F f \\<circ> \\<partial>\\<^sub>F g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sub>F (f \\<circ> g) =\n    \\<partial>\\<^sub>F f \\<circ> \\<partial>\\<^sub>F g", "by (metis (no_types, lifting) comp_assoc comp_id invol_dual map_dual_def)"], ["", "lemma map_dual_func2 [simp]: \"\\<partial>\\<^sub>F id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sub>F id = id", "by (simp add: map_dual_def)"], ["", "lemma map_dual_nat_iso: \"\\<partial>\\<^sub>F f \\<circ> \\<partial> = \\<partial> \\<circ> id f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sub>F f \\<circ> \\<partial> = \\<partial> \\<circ> id f", "by (simp add: comp_assoc map_dual_def)"], ["", "lemma map_dual_invol [simp]: \"\\<partial>\\<^sub>F \\<circ> \\<partial>\\<^sub>F = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sub>F \\<circ> \\<partial>\\<^sub>F = id", "unfolding map_dual_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       \\<partial> (\\<partial> (x (\\<partial> (\\<partial> xa)))) = id x xa", "by simp"], ["", "text \\<open>Thus map-dual is naturally isomorphic to the identify functor: The function dual is a natural transformation \nbetween  map-dual and the identity functor, and, because it has a two-sided inverse --- itself, it is a natural isomorphism.\\<close>"], ["", "text \\<open>The generic function set-dual provides another natural transformation (see below). Before introducing it, we introduce useful notation \nfor a widely used function.\\<close>"], ["", "abbreviation \"\\<eta> \\<equiv> (\\<lambda>x. {x})\""], ["", "lemma eta_inj: \"inj \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<eta>", "by simp"], ["", "definition \"set_dual = \\<eta> \\<circ> \\<partial>\""], ["", "lemma set_dual_prop: \"set_dual (\\<partial> x) = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_dual (\\<partial> x) = \\<eta> x", "by (metis comp_apply dual_iff set_dual_def)"], ["", "text \\<open>The next four lemmas show that (functional) image and preimage are functors (on functions). This does not really belong here, \nbut it is useful for what follows. The interaction between duality and (pre)images is needed in applications.\\<close>"], ["", "lemma image_func1: \"(`) (f \\<circ> g) = (`) f \\<circ> (`) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) (f \\<circ> g) = (`) f \\<circ> (`) g", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> g) ` x = ((`) f \\<circ> (`) g) x", "by (simp add: image_comp)"], ["", "lemma image_func2: \"(`) id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) id = id", "by simp"], ["", "lemma vimage_func1: \"(-`) (f \\<circ> g) = (-`) g \\<circ> (-`) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-`) (f \\<circ> g) = (-`) g \\<circ> (-`) f", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (f \\<circ> g) -` x = ((-`) g \\<circ> (-`) f) x", "by (simp add: vimage_comp)"], ["", "lemma vimage_func2: \"(-`) id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-`) id = id", "by simp"], ["", "lemma iso_image: \"mono ((`) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((`) f)", "by (simp add: image_mono monoI)"], ["", "lemma iso_preimage: \"mono ((-`) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((-`) f)", "by (simp add: monoI vimage_mono)"], ["", "context dual\nbegin"], ["", "lemma image_dual [simp]: \"(`) \\<partial> \\<circ> (`) \\<partial> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> (`) \\<partial> = id", "by (metis image_func1 image_func2 invol_dual)"], ["", "lemma vimage_dual [simp]: \"(-`) \\<partial> \\<circ> (-`) \\<partial> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (-`) \\<partial> \\<circ> (-`) \\<partial> = id", "by (simp add: set.comp)"], ["", "end"], ["", "text \\<open>The following natural transformation between the powerset functor (image) and the identity functor\nis well known.\\<close>"], ["", "lemma power_set_func_nat_trans: \"\\<eta> \\<circ> id f = (`) f \\<circ> \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<eta> \\<circ> id f = (`) f \\<circ> \\<eta>", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<eta> (id f x) = f ` \\<eta> x", "by simp"], ["", "text \\<open>As an instance, set-dual is a natural transformation with built-in type coercion.\\<close>"], ["", "lemma dual_singleton: \"(`) \\<partial> \\<circ> \\<eta> = \\<eta> \\<circ> \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<eta> = \\<eta> \\<circ> \\<partial>", "by auto"], ["", "lemma finite_dual [simp]: \"finite \\<circ> (`) \\<partial> = finite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite \\<circ> (`) \\<partial> = finite", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. finite (\\<partial> ` x) = finite x", "using inj_dual finite_vimageI inj_vimage_image_eq"], ["proof (prove)\nusing this:\n  inj \\<partial>\n  \\<lbrakk>finite ?F; inj ?h\\<rbrakk> \\<Longrightarrow> finite (?h -` ?F)\n  inj ?f \\<Longrightarrow> ?f -` ?f ` ?A = ?A\n\ngoal (1 subgoal):\n 1. \\<forall>x. finite (\\<partial> ` x) = finite x", "by fastforce"], ["", "lemma finite_dual_var [simp]: \"finite (\\<partial> ` X) = finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<partial> ` X) = finite X", "by (metis comp_def finite_dual)"], ["", "lemma subset_dual: \"(X = \\<partial> ` Y) = (\\<partial> ` X = Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X = \\<partial> ` Y) = (\\<partial> ` X = Y)", "by (metis image_dual pointfree_idE)"], ["", "lemma subset_dual1: \"(X \\<subseteq> Y) = (\\<partial> ` X \\<subseteq> \\<partial> ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<partial> ` X \\<subseteq> \\<partial> ` Y)", "by (simp add: inj_dual inj_image_subset_iff)"], ["", "lemma dual_empty [simp]: \"\\<partial> ` {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> ` {} = {}", "by simp"], ["", "lemma dual_UNIV [simp]: \"\\<partial> ` UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj \\<partial>", "by (simp add: surj_dual)"], ["", "lemma fun_dual1: \"(f = g \\<circ> \\<partial>) = (f \\<circ> \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g \\<circ> \\<partial>) = (f \\<circ> \\<partial> = g)", "by (metis comp_assoc comp_id invol_dual)"], ["", "lemma fun_dual2: \"(f = \\<partial> \\<circ> g) = (\\<partial> \\<circ> f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = \\<partial> \\<circ> g) = (\\<partial> \\<circ> f = g)", "by (metis comp_assoc fun.map_id invol_dual)"], ["", "lemma fun_dual3: \"(f = g \\<circ> (`) \\<partial>) = (f \\<circ> (`) \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g \\<circ> (`) \\<partial>) = (f \\<circ> (`) \\<partial> = g)", "by (metis comp_id image_dual o_assoc)"], ["", "lemma fun_dual4: \"(f = (`) \\<partial> \\<circ> g) = ((`) \\<partial> \\<circ> f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = (`) \\<partial> \\<circ> g) = ((`) \\<partial> \\<circ> f = g)", "by (metis comp_assoc id_comp image_dual)"], ["", "lemma fun_dual5: \"(f = \\<partial> \\<circ> g \\<circ> \\<partial>) = (\\<partial> \\<circ> f \\<circ> \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = \\<partial> \\<circ> g \\<circ> \\<partial>) =\n    (\\<partial> \\<circ> f \\<circ> \\<partial> = g)", "by (metis comp_assoc fun_dual1 fun_dual2)"], ["", "lemma fun_dual6: \"(f = (`) \\<partial> \\<circ> g \\<circ> (`) \\<partial>) = ((`) \\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = (`) \\<partial> \\<circ> g \\<circ> (`) \\<partial>) =\n    ((`) \\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)", "by (simp add: comp_assoc fun_dual3 fun_dual4)"], ["", "lemma fun_dual7: \"(f = \\<partial> \\<circ> g \\<circ> (`) \\<partial>) = (\\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = \\<partial> \\<circ> g \\<circ> (`) \\<partial>) =\n    (\\<partial> \\<circ> f \\<circ> (`) \\<partial> = g)", "by (simp add: comp_assoc fun_dual2 fun_dual3)"], ["", "lemma fun_dual8: \"(f = (`) \\<partial> \\<circ> g \\<circ> \\<partial>) = ((`) \\<partial> \\<circ> f \\<circ> \\<partial> = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = (`) \\<partial> \\<circ> g \\<circ> \\<partial>) =\n    ((`) \\<partial> \\<circ> f \\<circ> \\<partial> = g)", "by (simp add: comp_assoc fun_dual1 fun_dual4)"], ["", "lemma map_dual_dual: \"(\\<partial>\\<^sub>F f = g) = (\\<partial>\\<^sub>F g = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial>\\<^sub>F f = g) = (\\<partial>\\<^sub>F g = f)", "by (metis map_dual_invol pointfree_idE)"], ["", "text \\<open>The next facts show incrementally that the dual of a complete lattice is a complete lattice.\\<close>"], ["", "class ord_with_dual = dual + ord +\n  assumes ord_dual: \"x \\<le> y \\<Longrightarrow> \\<partial> y \\<le> \\<partial> x\"\n\nbegin"], ["", "lemma dual_dual_ord: \"(\\<partial> x \\<le> \\<partial> y) = (y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> x \\<le> \\<partial> y) = (y \\<le> x)", "by (metis dual_iff ord_dual)"], ["", "end"], ["", "lemma ord_pres_dual:\n  fixes f :: \"'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual\"   \n  shows \"ord_pres f \\<Longrightarrow> ord_pres (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_pres f \\<Longrightarrow> ord_pres (\\<partial>\\<^sub>F f)", "by (simp add: dual_dual_ord map_dual_def ord_pres_def)"], ["", "lemma map_dual_anti: \"(f::'a::ord_with_dual \\<Rightarrow> 'b::ord_with_dual) \\<le> g  \\<Longrightarrow> \\<partial>\\<^sub>F g \\<le> \\<partial>\\<^sub>F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<le> g \\<Longrightarrow>\n    \\<partial>\\<^sub>F g \\<le> \\<partial>\\<^sub>F f", "by (simp add: le_fun_def map_dual_def ord_dual)"], ["", "class preorder_with_dual = ord_with_dual + preorder\n\nbegin"], ["", "lemma less_dual_def_var: \"(\\<partial> y < \\<partial> x) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> y < \\<partial> x) = (x < y)", "by (simp add: dual_dual_ord less_le_not_le)"], ["", "end"], ["", "class order_with_dual = preorder_with_dual + order"], ["", "lemma iso_map_dual: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'b::order_with_dual\"   \n  shows \"mono f \\<Longrightarrow> mono (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (\\<partial>\\<^sub>F f)", "by (simp add: ord_pres_dual ord_pres_mono)"], ["", "class lattice_with_dual = lattice + dual +\n  assumes sup_dual_def: \"\\<partial> (x \\<squnion> y) = \\<partial> x \\<sqinter> \\<partial> y\"\n\nbegin"], ["", "subclass order_with_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order_with_dual \\<partial> (\\<le>) (<)", "by (unfold_locales, metis inf.absorb_iff2 sup_absorb1 sup_commute sup_dual_def)"], ["", "lemma inf_dual: \"\\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y", "by (metis invol_dual_var sup_dual_def)"], ["", "lemma inf_to_sup: \"x \\<sqinter> y = \\<partial> (\\<partial> x \\<squnion> \\<partial> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = \\<partial> (\\<partial> x \\<squnion> \\<partial> y)", "using inf_dual dual_iff"], ["proof (prove)\nusing this:\n  \\<partial> (?x \\<sqinter> ?y) = \\<partial> ?x \\<squnion> \\<partial> ?y\n  (\\<partial> ?x = ?y) = (?x = \\<partial> ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y = \\<partial> (\\<partial> x \\<squnion> \\<partial> y)", "by fastforce"], ["", "lemma sup_to_inf: \"x \\<squnion> y = \\<partial> (\\<partial> x \\<sqinter> \\<partial> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = \\<partial> (\\<partial> x \\<sqinter> \\<partial> y)", "by (simp add: inf_dual)"], ["", "end"], ["", "class bounded_lattice_with_dual = lattice_with_dual + bounded_lattice\n\nbegin"], ["", "lemma bot_dual: \"\\<partial> \\<bottom> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<bottom> = \\<top>", "by (metis dual_dual_ord dual_iff le_bot top_greatest)"], ["", "lemma top_dual: \"\\<partial> \\<top> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<top> = \\<bottom>", "using bot_dual dual_iff"], ["proof (prove)\nusing this:\n  \\<partial> \\<bottom> = \\<top>\n  (\\<partial> ?x = ?y) = (?x = \\<partial> ?y)\n\ngoal (1 subgoal):\n 1. \\<partial> \\<top> = \\<bottom>", "by force"], ["", "end"], ["", "class boolean_algebra_with_dual = lattice_with_dual + boolean_algebra"], ["", "sublocale boolean_algebra \\<subseteq> badual: boolean_algebra_with_dual _ _ _ _ _ _ _ _ uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.boolean_algebra_with_dual (-) uminus (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) \\<bottom> \\<top> uminus", "by unfold_locales simp_all"], ["", "class Sup_lattice_with_dual = Sup_lattice + dual +\n  assumes Sups_dual_def: \"\\<partial> \\<circ> Sup = Infs \\<circ> (`) \\<partial>\""], ["", "class Inf_lattice_with_dual = Inf_lattice + dual +\n  assumes Sups_dual_def: \"\\<partial> \\<circ> Supi = Inf \\<circ> (`) \\<partial>\""], ["", "class complete_lattice_with_dual = complete_lattice + dual +\n  assumes Sups_dual_def: \"\\<partial> \\<circ> Sup = Inf \\<circ> (`) \\<partial>\""], ["", "sublocale Sup_lattice_with_dual \\<subseteq> sclatd: complete_lattice_with_dual Infs Sup infs \"(\\<le>)\" le sups bots tops \"\\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_lattice_with_dual Infs Sup infs (\\<le>) le sups bots tops\n     \\<partial>", "by (unfold_locales, simp add: Sups_dual_def)"], ["", "sublocale Inf_lattice_with_dual \\<subseteq> iclatd: complete_lattice_with_dual Inf Supi infi \"(\\<le>)\" le supi boti topi \"\\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complete_lattice_with_dual Inf Supi infi (\\<le>) le supi boti topi\n     \\<partial>", "by (unfold_locales, simp add: Sups_dual_def)"], ["", "context complete_lattice_with_dual\nbegin"], ["", "lemma Inf_dual: \"\\<partial> \\<circ> Inf = Sup \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> Inf = Sup \\<circ> (`) \\<partial>", "by (metis comp_assoc comp_id fun.map_id Sups_dual_def image_dual invol_dual)"], ["", "lemma Inf_dual_var: \"\\<partial> (\\<Sqinter>X) = \\<Squnion>(\\<partial> ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (\\<Sqinter> X) = \\<Squnion> (\\<partial> ` X)", "using comp_eq_dest Inf_dual"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<circ> ?d \\<Longrightarrow> ?a (?b ?v) = ?c (?d ?v)\n  \\<partial> \\<circ> Inf = Sup \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. \\<partial> (\\<Sqinter> X) = \\<Squnion> (\\<partial> ` X)", "by fastforce"], ["", "lemma Inf_to_Sup: \"Inf = \\<partial> \\<circ> Sup \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf = \\<partial> \\<circ> Sup \\<circ> (`) \\<partial>", "by (auto simp add: Sups_dual_def image_comp)"], ["", "lemma Inf_to_Sup_var: \"\\<Sqinter>X = \\<partial> (\\<Squnion>(\\<partial> ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> X = \\<partial> (\\<Squnion> (\\<partial> ` X))", "using Inf_dual_var dual_iff"], ["proof (prove)\nusing this:\n  \\<partial> (\\<Sqinter> ?X) = \\<Squnion> (\\<partial> ` ?X)\n  (\\<partial> ?x = ?y) = (?x = \\<partial> ?y)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> X = \\<partial> (\\<Squnion> (\\<partial> ` X))", "by fastforce"], ["", "lemma Sup_to_Inf: \"Sup = \\<partial> \\<circ> Inf \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup = \\<partial> \\<circ> Inf \\<circ> (`) \\<partial>", "by (auto simp add: Inf_dual image_comp)"], ["", "lemma Sup_to_Inf_var: \"\\<Squnion>X = \\<partial> (\\<Sqinter>(\\<partial> ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> X = \\<partial> (\\<Sqinter> (\\<partial> ` X))", "using Sup_to_Inf"], ["proof (prove)\nusing this:\n  Sup = \\<partial> \\<circ> Inf \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. \\<Squnion> X = \\<partial> (\\<Sqinter> (\\<partial> ` X))", "by force"], ["", "lemma Sup_dual_def_var: \"\\<partial> (\\<Squnion>X) = \\<Sqinter> (\\<partial> ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (\\<Squnion> X) = \\<Sqinter> (\\<partial> ` X)", "using comp_eq_dest Sups_dual_def"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<circ> ?d \\<Longrightarrow> ?a (?b ?v) = ?c (?d ?v)\n  \\<partial> \\<circ> Sup = Inf \\<circ> (`) \\<partial>\n\ngoal (1 subgoal):\n 1. \\<partial> (\\<Squnion> X) = \\<Sqinter> (\\<partial> ` X)", "by fastforce"], ["", "lemma bot_dual_def: \"\\<partial> \\<top> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<top> = \\<bottom>", "by (smt Inf_UNIV Sup_UNIV Sups_dual_def surj_dual o_eq_dest)"], ["", "lemma top_dual_def: \"\\<partial> \\<bottom> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<bottom> = \\<top>", "using bot_dual_def dual_iff"], ["proof (prove)\nusing this:\n  \\<partial> \\<top> = \\<bottom>\n  (\\<partial> ?x = ?y) = (?x = \\<partial> ?y)\n\ngoal (1 subgoal):\n 1. \\<partial> \\<bottom> = \\<top>", "by blast"], ["", "lemma inf_dual2: \"\\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (x \\<sqinter> y) = \\<partial> x \\<squnion> \\<partial> y", "by (smt comp_eq_elim Inf_dual Inf_empty Inf_insert SUP_insert inf_top.right_neutral)"], ["", "lemma sup_dual: \"\\<partial> (x \\<squnion> y) = \\<partial> x \\<sqinter> \\<partial> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> (x \\<squnion> y) = \\<partial> x \\<sqinter> \\<partial> y", "by (metis inf_dual2 dual_iff)"], ["", "subclass lattice_with_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.lattice_with_dual (\\<sqinter>) (\\<le>) (<) (\\<squnion>) \\<partial>", "by (unfold_locales, auto simp: inf_dual sup_dual)"], ["", "subclass bounded_lattice_with_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_lattice_with_dual (\\<sqinter>) (\\<le>) (<) (\\<squnion>)\n     \\<bottom> \\<top> \\<partial>", ".."], ["", "end"], ["", "end"]]}