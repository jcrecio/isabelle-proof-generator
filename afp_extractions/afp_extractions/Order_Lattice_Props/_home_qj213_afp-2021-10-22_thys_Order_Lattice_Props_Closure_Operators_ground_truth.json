{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Closure_Operators.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma clop_extensive: \"clop f \\<Longrightarrow> id \\<le> f\"", "lemma clop_extensive_var: \"clop f \\<Longrightarrow> x \\<le> f x\"", "lemma clop_iso: \"clop f \\<Longrightarrow> mono f\"", "lemma clop_iso_var: \"clop f \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y\"", "lemma clop_idem: \"clop f \\<Longrightarrow> f \\<circ> f = f\"", "lemma clop_Fix_range: \"clop f \\<Longrightarrow> (Fix f = range f)\"", "lemma clop_idem_var: \"clop f \\<Longrightarrow> f (f x) = f x\"", "lemma clop_Inf_closed_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\" \n  shows \"clop f \\<Longrightarrow> f \\<circ> Inf \\<circ> (`) f  = Inf \\<circ> (`) f\"", "lemma clop_top:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"clop f \\<Longrightarrow> f \\<top> = \\<top>\"", "lemma \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (\\<Squnion>x \\<in> X. f x) = (\\<Squnion>x \\<in> X. f x)\"", "lemma \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y\"", "lemma  \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f \\<bottom> = \\<bottom>\"", "lemma \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (\\<Squnion>x \\<in> X. f x) = (\\<Squnion>x \\<in> X. f x)\"", "lemma \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y\"", "lemma  \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f \\<bottom> = \\<bottom>\"", "lemma clop_closure: \"clop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)\"", "lemma clop_closure_set: \"clop f \\<Longrightarrow> range f = Fix f\"", "lemma clop_closure_prop: \"(clop::('a::complete_lattice_with_dual\\<Rightarrow> 'a) \\<Rightarrow> bool) (Inf \\<circ> \\<up>)\"", "lemma clop_closure_prop_var: \"clop (\\<lambda>x::'a::complete_lattice. \\<Sqinter>{y. x \\<le> y})\"", "lemma clop_alt: \"(clop f) = (\\<forall>x y. x \\<le> f y \\<longleftrightarrow> f x \\<le> f y)\"", "lemma clop_adj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> clop (g \\<circ> f)\"", "lemma surj_surj_on: \"surj f \\<Longrightarrow> surj_on f Y\"", "lemma fun_surj_inj: \"\\<exists>g h. f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)\"", "lemma preorder_clop: \"clop (\\<Down>::'a::preorder set \\<Rightarrow> 'a set)\"", "lemma clop_preorder_aux: \"clop f \\<Longrightarrow> (x \\<in> f {y} \\<longleftrightarrow> f {x} \\<subseteq> f {y})\"", "lemma clop_preorder: \"clop f \\<Longrightarrow> class.preorder (\\<lambda>x y. f {x} \\<subseteq> f {y}) (\\<lambda>x y. f {x} \\<subset> f {y})\"", "lemma preorder_clop_dual: \"clop (\\<Up>::'a::preorder_with_dual set \\<Rightarrow> 'a set)\"", "lemma clop_Inf_closed: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"clop f \\<Longrightarrow> Inf_closed_set (Fix f)\"", "lemma clop_top_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"clop f \\<Longrightarrow> \\<top> \\<in> Fix f\"", "lemma Inf_closed_clop: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"Inf_closed_set X \\<Longrightarrow> clop (\\<lambda>y. \\<Sqinter>{x \\<in> X. y \\<le> x})\"", "lemma Inf_closed_clop_var: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"clop f \\<Longrightarrow> \\<forall>x \\<in> X. x \\<in> range f \\<Longrightarrow> \\<Sqinter>X \\<in> range f\"", "lemma coclop_dual: \"(coclop::('a::order_with_dual \\<Rightarrow> 'a) \\<Rightarrow> bool) = clop \\<circ> \\<partial>\\<^sub>F\"", "lemma coclop_dual_var: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f = clop (\\<partial>\\<^sub>F f)\"", "lemma clop_dual: \"(clop::('a::order_with_dual \\<Rightarrow> 'a) \\<Rightarrow> bool) = coclop \\<circ> \\<partial>\\<^sub>F\"", "lemma clop_dual_var: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'a\"\n  shows \"clop f = coclop (\\<partial>\\<^sub>F f)\"", "lemma coclop_coextensive: \"coclop f \\<Longrightarrow> f \\<le> id\"", "lemma coclop_coextensive_var: \"coclop f \\<Longrightarrow> f x \\<le> x\"", "lemma coclop_iso: \"coclop f \\<Longrightarrow> mono f\"", "lemma coclop_iso_var: \"coclop f \\<Longrightarrow> (x \\<le> y \\<longrightarrow> f x \\<le> f y)\"", "lemma coclop_idem: \"coclop f \\<Longrightarrow> f \\<circ> f = f\"", "lemma coclop_closure: \"coclop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)\"", "lemma coclop_Fix_range: \"coclop f \\<Longrightarrow> (Fix f = range f)\"", "lemma coclop_idem_var: \"coclop f \\<Longrightarrow> f (f x) = f x\"", "lemma coclop_Sup_closed_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f \\<Longrightarrow> f \\<circ> Sup \\<circ> (`) f  = Sup \\<circ> (`) f\"", "lemma Sup_closed_coclop_var: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"coclop f \\<Longrightarrow> \\<forall>x \\<in> X. x \\<in> range f \\<Longrightarrow> \\<Squnion>X \\<in> range f\"", "lemma coclop_bot: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f \\<Longrightarrow> f \\<bottom> = \\<bottom>\"", "lemma \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (\\<Sqinter>x \\<in> X. f x) = (\\<Sqinter>x \\<in> X. f x)\"", "lemma \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y\"", "lemma  \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f \\<top> = \\<top>\"", "lemma \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (\\<Sqinter>x \\<in> X. f x) = (\\<Sqinter>x \\<in> X. f x)\"", "lemma \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y\"", "lemma  \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f \\<top> = \\<top>\"", "lemma coclop_coclosure: \"coclop f \\<Longrightarrow> f x = x \\<longleftrightarrow> x \\<in> range f\"", "lemma coclop_coclosure_set: \"coclop f \\<Longrightarrow> range f = Fix f\"", "lemma coclop_coclosure_prop: \"(coclop::('a::complete_lattice \\<Rightarrow> 'a) \\<Rightarrow> bool) (Sup \\<circ> \\<down>)\"", "lemma coclop_coclosure_prop_var: \"coclop (\\<lambda>x::'a::complete_lattice. \\<Squnion>{y. y \\<le> x})\"", "lemma coclop_alt: \"(coclop f) = (\\<forall>x y. f x \\<le> y \\<longleftrightarrow> f x \\<le> f y)\"", "lemma coclop_adj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> coclop (f \\<circ> g)\"", "lemma coclop_Sup_closed: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"coclop f \\<Longrightarrow> Sup_closed_set (Fix f)\"", "lemma Sup_closed_coclop: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"Sup_closed_set X \\<Longrightarrow> coclop (\\<lambda>y. \\<Squnion>{x \\<in> X. x \\<le> y})\"", "lemma clop_cl_op: \"clop cl_op\"", "lemma clop_idem [simp]: \"cl_op \\<circ> cl_op = cl_op\"", "lemma clop_idem_var [simp]: \"cl_op (cl_op x) = cl_op x\"", "lemma clop_range_Fix: \"range cl_op = Fix cl_op\"", "lemma Inf_closed_cl_op_var: \n  fixes X :: \"'a set\"\n  shows \"\\<forall>x \\<in> X. x \\<in> range cl_op \\<Longrightarrow> \\<Sqinter>X \\<in> range cl_op\"", "lemma inf_closed_cl_op_var: \"x \\<in> range cl_op \\<Longrightarrow> y \\<in> range cl_op \\<Longrightarrow> x \\<sqinter> y \\<in> range cl_op\"", "lemma cl_op_prop [iff]: \"(cl_op (x \\<squnion> y) = cl_op y) = (cl_op (x::'a::clattice_with_clop) \\<le> cl_op y)\"", "lemma cl_op_prop_var [iff]: \"(cl_op (x \\<squnion> cl_op y) = cl_op y) = (cl_op (x::'a::clattice_with_clop) \\<le> cl_op y)\"", "lemma surj_Sup_pres_id:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"f \\<circ> (radj f) = id\"", "lemma surj_Sup_pres_inj:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"inj (radj f)\"", "lemma surj_Sup_pres_inj_on: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"inj_on f (range (radj f \\<circ> f))\"", "lemma surj_Sup_pres_bij_on: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"bij_betw f (range (radj f \\<circ> f)) UNIV\"", "lemma surj_Sup_pres_iso: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"f ((radj f \\<circ> f) (\\<Squnion>X)) = (\\<Squnion>x \\<in> X. f x)\"", "lemma up_set_prop: \"(X::'a::preorder set) \\<noteq> {} \\<Longrightarrow> ub_set X = \\<Inter>{\\<up>x |x. x \\<in> X}\"", "lemma lb_set_prop: \"(X::'a::preorder set) \\<noteq> {} \\<Longrightarrow> lb_set X = \\<Inter>{\\<down>x |x. x \\<in> X}\"", "lemma dm_downset_var: \"dm {x} = \\<down>(x::'a::preorder)\"", "lemma dm_downset: \"dm \\<circ> \\<eta> = (\\<down>::'a::preorder \\<Rightarrow> 'a set)\"", "lemma dm_inj: \"inj ((dm::'a::order set \\<Rightarrow> 'a set) \\<circ> \\<eta>)\"", "lemma \"clop (lb_set \\<circ> ub_set)\""], "translations": [["", "lemma clop_extensive: \"clop f \\<Longrightarrow> id \\<le> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> id \\<le> f", "by (simp add: clop_def)"], ["", "lemma clop_extensive_var: \"clop f \\<Longrightarrow> x \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> x \\<le> f x", "by (simp add: clop_def le_fun_def)"], ["", "lemma clop_iso: \"clop f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> mono f", "by (simp add: clop_def)"], ["", "lemma clop_iso_var: \"clop f \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>clop f; x \\<le> y\\<rbrakk> \\<Longrightarrow> f x \\<le> f y", "by (simp add: clop_def mono_def)"], ["", "lemma clop_idem: \"clop f \\<Longrightarrow> f \\<circ> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f \\<circ> f = f", "by (simp add: antisym clop_def le_fun_def)"], ["", "lemma clop_Fix_range: \"clop f \\<Longrightarrow> (Fix f = range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> Fix f = range f", "by (simp add: clop_idem retraction_prop_fix)"], ["", "lemma clop_idem_var: \"clop f \\<Longrightarrow> f (f x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (f x) = f x", "by (simp add: clop_idem retraction_prop)"], ["", "lemma clop_Inf_closed_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\" \n  shows \"clop f \\<Longrightarrow> f \\<circ> Inf \\<circ> (`) f  = Inf \\<circ> (`) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f \\<circ> Inf \\<circ> (`) f = Inf \\<circ> (`) f", "unfolding clop_def mono_def comp_def le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. id x \\<le> f x) \\<and>\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n    (\\<forall>x. f (f x) \\<le> f x) \\<Longrightarrow>\n    (\\<lambda>x. f (\\<Sqinter> (f ` x))) = (\\<lambda>x. \\<Sqinter> (f ` x))", "by (metis (mono_tags, lifting) antisym id_apply le_INF_iff order_refl)"], ["", "lemma clop_top:\n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"clop f \\<Longrightarrow> f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> top_pres f", "by (simp add: clop_extensive_var top.extremum_uniqueI)"], ["", "lemma \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (\\<Squnion>x \\<in> X. f x) = (\\<Squnion>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (\\<Squnion> (f ` X)) = \\<Squnion> (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (\\<Squnion> (f ` X)) = \\<Squnion> (f ` X)", "oops"], ["", "lemma \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y", "oops"], ["", "lemma  \"clop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> bot_pres f", "(*nitpick *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> bot_pres f", "oops"], ["", "lemma \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (\\<Squnion>x \\<in> X. f x) = (\\<Squnion>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (\\<Union> (f ` X)) = \\<Union> (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (\\<Union> (f ` X)) = \\<Union> (f ` X)", "oops"], ["", "lemma \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (f x \\<squnion> f y) = f x \\<squnion> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (f x \\<union> f y) = f x \\<union> f y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> f (f x \\<union> f y) = f x \\<union> f y", "oops"], ["", "lemma  \"clop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> bot_pres f", "(*nitpick *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> bot_pres f", "oops"], ["", "lemma clop_closure: \"clop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)", "by (simp add: clop_idem retraction_prop)"], ["", "lemma clop_closure_set: \"clop f \\<Longrightarrow> range f = Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> range f = Fix f", "by (simp add: clop_Fix_range)"], ["", "lemma clop_closure_prop: \"(clop::('a::complete_lattice_with_dual\\<Rightarrow> 'a) \\<Rightarrow> bool) (Inf \\<circ> \\<up>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop (Inf \\<circ> \\<up>)", "by (simp add: clop_def mono_def)"], ["", "lemma clop_closure_prop_var: \"clop (\\<lambda>x::'a::complete_lattice. \\<Sqinter>{y. x \\<le> y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop (\\<lambda>x. \\<Sqinter> {y. x \\<le> y})", "unfolding clop_def comp_def le_fun_def mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. id x \\<le> \\<Sqinter> Collect ((\\<le>) x)) \\<and>\n    (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        \\<Sqinter> Collect ((\\<le>) x)\n        \\<le> \\<Sqinter> Collect ((\\<le>) y)) \\<and>\n    (\\<forall>x.\n        \\<Sqinter> Collect ((\\<le>) (\\<Sqinter> Collect ((\\<le>) x)))\n        \\<le> \\<Sqinter> Collect ((\\<le>) x))", "by (simp add: Inf_lower le_Inf_iff)"], ["", "lemma clop_alt: \"(clop f) = (\\<forall>x y. x \\<le> f y \\<longleftrightarrow> f x \\<le> f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f = (\\<forall>x y. (x \\<le> f y) = (f x \\<le> f y))", "unfolding clop_def mono_def le_fun_def comp_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. x \\<le> f x) \\<and>\n     (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n     (\\<forall>x. f (f x) \\<le> f x)) =\n    (\\<forall>x y. (x \\<le> f y) = (f x \\<le> f y))", "by (meson dual_order.refl order_trans)"], ["", "text \\<open>Finally it is shown that adjoints in a Galois connection yield closure operators.\\<close>"], ["", "lemma clop_adj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> clop (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> clop (g \\<circ> f)", "by (simp add: adj_cancel2 adj_idem2 adj_iso4 clop_def)"], ["", "text \\<open>Closure operators are monads for posets, and monads arise from adjunctions. \nThis fact is not formalised at this point. But here is the first step: every function \ncan be decomposed into a surjection followed by an injection.\\<close>"], ["", "definition \"surj_on f Y = (\\<forall>y \\<in> Y. \\<exists>x. y = f x)\""], ["", "lemma surj_surj_on: \"surj f \\<Longrightarrow> surj_on f Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres ((`) f) \\<Longrightarrow> surj_on f Y", "by (simp add: surjD surj_on_def)"], ["", "lemma fun_surj_inj: \"\\<exists>g h. f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)", "obtain h where a: \"\\<forall>x. f x = h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<forall>x. f x = h x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. f x = h x\n\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. f x = h x", "have \"surj_on h (range f)\""], ["proof (prove)\nusing this:\n  \\<forall>x. f x = h x\n\ngoal (1 subgoal):\n 1. surj_on h (range f)", "by (metis (mono_tags, lifting) imageE surj_on_def)"], ["proof (state)\nthis:\n  surj_on h (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)", "then"], ["proof (chain)\npicking this:\n  surj_on h (range f)", "show ?thesis"], ["proof (prove)\nusing this:\n  surj_on h (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)", "unfolding inj_on_def surj_on_def fun_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>range f. \\<exists>x. y = h x\n\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       (\\<forall>x. f x = (g \\<circ> h) x) \\<and>\n       (\\<forall>y\\<in>range f. \\<exists>x. y = h x) \\<and>\n       (\\<forall>x\\<in>range f.\n           \\<forall>y\\<in>range f. g x = g y \\<longrightarrow> x = y)", "using a"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>range f. \\<exists>x. y = h x\n  \\<forall>x. f x = h x\n\ngoal (1 subgoal):\n 1. \\<exists>g h.\n       (\\<forall>x. f x = (g \\<circ> h) x) \\<and>\n       (\\<forall>y\\<in>range f. \\<exists>x. y = h x) \\<and>\n       (\\<forall>x\\<in>range f.\n           \\<forall>y\\<in>range f. g x = g y \\<longrightarrow> x = y)", "by auto"], ["proof (state)\nthis:\n  \\<exists>g h.\n     f = g \\<circ> h \\<and> surj_on h (range f) \\<and> inj_on g (range f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Connections between downsets, upsets and closure operators are outlined next.\\<close>"], ["", "lemma preorder_clop: \"clop (\\<Down>::'a::preorder set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop \\<Down>", "by (simp add: clop_def downset_set_ext downset_set_iso)"], ["", "lemma clop_preorder_aux: \"clop f \\<Longrightarrow> (x \\<in> f {y} \\<longleftrightarrow> f {x} \\<subseteq> f {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow>\n    (x \\<in> f (\\<eta> y)) = (f (\\<eta> x) \\<subseteq> f (\\<eta> y))", "by (simp add: clop_alt)"], ["", "lemma clop_preorder: \"clop f \\<Longrightarrow> class.preorder (\\<lambda>x y. f {x} \\<subseteq> f {y}) (\\<lambda>x y. f {x} \\<subset> f {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow>\n    class.preorder (\\<lambda>x y. f (\\<eta> x) \\<subseteq> f (\\<eta> y))\n     (\\<lambda>x y. f (\\<eta> x) \\<subset> f (\\<eta> y))", "unfolding clop_def mono_def le_fun_def id_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<subseteq> f x) \\<and>\n    (\\<forall>x y.\n        x \\<subseteq> y \\<longrightarrow> f x \\<subseteq> f y) \\<and>\n    (\\<forall>x. f (f x) \\<subseteq> f x) \\<Longrightarrow>\n    class.preorder (\\<lambda>x y. f (\\<eta> x) \\<subseteq> f (\\<eta> y))\n     (\\<lambda>x y. f (\\<eta> x) \\<subset> f (\\<eta> y))", "by standard (auto simp: subset_not_subset_eq)"], ["", "lemma preorder_clop_dual: \"clop (\\<Up>::'a::preorder_with_dual set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop \\<Up>", "by (simp add: clop_def upset_set_anti upset_set_ext)"], ["", "text \\<open>The closed elements of any closure operator over a complete lattice form an Inf-closed set (a Moore family).\\<close>"], ["", "lemma clop_Inf_closed: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"clop f \\<Longrightarrow> Inf_closed_set (Fix f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> Inf_closed_set (Fix f)", "unfolding clop_def Inf_closed_set_def mono_def le_fun_def comp_def id_def Fix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<le> f x) \\<and>\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n    (\\<forall>x. f (f x) \\<le> f x) \\<Longrightarrow>\n    \\<forall>Y\\<subseteq>{x. f x = x}. \\<Sqinter> Y \\<in> {x. f x = x}", "by (smt Inf_greatest Inf_lower antisym mem_Collect_eq subsetCE)"], ["", "lemma clop_top_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"clop f \\<Longrightarrow> \\<top> \\<in> Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f \\<Longrightarrow> \\<top> \\<in> Fix f", "by (simp add: clop_Fix_range clop_closure clop_top)"], ["", "text \\<open>Conversely, every Inf-closed subset of a complete lattice is the set of fixpoints of some closure operator.\\<close>"], ["", "lemma Inf_closed_clop: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"Inf_closed_set X \\<Longrightarrow> clop (\\<lambda>y. \\<Sqinter>{x \\<in> X. y \\<le> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_closed_set X \\<Longrightarrow>\n    clop (\\<lambda>y. \\<Sqinter> {x \\<in> X. y \\<le> x})", "by (smt Collect_mono_iff Inf_superset_mono clop_alt dual_order.trans le_Inf_iff mem_Collect_eq)"], ["", "lemma Inf_closed_clop_var: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"clop f \\<Longrightarrow> \\<forall>x \\<in> X. x \\<in> range f \\<Longrightarrow> \\<Sqinter>X \\<in> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>clop f; \\<forall>x\\<in>X. x \\<in> range f\\<rbrakk>\n    \\<Longrightarrow> \\<Sqinter> X \\<in> range f", "by (metis Inf_closed_set_def clop_Fix_range clop_Inf_closed subsetI)"], ["", "text \\<open>It is well known that downsets and upsets over an ordering form subalgebras of the complete powerset lattice.\\<close>"], ["", "typedef (overloaded) 'a downsets = \"range (\\<Down>::'a::order set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range \\<Down>", "by fastforce"], ["", "setup_lifting type_definition_downsets"], ["", "typedef (overloaded) 'a upsets = \"range (\\<Up>::'a::order set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range \\<Up>", "by fastforce"], ["", "setup_lifting type_definition_upsets"], ["", "instantiation downsets :: (order) Inf_lattice\nbegin"], ["", "lift_definition Inf_downsets :: \"'a downsets set \\<Rightarrow> 'a downsets\" is \"Abs_downsets \\<circ> Inf \\<circ> (`) Rep_downsets\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_downsets :: \"'a downsets \\<Rightarrow> 'a downsets \\<Rightarrow> bool\" is \"\\<lambda>X Y. Rep_downsets X \\<subseteq> Rep_downsets Y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_downsets :: \"'a downsets \\<Rightarrow> 'a downsets \\<Rightarrow> bool\" is \"\\<lambda>X Y. Rep_downsets X \\<subset> Rep_downsets Y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a downsets, Inf_lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 5. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 4. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 3. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (simp add: Closure_Operators.less_eq_downsets.abs_eq Rep_downsets_inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 2. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, smt Abs_downsets_inverse INF_lower Inf_closed_clop_var Rep_downsets image_iff o_def preorder_clop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "by transfer (smt comp_def Abs_downsets_inverse Inf_closed_clop_var Rep_downsets image_iff le_INF_iff preorder_clop)"], ["", "end"], ["", "instantiation upsets :: (order_with_dual) Inf_lattice\nbegin"], ["", "lift_definition Inf_upsets :: \"'a upsets set \\<Rightarrow> 'a upsets\" is \"Abs_upsets \\<circ> Inf \\<circ> (`) Rep_upsets\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_upsets :: \"'a upsets \\<Rightarrow> 'a upsets \\<Rightarrow> bool\" is \"\\<lambda>X Y. Rep_upsets X \\<subseteq> Rep_upsets Y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_upsets :: \"'a upsets \\<Rightarrow> 'a upsets \\<Rightarrow> bool\" is \"\\<lambda>X Y. Rep_upsets X \\<subset> Rep_upsets Y\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a upsets, Inf_lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 5. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 4. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 3. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (simp add: Closure_Operators.less_eq_upsets.abs_eq Rep_upsets_inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X. x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n 2. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "apply (transfer, smt Abs_upsets_inverse Inf_closed_clop_var Inf_lower Rep_upsets comp_apply image_iff preorder_clop_dual)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X z.\n       (\\<And>x. x \\<in> X \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> X", "by transfer (smt comp_def Abs_upsets_inverse Inf_closed_clop_var Inter_iff Rep_upsets image_iff preorder_clop_dual subsetCE subsetI)"], ["", "end"], ["", "text \\<open>It has already been shown in the section on representations that the map ds, which maps elements of the order to its downset, is an order \nembedding. However, the duality between the underlying ordering and the lattices of up- and down-closed sets as categories can probably not be expressed, \nas there is no easy access to contravariant functors. \\<close>"], ["", "subsection \\<open>Co-Closure Operators\\<close>"], ["", "text \\<open>Next, the co-closure (or kernel) operation satisfies dual laws.\\<close>"], ["", "definition coclop :: \"('a::order \\<Rightarrow> 'a::order) \\<Rightarrow> bool\" where\n  \"coclop f = (f \\<le> id \\<and> mono f \\<and> f \\<le> f \\<circ> f)\""], ["", "lemma coclop_dual: \"(coclop::('a::order_with_dual \\<Rightarrow> 'a) \\<Rightarrow> bool) = clop \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop = clop \\<circ> \\<partial>\\<^sub>F", "unfolding coclop_def clop_def id_def mono_def map_dual_def comp_def fun_eq_iff le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((\\<forall>xa. x xa \\<le> xa) \\<and>\n        (\\<forall>xa y. xa \\<le> y \\<longrightarrow> x xa \\<le> x y) \\<and>\n        (\\<forall>xa. x xa \\<le> x (x xa))) =\n       ((\\<forall>xa. xa \\<le> \\<partial> (x (\\<partial> xa))) \\<and>\n        (\\<forall>xa y.\n            xa \\<le> y \\<longrightarrow>\n            \\<partial> (x (\\<partial> xa))\n            \\<le> \\<partial> (x (\\<partial> y))) \\<and>\n        (\\<forall>xa.\n            \\<partial> (x (\\<partial> (\\<partial> (x (\\<partial> xa)))))\n            \\<le> \\<partial> (x (\\<partial> xa))))", "by (metis invol_dual_var ord_dual)"], ["", "lemma coclop_dual_var: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f = clop (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f = clop (\\<partial>\\<^sub>F f)", "by (simp add: coclop_dual)"], ["", "lemma clop_dual: \"(clop::('a::order_with_dual \\<Rightarrow> 'a) \\<Rightarrow> bool) = coclop \\<circ> \\<partial>\\<^sub>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop = coclop \\<circ> \\<partial>\\<^sub>F", "by (simp add: coclop_dual comp_assoc map_dual_invol)"], ["", "lemma clop_dual_var: \n  fixes f :: \"'a::order_with_dual \\<Rightarrow> 'a\"\n  shows \"clop f = coclop (\\<partial>\\<^sub>F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop f = coclop (\\<partial>\\<^sub>F f)", "by (simp add: clop_dual)"], ["", "lemma coclop_coextensive: \"coclop f \\<Longrightarrow> f \\<le> id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f \\<le> id", "by (simp add: coclop_def)"], ["", "lemma coclop_coextensive_var: \"coclop f \\<Longrightarrow> f x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f x \\<le> x", "using coclop_def le_funD"], ["proof (prove)\nusing this:\n  coclop ?f = (?f \\<le> id \\<and> mono ?f \\<and> ?f \\<le> ?f \\<circ> ?f)\n  ?f \\<le> ?g \\<Longrightarrow> ?f ?x \\<le> ?g ?x\n\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f x \\<le> x", "by fastforce"], ["", "lemma coclop_iso: \"coclop f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> mono f", "by (simp add: coclop_def)"], ["", "lemma coclop_iso_var: \"coclop f \\<Longrightarrow> (x \\<le> y \\<longrightarrow> f x \\<le> f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (simp add: coclop_iso monoD)"], ["", "lemma coclop_idem: \"coclop f \\<Longrightarrow> f \\<circ> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f \\<circ> f = f", "by (simp add: antisym coclop_def le_fun_def)"], ["", "lemma coclop_closure: \"coclop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> (x \\<in> range f) = (f x = x)", "by (simp add: coclop_idem retraction_prop)"], ["", "lemma coclop_Fix_range: \"coclop f \\<Longrightarrow> (Fix f = range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> Fix f = range f", "by (simp add: coclop_idem retraction_prop_fix)"], ["", "lemma coclop_idem_var: \"coclop f \\<Longrightarrow> f (f x) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (f x) = f x", "by (simp add: coclop_idem retraction_prop)"], ["", "lemma coclop_Sup_closed_var: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f \\<Longrightarrow> f \\<circ> Sup \\<circ> (`) f  = Sup \\<circ> (`) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow>\n    f \\<circ> Sup \\<circ> (`) f = Sup \\<circ> (`) f", "unfolding coclop_def mono_def comp_def le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. f x \\<le> id x) \\<and>\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n    (\\<forall>x. f x \\<le> f (f x)) \\<Longrightarrow>\n    (\\<lambda>x. f (\\<Squnion> (f ` x))) = (\\<lambda>x. \\<Squnion> (f ` x))", "by (metis (mono_tags, lifting) SUP_le_iff antisym id_apply order_refl)"], ["", "lemma Sup_closed_coclop_var: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"coclop f \\<Longrightarrow> \\<forall>x \\<in> X. x \\<in> range f \\<Longrightarrow> \\<Squnion>X \\<in> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coclop f; \\<forall>x\\<in>X. x \\<in> range f\\<rbrakk>\n    \\<Longrightarrow> \\<Squnion> X \\<in> range f", "by (smt Inf.INF_id_eq Sup.SUP_cong antisym coclop_closure coclop_coextensive_var coclop_iso id_apply mono_SUP)"], ["", "lemma coclop_bot: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'a\"\n  shows \"coclop f \\<Longrightarrow> f \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> bot_pres f", "by (simp add: bot.extremum_uniqueI coclop_coextensive_var)"], ["", "lemma \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (\\<Sqinter>x \\<in> X. f x) = (\\<Sqinter>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (\\<Sqinter> (f ` X)) = \\<Sqinter> (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (\\<Sqinter> (f ` X)) = \\<Sqinter> (f ` X)", "oops"], ["", "lemma \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y", "oops"], ["", "lemma  \"coclop (f::'a::complete_lattice \\<Rightarrow> 'a) \\<Longrightarrow> f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> top_pres f", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> top_pres f", "oops"], ["", "lemma \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (\\<Sqinter>x \\<in> X. f x) = (\\<Sqinter>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (\\<Inter> (f ` X)) = \\<Inter> (f ` X)", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (\\<Inter> (f ` X)) = \\<Inter> (f ` X)", "oops"], ["", "lemma \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f (f x \\<sqinter> f y) = f x \\<sqinter> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (f x \\<inter> f y) = f x \\<inter> f y", "(*nitpick*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> f (f x \\<inter> f y) = f x \\<inter> f y", "oops"], ["", "lemma  \"coclop (f::'a set \\<Rightarrow> 'a set) \\<Longrightarrow> f \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> top_pres f", "(*nitpick *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> top_pres f", "oops"], ["", "lemma coclop_coclosure: \"coclop f \\<Longrightarrow> f x = x \\<longleftrightarrow> x \\<in> range f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> (f x = x) = (x \\<in> range f)", "by (simp add: coclop_idem retraction_prop)"], ["", "lemma coclop_coclosure_set: \"coclop f \\<Longrightarrow> range f = Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> range f = Fix f", "by (simp add: coclop_idem retraction_prop_fix)"], ["", "lemma coclop_coclosure_prop: \"(coclop::('a::complete_lattice \\<Rightarrow> 'a) \\<Rightarrow> bool) (Sup \\<circ> \\<down>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop (Sup \\<circ> \\<down>)", "by (simp add: coclop_def mono_def)"], ["", "lemma coclop_coclosure_prop_var: \"coclop (\\<lambda>x::'a::complete_lattice. \\<Squnion>{y. y \\<le> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop (\\<lambda>x. \\<Squnion> {y. y \\<le> x})", "by (metis (mono_tags, lifting) Sup_atMost atMost_def coclop_def comp_apply eq_id_iff eq_refl mono_def)"], ["", "lemma coclop_alt: \"(coclop f) = (\\<forall>x y. f x \\<le> y \\<longleftrightarrow> f x \\<le> f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f = (\\<forall>x y. (f x \\<le> y) = (f x \\<le> f y))", "unfolding coclop_def mono_def le_fun_def comp_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. f x \\<le> x) \\<and>\n     (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n     (\\<forall>x. f x \\<le> f (f x))) =\n    (\\<forall>x y. (f x \\<le> y) = (f x \\<le> f y))", "by (meson dual_order.refl order_trans)"], ["", "lemma coclop_adj: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::order\"\n  shows \"f \\<stileturn> g \\<Longrightarrow> coclop (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> g \\<Longrightarrow> coclop (f \\<circ> g)", "by (simp add: adj_cancel1 adj_idem1 adj_iso3 coclop_def)"], ["", "text \\<open>Finally, a subset of a complete lattice is Sup-closed if and only if it is the set of fixpoints\nof some co-closure operator.\\<close>"], ["", "lemma coclop_Sup_closed: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows  \"coclop f \\<Longrightarrow> Sup_closed_set (Fix f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coclop f \\<Longrightarrow> Sup_closed_set (Fix f)", "unfolding coclop_def Sup_closed_set_def mono_def le_fun_def comp_def id_def Fix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. f x \\<le> x) \\<and>\n    (\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y) \\<and>\n    (\\<forall>x. f x \\<le> f (f x)) \\<Longrightarrow>\n    \\<forall>Y\\<subseteq>{x. f x = x}. \\<Squnion> Y \\<in> {x. f x = x}", "by (smt Sup_least Sup_upper antisym_conv mem_Collect_eq subsetCE)"], ["", "lemma Sup_closed_coclop: \n  fixes X :: \"'a::complete_lattice set\"\n  shows \"Sup_closed_set X \\<Longrightarrow> coclop (\\<lambda>y. \\<Squnion>{x \\<in> X. x \\<le> y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_closed_set X \\<Longrightarrow>\n    coclop (\\<lambda>y. \\<Squnion> {x \\<in> X. x \\<le> y})", "unfolding Sup_closed_set_def coclop_def mono_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X \\<Longrightarrow>\n    (\\<forall>x. \\<Squnion> {xa \\<in> X. xa \\<le> x} \\<le> id x) \\<and>\n    (\\<forall>x y.\n        x \\<le> y \\<longrightarrow>\n        \\<Squnion> {xa \\<in> X. xa \\<le> x}\n        \\<le> \\<Squnion> {x \\<in> X. x \\<le> y}) \\<and>\n    (\\<forall>x.\n        \\<Squnion> {xa \\<in> X. xa \\<le> x}\n        \\<le> \\<Squnion> {xa \\<in> X.\n                          xa \\<le> \\<Squnion> {xa \\<in> X. xa \\<le> x}})", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X \\<Longrightarrow>\n       \\<Squnion> {xa \\<in> X. xa \\<le> x} \\<le> id x\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X;\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {xa \\<in> X. xa \\<le> x}\n                         \\<le> \\<Squnion> {x \\<in> X. x \\<le> y}\n 3. \\<And>x.\n       \\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X \\<Longrightarrow>\n       \\<Squnion> {xa \\<in> X. xa \\<le> x}\n       \\<le> \\<Squnion> {xa \\<in> X.\n                         xa \\<le> \\<Squnion> {xa \\<in> X. xa \\<le> x}}", "apply (metis (no_types, lifting) Sup_least eq_id_iff mem_Collect_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X;\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {xa \\<in> X. xa \\<le> x}\n                         \\<le> \\<Squnion> {x \\<in> X. x \\<le> y}\n 2. \\<And>x.\n       \\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X \\<Longrightarrow>\n       \\<Squnion> {xa \\<in> X. xa \\<le> x}\n       \\<le> \\<Squnion> {xa \\<in> X.\n                         xa \\<le> \\<Squnion> {xa \\<in> X. xa \\<le> x}}", "apply (smt Collect_mono_iff Sup_subset_mono dual_order.trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>Y\\<subseteq>X. \\<Squnion> Y \\<in> X \\<Longrightarrow>\n       \\<Squnion> {xa \\<in> X. xa \\<le> x}\n       \\<le> \\<Squnion> {xa \\<in> X.\n                         xa \\<le> \\<Squnion> {xa \\<in> X. xa \\<le> x}}", "by (simp add: Collect_mono_iff Sup_subset_mono Sup_upper)"], ["", "subsection \\<open>Complete Lattices of Closed Elements\\<close>"], ["", "text \\<open>The machinery developed allows showing that the closed elements in a complete\nlattice (with respect to some closure operation) form themselves a complete lattice.\\<close>"], ["", "class cl_op = ord +\n  fixes cl_op :: \"'a \\<Rightarrow> 'a\"\n  assumes clop_ext: \"x \\<le> cl_op x\"\n  and clop_iso: \"x \\<le> y \\<Longrightarrow> cl_op x \\<le> cl_op y\"\n  and clop_wtrans: \"cl_op (cl_op x) \\<le> cl_op x\""], ["", "class clattice_with_clop = complete_lattice + cl_op\n\nbegin"], ["", "lemma clop_cl_op: \"clop cl_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop cl_op", "unfolding clop_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. id x \\<le> cl_op x) \\<and>\n    mono cl_op \\<and> (\\<forall>x. cl_op (cl_op x) \\<le> cl_op x)", "by (simp add: cl_op_class.clop_ext cl_op_class.clop_iso cl_op_class.clop_wtrans order_class.mono_def)"], ["", "lemma clop_idem [simp]: \"cl_op \\<circ> cl_op = cl_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_op \\<circ> cl_op = cl_op", "using clop_ext clop_wtrans order.antisym"], ["proof (prove)\nusing this:\n  ?x \\<le> cl_op ?x\n  cl_op (cl_op ?x) \\<le> cl_op ?x\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. cl_op \\<circ> cl_op = cl_op", "by auto"], ["", "lemma clop_idem_var [simp]: \"cl_op (cl_op x) = cl_op x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_op (cl_op x) = cl_op x", "by (simp add: antisym clop_ext clop_wtrans)"], ["", "lemma clop_range_Fix: \"range cl_op = Fix cl_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range cl_op = Fix cl_op", "by (simp add: retraction_prop_fix)"], ["", "lemma Inf_closed_cl_op_var: \n  fixes X :: \"'a set\"\n  shows \"\\<forall>x \\<in> X. x \\<in> range cl_op \\<Longrightarrow> \\<Sqinter>X \\<in> range cl_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<in> range cl_op \\<Longrightarrow>\n    \\<Sqinter> X \\<in> range cl_op", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<in> range cl_op \\<Longrightarrow>\n    \\<Sqinter> X \\<in> range cl_op", "assume h: \"\\<forall>x \\<in> X. x \\<in> range cl_op\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. x \\<in> range cl_op\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<in> range cl_op \\<Longrightarrow>\n    \\<Sqinter> X \\<in> range cl_op", "hence \"\\<forall>x \\<in> X. cl_op x = x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. x \\<in> range cl_op\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. cl_op x = x", "by (simp add: retraction_prop)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. cl_op x = x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<in> range cl_op \\<Longrightarrow>\n    \\<Sqinter> X \\<in> range cl_op", "hence \"cl_op (\\<Sqinter>X) = \\<Sqinter>X\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. cl_op x = x\n\ngoal (1 subgoal):\n 1. cl_op (\\<Sqinter> X) = \\<Sqinter> X", "by (metis Inf_lower clop_ext clop_iso dual_order.antisym le_Inf_iff)"], ["proof (state)\nthis:\n  cl_op (\\<Sqinter> X) = \\<Sqinter> X\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. x \\<in> range cl_op \\<Longrightarrow>\n    \\<Sqinter> X \\<in> range cl_op", "thus ?thesis"], ["proof (prove)\nusing this:\n  cl_op (\\<Sqinter> X) = \\<Sqinter> X\n\ngoal (1 subgoal):\n 1. \\<Sqinter> X \\<in> range cl_op", "by (metis rangeI)"], ["proof (state)\nthis:\n  \\<Sqinter> X \\<in> range cl_op\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_closed_cl_op_var: \"x \\<in> range cl_op \\<Longrightarrow> y \\<in> range cl_op \\<Longrightarrow> x \\<sqinter> y \\<in> range cl_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n    \\<Longrightarrow> x \\<sqinter> y \\<in> range cl_op", "by (smt Inf_closed_cl_op_var UnI1 insert_iff insert_is_Un inf_Inf)"], ["", "end"], ["", "typedef (overloaded) 'a::clattice_with_clop cl_op_im = \"range (cl_op::'a \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> range cl_op", "by force"], ["", "setup_lifting type_definition_cl_op_im"], ["", "lemma cl_op_prop [iff]: \"(cl_op (x \\<squnion> y) = cl_op y) = (cl_op (x::'a::clattice_with_clop) \\<le> cl_op y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cl_op (x \\<squnion> y) = cl_op y) = (cl_op x \\<le> cl_op y)", "by (smt cl_op_class.clop_iso clop_ext clop_wtrans inf_sup_ord(4) le_iff_sup sup.absorb_iff1 sup_left_commute)"], ["", "lemma cl_op_prop_var [iff]: \"(cl_op (x \\<squnion> cl_op y) = cl_op y) = (cl_op (x::'a::clattice_with_clop) \\<le> cl_op y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cl_op (x \\<squnion> cl_op y) = cl_op y) = (cl_op x \\<le> cl_op y)", "by (metis cl_op_prop clattice_with_clop_class.clop_idem_var)"], ["", "instantiation cl_op_im :: (clattice_with_clop) complete_lattice\nbegin"], ["", "lift_definition Inf_cl_op_im :: \"'a cl_op_im set \\<Rightarrow> 'a cl_op_im\" is Inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> range cl_op) \\<Longrightarrow>\n       \\<Sqinter> set \\<in> range cl_op", "by (simp add: Inf_closed_cl_op_var)"], ["", "lift_definition Sup_cl_op_im :: \"'a cl_op_im set \\<Rightarrow> 'a cl_op_im\" is \"\\<lambda>X. cl_op (\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           x \\<in> range cl_op) \\<Longrightarrow>\n       cl_op (\\<Squnion> set) \\<in> range cl_op", "by simp"], ["", "lift_definition inf_cl_op_im :: \"'a cl_op_im \\<Rightarrow> 'a cl_op_im \\<Rightarrow> 'a cl_op_im\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> range cl_op; a2 \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> a1 \\<sqinter> a2 \\<in> range cl_op", "by (simp add: inf_closed_cl_op_var)"], ["", "lift_definition sup_cl_op_im :: \"'a cl_op_im \\<Rightarrow> 'a cl_op_im \\<Rightarrow> 'a cl_op_im\" is \"\\<lambda>x y. cl_op (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> range cl_op; a2 \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> cl_op (a1 \\<squnion> a2) \\<in> range cl_op", "by simp"], ["", "lift_definition less_eq_cl_op_im :: \"'a cl_op_im \\<Rightarrow> 'a cl_op_im \\<Rightarrow> bool\" is \"(\\<le>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_cl_op_im :: \"'a cl_op_im \\<Rightarrow> 'a cl_op_im \\<Rightarrow> bool\" is \"(<)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition bot_cl_op_im :: \"'a cl_op_im\" is \"cl_op \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_op \\<bottom> \\<in> range cl_op", "by simp"], ["", "lift_definition top_cl_op_im :: \"'a cl_op_im\" is \"\\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<in> range cl_op", "by (simp add: clop_cl_op clop_closure clop_top)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a cl_op_im, complete_lattice_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<in> range cl_op \\<Longrightarrow> x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op;\n        z \\<in> range cl_op; x \\<le> y; y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op; x \\<le> y;\n        y \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op;\n        z \\<in> range cl_op; x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (x \\<squnion> y)\n 9. \\<And>y x.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> y \\<le> cl_op (x \\<squnion> y)\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op;\n         z \\<in> range cl_op; y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> cl_op (y \\<squnion> z) \\<le> x\nA total of 16 subgoals...", "apply (simp_all add: less_le_not_le Inf_lower Inf_greatest)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> range cl_op; y \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (x \\<squnion> y)\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> y \\<le> cl_op (x \\<squnion> y)\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op;\n        z \\<in> range cl_op; y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> cl_op (y \\<squnion> z) \\<le> x\n 4. \\<And>x A.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (\\<Squnion> A)\n 5. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; z \\<in> range cl_op;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> cl_op (\\<Squnion> A) \\<le> z", "apply (meson clop_cl_op clop_extensive_var dual_order.trans inf_sup_ord(3))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op\\<rbrakk>\n       \\<Longrightarrow> y \\<le> cl_op (x \\<squnion> y)\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op;\n        z \\<in> range cl_op; y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> cl_op (y \\<squnion> z) \\<le> x\n 3. \\<And>x A.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (\\<Squnion> A)\n 4. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; z \\<in> range cl_op;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> cl_op (\\<Squnion> A) \\<le> z", "apply (meson clop_cl_op clop_extensive_var dual_order.trans sup_ge2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<in> range cl_op; x \\<in> range cl_op;\n        z \\<in> range cl_op; y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> cl_op (y \\<squnion> z) \\<le> x\n 2. \\<And>x A.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (\\<Squnion> A)\n 3. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; z \\<in> range cl_op;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> cl_op (\\<Squnion> A) \\<le> z", "apply (metis cl_op_class.clop_iso clop_cl_op clop_closure le_sup_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<le> cl_op (\\<Squnion> A)\n 2. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; z \\<in> range cl_op;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> cl_op (\\<Squnion> A) \\<le> z", "apply (meson Sup_upper clop_cl_op clop_extensive_var dual_order.trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>\\<forall>x\\<in>A. x \\<in> range cl_op; z \\<in> range cl_op;\n        \\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> cl_op (\\<Squnion> A) \\<le> z", "by (metis Sup_le_iff cl_op_class.clop_iso clop_cl_op clop_closure)"], ["", "end"], ["", "text \\<open>This statement is perhaps less useful as it might seem, because it is difficult to make it cooperate with concrete closure operators, \nwhich one would not generally like to define within a type class. Alternatively, a sublocale statement could perhaps be given. It would also \nhave been nice to prove this statement for Sup-lattices---this would have cut down the number of proof obligations significantly.\nBut this would require a tighter integration of these structures. A similar statement could have been proved for co-closure operators. But this would\nnot lead to new insights.\\<close>"], ["", "text \\<open>Next I show that for every surjective Sup-preserving function between complete lattices there is a closure operator \nsuch that the set of closed elements is isomorphic to the range of the surjection.\\<close>"], ["", "lemma surj_Sup_pres_id:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"f \\<circ> (radj f) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> radj f = id", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<circ> radj f = id", "have \"f \\<stileturn> (radj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<stileturn> radj f", "using Sup_pres_ladj assms(2) radj_adj"], ["proof (prove)\nusing this:\n  Sup_pres ?f \\<Longrightarrow> \\<exists>g. ?f \\<stileturn> g\n  Sup_pres f\n  ?f \\<stileturn> ?g \\<Longrightarrow> ?g = radj ?f\n\ngoal (1 subgoal):\n 1. f \\<stileturn> radj f", "by auto"], ["proof (state)\nthis:\n  f \\<stileturn> radj f\n\ngoal (1 subgoal):\n 1. f \\<circ> radj f = id", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<stileturn> radj f\n\ngoal (1 subgoal):\n 1. f \\<circ> radj f = id", "using adj_sur_inv assms(1)"], ["proof (prove)\nusing this:\n  f \\<stileturn> radj f\n  ?f \\<stileturn> ?g \\<Longrightarrow>\n  top_pres ((`) ?f) = (?f \\<circ> ?g = id)\n  top_pres ((`) f)\n\ngoal (1 subgoal):\n 1. f \\<circ> radj f = id", "by blast"], ["proof (state)\nthis:\n  f \\<circ> radj f = id\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_Sup_pres_inj:\n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"inj (radj f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (radj f)", "by (metis assms comp_eq_dest_lhs id_apply injI surj_Sup_pres_id)"], ["", "lemma surj_Sup_pres_inj_on: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"inj_on f (range (radj f \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (range (radj f \\<circ> f))", "by (smt Sup_pres_ladj_aux adj_idem2 assms(2) comp_apply inj_on_def retraction_prop)"], ["", "lemma surj_Sup_pres_bij_on: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"bij_betw f (range (radj f \\<circ> f)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f (range (radj f \\<circ> f)) UNIV", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (range (radj f \\<circ> f)) \\<and>\n    f ` range (radj f \\<circ> f) = UNIV", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on f (range (radj f \\<circ> f))\n 2. \\<And>x xa xb.\n       xb \\<in> UNIV \\<Longrightarrow> f ((radj f \\<circ> f) xb) \\<in> UNIV\n 3. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> x \\<in> f ` range (radj f \\<circ> f)", "apply (simp add: assms(1) assms(2) surj_Sup_pres_inj_on cong del: image_cong_simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa xb.\n       xb \\<in> UNIV \\<Longrightarrow> f ((radj f \\<circ> f) xb) \\<in> UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> x \\<in> f ` range (radj f \\<circ> f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` range (\\<lambda>x. radj f (f x))", "apply (metis (mono_tags) UNIV_I assms(1) assms(2) comp_apply id_apply image_image surj_Sup_pres_id surj_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Thus the restriction of $f$ to the set of closed elements is indeed a bijection. The final fact\nshows that it preserves Sups of closed elements, and hence is an isomorphism of complete lattices.\\<close>"], ["", "lemma surj_Sup_pres_iso: \n  fixes f :: \"'a::complete_lattice_with_dual \\<Rightarrow> 'b::complete_lattice_with_dual\"\n  assumes \"surj f\"\n  and \"Sup_pres f\" \n  shows \"f ((radj f \\<circ> f) (\\<Squnion>X)) = (\\<Squnion>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((radj f \\<circ> f) (\\<Squnion> X)) = \\<Squnion> (f ` X)", "by (metis assms(1) assms(2) comp_def pointfree_idE surj_Sup_pres_id)"], ["", "subsection \\<open>A Quick Example: Dedekind-MacNeille Completions\\<close>"], ["", "text \\<open>I only outline the basic construction. Additional facts about join density, and that the completion yields \nthe least complete lattice that contains all Sups and Infs of the underlying posets, are left for future consideration.\\<close>"], ["", "abbreviation \"dm \\<equiv> lb_set \\<circ> ub_set\""], ["", "lemma up_set_prop: \"(X::'a::preorder set) \\<noteq> {} \\<Longrightarrow> ub_set X = \\<Inter>{\\<up>x |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow>\n    ub_set X = \\<Inter> {\\<up> x |x. x \\<in> X}", "unfolding ub_set_def upset_def upset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow>\n    {y. \\<forall>x\\<in>X. x \\<le> y} =\n    \\<Inter>\n     {((\\<lambda>X. {y. \\<exists>x\\<in>X. x \\<le> y}) \\<circ> \\<eta>) x |x.\n      x \\<in> X}", "by (safe, simp_all, blast)"], ["", "lemma lb_set_prop: \"(X::'a::preorder set) \\<noteq> {} \\<Longrightarrow> lb_set X = \\<Inter>{\\<down>x |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow>\n    lb_set X = \\<Inter> {\\<down> x |x. x \\<in> X}", "unfolding lb_set_def downset_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow>\n    {y. Ball X ((\\<le>) y)} =\n    \\<Inter>\n     {((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>) x |x. x \\<in> X}", "by (safe, simp_all, blast)"], ["", "lemma dm_downset_var: \"dm {x} = \\<down>(x::'a::preorder)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dm (\\<eta> x) = \\<down> x", "unfolding lb_set_def ub_set_def downset_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n     (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}))\n     (\\<eta> x) =\n    ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ> \\<eta>) x", "by (clarsimp, meson order_refl order_trans)"], ["", "lemma dm_downset: \"dm \\<circ> \\<eta> = (\\<down>::'a::preorder \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dm \\<circ> \\<eta> = \\<down>", "using dm_downset_var fun.map_cong"], ["proof (prove)\nusing this:\n  dm (\\<eta> ?x) = \\<down> ?x\n  \\<lbrakk>?x = ?ya;\n   \\<And>z. z \\<in> range ?ya \\<Longrightarrow> ?f z = ?g z\\<rbrakk>\n  \\<Longrightarrow> ?f \\<circ> ?x = ?g \\<circ> ?ya\n\ngoal (1 subgoal):\n 1. dm \\<circ> \\<eta> = \\<down>", "by fastforce"], ["", "lemma dm_inj: \"inj ((dm::'a::order set \\<Rightarrow> 'a set) \\<circ> \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (dm \\<circ> \\<eta>)", "by (simp add: dm_downset downset_inj)"], ["", "lemma \"clop (lb_set \\<circ> ub_set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clop dm", "unfolding clop_def lb_set_def ub_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n             (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}) \\<and>\n    mono\n     ((\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n      (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y})) \\<and>\n    (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n    (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}) \\<circ>\n    ((\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n     (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}))\n    \\<le> (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n          (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y})", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. id \\<le> (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n             (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y})\n 2. mono\n     ((\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n      (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}))\n 3. (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n    (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}) \\<circ>\n    ((\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n     (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y}))\n    \\<le> (\\<lambda>X. {y. Ball X ((\\<le>) y)}) \\<circ>\n          (\\<lambda>X. {y. \\<forall>x\\<in>X. x \\<le> y})", "unfolding le_fun_def comp_def id_def mono_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x.\n       x \\<subseteq> {y. Ball {y. \\<forall>x\\<in>x. x \\<le> y} ((\\<le>) y)}\n 2. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       {y. Ball {y. \\<forall>x\\<in>x. x \\<le> y} ((\\<le>) y)}\n       \\<subseteq> {ya.\n                    Ball {ya. \\<forall>x\\<in>y. x \\<le> ya} ((\\<le>) ya)}\n 3. \\<forall>x.\n       {y. Ball\n            {y. \\<forall>x\\<in>{y. Ball {y. \\<forall>x\\<in>x. x \\<le> y}\n                                    ((\\<le>) y)}.\n                   x \\<le> y}\n            ((\\<le>) y)}\n       \\<subseteq> {y. Ball {y. \\<forall>x\\<in>x. x \\<le> y} ((\\<le>) y)}", "by auto"], ["", "end"]]}