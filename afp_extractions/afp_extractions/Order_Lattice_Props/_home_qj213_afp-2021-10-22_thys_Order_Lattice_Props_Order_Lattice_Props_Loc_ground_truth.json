{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Order_Lattice_Props_Loc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma dual_min_set: \"min_set = dual_ord.max_set\"", "lemma dual_directed: \"directed = dual_ord.filtered\"", "lemma dual_downset: \"downset = dual_ord.upset\"", "lemma dual_downset_set: \"downset_set = dual_ord.upset_set\"", "lemma dual_downsets: \"downsets = dual_ord.upsets\"", "lemma dual_ideals: \"ideals = dual_ord.filters\"", "lemma dual_lfp: \"lfp = dual_complete_lattice.gfp\"", "lemma directed_nonempty: \"directed X \\<Longrightarrow> X \\<noteq> {}\"", "lemma directed_ub: \"directed X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z)\"", "lemma downset_set_prop: \"\\<Down> = Union \\<circ> (`) \\<down>\"", "lemma downset_set_prop_var: \"\\<Down>X = (\\<Union>x \\<in> X. \\<down>x)\"", "lemma downset_prop: \"\\<down>x = {y. y \\<le> x}\"", "lemma directed_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow> directed X\"", "lemma directed_alt: \"directed X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z))\"", "lemma downset_set_ext: \"id \\<le> \\<Down>\"", "lemma downset_set_iso: \"mono \\<Down>\"", "lemma downset_set_idem [simp]: \"\\<Down> \\<circ> \\<Down> = \\<Down>\"", "lemma downset_faithful: \"\\<down>x \\<subseteq> \\<down>y \\<Longrightarrow> x \\<le> y\"", "lemma downset_iso_iff: \"(\\<down>x \\<subseteq> \\<down>y) = (x \\<le> y)\"", "lemma downset_directed_downset_var [simp]: \"directed (\\<Down>X) = directed X\"", "lemma downset_directed_downset [simp]: \"directed \\<circ> \\<Down> = directed\"", "lemma directed_downset_ideals: \"directed (\\<Down>X) = (\\<Down>X \\<in> ideals)\"", "lemma downset_iso: \"mono (\\<down>::'a::order \\<Rightarrow> 'a set)\"", "lemma downset_inj: \"inj \\<down>\"", "lemma lat_ideals: \"X \\<in> ideals = (X \\<noteq> {} \\<and> X \\<in> downsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<squnion> y \\<in> X))\"", "lemma bot_ideal: \"X \\<in> ideals \\<Longrightarrow> \\<bottom> \\<in> X\"", "lemma Sup_downset_id [simp]: \"Sup \\<circ> \\<down> = id\"", "lemma downset_Sup_id: \"id \\<le> \\<down> \\<circ> Sup\"", "lemma Inf_Sup_var: \"\\<Squnion>(\\<Inter>x \\<in> X. \\<down>x) = \\<Sqinter>X\"", "lemma Inf_pres_downset_var: \"(\\<Inter>x \\<in> X. \\<down>x) = \\<down>(\\<Sqinter>X)\"", "lemma lfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> lfp f \\<in> Fix f\"", "lemma gfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> gfp f \\<in> Fix f\"", "lemma nonempty_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> Fix f \\<noteq> {}\"", "lemma filtered_nonempty: \"filtered X \\<Longrightarrow> X \\<noteq> {}\"", "lemma filtered_lb: \"filtered X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y)\"", "lemma upset_set_prop: \"\\<Up> = Union \\<circ> (`) \\<up>\"", "lemma upset_set_prop_var: \"\\<Up>X = (\\<Union>x \\<in> X. \\<up>x)\"", "lemma upset_prop: \"\\<up>x = {y. x \\<le> y}\"", "lemma filtered_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y) \\<Longrightarrow> filtered X\"", "lemma filtered_alt: \"filtered X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y))\"", "lemma upset_set_ext: \"id \\<le> \\<Up>\"", "lemma upset_set_anti: \"mono \\<Up>\"", "lemma up_set_idem [simp]: \"\\<Up> \\<circ> \\<Up> = \\<Up>\"", "lemma upset_faithful: \"\\<up>x \\<subseteq> \\<up>y \\<Longrightarrow> y \\<le> x\"", "lemma upset_anti_iff: \"(\\<up>y \\<subseteq> \\<up>x) = (x \\<le> y)\"", "lemma upset_filtered_upset [simp]: \"filtered \\<circ> \\<Up> = filtered\"", "lemma filtered_upset_filters: \"filtered (\\<Up>X) = (\\<Up>X \\<in> filters)\"", "lemma upset_inj: \"inj \\<up>\"", "lemma lat_filters: \"X \\<in> filters = (X \\<noteq> {} \\<and> X \\<in> upsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<sqinter> y \\<in> X))\"", "lemma top_filter: \"X \\<in> filters \\<Longrightarrow> \\<top> \\<in> X\"", "lemma Inf_upset_id [simp]: \"Inf \\<circ> \\<up> = id\"", "lemma upset_Inf_id: \"id \\<le> \\<up> \\<circ> Inf\"", "lemma Sup_Inf_var: \" \\<Sqinter>(\\<Inter>x \\<in> X. \\<up>x) = \\<Squnion>X\"", "lemma Sup_dual_upset_var: \"(\\<Inter>x \\<in> X. \\<up>x) = \\<up>(\\<Squnion>X)\"", "lemma upset_anti: \"antimono (\\<up>::'a::order \\<Rightarrow> 'a set)\"", "lemma fSup_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = (\\<Squnion>n. f n)\"", "lemma fInf_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = (\\<Sqinter>n. f n)\"", "lemma fun_isol: \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\"", "lemma fun_isor: \"mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)\"", "lemma Sup_sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> sup_pres f\"", "lemma Inf_inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows\"Inf_pres f \\<Longrightarrow> inf_pres f\"", "lemma Sup_bot_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> bot_pres f\"", "lemma Inf_top_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> top_pres f\"", "lemma iso_Inf_subdistl: \n  assumes \"mono (f::'a \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f\"", "lemma iso_Sup_supdistl: \n  assumes \"mono (f::'a \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup\"", "lemma Inf_subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f\"", "lemma Sup_supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f\"", "lemma supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f\"", "lemma subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f\"", "lemma fSup_distr: \"Sup_pres (\\<lambda>x. x \\<circ> f)\"", "lemma fSup_distr_var: \"\\<Squnion>F \\<circ> g = (\\<Squnion>f \\<in> F. f \\<circ> g)\"", "lemma fInf_distr: \"Inf_pres (\\<lambda>x. x \\<circ> f)\"", "lemma fInf_distr_var: \"\\<Sqinter>F \\<circ> g = (\\<Sqinter>f \\<in> F. f \\<circ> g)\"", "lemma fSup_subdistl: \n  assumes \"mono (f::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup\"", "lemma fSup_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<Squnion>g \\<in> G. f \\<circ> g) \\<le> f \\<circ> \\<Squnion>G\"", "lemma fInf_subdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)\"", "lemma fInf_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> \\<Sqinter>G \\<le> (\\<Sqinter>g \\<in> G. f \\<circ> g)\"", "lemma Inf_pres_downset: \"Inf_pres (\\<down>::'a::complete_lattice \\<Rightarrow> 'a set)\"", "lemma Sup_dual_upset: \"Sup_dual (\\<up>::'a::complete_lattice \\<Rightarrow> 'a set)\""], "translations": [["", "lemma dual_min_set: \"min_set = dual_ord.max_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_set = ord.max_set (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_ord.dual_max_set)"], ["", "lemma dual_directed: \"directed = dual_ord.filtered\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed = ord.filtered (\\<lambda>x y. y \\<le> x)", "by (simp add:dual_ord.dual_filtered)"], ["", "lemma dual_downset: \"downset = dual_ord.upset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> = ord.upset (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_ord.dual_upset)"], ["", "lemma dual_downset_set: \"downset_set = dual_ord.upset_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> = ord.upset_set (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_ord.dual_upset_set)"], ["", "lemma dual_downsets: \"downsets = dual_ord.upsets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. downsets = ord.upsets (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_ord.dual_upsets)"], ["", "lemma dual_ideals: \"ideals = dual_ord.filters\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideals = ord.filters (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_ord.dual_filters)"], ["", "end"], ["", "context complete_lattice\nbegin"], ["", "lemma dual_lfp: \"lfp = dual_complete_lattice.gfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp = complete_lattice.gfp Inf (\\<lambda>x y. y \\<le> x)", "by (simp add: dual_complete_lattice.dual_gfp)"], ["", "end"], ["", "subsection \\<open>Properties of Orderings, Again\\<close>"], ["", "context ord\nbegin"], ["", "lemma directed_nonempty: \"directed X \\<Longrightarrow> X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X \\<Longrightarrow> X \\<noteq> {}", "unfolding directed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n       (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x) \\<Longrightarrow>\n    X \\<noteq> {}", "by fastforce"], ["", "lemma directed_ub: \"directed X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z", "by (meson empty_subsetI directed_def finite.emptyI finite_insert insert_subset order_refl)"], ["", "lemma downset_set_prop: \"\\<Down> = Union \\<circ> (`) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> = \\<Union> \\<circ> (`) \\<down>", "unfolding downset_set_def downset_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {y. Bex x ((\\<le>) y)} =\n       (\\<Union> \\<circ>\n        (`) ((\\<lambda>X. {y. Bex X ((\\<le>) y)}) \\<circ>\n             (\\<lambda>x. {x})))\n        x", "by fastforce"], ["", "lemma downset_set_prop_var: \"\\<Down>X = (\\<Union>x \\<in> X. \\<down>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> X = \\<Union> (\\<down> ` X)", "by (simp add: downset_set_prop)"], ["", "lemma downset_prop: \"\\<down>x = {y. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> x = {y. y \\<le> x}", "unfolding downset_def downset_set_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. Bex {x} ((\\<le>) y)} = {y. y \\<le> x}", "by fastforce"], ["", "end"], ["", "context preorder\nbegin"], ["", "lemma directed_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z) \\<Longrightarrow> directed X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "assume h1: \"X \\<noteq> {}\"\n  and h2: \"\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n  \\<forall>x\\<in>X.\n     \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "{"], ["proof (state)\nthis:\n  X \\<noteq> {}\n  \\<forall>x\\<in>X.\n     \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "have \"finite Y \\<Longrightarrow> Y \\<subseteq> X \\<Longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite Y; Y \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> X \\<Longrightarrow>\n    \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> X\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> X \\<Longrightarrow>\n    \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x", "using h1"], ["proof (prove)\nusing this:\n  {} \\<subseteq> X\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>X. \\<forall>y\\<in>{}. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> X \\<Longrightarrow>\n        \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x;\n        insert x F \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>X.\n                            \\<forall>y\\<in>insert x F. y \\<le> xa", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> X \\<Longrightarrow>\n  \\<exists>x\\<in>X. \\<forall>y\\<in>F. y \\<le> x\n  insert x F \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>X. \\<forall>y\\<in>insert x F. y \\<le> xa", "by (metis h2 insert_iff insert_subset order_trans)"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>X. \\<forall>y\\<in>insert x F. y \\<le> xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite Y; Y \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?Y3; ?Y3 \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y3. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> directed X", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y3; ?Y3 \\<subseteq> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y3. y \\<le> x\n\ngoal (1 subgoal):\n 1. directed X", "by (simp add: directed_def)"], ["proof (state)\nthis:\n  directed X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma directed_alt: \"directed X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. x \\<le> z \\<and> y \\<le> z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed X =\n    (X \\<noteq> {} \\<and>\n     (\\<forall>x\\<in>X.\n         \\<forall>y\\<in>X. \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z))", "by (metis directed_prop directed_nonempty directed_ub)"], ["", "lemma downset_set_ext: \"id \\<le> \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<Down>", "unfolding le_fun_def id_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<subseteq> {y. Bex x ((\\<le>) y)}", "by auto"], ["", "lemma downset_set_iso: \"mono \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<Down>", "unfolding mono_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<subseteq> y \\<longrightarrow>\n       {y. Bex x ((\\<le>) y)} \\<subseteq> {ya. Bex y ((\\<le>) ya)}", "by blast"], ["", "lemma downset_set_idem [simp]: \"\\<Down> \\<circ> \\<Down> = \\<Down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> \\<circ> \\<Down> = \\<Down>", "unfolding fun_eq_iff downset_set_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {y. Bex {y. Bex x ((\\<le>) y)} ((\\<le>) y)} = {y. Bex x ((\\<le>) y)}", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {y. Bex {y. Bex x ((\\<le>) y)} ((\\<le>) y)} = {y. Bex x ((\\<le>) y)}", "by auto"], ["", "lemma downset_faithful: \"\\<down>x \\<subseteq> \\<down>y \\<Longrightarrow> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<down> x \\<subseteq> \\<down> y \\<Longrightarrow> x \\<le> y", "by (simp add: downset_prop subset_eq)"], ["", "lemma downset_iso_iff: \"(\\<down>x \\<subseteq> \\<down>y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<down> x \\<subseteq> \\<down> y) = (x \\<le> y)", "using atMost_iff downset_prop order_trans"], ["proof (prove)\nusing this:\n  (?i \\<in> {..?k}) = (?i \\<le> ?k)\n  \\<down> ?x = {y. y \\<le> ?x}\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (\\<down> x \\<subseteq> \\<down> y) = (x \\<le> y)", "by blast"], ["", "lemma downset_directed_downset_var [simp]: \"directed (\\<Down>X) = directed X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) = directed X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "assume h1: \"directed X\""], ["proof (state)\nthis:\n  directed X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "{"], ["proof (state)\nthis:\n  directed X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "fix Y"], ["proof (state)\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "assume h2: \"finite Y\" and h3: \"Y \\<subseteq> \\<Down>X\""], ["proof (state)\nthis:\n  finite Y\n  Y \\<subseteq> \\<Down> X\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<forall>y. \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and>  y \\<le> x\""], ["proof (prove)\nusing this:\n  finite Y\n  Y \\<subseteq> \\<Down> X\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x", "by (force simp: downset_set_def)"], ["proof (state)\nthis:\n  \\<forall>y.\n     \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>f. \\<forall>y. y \\<in> Y \\<longrightarrow>  f y \\<in> X \\<and> y \\<le> f y\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     \\<exists>x. y \\<in> Y \\<longrightarrow> x \\<in> X \\<and> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>y.\n          y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y", "by (rule choice)"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>y. y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>f. finite (f ` Y) \\<and> f ` Y \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. y \\<le> f y)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>y. y \\<in> Y \\<longrightarrow> f y \\<in> X \\<and> y \\<le> f y\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       finite (f ` Y) \\<and>\n       f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)", "by (metis finite_imageI h2 image_subsetI)"], ["proof (state)\nthis:\n  \\<exists>f.\n     finite (f ` Y) \\<and>\n     f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>Z. finite Z \\<and> Z \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. \\<exists> z \\<in> Z. y \\<le> z)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     finite (f ` Y) \\<and>\n     f ` Y \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. y \\<le> f y)\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       finite Z \\<and>\n       Z \\<subseteq> X \\<and>\n       (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>Z. finite Z \\<and> Z \\<subseteq> X \\<and> (\\<forall>y \\<in> Y. \\<exists> z \\<in> Z. y \\<le> z) \\<and> (\\<exists>x \\<in> X. \\<forall> z \\<in> Z. z \\<le> x)\""], ["proof (prove)\nusing this:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and> (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z)\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       finite Z \\<and>\n       Z \\<subseteq> X \\<and>\n       (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n       (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)", "by (metis directed_def h1)"], ["proof (state)\nthis:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and>\n     (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n     (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "hence \"\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x\""], ["proof (prove)\nusing this:\n  \\<exists>Z.\n     finite Z \\<and>\n     Z \\<subseteq> X \\<and>\n     (\\<forall>y\\<in>Y. \\<exists>z\\<in>Z. y \\<le> z) \\<and>\n     (\\<exists>x\\<in>X. \\<forall>z\\<in>Z. z \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "by (meson order_trans)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?Y3; ?Y3 \\<subseteq> \\<Down> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y3. y \\<le> x\n\ngoal (2 subgoals):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X\n 2. directed X \\<Longrightarrow> directed (\\<Down> X)", "thus \"directed (\\<Down>X)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y3; ?Y3 \\<subseteq> \\<Down> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y3. y \\<le> x\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X)", "unfolding directed_def downset_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?Y3; ?Y3 \\<subseteq> {y. Bex X ((\\<le>) y)}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>?Y3. y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and>\n       Y \\<subseteq> {y. Bex X ((\\<le>) y)} \\<longrightarrow>\n       (\\<exists>x\\<in>{y. Bex X ((\\<le>) y)}. \\<forall>y\\<in>Y. y \\<le> x)", "by fastforce"], ["proof (state)\nthis:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "assume \"directed (\\<Down>X)\""], ["proof (state)\nthis:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed (\\<Down> X) \\<Longrightarrow> directed X", "thus \"directed X\""], ["proof (prove)\nusing this:\n  directed (\\<Down> X)\n\ngoal (1 subgoal):\n 1. directed X", "unfolding directed_def downset_set_def"], ["proof (prove)\nusing this:\n  \\<forall>Y.\n     finite Y \\<and> Y \\<subseteq> {y. Bex X ((\\<le>) y)} \\<longrightarrow>\n     (\\<exists>x\\<in>{y. Bex X ((\\<le>) y)}. \\<forall>y\\<in>Y. y \\<le> x)\n\ngoal (1 subgoal):\n 1. \\<forall>Y.\n       finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n       (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>\\<forall>Y.\n                   finite Y \\<and>\n                   Y \\<subseteq> {y. \\<exists>x\\<in>X.\n  y \\<le> x} \\<longrightarrow>\n                   (\\<exists>x.\n                       (\\<exists>xa\\<in>X. x \\<le> xa) \\<and>\n                       (\\<forall>y\\<in>Y. y \\<le> x));\n        finite Y; Y \\<subseteq> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x", "by (smt Ball_Collect order_refl order_trans subsetCE)"], ["proof (state)\nthis:\n  directed X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma downset_directed_downset [simp]: \"directed \\<circ> \\<Down> = directed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed \\<circ> \\<Down> = directed", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. directed (\\<Down> x) = directed x", "by simp"], ["", "lemma directed_downset_ideals: \"directed (\\<Down>X) = (\\<Down>X \\<in> ideals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed (\\<Down> X) = idealp (\\<Down> X)", "by (metis (mono_tags, lifting) Fix_def comp_apply directed_alt downset_set_idem downsets_def ideals_def mem_Collect_eq)"], ["", "end"], ["", "lemma downset_iso: \"mono (\\<down>::'a::order \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<down>", "by (simp add: downset_iso_iff mono_def)"], ["", "context order\nbegin"], ["", "lemma downset_inj: \"inj \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<down>", "by (metis injI downset_iso_iff eq_iff)"], ["", "end"], ["", "context lattice\nbegin"], ["", "lemma lat_ideals: \"X \\<in> ideals = (X \\<noteq> {} \\<and> X \\<in> downsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<squnion> y \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X =\n    (X \\<noteq> {} \\<and>\n     downset_setp X \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<squnion> y \\<in> X))", "unfolding ideals_def directed_alt downsets_def Fix_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> {X. X \\<noteq> {} \\<and>\n                 X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n                 X \\<noteq> {} \\<and>\n                 (\\<forall>x\\<in>X.\n                     \\<forall>y\\<in>X.\n                        \\<exists>z\\<in>X. x \\<le> z \\<and> y \\<le> z)}) =\n    (X \\<noteq> {} \\<and>\n     X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<squnion> y \\<in> X))", "by (clarsimp, smt sup.cobounded1 sup.orderE sup.orderI sup_absorb2 sup_left_commute mem_Collect_eq)"], ["", "end"], ["", "context bounded_lattice\nbegin"], ["", "lemma bot_ideal: \"X \\<in> ideals \\<Longrightarrow> \\<bottom> \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idealp X \\<Longrightarrow> \\<bottom> \\<in> X", "unfolding ideals_def downsets_def Fix_def downset_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> {X. X \\<noteq> {} \\<and>\n                X \\<in> {x. {y. Bex x ((\\<le>) y)} = x} \\<and>\n                directed X} \\<Longrightarrow>\n    \\<bottom> \\<in> X", "by fastforce"], ["", "end"], ["", "context complete_lattice\nbegin"], ["", "lemma Sup_downset_id [simp]: \"Sup \\<circ> \\<down> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> \\<down> = id", "using Sup_atMost atMost_def downset_prop"], ["proof (prove)\nusing this:\n  \\<Squnion> {..?y} = ?y\n  {..?u} \\<equiv> {x. x \\<le> ?u}\n  \\<down> ?x = {y. y \\<le> ?x}\n\ngoal (1 subgoal):\n 1. Sup \\<circ> \\<down> = id", "by fastforce"], ["", "lemma downset_Sup_id: \"id \\<le> \\<down> \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<down> \\<circ> Sup", "by (simp add: Sup_upper downset_prop le_funI subsetI)"], ["", "lemma Inf_Sup_var: \"\\<Squnion>(\\<Inter>x \\<in> X. \\<down>x) = \\<Sqinter>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> \\<Inter> (\\<down> ` X) = \\<Sqinter> X", "unfolding downset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (\\<Inter>x\\<in>X. {y. y \\<le> x}) = \\<Sqinter> X", "by (simp add: Collect_ball_eq Inf_eq_Sup)"], ["", "lemma Inf_pres_downset_var: \"(\\<Inter>x \\<in> X. \\<down>x) = \\<down>(\\<Sqinter>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (\\<down> ` X) = \\<down> (\\<Sqinter> X)", "unfolding downset_prop"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>x\\<in>X. {y. y \\<le> x}) = {y. y \\<le> \\<Sqinter> X}", "by (safe, simp_all add: le_Inf_iff)"], ["", "end"], ["", "lemma lfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> lfp f \\<in> Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> lfp f \\<in> Fix f", "using Fix_def lfp_unfold"], ["proof (prove)\nusing this:\n  Fix ?f = {x. ?f x = x}\n  mono ?f \\<Longrightarrow> lfp ?f = ?f (lfp ?f)\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> lfp f \\<in> Fix f", "by fastforce"], ["", "lemma gfp_in_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> gfp f \\<in> Fix f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> gfp f \\<in> Fix f", "using Fix_def gfp_unfold"], ["proof (prove)\nusing this:\n  Fix ?f = {x. ?f x = x}\n  mono ?f \\<Longrightarrow> gfp ?f = ?f (gfp ?f)\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> gfp f \\<in> Fix f", "by fastforce"], ["", "lemma nonempty_Fix: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> Fix f \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Fix f \\<noteq> {}", "using lfp_in_Fix"], ["proof (prove)\nusing this:\n  mono ?f \\<Longrightarrow> lfp ?f \\<in> Fix ?f\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> Fix f \\<noteq> {}", "by fastforce"], ["", "subsection \\<open>Dual Properties of Orderings from Locales\\<close>"], ["", "text \\<open>These properties can be proved very smoothly overall. But only within the context of a class\nor locale!\\<close>"], ["", "context ord\nbegin"], ["", "lemma filtered_nonempty: \"filtered X \\<Longrightarrow> X \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow> X \\<noteq> {}", "by (simp add: dual_filtered dual_ord.directed_nonempty)"], ["", "lemma filtered_lb: \"filtered X \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y", "by (simp add: dual_filtered dual_ord.directed_ub)"], ["", "lemma upset_set_prop: \"\\<Up> = Union \\<circ> (`) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> = \\<Union> \\<circ> (`) \\<up>", "by (simp add: dual_ord.downset_set_prop dual_upset dual_upset_set)"], ["", "lemma upset_set_prop_var: \"\\<Up>X = (\\<Union>x \\<in> X. \\<up>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> X = \\<Union> (\\<up> ` X)", "by (simp add: dual_ord.downset_set_prop_var dual_upset dual_upset_set)"], ["", "lemma upset_prop: \"\\<up>x = {y. x \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> x = {y. x \\<le> y}", "by (simp add: dual_ord.downset_prop dual_upset)"], ["", "end"], ["", "context preorder\nbegin"], ["", "lemma filtered_prop: \"X \\<noteq> {} \\<Longrightarrow> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y) \\<Longrightarrow> filtered X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<noteq> {};\n     \\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> filtered X", "by (simp add: dual_filtered dual_preorder.directed_prop)"], ["", "lemma filtered_alt: \"filtered X = (X \\<noteq> {} \\<and> (\\<forall>x \\<in> X. \\<forall>y \\<in> X. \\<exists>z \\<in> X. z \\<le> x \\<and> z \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered X =\n    (X \\<noteq> {} \\<and>\n     (\\<forall>x\\<in>X.\n         \\<forall>y\\<in>X. \\<exists>z\\<in>X. z \\<le> x \\<and> z \\<le> y))", "by (simp add: dual_filtered dual_preorder.directed_alt)"], ["", "lemma upset_set_ext: \"id \\<le> \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<Up>", "by (simp add: dual_preorder.downset_set_ext dual_upset_set)"], ["", "lemma upset_set_anti: \"mono \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<Up>", "by (simp add: dual_preorder.downset_set_iso dual_upset_set)"], ["", "lemma up_set_idem [simp]: \"\\<Up> \\<circ> \\<Up> = \\<Up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Up> \\<circ> \\<Up> = \\<Up>", "by (simp add: dual_upset_set)"], ["", "lemma upset_faithful: \"\\<up>x \\<subseteq> \\<up>y \\<Longrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<up> x \\<subseteq> \\<up> y \\<Longrightarrow> y \\<le> x", "by (metis dual_preorder.downset_faithful dual_upset)"], ["", "lemma upset_anti_iff: \"(\\<up>y \\<subseteq> \\<up>x) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<up> y \\<subseteq> \\<up> x) = (x \\<le> y)", "by (simp add: dual_preorder.downset_iso_iff dual_upset)"], ["", "lemma upset_filtered_upset [simp]: \"filtered \\<circ> \\<Up> = filtered\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered \\<circ> \\<Up> = filtered", "by (simp add: dual_filtered dual_upset_set)"], ["", "lemma filtered_upset_filters: \"filtered (\\<Up>X) = (\\<Up>X \\<in> filters)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered (\\<Up> X) = filterp (\\<Up> X)", "using dual_filtered dual_preorder.directed_downset_ideals dual_upset_set ord.dual_filters"], ["proof (prove)\nusing this:\n  filtered = ord.directed (\\<lambda>x y. y \\<le> x)\n  ord.directed (\\<lambda>x y. y \\<le> x)\n   (ord.downset_set (\\<lambda>x y. y \\<le> x) ?X) =\n  (ord.downset_set (\\<lambda>x y. y \\<le> x) ?X\n   \\<in> ord.ideals (\\<lambda>x y. y \\<le> x))\n  \\<Up> = ord.downset_set (\\<lambda>x y. y \\<le> x)\n  ord.filters ?less_eq = ord.ideals (\\<lambda>x y. ?less_eq y x)\n\ngoal (1 subgoal):\n 1. filtered (\\<Up> X) = filterp (\\<Up> X)", "by fastforce"], ["", "end"], ["", "context order\nbegin"], ["", "lemma upset_inj: \"inj \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<up>", "by (simp add: dual_order.downset_inj dual_upset)"], ["", "end"], ["", "context lattice\nbegin"], ["", "lemma lat_filters: \"X \\<in> filters = (X \\<noteq> {} \\<and> X \\<in> upsets \\<and> (\\<forall>x \\<in> X. \\<forall> y \\<in> X. x \\<sqinter> y \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X =\n    (X \\<noteq> {} \\<and>\n     upset_setp X \\<and>\n     (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<sqinter> y \\<in> X))", "by (simp add: dual_filters dual_lattice.lat_ideals dual_ord.downsets_def dual_upset_set upsets_def)"], ["", "end"], ["", "context bounded_lattice\nbegin"], ["", "lemma top_filter: \"X \\<in> filters \\<Longrightarrow> \\<top> \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterp X \\<Longrightarrow> \\<top> \\<in> X", "by (simp add: dual_bounded_lattice.bot_ideal dual_filters)"], ["", "end"], ["", "context complete_lattice\nbegin"], ["", "lemma Inf_upset_id [simp]: \"Inf \\<circ> \\<up> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf \\<circ> \\<up> = id", "by (simp add:  dual_upset)"], ["", "lemma upset_Inf_id: \"id \\<le> \\<up> \\<circ> Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<le> \\<up> \\<circ> Inf", "by (simp add: dual_complete_lattice.downset_Sup_id dual_upset)"], ["", "lemma Sup_Inf_var: \" \\<Sqinter>(\\<Inter>x \\<in> X. \\<up>x) = \\<Squnion>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> \\<Inter> (\\<up> ` X) = \\<Squnion> X", "by (simp add: dual_complete_lattice.Inf_Sup_var dual_upset)"], ["", "lemma Sup_dual_upset_var: \"(\\<Inter>x \\<in> X. \\<up>x) = \\<up>(\\<Squnion>X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (\\<up> ` X) = \\<up> (\\<Squnion> X)", "by (simp add: dual_complete_lattice.Inf_pres_downset_var dual_upset)"], ["", "end"], ["", "subsection \\<open>Examples that Do Not Dualise\\<close>"], ["", "lemma upset_anti: \"antimono (\\<up>::'a::order \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono \\<up>", "by (simp add: antimono_def upset_anti_iff)"], ["", "context complete_lattice \nbegin"], ["", "lemma fSup_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = (\\<Squnion>n. f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<squnion> (\\<Squnion>n. f (Suc n)) = \\<Squnion> range f", "apply (intro antisym sup_least)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f 0 \\<le> \\<Squnion> range f\n 2. (\\<Squnion>n. f (Suc n)) \\<le> \\<Squnion> range f\n 3. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (rule Sup_upper, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Squnion>n. f (Suc n)) \\<le> \\<Squnion> range f\n 2. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (rule Sup_mono, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> range f \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "apply (safe intro!: Sup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       n \\<in> UNIV \\<Longrightarrow>\n       f n \\<le> f 0 \\<squnion> (\\<Squnion>n. f (Suc n))", "by (case_tac n, simp_all add: Sup_upper le_supI2)"], ["", "lemma fInf_unfold: \"(f::nat \\<Rightarrow> 'a) 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = (\\<Sqinter>n. f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) = \\<Sqinter> range f", "apply (intro antisym inf_greatest)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> \\<Sqinter> range f\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (rule Inf_greatest, safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x n.\n       n \\<in> UNIV \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (case_tac n)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x n.\n       \\<lbrakk>n \\<in> UNIV; n = 0\\<rbrakk>\n       \\<Longrightarrow> f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 2. \\<And>x n nat.\n       \\<lbrakk>n \\<in> UNIV; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f n\n 3. \\<Sqinter> range f \\<le> f 0\n 4. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n nat.\n       n = Suc nat \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f (Suc nat)\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "using Inf_lower inf.coboundedI2"], ["proof (prove)\nusing this:\n  ?x \\<in> ?A \\<Longrightarrow> \\<Sqinter> ?A \\<le> ?x\n  ?b \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n\ngoal (3 subgoals):\n 1. \\<And>n nat.\n       n = Suc nat \\<Longrightarrow>\n       f 0 \\<sqinter> (\\<Sqinter>n. f (Suc n)) \\<le> f (Suc nat)\n 2. \\<Sqinter> range f \\<le> f 0\n 3. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Sqinter> range f \\<le> f 0\n 2. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "apply (simp add: Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> range f \\<le> (\\<Sqinter>n. f (Suc n))", "by (auto intro: Inf_mono)"], ["", "end"], ["", "lemma fun_isol: \"mono f \\<Longrightarrow> mono ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono ((\\<circ>) f)", "by (simp add: le_fun_def mono_def)"], ["", "lemma fun_isor: \"mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (\\<lambda>x. x \\<circ> f)", "by (simp add: le_fun_def mono_def)"], ["", "lemma Sup_sup_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> sup_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> sup_pres f", "by (metis (no_types, hide_lams) Sup_empty Sup_insert comp_apply image_insert sup_bot.right_neutral)"], ["", "lemma Inf_inf_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows\"Inf_pres f \\<Longrightarrow> inf_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> inf_pres f", "by (smt INF_insert comp_eq_elim dual_complete_lattice.Sup_empty dual_complete_lattice.Sup_insert inf_top.right_neutral)"], ["", "lemma Sup_bot_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup_pres f \\<Longrightarrow> bot_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres f \\<Longrightarrow> bot_pres f", "by (metis SUP_empty Sup_empty comp_eq_elim)"], ["", "lemma Inf_top_pres: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Inf_pres f \\<Longrightarrow> top_pres f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres f \\<Longrightarrow> top_pres f", "by (metis INF_empty comp_eq_elim dual_complete_lattice.Sup_empty)"], ["", "context complete_lattice\nbegin"], ["", "lemma iso_Inf_subdistl: \n  assumes \"mono (f::'a \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> Inf \\<le> Inf \\<circ> (`) f", "by (simp add: assms complete_lattice_class.le_Inf_iff le_funI Inf_lower monoD)"], ["", "lemma iso_Sup_supdistl: \n  assumes \"mono (f::'a \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) f \\<le> f \\<circ> Sup", "by (simp add: assms complete_lattice_class.SUP_le_iff le_funI dual_complete_lattice.Inf_lower monoD)"], ["", "lemma Inf_subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> Inf \\<le> Inf \\<circ> (`) f \\<Longrightarrow> mono f", "unfolding mono_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. f (\\<Sqinter> x) \\<le> \\<Sqinter> (f ` x) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (metis complete_lattice_class.le_INF_iff Inf_atLeast atLeast_iff)"], ["", "lemma Sup_supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) f \\<le> f \\<circ> Sup \\<Longrightarrow> mono f", "unfolding mono_def le_fun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<Squnion> (f ` x) \\<le> f (\\<Squnion> x) \\<Longrightarrow>\n    \\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by (metis complete_lattice_class.SUP_le_iff Sup_atMost atMost_iff)"], ["", "lemma supdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f", "using Sup_supdistl_iso iso_Sup_supdistl"], ["proof (prove)\nusing this:\n  Sup \\<circ> (`) ?f \\<le> ?f \\<circ> Sup \\<Longrightarrow> mono ?f\n  mono ?f \\<Longrightarrow> Sup \\<circ> (`) ?f \\<le> ?f \\<circ> Sup\n\ngoal (1 subgoal):\n 1. (Sup \\<circ> (`) f \\<le> f \\<circ> Sup) = mono f", "by force"], ["", "lemma subdistl_iso: \n  fixes f :: \"'a \\<Rightarrow> 'b::complete_lattice\"\n  shows \"(f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f", "using Inf_subdistl_iso iso_Inf_subdistl"], ["proof (prove)\nusing this:\n  ?f \\<circ> Inf \\<le> Inf \\<circ> (`) ?f \\<Longrightarrow> mono ?f\n  mono ?f \\<Longrightarrow> ?f \\<circ> Inf \\<le> Inf \\<circ> (`) ?f\n\ngoal (1 subgoal):\n 1. (f \\<circ> Inf \\<le> Inf \\<circ> (`) f) = mono f", "by force"], ["", "end"], ["", "lemma fSup_distr: \"Sup_pres (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres (\\<lambda>x. x \\<circ> f)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<Squnion> x) (f xa) =\n       (\\<Squnion>x\\<in>x. (\\<lambda>xa. x (f xa))) xa", "by (smt Inf.INF_cong SUP_apply Sup_apply)"], ["", "lemma fSup_distr_var: \"\\<Squnion>F \\<circ> g = (\\<Squnion>f \\<in> F. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> F \\<circ> g = (\\<Squnion>f\\<in>F. f \\<circ> g)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<Squnion> F) (g x) = (\\<Squnion>f\\<in>F. (\\<lambda>x. f (g x))) x", "by (smt Inf.INF_cong SUP_apply Sup_apply)"], ["", "lemma fInf_distr: \"Inf_pres (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres (\\<lambda>x. x \\<circ> f)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       (\\<Sqinter> x) (f xa) =\n       (\\<Sqinter>x\\<in>x. (\\<lambda>xa. x (f xa))) xa", "by (smt INF_apply Inf.INF_cong Inf_apply)"], ["", "lemma fInf_distr_var: \"\\<Sqinter>F \\<circ> g = (\\<Sqinter>f \\<in> F. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> F \\<circ> g = (\\<Sqinter>f\\<in>F. f \\<circ> g)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<Sqinter> F) (g x) = (\\<Sqinter>f\\<in>F. (\\<lambda>x. f (g x))) x", "by (smt INF_apply Inf.INF_cong Inf_apply)"], ["", "lemma fSup_subdistl: \n  assumes \"mono (f::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice)\"\n  shows \"Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup", "using assms"], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. Sup \\<circ> (`) ((\\<circ>) f) \\<le> (\\<circ>) f \\<circ> Sup", "by (simp add: SUP_least Sup_upper le_fun_def monoD image_comp)"], ["", "lemma fSup_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<Squnion>g \\<in> G. f \\<circ> g) \\<le> f \\<circ> \\<Squnion>G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    \\<Squnion> ((\\<circ>) f ` G) \\<le> f \\<circ> \\<Squnion> G", "by (simp add: SUP_least Sup_upper le_fun_def monoD image_comp)"], ["", "lemma fInf_subdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows  \"mono f \\<Longrightarrow> (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    (\\<circ>) f \\<circ> Inf \\<le> Inf \\<circ> (`) ((\\<circ>) f)", "by (simp add: INF_greatest Inf_lower le_fun_def monoD image_comp)"], ["", "lemma fInf_subdistl_var: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> \\<Sqinter>G \\<le> (\\<Sqinter>g \\<in> G. f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    f \\<circ> \\<Sqinter> G \\<le> \\<Sqinter> ((\\<circ>) f ` G)", "by (simp add: INF_greatest Inf_lower le_fun_def monoD image_comp)"], ["", "lemma Inf_pres_downset: \"Inf_pres (\\<down>::'a::complete_lattice \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres \\<down>", "unfolding downset_prop fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {y. y \\<le> \\<Sqinter> x} = (\\<Inter>x\\<in>x. {y. y \\<le> x})", "by (safe, simp_all add: le_Inf_iff)"], ["", "lemma Sup_dual_upset: \"Sup_dual (\\<up>::'a::complete_lattice \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_dual \\<up>", "unfolding upset_prop fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       Collect ((\\<le>) (\\<Squnion> x)) =\n       (\\<Inter>x\\<in>x. Collect ((\\<le>) x))", "by (safe, simp_all add: Sup_le_iff)"], ["", "text \\<open>This approach could probably be combined with the explicit functor-based one. This may be good for proofs, but seems conceptually rather ugly.\\<close>"], ["", "end"]]}