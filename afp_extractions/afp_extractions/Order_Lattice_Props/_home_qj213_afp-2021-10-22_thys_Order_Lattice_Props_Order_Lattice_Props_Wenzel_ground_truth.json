{"file_name": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props/Order_Lattice_Props_Wenzel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Order_Lattice_Props", "problem_names": ["lemma dual_inj: \"inj \\<partial>\"", "lemma dual_surj: \"surj \\<partial>\"", "lemma dual_bij: \"bij \\<partial>\"", "lemma dual_inv1 [simp]: \"\\<partial>\\<^sup>- \\<circ> \\<partial> = id\"", "lemma dual_inv2 [simp]: \"\\<partial> \\<circ> \\<partial>\\<^sup>- = id\"", "lemma dual_inv_inj: \"inj \\<partial>\\<^sup>-\"", "lemma dual_inv_surj: \"surj \\<partial>\\<^sup>-\"", "lemma dual_inv_bij: \"bij \\<partial>\\<^sup>-\"", "lemma dual_iff: \"(\\<partial> x = y) \\<longleftrightarrow> (x = \\<partial>\\<^sup>- y)\"", "lemma map_dual_def_var [simp]: \"(map_dual::('a \\<Rightarrow> 'b) \\<Rightarrow> 'a dual \\<Rightarrow> 'b dual) f = \\<partial> \\<circ> f \\<circ> \\<partial>\\<^sup>-\"", "lemma map_dual_def_var2: \"\\<partial>\\<^sup>- \\<circ> map_dual f = f \\<circ> \\<partial>\\<^sup>-\"", "lemma map_dual_func1: \"map_dual (f \\<circ> g) = map_dual f \\<circ> map_dual g\"", "lemma map_dual_func2 : \"map_dual id = id\"", "lemma map_dual_inv_func1: \"map_dual_inv id = id\"", "lemma map_dual_inv_func2: \"map_dual_inv (f \\<circ> g) = map_dual_inv f \\<circ> map_dual_inv g\"", "lemma map_dual_inv1: \"map_dual \\<circ> map_dual_inv = id\"", "lemma map_dual_inv2: \"map_dual_inv \\<circ> map_dual = id\"", "lemma subset_dual: \"(\\<partial> ` X = Y) \\<longleftrightarrow> (X = \\<partial>\\<^sup>- ` Y)\"", "lemma subset_dual1: \"(X \\<subseteq> Y) \\<longleftrightarrow> (\\<partial> ` X \\<subseteq> \\<partial> ` Y)\"", "lemma dual_ball: \"(\\<forall>x \\<in> X. P (\\<partial> x)) \\<longleftrightarrow> (\\<forall>y \\<in> \\<partial> ` X. P y)\"", "lemma dual_inv_ball: \"(\\<forall>x \\<in> X. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<forall>y \\<in> \\<partial>\\<^sup>- ` X. P y)\"", "lemma dual_all: \"(\\<forall>x. P (\\<partial> x)) \\<longleftrightarrow> (\\<forall>y. P y)\"", "lemma dual_inv_all: \"(\\<forall>x. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<forall>y. P y)\"", "lemma dual_ex: \"(\\<exists>x. P (\\<partial> x)) \\<longleftrightarrow> (\\<exists>y. P y)\"", "lemma dual_inv_ex: \"(\\<exists>x. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<exists>y. P y)\"", "lemma dual_Collect: \"{\\<partial> x |x. P (\\<partial> x)} = {y. P y}\"", "lemma dual_inv_Collect: \"{\\<partial>\\<^sup>- x |x. P (\\<partial>\\<^sup>- x)} = {y. P y}\"", "lemma fun_dual1: \"(f \\<circ> \\<partial> = g) \\<longleftrightarrow> (f = g \\<circ> \\<partial>\\<^sup>-)\"", "lemma fun_dual2: \"(\\<partial> \\<circ> f = g) \\<longleftrightarrow> (f = \\<partial>\\<^sup>- \\<circ> g)\"", "lemma fun_dual3: \"(f \\<circ> (`) \\<partial> = g) \\<longleftrightarrow> (f = g \\<circ> (`) \\<partial>\\<^sup>-)\"", "lemma fun_dual4: \"(f = \\<partial>\\<^sup>- \\<circ> g \\<circ> (`) \\<partial>) \\<longleftrightarrow> (\\<partial> \\<circ> f \\<circ> (`) \\<partial>\\<^sup>- = g)\"", "lemma less_eq_dual_def_var: \"(x \\<le> y) = (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x)\"", "lemma less_dual_def_var: \"(x < y) = (\\<partial>\\<^sup>- y < \\<partial>\\<^sup>- x)\"", "lemma dual_anti: \"x \\<le> y \\<Longrightarrow> \\<partial> y \\<le> \\<partial> x\"", "lemma dual_anti_iff: \"(x \\<le> y) = (\\<partial> y \\<le> \\<partial> x)\"", "lemma \"mono f \\<Longrightarrow> mono (map_dual f)\"", "lemma filtered_directed_dual: \"filtered \\<circ> (`) \\<partial> = directed\"", "lemma directed_filtered_dual: \"directed \\<circ> (`) \\<partial> = filtered\"", "lemma downset_set_upset_set_dual: \"(`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\"", "lemma upset_set_downset_set_dual: \"(`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>\""], "translations": [["", "lemma dual_inj: \"inj \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<partial>", "using injI"], ["proof (prove)\nusing this:\n  (\\<And>x y. ?f x = ?f y \\<Longrightarrow> x = y) \\<Longrightarrow> inj ?f\n\ngoal (1 subgoal):\n 1. inj \\<partial>", "by fastforce"], ["", "lemma dual_surj: \"surj \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj \\<partial>", "using dual.exhaust_sel"], ["proof (prove)\nusing this:\n  (?dual = \\<partial> (\\<partial>\\<^sup>- ?dual) \\<Longrightarrow>\n   ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. surj \\<partial>", "by blast"], ["", "lemma dual_bij: \"bij \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<partial>", "by (simp add: bijI dual_inj dual_surj)"], ["", "text \\<open>Dual is not idempotent, and I see no way of imposing this condition. Yet at least an inverse exists --- namely un-dual..\\<close>"], ["", "lemma dual_inv1 [simp]: \"\\<partial>\\<^sup>- \\<circ> \\<partial> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sup>- \\<circ> \\<partial> = id", "by fastforce"], ["", "lemma dual_inv2 [simp]: \"\\<partial> \\<circ> \\<partial>\\<^sup>- = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial> \\<circ> \\<partial>\\<^sup>- = id", "by fastforce"], ["", "lemma dual_inv_inj: \"inj \\<partial>\\<^sup>-\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<partial>\\<^sup>-", "by (simp add: dual.expand injI)"], ["", "lemma dual_inv_surj: \"surj \\<partial>\\<^sup>-\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj \\<partial>\\<^sup>-", "by (metis dual.sel surj_def)"], ["", "lemma dual_inv_bij: \"bij \\<partial>\\<^sup>-\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<partial>\\<^sup>-", "by (simp add: bij_def dual_inv_inj dual_inv_surj)"], ["", "lemma dual_iff: \"(\\<partial> x = y) \\<longleftrightarrow> (x = \\<partial>\\<^sup>- y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> x = y) = (x = \\<partial>\\<^sup>- y)", "by fastforce"], ["", "text \\<open>Isabelle data types come with a number of generic functions.\\<close>"], ["", "text \\<open>The functor map-dual lifts functions to dual types. Isabelle's generic definition is not straightforward to \nunderstand and use. Yet conceptually it can be explained as follows.\\<close>"], ["", "lemma map_dual_def_var [simp]: \"(map_dual::('a \\<Rightarrow> 'b) \\<Rightarrow> 'a dual \\<Rightarrow> 'b dual) f = \\<partial> \\<circ> f \\<circ> \\<partial>\\<^sup>-\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual f = \\<partial> \\<circ> f \\<circ> \\<partial>\\<^sup>-", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. map_dual f x = \\<partial> (f (\\<partial>\\<^sup>- x))", "by (metis dual.map_sel dual_iff)"], ["", "lemma map_dual_def_var2: \"\\<partial>\\<^sup>- \\<circ> map_dual f = f \\<circ> \\<partial>\\<^sup>-\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<partial>\\<^sup>- \\<circ> map_dual f = f \\<circ> \\<partial>\\<^sup>-", "by (simp add: rewriteL_comp_comp)"], ["", "lemma map_dual_func1: \"map_dual (f \\<circ> g) = map_dual f \\<circ> map_dual g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual (f \\<circ> g) = map_dual f \\<circ> map_dual g", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. map_dual (\\<lambda>x. f (g x)) x = map_dual f (map_dual g x)", "by (metis dual.exhaust dual.map)"], ["", "lemma map_dual_func2 : \"map_dual id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual id = id", "by simp"], ["", "text \\<open>The functor map-dual has an inverse functor as well.\\<close>"], ["", "definition map_dual_inv :: \"('a dual \\<Rightarrow> 'b dual) => ('a => 'b)\" where\n  \"map_dual_inv f = \\<partial>\\<^sup>- \\<circ> f \\<circ> \\<partial>\""], ["", "lemma map_dual_inv_func1: \"map_dual_inv id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual_inv id = id", "by (simp add: map_dual_inv_def)"], ["", "lemma map_dual_inv_func2: \"map_dual_inv (f \\<circ> g) = map_dual_inv f \\<circ> map_dual_inv g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual_inv (f \\<circ> g) = map_dual_inv f \\<circ> map_dual_inv g", "unfolding fun_eq_iff comp_def map_dual_inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<partial>\\<^sup>- (f (g (\\<partial> x))) =\n       \\<partial>\\<^sup>-\n        (f (\\<partial> (\\<partial>\\<^sup>- (g (\\<partial> x)))))", "by (metis dual_iff)"], ["", "lemma map_dual_inv1: \"map_dual \\<circ> map_dual_inv = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual \\<circ> map_dual_inv = id", "unfolding fun_eq_iff map_dual_def_var map_dual_inv_def comp_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       \\<partial>\n        (\\<partial>\\<^sup>- (x (\\<partial> (\\<partial>\\<^sup>- xa)))) =\n       x xa", "by (metis dual_iff)"], ["", "lemma map_dual_inv2: \"map_dual_inv \\<circ> map_dual = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dual_inv \\<circ> map_dual = id", "unfolding fun_eq_iff map_dual_def_var map_dual_inv_def comp_def id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       \\<partial>\\<^sup>-\n        (\\<partial> (x (\\<partial>\\<^sup>- (\\<partial> xa)))) =\n       x xa", "by (metis dual_iff)"], ["", "text \\<open>Hence dual is an isomorphism between categories.\\<close>"], ["", "lemma subset_dual: \"(\\<partial> ` X = Y) \\<longleftrightarrow> (X = \\<partial>\\<^sup>- ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> ` X = Y) = (X = \\<partial>\\<^sup>- ` Y)", "by (metis dual_inj image_comp image_inv_f_f inv_o_cancel dual_inv2)"], ["", "lemma subset_dual1: \"(X \\<subseteq> Y) \\<longleftrightarrow> (\\<partial> ` X \\<subseteq> \\<partial> ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<subseteq> Y) = (\\<partial> ` X \\<subseteq> \\<partial> ` Y)", "by (simp add: dual_inj inj_image_subset_iff)"], ["", "lemma dual_ball: \"(\\<forall>x \\<in> X. P (\\<partial> x)) \\<longleftrightarrow> (\\<forall>y \\<in> \\<partial> ` X. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. P (\\<partial> x)) =\n    (\\<forall>y\\<in>\\<partial> ` X. P y)", "by simp"], ["", "lemma dual_inv_ball: \"(\\<forall>x \\<in> X. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<forall>y \\<in> \\<partial>\\<^sup>- ` X. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X. P (\\<partial>\\<^sup>- x)) =\n    (\\<forall>y\\<in>\\<partial>\\<^sup>- ` X. P y)", "by simp"], ["", "lemma dual_all: \"(\\<forall>x. P (\\<partial> x)) \\<longleftrightarrow> (\\<forall>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P (\\<partial> x)) = (\\<forall>y. P y)", "by (metis dual.collapse)"], ["", "lemma dual_inv_all: \"(\\<forall>x. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<forall>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P (\\<partial>\\<^sup>- x)) = (\\<forall>y. P y)", "by (metis dual_inv_surj surj_def)"], ["", "lemma dual_ex: \"(\\<exists>x. P (\\<partial> x)) \\<longleftrightarrow> (\\<exists>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P (\\<partial> x)) = (\\<exists>y. P y)", "by (metis UNIV_I bex_imageD dual_surj)"], ["", "lemma dual_inv_ex: \"(\\<exists>x. P (\\<partial>\\<^sup>- x)) \\<longleftrightarrow> (\\<exists>y. P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. P (\\<partial>\\<^sup>- x)) = (\\<exists>y. P y)", "by (metis dual.sel)"], ["", "lemma dual_Collect: \"{\\<partial> x |x. P (\\<partial> x)} = {y. P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<partial> x |x. P (\\<partial> x)} = {y. P y}", "by (metis dual.exhaust)"], ["", "lemma dual_inv_Collect: \"{\\<partial>\\<^sup>- x |x. P (\\<partial>\\<^sup>- x)} = {y. P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<partial>\\<^sup>- x |x. P (\\<partial>\\<^sup>- x)} = {y. P y}", "by (metis dual.collapse dual.inject)"], ["", "lemma fun_dual1: \"(f \\<circ> \\<partial> = g) \\<longleftrightarrow> (f = g \\<circ> \\<partial>\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<partial> = g) = (f = g \\<circ> \\<partial>\\<^sup>-)", "by auto"], ["", "lemma fun_dual2: \"(\\<partial> \\<circ> f = g) \\<longleftrightarrow> (f = \\<partial>\\<^sup>- \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial> \\<circ> f = g) = (f = \\<partial>\\<^sup>- \\<circ> g)", "by auto"], ["", "lemma fun_dual3: \"(f \\<circ> (`) \\<partial> = g) \\<longleftrightarrow> (f = g \\<circ> (`) \\<partial>\\<^sup>-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> (`) \\<partial> = g) = (f = g \\<circ> (`) \\<partial>\\<^sup>-)", "unfolding fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. f (\\<partial> ` x) = g x) =\n    (\\<forall>x. f x = g (\\<partial>\\<^sup>- ` x))", "by (metis subset_dual)"], ["", "lemma fun_dual4: \"(f = \\<partial>\\<^sup>- \\<circ> g \\<circ> (`) \\<partial>) \\<longleftrightarrow> (\\<partial> \\<circ> f \\<circ> (`) \\<partial>\\<^sup>- = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = \\<partial>\\<^sup>- \\<circ> g \\<circ> (`) \\<partial>) =\n    (\\<partial> \\<circ> f \\<circ> (`) \\<partial>\\<^sup>- = g)", "by (metis fun_dual2 fun_dual3 o_assoc)"], ["", "text \\<open>The next facts show incrementally that the dual of a complete lattice is a complete lattice.\nThis follows once again Wenzel.\\<close>"], ["", "instantiation dual :: (ord) ord\nbegin"], ["", "definition less_eq_dual_def: \"(\\<le>) = rel_dual (\\<ge>)\""], ["", "definition less_dual_def: \"(<) = rel_dual (>)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual, ord_class)", ".."], ["", "end"], ["", "lemma less_eq_dual_def_var: \"(x \\<le> y) = (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x)", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<le> y) \\<le> (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x)\n 2. (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x) \\<le> (x \\<le> y)", "apply (simp add: dual.rel_sel less_eq_dual_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<partial>\\<^sup>- y \\<le> \\<partial>\\<^sup>- x) \\<le> (x \\<le> y)", "by (simp add: dual.rel_sel less_eq_dual_def)"], ["", "lemma less_dual_def_var: \"(x < y) = (\\<partial>\\<^sup>- y < \\<partial>\\<^sup>- x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (\\<partial>\\<^sup>- y < \\<partial>\\<^sup>- x)", "by (simp add: dual.rel_sel less_dual_def)"], ["", "instance dual :: (preorder) preorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual, preorder_class)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp add: less_dual_def_var less_eq_dual_def_var less_le_not_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp add: less_eq_dual_def_var)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "by (meson less_eq_dual_def_var order_trans)"], ["", "instance dual :: (order) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual, order_class)", "by (standard, simp add: dual.expand less_eq_dual_def_var)"], ["", "lemma dual_anti: \"x \\<le> y \\<Longrightarrow> \\<partial> y \\<le> \\<partial> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> \\<partial> y \\<le> \\<partial> x", "by (simp add: dual_inj less_eq_dual_def the_inv_f_f)"], ["", "lemma dual_anti_iff: \"(x \\<le> y) = (\\<partial> y \\<le> \\<partial> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (\\<partial> y \\<le> \\<partial> x)", "by (simp add: dual_inj less_eq_dual_def the_inv_f_f)"], ["", "text \\<open>map-dual does not map isotone functions to antitone ones. It simply lifts the type!\\<close>"], ["", "lemma \"mono f \\<Longrightarrow> mono (map_dual f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (map_dual f)", "unfolding map_dual_def_var mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> f x \\<le> f y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow>\n       (\\<partial> \\<circ> f \\<circ> \\<partial>\\<^sup>-) x\n       \\<le> (\\<partial> \\<circ> f \\<circ> \\<partial>\\<^sup>-) y", "by (metis comp_apply dual_anti less_eq_dual_def_var)"], ["", "instantiation dual :: (lattice) lattice\nbegin"], ["", "definition inf_dual_def: \"x \\<sqinter> y = \\<partial> (\\<partial>\\<^sup>- x \\<squnion> \\<partial>\\<^sup>- y)\""], ["", "definition sup_dual_def: \"x \\<squnion> y = \\<partial> (\\<partial>\\<^sup>- x \\<sqinter> \\<partial>\\<^sup>- y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual, lattice_class)", "by (standard, simp_all add: dual_inj inf_dual_def sup_dual_def less_eq_dual_def_var the_inv_f_f)"], ["", "end"], ["", "instantiation dual :: (complete_lattice) complete_lattice\nbegin"], ["", "definition Inf_dual_def: \"Inf = \\<partial> \\<circ> Sup \\<circ> (`) \\<partial>\\<^sup>-\""], ["", "definition Sup_dual_def: \"Sup = \\<partial> \\<circ> Inf \\<circ> (`) \\<partial>\\<^sup>-\""], ["", "definition bot_dual_def: \"\\<bottom> = \\<partial> \\<top>\""], ["", "definition top_dual_def: \"\\<top> = \\<partial> \\<bottom>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a dual, complete_lattice_class)", "by (standard, simp_all add: Inf_dual_def top_dual_def Sup_dual_def bot_dual_def dual_inj le_INF_iff SUP_le_iff INF_lower SUP_upper less_eq_dual_def_var the_inv_f_f)"], ["", "end"], ["", "text \\<open>Next, directed and filtered sets, upsets, downsets, filters and ideals in posets are defined.\\<close>"], ["", "context ord\nbegin"], ["", "definition directed :: \"'a set \\<Rightarrow> bool\" where\n \"directed X = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. y \\<le> x))\""], ["", "definition filtered :: \"'a set \\<Rightarrow> bool\" where\n \"filtered X = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X. \\<forall>y \\<in> Y. x \\<le> y))\""], ["", "definition downset_set :: \"'a set \\<Rightarrow> 'a set\" (\"\\<Down>\") where\n  \"\\<Down>X = {y. \\<exists>x \\<in> X. y \\<le> x}\""], ["", "definition upset_set :: \"'a set \\<Rightarrow> 'a set\" (\"\\<Up>\") where\n \"\\<Up>X = {y. \\<exists>x \\<in> X. x \\<le> y}\""], ["", "end"], ["", "subsection \\<open>Examples that Do Not Dualise\\<close>"], ["", "text \\<open>Filtered and directed sets are dual.\\<close>"], ["", "text \\<open>Proofs could be simplified if dual was idempotent.\\<close>"], ["", "lemma filtered_directed_dual: \"filtered \\<circ> (`) \\<partial> = directed\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "fix X::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "have \"(filtered \\<circ> (`) \\<partial>) X = (\\<forall>Y. finite (\\<partial>\\<^sup>- ` Y) \\<and> \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X.\\<forall>y \\<in> (\\<partial>\\<^sup>- ` Y). \\<partial> x \\<le> \\<partial> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (filtered \\<circ> (`) \\<partial>) X =\n    (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> x \\<le> \\<partial> y))", "unfolding filtered_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Y.\n        finite Y \\<and> Y \\<subseteq> \\<partial> ` X \\<longrightarrow>\n        (\\<exists>x\\<in>\\<partial> ` X. Ball Y ((\\<le>) x))) =\n    (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> x \\<le> \\<partial> y))", "by (simp, metis dual_iff finite_subset_image subset_dual subset_dual1)"], ["proof (state)\nthis:\n  (filtered \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> x \\<le> \\<partial> y))\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "also"], ["proof (state)\nthis:\n  (filtered \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> x \\<le> \\<partial> y))\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "have \"... = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X.\\<forall>y \\<in> Y. y \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> x \\<le> \\<partial> y)) =\n    (\\<forall>Y.\n        finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x))", "by (metis dual_anti_iff dual_inv_surj finite_subset_image top.extremum)"], ["proof (state)\nthis:\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> x \\<le> \\<partial> y)) =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x))\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "finally"], ["proof (chain)\npicking this:\n  (filtered \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x))", "have \"(filtered \\<circ> (`) \\<partial>) X = directed X\""], ["proof (prove)\nusing this:\n  (filtered \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x))\n\ngoal (1 subgoal):\n 1. (filtered \\<circ> (`) \\<partial>) X = directed X", "using directed_def"], ["proof (prove)\nusing this:\n  (filtered \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. y \\<le> x))\n  directed ?X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> ?X \\<longrightarrow>\n      (\\<exists>x\\<in>?X. \\<forall>y\\<in>Y. y \\<le> x))\n\ngoal (1 subgoal):\n 1. (filtered \\<circ> (`) \\<partial>) X = directed X", "by auto"], ["proof (state)\nthis:\n  (filtered \\<circ> (`) \\<partial>) X = directed X\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "}"], ["proof (state)\nthis:\n  (filtered \\<circ> (`) \\<partial>) ?X2 = directed ?X2\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "thus ?thesis"], ["proof (prove)\nusing this:\n  (filtered \\<circ> (`) \\<partial>) ?X2 = directed ?X2\n\ngoal (1 subgoal):\n 1. filtered \\<circ> (`) \\<partial> = directed", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  (filtered \\<circ> (`) \\<partial>) ?X2 = directed ?X2\n\ngoal (1 subgoal):\n 1. \\<forall>x. (filtered \\<circ> (`) \\<partial>) x = directed x", "by simp"], ["proof (state)\nthis:\n  filtered \\<circ> (`) \\<partial> = directed\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma directed_filtered_dual: \"directed \\<circ> (`) \\<partial> = filtered\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "fix X::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "have \"(directed \\<circ> (`) \\<partial>) X = (\\<forall>Y. finite (\\<partial>\\<^sup>- ` Y) \\<and> \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X.\\<forall>y \\<in> (\\<partial>\\<^sup>- ` Y). \\<partial> y \\<le> \\<partial> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (directed \\<circ> (`) \\<partial>) X =\n    (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> y \\<le> \\<partial> x))", "unfolding directed_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Y.\n        finite Y \\<and> Y \\<subseteq> \\<partial> ` X \\<longrightarrow>\n        (\\<exists>x\\<in>\\<partial> ` X. \\<forall>y\\<in>Y. y \\<le> x)) =\n    (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> y \\<le> \\<partial> x))", "by (simp, metis dual_iff finite_subset_image subset_dual subset_dual1)"], ["proof (state)\nthis:\n  (directed \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> y \\<le> \\<partial> x))\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "also"], ["proof (state)\nthis:\n  (directed \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> y \\<le> \\<partial> x))\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "have \"... = (\\<forall>Y. finite Y \\<and> Y \\<subseteq> X \\<longrightarrow> (\\<exists>x \\<in> X.\\<forall>y \\<in> Y. x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n               \\<partial> y \\<le> \\<partial> x)) =\n    (\\<forall>Y.\n        finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))", "unfolding dual_anti_iff[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>Y.\n        finite (\\<partial>\\<^sup>- ` Y) \\<and>\n        \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X.\n            \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y. x \\<le> y)) =\n    (\\<forall>Y.\n        finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n        (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))", "by (metis dual_inv_surj finite_subset_image top_greatest)"], ["proof (state)\nthis:\n  (\\<forall>Y.\n      finite (\\<partial>\\<^sup>- ` Y) \\<and>\n      \\<partial>\\<^sup>- ` Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X.\n          \\<forall>y\\<in>\\<partial>\\<^sup>- ` Y.\n             \\<partial> y \\<le> \\<partial> x)) =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "finally"], ["proof (chain)\npicking this:\n  (directed \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))", "have \"(directed \\<circ> (`) \\<partial>) X = filtered X\""], ["proof (prove)\nusing this:\n  (directed \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))\n\ngoal (1 subgoal):\n 1. (directed \\<circ> (`) \\<partial>) X = filtered X", "using filtered_def"], ["proof (prove)\nusing this:\n  (directed \\<circ> (`) \\<partial>) X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> X \\<longrightarrow>\n      (\\<exists>x\\<in>X. \\<forall>y\\<in>Y. x \\<le> y))\n  filtered ?X =\n  (\\<forall>Y.\n      finite Y \\<and> Y \\<subseteq> ?X \\<longrightarrow>\n      (\\<exists>x\\<in>?X. \\<forall>y\\<in>Y. x \\<le> y))\n\ngoal (1 subgoal):\n 1. (directed \\<circ> (`) \\<partial>) X = filtered X", "by auto"], ["proof (state)\nthis:\n  (directed \\<circ> (`) \\<partial>) X = filtered X\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "}"], ["proof (state)\nthis:\n  (directed \\<circ> (`) \\<partial>) ?X2 = filtered ?X2\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "thus ?thesis"], ["proof (prove)\nusing this:\n  (directed \\<circ> (`) \\<partial>) ?X2 = filtered ?X2\n\ngoal (1 subgoal):\n 1. directed \\<circ> (`) \\<partial> = filtered", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  (directed \\<circ> (`) \\<partial>) ?X2 = filtered ?X2\n\ngoal (1 subgoal):\n 1. \\<forall>x. (directed \\<circ> (`) \\<partial>) x = filtered x", "by simp"], ["proof (state)\nthis:\n  directed \\<circ> (`) \\<partial> = filtered\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This example illustrates the deficiency of the approach. In the class-based approach the second proof is trivial.\\<close>"], ["", "text \\<open>The next example shows that this is a systematic problem.\\<close>"], ["", "lemma downset_set_upset_set_dual: \"(`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "fix X::\"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "have \"((`) \\<partial> \\<circ> \\<Down>) X = {\\<partial> y |y. \\<exists>x \\<in> X. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((`) \\<partial> \\<circ> \\<Down>) X =\n    {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x}", "by (simp add: downset_set_def setcompr_eq_image)"], ["proof (state)\nthis:\n  ((`) \\<partial> \\<circ> \\<Down>) X =\n  {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x}\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "also"], ["proof (state)\nthis:\n  ((`) \\<partial> \\<circ> \\<Down>) X =\n  {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x}\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "have \"... = {\\<partial> y |y. \\<exists>x \\<in> X. \\<partial> x \\<le> \\<partial> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x} =\n    {\\<partial> y |y. \\<exists>x\\<in>X. \\<partial> x \\<le> \\<partial> y}", "by (meson dual_anti_iff)"], ["proof (state)\nthis:\n  {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x} =\n  {\\<partial> y |y. \\<exists>x\\<in>X. \\<partial> x \\<le> \\<partial> y}\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "also"], ["proof (state)\nthis:\n  {\\<partial> y |y. \\<exists>x\\<in>X. y \\<le> x} =\n  {\\<partial> y |y. \\<exists>x\\<in>X. \\<partial> x \\<le> \\<partial> y}\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "have \"... = {y. \\<exists>x \\<in> \\<partial> ` X. x \\<le> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<partial> y |y. \\<exists>x\\<in>X. \\<partial> x \\<le> \\<partial> y} =\n    {y. \\<exists>x\\<in>\\<partial> ` X. x \\<le> y}", "by (metis (mono_tags, hide_lams) dual.exhaust image_iff)"], ["proof (state)\nthis:\n  {\\<partial> y |y. \\<exists>x\\<in>X. \\<partial> x \\<le> \\<partial> y} =\n  {y. \\<exists>x\\<in>\\<partial> ` X. x \\<le> y}\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "finally"], ["proof (chain)\npicking this:\n  ((`) \\<partial> \\<circ> \\<Down>) X =\n  {y. \\<exists>x\\<in>\\<partial> ` X. x \\<le> y}", "have \"((`) \\<partial> \\<circ> \\<Down>) X = (\\<Up> \\<circ> (`) \\<partial>) X\""], ["proof (prove)\nusing this:\n  ((`) \\<partial> \\<circ> \\<Down>) X =\n  {y. \\<exists>x\\<in>\\<partial> ` X. x \\<le> y}\n\ngoal (1 subgoal):\n 1. ((`) \\<partial> \\<circ> \\<Down>) X = (\\<Up> \\<circ> (`) \\<partial>) X", "by (simp add: upset_set_def)"], ["proof (state)\nthis:\n  ((`) \\<partial> \\<circ> \\<Down>) X = (\\<Up> \\<circ> (`) \\<partial>) X\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "}"], ["proof (state)\nthis:\n  ((`) \\<partial> \\<circ> \\<Down>) ?X2 = (\\<Up> \\<circ> (`) \\<partial>) ?X2\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((`) \\<partial> \\<circ> \\<Down>) ?X2 = (\\<Up> \\<circ> (`) \\<partial>) ?X2\n\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  ((`) \\<partial> \\<circ> \\<Down>) ?X2 = (\\<Up> \\<circ> (`) \\<partial>) ?X2\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((`) \\<partial> \\<circ> \\<Down>) x = (\\<Up> \\<circ> (`) \\<partial>) x", "by simp"], ["proof (state)\nthis:\n  (`) \\<partial> \\<circ> \\<Down> = \\<Up> \\<circ> (`) \\<partial>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upset_set_downset_set_dual: \"(`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<partial> \\<circ> \\<Up> = \\<Down> \\<circ> (`) \\<partial>", "unfolding downset_set_def upset_set_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<partial> ` {y. \\<exists>x\\<in>x. x \\<le> y} =\n       {y. Bex (\\<partial> ` x) ((\\<le>) y)}", "apply (safe, force simp: dual_anti)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       \\<lbrakk>xa \\<le> \\<partial> xc; xc \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<partial> `\n                                  {y. \\<exists>x\\<in>x. x \\<le> y}", "by (metis (mono_tags, lifting) dual.exhaust dual_anti_iff mem_Collect_eq rev_image_eqI)"], ["", "end"]]}