{"file_name": "/home/qj213/afp-2021-10-22/thys/HereditarilyFinite/Finite_Automata.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HereditarilyFinite", "problem_names": ["lemma reaches_imp_states: \"reaches fsm st xs st' \\<Longrightarrow> st \\<^bold>\\<in> states fsm \\<and> st' \\<^bold>\\<in> states fsm\"", "lemma reaches_append_iff:\n     \"reaches fsm st (xs@ys) st' \\<longleftrightarrow> (\\<exists>st''. reaches fsm st xs st'' \\<and> reaches fsm st'' ys st')\"", "theorem regular_empty:  \"regular {}\"", "theorem regular_emptystr:  \"regular {[]}\"", "theorem regular_singstr: \"regular {[a]}\"", "lemma Reverse_Reverse_ident [simp]: \"Reverse (Reverse fsm) = fsm\"", "lemma reaches_Reverse_iff [simp]:\n     \"reaches (Reverse fsm) st (rev xs) st' \\<longleftrightarrow> reaches fsm st' xs st\"", "lemma reaches_Reverse_iff2 [simp]:\n     \"reaches (Reverse fsm) st' xs st \\<longleftrightarrow> reaches fsm st (rev xs) st'\"", "lemma [simp]: \"init (Reverse fsm) = final fsm\"", "lemma [simp]: \"final (Reverse fsm) = init fsm\"", "theorem regular_rev: \"regular S \\<Longrightarrow> regular (rev ` S)\"", "lemma states_Times [simp]: \"states (Times fsm1 fsm2) = states fsm1 * states fsm2\"", "lemma init_Times [simp]: \"init (Times fsm1 fsm2) = init fsm1 * init fsm2\"", "lemma final_Times [simp]: \"final (Times fsm1 fsm2) = final fsm1 * final fsm2\"", "lemma next_Times: \"next (Times fsm1 fsm2) \\<langle>st1,st2\\<rangle> x st' \\<longleftrightarrow>\n    (\\<exists>st1' st2'. st' = \\<langle>st1',st2'\\<rangle> \\<and> next fsm1 st1 x st1' \\<and> next fsm2 st2 x st2')\"", "lemma reaches_Times_iff [simp]:\n     \"reaches (Times fsm1 fsm2) \\<langle>st1,st2\\<rangle> xs \\<langle>st1',st2'\\<rangle> \\<longleftrightarrow>\n      reaches fsm1 st1 xs st1' \\<and> reaches fsm2 st2 xs st2'\"", "lemma accepts_Times_iff [simp]:\n     \"accepts (Times fsm1 fsm2) xs \\<longleftrightarrow>\n      accepts fsm1 xs \\<and> accepts fsm2 xs\"", "theorem regular_Int:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<inter> T)\"", "lemma states_Plus [simp]: \"states (Plus fsm1 fsm2) = states fsm1 + states fsm2\"", "lemma init_Plus [simp]: \"init (Plus fsm1 fsm2) = init fsm1 + init fsm2\"", "lemma final_Plus [simp]: \"final (Plus fsm1 fsm2) = final fsm1 + final fsm2\"", "lemma next_Plus1: \"next (Plus fsm1 fsm2) (Inl st1) x st' \\<longleftrightarrow> (\\<exists>st1'. st' = Inl st1' \\<and> next fsm1 st1 x st1')\"", "lemma next_Plus2: \"next (Plus fsm1 fsm2) (Inr st2) x st' \\<longleftrightarrow> (\\<exists>st2'. st' = Inr st2' \\<and> next fsm2 st2 x st2')\"", "lemma reaches_Plus_iff1 [simp]:\n     \"reaches (Plus fsm1 fsm2) (Inl st1) xs st' \\<longleftrightarrow>\n      (\\<exists>st1'. st' = Inl st1' \\<and> reaches fsm1 st1 xs st1')\"", "lemma reaches_Plus_iff2 [simp]:\n     \"reaches (Plus fsm1 fsm2) (Inr st2) xs st' \\<longleftrightarrow>\n      (\\<exists>st2'. st' = Inr st2' \\<and> reaches fsm2 st2 xs st2')\"", "lemma reaches_Plus_iff [simp]:\n     \"reaches (Plus fsm1 fsm2) st xs st' \\<longleftrightarrow>\n      (\\<exists>st1 st1'. st = Inl st1 \\<and> st' = Inl st1' \\<and> reaches fsm1 st1 xs st1') \\<or>\n      (\\<exists>st2 st2'. st = Inr st2 \\<and> st' = Inr st2' \\<and> reaches fsm2 st2 xs st2')\"", "lemma accepts_Plus_iff [simp]:\n     \"accepts (Plus fsm1 fsm2) xs \\<longleftrightarrow> accepts fsm1 xs \\<or> accepts fsm2 xs\"", "lemma regular_Un:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<union> T)\""], "translations": [["", "lemma reaches_imp_states: \"reaches fsm st xs st' \\<Longrightarrow> st \\<^bold>\\<in> states fsm \\<and> st' \\<^bold>\\<in> states fsm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches fsm st xs st' \\<Longrightarrow>\n    st \\<^bold>\\<in> states fsm \\<and> st' \\<^bold>\\<in> states fsm", "by (induct xs arbitrary: st st', auto)"], ["", "lemma reaches_append_iff:\n     \"reaches fsm st (xs@ys) st' \\<longleftrightarrow> (\\<exists>st''. reaches fsm st xs st'' \\<and> reaches fsm st'' ys st')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches fsm st (xs @ ys) st' =\n    (\\<exists>st''. reaches fsm st xs st'' \\<and> reaches fsm st'' ys st')", "by (induct xs arbitrary: ys st st') (auto simp: reaches_imp_states)"], ["", "definition accepts :: \"'a fsm \\<Rightarrow> 'a list \\<Rightarrow> bool\"  where\n  \"accepts fsm xs \\<equiv> \\<exists>st st'. reaches fsm st xs st' \\<and> st \\<^bold>\\<in> init fsm \\<and> st' \\<^bold>\\<in> final fsm\""], ["", "definition regular :: \"'a list set \\<Rightarrow> bool\" where\n  \"regular S \\<equiv> \\<exists>fsm. S = {xs. accepts fsm xs}\""], ["", "definition Null where\n  \"Null = \\<lparr>states = 0, init = 0, final = 0, next = \\<lambda>st x st'. False\\<rparr>\""], ["", "theorem regular_empty:  \"regular {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {}", "by (auto simp: regular_def accepts_def) (metis hempty_iff simps(2))"], ["", "abbreviation NullStr where\n  \"NullStr \\<equiv> \\<lparr>states = 1, init = 1, final = 1, next = \\<lambda>st x st'. False\\<rparr>\""], ["", "theorem regular_emptystr:  \"regular {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {[]}", "apply (auto simp: regular_def accepts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fsm.\n       {[]} =\n       {xs.\n        \\<exists>st st'.\n           reaches fsm st xs st' \\<and>\n           st \\<^bold>\\<in> init fsm \\<and> st' \\<^bold>\\<in> final fsm}", "apply (rule exI [where x = NullStr], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. reaches NullStr 0 x 0 \\<Longrightarrow> x = []", "apply (case_tac x, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation SingStr where\n  \"SingStr a \\<equiv> \\<lparr>states = \\<lbrace>0, 1\\<rbrace>, init = \\<lbrace>0\\<rbrace>, final = \\<lbrace>1\\<rbrace>, next = \\<lambda>st x st'. st=0 \\<and> x=a \\<and> st'=1\\<rparr>\""], ["", "theorem regular_singstr: \"regular {[a]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular {[a]}", "apply (auto simp: regular_def accepts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fsm.\n       {[a]} =\n       {xs.\n        \\<exists>st st'.\n           reaches fsm st xs st' \\<and>\n           st \\<^bold>\\<in> init fsm \\<and> st' \\<^bold>\\<in> final fsm}", "apply (rule exI [where x = \"SingStr a\"], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. reaches (SingStr a) 0 x 1 \\<Longrightarrow> x = [a]", "apply (case_tac x, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list. reaches (SingStr a) 1 list 1 \\<Longrightarrow> list = []", "apply (case_tac list, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition Reverse where\n  \"Reverse fsm = \\<lparr>states = states fsm, init = final fsm, final = init fsm,\n                  next = \\<lambda>st x st'. next fsm st' x st\\<rparr>\""], ["", "lemma Reverse_Reverse_ident [simp]: \"Reverse (Reverse fsm) = fsm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Reverse (Reverse fsm) = fsm", "by (simp add: Reverse_def)"], ["", "lemma reaches_Reverse_iff [simp]:\n     \"reaches (Reverse fsm) st (rev xs) st' \\<longleftrightarrow> reaches fsm st' xs st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Reverse fsm) st (rev xs) st' = reaches fsm st' xs st", "by (induct xs arbitrary: st st') (auto simp add: Reverse_def reaches_append_iff reaches_imp_states)"], ["", "lemma reaches_Reverse_iff2 [simp]:\n     \"reaches (Reverse fsm) st' xs st \\<longleftrightarrow> reaches fsm st (rev xs) st'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Reverse fsm) st' xs st = reaches fsm st (rev xs) st'", "by (metis reaches_Reverse_iff rev_rev_ident)"], ["", "lemma [simp]: \"init (Reverse fsm) = final fsm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (Reverse fsm) = final fsm", "by (simp add: Reverse_def)"], ["", "lemma [simp]: \"final (Reverse fsm) = init fsm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (Reverse fsm) = init fsm", "by (simp add: Reverse_def)"], ["", "theorem regular_rev: \"regular S \\<Longrightarrow> regular (rev ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular S \\<Longrightarrow> regular (rev ` S)", "apply (auto simp: regular_def accepts_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fsm.\n       S =\n       {xs.\n        \\<exists>st st'.\n           reaches fsm st xs st' \\<and>\n           st \\<^bold>\\<in> init fsm \\<and>\n           st' \\<^bold>\\<in> final fsm} \\<Longrightarrow>\n       \\<exists>fsma.\n          rev `\n          {xs.\n           \\<exists>st st'.\n              reaches fsm st xs st' \\<and>\n              st \\<^bold>\\<in> init fsm \\<and>\n              st' \\<^bold>\\<in> final fsm} =\n          {xs.\n           \\<exists>st st'.\n              reaches fsma st xs st' \\<and>\n              st \\<^bold>\\<in> init fsma \\<and>\n              st' \\<^bold>\\<in> final fsma}", "apply (rule_tac x=\"Reverse fsm\" in exI, force+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition Times where\n  \"Times fsm1 fsm2 = \\<lparr>states = states fsm1 * states fsm2,\n                      init = init fsm1 * init fsm2,\n                      final = final fsm1 * final fsm2,\n                      next = \\<lambda>st x st'. (\\<exists>st1 st2 st1' st2'. st = \\<langle>st1,st2\\<rangle> \\<and> st' = \\<langle>st1',st2'\\<rangle> \\<and>\n                                      next fsm1 st1 x st1' \\<and> next fsm2 st2 x st2')\\<rparr>\""], ["", "lemma states_Times [simp]: \"states (Times fsm1 fsm2) = states fsm1 * states fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (Times fsm1 fsm2) = states fsm1 * states fsm2", "by (simp add: Times_def)"], ["", "lemma init_Times [simp]: \"init (Times fsm1 fsm2) = init fsm1 * init fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (Times fsm1 fsm2) = init fsm1 * init fsm2", "by (simp add: Times_def)"], ["", "lemma final_Times [simp]: \"final (Times fsm1 fsm2) = final fsm1 * final fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (Times fsm1 fsm2) = final fsm1 * final fsm2", "by (simp add: Times_def)"], ["", "lemma next_Times: \"next (Times fsm1 fsm2) \\<langle>st1,st2\\<rangle> x st' \\<longleftrightarrow>\n    (\\<exists>st1' st2'. st' = \\<langle>st1',st2'\\<rangle> \\<and> next fsm1 st1 x st1' \\<and> next fsm2 st2 x st2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next (Times fsm1 fsm2) \\<langle>st1, st2\\<rangle> x st' =\n    (\\<exists>st1' st2'.\n        st' = \\<langle>st1', st2'\\<rangle> \\<and>\n        next fsm1 st1 x st1' \\<and> next fsm2 st2 x st2')", "by (simp add: Times_def)"], ["", "lemma reaches_Times_iff [simp]:\n     \"reaches (Times fsm1 fsm2) \\<langle>st1,st2\\<rangle> xs \\<langle>st1',st2'\\<rangle> \\<longleftrightarrow>\n      reaches fsm1 st1 xs st1' \\<and> reaches fsm2 st2 xs st2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Times fsm1 fsm2) \\<langle>st1, st2\\<rangle> xs\n     \\<langle>st1', st2'\\<rangle> =\n    (reaches fsm1 st1 xs st1' \\<and> reaches fsm2 st2 xs st2')", "apply (induct xs arbitrary: st1 st2 st1' st2', force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs st1 st2 st1' st2'.\n       (\\<And>st1 st2 st1' st2'.\n           reaches (Times fsm1 fsm2) \\<langle>st1, st2\\<rangle> xs\n            \\<langle>st1', st2'\\<rangle> =\n           (reaches fsm1 st1 xs st1' \\<and>\n            reaches fsm2 st2 xs st2')) \\<Longrightarrow>\n       reaches (Times fsm1 fsm2) \\<langle>st1, st2\\<rangle> (a # xs)\n        \\<langle>st1', st2'\\<rangle> =\n       (reaches fsm1 st1 (a # xs) st1' \\<and>\n        reaches fsm2 st2 (a # xs) st2')", "apply (force simp add: next_Times Times_def reaches.Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma accepts_Times_iff [simp]:\n     \"accepts (Times fsm1 fsm2) xs \\<longleftrightarrow>\n      accepts fsm1 xs \\<and> accepts fsm2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts (Times fsm1 fsm2) xs = (accepts fsm1 xs \\<and> accepts fsm2 xs)", "by (force simp add: accepts_def)"], ["", "theorem regular_Int:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<inter> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "obtain fsmS fsmT where \"S = {xs. accepts fsmS xs}\" \"T = {xs. accepts fsmT xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsmS fsmT.\n        \\<lbrakk>S = {xs. accepts fsmS xs};\n         T = {xs. accepts fsmT xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S T"], ["proof (prove)\nusing this:\n  regular S\n  regular T\n\ngoal (1 subgoal):\n 1. (\\<And>fsmS fsmT.\n        \\<lbrakk>S = {xs. accepts fsmS xs};\n         T = {xs. accepts fsmT xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  S = {xs. accepts fsmS xs}\n  T = {xs. accepts fsmT xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "hence \"S \\<inter> T = {xs. accepts (Times fsmS fsmT) xs}\""], ["proof (prove)\nusing this:\n  S = {xs. accepts fsmS xs}\n  T = {xs. accepts fsmT xs}\n\ngoal (1 subgoal):\n 1. S \\<inter> T = {xs. accepts (Times fsmS fsmT) xs}", "by (auto simp: accepts_Times_iff [of fsmS fsmT])"], ["proof (state)\nthis:\n  S \\<inter> T = {xs. accepts (Times fsmS fsmT) xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S \\<inter> T = {xs. accepts (Times fsmS fsmT) xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<inter> T)", "by (metis regular_def)"], ["proof (state)\nthis:\n  regular (S \\<inter> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Plus where\n  \"Plus fsm1 fsm2 = \\<lparr>states = states fsm1 + states fsm2,\n                      init = init fsm1 + init fsm2,\n                      final = final fsm1 + final fsm2,\n                      next = \\<lambda>st x st'. (\\<exists>st1 st1'. st = Inl st1 \\<and> st' = Inl st1' \\<and> next fsm1 st1 x st1') \\<or>\n                                       (\\<exists>st2 st2'. st = Inr st2 \\<and> st' = Inr st2' \\<and> next fsm2 st2 x st2')\\<rparr>\""], ["", "lemma states_Plus [simp]: \"states (Plus fsm1 fsm2) = states fsm1 + states fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (Plus fsm1 fsm2) = states fsm1 + states fsm2", "by (simp add: Plus_def)"], ["", "lemma init_Plus [simp]: \"init (Plus fsm1 fsm2) = init fsm1 + init fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (Plus fsm1 fsm2) = init fsm1 + init fsm2", "by (simp add: Plus_def)"], ["", "lemma final_Plus [simp]: \"final (Plus fsm1 fsm2) = final fsm1 + final fsm2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final (Plus fsm1 fsm2) = final fsm1 + final fsm2", "by (simp add: Plus_def)"], ["", "lemma next_Plus1: \"next (Plus fsm1 fsm2) (Inl st1) x st' \\<longleftrightarrow> (\\<exists>st1'. st' = Inl st1' \\<and> next fsm1 st1 x st1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next (Plus fsm1 fsm2) (HF.Inl st1) x st' =\n    (\\<exists>st1'. st' = HF.Inl st1' \\<and> next fsm1 st1 x st1')", "by (simp add: Plus_def)"], ["", "lemma next_Plus2: \"next (Plus fsm1 fsm2) (Inr st2) x st' \\<longleftrightarrow> (\\<exists>st2'. st' = Inr st2' \\<and> next fsm2 st2 x st2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next (Plus fsm1 fsm2) (HF.Inr st2) x st' =\n    (\\<exists>st2'. st' = HF.Inr st2' \\<and> next fsm2 st2 x st2')", "by (simp add: Plus_def)"], ["", "lemma reaches_Plus_iff1 [simp]:\n     \"reaches (Plus fsm1 fsm2) (Inl st1) xs st' \\<longleftrightarrow>\n      (\\<exists>st1'. st' = Inl st1' \\<and> reaches fsm1 st1 xs st1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Plus fsm1 fsm2) (HF.Inl st1) xs st' =\n    (\\<exists>st1'. st' = HF.Inl st1' \\<and> reaches fsm1 st1 xs st1')", "apply (induct xs arbitrary: st1, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs st1.\n       (\\<And>st1.\n           reaches (Plus fsm1 fsm2) (HF.Inl st1) xs st' =\n           (\\<exists>st1'.\n               st' = HF.Inl st1' \\<and>\n               reaches fsm1 st1 xs st1')) \\<Longrightarrow>\n       reaches (Plus fsm1 fsm2) (HF.Inl st1) (a # xs) st' =\n       (\\<exists>st1'.\n           st' = HF.Inl st1' \\<and> reaches fsm1 st1 (a # xs) st1')", "apply (force simp add: next_Plus1 reaches.Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reaches_Plus_iff2 [simp]:\n     \"reaches (Plus fsm1 fsm2) (Inr st2) xs st' \\<longleftrightarrow>\n      (\\<exists>st2'. st' = Inr st2' \\<and> reaches fsm2 st2 xs st2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Plus fsm1 fsm2) (HF.Inr st2) xs st' =\n    (\\<exists>st2'. st' = HF.Inr st2' \\<and> reaches fsm2 st2 xs st2')", "apply (induct xs arbitrary: st2, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs st2.\n       (\\<And>st2.\n           reaches (Plus fsm1 fsm2) (HF.Inr st2) xs st' =\n           (\\<exists>st2'.\n               st' = HF.Inr st2' \\<and>\n               reaches fsm2 st2 xs st2')) \\<Longrightarrow>\n       reaches (Plus fsm1 fsm2) (HF.Inr st2) (a # xs) st' =\n       (\\<exists>st2'.\n           st' = HF.Inr st2' \\<and> reaches fsm2 st2 (a # xs) st2')", "apply (force simp add: next_Plus2 reaches.Cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reaches_Plus_iff [simp]:\n     \"reaches (Plus fsm1 fsm2) st xs st' \\<longleftrightarrow>\n      (\\<exists>st1 st1'. st = Inl st1 \\<and> st' = Inl st1' \\<and> reaches fsm1 st1 xs st1') \\<or>\n      (\\<exists>st2 st2'. st = Inr st2 \\<and> st' = Inr st2' \\<and> reaches fsm2 st2 xs st2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaches (Plus fsm1 fsm2) st xs st' =\n    ((\\<exists>st1 st1'.\n         st = HF.Inl st1 \\<and>\n         st' = HF.Inl st1' \\<and> reaches fsm1 st1 xs st1') \\<or>\n     (\\<exists>st2 st2'.\n         st = HF.Inr st2 \\<and>\n         st' = HF.Inr st2' \\<and> reaches fsm2 st2 xs st2'))", "apply (induct xs arbitrary: st st', auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a xs x st1 st1'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inl x) a (HF.Inl st1);\n        x \\<^bold>\\<in> states fsm1; reaches fsm1 st1 xs st1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st''.\n                            next fsm1 x a st'' \\<and>\n                            reaches fsm1 st'' xs st1'\n 2. \\<And>a xs x st2 st2'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inl x) a (HF.Inr st2);\n        x \\<^bold>\\<in> states fsm1; reaches fsm2 st2 xs st2'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a xs y st1 st1'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inr y) a (HF.Inl st1);\n        y \\<^bold>\\<in> states fsm2; reaches fsm1 st1 xs st1'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a xs y st2 st2'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inr y) a (HF.Inr st2);\n        \\<forall>st''.\n           next fsm2 y a st'' \\<longrightarrow>\n           \\<not> reaches fsm2 st'' xs st2';\n        y \\<^bold>\\<in> states fsm2; reaches fsm2 st2 xs st2'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a xs st1 st1' st''.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next fsm1 st1 a st''; reaches fsm1 st'' xs st1';\n        st1 \\<^bold>\\<in> states fsm1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st''.\n                            next (Plus fsm1 fsm2) (HF.Inl st1) a st'' \\<and>\n                            (\\<exists>st1.\n                                st'' = HF.Inl st1 \\<and>\n                                reaches fsm1 st1 xs st1')\n 6. \\<And>a xs st2 st2' st''.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next fsm2 st2 a st''; reaches fsm2 st'' xs st2';\n        st2 \\<^bold>\\<in> states fsm2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st''.\n                            next (Plus fsm1 fsm2) (HF.Inr st2) a st'' \\<and>\n                            (\\<exists>st2.\n                                st'' = HF.Inr st2 \\<and>\n                                reaches fsm2 st2 xs st2')", "apply (force simp add: next_Plus1 next_Plus2 Plus_def reaches.Cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a xs x st2 st2'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inl x) a (HF.Inr st2);\n        x \\<^bold>\\<in> states fsm1; reaches fsm2 st2 xs st2'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a xs y st1 st1'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inr y) a (HF.Inl st1);\n        y \\<^bold>\\<in> states fsm2; reaches fsm1 st1 xs st1'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a xs y st2 st2'.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next (Plus fsm1 fsm2) (HF.Inr y) a (HF.Inr st2);\n        \\<forall>st''.\n           next fsm2 y a st'' \\<longrightarrow>\n           \\<not> reaches fsm2 st'' xs st2';\n        y \\<^bold>\\<in> states fsm2; reaches fsm2 st2 xs st2'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a xs st1 st1' st''.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next fsm1 st1 a st''; reaches fsm1 st'' xs st1';\n        st1 \\<^bold>\\<in> states fsm1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st''.\n                            next (Plus fsm1 fsm2) (HF.Inl st1) a st'' \\<and>\n                            (\\<exists>st1.\n                                st'' = HF.Inl st1 \\<and>\n                                reaches fsm1 st1 xs st1')\n 5. \\<And>a xs st2 st2' st''.\n       \\<lbrakk>\\<And>st st'.\n                   reaches (Plus fsm1 fsm2) st xs st' =\n                   ((\\<exists>st1.\n                        st = HF.Inl st1 \\<and>\n                        (\\<exists>st1'.\n                            st' = HF.Inl st1' \\<and>\n                            reaches fsm1 st1 xs st1')) \\<or>\n                    (\\<exists>st2.\n                        st = HF.Inr st2 \\<and>\n                        (\\<exists>st2'.\n                            st' = HF.Inr st2' \\<and>\n                            reaches fsm2 st2 xs st2')));\n        next fsm2 st2 a st''; reaches fsm2 st'' xs st2';\n        st2 \\<^bold>\\<in> states fsm2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>st''.\n                            next (Plus fsm1 fsm2) (HF.Inr st2) a st'' \\<and>\n                            (\\<exists>st2.\n                                st'' = HF.Inr st2 \\<and>\n                                reaches fsm2 st2 xs st2')", "apply (auto simp: Plus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma accepts_Plus_iff [simp]:\n     \"accepts (Plus fsm1 fsm2) xs \\<longleftrightarrow> accepts fsm1 xs \\<or> accepts fsm2 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accepts (Plus fsm1 fsm2) xs = (accepts fsm1 xs \\<or> accepts fsm2 xs)", "by (auto simp: accepts_def) (metis sum_iff)"], ["", "lemma regular_Un:\n  assumes S: \"regular S\" and T: \"regular T\" shows \"regular (S \\<union> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "obtain fsmS fsmT where \"S = {xs. accepts fsmS xs}\" \"T = {xs. accepts fsmT xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fsmS fsmT.\n        \\<lbrakk>S = {xs. accepts fsmS xs};\n         T = {xs. accepts fsmT xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using S T"], ["proof (prove)\nusing this:\n  regular S\n  regular T\n\ngoal (1 subgoal):\n 1. (\\<And>fsmS fsmT.\n        \\<lbrakk>S = {xs. accepts fsmS xs};\n         T = {xs. accepts fsmT xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: regular_def)"], ["proof (state)\nthis:\n  S = {xs. accepts fsmS xs}\n  T = {xs. accepts fsmT xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "hence \"S \\<union> T = {xs. accepts (Plus fsmS fsmT) xs}\""], ["proof (prove)\nusing this:\n  S = {xs. accepts fsmS xs}\n  T = {xs. accepts fsmT xs}\n\ngoal (1 subgoal):\n 1. S \\<union> T = {xs. accepts (Plus fsmS fsmT) xs}", "by (auto simp: accepts_Plus_iff [of fsmS fsmT])"], ["proof (state)\nthis:\n  S \\<union> T = {xs. accepts (Plus fsmS fsmT) xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S \\<union> T = {xs. accepts (Plus fsmS fsmT) xs}\n\ngoal (1 subgoal):\n 1. regular (S \\<union> T)", "by (metis regular_def)"], ["proof (state)\nthis:\n  regular (S \\<union> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}