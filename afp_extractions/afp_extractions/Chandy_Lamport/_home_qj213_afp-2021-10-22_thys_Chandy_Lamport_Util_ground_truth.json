{"file_name": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport/Util.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport", "problem_names": ["lemma swap_neighbors_2:\n  shows\n    \"i+1 < length t \\<Longrightarrow> swap_events i (i+1) t = (t[i := t ! (i+1)])[i+1 := t ! i]\"", "lemma swap_identical_length:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"length t = length (swap_events i j t)\"", "lemma swap_identical_heads:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"take i t = take i (swap_events i j t)\"", "lemma swap_identical_tails:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"drop (j+1) t = drop (j+1) (swap_events i j t)\"", "lemma swap_neighbors:\n  shows\n    \"i+1 < length l \\<Longrightarrow> (l[i := l ! (i+1)])[i+1 := l ! i] = take i l @ [l ! (i+1), l ! i] @ drop (i+2) l\"", "lemma swap_events_perm:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"perm (swap_events i j t) t\"", "lemma sum_eq_if_same_subterms:\n  fixes\n    i :: nat\n  shows\n    \"\\<forall>k. i \\<le> k \\<and> k < j \\<longrightarrow> f k = f' k \\<Longrightarrow> sum f {i..<j} = sum f' {i..<j}\"", "lemma filter_neq_takeWhile:\n  assumes\n    \"filter ((\\<noteq>) a) l \\<noteq> takeWhile ((\\<noteq>) a) l\"\n  shows\n    \"\\<exists>i j. i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a\" (is ?P)", "lemma util_exactly_one_element:\n  assumes\n    \"m \\<notin> set l\" and\n    \"l' = l @ [m]\"\n  shows\n    \"\\<exists>!j. j < length l' \\<and> l' ! j = m\" (is ?P)", "lemma exists_one_iff_filter_one:\n  shows\n    \"(\\<exists>!j. j < length l \\<and> l ! j = a) \\<longleftrightarrow> length (filter ((=) a) l) = 1\""], "translations": [["", "lemma swap_neighbors_2:\n  shows\n    \"i+1 < length t \\<Longrightarrow> swap_events i (i+1) t = (t[i := t ! (i+1)])[i+1 := t ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 < length t \\<Longrightarrow>\n    swap_events i (i + 1) t = t[i := t ! (i + 1), i + 1 := t ! i]", "proof (induct i arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       0 + 1 < length t \\<Longrightarrow>\n       swap_events 0 (0 + 1) t = t[0 := t ! (0 + 1), 0 + 1 := t ! 0]\n 2. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "case 0"], ["proof (state)\nthis:\n  0 + 1 < length t\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       0 + 1 < length t \\<Longrightarrow>\n       swap_events 0 (0 + 1) t = t[0 := t ! (0 + 1), 0 + 1 := t ! 0]\n 2. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "then"], ["proof (chain)\npicking this:\n  0 + 1 < length t", "show ?case"], ["proof (prove)\nusing this:\n  0 + 1 < length t\n\ngoal (1 subgoal):\n 1. swap_events 0 (0 + 1) t = t[0 := t ! (0 + 1), 0 + 1 := t ! 0]", "by (metis One_nat_def Suc_eq_plus1 add_lessD1 append.left_neutral append_Cons cancel_comm_monoid_add_class.diff_cancel drop_update_cancel length_list_update numeral_One take_0 take_Cons_numeral upd_conv_take_nth_drop zero_less_Suc)"], ["proof (state)\nthis:\n  swap_events 0 (0 + 1) t = t[0 := t ! (0 + 1), 0 + 1 := t ! 0]\n\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "case (Suc n)"], ["proof (state)\nthis:\n  n + 1 < length ?t \\<Longrightarrow>\n  swap_events n (n + 1) ?t = ?t[n := ?t ! (n + 1), n + 1 := ?t ! n]\n  Suc n + 1 < length t\n\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "let ?t = \"tl t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "have \"t = hd t # ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = hd t # tl t", "by (metis Suc.prems hd_Cons_tl list.size(3) not_less_zero)"], ["proof (state)\nthis:\n  t = hd t # tl t\n\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "moreover"], ["proof (state)\nthis:\n  t = hd t # tl t\n\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "have \"swap_events n (n+1) ?t = (?t[n := ?t ! (n+1)])[n+1 := ?t ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_events n (n + 1) (tl t) = (tl t)\n    [n := tl t ! (n + 1), n + 1 := tl t ! n]", "by (metis Suc.hyps Suc.prems Suc_eq_plus1 length_tl less_diff_conv)"], ["proof (state)\nthis:\n  swap_events n (n + 1) (tl t) = (tl t)\n  [n := tl t ! (n + 1), n + 1 := tl t ! n]\n\ngoal (1 subgoal):\n 1. \\<And>i t.\n       \\<lbrakk>\\<And>t.\n                   i + 1 < length t \\<Longrightarrow>\n                   swap_events i (i + 1) t = t\n                   [i := t ! (i + 1), i + 1 := t ! i];\n        Suc i + 1 < length t\\<rbrakk>\n       \\<Longrightarrow> swap_events (Suc i) (Suc i + 1) t = t\n                         [Suc i := t ! (Suc i + 1), Suc i + 1 := t ! Suc i]", "ultimately"], ["proof (chain)\npicking this:\n  t = hd t # tl t\n  swap_events n (n + 1) (tl t) = (tl t)\n  [n := tl t ! (n + 1), n + 1 := tl t ! n]", "show ?case"], ["proof (prove)\nusing this:\n  t = hd t # tl t\n  swap_events n (n + 1) (tl t) = (tl t)\n  [n := tl t ! (n + 1), n + 1 := tl t ! n]\n\ngoal (1 subgoal):\n 1. swap_events (Suc n) (Suc n + 1) t = t\n    [Suc n := t ! (Suc n + 1), Suc n + 1 := t ! Suc n]", "by (metis Suc_eq_plus1 append_Cons diff_self_eq_0 drop_Suc_Cons list_update_code(3) nth_Cons_Suc take_Suc_Cons)"], ["proof (state)\nthis:\n  swap_events (Suc n) (Suc n + 1) t = t\n  [Suc n := t ! (Suc n + 1), Suc n + 1 := t ! Suc n]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_identical_length:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"length t = length (swap_events i j t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "have \"length (take i t @ [t ! j, t ! i] @ take (j - (i+1)) (drop (i+1) t))\n      = length (take i t) + length [t ! j, t ! i] + length (take (j - (i+1)) (drop (i+1) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n    length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t))", "by simp"], ["proof (state)\nthis:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "then"], ["proof (chain)\npicking this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))", "have \"... = j+1\""], ["proof (prove)\nusing this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n\ngoal (1 subgoal):\n 1. length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t)) =\n    j + 1", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n  i < j\n  j < length t\n\ngoal (1 subgoal):\n 1. length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t)) =\n    j + 1", "by auto"], ["proof (state)\nthis:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1\n\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "then"], ["proof (chain)\npicking this:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1\n\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "using assms(2)"], ["proof (prove)\nusing this:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1\n  j < length t\n\ngoal (1 subgoal):\n 1. length t = length (swap_events i j t)", "by auto"], ["proof (state)\nthis:\n  length t = length (swap_events i j t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_identical_heads:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"take i t = take i (swap_events i j t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i t = take i (swap_events i j t)", "using assms"], ["proof (prove)\nusing this:\n  i < j\n  j < length t\n\ngoal (1 subgoal):\n 1. take i t = take i (swap_events i j t)", "by auto"], ["", "lemma swap_identical_tails:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"drop (j+1) t = drop (j+1) (swap_events i j t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (j + 1) t = drop (j + 1) (swap_events i j t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop (j + 1) t = drop (j + 1) (swap_events i j t)", "have \"length (take i t @ [t ! j, t ! i] @ take (j - (i+1)) (drop (i+1) t))\n      = length (take i t) + length [t ! j, t ! i] + length (take (j - (i+1)) (drop (i+1) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n    length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t))", "by simp"], ["proof (state)\nthis:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n\ngoal (1 subgoal):\n 1. drop (j + 1) t = drop (j + 1) (swap_events i j t)", "then"], ["proof (chain)\npicking this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))", "have \"... = j+1\""], ["proof (prove)\nusing this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n\ngoal (1 subgoal):\n 1. length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t)) =\n    j + 1", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) =\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t))\n  i < j\n  j < length t\n\ngoal (1 subgoal):\n 1. length (take i t) + length [t ! j, t ! i] +\n    length (take (j - (i + 1)) (drop (i + 1) t)) =\n    j + 1", "by auto"], ["proof (state)\nthis:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1\n\ngoal (1 subgoal):\n 1. drop (j + 1) t = drop (j + 1) (swap_events i j t)", "then"], ["proof (chain)\npicking this:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (take i t) + length [t ! j, t ! i] +\n  length (take (j - (i + 1)) (drop (i + 1) t)) =\n  j + 1\n\ngoal (1 subgoal):\n 1. drop (j + 1) t = drop (j + 1) (swap_events i j t)", "by (metis \\<open>length (take i t @ [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t)) = length (take i t) + length [t ! j, t ! i] + length (take (j - (i + 1)) (drop (i + 1) t))\\<close> append.assoc append_eq_conv_conj)"], ["proof (state)\nthis:\n  drop (j + 1) t = drop (j + 1) (swap_events i j t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_neighbors:\n  shows\n    \"i+1 < length l \\<Longrightarrow> (l[i := l ! (i+1)])[i+1 := l ! i] = take i l @ [l ! (i+1), l ! i] @ drop (i+2) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 1 < length l \\<Longrightarrow>\n    l[i := l ! (i + 1), i + 1 := l ! i] =\n    take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l", "proof (induct i arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 + 1 < length l \\<Longrightarrow>\n       l[0 := l ! (0 + 1), 0 + 1 := l ! 0] =\n       take 0 l @ [l ! (0 + 1), l ! 0] @ drop (0 + 2) l\n 2. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "case 0"], ["proof (state)\nthis:\n  0 + 1 < length l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 + 1 < length l \\<Longrightarrow>\n       l[0 := l ! (0 + 1), 0 + 1 := l ! 0] =\n       take 0 l @ [l ! (0 + 1), l ! 0] @ drop (0 + 2) l\n 2. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "then"], ["proof (chain)\npicking this:\n  0 + 1 < length l", "show ?case"], ["proof (prove)\nusing this:\n  0 + 1 < length l\n\ngoal (1 subgoal):\n 1. l[0 := l ! (0 + 1), 0 + 1 := l ! 0] =\n    take 0 l @ [l ! (0 + 1), l ! 0] @ drop (0 + 2) l", "by (metis One_nat_def add.left_neutral add_lessD1 append_Cons append_Nil drop_update_cancel length_list_update one_add_one plus_1_eq_Suc take0 take_Suc_Cons upd_conv_take_nth_drop zero_less_two)"], ["proof (state)\nthis:\n  l[0 := l ! (0 + 1), 0 + 1 := l ! 0] =\n  take 0 l @ [l ! (0 + 1), l ! 0] @ drop (0 + 2) l\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "case (Suc n)"], ["proof (state)\nthis:\n  n + 1 < length ?l \\<Longrightarrow>\n  ?l[n := ?l ! (n + 1), n + 1 := ?l ! n] =\n  take n ?l @ [?l ! (n + 1), ?l ! n] @ drop (n + 2) ?l\n  Suc n + 1 < length l\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "let ?l = \"tl l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "have \"(l[Suc n := l ! (Suc n + 1)])[Suc n + 1 := l ! Suc n] = hd l # (?l[n := ?l ! (n+1)])[n+1 := ?l ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l[Suc n := l ! (Suc n + 1), Suc n + 1 := l ! Suc n] =\n    hd l # (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n]", "by (metis Suc.prems add.commute add_less_same_cancel2 list.collapse list.size(3) list_update_code(3) not_add_less2 nth_Cons_Suc plus_1_eq_Suc)"], ["proof (state)\nthis:\n  l[Suc n := l ! (Suc n + 1), Suc n + 1 := l ! Suc n] =\n  hd l # (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n]\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "have \"n + 1 < length ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 < length (tl l)", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc n + 1 < length l\n\ngoal (1 subgoal):\n 1. n + 1 < length (tl l)", "by auto"], ["proof (state)\nthis:\n  n + 1 < length (tl l)\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "then"], ["proof (chain)\npicking this:\n  n + 1 < length (tl l)", "have \"(?l[n := ?l ! (n+1)])[n+1 := ?l ! n] = take n ?l @ [?l ! (n+1), ?l ! n] @ drop (n+2) ?l\""], ["proof (prove)\nusing this:\n  n + 1 < length (tl l)\n\ngoal (1 subgoal):\n 1. (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n] =\n    take n (tl l) @ [tl l ! (n + 1), tl l ! n] @ drop (n + 2) (tl l)", "using Suc.hyps"], ["proof (prove)\nusing this:\n  n + 1 < length (tl l)\n  n + 1 < length ?l \\<Longrightarrow>\n  ?l[n := ?l ! (n + 1), n + 1 := ?l ! n] =\n  take n ?l @ [?l ! (n + 1), ?l ! n] @ drop (n + 2) ?l\n\ngoal (1 subgoal):\n 1. (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n] =\n    take n (tl l) @ [tl l ! (n + 1), tl l ! n] @ drop (n + 2) (tl l)", "by simp"], ["proof (state)\nthis:\n  (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n] =\n  take n (tl l) @ [tl l ! (n + 1), tl l ! n] @ drop (n + 2) (tl l)\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i + 1 < length l \\<Longrightarrow>\n                   l[i := l ! (i + 1), i + 1 := l ! i] =\n                   take i l @ [l ! (i + 1), l ! i] @ drop (i + 2) l;\n        Suc i + 1 < length l\\<rbrakk>\n       \\<Longrightarrow> l[Suc i := l ! (Suc i + 1),\n                           Suc i + 1 := l ! Suc i] =\n                         take (Suc i) l @\n                         [l ! (Suc i + 1), l ! Suc i] @ drop (Suc i + 2) l", "then"], ["proof (chain)\npicking this:\n  (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n] =\n  take n (tl l) @ [tl l ! (n + 1), tl l ! n] @ drop (n + 2) (tl l)", "show ?case"], ["proof (prove)\nusing this:\n  (tl l)[n := tl l ! (n + 1), n + 1 := tl l ! n] =\n  take n (tl l) @ [tl l ! (n + 1), tl l ! n] @ drop (n + 2) (tl l)\n\ngoal (1 subgoal):\n 1. l[Suc n := l ! (Suc n + 1), Suc n + 1 := l ! Suc n] =\n    take (Suc n) l @ [l ! (Suc n + 1), l ! Suc n] @ drop (Suc n + 2) l", "by (cases l) auto"], ["proof (state)\nthis:\n  l[Suc n := l ! (Suc n + 1), Suc n + 1 := l ! Suc n] =\n  take (Suc n) l @ [l ! (Suc n + 1), l ! Suc n] @ drop (Suc n + 2) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_events_perm:\n  assumes\n    \"i < j\" and\n    \"j < length t\"\n  shows\n    \"perm (swap_events i j t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "have swap: \"swap_events i j t\n      = take i t @ [t ! j, t ! i] @ (take (j - (i+1)) (drop (i+1) t)) @ (drop (j+1) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_events i j t = swap_events i j t", "by auto"], ["proof (state)\nthis:\n  swap_events i j t = swap_events i j t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "have reg: \"t = take i t @ (take ((j+1) - i) (drop i t)) @ drop (j+1) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = take i t @ take (j + 1 - i) (drop i t) @ drop (j + 1) t", "by (metis add_diff_inverse_nat add_lessD1 append.assoc append_take_drop_id assms(1) less_imp_add_positive less_not_refl take_add)"], ["proof (state)\nthis:\n  t = take i t @ take (j + 1 - i) (drop i t) @ drop (j + 1) t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "have \"perm (take i t) (take i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i t <~~> take i t", "by simp"], ["proof (state)\nthis:\n  take i t <~~> take i t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "moreover"], ["proof (state)\nthis:\n  take i t <~~> take i t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "have \"perm (drop (j+1) t) (drop (j+1) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (j + 1) t <~~> drop (j + 1) t", "by simp"], ["proof (state)\nthis:\n  drop (j + 1) t <~~> drop (j + 1) t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "moreover"], ["proof (state)\nthis:\n  drop (j + 1) t <~~> drop (j + 1) t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "have \"perm ([t ! j, t ! i] @ (take (j - (i+1)) (drop (i+1) t))) (take ((j+1) - i) (drop i t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "let ?l = \"take (j - (i+1)) (drop (i+1) t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "have \"take ((j+1) - i) (drop i t) = t ! i # ?l @ [t ! j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "have f1: \"Suc (j - Suc i) = j - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (j - Suc i) = j - i", "by (meson Suc_diff_Suc assms(1))"], ["proof (state)\nthis:\n  Suc (j - Suc i) = j - i\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "have f2: \"i < length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length t", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  i < j\n  j < length t\n\ngoal (1 subgoal):\n 1. i < length t", "by linarith"], ["proof (state)\nthis:\n  i < length t\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "have f3: \"j - (i + 1) + (i + 1) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - (i + 1) + (i + 1) = j", "by (meson assms(1) discrete le_add_diff_inverse2)"], ["proof (state)\nthis:\n  j - (i + 1) + (i + 1) = j\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "then"], ["proof (chain)\npicking this:\n  j - (i + 1) + (i + 1) = j", "have \"drop (j - (i + 1)) (drop (i + 1) t) = drop j t\""], ["proof (prove)\nusing this:\n  j - (i + 1) + (i + 1) = j\n\ngoal (1 subgoal):\n 1. drop (j - (i + 1)) (drop (i + 1) t) = drop j t", "by (metis drop_drop)"], ["proof (state)\nthis:\n  drop (j - (i + 1)) (drop (i + 1) t) = drop j t\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "then"], ["proof (chain)\npicking this:\n  drop (j - (i + 1)) (drop (i + 1) t) = drop j t", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (j - (i + 1)) (drop (i + 1) t) = drop j t\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "using f3 f2 f1"], ["proof (prove)\nusing this:\n  drop (j - (i + 1)) (drop (i + 1) t) = drop j t\n  j - (i + 1) + (i + 1) = j\n  i < length t\n  Suc (j - Suc i) = j - i\n\ngoal (1 subgoal):\n 1. take (j + 1 - i) (drop i t) =\n    t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "by (metis (no_types) Cons_nth_drop_Suc Suc_diff_le Suc_eq_plus1 assms(1) assms(2) hd_drop_conv_nth length_drop less_diff_conv nat_less_le take_Suc_Cons take_hd_drop)"], ["proof (state)\nthis:\n  take (j + 1 - i) (drop i t) =\n  t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  take (j + 1 - i) (drop i t) =\n  t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]\n\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "then"], ["proof (chain)\npicking this:\n  take (j + 1 - i) (drop i t) =\n  t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]", "show ?thesis"], ["proof (prove)\nusing this:\n  take (j + 1 - i) (drop i t) =\n  t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]\n\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "using mset_eq_perm"], ["proof (prove)\nusing this:\n  take (j + 1 - i) (drop i t) =\n  t ! i # take (j - (i + 1)) (drop (i + 1) t) @ [t ! j]\n  (mset ?xs = mset ?ys) = (?xs <~~> ?ys)\n\ngoal (1 subgoal):\n 1. [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n    take (j + 1 - i) (drop i t)", "by fastforce"], ["proof (state)\nthis:\n  [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n  take (j + 1 - i) (drop i t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n  take (j + 1 - i) (drop i t)\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "ultimately"], ["proof (chain)\npicking this:\n  take i t <~~> take i t\n  drop (j + 1) t <~~> drop (j + 1) t\n  [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n  take (j + 1 - i) (drop i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  take i t <~~> take i t\n  drop (j + 1) t <~~> drop (j + 1) t\n  [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n  take (j + 1 - i) (drop i t)\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "using swap reg"], ["proof (prove)\nusing this:\n  take i t <~~> take i t\n  drop (j + 1) t <~~> drop (j + 1) t\n  [t ! j, t ! i] @ take (j - (i + 1)) (drop (i + 1) t) <~~>\n  take (j + 1 - i) (drop i t)\n  swap_events i j t = swap_events i j t\n  t = take i t @ take (j + 1 - i) (drop i t) @ drop (j + 1) t\n\ngoal (1 subgoal):\n 1. swap_events i j t <~~> t", "by (metis append.assoc perm_append1 perm_append2)"], ["proof (state)\nthis:\n  swap_events i j t <~~> t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_eq_if_same_subterms:\n  fixes\n    i :: nat\n  shows\n    \"\\<forall>k. i \\<le> k \\<and> k < j \\<longrightarrow> f k = f' k \\<Longrightarrow> sum f {i..<j} = sum f' {i..<j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       i \\<le> k \\<and> k < j \\<longrightarrow> f k = f' k \\<Longrightarrow>\n    sum f {i..<j} = sum f' {i..<j}", "by auto"], ["", "lemma filter_neq_takeWhile:\n  assumes\n    \"filter ((\\<noteq>) a) l \\<noteq> takeWhile ((\\<noteq>) a) l\"\n  shows\n    \"\\<exists>i j. i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < j \\<and>\n       j < length l \\<and>\n       l ! i = a \\<and> l ! j \\<noteq> a \\<Longrightarrow>\n    False", "assume \"~ ?P\""], ["proof (state)\nthis:\n  \\<nexists>i j.\n     i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < j \\<and>\n       j < length l \\<and>\n       l ! i = a \\<and> l ! j \\<noteq> a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>i j.\n     i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a", "have asm: \"\\<forall>i j. i < j \\<and> j < length l \\<longrightarrow> l ! i \\<noteq> a \\<or> l ! j = a\" (is ?Q)"], ["proof (prove)\nusing this:\n  \\<nexists>i j.\n     i < j \\<and> j < length l \\<and> l ! i = a \\<and> l ! j \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i < j \\<and> j < length l \\<longrightarrow>\n       l ! i \\<noteq> a \\<or> l ! j = a", "by simp"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < j \\<and>\n       j < length l \\<and>\n       l ! i = a \\<and> l ! j \\<noteq> a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a", "have \"filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "proof (cases \"a : set l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n 2. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "case False"], ["proof (state)\nthis:\n  a \\<notin> set l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n 2. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "then"], ["proof (chain)\npicking this:\n  a \\<notin> set l", "have \"\\<forall>i. i < length l \\<longrightarrow> l ! i \\<noteq> a\""], ["proof (prove)\nusing this:\n  a \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<forall>i<length l. l ! i \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length l. l ! i \\<noteq> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n 2. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length l. l ! i \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length l. l ! i \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "by (metis (mono_tags, lifting) False filter_True takeWhile_eq_all_conv)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "case True"], ["proof (state)\nthis:\n  a \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "then"], ["proof (chain)\npicking this:\n  a \\<in> set l", "have ex_j: \"\\<exists>j. j < length l \\<and> l ! j = a\""], ["proof (prove)\nusing this:\n  a \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<exists>j<length l. l ! j = a", "by (simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>j<length l. l ! j = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "let ?j = \"Min {j. j < length l \\<and> l ! j = a}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "have fin_j: \"finite {j. j < length l \\<and> l ! j = a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {j. j < length l \\<and> l ! j = a}", "using finite_nat_set_iff_bounded"], ["proof (prove)\nusing this:\n  finite ?N = (\\<exists>m. \\<forall>n\\<in>?N. n < m)\n\ngoal (1 subgoal):\n 1. finite {j. j < length l \\<and> l ! j = a}", "by blast"], ["proof (state)\nthis:\n  finite {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "moreover"], ["proof (state)\nthis:\n  finite {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "have \"{j. j < length l \\<and> l ! j = a} \\<noteq> empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {j. j < length l \\<and> l ! j = a} \\<noteq> {}", "using ex_j"], ["proof (prove)\nusing this:\n  \\<exists>j<length l. l ! j = a\n\ngoal (1 subgoal):\n 1. {j. j < length l \\<and> l ! j = a} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {j. j < length l \\<and> l ! j = a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "ultimately"], ["proof (chain)\npicking this:\n  finite {j. j < length l \\<and> l ! j = a}\n  {j. j < length l \\<and> l ! j = a} \\<noteq> {}", "have \"?j < length l\""], ["proof (prove)\nusing this:\n  finite {j. j < length l \\<and> l ! j = a}\n  {j. j < length l \\<and> l ! j = a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Min {j. j < length l \\<and> l ! j = a} < length l", "using Min_less_iff"], ["proof (prove)\nusing this:\n  finite {j. j < length l \\<and> l ! j = a}\n  {j. j < length l \\<and> l ! j = a} \\<noteq> {}\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> (Min ?A < ?x) = (\\<exists>a\\<in>?A. a < ?x)\n\ngoal (1 subgoal):\n 1. Min {j. j < length l \\<and> l ! j = a} < length l", "by blast"], ["proof (state)\nthis:\n  Min {j. j < length l \\<and> l ! j = a} < length l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "have tail_all_a: \"\\<forall>j. j < length l \\<and> j \\<ge> ?j \\<longrightarrow> l ! j = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n       l ! j = a", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<Longrightarrow>\n       l ! j = a", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<Longrightarrow>\n       l ! j = a", "assume \"j < length l \\<and> j \\<ge> ?j\""], ["proof (state)\nthis:\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<Longrightarrow>\n       l ! j = a", "moreover"], ["proof (state)\nthis:\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<Longrightarrow>\n       l ! j = a", "have \"\\<lbrakk> ?Q; j < length l \\<and> j \\<ge> ?j \\<rbrakk> \\<Longrightarrow> \\<forall>k. k \\<ge> ?j \\<and> k \\<le> j \\<longrightarrow> l ! j = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k.\n                         Min {j. j < length l \\<and> l ! j = a}\n                         \\<le> k \\<and>\n                         k \\<le> j \\<longrightarrow>\n                         l ! j = a", "proof (induct \"j - ?j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 = j - Min {j. j < length l \\<and> l ! j = a};\n     \\<forall>i j.\n        i < j \\<and> j < length l \\<longrightarrow>\n        l ! i \\<noteq> a \\<or> l ! j = a;\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k.\n                         Min {j. j < length l \\<and> l ! j = a}\n                         \\<le> k \\<and>\n                         k \\<le> j \\<longrightarrow>\n                         l ! j = a\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "case 0"], ["proof (state)\nthis:\n  0 = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 = j - Min {j. j < length l \\<and> l ! j = a};\n     \\<forall>i j.\n        i < j \\<and> j < length l \\<longrightarrow>\n        l ! i \\<noteq> a \\<or> l ! j = a;\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k.\n                         Min {j. j < length l \\<and> l ! j = a}\n                         \\<le> k \\<and>\n                         k \\<le> j \\<longrightarrow>\n                         l ! j = a\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "then"], ["proof (chain)\npicking this:\n  0 = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j", "have \"j = ?j\""], ["proof (prove)\nusing this:\n  0 = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. j = Min {j. j < length l \\<and> l ! j = a}", "using 0"], ["proof (prove)\nusing this:\n  0 = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n  0 = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. j = Min {j. j < length l \\<and> l ! j = a}", "by simp"], ["proof (state)\nthis:\n  j = Min {j. j < length l \\<and> l ! j = a}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 = j - Min {j. j < length l \\<and> l ! j = a};\n     \\<forall>i j.\n        i < j \\<and> j < length l \\<longrightarrow>\n        l ! i \\<noteq> a \\<or> l ! j = a;\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n    \\<Longrightarrow> \\<forall>k.\n                         Min {j. j < length l \\<and> l ! j = a}\n                         \\<le> k \\<and>\n                         k \\<le> j \\<longrightarrow>\n                         l ! j = a\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "then"], ["proof (chain)\npicking this:\n  j = Min {j. j < length l \\<and> l ! j = a}", "show ?case"], ["proof (prove)\nusing this:\n  j = Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n       k \\<le> j \\<longrightarrow>\n       l ! j = a", "using Min_in \\<open>{j. j < length l \\<and> l ! j = a} \\<noteq> {}\\<close> fin_j"], ["proof (prove)\nusing this:\n  j = Min {j. j < length l \\<and> l ! j = a}\n  \\<lbrakk>finite ?A; ?A \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Min ?A \\<in> ?A\n  {j. j < length l \\<and> l ! j = a} \\<noteq> {}\n  finite {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n       k \\<le> j \\<longrightarrow>\n       l ! j = a", "by blast"], ["proof (state)\nthis:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = j - Min {j. j < length l \\<and> l ! j = a};\n   \\<forall>i j.\n      i < j \\<and> j < length l \\<longrightarrow>\n      l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n  Suc n = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = j - Min {j. j < length l \\<and> l ! j = a};\n   \\<forall>i j.\n      i < j \\<and> j < length l \\<longrightarrow>\n      l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n  Suc n = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j", "have \"\\<forall>k. k \\<ge> ?j \\<and> k < j \\<longrightarrow> l ! j = a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = j - Min {j. j < length l \\<and> l ! j = a};\n   \\<forall>i j.\n      i < j \\<and> j < length l \\<longrightarrow>\n      l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n  Suc n = j - Min {j. j < length l \\<and> l ! j = a}\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n       k < j \\<longrightarrow>\n       l ! j = a", "by (metis (mono_tags, lifting) Min_in \\<open>{j. j < length l \\<and> l ! j = a} \\<noteq> {}\\<close> fin_j le_eq_less_or_eq mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k < j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = j - Min {j. j < length l \\<and> l ! j = a};\n                 \\<forall>i j.\n                    i < j \\<and> j < length l \\<longrightarrow>\n                    l ! i \\<noteq> a \\<or> l ! j = a;\n                 j < length l \\<and>\n                 Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n                \\<Longrightarrow> \\<forall>k.\n                                     Min {j. j < length l \\<and> l ! j = a}\n                                     \\<le> k \\<and>\n                                     k \\<le> j \\<longrightarrow>\n                                     l ! j = a;\n        Suc x = j - Min {j. j < length l \\<and> l ! j = a};\n        \\<forall>i j.\n           i < j \\<and> j < length l \\<longrightarrow>\n           l ! i \\<noteq> a \\<or> l ! j = a;\n        j < length l \\<and>\n        Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k.\n                            Min {j. j < length l \\<and> l ! j = a}\n                            \\<le> k \\<and>\n                            k \\<le> j \\<longrightarrow>\n                            l ! j = a", "then"], ["proof (chain)\npicking this:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k < j \\<longrightarrow>\n     l ! j = a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k < j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n       k \\<le> j \\<longrightarrow>\n       l ! j = a", "using Suc.hyps(2)"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k < j \\<longrightarrow>\n     l ! j = a\n  Suc n = j - Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n       k \\<le> j \\<longrightarrow>\n       l ! j = a", "by auto"], ["proof (state)\nthis:\n  \\<forall>k.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n     k \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i j.\n              i < j \\<and> j < length l \\<longrightarrow>\n              l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < length l \\<and>\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<Longrightarrow>\n       l ! j = a", "ultimately"], ["proof (chain)\npicking this:\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n  \\<lbrakk>\\<forall>i j.\n              i < j \\<and> j < length l \\<longrightarrow>\n              l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a", "show \"l ! j = a\""], ["proof (prove)\nusing this:\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n  \\<lbrakk>\\<forall>i j.\n              i < j \\<and> j < length l \\<longrightarrow>\n              l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n\ngoal (1 subgoal):\n 1. l ! j = a", "using asm"], ["proof (prove)\nusing this:\n  j < length l \\<and> Min {j. j < length l \\<and> l ! j = a} \\<le> j\n  \\<lbrakk>\\<forall>i j.\n              i < j \\<and> j < length l \\<longrightarrow>\n              l ! i \\<noteq> a \\<or> l ! j = a;\n   j < length l \\<and>\n   Min {j. j < length l \\<and> l ! j = a} \\<le> j\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k.\n                       Min {j. j < length l \\<and> l ! j = a} \\<le> k \\<and>\n                       k \\<le> j \\<longrightarrow>\n                       l ! j = a\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n\ngoal (1 subgoal):\n 1. l ! j = a", "by blast"], ["proof (state)\nthis:\n  l ! j = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "moreover"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "have head_all_not_a: \"\\<forall>i. i < ?j \\<longrightarrow> l ! i \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a", "using asm calculation"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i < j \\<and> j < length l \\<longrightarrow>\n     l ! i \\<noteq> a \\<or> l ! j = a\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a", "by (metis (mono_tags, lifting) Min_le \\<open>Min {j. j < length l \\<and> l ! j = a} < length l\\<close> fin_j leD less_trans mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n  \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a", "have \"takeWhile ((\\<noteq>) a) l = take ?j l\""], ["proof (prove)\nusing this:\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n  \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a\n\ngoal (1 subgoal):\n 1. takeWhile ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j.\n                j < length l \\<and>\n                Min {j. j < length l \\<and> l ! j = a}\n                \\<le> j \\<longrightarrow>\n                l ! j = a;\n     \\<forall>i<Min {j. j < length l \\<and> l ! j = a}.\n        l ! i \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> takeWhile ((\\<noteq>) a) l =\n                      take (Min {j. j < length l \\<and> l ! j = a}) l", "have \"length (takeWhile ((\\<noteq>) a) l) = ?j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "have \"length (takeWhile ((\\<noteq>) a) l) \\<le> ?j\" (is ?S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l)\n    \\<le> Min {j. j < length l \\<and> l ! j = a}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (takeWhile ((\\<noteq>) a) l)\n           \\<le> Min {j. j < length l \\<and> l ! j = a} \\<Longrightarrow>\n    False", "assume \"\\<not> ?S\""], ["proof (state)\nthis:\n  \\<not> length (takeWhile ((\\<noteq>) a) l)\n         \\<le> Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<not> length (takeWhile ((\\<noteq>) a) l)\n           \\<le> Min {j. j < length l \\<and> l ! j = a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> length (takeWhile ((\\<noteq>) a) l)\n         \\<le> Min {j. j < length l \\<and> l ! j = a}", "have \"l ! ?j \\<noteq> a\""], ["proof (prove)\nusing this:\n  \\<not> length (takeWhile ((\\<noteq>) a) l)\n         \\<le> Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. l ! Min {j. j < length l \\<and> l ! j = a} \\<noteq> a", "by (metis (mono_tags, lifting) not_le_imp_less nth_mem set_takeWhileD takeWhile_nth)"], ["proof (state)\nthis:\n  l ! Min {j. j < length l \\<and> l ! j = a} \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<not> length (takeWhile ((\\<noteq>) a) l)\n           \\<le> Min {j. j < length l \\<and> l ! j = a} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  l ! Min {j. j < length l \\<and> l ! j = a} \\<noteq> a", "show False"], ["proof (prove)\nusing this:\n  l ! Min {j. j < length l \\<and> l ! j = a} \\<noteq> a\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Min {j. j < length l \\<and> l ! j = a} < length l\\<close> tail_all_a"], ["proof (prove)\nusing this:\n  l ! Min {j. j < length l \\<and> l ! j = a} \\<noteq> a\n  Min {j. j < length l \\<and> l ! j = a} < length l\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (takeWhile ((\\<noteq>) a) l)\n  \\<le> Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "moreover"], ["proof (state)\nthis:\n  length (takeWhile ((\\<noteq>) a) l)\n  \\<le> Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "have \"length (takeWhile ((\\<noteq>) a) l) \\<ge> ?j\" (is ?T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {j. j < length l \\<and> l ! j = a}\n    \\<le> length (takeWhile ((\\<noteq>) a) l)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Min {j. j < length l \\<and> l ! j = a}\n           \\<le> length (takeWhile ((\\<noteq>) a) l) \\<Longrightarrow>\n    False", "assume \"\\<not> ?T\""], ["proof (state)\nthis:\n  \\<not> Min {j. j < length l \\<and> l ! j = a}\n         \\<le> length (takeWhile ((\\<noteq>) a) l)\n\ngoal (1 subgoal):\n 1. \\<not> Min {j. j < length l \\<and> l ! j = a}\n           \\<le> length (takeWhile ((\\<noteq>) a) l) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> Min {j. j < length l \\<and> l ! j = a}\n         \\<le> length (takeWhile ((\\<noteq>) a) l)", "have \"\\<exists>j. j < ?j \\<and> l ! j = a\""], ["proof (prove)\nusing this:\n  \\<not> Min {j. j < length l \\<and> l ! j = a}\n         \\<le> length (takeWhile ((\\<noteq>) a) l)\n\ngoal (1 subgoal):\n 1. \\<exists>j<Min {j. j < length l \\<and> l ! j = a}. l ! j = a", "by (metis (mono_tags, lifting) \\<open>Min {j. j < length l \\<and> l ! j = a} < length l\\<close> calculation le_less_trans not_le_imp_less nth_length_takeWhile)"], ["proof (state)\nthis:\n  \\<exists>j<Min {j. j < length l \\<and> l ! j = a}. l ! j = a\n\ngoal (1 subgoal):\n 1. \\<not> Min {j. j < length l \\<and> l ! j = a}\n           \\<le> length (takeWhile ((\\<noteq>) a) l) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<Min {j. j < length l \\<and> l ! j = a}. l ! j = a", "show False"], ["proof (prove)\nusing this:\n  \\<exists>j<Min {j. j < length l \\<and> l ! j = a}. l ! j = a\n\ngoal (1 subgoal):\n 1. False", "using head_all_not_a"], ["proof (prove)\nusing this:\n  \\<exists>j<Min {j. j < length l \\<and> l ! j = a}. l ! j = a\n  \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Min {j. j < length l \\<and> l ! j = a}\n  \\<le> length (takeWhile ((\\<noteq>) a) l)\n\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "ultimately"], ["proof (chain)\npicking this:\n  length (takeWhile ((\\<noteq>) a) l)\n  \\<le> Min {j. j < length l \\<and> l ! j = a}\n  Min {j. j < length l \\<and> l ! j = a}\n  \\<le> length (takeWhile ((\\<noteq>) a) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (takeWhile ((\\<noteq>) a) l)\n  \\<le> Min {j. j < length l \\<and> l ! j = a}\n  Min {j. j < length l \\<and> l ! j = a}\n  \\<le> length (takeWhile ((\\<noteq>) a) l)\n\ngoal (1 subgoal):\n 1. length (takeWhile ((\\<noteq>) a) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "by simp"], ["proof (state)\nthis:\n  length (takeWhile ((\\<noteq>) a) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (takeWhile ((\\<noteq>) a) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j.\n                j < length l \\<and>\n                Min {j. j < length l \\<and> l ! j = a}\n                \\<le> j \\<longrightarrow>\n                l ! j = a;\n     \\<forall>i<Min {j. j < length l \\<and> l ! j = a}.\n        l ! i \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> takeWhile ((\\<noteq>) a) l =\n                      take (Min {j. j < length l \\<and> l ! j = a}) l", "moreover"], ["proof (state)\nthis:\n  length (takeWhile ((\\<noteq>) a) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j.\n                j < length l \\<and>\n                Min {j. j < length l \\<and> l ! j = a}\n                \\<le> j \\<longrightarrow>\n                l ! j = a;\n     \\<forall>i<Min {j. j < length l \\<and> l ! j = a}.\n        l ! i \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> takeWhile ((\\<noteq>) a) l =\n                      take (Min {j. j < length l \\<and> l ! j = a}) l", "have \"length (take ?j l) = ?j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n    Min {j. j < length l \\<and> l ! j = a}", "by (metis calculation takeWhile_eq_take)"], ["proof (state)\nthis:\n  length (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j.\n                j < length l \\<and>\n                Min {j. j < length l \\<and> l ! j = a}\n                \\<le> j \\<longrightarrow>\n                l ! j = a;\n     \\<forall>i<Min {j. j < length l \\<and> l ! j = a}.\n        l ! i \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> takeWhile ((\\<noteq>) a) l =\n                      take (Min {j. j < length l \\<and> l ! j = a}) l", "ultimately"], ["proof (chain)\npicking this:\n  length (takeWhile ((\\<noteq>) a) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n  length (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  Min {j. j < length l \\<and> l ! j = a}", "show ?thesis"], ["proof (prove)\nusing this:\n  length (takeWhile ((\\<noteq>) a) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n  length (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  Min {j. j < length l \\<and> l ! j = a}\n\ngoal (1 subgoal):\n 1. takeWhile ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "by (metis takeWhile_eq_take)"], ["proof (state)\nthis:\n  takeWhile ((\\<noteq>) a) l =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  takeWhile ((\\<noteq>) a) l =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "moreover"], ["proof (state)\nthis:\n  takeWhile ((\\<noteq>) a) l =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "have \"filter ((\\<noteq>) a) l = take ?j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "have \"filter ((\\<noteq>) a) l = filter ((\\<noteq>) a) (take ?j l) @ filter ((\\<noteq>) a) (drop ?j l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    filter ((\\<noteq>) a)\n     (take (Min {j. j < length l \\<and> l ! j = a}) l) @\n    filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l)", "by (metis append_take_drop_id filter_append)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l =\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) @\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "moreover"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l =\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) @\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "have \"filter ((\\<noteq>) a) (take ?j l) = take ?j l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "using head_all_not_a"], ["proof (prove)\nusing this:\n  \\<forall>i<Min {j. j < length l \\<and> l ! j = a}. l ! i \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "by (metis \\<open>takeWhile ((\\<noteq>) a) l = take (Min {j. j < length l \\<and> l ! j = a}) l\\<close> filter_id_conv set_takeWhileD)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "moreover"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "have \"filter ((\\<noteq>) a) (drop ?j l) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "have \"\\<forall>j. j \\<ge> ?j \\<and> j < length l \\<longrightarrow> l ! j = drop ?j l ! (j - ?j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<and>\n       j < length l \\<longrightarrow>\n       l ! j =\n       drop (Min {j. j < length l \\<and> l ! j = a}) l !\n       (j - Min {j. j < length l \\<and> l ! j = a})", "by simp"], ["proof (state)\nthis:\n  \\<forall>j.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<and>\n     j < length l \\<longrightarrow>\n     l ! j =\n     drop (Min {j. j < length l \\<and> l ! j = a}) l !\n     (j - Min {j. j < length l \\<and> l ! j = a})\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  \\<forall>j.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<and>\n     j < length l \\<longrightarrow>\n     l ! j =\n     drop (Min {j. j < length l \\<and> l ! j = a}) l !\n     (j - Min {j. j < length l \\<and> l ! j = a})", "have \"\\<forall>j. j < length l - ?j \\<longrightarrow> drop ?j l ! j = a\""], ["proof (prove)\nusing this:\n  \\<forall>j.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<and>\n     j < length l \\<longrightarrow>\n     l ! j =\n     drop (Min {j. j < length l \\<and> l ! j = a}) l !\n     (j - Min {j. j < length l \\<and> l ! j = a})\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a", "using tail_all_a"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<and>\n     j < length l \\<longrightarrow>\n     l ! j =\n     drop (Min {j. j < length l \\<and> l ! j = a}) l !\n     (j - Min {j. j < length l \\<and> l ! j = a})\n  \\<forall>j.\n     j < length l \\<and>\n     Min {j. j < length l \\<and> l ! j = a} \\<le> j \\<longrightarrow>\n     l ! j = a\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a", "by (metis (no_types, lifting) Groups.add_ac(2) \\<open>Min {j. j < length l \\<and> l ! j = a} < length l\\<close> less_diff_conv less_imp_le_nat not_add_less2 not_le nth_drop)"], ["proof (state)\nthis:\n  \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n     drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n     drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n     drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "obtain aa :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a\" where\n            \"\\<forall>x0 x1. (\\<exists>v2. v2 \\<in> set x1 \\<and> x0 v2) = (aa x0 x1 \\<in> set x1 \\<and> x0 (aa x0 x1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        \\<forall>x0 x1.\n           (\\<exists>v2. v2 \\<in> set x1 \\<and> x0 v2) =\n           (aa x0 x1 \\<in> set x1 \\<and> x0 (aa x0 x1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> set x1 \\<and> x0 v2) =\n     (aa x0 x1 \\<in> set x1 \\<and> x0 (aa x0 x1))\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> set x1 \\<and> x0 v2) =\n     (aa x0 x1 \\<in> set x1 \\<and> x0 (aa x0 x1))", "have f1: \"\\<forall>as p. aa p as \\<in> set as \\<and> p (aa p as) \\<or> filter p as = []\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1.\n     (\\<exists>v2. v2 \\<in> set x1 \\<and> x0 v2) =\n     (aa x0 x1 \\<in> set x1 \\<and> x0 (aa x0 x1))\n\ngoal (1 subgoal):\n 1. \\<forall>as p.\n       aa p as \\<in> set as \\<and> p (aa p as) \\<or> filter p as = []", "by (metis (full_types) filter_False)"], ["proof (state)\nthis:\n  \\<forall>as p.\n     aa p as \\<in> set as \\<and> p (aa p as) \\<or> filter p as = []\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "obtain nn :: \"'a list \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n            f2: \"\\<forall>x0 x1. (\\<exists>v2<length x0. x0 ! v2 = x1) = (nn x0 x1 < length x0 \\<and> x0 ! nn x0 x1 = x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nn.\n        \\<forall>x0 x1.\n           (\\<exists>v2<length x0. x0 ! v2 = x1) =\n           (nn x0 x1 < length x0 \\<and>\n            x0 ! nn x0 x1 = x1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2<length x0. x0 ! v2 = x1) =\n     (nn x0 x1 < length x0 \\<and> x0 ! nn x0 x1 = x1)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "{"], ["proof (state)\nthis:\n  \\<forall>x0 x1.\n     (\\<exists>v2<length x0. x0 ! v2 = x1) =\n     (nn x0 x1 < length x0 \\<and> x0 ! nn x0 x1 = x1)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "assume \"drop (Min {n. n < length l \\<and> l ! n = a}) l ! nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) = a\""], ["proof (state)\nthis:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a", "have \"filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) = [] \\<or> \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or> drop (Min {n. n < length l \\<and> l ! n = a}) l ! nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq> aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\""], ["proof (prove)\nusing this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n    [] \\<or>\n    \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n            (aa ((\\<noteq>) a)\n              (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n           < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n    drop (Min {n. n < length l \\<and> l ! n = a}) l !\n    nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n     (aa ((\\<noteq>) a)\n       (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n    aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "using f1"], ["proof (prove)\nusing this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a\n  \\<forall>as p.\n     aa p as \\<in> set as \\<and> p (aa p as) \\<or> filter p as = []\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n    [] \\<or>\n    \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n            (aa ((\\<noteq>) a)\n              (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n           < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n    drop (Min {n. n < length l \\<and> l ! n = a}) l !\n    nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n     (aa ((\\<noteq>) a)\n       (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n    aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "by (metis (full_types))"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "}"], ["proof (state)\nthis:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "moreover"], ["proof (state)\nthis:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "{"], ["proof (state)\nthis:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "assume \"\\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) < length l - Min {n. n < length l \\<and> l ! n = a}\""], ["proof (state)\nthis:\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l - Min {n. n < length l \\<and> l ! n = a}\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l - Min {n. n < length l \\<and> l ! n = a}", "have \"\\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or> drop (Min {n. n < length l \\<and> l ! n = a}) l ! nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq> aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\""], ["proof (prove)\nusing this:\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l - Min {n. n < length l \\<and> l ! n = a}\n\ngoal (1 subgoal):\n 1. \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n            (aa ((\\<noteq>) a)\n              (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n           < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n    drop (Min {n. n < length l \\<and> l ! n = a}) l !\n    nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n     (aa ((\\<noteq>) a)\n       (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n    aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "by simp"], ["proof (state)\nthis:\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "}"], ["proof (state)\nthis:\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l -\n           Min {n. n < length l \\<and> l ! n = a} \\<Longrightarrow>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "ultimately"], ["proof (chain)\npicking this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l -\n           Min {n. n < length l \\<and> l ! n = a} \\<Longrightarrow>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "have \"filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) = [] \\<or> \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or> drop (Min {n. n < length l \\<and> l ! n = a}) l ! nn (drop (Min {n. n < length l \\<and> l ! n = a}) l) (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq> aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\""], ["proof (prove)\nusing this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l -\n           Min {n. n < length l \\<and> l ! n = a} \\<Longrightarrow>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n    [] \\<or>\n    \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n            (aa ((\\<noteq>) a)\n              (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n           < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n    drop (Min {n. n < length l \\<and> l ! n = a}) l !\n    nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n     (aa ((\\<noteq>) a)\n       (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n    aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "using \\<open>\\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}. drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a\\<close>"], ["proof (prove)\nusing this:\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)) =\n  a \\<Longrightarrow>\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length l -\n           Min {n. n < length l \\<and> l ! n = a} \\<Longrightarrow>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n  \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n     drop (Min {j. j < length l \\<and> l ! j = a}) l ! j = a\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n    [] \\<or>\n    \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n            (aa ((\\<noteq>) a)\n              (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n           < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n    drop (Min {n. n < length l \\<and> l ! n = a}) l !\n    nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n     (aa ((\\<noteq>) a)\n       (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n    aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "by blast"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. \\<forall>j<length l - Min {j. j < length l \\<and> l ! j = a}.\n       drop (Min {j. j < length l \\<and> l ! j = a}) l ! j =\n       a \\<Longrightarrow>\n    filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "then"], ["proof (chain)\npicking this:\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "using f2 f1"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l) =\n  [] \\<or>\n  \\<not> nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n          (aa ((\\<noteq>) a)\n            (drop (Min {n. n < length l \\<and> l ! n = a}) l))\n         < length (drop (Min {n. n < length l \\<and> l ! n = a}) l) \\<or>\n  drop (Min {n. n < length l \\<and> l ! n = a}) l !\n  nn (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n   (aa ((\\<noteq>) a)\n     (drop (Min {n. n < length l \\<and> l ! n = a}) l)) \\<noteq>\n  aa ((\\<noteq>) a) (drop (Min {n. n < length l \\<and> l ! n = a}) l)\n  \\<forall>x0 x1.\n     (\\<exists>v2<length x0. x0 ! v2 = x1) =\n     (nn x0 x1 < length x0 \\<and> x0 ! nn x0 x1 = x1)\n  \\<forall>as p.\n     aa p as \\<in> set as \\<and> p (aa p as) \\<or> filter p as = []\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a)\n     (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n    []", "by (meson in_set_conv_nth)"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n  []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n  []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n  []\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "ultimately"], ["proof (chain)\npicking this:\n  filter ((\\<noteq>) a) l =\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) @\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l)\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n  []", "show ?thesis"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) a) l =\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) @\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l)\n  filter ((\\<noteq>) a) (take (Min {j. j < length l \\<and> l ! j = a}) l) =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n  filter ((\\<noteq>) a) (drop (Min {j. j < length l \\<and> l ! j = a}) l) =\n  []\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l =\n    take (Min {j. j < length l \\<and> l ! j = a}) l", "by simp"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l = take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l = take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i < j \\<and> j < length l \\<longrightarrow>\n                l ! i \\<noteq> a \\<or> l ! j = a;\n     a \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "ultimately"], ["proof (chain)\npicking this:\n  takeWhile ((\\<noteq>) a) l =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n  filter ((\\<noteq>) a) l = take (Min {j. j < length l \\<and> l ! j = a}) l", "show ?thesis"], ["proof (prove)\nusing this:\n  takeWhile ((\\<noteq>) a) l =\n  take (Min {j. j < length l \\<and> l ! j = a}) l\n  filter ((\\<noteq>) a) l = take (Min {j. j < length l \\<and> l ! j = a}) l\n\ngoal (1 subgoal):\n 1. filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "by simp"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n\ngoal (1 subgoal):\n 1. \\<nexists>i j.\n       i < j \\<and>\n       j < length l \\<and>\n       l ! i = a \\<and> l ! j \\<noteq> a \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l", "show False"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  filter ((\\<noteq>) a) l = takeWhile ((\\<noteq>) a) l\n  filter ((\\<noteq>) a) l \\<noteq> takeWhile ((\\<noteq>) a) l\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma util_exactly_one_element:\n  assumes\n    \"m \\<notin> set l\" and\n    \"l' = l @ [m]\"\n  shows\n    \"\\<exists>!j. j < length l' \\<and> l' ! j = m\" (is ?P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l' \\<and> l' ! j = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l' \\<and> l' ! j = m", "have \"\\<forall>j. j < length l' - 1 \\<longrightarrow> l' ! j \\<noteq> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<length l' - 1. l' ! j \\<noteq> m", "by (metis assms(1) assms(2) butlast_snoc length_butlast nth_append nth_mem)"], ["proof (state)\nthis:\n  \\<forall>j<length l' - 1. l' ! j \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l' \\<and> l' ! j = m", "then"], ["proof (chain)\npicking this:\n  \\<forall>j<length l' - 1. l' ! j \\<noteq> m", "have one_j: \"\\<forall>j. j < length l' \\<and> l' ! j = m \\<longrightarrow> j = (length l' - 1)\""], ["proof (prove)\nusing this:\n  \\<forall>j<length l' - 1. l' ! j \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < length l' \\<and> l' ! j = m \\<longrightarrow> j = length l' - 1", "by (metis (no_types, hide_lams) diff_Suc_1 lessE)"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < length l' \\<and> l' ! j = m \\<longrightarrow> j = length l' - 1\n\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l' \\<and> l' ! j = m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l' \\<and> l' ! j = m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>!j. j < length l' \\<and> l' ! j = m \\<Longrightarrow> False", "assume \"~ ?P\""], ["proof (state)\nthis:\n  \\<nexists>!j. j < length l' \\<and> l' ! j = m\n\ngoal (1 subgoal):\n 1. \\<nexists>!j. j < length l' \\<and> l' ! j = m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>!j. j < length l' \\<and> l' ! j = m", "obtain i j where \"i \\<noteq> j\" \"i < length l'\" \"j < length l'\"\n                          \"l' ! i = m\" \"l' ! j = m\""], ["proof (prove)\nusing this:\n  \\<nexists>!j. j < length l' \\<and> l' ! j = m\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; i < length l'; j < length l'; l' ! i = m;\n         l' ! j = m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<nexists>!j. j < length l' \\<and> l' ! j = m\n  m \\<notin> set l\n  l' = l @ [m]\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<noteq> j; i < length l'; j < length l'; l' ! i = m;\n         l' ! j = m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> j\n  i < length l'\n  j < length l'\n  l' ! i = m\n  l' ! j = m\n\ngoal (1 subgoal):\n 1. \\<nexists>!j. j < length l' \\<and> l' ! j = m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  i < length l'\n  j < length l'\n  l' ! i = m\n  l' ! j = m", "show False"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < length l'\n  j < length l'\n  l' ! i = m\n  l' ! j = m\n\ngoal (1 subgoal):\n 1. False", "using one_j"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i < length l'\n  j < length l'\n  l' ! i = m\n  l' ! j = m\n  \\<forall>j.\n     j < length l' \\<and> l' ! j = m \\<longrightarrow> j = length l' - 1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!j. j < length l' \\<and> l' ! j = m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_one_iff_filter_one:\n  shows\n    \"(\\<exists>!j. j < length l \\<and> l ! j = a) \\<longleftrightarrow> length (filter ((=) a) l) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!j. j < length l \\<and> l ! j = a) =\n    (length (filter ((=) a) l) = 1)", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "assume \"\\<exists>!j. j < length l \\<and> l ! j = a\""], ["proof (state)\nthis:\n  \\<exists>!j. j < length l \\<and> l ! j = a\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "then"], ["proof (chain)\npicking this:\n  \\<exists>!j. j < length l \\<and> l ! j = a", "obtain j where \"j < length l\" \"l ! j = a\""], ["proof (prove)\nusing this:\n  \\<exists>!j. j < length l \\<and> l ! j = a\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length l; l ! j = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length l\n  l ! j = a\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "moreover"], ["proof (state)\nthis:\n  j < length l\n  l ! j = a\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "have \"\\<forall>k. k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a", "using \\<open>\\<exists>!j. j < length l \\<and> l ! j = a\\<close> \\<open>j < length l\\<close> \\<open>l ! j = a\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>!j. j < length l \\<and> l ! j = a\n  j < length l\n  l ! j = a\n\ngoal (1 subgoal):\n 1. \\<forall>k.\n       k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a", "by blast"], ["proof (state)\nthis:\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "moreover"], ["proof (state)\nthis:\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "have \"l = take j l @ [l ! j] @ drop (j+1) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = take j l @ [l ! j] @ drop (j + 1) l", "by (metis Cons_eq_appendI Cons_nth_drop_Suc Suc_eq_plus1 append_self_conv2 append_take_drop_id calculation(1) calculation(2))"], ["proof (state)\nthis:\n  l = take j l @ [l ! j] @ drop (j + 1) l\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "moreover"], ["proof (state)\nthis:\n  l = take j l @ [l ! j] @ drop (j + 1) l\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "have \"filter ((=) a) (take j l) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((=) a) (take j l) = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((=) a) (take j l) = []", "have \"\\<forall>k. k < length (take j l) \\<longrightarrow> (take j l) ! k \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length (take j l). take j l ! k \\<noteq> a", "using calculation(3)"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (take j l). take j l ! k \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  \\<forall>k<length (take j l). take j l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((=) a) (take j l) = []", "then"], ["proof (chain)\npicking this:\n  \\<forall>k<length (take j l). take j l ! k \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k<length (take j l). take j l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((=) a) (take j l) = []", "by (metis (full_types) filter_False in_set_conv_nth)"], ["proof (state)\nthis:\n  filter ((=) a) (take j l) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((=) a) (take j l) = []\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "moreover"], ["proof (state)\nthis:\n  filter ((=) a) (take j l) = []\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "have \"filter ((=) a) (drop (j+1) l) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter ((=) a) (drop (j + 1) l) = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter ((=) a) (drop (j + 1) l) = []", "have \"\\<forall>k. k < length (drop (j+1) l) \\<longrightarrow> (drop (j+1) l) ! k \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<length (drop (j + 1) l). drop (j + 1) l ! k \\<noteq> a", "using calculation(3)"], ["proof (prove)\nusing this:\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<forall>k<length (drop (j + 1) l). drop (j + 1) l ! k \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  \\<forall>k<length (drop (j + 1) l). drop (j + 1) l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((=) a) (drop (j + 1) l) = []", "then"], ["proof (chain)\npicking this:\n  \\<forall>k<length (drop (j + 1) l). drop (j + 1) l ! k \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k<length (drop (j + 1) l). drop (j + 1) l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. filter ((=) a) (drop (j + 1) l) = []", "by (metis (full_types) filter_False in_set_conv_nth)"], ["proof (state)\nthis:\n  filter ((=) a) (drop (j + 1) l) = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((=) a) (drop (j + 1) l) = []\n\ngoal (2 subgoals):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a \\<Longrightarrow>\n    length (filter ((=) a) l) = 1\n 2. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "ultimately"], ["proof (chain)\npicking this:\n  j < length l\n  l ! j = a\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n  l = take j l @ [l ! j] @ drop (j + 1) l\n  filter ((=) a) (take j l) = []\n  filter ((=) a) (drop (j + 1) l) = []", "show \"length (filter ((=) a) l) = 1\""], ["proof (prove)\nusing this:\n  j < length l\n  l ! j = a\n  \\<forall>k.\n     k \\<noteq> j \\<and> k < length l \\<longrightarrow> l ! k \\<noteq> a\n  l = take j l @ [l ! j] @ drop (j + 1) l\n  filter ((=) a) (take j l) = []\n  filter ((=) a) (drop (j + 1) l) = []\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1", "by (metis (mono_tags, lifting) One_nat_def Suc_eq_plus1 append_Cons append_self_conv2 filter.simps(2) filter_append list.size(3) list.size(4))"], ["proof (state)\nthis:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "assume asm: \"length (filter ((=) a) l) = 1\""], ["proof (state)\nthis:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "then"], ["proof (chain)\npicking this:\n  length (filter ((=) a) l) = 1", "have \"filter ((=) a) l = [a]\""], ["proof (prove)\nusing this:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. filter ((=) a) l = [a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow> filter ((=) a) l = [a]", "let ?xs = \"filter ((=) a) l\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow> filter ((=) a) l = [a]", "have \"length ?xs = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1", "using asm"], ["proof (prove)\nusing this:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1", "by blast"], ["proof (state)\nthis:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow> filter ((=) a) l = [a]", "then"], ["proof (chain)\npicking this:\n  length (filter ((=) a) l) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. filter ((=) a) l = [a]", "by (metis (full_types) Cons_eq_filterD One_nat_def length_0_conv length_Suc_conv)"], ["proof (state)\nthis:\n  filter ((=) a) l = [a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter ((=) a) l = [a]\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "then"], ["proof (chain)\npicking this:\n  filter ((=) a) l = [a]", "have \"\\<exists>j. j < length l \\<and> l ! j = a\""], ["proof (prove)\nusing this:\n  filter ((=) a) l = [a]\n\ngoal (1 subgoal):\n 1. \\<exists>j<length l. l ! j = a", "by (metis (full_types) filter_False in_set_conv_nth list.discI)"], ["proof (state)\nthis:\n  \\<exists>j<length l. l ! j = a\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<length l. l ! j = a", "obtain j where j: \"j < length l\" \"l ! j = a\""], ["proof (prove)\nusing this:\n  \\<exists>j<length l. l ! j = a\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length l; l ! j = a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length l\n  l ! j = a\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "moreover"], ["proof (state)\nthis:\n  j < length l\n  l ! j = a\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "have \"\\<forall>k. k < length l \\<and> k \\<noteq> j \\<longrightarrow> l ! k \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k.\n       k < length l \\<and> k \\<noteq> j \\<longrightarrow> l ! k \\<noteq> a", "proof (rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length l \\<and> k \\<noteq> j \\<Longrightarrow> l ! k \\<noteq> a", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length l \\<and> k \\<noteq> j \\<Longrightarrow> l ! k \\<noteq> a", "assume assm: \"k < length l \\<and> k \\<noteq> j\""], ["proof (state)\nthis:\n  k < length l \\<and> k \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k < length l \\<and> k \\<noteq> j \\<Longrightarrow> l ! k \\<noteq> a", "show \"l ! k \\<noteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! k \\<noteq> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l ! k \\<noteq> a \\<Longrightarrow> False", "assume lka: \"\\<not> l ! k \\<noteq> a\""], ["proof (state)\nthis:\n  \\<not> l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<not> l ! k \\<noteq> a \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"k < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "let ?xs = \"take (k+1) l\""], ["proof (state)\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "let ?ys = \"drop (k+1) l\""], ["proof (state)\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  k < j\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k < j", "have \"length (filter ((=) a) ?xs) > 0\""], ["proof (prove)\nusing this:\n  k < j\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (take (k + 1) l))", "by (metis (full_types, hide_lams) add.commute assm discrete filter_empty_conv length_greater_0_conv length_take less_add_one lka min.absorb2 nth_mem nth_take)"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (take (k + 1) l))\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (take (k + 1) l))\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "have \"length (filter ((=) a) ?ys) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "have \"?ys ! (j - (k+1)) = l ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (k + 1) l ! (j - (k + 1)) = l ! j", "using True assm"], ["proof (prove)\nusing this:\n  k < j\n  k < length l \\<and> k \\<noteq> j\n\ngoal (1 subgoal):\n 1. drop (k + 1) l ! (j - (k + 1)) = l ! j", "by auto"], ["proof (state)\nthis:\n  drop (k + 1) l ! (j - (k + 1)) = l ! j\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "moreover"], ["proof (state)\nthis:\n  drop (k + 1) l ! (j - (k + 1)) = l ! j\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "have \"j - (k+1) < length ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - (k + 1) < length (drop (k + 1) l)", "using True \\<open>j < length l\\<close>"], ["proof (prove)\nusing this:\n  k < j\n  j < length l\n\ngoal (1 subgoal):\n 1. j - (k + 1) < length (drop (k + 1) l)", "by auto"], ["proof (state)\nthis:\n  j - (k + 1) < length (drop (k + 1) l)\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "ultimately"], ["proof (chain)\npicking this:\n  drop (k + 1) l ! (j - (k + 1)) = l ! j\n  j - (k + 1) < length (drop (k + 1) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (k + 1) l ! (j - (k + 1)) = l ! j\n  j - (k + 1) < length (drop (k + 1) l)\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (k + 1) l))", "by (metis (full_types) \\<open>l ! j = a\\<close> filter_empty_conv length_greater_0_conv nth_mem)"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (k + 1) l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (k + 1) l))\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (k + 1) l))\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "have \"?xs @ ?ys = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (k + 1) l @ drop (k + 1) l = l", "using append_take_drop_id"], ["proof (prove)\nusing this:\n  take ?n ?xs @ drop ?n ?xs = ?xs\n\ngoal (1 subgoal):\n 1. take (k + 1) l @ drop (k + 1) l = l", "by blast"], ["proof (state)\nthis:\n  take (k + 1) l @ drop (k + 1) l = l\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < length (filter ((=) a) (take (k + 1) l))\n  0 < length (filter ((=) a) (drop (k + 1) l))\n  take (k + 1) l @ drop (k + 1) l = l", "have \"length (filter ((=) a) l) > 1\""], ["proof (prove)\nusing this:\n  0 < length (filter ((=) a) (take (k + 1) l))\n  0 < length (filter ((=) a) (drop (k + 1) l))\n  take (k + 1) l @ drop (k + 1) l = l\n\ngoal (1 subgoal):\n 1. 1 < length (filter ((=) a) l)", "by (metis (no_types, lifting) One_nat_def Suc_eq_plus1 asm filter_append length_append less_add_eq_less less_one nat_neq_iff)"], ["proof (state)\nthis:\n  1 < length (filter ((=) a) l)\n\ngoal (2 subgoals):\n 1. k < j \\<Longrightarrow> False\n 2. \\<not> k < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  1 < length (filter ((=) a) l)", "show False"], ["proof (prove)\nusing this:\n  1 < length (filter ((=) a) l)\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  1 < length (filter ((=) a) l)\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "let ?xs = \"take (j+1) l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "let ?ys = \"drop (j+1) l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> k < j\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> k < j", "have \"length (filter ((=) a) ?xs) > 0\""], ["proof (prove)\nusing this:\n  \\<not> k < j\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (take (j + 1) l))", "by (metis (full_types, hide_lams) add.commute j discrete filter_empty_conv length_greater_0_conv length_take less_add_one min.absorb2 nth_mem nth_take)"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (take (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (take (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "have \"length (filter ((=) a) ?ys) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "have \"?ys ! (k - (j+1)) = l ! k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (j + 1) l ! (k - (j + 1)) = l ! k", "using False assm"], ["proof (prove)\nusing this:\n  \\<not> k < j\n  k < length l \\<and> k \\<noteq> j\n\ngoal (1 subgoal):\n 1. drop (j + 1) l ! (k - (j + 1)) = l ! k", "by auto"], ["proof (state)\nthis:\n  drop (j + 1) l ! (k - (j + 1)) = l ! k\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "moreover"], ["proof (state)\nthis:\n  drop (j + 1) l ! (k - (j + 1)) = l ! k\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "have \"k - (j+1) < length ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - (j + 1) < length (drop (j + 1) l)", "using False assm"], ["proof (prove)\nusing this:\n  \\<not> k < j\n  k < length l \\<and> k \\<noteq> j\n\ngoal (1 subgoal):\n 1. k - (j + 1) < length (drop (j + 1) l)", "by auto"], ["proof (state)\nthis:\n  k - (j + 1) < length (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "ultimately"], ["proof (chain)\npicking this:\n  drop (j + 1) l ! (k - (j + 1)) = l ! k\n  k - (j + 1) < length (drop (j + 1) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (j + 1) l ! (k - (j + 1)) = l ! k\n  k - (j + 1) < length (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. 0 < length (filter ((=) a) (drop (j + 1) l))", "by (metis (full_types) filter_empty_conv length_greater_0_conv lka nth_mem)"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (j + 1) l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  0 < length (filter ((=) a) (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "have \"?xs @ ?ys = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (j + 1) l @ drop (j + 1) l = l", "using append_take_drop_id"], ["proof (prove)\nusing this:\n  take ?n ?xs @ drop ?n ?xs = ?xs\n\ngoal (1 subgoal):\n 1. take (j + 1) l @ drop (j + 1) l = l", "by blast"], ["proof (state)\nthis:\n  take (j + 1) l @ drop (j + 1) l = l\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  0 < length (filter ((=) a) (take (j + 1) l))\n  0 < length (filter ((=) a) (drop (j + 1) l))\n  take (j + 1) l @ drop (j + 1) l = l", "have \"length (filter ((=) a) l) > 1\""], ["proof (prove)\nusing this:\n  0 < length (filter ((=) a) (take (j + 1) l))\n  0 < length (filter ((=) a) (drop (j + 1) l))\n  take (j + 1) l @ drop (j + 1) l = l\n\ngoal (1 subgoal):\n 1. 1 < length (filter ((=) a) l)", "by (metis (no_types, lifting) One_nat_def Suc_eq_plus1 asm filter_append length_append less_add_eq_less less_one nat_neq_iff)"], ["proof (state)\nthis:\n  1 < length (filter ((=) a) l)\n\ngoal (1 subgoal):\n 1. \\<not> k < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  1 < length (filter ((=) a) l)", "show False"], ["proof (prove)\nusing this:\n  1 < length (filter ((=) a) l)\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  1 < length (filter ((=) a) l)\n  length (filter ((=) a) l) = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l ! k \\<noteq> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k.\n     k < length l \\<and> k \\<noteq> j \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. length (filter ((=) a) l) = 1 \\<Longrightarrow>\n    \\<exists>!j. j < length l \\<and> l ! j = a", "ultimately"], ["proof (chain)\npicking this:\n  j < length l\n  l ! j = a\n  \\<forall>k.\n     k < length l \\<and> k \\<noteq> j \\<longrightarrow> l ! k \\<noteq> a", "show \"\\<exists>!j. j < length l \\<and> l ! j = a\""], ["proof (prove)\nusing this:\n  j < length l\n  l ! j = a\n  \\<forall>k.\n     k < length l \\<and> k \\<noteq> j \\<longrightarrow> l ! k \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<exists>!j. j < length l \\<and> l ! j = a", "by blast"], ["proof (state)\nthis:\n  \\<exists>!j. j < length l \\<and> l ! j = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}