{"file_name": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport/Trace.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport", "problem_names": ["lemma trace_trans:\n  shows\n    \"\\<lbrakk> trace c t c';\n       trace c' t' c''\n     \\<rbrakk> \\<Longrightarrow> trace c (t @ t') c''\"", "lemma trace_decomp_head:\n  assumes\n    \"trace c (ev # t) c'\"\n  shows\n    \"\\<exists>c''. c \\<turnstile> ev \\<mapsto> c'' \\<and> trace c'' t c'\"", "lemma trace_decomp_tail:\n  shows\n    \"trace c (t @ [ev]) c' \\<Longrightarrow> \\<exists>c''. trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\"", "lemma trace_snoc: \n  assumes\n    \"trace c t c'\" and\n    \"c' \\<turnstile> ev \\<mapsto> c''\"\n  shows\n    \"trace c (t @ [ev]) c''\"", "lemma trace_rev_induct [consumes 1, case_names tr_rev_init tr_rev_step]:\n  \"\\<lbrakk> trace c t c';\n     (\\<And>c. P c [] c);\n     (\\<And>c t c' ev c''. trace c t c' \\<Longrightarrow> P c t c' \\<Longrightarrow> c' \\<turnstile> ev \\<mapsto> c'' \\<Longrightarrow> P c (t @ [ev]) c'')\n   \\<rbrakk> \\<Longrightarrow> P c t c'\"", "lemma trace_and_start_determines_end:\n  shows\n    \"trace c t c' \\<Longrightarrow> trace c t d' \\<Longrightarrow> c' = d'\"", "lemma suffix_split_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       suffix t' t\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\"", "lemma prefix_split_trace:\n  fixes\n    c :: \"('p, 's, 'm) configuration\" and\n    t :: \"('p, 's, 'm) trace\"\n  shows\n    \"\\<lbrakk> \\<exists>c'. trace c t c';\n       prefix t' t\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c t' c''\"", "lemma split_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       t = t' @ t''\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c t' c'' \\<and> trace c'' t'' c'\"", "lemma fun_must_admit_trace:\n  shows\n    \"single_valued R \\<Longrightarrow> x \\<in> Domain R\n     \\<Longrightarrow> (x, construct_fun_from_rel R x) \\<in> R\"", "lemma single_valued_trace_rel:\n  shows\n    \"single_valued trace_rel\"", "lemma s_is_partial_execution:\n  shows\n    \"s c t i = run_trace (c, take i t)\"", "lemma exists_trace_for_any_i:\n  assumes\n    \"\\<exists>c'. trace c t c'\"\n  shows\n    \"trace c (take i t) (s c t i)\"", "lemma exists_trace_for_any_i_j:\n  assumes\n    \"\\<exists>c'. trace c t c'\" and\n    \"i \\<le> j\"\n  shows\n    \"trace (s c t i) (take (j - i) (drop i t)) (s c t j)\"", "lemma step_Suc:\n  assumes\n    \"i < length t\" and\n    valid: \"trace c t c'\"\n  shows \"(s c t i) \\<turnstile> (t ! i) \\<mapsto> (s c t (Suc i))\"", "lemma snapshot_state_unchanged_trace:\n  assumes\n    \"trace c t c'\" and\n    \"ps c p = Some u\"\n  shows\n    \"ps c' p = Some u\"", "lemma no_state_change_if_only_nonregular_events:\n  shows\n    \"\\<lbrakk> trace c t c';\n       \\<nexists>ev. ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p;\n       states c p = st\n     \\<rbrakk> \\<Longrightarrow> states c' p = st\"", "lemma message_must_be_delivered_2_trace:\n  assumes\n    \"trace c t c'\" and\n    \"m : set (msgs c i)\" and\n    \"m \\<notin> set (msgs c' i)\" and\n    \"channel i = Some (q, p)\"\n  shows\n    \"\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or> (\\<exists>p q s s' m'. ev = Recv i q p s s' m' \\<and> m = Msg m')\"", "lemma marker_must_be_delivered_2_trace:\n  assumes\n    \"trace c t c'\" and\n    \"Marker : set (msgs c i)\" and\n    \"Marker \\<notin> set (msgs c' i)\" and\n    \"channel i = Some (p, q)\"\n  shows\n    \"\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q)\"", "lemma snapshot_stable:\n  shows\n    \"\\<lbrakk> trace c t c';\n       has_snapshotted c p\n     \\<rbrakk> \\<Longrightarrow> has_snapshotted c' p\"", "lemma snapshot_stable_2:\n  shows\n    \"trace c t c' \\<Longrightarrow> ~ has_snapshotted c' p \\<Longrightarrow> ~ has_snapshotted c p\"", "lemma no_markers_if_all_snapshotted:\n  shows\n    \"\\<lbrakk> trace c t c';\n      \\<forall>p. has_snapshotted c p;\n      Marker \\<notin> set (msgs c i)\n     \\<rbrakk> \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\"", "lemma event_stays_valid_if_no_occurrence_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n       can_occur ev' c\n     \\<rbrakk> \\<Longrightarrow> can_occur ev' c'\"", "lemma event_can_go_back_if_no_sender_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n       can_occur ev' c';\n       ~ isRecvMarker ev';\n       list_all (\\<lambda>ev. ~ isSend ev) t\n     \\<rbrakk> \\<Longrightarrow> can_occur ev' c\"", "lemma done_only_from_recv_marker_trace:\n  assumes\n    \"trace c t c'\" and\n    \"t \\<noteq> []\" and\n    \"snd (cs c cid) \\<noteq> Done\" and\n    \"snd (cs c' cid) = Done\" and\n    \"channel cid = Some (p, q)\"\n  shows\n    \"RecvMarker cid q p \\<in> set t\"", "lemma cs_not_not_started_stable_trace:\n  shows\n    \"\\<lbrakk> trace c t c'; snd (cs c cid) \\<noteq> NotStarted; channel cid = Some (p, q) \\<rbrakk> \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted\"", "lemma no_messages_introduced_if_no_channel:\n  assumes\n    trace: \"trace init t final\" and\n    no_msgs_if_no_channel: \"\\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\"\n  shows\n    \"channel cid = None \\<Longrightarrow> msgs (s init t i) cid = []\""], "translations": [["", "lemma trace_trans:\n  shows\n    \"\\<lbrakk> trace c t c';\n       trace c' t' c''\n     \\<rbrakk> \\<Longrightarrow> trace c (t @ t') c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; trace c' t' c''\\<rbrakk>\n    \\<Longrightarrow> trace c (t @ t') c''", "proof (induct c t c' rule:trace.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c. trace c t' c'' \\<Longrightarrow> trace c ([] @ t') c''\n 2. \\<And>c ev c' t c''a.\n       \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; trace c' t c''a;\n        trace c''a t' c'' \\<Longrightarrow> trace c' (t @ t') c'';\n        trace c''a t' c''\\<rbrakk>\n       \\<Longrightarrow> trace c ((ev # t) @ t') c''", "case tr_init"], ["proof (state)\nthis:\n  trace c_ t' c''\n\ngoal (2 subgoals):\n 1. \\<And>c. trace c t' c'' \\<Longrightarrow> trace c ([] @ t') c''\n 2. \\<And>c ev c' t c''a.\n       \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; trace c' t c''a;\n        trace c''a t' c'' \\<Longrightarrow> trace c' (t @ t') c'';\n        trace c''a t' c''\\<rbrakk>\n       \\<Longrightarrow> trace c ((ev # t) @ t') c''", "then"], ["proof (chain)\npicking this:\n  trace c_ t' c''", "show ?case"], ["proof (prove)\nusing this:\n  trace c_ t' c''\n\ngoal (1 subgoal):\n 1. trace c_ ([] @ t') c''", "by simp"], ["proof (state)\nthis:\n  trace c_ ([] @ t') c''\n\ngoal (1 subgoal):\n 1. \\<And>c ev c' t c''a.\n       \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; trace c' t c''a;\n        trace c''a t' c'' \\<Longrightarrow> trace c' (t @ t') c'';\n        trace c''a t' c''\\<rbrakk>\n       \\<Longrightarrow> trace c ((ev # t) @ t') c''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c ev c' t c''a.\n       \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; trace c' t c''a;\n        trace c''a t' c'' \\<Longrightarrow> trace c' (t @ t') c'';\n        trace c''a t' c''\\<rbrakk>\n       \\<Longrightarrow> trace c ((ev # t) @ t') c''", "case tr_step"], ["proof (state)\nthis:\n  c_ \\<turnstile> ev_ \\<mapsto> c'_\n  trace c'_ t_ c''_\n  trace c''_ t' c'' \\<Longrightarrow> trace c'_ (t_ @ t') c''\n  trace c''_ t' c''\n\ngoal (1 subgoal):\n 1. \\<And>c ev c' t c''a.\n       \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; trace c' t c''a;\n        trace c''a t' c'' \\<Longrightarrow> trace c' (t @ t') c'';\n        trace c''a t' c''\\<rbrakk>\n       \\<Longrightarrow> trace c ((ev # t) @ t') c''", "then"], ["proof (chain)\npicking this:\n  c_ \\<turnstile> ev_ \\<mapsto> c'_\n  trace c'_ t_ c''_\n  trace c''_ t' c'' \\<Longrightarrow> trace c'_ (t_ @ t') c''\n  trace c''_ t' c''", "show ?case"], ["proof (prove)\nusing this:\n  c_ \\<turnstile> ev_ \\<mapsto> c'_\n  trace c'_ t_ c''_\n  trace c''_ t' c'' \\<Longrightarrow> trace c'_ (t_ @ t') c''\n  trace c''_ t' c''\n\ngoal (1 subgoal):\n 1. trace c_ ((ev_ # t_) @ t') c''", "using trace.tr_step"], ["proof (prove)\nusing this:\n  c_ \\<turnstile> ev_ \\<mapsto> c'_\n  trace c'_ t_ c''_\n  trace c''_ t' c'' \\<Longrightarrow> trace c'_ (t_ @ t') c''\n  trace c''_ t' c''\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; trace ?c' ?t ?c''\\<rbrakk>\n  \\<Longrightarrow> trace ?c (?ev # ?t) ?c''\n\ngoal (1 subgoal):\n 1. trace c_ ((ev_ # t_) @ t') c''", "by auto"], ["proof (state)\nthis:\n  trace c_ ((ev_ # t_) @ t') c''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_decomp_head:\n  assumes\n    \"trace c (ev # t) c'\"\n  shows\n    \"\\<exists>c''. c \\<turnstile> ev \\<mapsto> c'' \\<and> trace c'' t c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c''. c \\<turnstile> ev \\<mapsto> c'' \\<and> trace c'' t c'", "using assms trace.simps"], ["proof (prove)\nusing this:\n  trace c (ev # t) c'\n  trace ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>c. ?a1.0 = c \\<and> ?a2.0 = [] \\<and> ?a3.0 = c) \\<or>\n   (\\<exists>c ev c' t c''.\n       ?a1.0 = c \\<and>\n       ?a2.0 = ev # t \\<and>\n       ?a3.0 = c'' \\<and>\n       c \\<turnstile> ev \\<mapsto> c' \\<and> trace c' t c''))\n\ngoal (1 subgoal):\n 1. \\<exists>c''. c \\<turnstile> ev \\<mapsto> c'' \\<and> trace c'' t c'", "by blast"], ["", "lemma trace_decomp_tail:\n  shows\n    \"trace c (t @ [ev]) c' \\<Longrightarrow> \\<exists>c''. trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace c (t @ [ev]) c' \\<Longrightarrow>\n    \\<exists>c''. trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'", "proof (induct t arbitrary: c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       trace c ([] @ [ev]) c' \\<Longrightarrow>\n       \\<exists>c''. trace c [] c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "case Nil"], ["proof (state)\nthis:\n  trace c ([] @ [ev]) c'\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       trace c ([] @ [ev]) c' \\<Longrightarrow>\n       \\<exists>c''. trace c [] c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "then"], ["proof (chain)\npicking this:\n  trace c ([] @ [ev]) c'", "show ?case"], ["proof (prove)\nusing this:\n  trace c ([] @ [ev]) c'\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c [] c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'", "by (metis (mono_tags, lifting) append_Nil distributed_system.trace.simps distributed_system_axioms list.discI list.sel(1) list.sel(3))"], ["proof (state)\nthis:\n  \\<exists>c''. trace c [] c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "case (Cons ev' t)"], ["proof (state)\nthis:\n  trace ?c5 (t @ [ev]) c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c5 t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n  trace c ((ev' # t) @ [ev]) c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "then"], ["proof (chain)\npicking this:\n  trace ?c5 (t @ [ev]) c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c5 t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n  trace c ((ev' # t) @ [ev]) c'", "obtain d where step: \"c \\<turnstile> ev' \\<mapsto> d\" and \"trace d (t @ [ev]) c'\""], ["proof (prove)\nusing this:\n  trace ?c5 (t @ [ev]) c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c5 t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n  trace c ((ev' # t) @ [ev]) c'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c \\<turnstile> ev' \\<mapsto> d;\n         trace d (t @ [ev]) c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trace_decomp_head"], ["proof (prove)\nusing this:\n  trace ?c5 (t @ [ev]) c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c5 t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n  trace c ((ev' # t) @ [ev]) c'\n  trace ?c (?ev # ?t) ?c' \\<Longrightarrow>\n  \\<exists>c''. ?c \\<turnstile> ?ev \\<mapsto> c'' \\<and> trace c'' ?t ?c'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>c \\<turnstile> ev' \\<mapsto> d;\n         trace d (t @ [ev]) c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  c \\<turnstile> ev' \\<mapsto> d\n  trace d (t @ [ev]) c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "then"], ["proof (chain)\npicking this:\n  c \\<turnstile> ev' \\<mapsto> d\n  trace d (t @ [ev]) c'", "obtain d' where tr: \"trace d t d'\" and \"d' \\<turnstile> ev \\<mapsto> c'\""], ["proof (prove)\nusing this:\n  c \\<turnstile> ev' \\<mapsto> d\n  trace d (t @ [ev]) c'\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>trace d t d'; d' \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.hyps"], ["proof (prove)\nusing this:\n  c \\<turnstile> ev' \\<mapsto> d\n  trace d (t @ [ev]) c'\n  trace ?c5 (t @ [ev]) c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c5 t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        \\<lbrakk>trace d t d'; d' \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace d t d'\n  d' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "moreover"], ["proof (state)\nthis:\n  trace d t d'\n  d' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "have \"trace c (ev' # t) d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace c (ev' # t) d'", "using step tr trace.tr_step"], ["proof (prove)\nusing this:\n  c \\<turnstile> ev' \\<mapsto> d\n  trace d t d'\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; trace ?c' ?t ?c''\\<rbrakk>\n  \\<Longrightarrow> trace ?c (?ev # ?t) ?c''\n\ngoal (1 subgoal):\n 1. trace c (ev' # t) d'", "by simp"], ["proof (state)\nthis:\n  trace c (ev' # t) d'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   trace c (t @ [ev]) c' \\<Longrightarrow>\n                   \\<exists>c''.\n                      trace c t c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c';\n        trace c ((a # t) @ [ev]) c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c (a # t) c'' \\<and>\n                            c'' \\<turnstile> ev \\<mapsto> c'", "ultimately"], ["proof (chain)\npicking this:\n  trace d t d'\n  d' \\<turnstile> ev \\<mapsto> c'\n  trace c (ev' # t) d'", "show ?case"], ["proof (prove)\nusing this:\n  trace d t d'\n  d' \\<turnstile> ev \\<mapsto> c'\n  trace c (ev' # t) d'\n\ngoal (1 subgoal):\n 1. \\<exists>c''.\n       trace c (ev' # t) c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'", "by auto"], ["proof (state)\nthis:\n  \\<exists>c''.\n     trace c (ev' # t) c'' \\<and> c'' \\<turnstile> ev \\<mapsto> c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_snoc: \n  assumes\n    \"trace c t c'\" and\n    \"c' \\<turnstile> ev \\<mapsto> c''\"\n  shows\n    \"trace c (t @ [ev]) c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace c (t @ [ev]) c''", "using assms(1) assms(2) tr_init tr_step trace_trans"], ["proof (prove)\nusing this:\n  trace c t c'\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace ?c [] ?c\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; trace ?c' ?t ?c''\\<rbrakk>\n  \\<Longrightarrow> trace ?c (?ev # ?t) ?c''\n  \\<lbrakk>trace ?c ?t ?c'; trace ?c' ?t' ?c''\\<rbrakk>\n  \\<Longrightarrow> trace ?c (?t @ ?t') ?c''\n\ngoal (1 subgoal):\n 1. trace c (t @ [ev]) c''", "by auto"], ["", "lemma trace_rev_induct [consumes 1, case_names tr_rev_init tr_rev_step]:\n  \"\\<lbrakk> trace c t c';\n     (\\<And>c. P c [] c);\n     (\\<And>c t c' ev c''. trace c t c' \\<Longrightarrow> P c t c' \\<Longrightarrow> c' \\<turnstile> ev \\<mapsto> c'' \\<Longrightarrow> P c (t @ [ev]) c'')\n   \\<rbrakk> \\<Longrightarrow> P c t c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; \\<And>c. P c [] c;\n     \\<And>c t c' ev c''.\n        \\<lbrakk>trace c t c'; P c t c';\n         c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n        \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n    \\<Longrightarrow> P c t c'", "proof (induct t arbitrary: c' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c [] c'\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "case Nil"], ["proof (state)\nthis:\n  trace c [] c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c [] c'\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "then"], ["proof (chain)\npicking this:\n  trace c [] c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5", "show ?case"], ["proof (prove)\nusing this:\n  trace c [] c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n\ngoal (1 subgoal):\n 1. P c [] c'", "using distributed_system.trace.cases distributed_system_axioms"], ["proof (prove)\nusing this:\n  trace c [] c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n  \\<lbrakk>distributed_system ?channel;\n   distributed_system.trace ?channel ?trans ?send ?recv ?a1.0 ?a2.0 ?a3.0;\n   \\<And>c.\n      \\<lbrakk>?a1.0 = c; ?a2.0 = []; ?a3.0 = c\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>c ev c' t c''.\n      \\<lbrakk>?a1.0 = c; ?a2.0 = ev # t; ?a3.0 = c'';\n       distributed_system.next ?channel ?trans ?send ?recv c ev c';\n       distributed_system.trace ?channel ?trans ?send ?recv c' t\n        c''\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  distributed_system channel\n\ngoal (1 subgoal):\n 1. P c [] c'", "by blast"], ["proof (state)\nthis:\n  P c [] c'\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "case (snoc ev t)"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t ?c'5; \\<And>c. P c [] c;\n   \\<And>c t c' ev c''.\n      \\<lbrakk>trace c t c'; P c t c';\n       c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n      \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n  \\<Longrightarrow> P c t ?c'5\n  trace c (t @ [ev]) c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>trace c t ?c'5; \\<And>c. P c [] c;\n   \\<And>c t c' ev c''.\n      \\<lbrakk>trace c t c'; P c t c';\n       c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n      \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n  \\<Longrightarrow> P c t ?c'5\n  trace c (t @ [ev]) c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5", "obtain c'' where \"trace c t c''\" \"c'' \\<turnstile> ev \\<mapsto> c'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; \\<And>c. P c [] c;\n   \\<And>c t c' ev c''.\n      \\<lbrakk>trace c t c'; P c t c';\n       c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n      \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n  \\<Longrightarrow> P c t ?c'5\n  trace c (t @ [ev]) c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        \\<lbrakk>trace c t c''; c'' \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trace_decomp_tail"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; \\<And>c. P c [] c;\n   \\<And>c t c' ev c''.\n      \\<lbrakk>trace c t c'; P c t c';\n       c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n      \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n  \\<Longrightarrow> P c t ?c'5\n  trace c (t @ [ev]) c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        \\<lbrakk>trace c t c''; c'' \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace c t c''\n  c'' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c'; \\<And>c. P c [] c;\n                    \\<And>c t c' ev c''.\n                       \\<lbrakk>trace c t c'; P c t c';\n                        c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n                       \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n                   \\<Longrightarrow> P c xs c';\n        trace c (xs @ [x]) c'; \\<And>c. P c [] c;\n        \\<And>c t c' ev c''.\n           \\<lbrakk>trace c t c'; P c t c';\n            c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n           \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n       \\<Longrightarrow> P c (xs @ [x]) c'", "then"], ["proof (chain)\npicking this:\n  trace c t c''\n  c'' \\<turnstile> ev \\<mapsto> c'", "show ?case"], ["proof (prove)\nusing this:\n  trace c t c''\n  c'' \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. P c (t @ [ev]) c'", "using snoc"], ["proof (prove)\nusing this:\n  trace c t c''\n  c'' \\<turnstile> ev \\<mapsto> c'\n  \\<lbrakk>trace c t ?c'5; \\<And>c. P c [] c;\n   \\<And>c t c' ev c''.\n      \\<lbrakk>trace c t c'; P c t c';\n       c' \\<turnstile> ev \\<mapsto> c''\\<rbrakk>\n      \\<Longrightarrow> P c (t @ [ev]) c''\\<rbrakk>\n  \\<Longrightarrow> P c t ?c'5\n  trace c (t @ [ev]) c'\n  P ?c5 [] ?c5\n  \\<lbrakk>trace ?c5 ?t5 ?c'5; P ?c5 ?t5 ?c'5;\n   ?c'5 \\<turnstile> ?ev5 \\<mapsto> ?c''5\\<rbrakk>\n  \\<Longrightarrow> P ?c5 (?t5 @ [?ev5]) ?c''5\n\ngoal (1 subgoal):\n 1. P c (t @ [ev]) c'", "by simp"], ["proof (state)\nthis:\n  P c (t @ [ev]) c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_and_start_determines_end:\n  shows\n    \"trace c t c' \\<Longrightarrow> trace c t d' \\<Longrightarrow> c' = d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; trace c t d'\\<rbrakk> \\<Longrightarrow> c' = d'", "proof (induct c t c' arbitrary: d' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c d'. trace c [] d' \\<Longrightarrow> c = d'\n 2. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "case tr_rev_init"], ["proof (state)\nthis:\n  trace c_ [] d'\n\ngoal (2 subgoals):\n 1. \\<And>c d'. trace c [] d' \\<Longrightarrow> c = d'\n 2. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "then"], ["proof (chain)\npicking this:\n  trace c_ [] d'", "show ?case"], ["proof (prove)\nusing this:\n  trace c_ [] d'\n\ngoal (1 subgoal):\n 1. c_ = d'", "using trace.cases"], ["proof (prove)\nusing this:\n  trace c_ [] d'\n  \\<lbrakk>trace ?a1.0 ?a2.0 ?a3.0;\n   \\<And>c.\n      \\<lbrakk>?a1.0 = c; ?a2.0 = []; ?a3.0 = c\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>c ev c' t c''.\n      \\<lbrakk>?a1.0 = c; ?a2.0 = ev # t; ?a3.0 = c'';\n       c \\<turnstile> ev \\<mapsto> c'; trace c' t c''\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. c_ = d'", "by fastforce"], ["proof (state)\nthis:\n  c_ = d'\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "case (tr_rev_step c t c' ev c'')"], ["proof (state)\nthis:\n  trace c t c'\n  trace c t ?d'5 \\<Longrightarrow> c' = ?d'5\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace c (t @ [ev]) d'\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "then"], ["proof (chain)\npicking this:\n  trace c t c'\n  trace c t ?d'5 \\<Longrightarrow> c' = ?d'5\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace c (t @ [ev]) d'", "obtain d'' where \"trace c t d''\" \"d'' \\<turnstile> ev \\<mapsto> d'\""], ["proof (prove)\nusing this:\n  trace c t c'\n  trace c t ?d'5 \\<Longrightarrow> c' = ?d'5\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace c (t @ [ev]) d'\n\ngoal (1 subgoal):\n 1. (\\<And>d''.\n        \\<lbrakk>trace c t d''; d'' \\<turnstile> ev \\<mapsto> d'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trace_decomp_tail"], ["proof (prove)\nusing this:\n  trace c t c'\n  trace c t ?d'5 \\<Longrightarrow> c' = ?d'5\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace c (t @ [ev]) d'\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n\ngoal (1 subgoal):\n 1. (\\<And>d''.\n        \\<lbrakk>trace c t d''; d'' \\<turnstile> ev \\<mapsto> d'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace c t d''\n  d'' \\<turnstile> ev \\<mapsto> d'\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c'' d'.\n       \\<lbrakk>trace c t c';\n        \\<And>d'. trace c t d' \\<Longrightarrow> c' = d';\n        c' \\<turnstile> ev \\<mapsto> c''; trace c (t @ [ev]) d'\\<rbrakk>\n       \\<Longrightarrow> c'' = d'", "then"], ["proof (chain)\npicking this:\n  trace c t d''\n  d'' \\<turnstile> ev \\<mapsto> d'", "show ?case"], ["proof (prove)\nusing this:\n  trace c t d''\n  d'' \\<turnstile> ev \\<mapsto> d'\n\ngoal (1 subgoal):\n 1. c'' = d'", "using tr_rev_step state_and_event_determine_next"], ["proof (prove)\nusing this:\n  trace c t d''\n  d'' \\<turnstile> ev \\<mapsto> d'\n  trace c t c'\n  trace c t ?d'5 \\<Longrightarrow> c' = ?d'5\n  c' \\<turnstile> ev \\<mapsto> c''\n  trace c (t @ [ev]) d'\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   ?c \\<turnstile> ?ev \\<mapsto> ?c''\\<rbrakk>\n  \\<Longrightarrow> ?c' = ?c''\n\ngoal (1 subgoal):\n 1. c'' = d'", "by simp"], ["proof (state)\nthis:\n  c'' = d'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma suffix_split_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       suffix t' t\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "proof (induct t arbitrary: c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>trace c [] c'; suffix t' []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "case Nil"], ["proof (state)\nthis:\n  trace c [] c'\n  suffix t' []\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>trace c [] c'; suffix t' []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "then"], ["proof (chain)\npicking this:\n  trace c [] c'\n  suffix t' []", "have \"t' = []\""], ["proof (prove)\nusing this:\n  trace c [] c'\n  suffix t' []\n\ngoal (1 subgoal):\n 1. t' = []", "by simp"], ["proof (state)\nthis:\n  t' = []\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>trace c [] c'; suffix t' []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "then"], ["proof (chain)\npicking this:\n  t' = []", "have \"trace c' t' c'\""], ["proof (prove)\nusing this:\n  t' = []\n\ngoal (1 subgoal):\n 1. trace c' t' c'", "using tr_init"], ["proof (prove)\nusing this:\n  t' = []\n  trace ?c [] ?c\n\ngoal (1 subgoal):\n 1. trace c' t' c'", "by simp"], ["proof (state)\nthis:\n  trace c' t' c'\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>trace c [] c'; suffix t' []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "then"], ["proof (chain)\npicking this:\n  trace c' t' c'", "show ?case"], ["proof (prove)\nusing this:\n  trace c' t' c'\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>c''. trace c'' t' c'\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "case (Cons ev t'')"], ["proof (state)\nthis:\n  \\<lbrakk>trace ?c5 t'' c'; suffix t' t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n  trace c (ev # t'') c'\n  suffix t' (ev # t'')\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "from Cons.prems"], ["proof (chain)\npicking this:\n  trace c (ev # t'') c'\n  suffix t' (ev # t'')", "have q: \"suffix t' t'' \\<or> t' = ev # t''\""], ["proof (prove)\nusing this:\n  trace c (ev # t'') c'\n  suffix t' (ev # t'')\n\ngoal (1 subgoal):\n 1. suffix t' t'' \\<or> t' = ev # t''", "by (meson suffix_Cons)"], ["proof (state)\nthis:\n  suffix t' t'' \\<or> t' = ev # t''\n\ngoal (1 subgoal):\n 1. \\<And>a t c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>trace c t c'; suffix t' t\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''. trace c'' t' c';\n        trace c (a # t) c'; suffix t' (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "thus ?case"], ["proof (prove)\nusing this:\n  suffix t' t'' \\<or> t' = ev # t''\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "proof (cases \"suffix t' t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t''; suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "case True"], ["proof (state)\nthis:\n  suffix t' t''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t''; suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n 2. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "then"], ["proof (chain)\npicking this:\n  suffix t' t''", "show ?thesis"], ["proof (prove)\nusing this:\n  suffix t' t''\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "using Cons.hyps Cons.prems(1) trace.simps"], ["proof (prove)\nusing this:\n  suffix t' t''\n  \\<lbrakk>trace ?c5 t'' c'; suffix t' t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n  trace c (ev # t'') c'\n  trace ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>c. ?a1.0 = c \\<and> ?a2.0 = [] \\<and> ?a3.0 = c) \\<or>\n   (\\<exists>c ev c' t c''.\n       ?a1.0 = c \\<and>\n       ?a2.0 = ev # t \\<and>\n       ?a3.0 = c'' \\<and>\n       c \\<turnstile> ev \\<mapsto> c' \\<and> trace c' t c''))\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>c''. trace c'' t' c'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "case False"], ["proof (state)\nthis:\n  \\<not> suffix t' t''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "hence \"t' = ev # t''\""], ["proof (prove)\nusing this:\n  \\<not> suffix t' t''\n\ngoal (1 subgoal):\n 1. t' = ev # t''", "using q"], ["proof (prove)\nusing this:\n  \\<not> suffix t' t''\n  suffix t' t'' \\<or> t' = ev # t''\n\ngoal (1 subgoal):\n 1. t' = ev # t''", "by simp"], ["proof (state)\nthis:\n  t' = ev # t''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>suffix t' t'' \\<or> t' = ev # t'';\n     \\<not> suffix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c'' t' c'", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' = ev # t''\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "using Cons.hyps Cons.prems"], ["proof (prove)\nusing this:\n  t' = ev # t''\n  \\<lbrakk>trace ?c5 t'' c'; suffix t' t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace c'' t' c'\n  trace c (ev # t'') c'\n  suffix t' (ev # t'')\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c'' t' c'", "by blast"], ["proof (state)\nthis:\n  \\<exists>c''. trace c'' t' c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>c''. trace c'' t' c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefix_split_trace:\n  fixes\n    c :: \"('p, 's, 'm) configuration\" and\n    t :: \"('p, 's, 'm) trace\"\n  shows\n    \"\\<lbrakk> \\<exists>c'. trace c t c';\n       prefix t' t\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c t' c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c'. trace c t c'; prefix t' t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c t' c''", "proof (induct t rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Ex (trace c []); prefix t' []\\<rbrakk>\n    \\<Longrightarrow> Ex (trace c t')\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "case Nil"], ["proof (state)\nthis:\n  \\<exists>a. trace c [] a\n  prefix t' []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Ex (trace c []); prefix t' []\\<rbrakk>\n    \\<Longrightarrow> Ex (trace c t')\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. trace c [] a\n  prefix t' []", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>a. trace c [] a\n  prefix t' []\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a. trace c t' a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "case (snoc ev t'')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>a. trace c t'' a; prefix t' t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. trace c t' a\n  \\<exists>a. trace c (t'' @ [ev]) a\n  prefix t' (t'' @ [ev])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "from snoc.prems"], ["proof (chain)\npicking this:\n  \\<exists>a. trace c (t'' @ [ev]) a\n  prefix t' (t'' @ [ev])", "have q: \"prefix t' t'' \\<or> t' = t'' @ [ev]\""], ["proof (prove)\nusing this:\n  \\<exists>a. trace c (t'' @ [ev]) a\n  prefix t' (t'' @ [ev])\n\ngoal (1 subgoal):\n 1. prefix t' t'' \\<or> t' = t'' @ [ev]", "by auto"], ["proof (state)\nthis:\n  prefix t' t'' \\<or> t' = t'' @ [ev]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>Ex (trace c xs); prefix t' xs\\<rbrakk>\n                \\<Longrightarrow> Ex (trace c t');\n        Ex (trace c (xs @ [x])); prefix t' (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Ex (trace c t')", "thus ?case"], ["proof (prove)\nusing this:\n  prefix t' t'' \\<or> t' = t'' @ [ev]\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "proof (cases \"prefix t' t''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev]; prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a\n 2. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev];\n     \\<not> prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a", "case True"], ["proof (state)\nthis:\n  prefix t' t''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev]; prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a\n 2. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev];\n     \\<not> prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a", "thus ?thesis"], ["proof (prove)\nusing this:\n  prefix t' t''\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "using trace_decomp_tail"], ["proof (prove)\nusing this:\n  prefix t' t''\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "using snoc.hyps snoc.prems(1) trace.simps"], ["proof (prove)\nusing this:\n  prefix t' t''\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n  \\<lbrakk>\\<exists>a. trace c t'' a; prefix t' t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. trace c t' a\n  \\<exists>a. trace c (t'' @ [ev]) a\n  trace ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>c. ?a1.0 = c \\<and> ?a2.0 = [] \\<and> ?a3.0 = c) \\<or>\n   (\\<exists>c ev c' t c''.\n       ?a1.0 = c \\<and>\n       ?a2.0 = ev # t \\<and>\n       ?a3.0 = c'' \\<and>\n       c \\<turnstile> ev \\<mapsto> c' \\<and> trace c' t c''))\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. trace c t' a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev];\n     \\<not> prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev];\n     \\<not> prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a", "case False"], ["proof (state)\nthis:\n  \\<not> prefix t' t''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix t' t'' \\<or> t' = t'' @ [ev];\n     \\<not> prefix t' t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. trace c t' a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prefix t' t''\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "using q snoc.prems"], ["proof (prove)\nusing this:\n  \\<not> prefix t' t''\n  prefix t' t'' \\<or> t' = t'' @ [ev]\n  \\<exists>a. trace c (t'' @ [ev]) a\n  prefix t' (t'' @ [ev])\n\ngoal (1 subgoal):\n 1. \\<exists>a. trace c t' a", "by fast"], ["proof (state)\nthis:\n  \\<exists>a. trace c t' a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. trace c t' a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       t = t' @ t''\n     \\<rbrakk> \\<Longrightarrow> \\<exists>c''. trace c t' c'' \\<and> trace c'' t'' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c''. trace c t' c'' \\<and> trace c'' t'' c'", "proof (induct t'' arbitrary: t')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>trace c t c'; t = t' @ []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c t' c'' \\<and> trace c'' [] c'\n 2. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "case Nil"], ["proof (state)\nthis:\n  trace c t c'\n  t = t' @ []\n\ngoal (2 subgoals):\n 1. \\<And>t'.\n       \\<lbrakk>trace c t c'; t = t' @ []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''. trace c t' c'' \\<and> trace c'' [] c'\n 2. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "then"], ["proof (chain)\npicking this:\n  trace c t c'\n  t = t' @ []", "show ?case"], ["proof (prove)\nusing this:\n  trace c t c'\n  t = t' @ []\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c t' c'' \\<and> trace c'' [] c'", "using tr_init"], ["proof (prove)\nusing this:\n  trace c t c'\n  t = t' @ []\n  trace ?c [] ?c\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c t' c'' \\<and> trace c'' [] c'", "by auto"], ["proof (state)\nthis:\n  \\<exists>c''. trace c t' c'' \\<and> trace c'' [] c'\n\ngoal (1 subgoal):\n 1. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "case (Cons ev t'')"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t c'; t = ?t'5 @ t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace c ?t'5 c'' \\<and> trace c'' t'' c'\n  trace c t c'\n  t = t' @ ev # t''\n\ngoal (1 subgoal):\n 1. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "obtain c'' where p: \"trace c (t' @ [ev]) c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        trace c (t' @ [ev]) c'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems prefix_split_trace rotate1.simps(2)"], ["proof (prove)\nusing this:\n  trace c t c'\n  t = t' @ ev # t''\n  \\<lbrakk>\\<exists>c'. trace ?c ?t c'; prefix ?t' ?t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace ?c ?t' c''\n  rotate1 (?x # ?xs) = ?xs @ [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        trace c (t' @ [ev]) c'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  trace c (t' @ [ev]) c''\n\ngoal (1 subgoal):\n 1. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "then"], ["proof (chain)\npicking this:\n  trace c (t' @ [ev]) c''", "have \"trace c'' t'' c'\""], ["proof (prove)\nusing this:\n  trace c (t' @ [ev]) c''\n\ngoal (1 subgoal):\n 1. trace c'' t'' c'", "using Cons.hyps Cons.prems trace_and_start_determines_end"], ["proof (prove)\nusing this:\n  trace c (t' @ [ev]) c''\n  \\<lbrakk>trace c t c'; t = ?t'5 @ t''\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace c ?t'5 c'' \\<and> trace c'' t'' c'\n  trace c t c'\n  t = t' @ ev # t''\n  \\<lbrakk>trace ?c ?t ?c'; trace ?c ?t ?d'\\<rbrakk>\n  \\<Longrightarrow> ?c' = ?d'\n\ngoal (1 subgoal):\n 1. trace c'' t'' c'", "by force"], ["proof (state)\nthis:\n  trace c'' t'' c'\n\ngoal (1 subgoal):\n 1. \\<And>a t'' t'.\n       \\<lbrakk>\\<And>t'.\n                   \\<lbrakk>trace c t c'; t = t' @ t''\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>c''.\n  trace c t' c'' \\<and> trace c'' t'' c';\n        trace c t c'; t = t' @ a # t''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c''.\n                            trace c t' c'' \\<and> trace c'' (a # t'') c'", "then"], ["proof (chain)\npicking this:\n  trace c'' t'' c'", "show ?case"], ["proof (prove)\nusing this:\n  trace c'' t'' c'\n\ngoal (1 subgoal):\n 1. \\<exists>c''. trace c t' c'' \\<and> trace c'' (ev # t'') c'", "by (meson distributed_system.tr_step distributed_system.trace_decomp_tail distributed_system_axioms p)"], ["proof (state)\nthis:\n  \\<exists>c''. trace c t' c'' \\<and> trace c'' (ev # t'') c'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Describing intermediate configurations\\<close>"], ["", "definition construct_fun_from_rel :: \"('a * 'b) set \\<Rightarrow> 'a \\<Rightarrow> 'b\" where\n  \"construct_fun_from_rel R x = (THE y. (x,y) \\<in> R)\""], ["", "definition trace_rel where\n  \"trace_rel \\<equiv> {((x, t'), y). trace x t' y}\""], ["", "lemma fun_must_admit_trace:\n  shows\n    \"single_valued R \\<Longrightarrow> x \\<in> Domain R\n     \\<Longrightarrow> (x, construct_fun_from_rel R x) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; x \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (x, construct_fun_from_rel R x) \\<in> R", "unfolding construct_fun_from_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; x \\<in> Domain R\\<rbrakk>\n    \\<Longrightarrow> (x, THE y. (x, y) \\<in> R) \\<in> R", "by (rule theI') (auto simp add: single_valued_def)"], ["", "lemma single_valued_trace_rel:\n  shows\n    \"single_valued trace_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued trace_rel", "proof (rule single_valuedI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> trace_rel; (x, z) \\<in> trace_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> trace_rel; (x, z) \\<in> trace_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume asm: \"(x, y) \\<in> trace_rel\" \"(x, y') \\<in> trace_rel\""], ["proof (state)\nthis:\n  (x, y) \\<in> trace_rel\n  (x, y') \\<in> trace_rel\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> trace_rel; (x, z) \\<in> trace_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> trace_rel\n  (x, y') \\<in> trace_rel", "obtain x' t where \"x = (x', t)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> trace_rel\n  (x, y') \\<in> trace_rel\n\ngoal (1 subgoal):\n 1. (\\<And>x' t. x = (x', t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  x = (x', t)\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> trace_rel; (x, z) \\<in> trace_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  x = (x', t)", "have \"trace x' t y\" \"trace x' t y'\""], ["proof (prove)\nusing this:\n  x = (x', t)\n\ngoal (1 subgoal):\n 1. trace x' t y &&& trace x' t y'", "using asm trace_rel_def"], ["proof (prove)\nusing this:\n  x = (x', t)\n  (x, y) \\<in> trace_rel\n  (x, y') \\<in> trace_rel\n  trace_rel \\<equiv> Collect (case_prod (\\<lambda>(x, y). trace x y))\n\ngoal (1 subgoal):\n 1. trace x' t y &&& trace x' t y'", "by auto"], ["proof (state)\nthis:\n  trace x' t y\n  trace x' t y'\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> trace_rel; (x, z) \\<in> trace_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  trace x' t y\n  trace x' t y'", "show \"y = y'\""], ["proof (prove)\nusing this:\n  trace x' t y\n  trace x' t y'\n\ngoal (1 subgoal):\n 1. y = y'", "using trace_and_start_determines_end"], ["proof (prove)\nusing this:\n  trace x' t y\n  trace x' t y'\n  \\<lbrakk>trace ?c ?t ?c'; trace ?c ?t ?d'\\<rbrakk>\n  \\<Longrightarrow> ?c' = ?d'\n\ngoal (1 subgoal):\n 1. y = y'", "by blast"], ["proof (state)\nthis:\n  y = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition run_trace where\n  \"run_trace \\<equiv> construct_fun_from_rel trace_rel\""], ["", "text \\<open>In order to describe intermediate configurations\nof a trace we introduce the $s$ function definition, which,\ngiven an initial configuration $c$, a trace $t$ and an index $i \\in \\mathbb{N}$,\ndetermines the unique state after the first $i$ events of $t$.\\<close>"], ["", "definition s where\n  \"s c t i = (THE c'. trace c (take i t) c')\""], ["", "lemma s_is_partial_execution:\n  shows\n    \"s c t i = run_trace (c, take i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s c t i = run_trace (c, take i t)", "unfolding s_def run_trace_def\n            construct_fun_from_rel_def trace_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. The (trace c (take i t)) =\n    (THE y.\n        ((c, take i t), y)\n        \\<in> Collect (case_prod (\\<lambda>(x, y). trace x y)))", "by auto"], ["", "lemma exists_trace_for_any_i:\n  assumes\n    \"\\<exists>c'. trace c t c'\"\n  shows\n    \"trace c (take i t) (s c t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "have \"prefix (take i t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take i t) t", "using take_is_prefix"], ["proof (prove)\nusing this:\n  prefix (take ?n ?xs) ?xs\n\ngoal (1 subgoal):\n 1. prefix (take i t) t", "by auto"], ["proof (state)\nthis:\n  prefix (take i t) t\n\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "then"], ["proof (chain)\npicking this:\n  prefix (take i t) t", "obtain c'' where tr: \"trace c (take i t) c''\""], ["proof (prove)\nusing this:\n  prefix (take i t) t\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        trace c (take i t) c'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms prefix_split_trace"], ["proof (prove)\nusing this:\n  prefix (take i t) t\n  \\<exists>c'. trace c t c'\n  \\<lbrakk>\\<exists>c'. trace ?c ?t c'; prefix ?t' ?t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c''. trace ?c ?t' c''\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        trace c (take i t) c'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace c (take i t) c''\n\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "then"], ["proof (chain)\npicking this:\n  trace c (take i t) c''", "show ?thesis"], ["proof (prove)\nusing this:\n  trace c (take i t) c''\n\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace c (take i t) c'' \\<Longrightarrow> trace c (take i t) (s c t i)", "have \"((c, take i t), s c t i) \\<in> trace_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, take i t), s c t i) \\<in> trace_rel", "unfolding s_def trace_rel_def construct_fun_from_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((c, take i t), The (trace c (take i t)))\n    \\<in> Collect (case_prod (\\<lambda>(x, y). trace x y))", "by (metis case_prod_conv distributed_system.trace_and_start_determines_end distributed_system_axioms mem_Collect_eq the_equality tr)"], ["proof (state)\nthis:\n  ((c, take i t), s c t i) \\<in> trace_rel\n\ngoal (1 subgoal):\n 1. trace c (take i t) c'' \\<Longrightarrow> trace c (take i t) (s c t i)", "then"], ["proof (chain)\npicking this:\n  ((c, take i t), s c t i) \\<in> trace_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  ((c, take i t), s c t i) \\<in> trace_rel\n\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i)", "by (simp add: trace_rel_def)"], ["proof (state)\nthis:\n  trace c (take i t) (s c t i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace c (take i t) (s c t i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_trace_for_any_i_j:\n  assumes\n    \"\\<exists>c'. trace c t c'\" and\n    \"i \\<le> j\"\n  shows\n    \"trace (s c t i) (take (j - i) (drop i t)) (s c t j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "have \"trace c (take j t) (s c t j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace c (take j t) (s c t j)", "using exists_trace_for_any_i assms"], ["proof (prove)\nusing this:\n  \\<exists>c'. trace ?c ?t c' \\<Longrightarrow>\n  trace ?c (take ?i ?t) (s ?c ?t ?i)\n  \\<exists>c'. trace c t c'\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. trace c (take j t) (s c t j)", "by simp"], ["proof (state)\nthis:\n  trace c (take j t) (s c t j)\n\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "from \\<open>j \\<ge> i\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"take j t = take i t @ (take (j - i) (drop i t))\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. take j t = take i t @ take (j - i) (drop i t)", "by (metis le_add_diff_inverse take_add)"], ["proof (state)\nthis:\n  take j t = take i t @ take (j - i) (drop i t)\n\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "then"], ["proof (chain)\npicking this:\n  take j t = take i t @ take (j - i) (drop i t)", "have \"trace c (take i t) (s c t i) \\<and> trace (s c t i) (take (j - i) (drop i t)) (s c t j)\""], ["proof (prove)\nusing this:\n  take j t = take i t @ take (j - i) (drop i t)\n\ngoal (1 subgoal):\n 1. trace c (take i t) (s c t i) \\<and>\n    trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "by (metis (no_types, lifting) assms(1) exists_trace_for_any_i split_trace trace_and_start_determines_end)"], ["proof (state)\nthis:\n  trace c (take i t) (s c t i) \\<and>\n  trace (s c t i) (take (j - i) (drop i t)) (s c t j)\n\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "then"], ["proof (chain)\npicking this:\n  trace c (take i t) (s c t i) \\<and>\n  trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace c (take i t) (s c t i) \\<and>\n  trace (s c t i) (take (j - i) (drop i t)) (s c t j)\n\ngoal (1 subgoal):\n 1. trace (s c t i) (take (j - i) (drop i t)) (s c t j)", "by simp"], ["proof (state)\nthis:\n  trace (s c t i) (take (j - i) (drop i t)) (s c t j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_Suc:\n  assumes\n    \"i < length t\" and\n    valid: \"trace c t c'\"\n  shows \"(s c t i) \\<turnstile> (t ! i) \\<mapsto> (s c t (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "have ex_trace: \"trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))", "using exists_trace_for_any_i_j le_less valid"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>c'. trace ?c ?t c'; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> trace (s ?c ?t ?i) (take (?j - ?i) (drop ?i ?t))\n                     (s ?c ?t ?j)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  trace c t c'\n\ngoal (1 subgoal):\n 1. trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))", "by blast"], ["proof (state)\nthis:\n  trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "moreover"], ["proof (state)\nthis:\n  trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "have \"Suc i - i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i - i = 1", "by auto"], ["proof (state)\nthis:\n  Suc i - i = 1\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "moreover"], ["proof (state)\nthis:\n  Suc i - i = 1\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "have \"take 1 (drop i t) = [t ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take 1 (drop i t) = [t ! i]", "by (metis \\<open>Suc i - i = 1\\<close> assms(1) hd_drop_conv_nth le_add_diff_inverse lessI nat_less_le same_append_eq take_add take_hd_drop)"], ["proof (state)\nthis:\n  take 1 (drop i t) = [t ! i]\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "ultimately"], ["proof (chain)\npicking this:\n  trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))\n  Suc i - i = 1\n  take 1 (drop i t) = [t ! i]", "show ?thesis"], ["proof (prove)\nusing this:\n  trace (s c t i) (take (Suc i - i) (drop i t)) (s c t (Suc i))\n  Suc i - i = 1\n  take 1 (drop i t) = [t ! i]\n\ngoal (1 subgoal):\n 1. s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)", "by (metis list.discI trace.simps trace_decomp_head)"], ["proof (state)\nthis:\n  s c t i \\<turnstile> t ! i \\<mapsto> s c t (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Trace-related lemmas\\<close>"], ["", "lemma snapshot_state_unchanged_trace:\n  assumes\n    \"trace c t c'\" and\n    \"ps c p = Some u\"\n  shows\n    \"ps c' p = Some u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps c' p = Some u", "using assms snapshot_state_unchanged"], ["proof (prove)\nusing this:\n  trace c t c'\n  ps c p = Some u\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   ps ?c ?p \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ps ?c ?p = ps ?c' ?p\n\ngoal (1 subgoal):\n 1. ps c' p = Some u", "by (induct c t c', auto)"], ["", "lemma no_state_change_if_only_nonregular_events:\n  shows\n    \"\\<lbrakk> trace c t c';\n       \\<nexists>ev. ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p;\n       states c p = st\n     \\<rbrakk> \\<Longrightarrow> states c' p = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c';\n     \\<nexists>ev.\n        ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p;\n     states c p = st\\<rbrakk>\n    \\<Longrightarrow> states c' p = st", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<nexists>ev.\n                   ev \\<in> set [] \\<and>\n                   regular_event ev \\<and> occurs_on ev = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c p = st\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "case (tr_rev_init c)"], ["proof (state)\nthis:\n  \\<nexists>ev.\n     ev \\<in> set [] \\<and> regular_event ev \\<and> occurs_on ev = p\n  states c p = st\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<nexists>ev.\n                   ev \\<in> set [] \\<and>\n                   regular_event ev \\<and> occurs_on ev = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c p = st\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "then"], ["proof (chain)\npicking this:\n  \\<nexists>ev.\n     ev \\<in> set [] \\<and> regular_event ev \\<and> occurs_on ev = p\n  states c p = st", "show ?case"], ["proof (prove)\nusing this:\n  \\<nexists>ev.\n     ev \\<in> set [] \\<and> regular_event ev \\<and> occurs_on ev = p\n  states c p = st\n\ngoal (1 subgoal):\n 1. states c p = st", "by simp"], ["proof (state)\nthis:\n  states c p = st\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "case (tr_rev_step c t c' ev c'')"], ["proof (state)\nthis:\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "then"], ["proof (chain)\npicking this:\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st", "have \"states c' p = st\""], ["proof (prove)\nusing this:\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st\n\ngoal (1 subgoal):\n 1. states c' p = st", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c';\n     \\<lbrakk>\\<nexists>ev.\n                 ev \\<in> set t \\<and>\n                 regular_event ev \\<and> occurs_on ev = p;\n      states c p = st\\<rbrakk>\n     \\<Longrightarrow> states c' p = st;\n     c' \\<turnstile> ev \\<mapsto> c'';\n     \\<nexists>eva.\n        eva \\<in> set (t @ [ev]) \\<and>\n        regular_event eva \\<and> occurs_on eva = p;\n     states c p = st\\<rbrakk>\n    \\<Longrightarrow> states c' p = st", "have \"\\<nexists>ev. ev : set t \\<and> regular_event ev \\<and> occurs_on ev = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>ev.\n       ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p", "using tr_rev_step"], ["proof (prove)\nusing this:\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st\n\ngoal (1 subgoal):\n 1. \\<nexists>ev.\n       ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p", "by auto"], ["proof (state)\nthis:\n  \\<nexists>ev.\n     ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c';\n     \\<lbrakk>\\<nexists>ev.\n                 ev \\<in> set t \\<and>\n                 regular_event ev \\<and> occurs_on ev = p;\n      states c p = st\\<rbrakk>\n     \\<Longrightarrow> states c' p = st;\n     c' \\<turnstile> ev \\<mapsto> c'';\n     \\<nexists>eva.\n        eva \\<in> set (t @ [ev]) \\<and>\n        regular_event eva \\<and> occurs_on eva = p;\n     states c p = st\\<rbrakk>\n    \\<Longrightarrow> states c' p = st", "then"], ["proof (chain)\npicking this:\n  \\<nexists>ev.\n     ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>ev.\n     ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p\n\ngoal (1 subgoal):\n 1. states c' p = st", "using tr_rev_step"], ["proof (prove)\nusing this:\n  \\<nexists>ev.\n     ev \\<in> set t \\<and> regular_event ev \\<and> occurs_on ev = p\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st\n\ngoal (1 subgoal):\n 1. states c' p = st", "by blast"], ["proof (state)\nthis:\n  states c' p = st\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  states c' p = st\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<nexists>ev.\n                    ev \\<in> set t \\<and>\n                    regular_event ev \\<and> occurs_on ev = p;\n         states c p = st\\<rbrakk>\n        \\<Longrightarrow> states c' p = st;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        \\<nexists>eva.\n           eva \\<in> set (t @ [ev]) \\<and>\n           regular_event eva \\<and> occurs_on eva = p;\n        states c p = st\\<rbrakk>\n       \\<Longrightarrow> states c'' p = st", "then"], ["proof (chain)\npicking this:\n  states c' p = st", "show ?case"], ["proof (prove)\nusing this:\n  states c' p = st\n\ngoal (1 subgoal):\n 1. states c'' p = st", "using tr_rev_step no_state_change_if_no_event no_state_change_if_nonregular_event"], ["proof (prove)\nusing this:\n  states c' p = st\n  trace c t c'\n  \\<lbrakk>\\<nexists>ev.\n              ev \\<in> set t \\<and>\n              regular_event ev \\<and> occurs_on ev = p;\n   states c p = st\\<rbrakk>\n  \\<Longrightarrow> states c' p = st\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<nexists>eva.\n     eva \\<in> set (t @ [ev]) \\<and>\n     regular_event eva \\<and> occurs_on eva = p\n  states c p = st\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   occurs_on ?ev \\<noteq> ?p\\<rbrakk>\n  \\<Longrightarrow> states ?c ?p = states ?c' ?p \\<and> ps ?c ?p = ps ?c' ?p\n  \\<lbrakk>\\<not> regular_event ?ev;\n   ?c \\<turnstile> ?ev \\<mapsto> ?c'\\<rbrakk>\n  \\<Longrightarrow> states ?c ?p = states ?c' ?p\n\ngoal (1 subgoal):\n 1. states c'' p = st", "by auto"], ["proof (state)\nthis:\n  states c'' p = st\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma message_must_be_delivered_2_trace:\n  assumes\n    \"trace c t c'\" and\n    \"m : set (msgs c i)\" and\n    \"m \\<notin> set (msgs c' i)\" and\n    \"channel i = Some (q, p)\"\n  shows\n    \"\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or> (\\<exists>p q s s' m'. ev = Recv i q p s s' m' \\<and> m = Msg m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ev\\<in>set t.\n       (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n       (\\<exists>p q s s' m'. ev = Recv i q p s s' m' \\<and> m = Msg m')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>ev\\<in>set t.\n               (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n               (\\<exists>p q s s' m'.\n                   ev = Recv i q p s s' m' \\<and>\n                   m = Msg m')) \\<Longrightarrow>\n    False", "assume \"~ (\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or> (\\<exists>p q s s' m'. ev = Recv i q p s s' m' \\<and> m = Msg m'))\" (is ?P)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>ev\\<in>set t.\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>ev\\<in>set t.\n               (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n               (\\<exists>p q s s' m'.\n                   ev = Recv i q p s s' m' \\<and>\n                   m = Msg m')) \\<Longrightarrow>\n    False", "have \"\\<lbrakk> trace c t c'; m : set (msgs c i); ?P \\<rbrakk> \\<Longrightarrow> m : set (msgs c' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; m \\<in> set (msgs c i);\n     \\<not> (\\<exists>ev\\<in>set t.\n                (\\<exists>p q.\n                    ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                (\\<exists>p q s s' m'.\n                    ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set [].\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c i)\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "case (tr_rev_init c)"], ["proof (state)\nthis:\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set [].\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set [].\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c i)\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set [].\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set [].\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c i)", "by simp"], ["proof (state)\nthis:\n  m \\<in> set (msgs c i)\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "case (tr_rev_step c t d ev c')"], ["proof (state)\nthis:\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))", "have m_in_set: \"m : set (msgs d i)\""], ["proof (prove)\nusing this:\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs d i)", "using tr_rev_step"], ["proof (prove)\nusing this:\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs d i)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (msgs d i)\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>m \\<in> set (msgs c i);\n         \\<not> (\\<exists>ev\\<in>set t.\n                    (\\<exists>p q.\n                        ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n        \\<Longrightarrow> m \\<in> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; m \\<in> set (msgs c i);\n        \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n                   (\\<exists>p q.\n                       ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n                   (\\<exists>p q s s' m'.\n                       ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  m \\<in> set (msgs d i)", "show ?case"], ["proof (prove)\nusing this:\n  m \\<in> set (msgs d i)\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "proof (cases ev)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 4. \\<And>x4.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "case (Snapshot r)"], ["proof (state)\nthis:\n  ev = Snapshot r\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 4. \\<And>x4.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  ev = Snapshot r", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using distributed_system.message_must_be_delivered_2 distributed_system_axioms m_in_set tr_rev_step.hyps(3)"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n  \\<lbrakk>distributed_system ?channel;\n   distributed_system.next ?channel ?trans ?send ?recv ?c ?ev ?c';\n   ?m \\<in> set (msgs ?c ?i); ?m \\<notin> set (msgs ?c' ?i)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>p q.\n                        ?ev = RecvMarker ?i p q \\<and> ?m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ?ev = Recv ?i p q s s' m' \\<and> ?m = Msg m')\n  distributed_system channel\n  m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by blast"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "case (RecvMarker i' r s)"], ["proof (state)\nthis:\n  ev = RecvMarker i' r s\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  ev = RecvMarker i' r s", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = RecvMarker i' r s\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "proof (cases \"m = Marker\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m = Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "case True"], ["proof (state)\nthis:\n  m = Marker\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m = Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  m = Marker", "have \"i' \\<noteq> i\""], ["proof (prove)\nusing this:\n  m = Marker\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "using tr_rev_step RecvMarker"], ["proof (prove)\nusing this:\n  m = Marker\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n  ev = RecvMarker i' r s\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m = Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  i' \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using RecvMarker m_in_set message_must_be_delivered_2 tr_rev_step.hyps(3)"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  ev = RecvMarker i' r s\n  m \\<in> set (msgs d i)\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; ?m \\<in> set (msgs ?c ?i);\n   ?m \\<notin> set (msgs ?c' ?i)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>p q.\n                        ?ev = RecvMarker ?i p q \\<and> ?m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ?ev = Recv ?i p q s s' m' \\<and> ?m = Msg m')\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by blast"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> Marker\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = RecvMarker i' r s; m \\<noteq> Marker\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  m \\<noteq> Marker", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<noteq> Marker\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using RecvMarker tr_rev_step.hyps(3) m_in_set message_must_be_delivered_2"], ["proof (prove)\nusing this:\n  m \\<noteq> Marker\n  ev = RecvMarker i' r s\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs d i)\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; ?m \\<in> set (msgs ?c ?i);\n   ?m \\<notin> set (msgs ?c' ?i)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>p q.\n                        ?ev = RecvMarker ?i p q \\<and> ?m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ?ev = Recv ?i p q s s' m' \\<and> ?m = Msg m')\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by blast"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "case (Trans r u u')"], ["proof (state)\nthis:\n  ev = Trans r u u'\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>m \\<in> set (msgs d i); ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  ev = Trans r u u'", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Trans r u u'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using tr_rev_step.hyps(3) m_in_set"], ["proof (prove)\nusing this:\n  ev = Trans r u u'\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs d i)\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "case (Send i' r s u u' m')"], ["proof (state)\nthis:\n  ev = Send i' r s u u' m'\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  ev = Send i' r s u u' m'", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Send i' r s u u' m'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using distributed_system.message_must_be_delivered_2 distributed_system_axioms m_in_set tr_rev_step.hyps(3)"], ["proof (prove)\nusing this:\n  ev = Send i' r s u u' m'\n  \\<lbrakk>distributed_system ?channel;\n   distributed_system.next ?channel ?trans ?send ?recv ?c ?ev ?c';\n   ?m \\<in> set (msgs ?c ?i); ?m \\<notin> set (msgs ?c' ?i)\\<rbrakk>\n  \\<Longrightarrow> (\\<exists>p q.\n                        ?ev = RecvMarker ?i p q \\<and> ?m = Marker) \\<or>\n                    (\\<exists>p q s s' m'.\n                        ?ev = Recv ?i p q s s' m' \\<and> ?m = Msg m')\n  distributed_system channel\n  m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by blast"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "case (Recv i' r s u u' m')"], ["proof (state)\nthis:\n  ev = Recv i' r s u u' m'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>m \\<in> set (msgs d i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  ev = Recv i' r s u u' m'", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Recv i' r s u u' m'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "proof (cases \"Msg m' = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' = m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "case True"], ["proof (state)\nthis:\n  Msg m' = m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' = m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  Msg m' = m", "have \"i' \\<noteq> i\""], ["proof (prove)\nusing this:\n  Msg m' = m\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "using Recv tr_rev_step"], ["proof (prove)\nusing this:\n  Msg m' = m\n  ev = Recv i' r s u u' m'\n  trace c t d\n  \\<lbrakk>m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n  m \\<in> set (msgs c i)\n  \\<not> (\\<exists>ev\\<in>set (t @ [ev]).\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "by auto"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' = m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  i' \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using Recv m_in_set tr_rev_step(3)"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  ev = Recv i' r s u u' m'\n  m \\<in> set (msgs d i)\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "case False"], ["proof (state)\nthis:\n  Msg m' \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m'; Msg m' \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set (msgs c' i)", "then"], ["proof (chain)\npicking this:\n  Msg m' \\<noteq> m", "show ?thesis"], ["proof (prove)\nusing this:\n  Msg m' \\<noteq> m\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by (metis Recv event.distinct(17) event.inject(3) m_in_set message_must_be_delivered_2 tr_rev_step.hyps(3))"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t c'; m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>ev\\<in>set t.\n               (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n               (\\<exists>p q s s' m'.\n                   ev = Recv i q p s s' m' \\<and>\n                   m = Msg m')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>trace c t c'; m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs c' i)", "have \"m : set (msgs c' i)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t c'; m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "using assms \\<open>?P\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t c'; m \\<in> set (msgs c i);\n   \\<not> (\\<exists>ev\\<in>set t.\n              (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n              (\\<exists>p q s s' m'.\n                  ev = Recv i q p s s' m' \\<and> m = Msg m'))\\<rbrakk>\n  \\<Longrightarrow> m \\<in> set (msgs c' i)\n  trace c t c'\n  m \\<in> set (msgs c i)\n  m \\<notin> set (msgs c' i)\n  channel i = Some (q, p)\n  \\<not> (\\<exists>ev\\<in>set t.\n             (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n             (\\<exists>p q s s' m'.\n                 ev = Recv i q p s s' m' \\<and> m = Msg m'))\n\ngoal (1 subgoal):\n 1. m \\<in> set (msgs c' i)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>ev\\<in>set t.\n               (\\<exists>p q. ev = RecvMarker i p q \\<and> m = Marker) \\<or>\n               (\\<exists>p q s s' m'.\n                   ev = Recv i q p s s' m' \\<and>\n                   m = Msg m')) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  m \\<in> set (msgs c' i)", "show False"], ["proof (prove)\nusing this:\n  m \\<in> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  m \\<in> set (msgs c' i)\n  trace c t c'\n  m \\<in> set (msgs c i)\n  m \\<notin> set (msgs c' i)\n  channel i = Some (q, p)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma marker_must_be_delivered_2_trace:\n  assumes\n    \"trace c t c'\" and\n    \"Marker : set (msgs c i)\" and\n    \"Marker \\<notin> set (msgs c' i)\" and\n    \"channel i = Some (p, q)\"\n  shows\n    \"\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ev\\<in>set t. \\<exists>p q. ev = RecvMarker i p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ev\\<in>set t. \\<exists>p q. ev = RecvMarker i p q", "show \"\\<exists>ev \\<in> set t. (\\<exists>p q. ev = RecvMarker i p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ev\\<in>set t. \\<exists>p q. ev = RecvMarker i p q", "using assms message_must_be_delivered_2_trace"], ["proof (prove)\nusing this:\n  trace c t c'\n  Marker \\<in> set (msgs c i)\n  Marker \\<notin> set (msgs c' i)\n  channel i = Some (p, q)\n  \\<lbrakk>trace ?c ?t ?c'; ?m \\<in> set (msgs ?c ?i);\n   ?m \\<notin> set (msgs ?c' ?i); channel ?i = Some (?q, ?p)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ev\\<in>set ?t.\n                       (\\<exists>p q.\n                           ev = RecvMarker ?i p q \\<and> ?m = Marker) \\<or>\n                       (\\<exists>p q s s' m'.\n                           ev = Recv ?i q p s s' m' \\<and> ?m = Msg m')\n\ngoal (1 subgoal):\n 1. \\<exists>ev\\<in>set t. \\<exists>p q. ev = RecvMarker i p q", "by fast"], ["proof (state)\nthis:\n  \\<exists>ev\\<in>set t. \\<exists>p q. ev = RecvMarker i p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snapshot_stable:\n  shows\n    \"\\<lbrakk> trace c t c';\n       has_snapshotted c p\n     \\<rbrakk> \\<Longrightarrow> has_snapshotted c' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; ps c p \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ps c' p \\<noteq> None", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c. ps c p \\<noteq> None \\<Longrightarrow> ps c p \\<noteq> None\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "case (tr_rev_init c)"], ["proof (state)\nthis:\n  ps c p \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<And>c. ps c p \\<noteq> None \\<Longrightarrow> ps c p \\<noteq> None\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  ps c p \\<noteq> None", "show ?case"], ["proof (prove)\nusing this:\n  ps c p \\<noteq> None\n\ngoal (1 subgoal):\n 1. ps c p \\<noteq> None", "by blast"], ["proof (state)\nthis:\n  ps c p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "case (tr_rev_step c t c' ev c'')"], ["proof (state)\nthis:\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None", "show ?case"], ["proof (prove)\nusing this:\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n\ngoal (1 subgoal):\n 1. ps c'' p \\<noteq> None", "proof (cases ev)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x4.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "case (Snapshot q)"], ["proof (state)\nthis:\n  ev = Snapshot q\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x4.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  ev = Snapshot q", "have \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  ev = Snapshot q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "using tr_rev_step next_snapshot can_occur_def"], ["proof (prove)\nusing this:\n  ev = Snapshot q\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n  ?c \\<turnstile> Snapshot ?p \\<mapsto> ?c' =\n  (can_occur (Snapshot ?p) ?c \\<and>\n   ps ?c' ?p = Some (states ?c ?p) \\<and>\n   (\\<forall>p'. states ?c p' = states ?c' p') \\<and>\n   (\\<forall>p'.\n       p' \\<noteq> ?p \\<longrightarrow> ps ?c' p' = ps ?c p') \\<and>\n   (\\<forall>i.\n       (\\<exists>q. channel i = Some (?p, q)) \\<longrightarrow>\n       msgs ?c' i = msgs ?c i @ [Marker]) \\<and>\n   (\\<forall>i.\n       (\\<exists>q. channel i = Some (q, ?p)) \\<longrightarrow>\n       cs ?c' i = (fst (cs ?c i), Recording)) \\<and>\n   (\\<forall>i.\n       (\\<nexists>q. channel i = Some (?p, q)) \\<longrightarrow>\n       msgs ?c' i = msgs ?c i) \\<and>\n   (\\<forall>i.\n       (\\<nexists>q. channel i = Some (q, ?p)) \\<longrightarrow>\n       cs ?c' i = cs ?c i))\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x4.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> q", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. ps c'' p \\<noteq> None", "using Snapshot tr_rev_step"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  ev = Snapshot q\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n\ngoal (1 subgoal):\n 1. ps c'' p \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  ps c'' p \\<noteq> None\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "case (RecvMarker i q r)"], ["proof (state)\nthis:\n  ev = RecvMarker i q r\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "with tr_rev_step"], ["proof (chain)\npicking this:\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n  ev = RecvMarker i q r", "show ?thesis"], ["proof (prove)\nusing this:\n  trace c t c'\n  ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None\n  c' \\<turnstile> ev \\<mapsto> c''\n  ps c p \\<noteq> None\n  ev = RecvMarker i q r\n\ngoal (1 subgoal):\n 1. ps c'' p \\<noteq> None", "by (cases \"p = q\"; auto)"], ["proof (state)\nthis:\n  ps c'' p \\<noteq> None\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>trace c t c';\n        ps c p \\<noteq> None \\<Longrightarrow> ps c' p \\<noteq> None;\n        c' \\<turnstile> ev \\<mapsto> c''; ps c p \\<noteq> None;\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> ps c'' p \\<noteq> None", "qed simp_all"], ["proof (state)\nthis:\n  ps c'' p \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snapshot_stable_2:\n  shows\n    \"trace c t c' \\<Longrightarrow> ~ has_snapshotted c' p \\<Longrightarrow> ~ has_snapshotted c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; \\<not> ps c' p \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> \\<not> ps c p \\<noteq> None", "using snapshot_stable"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace ?c ?t ?c'; ps ?c ?p \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ps ?c' ?p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; \\<not> ps c' p \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> \\<not> ps c p \\<noteq> None", "by blast"], ["", "lemma no_markers_if_all_snapshotted:\n  shows\n    \"\\<lbrakk> trace c t c';\n      \\<forall>p. has_snapshotted c p;\n      Marker \\<notin> set (msgs c i)\n     \\<rbrakk> \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; \\<forall>p. ps c p \\<noteq> None;\n     Marker \\<notin> set (msgs c i)\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c' i)", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c i)\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (tr_rev_init c)"], ["proof (state)\nthis:\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c i)\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c i)", "by simp"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (tr_rev_step c t c' ev c'')"], ["proof (state)\nthis:\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "have all_snapshotted: \"\\<forall>p. has_snapshotted c' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. ps c' p \\<noteq> None", "using snapshot_stable tr_rev_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace ?c ?t ?c'; ps ?c ?p \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ps ?c' ?p \\<noteq> None\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. \\<forall>p. ps c' p \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  \\<forall>p. ps c' p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "have no_marker: \"Marker \\<notin> set (msgs c' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c' i)", "using tr_rev_step"], ["proof (prove)\nusing this:\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c' i)", "by blast"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n         Marker \\<notin> set (msgs c i)\\<rbrakk>\n        \\<Longrightarrow> Marker \\<notin> set (msgs c' i);\n        c' \\<turnstile> ev \\<mapsto> c''; \\<forall>p. ps c p \\<noteq> None;\n        Marker \\<notin> set (msgs c i)\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  Marker \\<notin> set (msgs c' i)", "show ?case"], ["proof (prove)\nusing this:\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "proof (cases ev)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x4.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i); ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (Snapshot r)"], ["proof (state)\nthis:\n  ev = Snapshot r\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x4.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i); ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  ev = Snapshot r", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using can_occur_def tr_rev_step all_snapshotted"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  \\<forall>p. ps c' p \\<noteq> None\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (RecvMarker i' r s)"], ["proof (state)\nthis:\n  ev = RecvMarker i' r s\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "have \"i' \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<noteq> i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i' \\<noteq> i \\<Longrightarrow> False", "assume \"~ i' \\<noteq> i\""], ["proof (state)\nthis:\n  \\<not> i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<not> i' \\<noteq> i \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> i' \\<noteq> i", "have \"Marker : set (msgs c i)\""], ["proof (prove)\nusing this:\n  \\<not> i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. Marker \\<in> set (msgs c i)", "using can_occur_def RecvMarker tr_rev_step  RecvMarker_implies_Marker_in_set"], ["proof (prove)\nusing this:\n  \\<not> i' \\<noteq> i\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n  ev = RecvMarker i' r s\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   ?ev = RecvMarker ?cid ?p ?q\\<rbrakk>\n  \\<Longrightarrow> Marker \\<in> set (msgs ?c ?cid)\n\ngoal (1 subgoal):\n 1. Marker \\<in> set (msgs c i)", "by blast"], ["proof (state)\nthis:\n  Marker \\<in> set (msgs c i)\n\ngoal (1 subgoal):\n 1. \\<not> i' \\<noteq> i \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Marker \\<in> set (msgs c i)", "show False"], ["proof (prove)\nusing this:\n  Marker \\<in> set (msgs c i)\n\ngoal (1 subgoal):\n 1. False", "using tr_rev_step"], ["proof (prove)\nusing this:\n  Marker \\<in> set (msgs c i)\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  i' \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using tr_rev_step all_snapshotted no_marker RecvMarker"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  \\<forall>p. ps c' p \\<noteq> None\n  Marker \\<notin> set (msgs c' i)\n  ev = RecvMarker i' r s\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (Trans p s s')"], ["proof (state)\nthis:\n  ev = Trans p s s'\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  ev = Trans p s s'", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Trans p s s'\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using tr_rev_step no_marker"], ["proof (prove)\nusing this:\n  ev = Trans p s s'\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (Send i' r s u u' m)"], ["proof (state)\nthis:\n  ev = Send i' r s u u' m\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  ev = Send i' r s u u' m", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Send i' r s u u' m\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "proof (cases \"i' = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' = i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case True"], ["proof (state)\nthis:\n  i' = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' = i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  i' = i", "have \"msgs c'' i = msgs c' i @ [Msg m]\""], ["proof (prove)\nusing this:\n  i' = i\n\ngoal (1 subgoal):\n 1. msgs c'' i = msgs c' i @ [Msg m]", "using tr_rev_step Send"], ["proof (prove)\nusing this:\n  i' = i\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  ev = Send i' r s u u' m\n\ngoal (1 subgoal):\n 1. msgs c'' i = msgs c' i @ [Msg m]", "by auto"], ["proof (state)\nthis:\n  msgs c'' i = msgs c' i @ [Msg m]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' = i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  msgs c'' i = msgs c' i @ [Msg m]", "show ?thesis"], ["proof (prove)\nusing this:\n  msgs c'' i = msgs c' i @ [Msg m]\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using no_marker"], ["proof (prove)\nusing this:\n  msgs c'' i = msgs c' i @ [Msg m]\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case False"], ["proof (state)\nthis:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Send i' r s u u' m; i' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  i' \\<noteq> i", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using Send tr_rev_step no_marker"], ["proof (prove)\nusing this:\n  i' \\<noteq> i\n  ev = Send i' r s u u' m\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case (Recv i' r s u u' m)"], ["proof (state)\nthis:\n  ev = Recv i' r s u u' m\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>Marker \\<notin> set (msgs c' i);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  ev = Recv i' r s u u' m", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Recv i' r s u u' m\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "proof (cases \"i = i'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i = i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case True"], ["proof (state)\nthis:\n  i = i'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i = i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  i = i'", "have \"msgs c'' i = tl (msgs c' i)\""], ["proof (prove)\nusing this:\n  i = i'\n\ngoal (1 subgoal):\n 1. msgs c'' i = tl (msgs c' i)", "using tr_rev_step Recv"], ["proof (prove)\nusing this:\n  i = i'\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  ev = Recv i' r s u u' m\n\ngoal (1 subgoal):\n 1. msgs c'' i = tl (msgs c' i)", "by auto"], ["proof (state)\nthis:\n  msgs c'' i = tl (msgs c' i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i = i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)\n 2. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  msgs c'' i = tl (msgs c' i)", "show ?thesis"], ["proof (prove)\nusing this:\n  msgs c'' i = tl (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using no_marker"], ["proof (prove)\nusing this:\n  msgs c'' i = tl (msgs c' i)\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by (metis list.sel(2) list.set_sel(2))"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ev = Recv i' r s u u' m; i \\<noteq> i'\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs c'' i)", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> i'", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> i'\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "using Recv tr_rev_step no_marker"], ["proof (prove)\nusing this:\n  i \\<noteq> i'\n  ev = Recv i' r s u u' m\n  trace c t c'\n  \\<lbrakk>\\<forall>p. ps c p \\<noteq> None;\n   Marker \\<notin> set (msgs c i)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs c' i)\n  c' \\<turnstile> ev \\<mapsto> c''\n  \\<forall>p. ps c p \\<noteq> None\n  Marker \\<notin> set (msgs c i)\n  Marker \\<notin> set (msgs c' i)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs c'' i)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs c'' i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma event_stays_valid_if_no_occurrence_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n       can_occur ev' c\n     \\<rbrakk> \\<Longrightarrow> can_occur ev' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c';\n     list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n     can_occur ev' c\\<rbrakk>\n    \\<Longrightarrow> can_occur ev' c'", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                 [];\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c';\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c''", "case tr_rev_init"], ["proof (state)\nthis:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                 [];\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c';\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c''", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_\n\ngoal (1 subgoal):\n 1. can_occur ev' c_", "by blast"], ["proof (state)\nthis:\n  can_occur ev' c_\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c';\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c';\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c''", "case tr_rev_step"], ["proof (state)\nthis:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c'_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c_\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c';\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c''", "then"], ["proof (chain)\npicking this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c'_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c_", "show ?case"], ["proof (prove)\nusing this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c'_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c_\n\ngoal (1 subgoal):\n 1. can_occur ev' c''_", "using event_stays_valid_if_no_occurrence"], ["proof (prove)\nusing this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c'_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c_\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   occurs_on ?ev \\<noteq> occurs_on ?ev'; can_occur ?ev' ?c\\<rbrakk>\n  \\<Longrightarrow> can_occur ?ev' ?c'\n\ngoal (1 subgoal):\n 1. can_occur ev' c''_", "by auto"], ["proof (state)\nthis:\n  can_occur ev' c''_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma event_can_go_back_if_no_sender_trace:\n  shows\n    \"\\<lbrakk> trace c t c';\n       list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n       can_occur ev' c';\n       ~ isRecvMarker ev';\n       list_all (\\<lambda>ev. ~ isSend ev) t\n     \\<rbrakk> \\<Longrightarrow> can_occur ev' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c';\n     list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t;\n     can_occur ev' c'; \\<not> isRecvMarker ev';\n     list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n    \\<Longrightarrow> can_occur ev' c", "proof (induct c t c' rule:trace_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                 [];\n        can_occur ev' c; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) []\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c'; \\<not> isRecvMarker ev';\n         list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c''; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) (t @ [ev])\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c", "case tr_rev_init"], ["proof (state)\nthis:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) []\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                 [];\n        can_occur ev' c; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) []\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c\n 2. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c'; \\<not> isRecvMarker ev';\n         list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c''; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) (t @ [ev])\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) []", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') []\n  can_occur ev' c_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) []\n\ngoal (1 subgoal):\n 1. can_occur ev' c_", "by blast"], ["proof (state)\nthis:\n  can_occur ev' c_\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c'; \\<not> isRecvMarker ev';\n         list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c''; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) (t @ [ev])\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c'; \\<not> isRecvMarker ev';\n         list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c''; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) (t @ [ev])\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c", "case tr_rev_step"], ["proof (state)\nthis:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c'_; \\<not> isRecvMarker ev';\n   list_all (\\<lambda>ev. \\<not> isSend ev) t_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c''_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) (t_ @ [ev_])\n\ngoal (1 subgoal):\n 1. \\<And>c t c' ev c''.\n       \\<lbrakk>trace c t c';\n        \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n                  t;\n         can_occur ev' c'; \\<not> isRecvMarker ev';\n         list_all (\\<lambda>ev. \\<not> isSend ev) t\\<rbrakk>\n        \\<Longrightarrow> can_occur ev' c;\n        c' \\<turnstile> ev \\<mapsto> c'';\n        list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev')\n         (t @ [ev]);\n        can_occur ev' c''; \\<not> isRecvMarker ev';\n        list_all (\\<lambda>ev. \\<not> isSend ev) (t @ [ev])\\<rbrakk>\n       \\<Longrightarrow> can_occur ev' c", "then"], ["proof (chain)\npicking this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c'_; \\<not> isRecvMarker ev';\n   list_all (\\<lambda>ev. \\<not> isSend ev) t_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c''_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) (t_ @ [ev_])", "show ?case"], ["proof (prove)\nusing this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c'_; \\<not> isRecvMarker ev';\n   list_all (\\<lambda>ev. \\<not> isSend ev) t_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c''_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) (t_ @ [ev_])\n\ngoal (1 subgoal):\n 1. can_occur ev' c_", "using event_can_go_back_if_no_sender"], ["proof (prove)\nusing this:\n  trace c_ t_ c'_\n  \\<lbrakk>list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') t_;\n   can_occur ev' c'_; \\<not> isRecvMarker ev';\n   list_all (\\<lambda>ev. \\<not> isSend ev) t_\\<rbrakk>\n  \\<Longrightarrow> can_occur ev' c_\n  c'_ \\<turnstile> ev_ \\<mapsto> c''_\n  list_all (\\<lambda>ev. occurs_on ev \\<noteq> occurs_on ev') (t_ @ [ev_])\n  can_occur ev' c''_\n  \\<not> isRecvMarker ev'\n  list_all (\\<lambda>ev. \\<not> isSend ev) (t_ @ [ev_])\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   occurs_on ?ev \\<noteq> occurs_on ?ev'; can_occur ?ev' ?c';\n   \\<not> isRecvMarker ?ev'; \\<not> isSend ?ev\\<rbrakk>\n  \\<Longrightarrow> can_occur ?ev' ?c\n\ngoal (1 subgoal):\n 1. can_occur ev' c_", "by auto"], ["proof (state)\nthis:\n  can_occur ev' c_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma done_only_from_recv_marker_trace:\n  assumes\n    \"trace c t c'\" and\n    \"t \\<noteq> []\" and\n    \"snd (cs c cid) \\<noteq> Done\" and\n    \"snd (cs c' cid) = Done\" and\n    \"channel cid = Some (p, q)\"\n  shows\n    \"RecvMarker cid q p \\<in> set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<in> set t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t \\<Longrightarrow> False", "assume \"~ RecvMarker cid q p \\<in> set t\""], ["proof (state)\nthis:\n  RecvMarker cid q p \\<notin> set t\n\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  RecvMarker cid q p \\<notin> set t\n\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t \\<Longrightarrow> False", "have \"\\<lbrakk> trace c t c'; ~ RecvMarker cid q p \\<in> set t; snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q) \\<rbrakk>\n                 \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; RecvMarker cid q p \\<notin> set t;\n     snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n    \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "proof (induct t arbitrary: c' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; RecvMarker cid q p \\<notin> set [];\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "case Nil"], ["proof (state)\nthis:\n  trace c [] c'\n  RecvMarker cid q p \\<notin> set []\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; RecvMarker cid q p \\<notin> set [];\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "then"], ["proof (chain)\npicking this:\n  trace c [] c'\n  RecvMarker cid q p \\<notin> set []\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)", "show ?case"], ["proof (prove)\nusing this:\n  trace c [] c'\n  RecvMarker cid q p \\<notin> set []\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> Done", "by (metis list.discI trace.simps)"], ["proof (state)\nthis:\n  snd (cs c' cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "case (snoc ev t)"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t ?c'5; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> Done\n  trace c (t @ [ev]) c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>trace c t ?c'5; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> Done\n  trace c (t @ [ev]) c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)", "obtain d where ind: \"trace c t d\" and step: \"d \\<turnstile> ev \\<mapsto> c'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> Done\n  trace c (t @ [ev]) c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trace_decomp_tail"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> Done\n  trace c (t @ [ev]) c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "then"], ["proof (chain)\npicking this:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'", "have \"snd (cs d cid) \\<noteq> Done\""], ["proof (prove)\nusing this:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. snd (cs d cid) \\<noteq> Done", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n    \\<Longrightarrow> snd (cs d cid) \\<noteq> Done", "have \"~ RecvMarker cid q p \\<in> set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t", "by auto"], ["proof (state)\nthis:\n  RecvMarker cid q p \\<notin> set t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n    \\<Longrightarrow> snd (cs d cid) \\<noteq> Done", "then"], ["proof (chain)\npicking this:\n  RecvMarker cid q p \\<notin> set t", "show ?thesis"], ["proof (prove)\nusing this:\n  RecvMarker cid q p \\<notin> set t\n\ngoal (1 subgoal):\n 1. snd (cs d cid) \\<noteq> Done", "using snoc ind"], ["proof (prove)\nusing this:\n  RecvMarker cid q p \\<notin> set t\n  \\<lbrakk>trace c t ?c'5; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> Done\n  trace c (t @ [ev]) c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  snd (cs c cid) \\<noteq> Done\n  channel cid = Some (p, q)\n  trace c t d\n\ngoal (1 subgoal):\n 1. snd (cs d cid) \\<noteq> Done", "by blast"], ["proof (state)\nthis:\n  snd (cs d cid) \\<noteq> Done\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (cs d cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    RecvMarker cid q p \\<notin> set xs;\n                    snd (cs c cid) \\<noteq> Done;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done;\n        trace c (xs @ [x]) c'; RecvMarker cid q p \\<notin> set (xs @ [x]);\n        snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "then"], ["proof (chain)\npicking this:\n  snd (cs d cid) \\<noteq> Done", "show ?case"], ["proof (prove)\nusing this:\n  snd (cs d cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> Done", "using done_only_from_recv_marker local.step snoc.prems(2) snoc.prems(4)"], ["proof (prove)\nusing this:\n  snd (cs d cid) \\<noteq> Done\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c'; channel ?cid = Some (?p, ?q);\n   snd (cs ?c ?cid) \\<noteq> Done; snd (cs ?c' ?cid) = Done\\<rbrakk>\n  \\<Longrightarrow> ?ev = RecvMarker ?cid ?q ?p\n  d \\<turnstile> ev \\<mapsto> c'\n  RecvMarker cid q p \\<notin> set (t @ [ev])\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> Done", "by auto"], ["proof (state)\nthis:\n  snd (cs c' cid) \\<noteq> Done\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t c'; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  RecvMarker cid q p \\<notin> set t\n  \\<lbrakk>trace c t c'; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done", "have \"snd (cs c' cid) \\<noteq> Done\""], ["proof (prove)\nusing this:\n  RecvMarker cid q p \\<notin> set t\n  \\<lbrakk>trace c t c'; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> Done", "using assms"], ["proof (prove)\nusing this:\n  RecvMarker cid q p \\<notin> set t\n  \\<lbrakk>trace c t c'; RecvMarker cid q p \\<notin> set t;\n   snd (cs c cid) \\<noteq> Done; channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs c' cid) \\<noteq> Done\n  trace c t c'\n  t \\<noteq> []\n  snd (cs c cid) \\<noteq> Done\n  snd (cs c' cid) = Done\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> Done", "by blast"], ["proof (state)\nthis:\n  snd (cs c' cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. RecvMarker cid q p \\<notin> set t \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  snd (cs c' cid) \\<noteq> Done", "show False"], ["proof (prove)\nusing this:\n  snd (cs c' cid) \\<noteq> Done\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  snd (cs c' cid) \\<noteq> Done\n  trace c t c'\n  t \\<noteq> []\n  snd (cs c cid) \\<noteq> Done\n  snd (cs c' cid) = Done\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cs_not_not_started_stable_trace:\n  shows\n    \"\\<lbrakk> trace c t c'; snd (cs c cid) \\<noteq> NotStarted; channel cid = Some (p, q) \\<rbrakk> \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; snd (cs c cid) \\<noteq> NotStarted;\n     channel cid = Some (p, q)\\<rbrakk>\n    \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "proof (induct t arbitrary:c' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "case Nil"], ["proof (state)\nthis:\n  trace c [] c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n\ngoal (2 subgoals):\n 1. \\<And>c'.\n       \\<lbrakk>trace c [] c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted\n 2. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "then"], ["proof (chain)\npicking this:\n  trace c [] c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)", "show ?case"], ["proof (prove)\nusing this:\n  trace c [] c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> NotStarted", "by (metis list.discI trace.simps)"], ["proof (state)\nthis:\n  snd (cs c' cid) \\<noteq> NotStarted\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "case (snoc ev t)"], ["proof (state)\nthis:\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)", "obtain d where tr: \"trace c t d\" and step: \"d \\<turnstile> ev \\<mapsto> c'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trace_decomp_tail"], ["proof (prove)\nusing this:\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n  trace ?c (?t @ [?ev]) ?c' \\<Longrightarrow>\n  \\<exists>c''. trace ?c ?t c'' \\<and> c'' \\<turnstile> ?ev \\<mapsto> ?c'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>trace c t d; d \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "then"], ["proof (chain)\npicking this:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'", "have \"snd (cs d cid) \\<noteq> NotStarted\""], ["proof (prove)\nusing this:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. snd (cs d cid) \\<noteq> NotStarted", "using snoc"], ["proof (prove)\nusing this:\n  trace c t d\n  d \\<turnstile> ev \\<mapsto> c'\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n\ngoal (1 subgoal):\n 1. snd (cs d cid) \\<noteq> NotStarted", "by blast"], ["proof (state)\nthis:\n  snd (cs d cid) \\<noteq> NotStarted\n\ngoal (1 subgoal):\n 1. \\<And>x xs c'.\n       \\<lbrakk>\\<And>c'.\n                   \\<lbrakk>trace c xs c';\n                    snd (cs c cid) \\<noteq> NotStarted;\n                    channel cid = Some (p, q)\\<rbrakk>\n                   \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted;\n        trace c (xs @ [x]) c'; snd (cs c cid) \\<noteq> NotStarted;\n        channel cid = Some (p, q)\\<rbrakk>\n       \\<Longrightarrow> snd (cs c' cid) \\<noteq> NotStarted", "then"], ["proof (chain)\npicking this:\n  snd (cs d cid) \\<noteq> NotStarted", "show ?case"], ["proof (prove)\nusing this:\n  snd (cs d cid) \\<noteq> NotStarted\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> NotStarted", "using cs_not_not_started_stable snoc step"], ["proof (prove)\nusing this:\n  snd (cs d cid) \\<noteq> NotStarted\n  \\<lbrakk>?c \\<turnstile> ?ev \\<mapsto> ?c';\n   snd (cs ?c ?cid) \\<noteq> NotStarted;\n   channel ?cid = Some (?p, ?q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c' ?cid) \\<noteq> NotStarted\n  \\<lbrakk>trace c t ?c'5; snd (cs c cid) \\<noteq> NotStarted;\n   channel cid = Some (p, q)\\<rbrakk>\n  \\<Longrightarrow> snd (cs ?c'5 cid) \\<noteq> NotStarted\n  trace c (t @ [ev]) c'\n  snd (cs c cid) \\<noteq> NotStarted\n  channel cid = Some (p, q)\n  d \\<turnstile> ev \\<mapsto> c'\n\ngoal (1 subgoal):\n 1. snd (cs c' cid) \\<noteq> NotStarted", "by blast"], ["proof (state)\nthis:\n  snd (cs c' cid) \\<noteq> NotStarted\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_messages_introduced_if_no_channel:\n  assumes\n    trace: \"trace init t final\" and\n    no_msgs_if_no_channel: \"\\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\"\n  shows\n    \"channel cid = None \\<Longrightarrow> msgs (s init t i) cid = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. channel cid = None \\<Longrightarrow> msgs (s init t i) cid = []", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. channel cid = None \\<Longrightarrow> msgs (s init t 0) cid = []\n 2. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "case 0"], ["proof (state)\nthis:\n  channel cid = None\n\ngoal (2 subgoals):\n 1. channel cid = None \\<Longrightarrow> msgs (s init t 0) cid = []\n 2. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "then"], ["proof (chain)\npicking this:\n  channel cid = None", "show ?case"], ["proof (prove)\nusing this:\n  channel cid = None\n\ngoal (1 subgoal):\n 1. msgs (s init t 0) cid = []", "by (metis assms exists_trace_for_any_i no_msgs_if_no_channel take0 tr_init trace_and_start_determines_end)"], ["proof (state)\nthis:\n  msgs (s init t 0) cid = []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "case (Suc n)"], ["proof (state)\nthis:\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "have f: \"trace (s init t n) (take ((Suc n) - n) (drop n t)) (s init t (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace (s init t n) (take (Suc n - n) (drop n t)) (s init t (Suc n))", "using exists_trace_for_any_i_j order_le_less trace assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<exists>c'. trace ?c ?t c'; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> trace (s ?c ?t ?i) (take (?j - ?i) (drop ?i ?t))\n                     (s ?c ?t ?j)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  trace init t final\n  trace init t final\n  \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n\ngoal (1 subgoal):\n 1. trace (s init t n) (take (Suc n - n) (drop n t)) (s init t (Suc n))", "by blast"], ["proof (state)\nthis:\n  trace (s init t n) (take (Suc n - n) (drop n t)) (s init t (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>channel cid = None \\<Longrightarrow>\n                msgs (s init t i) cid = [];\n        channel cid = None\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc i)) cid = []", "then"], ["proof (chain)\npicking this:\n  trace (s init t n) (take (Suc n - n) (drop n t)) (s init t (Suc n))", "show ?case"], ["proof (prove)\nusing this:\n  trace (s init t n) (take (Suc n - n) (drop n t)) (s init t (Suc n))\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "proof (cases \"drop n t = Nil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t = []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case True"], ["proof (state)\nthis:\n  drop n t = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t = []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  drop n t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  drop n t = []\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "using Suc.hyps Suc.prems"], ["proof (prove)\nusing this:\n  drop n t = []\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by (metis f tr_init trace_and_start_determines_end take_Nil)"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case False"], ["proof (state)\nthis:\n  drop n t \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "have suc_n_minus_n: \"Suc n - n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n - n = 1", "by auto"], ["proof (state)\nthis:\n  Suc n - n = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  Suc n - n = 1", "have \"length (take ((Suc n) - n) (drop n t)) = 1\""], ["proof (prove)\nusing this:\n  Suc n - n = 1\n\ngoal (1 subgoal):\n 1. length (take (Suc n - n) (drop n t)) = 1", "using False"], ["proof (prove)\nusing this:\n  Suc n - n = 1\n  drop n t \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (take (Suc n - n) (drop n t)) = 1", "by auto"], ["proof (state)\nthis:\n  length (take (Suc n - n) (drop n t)) = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  length (take (Suc n - n) (drop n t)) = 1", "obtain ev where \"ev # Nil = take ((Suc n) - n) (drop n t)\""], ["proof (prove)\nusing this:\n  length (take (Suc n - n) (drop n t)) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>ev.\n        [ev] = take (Suc n - n) (drop n t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis False One_nat_def suc_n_minus_n length_greater_0_conv self_append_conv2 take_eq_Nil take_hd_drop)"], ["proof (state)\nthis:\n  [ev] = take (Suc n - n) (drop n t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  [ev] = take (Suc n - n) (drop n t)", "have g: \"(s init t n) \\<turnstile> ev \\<mapsto> (s init t (Suc n))\""], ["proof (prove)\nusing this:\n  [ev] = take (Suc n - n) (drop n t)\n\ngoal (1 subgoal):\n 1. s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)", "by (metis f tr_init trace_and_start_determines_end trace_decomp_head)"], ["proof (state)\nthis:\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>trace (s init t n) (take (Suc n - n) (drop n t))\n              (s init t (Suc n));\n     drop n t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)", "show ?thesis"], ["proof (prove)\nusing this:\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "proof (cases ev)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x4.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case (Snapshot r)"], ["proof (state)\nthis:\n  ev = Snapshot r\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x4.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Snapshot x4\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  ev = Snapshot r", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "using Suc.hyps Suc.prems g"], ["proof (prove)\nusing this:\n  ev = Snapshot r\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by auto"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case (RecvMarker cid' sr r)"], ["proof (state)\nthis:\n  ev = RecvMarker cid' sr r\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "have \"cid' \\<noteq> cid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "using RecvMarker can_occur_def g Suc"], ["proof (prove)\nusing this:\n  ev = RecvMarker cid' sr r\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "by auto"], ["proof (state)\nthis:\n  cid' \\<noteq> cid\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 4. \\<And>x51 x52 x53.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = RecvMarker x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "with RecvMarker Suc g"], ["proof (chain)\npicking this:\n  ev = RecvMarker cid' sr r\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  cid' \\<noteq> cid", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = RecvMarker cid' sr r\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  cid' \\<noteq> cid\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by (cases \"has_snapshotted (s init t n) sr\", auto)"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case (Trans r u u')"], ["proof (state)\nthis:\n  ev = Trans r u u'\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12 x13.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Trans x11 x12 x13\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 3. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  ev = Trans r u u'", "show ?thesis"], ["proof (prove)\nusing this:\n  ev = Trans r u u'\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by (metis Suc.hyps Suc.prems g next_trans)"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case (Send cid' r s u u' m)"], ["proof (state)\nthis:\n  ev = Send cid' r s u u' m\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "have \"cid' \\<noteq> cid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "using Send can_occur_def g Suc"], ["proof (prove)\nusing this:\n  ev = Send cid' r s u u' m\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "by auto"], ["proof (state)\nthis:\n  cid' \\<noteq> cid\n\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x23 x24 x25 x26.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Send x21 x22 x23 x24 x25 x26\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []\n 2. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  cid' \\<noteq> cid", "show ?thesis"], ["proof (prove)\nusing this:\n  cid' \\<noteq> cid\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "using Suc g Send"], ["proof (prove)\nusing this:\n  cid' \\<noteq> cid\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  ev = Send cid' r s u u' m\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by simp"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "case (Recv cid' s r u u' m)"], ["proof (state)\nthis:\n  ev = Recv cid' s r u u' m\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "have \"cid' \\<noteq> cid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "using Recv can_occur_def g Suc"], ["proof (prove)\nusing this:\n  ev = Recv cid' s r u u' m\n  can_occur ?ev ?c \\<equiv>\n  case ?ev of Trans p s s' \\<Rightarrow> states ?c p = s \\<and> trans p s s'\n  | Send i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (p, q) \\<and> send i p q s s' msg\n  | Recv i p q s s' msg \\<Rightarrow>\n      states ?c p = s \\<and>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and>\n      hd (msgs ?c i) = Msg msg \\<and> recv i p q s s' msg\n  | Snapshot p \\<Rightarrow> \\<not> ps ?c p \\<noteq> None\n  | RecvMarker i p q \\<Rightarrow>\n      channel i = Some (q, p) \\<and>\n      0 < length (msgs ?c i) \\<and> hd (msgs ?c i) = Marker\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n\ngoal (1 subgoal):\n 1. cid' \\<noteq> cid", "by auto"], ["proof (state)\nthis:\n  cid' \\<noteq> cid\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32 x33 x34 x35 x36.\n       \\<lbrakk>s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n);\n        ev = Recv x31 x32 x33 x34 x35 x36\\<rbrakk>\n       \\<Longrightarrow> msgs (s init t (Suc n)) cid = []", "then"], ["proof (chain)\npicking this:\n  cid' \\<noteq> cid", "show ?thesis"], ["proof (prove)\nusing this:\n  cid' \\<noteq> cid\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "using Suc g Recv"], ["proof (prove)\nusing this:\n  cid' \\<noteq> cid\n  channel cid = None \\<Longrightarrow> msgs (s init t n) cid = []\n  channel cid = None\n  s init t n \\<turnstile> ev \\<mapsto> s init t (Suc n)\n  ev = Recv cid' s r u u' m\n\ngoal (1 subgoal):\n 1. msgs (s init t (Suc n)) cid = []", "by simp"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  msgs (s init t (Suc n)) cid = []\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context distributed_system *)"], ["", "end"], ["", "(* theory Trace *)"]]}