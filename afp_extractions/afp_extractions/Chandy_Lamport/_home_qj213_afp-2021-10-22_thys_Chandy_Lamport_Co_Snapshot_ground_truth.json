{"file_name": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport/Co_Snapshot.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Chandy_Lamport", "problem_names": ["lemma ltake_LNil[simp]: \"ltake i LNil = []\"", "lemma ltake_LCons: \"0 < i \\<Longrightarrow> ltake i (LCons x t) = x # ltake (i - 1) t\"", "lemma take_ltake: \"i \\<le> j \\<Longrightarrow> take i (ltake j xs) = ltake i xs\"", "lemma nth_ltake [simp]: \"i < min n (llength xs) \\<Longrightarrow> (ltake n xs) ! i = lnth xs i\"", "lemma length_ltake[simp]: \"length (ltake i xs) = (case llength xs of \\<infinity> \\<Rightarrow> i | enat m \\<Rightarrow> min i m)\"", "lemma ltake_prepend:\n  \"ltake i (prepend xs t) = (if i \\<le> length xs then take i xs else xs @ ltake (i - length xs) t)\"", "lemma prepend_ltake_ldrop_id: \"prepend (ltake i t) (ldrop i t) = t\"", "lemma cotrace_trace: \"cotrace c t \\<Longrightarrow> \\<exists>!c'. trace c (ltake i t) c'\"", "lemma cotrace_trace': \"cotrace c t \\<Longrightarrow> \\<exists>c'. trace c (ltake i t) c'\"", "lemma cotrace_trace_cos: \"cotrace c t \\<Longrightarrow> trace c (ltake i t) (cos c t i)\"", "lemma s_0[simp]: \"s c t 0 = c\"", "lemma s_chop: \"i \\<le> length t \\<Longrightarrow> s c t i = s c (take i t) i\"", "lemma cotrace_prepend: \"trace c t c' \\<Longrightarrow> cotrace c' u \\<Longrightarrow> cotrace c (prepend t u)\"", "lemma s_Cons: \"\\<exists>c''. trace c' xs c'' \\<Longrightarrow> c \\<turnstile> ev \\<mapsto> c' \\<Longrightarrow> s c (ev # xs) (Suc i) = s c' xs i\"", "lemma cotrace_ldrop: \"cotrace c t \\<Longrightarrow> i \\<le> llength t \\<Longrightarrow> cotrace (cos c t i) (ldrop i t)\"", "lemma has_snapshotted: \n  \"cotrace init t \\<Longrightarrow> has_snapshotted (coS t (some_snapshot t p)) p \\<and> some_snapshot t p \\<le> llength t\"", "lemma cotrace_cos: \"cotrace init t \\<Longrightarrow> j < llength t \\<Longrightarrow> \n  (coS t j) \\<turnstile> lnth t j \\<mapsto> (coS t (Suc j))\"", "lemma snapshot_stable:\n  \"cotrace init t \\<Longrightarrow> i \\<le> j \\<Longrightarrow> has_snapshotted (coS t i) p \\<Longrightarrow> has_snapshotted (coS t j) p\"", "lemma no_markers_if_all_snapshotted:\n  \"cotrace init t \\<Longrightarrow> i \\<le> j \\<Longrightarrow> \\<forall>p. has_snapshotted (coS t i) p \\<Longrightarrow>\n      Marker \\<notin> set (msgs (coS t i) c) \\<Longrightarrow> Marker \\<notin> set (msgs (coS t j) c)\"", "lemma cotrace_all_have_snapshotted:\n  assumes \"cotrace init t\"\n  shows \"\\<exists>i \\<le> llength t. \\<forall>p. has_snapshotted (coS t i) p\"", "lemma no_messages_if_no_channel:\n  assumes \"cotrace init t\"\n  shows \"channel cid = None \\<Longrightarrow> msgs (coS t i) cid = []\"", "lemma cotrace_all_have_snapshotted_and_no_markers:\n  assumes \"cotrace init t\"\n  shows \"\\<exists>i \\<le> llength t. (\\<forall>p. has_snapshotted (coS t i) p) \\<and> \n                         (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\"", "lemma final_i: \"final_i \\<le> llength t\" \"(\\<forall>p. has_snapshotted (coS t final_i) p)\" \"(\\<forall>c. Marker \\<notin> set (msgs (coS t final_i) c))\"", "lemma final: \"\\<exists>t. trace init t final\" \"(\\<forall>p. has_snapshotted final p)\" \"(\\<forall>c. Marker \\<notin> set (msgs final c))\"", "lemma copermIL: \"perm ys xs \\<Longrightarrow> t = prepend xs z \\<Longrightarrow> coperm (prepend ys z) t\"", "lemma snapshot_algorithm_is_cocorrect:\n  \"\\<exists>t' i. cotrace init t' \\<and> coperm t' t \\<and> state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i\""], "translations": [["", "lemma ltake_LNil[simp]: \"ltake i LNil = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Co_Snapshot.ltake i LNil = []", "by (induct i) auto"], ["", "lemma ltake_LCons: \"0 < i \\<Longrightarrow> ltake i (LCons x t) = x # ltake (i - 1) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow>\n    Co_Snapshot.ltake i (LCons x t) = x # Co_Snapshot.ltake (i - 1) t", "by (induct i) auto"], ["", "lemma take_ltake: \"i \\<le> j \\<Longrightarrow> take i (ltake j xs) = ltake i xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    take i (Co_Snapshot.ltake j xs) = Co_Snapshot.ltake i xs", "by (induct j arbitrary: i xs) (auto simp: le_Suc_eq take_Cons' ltake_LCons split: llist.splits if_splits)"], ["", "lemma nth_ltake [simp]: \"i < min n (llength xs) \\<Longrightarrow> (ltake n xs) ! i = lnth xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < min (enat n) (llength xs) \\<Longrightarrow>\n    Co_Snapshot.ltake n xs ! i = lnth xs i", "by (induct n arbitrary: i xs)\n    (auto simp: nth_Cons' gr0_conv_Suc eSuc_enat[symmetric] split: llist.splits)"], ["", "lemma length_ltake[simp]: \"length (ltake i xs) = (case llength xs of \\<infinity> \\<Rightarrow> i | enat m \\<Rightarrow> min i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (Co_Snapshot.ltake i xs) =\n    (case llength xs of enat m \\<Rightarrow> min i m\n     | \\<infinity> \\<Rightarrow> i)", "by (induct i arbitrary: xs)\n    (auto simp: zero_enat_def[symmetric] eSuc_enat split: llist.splits enat.splits)"], ["", "lemma ltake_prepend:\n  \"ltake i (prepend xs t) = (if i \\<le> length xs then take i xs else xs @ ltake (i - length xs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Co_Snapshot.ltake i (prepend xs t) =\n    (if i \\<le> length xs then take i xs\n     else xs @ Co_Snapshot.ltake (i - length xs) t)", "proof (induct i arbitrary: xs t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs t.\n       Co_Snapshot.ltake 0 (prepend xs t) =\n       (if 0 \\<le> length xs then take 0 xs\n        else xs @ Co_Snapshot.ltake (0 - length xs) t)\n 2. \\<And>i xs t.\n       (\\<And>xs t.\n           Co_Snapshot.ltake i (prepend xs t) =\n           (if i \\<le> length xs then take i xs\n            else xs @\n                 Co_Snapshot.ltake (i - length xs) t)) \\<Longrightarrow>\n       Co_Snapshot.ltake (Suc i) (prepend xs t) =\n       (if Suc i \\<le> length xs then take (Suc i) xs\n        else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs t.\n       Co_Snapshot.ltake 0 (prepend xs t) =\n       (if 0 \\<le> length xs then take 0 xs\n        else xs @ Co_Snapshot.ltake (0 - length xs) t)\n 2. \\<And>i xs t.\n       (\\<And>xs t.\n           Co_Snapshot.ltake i (prepend xs t) =\n           (if i \\<le> length xs then take i xs\n            else xs @\n                 Co_Snapshot.ltake (i - length xs) t)) \\<Longrightarrow>\n       Co_Snapshot.ltake (Suc i) (prepend xs t) =\n       (if Suc i \\<le> length xs then take (Suc i) xs\n        else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Co_Snapshot.ltake 0 (prepend xs t) =\n    (if 0 \\<le> length xs then take 0 xs\n     else xs @ Co_Snapshot.ltake (0 - length xs) t)", "by (cases xs) auto"], ["proof (state)\nthis:\n  Co_Snapshot.ltake 0 (prepend xs t) =\n  (if 0 \\<le> length xs then take 0 xs\n   else xs @ Co_Snapshot.ltake (0 - length xs) t)\n\ngoal (1 subgoal):\n 1. \\<And>i xs t.\n       (\\<And>xs t.\n           Co_Snapshot.ltake i (prepend xs t) =\n           (if i \\<le> length xs then take i xs\n            else xs @\n                 Co_Snapshot.ltake (i - length xs) t)) \\<Longrightarrow>\n       Co_Snapshot.ltake (Suc i) (prepend xs t) =\n       (if Suc i \\<le> length xs then take (Suc i) xs\n        else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i xs t.\n       (\\<And>xs t.\n           Co_Snapshot.ltake i (prepend xs t) =\n           (if i \\<le> length xs then take i xs\n            else xs @\n                 Co_Snapshot.ltake (i - length xs) t)) \\<Longrightarrow>\n       Co_Snapshot.ltake (Suc i) (prepend xs t) =\n       (if Suc i \\<le> length xs then take (Suc i) xs\n        else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "case (Suc i)"], ["proof (state)\nthis:\n  Co_Snapshot.ltake i (prepend ?xs ?t) =\n  (if i \\<le> length ?xs then take i ?xs\n   else ?xs @ Co_Snapshot.ltake (i - length ?xs) ?t)\n\ngoal (1 subgoal):\n 1. \\<And>i xs t.\n       (\\<And>xs t.\n           Co_Snapshot.ltake i (prepend xs t) =\n           (if i \\<le> length xs then take i xs\n            else xs @\n                 Co_Snapshot.ltake (i - length xs) t)) \\<Longrightarrow>\n       Co_Snapshot.ltake (Suc i) (prepend xs t) =\n       (if Suc i \\<le> length xs then take (Suc i) xs\n        else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "then"], ["proof (chain)\npicking this:\n  Co_Snapshot.ltake i (prepend ?xs ?t) =\n  (if i \\<le> length ?xs then take i ?xs\n   else ?xs @ Co_Snapshot.ltake (i - length ?xs) ?t)", "show ?case"], ["proof (prove)\nusing this:\n  Co_Snapshot.ltake i (prepend ?xs ?t) =\n  (if i \\<le> length ?xs then take i ?xs\n   else ?xs @ Co_Snapshot.ltake (i - length ?xs) ?t)\n\ngoal (1 subgoal):\n 1. Co_Snapshot.ltake (Suc i) (prepend xs t) =\n    (if Suc i \\<le> length xs then take (Suc i) xs\n     else xs @ Co_Snapshot.ltake (Suc i - length xs) t)", "by (cases xs) auto"], ["proof (state)\nthis:\n  Co_Snapshot.ltake (Suc i) (prepend xs t) =\n  (if Suc i \\<le> length xs then take (Suc i) xs\n   else xs @ Co_Snapshot.ltake (Suc i - length xs) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prepend_ltake_ldrop_id: \"prepend (ltake i t) (ldrop i t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepend (Co_Snapshot.ltake i t) (Co_Snapshot.ldrop i t) = t", "by (induct i arbitrary: t) (auto split: llist.splits)"], ["", "context distributed_system\nbegin"], ["", "coinductive cotrace where\n    cotr_init: \"cotrace c LNil\"\n  | cotr_step: \"\\<lbrakk> c \\<turnstile> ev \\<mapsto> c'; cotrace c' t \\<rbrakk> \\<Longrightarrow> cotrace c (LCons ev t)\""], ["", "lemma cotrace_trace: \"cotrace c t \\<Longrightarrow> \\<exists>!c'. trace c (ltake i t) c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace c t \\<Longrightarrow>\n    \\<exists>!c'. trace c (Co_Snapshot.ltake i t) c'", "proof (induct i arbitrary: c t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c t.\n       cotrace c t \\<Longrightarrow> Ex1 (trace c (Co_Snapshot.ltake 0 t))\n 2. \\<And>i c t.\n       \\<lbrakk>\\<And>c t.\n                   cotrace c t \\<Longrightarrow>\n                   Ex1 (trace c (Co_Snapshot.ltake i t));\n        cotrace c t\\<rbrakk>\n       \\<Longrightarrow> Ex1 (trace c (Co_Snapshot.ltake (Suc i) t))", "case (Suc i)"], ["proof (state)\nthis:\n  cotrace ?c5 ?t5 \\<Longrightarrow>\n  \\<exists>!a. trace ?c5 (Co_Snapshot.ltake i ?t5) a\n  cotrace c t\n\ngoal (2 subgoals):\n 1. \\<And>c t.\n       cotrace c t \\<Longrightarrow> Ex1 (trace c (Co_Snapshot.ltake 0 t))\n 2. \\<And>i c t.\n       \\<lbrakk>\\<And>c t.\n                   cotrace c t \\<Longrightarrow>\n                   Ex1 (trace c (Co_Snapshot.ltake i t));\n        cotrace c t\\<rbrakk>\n       \\<Longrightarrow> Ex1 (trace c (Co_Snapshot.ltake (Suc i) t))", "then"], ["proof (chain)\npicking this:\n  cotrace ?c5 ?t5 \\<Longrightarrow>\n  \\<exists>!a. trace ?c5 (Co_Snapshot.ltake i ?t5) a\n  cotrace c t", "show ?case"], ["proof (prove)\nusing this:\n  cotrace ?c5 ?t5 \\<Longrightarrow>\n  \\<exists>!a. trace ?c5 (Co_Snapshot.ltake i ?t5) a\n  cotrace c t\n\ngoal (1 subgoal):\n 1. \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                cotrace c t \\<Longrightarrow>\n                \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n     cotrace c t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   cotrace c t \\<Longrightarrow>\n                   \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n        cotrace c t; t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            trace c (Co_Snapshot.ltake (Suc i) t) a", "case (LCons ev t')"], ["proof (state)\nthis:\n  t = LCons ev t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                cotrace c t \\<Longrightarrow>\n                \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n     cotrace c t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   cotrace c t \\<Longrightarrow>\n                   \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n        cotrace c t; t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            trace c (Co_Snapshot.ltake (Suc i) t) a", "with Suc(2)"], ["proof (chain)\npicking this:\n  cotrace c t\n  t = LCons ev t'", "obtain c' where \"c \\<turnstile> ev \\<mapsto> c'\" \"cotrace c' t'\""], ["proof (prove)\nusing this:\n  cotrace c t\n  t = LCons ev t'\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; cotrace c' t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: cotrace.cases)"], ["proof (state)\nthis:\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                cotrace c t \\<Longrightarrow>\n                \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n     cotrace c t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   cotrace c t \\<Longrightarrow>\n                   \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n        cotrace c t; t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a.\n                            trace c (Co_Snapshot.ltake (Suc i) t) a", "with Suc(1)[OF \\<open>cotrace c' t'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>!a. trace c' (Co_Snapshot.ltake i t') a\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!a. trace c' (Co_Snapshot.ltake i t') a\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'\n\ngoal (1 subgoal):\n 1. \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a", "by (auto simp: LCons elim: trace.intros(2) elim: trace.cases trace_and_start_determines_end)"], ["proof (state)\nthis:\n  \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c t.\n                cotrace c t \\<Longrightarrow>\n                \\<exists>!a. trace c (Co_Snapshot.ltake i t) a;\n     cotrace c t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a", "qed (auto intro: trace.intros elim: trace.cases)"], ["proof (state)\nthis:\n  \\<exists>!a. trace c (Co_Snapshot.ltake (Suc i) t) a\n\ngoal (1 subgoal):\n 1. \\<And>c t.\n       cotrace c t \\<Longrightarrow> Ex1 (trace c (Co_Snapshot.ltake 0 t))", "qed (auto simp: zero_enat_def[symmetric] intro: trace.intros elim: trace.cases)"], ["", "lemma cotrace_trace': \"cotrace c t \\<Longrightarrow> \\<exists>c'. trace c (ltake i t) c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace c t \\<Longrightarrow>\n    \\<exists>c'. trace c (Co_Snapshot.ltake i t) c'", "by (metis cotrace_trace)"], ["", "definition cos where \"cos c t i = s c (ltake i t) i\""], ["", "lemma cotrace_trace_cos: \"cotrace c t \\<Longrightarrow> trace c (ltake i t) (cos c t i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace c t \\<Longrightarrow>\n    trace c (Co_Snapshot.ltake i t) (local.cos c t i)", "unfolding cos_def s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace c t \\<Longrightarrow>\n    trace c (Co_Snapshot.ltake i t)\n     (The (trace c (take i (Co_Snapshot.ltake i t))))", "by (subst take_ltake, auto dest!: cotrace_trace[of _ _ i] elim!: theI')"], ["", "lemma s_0[simp]: \"s c t 0 = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s c t 0 = c", "unfolding s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. The (trace c (take 0 t)) = c", "by (auto intro!: the_equality[where P = \"trace c []\"] trace.intros elim: trace.cases)"], ["", "lemma s_chop: \"i \\<le> length t \\<Longrightarrow> s c t i = s c (take i t) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length t \\<Longrightarrow> s c t i = s c (take i t) i", "unfolding s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length t \\<Longrightarrow>\n    The (trace c (take i t)) = The (trace c (take i (take i t)))", "by auto"], ["", "lemma cotrace_prepend: \"trace c t c' \\<Longrightarrow> cotrace c' u \\<Longrightarrow> cotrace c (prepend t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace c t c'; cotrace c' u\\<rbrakk>\n    \\<Longrightarrow> cotrace c (prepend t u)", "by (induct c t c' rule: trace.induct) (auto intro: cotrace.intros)"], ["", "lemma s_Cons: \"\\<exists>c''. trace c' xs c'' \\<Longrightarrow> c \\<turnstile> ev \\<mapsto> c' \\<Longrightarrow> s c (ev # xs) (Suc i) = s c' xs i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>c''. trace c' xs c'';\n     c \\<turnstile> ev \\<mapsto> c'\\<rbrakk>\n    \\<Longrightarrow> s c (ev # xs) (Suc i) = s c' xs i", "by (smt exists_trace_for_any_i take_Suc_Cons tr_step trace_and_start_determines_end)"], ["", "lemma cotrace_ldrop: \"cotrace c t \\<Longrightarrow> i \\<le> llength t \\<Longrightarrow> cotrace (cos c t i) (ldrop i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n    \\<Longrightarrow> cotrace (local.cos c t i) (Co_Snapshot.ldrop i t)", "proof (induct i arbitrary: c t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c t.\n       \\<lbrakk>cotrace c t; enat 0 \\<le> llength t\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t 0) (Co_Snapshot.ldrop 0 t)\n 2. \\<And>i c t.\n       \\<lbrakk>\\<And>c t.\n                   \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                   \\<Longrightarrow> cotrace (local.cos c t i)\n(Co_Snapshot.ldrop i t);\n        cotrace c t; enat (Suc i) \\<le> llength t\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                          (Co_Snapshot.ldrop (Suc i) t)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>cotrace ?c5 ?t5; enat i \\<le> llength ?t5\\<rbrakk>\n  \\<Longrightarrow> cotrace (local.cos ?c5 ?t5 i) (Co_Snapshot.ldrop i ?t5)\n  cotrace c t\n  enat (Suc i) \\<le> llength t\n\ngoal (2 subgoals):\n 1. \\<And>c t.\n       \\<lbrakk>cotrace c t; enat 0 \\<le> llength t\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t 0) (Co_Snapshot.ldrop 0 t)\n 2. \\<And>i c t.\n       \\<lbrakk>\\<And>c t.\n                   \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                   \\<Longrightarrow> cotrace (local.cos c t i)\n(Co_Snapshot.ldrop i t);\n        cotrace c t; enat (Suc i) \\<le> llength t\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                          (Co_Snapshot.ldrop (Suc i) t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>cotrace ?c5 ?t5; enat i \\<le> llength ?t5\\<rbrakk>\n  \\<Longrightarrow> cotrace (local.cos ?c5 ?t5 i) (Co_Snapshot.ldrop i ?t5)\n  cotrace c t\n  enat (Suc i) \\<le> llength t", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>cotrace ?c5 ?t5; enat i \\<le> llength ?t5\\<rbrakk>\n  \\<Longrightarrow> cotrace (local.cos ?c5 ?t5 i) (Co_Snapshot.ldrop i ?t5)\n  cotrace c t\n  enat (Suc i) \\<le> llength t\n\ngoal (1 subgoal):\n 1. cotrace (local.cos c t (Suc i)) (Co_Snapshot.ldrop (Suc i) t)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                \\<Longrightarrow> cotrace (local.cos c t i)\n                                   (Co_Snapshot.ldrop i t);\n     cotrace c t; enat (Suc i) \\<le> llength t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                       (Co_Snapshot.ldrop (Suc i) t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                   \\<Longrightarrow> cotrace (local.cos c t i)\n(Co_Snapshot.ldrop i t);\n        cotrace c t; enat (Suc i) \\<le> llength t;\n        t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                          (Co_Snapshot.ldrop (Suc i) t)", "case (LCons ev t')"], ["proof (state)\nthis:\n  t = LCons ev t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                \\<Longrightarrow> cotrace (local.cos c t i)\n                                   (Co_Snapshot.ldrop i t);\n     cotrace c t; enat (Suc i) \\<le> llength t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                       (Co_Snapshot.ldrop (Suc i) t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                   \\<Longrightarrow> cotrace (local.cos c t i)\n(Co_Snapshot.ldrop i t);\n        cotrace c t; enat (Suc i) \\<le> llength t;\n        t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                          (Co_Snapshot.ldrop (Suc i) t)", "with Suc(2)"], ["proof (chain)\npicking this:\n  cotrace c t\n  t = LCons ev t'", "obtain c' where \"c \\<turnstile> ev \\<mapsto> c'\" \"cotrace c' t'\""], ["proof (prove)\nusing this:\n  cotrace c t\n  t = LCons ev t'\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>c \\<turnstile> ev \\<mapsto> c'; cotrace c' t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: cotrace.cases)"], ["proof (state)\nthis:\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c t.\n                \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                \\<Longrightarrow> cotrace (local.cos c t i)\n                                   (Co_Snapshot.ldrop i t);\n     cotrace c t; enat (Suc i) \\<le> llength t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                       (Co_Snapshot.ldrop (Suc i) t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>c t.\n                   \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                   \\<Longrightarrow> cotrace (local.cos c t i)\n(Co_Snapshot.ldrop i t);\n        cotrace c t; enat (Suc i) \\<le> llength t;\n        t = LCons x21 x22\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                          (Co_Snapshot.ldrop (Suc i) t)", "with Suc(1)[OF \\<open>cotrace c' t'\\<close>] Suc(3)"], ["proof (chain)\npicking this:\n  enat i \\<le> llength t' \\<Longrightarrow>\n  cotrace (local.cos c' t' i) (Co_Snapshot.ldrop i t')\n  enat (Suc i) \\<le> llength t\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'", "show ?thesis"], ["proof (prove)\nusing this:\n  enat i \\<le> llength t' \\<Longrightarrow>\n  cotrace (local.cos c' t' i) (Co_Snapshot.ldrop i t')\n  enat (Suc i) \\<le> llength t\n  c \\<turnstile> ev \\<mapsto> c'\n  cotrace c' t'\n\ngoal (1 subgoal):\n 1. cotrace (local.cos c t (Suc i)) (Co_Snapshot.ldrop (Suc i) t)", "by (auto simp: LCons cos_def eSuc_enat[symmetric] s_chop[symmetric] s_Cons[OF cotrace_trace'])"], ["proof (state)\nthis:\n  cotrace (local.cos c t (Suc i)) (Co_Snapshot.ldrop (Suc i) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c t.\n                \\<lbrakk>cotrace c t; enat i \\<le> llength t\\<rbrakk>\n                \\<Longrightarrow> cotrace (local.cos c t i)\n                                   (Co_Snapshot.ldrop i t);\n     cotrace c t; enat (Suc i) \\<le> llength t; t = LNil\\<rbrakk>\n    \\<Longrightarrow> cotrace (local.cos c t (Suc i))\n                       (Co_Snapshot.ldrop (Suc i) t)", "qed (auto intro: cotrace.intros)"], ["proof (state)\nthis:\n  cotrace (local.cos c t (Suc i)) (Co_Snapshot.ldrop (Suc i) t)\n\ngoal (1 subgoal):\n 1. \\<And>c t.\n       \\<lbrakk>cotrace c t; enat 0 \\<le> llength t\\<rbrakk>\n       \\<Longrightarrow> cotrace (local.cos c t 0) (Co_Snapshot.ldrop 0 t)", "qed (auto simp: zero_enat_def[symmetric] cos_def intro: cotrace.intros)"], ["", "end"], ["", "locale cocomputation = distributed_system +\n  fixes\n    init :: \"('a, 'b, 'c) configuration\"\n  assumes\n    finite_channels:\n      \"finite {i. \\<exists>p q. channel i = Some (p, q)}\" and\n    strongly_connected_raw:\n      \"\\<forall>p q. (p \\<noteq> q) \\<longrightarrow>\n         (tranclp (\\<lambda>p q. (\\<exists>i. channel i = Some (p, q)))) p q\" and\n\n    at_least_two_processes:\n      \"card (UNIV :: 'a set) > 1\" and\n    finite_processes:\n      \"finite (UNIV :: 'a set)\" and\n\n    no_initial_Marker:\n      \"\\<forall>i. (\\<exists>p q. channel i = Some (p, q))\n      \\<longrightarrow> Marker \\<notin> set (msgs init i)\" and\n    no_msgs_if_no_channel:\n      \"\\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\" and\n    no_initial_process_snapshot:\n      \"\\<forall>p. \\<not> has_snapshotted init p\" and\n    no_initial_channel_snapshot:\n      \"\\<forall>i. channel_snapshot init i = ([], NotStarted)\" and\n\n    valid: \"\\<exists>t. cotrace init t\" and\n    l1: \"\\<forall>t i cid. cotrace init t\n                 \\<and> Marker \\<in> set (msgs (cos init t i) cid)\n      \\<longrightarrow> (\\<exists>j \\<le> llength t. j \\<ge> i \\<and> Marker \\<notin> set (msgs (cos init t j) cid))\" and\n    l2: \"\\<forall>t p. cotrace init t\n      \\<longrightarrow> (\\<exists>i \\<le> llength t. has_snapshotted (cos init t i) p)\"\nbegin"], ["", "abbreviation coS where \"coS \\<equiv> cos init\""], ["", "definition \"some_snapshot t p = (SOME i. has_snapshotted (coS t i) p \\<and> i \\<le> llength t)\""], ["", "lemma has_snapshotted: \n  \"cotrace init t \\<Longrightarrow> has_snapshotted (coS t (some_snapshot t p)) p \\<and> some_snapshot t p \\<le> llength t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace init t \\<Longrightarrow>\n    ps (coS t (some_snapshot t p)) p \\<noteq> None \\<and>\n    enat (some_snapshot t p) \\<le> llength t", "unfolding some_snapshot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace init t \\<Longrightarrow>\n    ps (coS t\n         (SOME i.\n             ps (coS t i) p \\<noteq> None \\<and> enat i \\<le> llength t))\n     p \\<noteq>\n    None \\<and>\n    enat\n     (SOME i. ps (coS t i) p \\<noteq> None \\<and> enat i \\<le> llength t)\n    \\<le> llength t", "by (rule someI_ex) (auto dest!: l2[rule_format])"], ["", "lemma cotrace_cos: \"cotrace init t \\<Longrightarrow> j < llength t \\<Longrightarrow> \n  (coS t j) \\<turnstile> lnth t j \\<mapsto> (coS t (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cotrace init t; enat j < llength t\\<rbrakk>\n    \\<Longrightarrow> coS t j \\<turnstile> lnth t j \\<mapsto> coS t (Suc j)", "apply (drule cotrace_trace_cos[of _ _ \"Suc j\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat j < llength t;\n     trace init (Co_Snapshot.ltake (Suc j) t) (coS t (Suc j))\\<rbrakk>\n    \\<Longrightarrow> coS t j \\<turnstile> lnth t j \\<mapsto> coS t (Suc j)", "apply (drule step_Suc[rotated, of _ _ _ \"j\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. enat j < llength t \\<Longrightarrow>\n    j < length (Co_Snapshot.ltake (Suc j) t)\n 2. \\<lbrakk>enat j < llength t;\n     s init (Co_Snapshot.ltake (Suc j) t)\n      j \\<turnstile> Co_Snapshot.ltake (Suc j) t !\n                     j \\<mapsto> s init (Co_Snapshot.ltake (Suc j) t)\n                                  (Suc j)\\<rbrakk>\n    \\<Longrightarrow> coS t j \\<turnstile> lnth t j \\<mapsto> coS t (Suc j)", "apply (auto split: enat.splits llist.splits) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat j < llength t;\n     s init (Co_Snapshot.ltake (Suc j) t)\n      j \\<turnstile> Co_Snapshot.ltake (Suc j) t !\n                     j \\<mapsto> s init (Co_Snapshot.ltake (Suc j) t)\n                                  (Suc j)\\<rbrakk>\n    \\<Longrightarrow> coS t j \\<turnstile> lnth t j \\<mapsto> coS t (Suc j)", "apply (auto simp: s_chop[of j \"_ # ltake j _\"] cos_def nth_Cons' ltake_LCons lnth_LCons'\n    take_Cons' take_ltake\n    split: llist.splits enat.splits if_splits elim: order.strict_trans2[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j;\n        s init (x21 # Co_Snapshot.ltake j x22)\n         j \\<turnstile> Co_Snapshot.ltake j x22 !\n                        (j -\n                         Suc 0) \\<mapsto> s init\n     (x21 # Co_Snapshot.ltake j x22) (Suc j)\\<rbrakk>\n       \\<Longrightarrow> s init (x21 # Co_Snapshot.ltake (j - Suc 0) x22)\n                          j \\<turnstile> lnth x22\n    (j - Suc 0) \\<mapsto> s init (x21 # Co_Snapshot.ltake j x22) (Suc j)", "apply (subst (asm) nth_ltake)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j\\<rbrakk>\n       \\<Longrightarrow> enat (j - Suc 0) < min (enat j) (llength x22)\n 2. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j;\n        s init (x21 # Co_Snapshot.ltake j x22)\n         j \\<turnstile> lnth x22\n                         (j -\n                          Suc 0) \\<mapsto> s init\n      (x21 # Co_Snapshot.ltake j x22) (Suc j)\\<rbrakk>\n       \\<Longrightarrow> s init (x21 # Co_Snapshot.ltake (j - Suc 0) x22)\n                          j \\<turnstile> lnth x22\n    (j - Suc 0) \\<mapsto> s init (x21 # Co_Snapshot.ltake j x22) (Suc j)", "apply (auto elim!: order.strict_trans2[rotated]) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j;\n        s init (x21 # Co_Snapshot.ltake j x22)\n         j \\<turnstile> lnth x22\n                         (j -\n                          Suc 0) \\<mapsto> s init\n      (x21 # Co_Snapshot.ltake j x22) (Suc j)\\<rbrakk>\n       \\<Longrightarrow> s init (x21 # Co_Snapshot.ltake (j - Suc 0) x22)\n                          j \\<turnstile> lnth x22\n    (j - Suc 0) \\<mapsto> s init (x21 # Co_Snapshot.ltake j x22) (Suc j)", "apply (subst (asm) s_chop[of j \"_ # ltake j _\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j\\<rbrakk>\n       \\<Longrightarrow> j \\<le> length (x21 # Co_Snapshot.ltake j x22)\n 2. \\<And>x21 x22.\n       \\<lbrakk>enat j \\<le> llength x22; t = LCons x21 x22; 0 < j;\n        s init (take j (x21 # Co_Snapshot.ltake j x22))\n         j \\<turnstile> lnth x22\n                         (j -\n                          Suc 0) \\<mapsto> s init\n      (x21 # Co_Snapshot.ltake j x22) (Suc j)\\<rbrakk>\n       \\<Longrightarrow> s init (x21 # Co_Snapshot.ltake (j - Suc 0) x22)\n                          j \\<turnstile> lnth x22\n    (j - Suc 0) \\<mapsto> s init (x21 # Co_Snapshot.ltake j x22) (Suc j)", "apply (auto simp: take_Cons' take_ltake split: enat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snapshot_stable:\n  \"cotrace init t \\<Longrightarrow> i \\<le> j \\<Longrightarrow> has_snapshotted (coS t i) p \\<Longrightarrow> has_snapshotted (coS t j) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cotrace init t; i \\<le> j;\n     ps (coS t i) p \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> ps (coS t j) p \\<noteq> None", "apply (drule cotrace_trace_cos[of _ _ j])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; ps (coS t i) p \\<noteq> None;\n     trace init (Co_Snapshot.ltake j t) (coS t j)\\<rbrakk>\n    \\<Longrightarrow> ps (coS t j) p \\<noteq> None", "unfolding cos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j;\n     ps (s init (Co_Snapshot.ltake i t) i) p \\<noteq> None;\n     trace init (Co_Snapshot.ltake j t)\n      (s init (Co_Snapshot.ltake j t) j)\\<rbrakk>\n    \\<Longrightarrow> ps (s init (Co_Snapshot.ltake j t) j) p \\<noteq> None", "by (metis exists_trace_for_any_i_j order_refl s_def snapshot_stable take_ltake)"], ["", "lemma no_markers_if_all_snapshotted:\n  \"cotrace init t \\<Longrightarrow> i \\<le> j \\<Longrightarrow> \\<forall>p. has_snapshotted (coS t i) p \\<Longrightarrow>\n      Marker \\<notin> set (msgs (coS t i) c) \\<Longrightarrow> Marker \\<notin> set (msgs (coS t j) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cotrace init t; i \\<le> j;\n     \\<forall>p. ps (coS t i) p \\<noteq> None;\n     Marker \\<notin> set (msgs (coS t i) c)\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t j) c)", "apply (drule cotrace_trace_cos[of _ _ j])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; \\<forall>p. ps (coS t i) p \\<noteq> None;\n     Marker \\<notin> set (msgs (coS t i) c);\n     trace init (Co_Snapshot.ltake j t) (coS t j)\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t j) c)", "unfolding cos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j;\n     \\<forall>p. ps (s init (Co_Snapshot.ltake i t) i) p \\<noteq> None;\n     Marker \\<notin> set (msgs (s init (Co_Snapshot.ltake i t) i) c);\n     trace init (Co_Snapshot.ltake j t)\n      (s init (Co_Snapshot.ltake j t) j)\\<rbrakk>\n    \\<Longrightarrow> Marker\n                      \\<notin> set (msgs (s init (Co_Snapshot.ltake j t) j)\n                                     c)", "by (metis exists_trace_for_any_i_j no_markers_if_all_snapshotted order_refl s_def take_ltake)"], ["", "lemma cotrace_all_have_snapshotted:\n  assumes \"cotrace init t\"\n  shows \"\\<exists>i \\<le> llength t. \\<forall>p. has_snapshotted (coS t i) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None)", "let ?i = \"Max (range (some_snapshot t))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None)", "using has_snapshotted[OF assms] snapshot_stable[OF assms, of \"some_snapshot t _\" ?i _]"], ["proof (prove)\nusing this:\n  ps (coS t (some_snapshot t ?p)) ?p \\<noteq> None \\<and>\n  enat (some_snapshot t ?p) \\<le> llength t\n  \\<lbrakk>some_snapshot t ?uu8 \\<le> Max (range (some_snapshot t));\n   ps (coS t (some_snapshot t ?uu8)) ?p \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ps (coS t (Max (range (some_snapshot t)))) ?p \\<noteq>\n                    None\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None)", "apply (intro exI[of _ ?i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p.\n                ps (coS t (some_snapshot t p)) p \\<noteq> None \\<and>\n                enat (some_snapshot t p) \\<le> llength t;\n     \\<And>uu p.\n        \\<lbrakk>some_snapshot t uu \\<le> Max (range (some_snapshot t));\n         ps (coS t (some_snapshot t uu)) p \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> ps (coS t (Max (range (some_snapshot t))))\n                           p \\<noteq>\n                          None\\<rbrakk>\n    \\<Longrightarrow> enat (Max (range (some_snapshot t)))\n                      \\<le> llength t \\<and>\n                      (\\<forall>p.\n                          ps (coS t (Max (range (some_snapshot t))))\n                           p \\<noteq>\n                          None)", "apply (auto simp: finite_processes)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p.\n                (\\<exists>y.\n                    ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                enat (some_snapshot t p) \\<le> llength t;\n     \\<And>uu p.\n        \\<exists>y.\n           ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n        \\<exists>y.\n           ps (coS t (Max (range (some_snapshot t)))) p = Some y\\<rbrakk>\n    \\<Longrightarrow> enat (Max (range (some_snapshot t))) \\<le> llength t\n 2. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   enat (some_snapshot t p) \\<le> llength t;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ps (coS t (Max (range (some_snapshot t)))) p =\n                            Some y", "apply (cases \"llength t\"; auto simp: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   some_snapshot t p \\<le> nat;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y;\n        llength t = enat nat\\<rbrakk>\n       \\<Longrightarrow> Max (range (some_snapshot t)) \\<le> nat\n 2. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   enat (some_snapshot t p) \\<le> llength t;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ps (coS t (Max (range (some_snapshot t)))) p =\n                            Some y", "apply (subst Max_le_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   some_snapshot t p \\<le> nat;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y;\n        llength t = enat nat\\<rbrakk>\n       \\<Longrightarrow> finite (range (some_snapshot t))\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   some_snapshot t p \\<le> nat;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y;\n        llength t = enat nat\\<rbrakk>\n       \\<Longrightarrow> range (some_snapshot t) \\<noteq> {}\n 3. \\<And>nat.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   some_snapshot t p \\<le> nat;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y;\n        llength t = enat nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a\\<in>range (some_snapshot t). a \\<le> nat\n 4. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   enat (some_snapshot t p) \\<le> llength t;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ps (coS t (Max (range (some_snapshot t)))) p =\n                            Some y", "apply (auto simp: finite_processes)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   (\\<exists>y.\n                       ps (coS t (some_snapshot t p)) p = Some y) \\<and>\n                   enat (some_snapshot t p) \\<le> llength t;\n        \\<And>uu p.\n           \\<exists>y.\n              ps (coS t (some_snapshot t uu)) p = Some y \\<Longrightarrow>\n           \\<exists>y.\n              ps (coS t (Max (range (some_snapshot t)))) p = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ps (coS t (Max (range (some_snapshot t)))) p =\n                            Some y", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_messages_if_no_channel:\n  assumes \"cotrace init t\"\n  shows \"channel cid = None \\<Longrightarrow> msgs (coS t i) cid = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. channel cid = None \\<Longrightarrow> msgs (coS t i) cid = []", "using no_messages_introduced_if_no_channel[OF assms[THEN cotrace_trace_cos, of i] no_msgs_if_no_channel, of cid i]"], ["proof (prove)\nusing this:\n  channel cid = None \\<Longrightarrow>\n  msgs (s init (Co_Snapshot.ltake i t) i) cid = []\n\ngoal (1 subgoal):\n 1. channel cid = None \\<Longrightarrow> msgs (coS t i) cid = []", "by (auto simp: cos_def)"], ["", "lemma cotrace_all_have_snapshotted_and_no_markers:\n  assumes \"cotrace init t\"\n  shows \"\\<exists>i \\<le> llength t. (\\<forall>p. has_snapshotted (coS t i) p) \\<and> \n                         (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "from cotrace_all_have_snapshotted[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None)", "obtain j :: nat where\n    j: \"j \\<le> llength t\" \"\\<forall>p. has_snapshotted (coS t j) p\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>enat j \\<le> llength t;\n         \\<forall>p. ps (coS t j) p \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enat j \\<le> llength t\n  \\<forall>p. ps (coS t j) p \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "from j(2)"], ["proof (chain)\npicking this:\n  \\<forall>p. ps (coS t j) p \\<noteq> None", "have *: \"has_snapshotted (coS t k) p\" if \"k \\<ge> j\" for k p"], ["proof (prove)\nusing this:\n  \\<forall>p. ps (coS t j) p \\<noteq> None\n\ngoal (1 subgoal):\n 1. ps (coS t k) p \\<noteq> None", "using snapshot_stable[OF assms, of j k p] that"], ["proof (prove)\nusing this:\n  \\<forall>p. ps (coS t j) p \\<noteq> None\n  \\<lbrakk>j \\<le> k; ps (coS t j) p \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ps (coS t k) p \\<noteq> None\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. ps (coS t k) p \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  j \\<le> ?k5 \\<Longrightarrow> ps (coS t ?k5) ?p5 \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "define C where \"C = {c. Marker \\<in> set (msgs (coS t j) c)}\""], ["proof (state)\nthis:\n  C = {c. Marker \\<in> set (msgs (coS t j) c)}\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "have \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "using no_messages_if_no_channel[OF assms, of _ j]"], ["proof (prove)\nusing this:\n  channel ?cid = None \\<Longrightarrow> msgs (coS t j) ?cid = []\n\ngoal (1 subgoal):\n 1. finite C", "unfolding C_def"], ["proof (prove)\nusing this:\n  channel ?cid = None \\<Longrightarrow> msgs (coS t j) ?cid = []\n\ngoal (1 subgoal):\n 1. finite {c. Marker \\<in> set (msgs (coS t j) c)}", "by (intro finite_subset[OF _ finite_channels]) fastforce"], ["proof (state)\nthis:\n  finite C\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "define pick where \"pick = (\\<lambda>c. SOME k. k \\<le> llength t \\<and> k \\<ge> j \\<and> Marker \\<notin> set (msgs (coS t k) c))\""], ["proof (state)\nthis:\n  pick =\n  (\\<lambda>c.\n      SOME k.\n         enat k \\<le> llength t \\<and>\n         j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "{"], ["proof (state)\nthis:\n  pick =\n  (\\<lambda>c.\n      SOME k.\n         enat k \\<le> llength t \\<and>\n         j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "assume \"c \\<in> C\""], ["proof (state)\nthis:\n  c \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "then"], ["proof (chain)\npicking this:\n  c \\<in> C", "have \"\\<exists>k \\<le> llength t. k \\<ge> j \\<and> Marker \\<notin> set (msgs (coS t k) c)\""], ["proof (prove)\nusing this:\n  c \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       enat k \\<le> llength t \\<and>\n       j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)", "using l1[rule_format, of t j c] assms"], ["proof (prove)\nusing this:\n  c \\<in> C\n  cotrace init t \\<and>\n  Marker \\<in> set (msgs (coS t j) c) \\<Longrightarrow>\n  \\<exists>ja.\n     enat ja \\<le> llength t \\<and>\n     j \\<le> ja \\<and> Marker \\<notin> set (msgs (coS t ja) c)\n  cotrace init t\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       enat k \\<le> llength t \\<and>\n       j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)", "unfolding C_def"], ["proof (prove)\nusing this:\n  c \\<in> {c. Marker \\<in> set (msgs (coS t j) c)}\n  cotrace init t \\<and>\n  Marker \\<in> set (msgs (coS t j) c) \\<Longrightarrow>\n  \\<exists>ja.\n     enat ja \\<le> llength t \\<and>\n     j \\<le> ja \\<and> Marker \\<notin> set (msgs (coS t ja) c)\n  cotrace init t\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       enat k \\<le> llength t \\<and>\n       j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)", "by blast"], ["proof (state)\nthis:\n  \\<exists>k.\n     enat k \\<le> llength t \\<and>\n     j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "then"], ["proof (chain)\npicking this:\n  \\<exists>k.\n     enat k \\<le> llength t \\<and>\n     j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)", "have \"pick c \\<le> llength t \\<and> pick c \\<ge> j \\<and> Marker \\<notin> set (msgs (coS t (pick c)) c)\""], ["proof (prove)\nusing this:\n  \\<exists>k.\n     enat k \\<le> llength t \\<and>\n     j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)\n\ngoal (1 subgoal):\n 1. enat (pick c) \\<le> llength t \\<and>\n    j \\<le> pick c \\<and> Marker \\<notin> set (msgs (coS t (pick c)) c)", "unfolding pick_def"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     enat k \\<le> llength t \\<and>\n     j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c)\n\ngoal (1 subgoal):\n 1. enat\n     (SOME k.\n         enat k \\<le> llength t \\<and>\n         j \\<le> k \\<and> Marker \\<notin> set (msgs (coS t k) c))\n    \\<le> llength t \\<and>\n    j \\<le> (SOME k.\n                enat k \\<le> llength t \\<and>\n                j \\<le> k \\<and>\n                Marker \\<notin> set (msgs (coS t k) c)) \\<and>\n    Marker\n    \\<notin> set (msgs\n                   (coS t\n                     (SOME k.\n                         enat k \\<le> llength t \\<and>\n                         j \\<le> k \\<and>\n                         Marker \\<notin> set (msgs (coS t k) c)))\n                   c)", "by (rule someI_ex)"], ["proof (state)\nthis:\n  enat (pick c) \\<le> llength t \\<and>\n  j \\<le> pick c \\<and> Marker \\<notin> set (msgs (coS t (pick c)) c)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "}"], ["proof (state)\nthis:\n  ?c7 \\<in> C \\<Longrightarrow>\n  enat (pick ?c7) \\<le> llength t \\<and>\n  j \\<le> pick ?c7 \\<and> Marker \\<notin> set (msgs (coS t (pick ?c7)) ?c7)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "note pick = conjunct1[OF this] conjunct1[OF conjunct2[OF this]] conjunct2[OF conjunct2[OF this]]"], ["proof (state)\nthis:\n  ?c8 \\<in> C \\<Longrightarrow> enat (pick ?c8) \\<le> llength t\n  ?c9 \\<in> C \\<Longrightarrow> j \\<le> pick ?c9\n  ?c9 \\<in> C \\<Longrightarrow>\n  Marker \\<notin> set (msgs (coS t (pick ?c9)) ?c9)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "proof (cases \"C = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C = {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\n 2. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "case True"], ["proof (state)\nthis:\n  C = {}\n\ngoal (2 subgoals):\n 1. C = {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\n 2. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "with j"], ["proof (chain)\npicking this:\n  enat j \\<le> llength t\n  \\<forall>p. ps (coS t j) p \\<noteq> None\n  C = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  enat j \\<le> llength t\n  \\<forall>p. ps (coS t j) p \\<noteq> None\n  C = {}\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "by (auto intro!: exI[of _ j] simp: C_def)"], ["proof (state)\nthis:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n     (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "define m where \"m = Max (pick ` C)\""], ["proof (state)\nthis:\n  m = Max (pick ` C)\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "case False"], ["proof (state)\nthis:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "with \\<open>finite C\\<close>"], ["proof (chain)\npicking this:\n  finite C\n  C \\<noteq> {}", "have m: \"m \\<in> pick ` C\" \"\\<forall>x \\<in> pick ` C. m \\<ge> x\""], ["proof (prove)\nusing this:\n  finite C\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. m \\<in> pick ` C &&& \\<forall>x\\<in>pick ` C. x \\<le> m", "unfolding m_def"], ["proof (prove)\nusing this:\n  finite C\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Max (pick ` C) \\<in> pick ` C &&&\n    \\<forall>x\\<in>pick ` C. x \\<le> Max (pick ` C)", "by auto"], ["proof (state)\nthis:\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "then"], ["proof (chain)\npicking this:\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m", "have \"j \\<le> m\""], ["proof (prove)\nusing this:\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n\ngoal (1 subgoal):\n 1. j \\<le> m", "using pick(2)"], ["proof (prove)\nusing this:\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n  ?c9 \\<in> C \\<Longrightarrow> j \\<le> pick ?c9\n\ngoal (1 subgoal):\n 1. j \\<le> m", "by auto"], ["proof (state)\nthis:\n  j \\<le> m\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "from *[OF \\<open>j \\<le> m\\<close>]"], ["proof (chain)\npicking this:\n  ps (coS t m) ?p5 \\<noteq> None", "have \"Marker \\<notin> set (msgs (coS t m) c)\" for c"], ["proof (prove)\nusing this:\n  ps (coS t m) ?p5 \\<noteq> None\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs (coS t m) c)", "proof (cases \"c \\<in> C\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<in> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)\n 2. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<notin> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)", "case True"], ["proof (state)\nthis:\n  c \\<in> C\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<in> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)\n 2. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<notin> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)", "then"], ["proof (chain)\npicking this:\n  c \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<in> C\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs (coS t m) c)", "using no_markers_if_all_snapshotted[OF assms, of \"pick c\" m c] pick[of c] m *"], ["proof (prove)\nusing this:\n  c \\<in> C\n  \\<lbrakk>pick c \\<le> m; \\<forall>p. ps (coS t (pick c)) p \\<noteq> None;\n   Marker \\<notin> set (msgs (coS t (pick c)) c)\\<rbrakk>\n  \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)\n  c \\<in> C \\<Longrightarrow> enat (pick c) \\<le> llength t\n  c \\<in> C \\<Longrightarrow> j \\<le> pick c\n  c \\<in> C \\<Longrightarrow> Marker \\<notin> set (msgs (coS t (pick c)) c)\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n  j \\<le> ?k5 \\<Longrightarrow> ps (coS t ?k5) ?p5 \\<noteq> None\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs (coS t m) c)", "by auto"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs (coS t m) c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<notin> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<notin> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)", "case False"], ["proof (state)\nthis:\n  c \\<notin> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p. ps (coS t m) p \\<noteq> None; c \\<notin> C\\<rbrakk>\n    \\<Longrightarrow> Marker \\<notin> set (msgs (coS t m) c)", "then"], ["proof (chain)\npicking this:\n  c \\<notin> C", "show ?thesis"], ["proof (prove)\nusing this:\n  c \\<notin> C\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs (coS t m) c)", "using no_markers_if_all_snapshotted[OF assms \\<open>j \\<le> m\\<close> j(2), of c]"], ["proof (prove)\nusing this:\n  c \\<notin> C\n  Marker \\<notin> set (msgs (coS t j) c) \\<Longrightarrow>\n  Marker \\<notin> set (msgs (coS t m) c)\n\ngoal (1 subgoal):\n 1. Marker \\<notin> set (msgs (coS t m) c)", "by (auto simp: C_def)"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs (coS t m) c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Marker \\<notin> set (msgs (coS t m) ?c5)\n\ngoal (1 subgoal):\n 1. C \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "with *[OF \\<open>j \\<le> m\\<close>] m pick"], ["proof (chain)\npicking this:\n  ps (coS t m) ?p5 \\<noteq> None\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n  ?c8 \\<in> C \\<Longrightarrow> enat (pick ?c8) \\<le> llength t\n  ?c9 \\<in> C \\<Longrightarrow> j \\<le> pick ?c9\n  ?c9 \\<in> C \\<Longrightarrow>\n  Marker \\<notin> set (msgs (coS t (pick ?c9)) ?c9)\n  Marker \\<notin> set (msgs (coS t m) ?c5)", "show ?thesis"], ["proof (prove)\nusing this:\n  ps (coS t m) ?p5 \\<noteq> None\n  m \\<in> pick ` C\n  \\<forall>x\\<in>pick ` C. x \\<le> m\n  ?c8 \\<in> C \\<Longrightarrow> enat (pick ?c8) \\<le> llength t\n  ?c9 \\<in> C \\<Longrightarrow> j \\<le> pick ?c9\n  ?c9 \\<in> C \\<Longrightarrow>\n  Marker \\<notin> set (msgs (coS t (pick ?c9)) ?c9)\n  Marker \\<notin> set (msgs (coS t m) ?c5)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       enat i \\<le> llength t \\<and>\n       (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n       (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n     (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i.\n     enat i \\<le> llength t \\<and>\n     (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n     (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes t\n  assumes cotrace: \"cotrace init t\"\nbegin"], ["", "definition \"final_i \\<equiv>\n  (SOME i. i \\<le> llength t \\<and> (\\<forall>p. has_snapshotted (coS t i) p) \\<and> (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c)))\""], ["", "definition final where\n  \"final = coS t final_i\""], ["", "lemma final_i: \"final_i \\<le> llength t\" \"(\\<forall>p. has_snapshotted (coS t final_i) p)\" \"(\\<forall>c. Marker \\<notin> set (msgs (coS t final_i) c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat final_i \\<le> llength t &&&\n    \\<forall>p. ps (coS t final_i) p \\<noteq> None &&&\n    \\<forall>c. Marker \\<notin> set (msgs (coS t final_i) c)", "unfolding final_i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat\n     (SOME i.\n         enat i \\<le> llength t \\<and>\n         (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n         (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c)))\n    \\<le> llength t &&&\n    \\<forall>p.\n       ps (coS t\n            (SOME i.\n                enat i \\<le> llength t \\<and>\n                (\\<forall>p. ps (coS t i) p \\<noteq> None) \\<and>\n                (\\<forall>c. Marker \\<notin> set (msgs (coS t i) c))))\n        p \\<noteq>\n       None &&&\n    \\<forall>c.\n       Marker\n       \\<notin> set (msgs\n                      (coS t\n                        (SOME i.\n                            enat i \\<le> llength t \\<and>\n                            (\\<forall>p.\n                                ps (coS t i) p \\<noteq> None) \\<and>\n                            (\\<forall>c.\n                                Marker \\<notin> set (msgs (coS t i) c))))\n                      c)", "by (rule someI2_ex[OF cotrace_all_have_snapshotted_and_no_markers[OF cotrace]]; auto intro: cotrace_trace_cos[OF cotrace])+"], ["", "lemma final: \"\\<exists>t. trace init t final\" \"(\\<forall>p. has_snapshotted final p)\" \"(\\<forall>c. Marker \\<notin> set (msgs final c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. trace init t final &&&\n    \\<forall>p. ps final p \\<noteq> None &&&\n    \\<forall>c. Marker \\<notin> set (msgs final c)", "unfolding final_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ta. trace init ta (coS t final_i) &&&\n    \\<forall>p. ps (coS t final_i) p \\<noteq> None &&&\n    \\<forall>c. Marker \\<notin> set (msgs (coS t final_i) c)", "by (rule cotrace_trace_cos[OF cotrace] final_i exI)+"], ["", "interpretation computation channel trans send recv init final"], ["proof (prove)\ngoal (1 subgoal):\n 1. computation channel trans send recv init final", "apply standard"], ["proof (prove)\ngoal (11 subgoals):\n 1. finite {i. \\<exists>p q. channel i = Some (p, q)}\n 2. \\<forall>p q.\n       p \\<noteq> q \\<longrightarrow>\n       (\\<lambda>p q. \\<exists>i. channel i = Some (p, q))\\<^sup>+\\<^sup>+ p\n        q\n 3. 1 < card UNIV\n 4. finite UNIV\n 5. \\<forall>i.\n       (\\<exists>p q. channel i = Some (p, q)) \\<longrightarrow>\n       Marker \\<notin> set (msgs init i)\n 6. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 7. \\<forall>p. \\<not> ps init p \\<noteq> None\n 8. \\<forall>i. cs init i = ([], NotStarted)\n 9. \\<exists>t. trace init t final\n 10. \\<forall>t i cid.\n        trace init t final \\<and>\n        Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n        (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\nA total of 11 subgoals...", "apply (rule finite_channels)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<forall>p q.\n       p \\<noteq> q \\<longrightarrow>\n       (\\<lambda>p q. \\<exists>i. channel i = Some (p, q))\\<^sup>+\\<^sup>+ p\n        q\n 2. 1 < card UNIV\n 3. finite UNIV\n 4. \\<forall>i.\n       (\\<exists>p q. channel i = Some (p, q)) \\<longrightarrow>\n       Marker \\<notin> set (msgs init i)\n 5. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 6. \\<forall>p. \\<not> ps init p \\<noteq> None\n 7. \\<forall>i. cs init i = ([], NotStarted)\n 8. \\<exists>t. trace init t final\n 9. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 10. \\<forall>t p.\n        trace init t final \\<longrightarrow>\n        (\\<exists>i.\n            ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule strongly_connected_raw)"], ["proof (prove)\ngoal (9 subgoals):\n 1. 1 < card UNIV\n 2. finite UNIV\n 3. \\<forall>i.\n       (\\<exists>p q. channel i = Some (p, q)) \\<longrightarrow>\n       Marker \\<notin> set (msgs init i)\n 4. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 5. \\<forall>p. \\<not> ps init p \\<noteq> None\n 6. \\<forall>i. cs init i = ([], NotStarted)\n 7. \\<exists>t. trace init t final\n 8. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 9. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule at_least_two_processes)"], ["proof (prove)\ngoal (8 subgoals):\n 1. finite UNIV\n 2. \\<forall>i.\n       (\\<exists>p q. channel i = Some (p, q)) \\<longrightarrow>\n       Marker \\<notin> set (msgs init i)\n 3. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 4. \\<forall>p. \\<not> ps init p \\<noteq> None\n 5. \\<forall>i. cs init i = ([], NotStarted)\n 6. \\<exists>t. trace init t final\n 7. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 8. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule finite_processes)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>i.\n       (\\<exists>p q. channel i = Some (p, q)) \\<longrightarrow>\n       Marker \\<notin> set (msgs init i)\n 2. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 3. \\<forall>p. \\<not> ps init p \\<noteq> None\n 4. \\<forall>i. cs init i = ([], NotStarted)\n 5. \\<exists>t. trace init t final\n 6. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 7. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule no_initial_Marker)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<forall>i. channel i = None \\<longrightarrow> msgs init i = []\n 2. \\<forall>p. \\<not> ps init p \\<noteq> None\n 3. \\<forall>i. cs init i = ([], NotStarted)\n 4. \\<exists>t. trace init t final\n 5. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 6. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule no_msgs_if_no_channel)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>p. \\<not> ps init p \\<noteq> None\n 2. \\<forall>i. cs init i = ([], NotStarted)\n 3. \\<exists>t. trace init t final\n 4. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 5. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule no_initial_process_snapshot)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i. cs init i = ([], NotStarted)\n 2. \\<exists>t. trace init t final\n 3. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 4. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule no_initial_channel_snapshot)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>t. trace init t final\n 2. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 3. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (rule final(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<longrightarrow>\n       (\\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid))\n 2. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (intro allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t i cid.\n       trace init t final \\<and>\n       Marker \\<in> set (msgs (s init t i) cid) \\<Longrightarrow>\n       \\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid)\n 2. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "subgoal for t i cid"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace init t final \\<and>\n    Marker \\<in> set (msgs (s init t i) cid) \\<Longrightarrow>\n    \\<exists>j\\<ge>i. Marker \\<notin> set (msgs (s init t j) cid)", "apply (rule exI[of _ \"length t\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace init t final \\<and>\n    Marker \\<in> set (msgs (s init t i) cid) \\<Longrightarrow>\n    i \\<le> length t \\<and>\n    Marker \\<notin> set (msgs (s init t (length t)) cid)", "apply (metis exists_trace_for_any_i final(3) le_cases take_all trace_and_start_determines_end)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t p.\n       trace init t final \\<longrightarrow>\n       (\\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t p.\n       trace init t final \\<Longrightarrow>\n       \\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t", "subgoal for t p"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace init t final \\<Longrightarrow>\n    \\<exists>i. ps (s init t i) p \\<noteq> None \\<and> i \\<le> length t", "apply (rule exI[of _ \"length t\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace init t final \\<Longrightarrow>\n    ps (s init t (length t)) p \\<noteq> None \\<and> length t \\<le> length t", "apply (metis exists_trace_for_any_i final(2) order_refl take_all trace_and_start_determines_end)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition coperm where\n  \"coperm l r = (\\<exists>xs ys z. perm xs ys \\<and> l = prepend xs z \\<and> r = prepend ys z)\""], ["", "lemma copermIL: \"perm ys xs \\<Longrightarrow> t = prepend xs z \\<Longrightarrow> coperm (prepend ys z) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys <~~> xs; t = prepend xs z\\<rbrakk>\n    \\<Longrightarrow> coperm (prepend ys z) t", "unfolding coperm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ys <~~> xs; t = prepend xs z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ysa za.\n                         xs <~~> ysa \\<and>\n                         prepend ys z = prepend xs za \\<and>\n                         t = prepend ysa za", "by auto"], ["", "lemma snapshot_algorithm_is_cocorrect:\n  \"\\<exists>t' i. cotrace init t' \\<and> coperm t' t \\<and> state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "define prefix where \"prefix = ltake final_i t\""], ["proof (state)\nthis:\n  prefix = Co_Snapshot.ltake final_i t\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "define suffix where \"suffix = ldrop final_i t\""], ["proof (state)\nthis:\n  suffix = Co_Snapshot.ldrop final_i t\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "have [simp]: \"prepend prefix suffix = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prepend prefix suffix = t", "unfolding prefix_def suffix_def prepend_ltake_ldrop_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = t", ".."], ["proof (state)\nthis:\n  prepend prefix suffix = t\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "have [simp]: \"cotrace final suffix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace final suffix", "unfolding suffix_def final_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cotrace (coS t final_i) (Co_Snapshot.ldrop final_i t)", "by (auto simp: cotrace final_i(1) intro!: cotrace_ldrop)"], ["proof (state)\nthis:\n  cotrace final suffix\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "from cotrace_trace_cos[OF cotrace]"], ["proof (chain)\npicking this:\n  trace init (Co_Snapshot.ltake ?i t) (coS t ?i)", "have \"trace init prefix final\""], ["proof (prove)\nusing this:\n  trace init (Co_Snapshot.ltake ?i t) (coS t ?i)\n\ngoal (1 subgoal):\n 1. trace init prefix final", "unfolding final_def prefix_def"], ["proof (prove)\nusing this:\n  trace init (Co_Snapshot.ltake ?i t) (coS t ?i)\n\ngoal (1 subgoal):\n 1. trace init (Co_Snapshot.ltake final_i t) (coS t final_i)", "by blast"], ["proof (state)\nthis:\n  trace init prefix final\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "with snapshot_algorithm_is_correct"], ["proof (chain)\npicking this:\n  trace init ?t final \\<Longrightarrow>\n  \\<exists>t' i.\n     trace init t' final \\<and>\n     t' <~~> ?t \\<and>\n     state_equal_to_snapshot (S t' i) final \\<and> i \\<le> length t'\n  trace init prefix final", "obtain prefix' i where\n    \"trace init prefix' final\" \"perm prefix' prefix\" \"state_equal_to_snapshot (S prefix' i) final\"\n    \"i \\<le> length prefix'\""], ["proof (prove)\nusing this:\n  trace init ?t final \\<Longrightarrow>\n  \\<exists>t' i.\n     trace init t' final \\<and>\n     t' <~~> ?t \\<and>\n     state_equal_to_snapshot (S t' i) final \\<and> i \\<le> length t'\n  trace init prefix final\n\ngoal (1 subgoal):\n 1. (\\<And>prefix' i.\n        \\<lbrakk>trace init prefix' final; prefix' <~~> prefix;\n         state_equal_to_snapshot (S prefix' i) final;\n         i \\<le> length prefix'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trace init prefix' final\n  prefix' <~~> prefix\n  state_equal_to_snapshot (S prefix' i) final\n  i \\<le> length prefix'\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "moreover"], ["proof (state)\nthis:\n  trace init prefix' final\n  prefix' <~~> prefix\n  state_equal_to_snapshot (S prefix' i) final\n  i \\<le> length prefix'\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "from \\<open>perm prefix' prefix\\<close> \\<open>i \\<le> length prefix'\\<close>"], ["proof (chain)\npicking this:\n  prefix' <~~> prefix\n  i \\<le> length prefix'", "have \"i \\<le> final_i\""], ["proof (prove)\nusing this:\n  prefix' <~~> prefix\n  i \\<le> length prefix'\n\ngoal (1 subgoal):\n 1. i \\<le> final_i", "by (auto dest!: perm_length simp: prefix_def split: enat.splits)"], ["proof (state)\nthis:\n  i \\<le> final_i\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "ultimately"], ["proof (chain)\npicking this:\n  trace init prefix' final\n  prefix' <~~> prefix\n  state_equal_to_snapshot (S prefix' i) final\n  i \\<le> length prefix'\n  i \\<le> final_i", "show ?thesis"], ["proof (prove)\nusing this:\n  trace init prefix' final\n  prefix' <~~> prefix\n  state_equal_to_snapshot (S prefix' i) final\n  i \\<le> length prefix'\n  i \\<le> final_i\n\ngoal (1 subgoal):\n 1. \\<exists>t' i.\n       cotrace init t' \\<and>\n       coperm t' t \\<and>\n       state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i", "by (intro exI[of _ \"prepend prefix' suffix\"] exI[of _ i])\n      (auto simp: cos_def ltake_prepend s_chop[symmetric] intro!: cotrace_prepend elim!: copermIL)"], ["proof (state)\nthis:\n  \\<exists>t' i.\n     cotrace init t' \\<and>\n     coperm t' t \\<and>\n     state_equal_to_snapshot (coS t' i) final \\<and> i \\<le> final_i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "print_statement snapshot_algorithm_is_cocorrect"], ["", "end"], ["", "end"]]}