{"file_name": "/home/qj213/afp-2021-10-22/thys/Splay_Tree/Splay_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Splay_Tree", "problem_names": ["lemma splay_code: \"splay (x::_::linorder) t = (case t of Leaf \\<Rightarrow> Leaf |\n  Node al a ar \\<Rightarrow> (case cmp x (fst a) of\n    EQ \\<Rightarrow> t |\n    LT \\<Rightarrow> (case al of\n      Leaf \\<Rightarrow> t |\n      Node bl b br \\<Rightarrow> (case cmp x (fst b) of\n        EQ \\<Rightarrow> Node bl b (Node br a ar) |\n        LT \\<Rightarrow> if bl = Leaf then Node bl b (Node br a ar)\n              else case splay x bl of\n                Node bll y blr \\<Rightarrow> Node bll y (Node blr b (Node br a ar)) |\n        GT \\<Rightarrow> if br = Leaf then Node bl b (Node br a ar)\n              else case splay x br of\n                Node brl y brr \\<Rightarrow> Node (Node bl b brl) y (Node brr a ar))) |\n    GT \\<Rightarrow> (case ar of\n      Leaf \\<Rightarrow> t |\n      Node bl b br \\<Rightarrow> (case cmp x (fst b) of\n        EQ \\<Rightarrow> Node (Node al a bl) b br |\n        LT \\<Rightarrow> if bl = Leaf then Node (Node al a bl) b br\n              else case splay x bl of\n                Node bll y blr \\<Rightarrow> Node (Node al a bll) y (Node blr b br) |\n        GT \\<Rightarrow> if br=Leaf then Node (Node al a bl) b br\n              else case splay x br of\n                Node bll y blr \\<Rightarrow> Node (Node (Node al a bl) b bll) y blr))))\"", "lemma splay_Leaf_iff: \"(splay x t = Leaf) = (t = Leaf)\"", "lemma splay_map_of_inorder:\n  \"splay x t = Node l a r \\<Longrightarrow> sorted1(inorder t) \\<Longrightarrow>\n   map_of (inorder t) x = (if x = fst a then Some(snd a) else None)\"", "lemma lookup_eq:\n  \"sorted1(inorder t) \\<Longrightarrow> lookup t x = map_of (inorder t) x\"", "lemma inorder_splay: \"inorder(splay x t) = inorder t\"", "lemma sorted_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> splay x t = Node l a r \\<Longrightarrow>\n  sorted(map fst (inorder l) @ x # map fst (inorder r))\"", "lemma inorder_update_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> inorder(update x y t) = upd_list x y (inorder t)\"", "lemma inorder_splay_maxD:\n  \"splay_max t = Node l a r \\<Longrightarrow> sorted1(inorder t) \\<Longrightarrow>\n  inorder l @ [a] = inorder t \\<and> r = Leaf\"", "lemma inorder_delete_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\""], "translations": [["", "lemma splay_code: \"splay (x::_::linorder) t = (case t of Leaf \\<Rightarrow> Leaf |\n  Node al a ar \\<Rightarrow> (case cmp x (fst a) of\n    EQ \\<Rightarrow> t |\n    LT \\<Rightarrow> (case al of\n      Leaf \\<Rightarrow> t |\n      Node bl b br \\<Rightarrow> (case cmp x (fst b) of\n        EQ \\<Rightarrow> Node bl b (Node br a ar) |\n        LT \\<Rightarrow> if bl = Leaf then Node bl b (Node br a ar)\n              else case splay x bl of\n                Node bll y blr \\<Rightarrow> Node bll y (Node blr b (Node br a ar)) |\n        GT \\<Rightarrow> if br = Leaf then Node bl b (Node br a ar)\n              else case splay x br of\n                Node brl y brr \\<Rightarrow> Node (Node bl b brl) y (Node brr a ar))) |\n    GT \\<Rightarrow> (case ar of\n      Leaf \\<Rightarrow> t |\n      Node bl b br \\<Rightarrow> (case cmp x (fst b) of\n        EQ \\<Rightarrow> Node (Node al a bl) b br |\n        LT \\<Rightarrow> if bl = Leaf then Node (Node al a bl) b br\n              else case splay x bl of\n                Node bll y blr \\<Rightarrow> Node (Node al a bll) y (Node blr b br) |\n        GT \\<Rightarrow> if br=Leaf then Node (Node al a bl) b br\n              else case splay x br of\n                Node bll y blr \\<Rightarrow> Node (Node (Node al a bl) b bll) y blr))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Splay_Map.splay x t =\n    (case t of \\<langle>\\<rangle> \\<Rightarrow> \\<langle>\\<rangle>\n     | \\<langle>al, a, ar\\<rangle> \\<Rightarrow>\n         case cmp x (fst a) of\n         LT \\<Rightarrow>\n           case al of \\<langle>\\<rangle> \\<Rightarrow> t\n           | \\<langle>bl, b, br\\<rangle> \\<Rightarrow>\n               case cmp x (fst b) of\n               LT \\<Rightarrow>\n                 if bl = \\<langle>\\<rangle>\n                 then \\<langle>bl, b, \\<langle>br, a, ar\\<rangle>\\<rangle>\n                 else case Splay_Map.splay x bl of\n                      \\<langle>bll, y, blr\\<rangle> \\<Rightarrow>\n                        \\<langle>bll, y,\n                         \\<langle>blr, b,\n                          \\<langle>br, a, ar\\<rangle>\\<rangle>\\<rangle>\n               | EQ \\<Rightarrow>\n                   \\<langle>bl, b, \\<langle>br, a, ar\\<rangle>\\<rangle>\n               | GT \\<Rightarrow>\n                   if br = \\<langle>\\<rangle>\n                   then \\<langle>bl, b, \\<langle>br, a, ar\\<rangle>\\<rangle>\n                   else case Splay_Map.splay x br of\n                        \\<langle>brl, y, brr\\<rangle> \\<Rightarrow>\n                          \\<langle>\\<langle>bl, b, brl\\<rangle>, y,\n                           \\<langle>brr, a, ar\\<rangle>\\<rangle>\n         | EQ \\<Rightarrow> t\n         | GT \\<Rightarrow>\n             case ar of \\<langle>\\<rangle> \\<Rightarrow> t\n             | \\<langle>bl, b, br\\<rangle> \\<Rightarrow>\n                 case cmp x (fst b) of\n                 LT \\<Rightarrow>\n                   if bl = \\<langle>\\<rangle>\n                   then \\<langle>\\<langle>al, a, bl\\<rangle>, b, br\\<rangle>\n                   else case Splay_Map.splay x bl of\n                        \\<langle>bll, y, blr\\<rangle> \\<Rightarrow>\n                          \\<langle>\\<langle>al, a, bll\\<rangle>, y,\n                           \\<langle>blr, b, br\\<rangle>\\<rangle>\n                 | EQ \\<Rightarrow>\n                     \\<langle>\\<langle>al, a, bl\\<rangle>, b, br\\<rangle>\n                 | GT \\<Rightarrow>\n                     if br = \\<langle>\\<rangle>\n                     then \\<langle>\\<langle>al, a, bl\\<rangle>, b,\n                           br\\<rangle>\n                     else case Splay_Map.splay x br of\n                          \\<langle>bll, y, blr\\<rangle> \\<Rightarrow>\n                            \\<langle>\\<langle>\\<langle>al, a, bl\\<rangle>,\nb, bll\\<rangle>,\n                             y, blr\\<rangle>)", "by(auto split!: tree.split)"], ["", "definition lookup :: \"('a*'b)tree \\<Rightarrow> 'a::linorder \\<Rightarrow> 'b option\" where \"lookup t x =\n  (case splay x t of Leaf \\<Rightarrow> None | Node _ (a,b) _ \\<Rightarrow> if x=a then Some b else None)\""], ["", "hide_const (open) insert"], ["", "fun update :: \"'a::linorder \\<Rightarrow> 'b \\<Rightarrow> ('a*'b) tree \\<Rightarrow> ('a*'b) tree\" where\n\"update x y t =  (if t = Leaf then Node Leaf (x,y) Leaf\n  else case splay x t of\n    Node l a r \\<Rightarrow> if x = fst a then Node l (x,y) r\n      else if x < fst a then Node l (x,y) (Node Leaf a r) else Node (Node l a Leaf) (x,y) r)\""], ["", "definition delete :: \"'a::linorder \\<Rightarrow> ('a*'b) tree \\<Rightarrow> ('a*'b) tree\" where\n\"delete x t = (if t = Leaf then Leaf\n  else case splay x t of Node l a r \\<Rightarrow>\n    if x = fst a\n    then if l = Leaf then r else case splay_max l of Node l' m r' \\<Rightarrow> Node l' m r\n    else Node l a r)\""], ["", "subsection \"Functional Correctness Proofs\""], ["", "lemma splay_Leaf_iff: \"(splay x t = Leaf) = (t = Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Splay_Map.splay x t = \\<langle>\\<rangle>) = (t = \\<langle>\\<rangle>)", "by(induction x t rule: splay.induct) (auto split: tree.splits)"], ["", "subsubsection \"Proofs for lookup\""], ["", "lemma splay_map_of_inorder:\n  \"splay x t = Node l a r \\<Longrightarrow> sorted1(inorder t) \\<Longrightarrow>\n   map_of (inorder t) x = (if x = fst a then Some(snd a) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Splay_Map.splay x t = \\<langle>l, a, r\\<rangle>;\n     sorted1 (inorder t)\\<rbrakk>\n    \\<Longrightarrow> AList_Upd_Del.map_of (inorder t) x =\n                      (if x = fst a then Some (snd a) else None)", "by(induction x t arbitrary: l a r rule: splay.induct)\n  (auto simp: map_of_simps splay_Leaf_iff split: tree.splits)"], ["", "lemma lookup_eq:\n  \"sorted1(inorder t) \\<Longrightarrow> lookup t x = map_of (inorder t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted1 (inorder t) \\<Longrightarrow>\n    lookup t x = AList_Upd_Del.map_of (inorder t) x", "by(auto simp: lookup_def splay_Leaf_iff splay_map_of_inorder split: tree.split)"], ["", "subsubsection \"Proofs for update\""], ["", "lemma inorder_splay: \"inorder(splay x t) = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (Splay_Map.splay x t) = inorder t", "by(induction x t rule: splay.induct)\n  (auto simp: neq_Leaf_iff split: tree.split)"], ["", "lemma sorted_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> splay x t = Node l a r \\<Longrightarrow>\n  sorted(map fst (inorder l) @ x # map fst (inorder r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted1 (inorder t);\n     Splay_Map.splay x t = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Sorted_Less.sorted\n                       (map fst (inorder l) @ x # map fst (inorder r))", "unfolding inorder_splay[of x t, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted1 (inorder (Splay_Map.splay x t));\n     Splay_Map.splay x t = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Sorted_Less.sorted\n                       (map fst (inorder l) @ x # map fst (inorder r))", "by(induction x t arbitrary: l a r rule: splay.induct)\n  (auto simp: sorted_lems sorted_Cons_le sorted_snoc_le splay_Leaf_iff split: tree.splits)"], ["", "lemma inorder_update_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> inorder(update x y t) = upd_list x y (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted1 (inorder t) \\<Longrightarrow>\n    inorder (update x y t) = upd_list x y (inorder t)", "using inorder_splay[of x t, symmetric] sorted_splay[of t x]"], ["proof (prove)\nusing this:\n  inorder t = inorder (Splay_Map.splay x t)\n  \\<lbrakk>sorted1 (inorder t);\n   Splay_Map.splay x t = \\<langle>?l, ?a, ?r\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> Sorted_Less.sorted\n                     (map fst (inorder ?l) @ x # map fst (inorder ?r))\n\ngoal (1 subgoal):\n 1. sorted1 (inorder t) \\<Longrightarrow>\n    inorder (update x y t) = upd_list x y (inorder t)", "by(auto simp: upd_list_simps upd_list_Cons upd_list_snoc neq_Leaf_iff split: tree.split)"], ["", "subsubsection \"Proofs for delete\""], ["", "lemma inorder_splay_maxD:\n  \"splay_max t = Node l a r \\<Longrightarrow> sorted1(inorder t) \\<Longrightarrow>\n  inorder l @ [a] = inorder t \\<and> r = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>splay_max t = \\<langle>l, a, r\\<rangle>;\n     sorted1 (inorder t)\\<rbrakk>\n    \\<Longrightarrow> inorder l @ [a] = inorder t \\<and>\n                      r = \\<langle>\\<rangle>", "by(induction t arbitrary: l a r rule: splay_max.induct)\n  (auto simp: sorted_lems split: tree.splits if_splits)"], ["", "lemma inorder_delete_splay:\n  \"sorted1(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted1 (inorder t) \\<Longrightarrow>\n    inorder (Splay_Map.delete x t) = AList_Upd_Del.del_list x (inorder t)", "using inorder_splay[of x t, symmetric] sorted_splay[of t x]"], ["proof (prove)\nusing this:\n  inorder t = inorder (Splay_Map.splay x t)\n  \\<lbrakk>sorted1 (inorder t);\n   Splay_Map.splay x t = \\<langle>?l, ?a, ?r\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> Sorted_Less.sorted\n                     (map fst (inorder ?l) @ x # map fst (inorder ?r))\n\ngoal (1 subgoal):\n 1. sorted1 (inorder t) \\<Longrightarrow>\n    inorder (Splay_Map.delete x t) = AList_Upd_Del.del_list x (inorder t)", "by (auto simp: del_list_simps del_list_sorted_app delete_def del_list_notin_Cons inorder_splay_maxD\n  split: tree.splits)"], ["", "subsubsection \"Overall Correctness\""], ["", "interpretation Map_by_Ordered\nwhere empty = empty and lookup = lookup and update = update\nand delete = delete and inorder = inorder and inv = \"\\<lambda>_. True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map_by_Ordered Splay_Tree.empty update Splay_Map.delete lookup inorder\n     (\\<lambda>_. True)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       lookup t a = AList_Upd_Del.map_of (inorder t) a\n 3. \\<And>t a b.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (update a b t) = upd_list a b (inorder t)\n 4. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 5. True\n 6. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 7. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "case 2"], ["proof (state)\nthis:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (7 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       lookup t a = AList_Upd_Del.map_of (inorder t) a\n 3. \\<And>t a b.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (update a b t) = upd_list a b (inorder t)\n 4. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 5. True\n 6. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 7. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (1 subgoal):\n 1. lookup t_ a_ = AList_Upd_Del.map_of (inorder t_) a_", "by(simp add: lookup_eq)"], ["proof (state)\nthis:\n  lookup t_ a_ = AList_Upd_Del.map_of (inorder t_) a_\n\ngoal (6 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a b.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (update a b t) = upd_list a b (inorder t)\n 3. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 4. True\n 5. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 6. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a b.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (update a b t) = upd_list a b (inorder t)\n 3. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 4. True\n 5. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 6. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "case 3"], ["proof (state)\nthis:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (6 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a b.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (update a b t) = upd_list a b (inorder t)\n 3. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 4. True\n 5. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 6. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (1 subgoal):\n 1. inorder (update a_ b_ t_) = upd_list a_ b_ (inorder t_)", "by(simp add: inorder_update_splay del: update.simps)"], ["proof (state)\nthis:\n  inorder (update a_ b_ t_) = upd_list a_ b_ (inorder t_)\n\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 3. True\n 4. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 5. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 3. True\n 4. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 5. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "case 4"], ["proof (state)\nthis:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t a.\n       True \\<and> sorted1 (inorder t) \\<Longrightarrow>\n       inorder (Splay_Map.delete a t) = AList_Upd_Del.del_list a (inorder t)\n 3. True\n 4. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 5. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> sorted1 (inorder t_)\n\ngoal (1 subgoal):\n 1. inorder (Splay_Map.delete a_ t_) =\n    AList_Upd_Del.del_list a_ (inorder t_)", "by(simp add: inorder_delete_splay)"], ["proof (state)\nthis:\n  inorder (Splay_Map.delete a_ t_) = AList_Upd_Del.del_list a_ (inorder t_)\n\ngoal (4 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. True\n 3. \\<And>t a b. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True\n 4. \\<And>t a. True \\<and> sorted1 (inorder t) \\<Longrightarrow> True", "qed (auto simp: empty_def)"], ["", "end"]]}