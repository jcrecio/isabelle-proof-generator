{"file_name": "/home/qj213/afp-2021-10-22/thys/Splay_Tree/Splay_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Splay_Tree", "problem_names": ["lemma get_min_in:\n  \"h \\<noteq> Leaf \\<Longrightarrow> get_min h \\<in> set_tree h\"", "lemma get_min_min:\n  \"\\<lbrakk> bst_wrt (\\<le>) h; h \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set_tree h. get_min h \\<le> x\"", "lemma size_partition: \"partition p t = (l',r') \\<Longrightarrow> size t = size l' + size r'\"", "lemma mset_partition: \"\\<lbrakk> bst_wrt (\\<le>) t; partition p t = (l',r') \\<rbrakk>\n \\<Longrightarrow> mset_tree t = mset_tree l' + mset_tree r'\"", "lemma set_partition: \"\\<lbrakk> bst_wrt (\\<le>) t; partition p t = (l',r') \\<rbrakk>\n \\<Longrightarrow> set_tree t = set_tree l' \\<union> set_tree r'\"", "lemma bst_partition:\n  \"partition p t = (l',r') \\<Longrightarrow> bst_wrt (\\<le>) t \\<Longrightarrow> bst_wrt (\\<le>) (Node l' p r')\"", "lemma size_del_min[simp]: \"size(del_min t) = size t - 1\"", "lemma mset_del_min: \"mset_tree (del_min h) = mset_tree h - {# get_min h #}\"", "lemma bst_del_min: \"bst_wrt (\\<le>) t \\<Longrightarrow> bst_wrt (\\<le>) (del_min t)\""], "translations": [["", "lemma get_min_in:\n  \"h \\<noteq> Leaf \\<Longrightarrow> get_min h \\<in> set_tree h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    get_min h \\<in> set_tree h", "by(induction h) auto"], ["", "lemma get_min_min:\n  \"\\<lbrakk> bst_wrt (\\<le>) h; h \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set_tree h. get_min h \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst_wrt (\\<le>) h; h \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set_tree h. get_min h \\<le> x", "proof(induction h)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n     \\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ball (set_tree \\<langle>\\<rangle>)\n                       ((\\<le>) (get_min \\<langle>\\<rangle>))\n 2. \\<And>h1 x2 h2.\n       \\<lbrakk>\\<lbrakk>bst_wrt (\\<le>) h1;\n                 h1 \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> Ball (set_tree h1) ((\\<le>) (get_min h1));\n        \\<lbrakk>bst_wrt (\\<le>) h2; h2 \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> Ball (set_tree h2) ((\\<le>) (get_min h2));\n        bst_wrt (\\<le>) \\<langle>h1, x2, h2\\<rangle>;\n        \\<langle>h1, x2, h2\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> Ball (set_tree \\<langle>h1, x2, h2\\<rangle>)\n                          ((\\<le>) (get_min \\<langle>h1, x2, h2\\<rangle>))", "case (Node l x r)"], ["proof (state)\nthis:\n  \\<lbrakk>bst_wrt (\\<le>) l; l \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree l. get_min l \\<le> a\n  \\<lbrakk>bst_wrt (\\<le>) r; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree r. get_min r \\<le> a\n  bst_wrt (\\<le>) \\<langle>l, x, r\\<rangle>\n  \\<langle>l, x, r\\<rangle> \\<noteq> \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n     \\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ball (set_tree \\<langle>\\<rangle>)\n                       ((\\<le>) (get_min \\<langle>\\<rangle>))\n 2. \\<And>h1 x2 h2.\n       \\<lbrakk>\\<lbrakk>bst_wrt (\\<le>) h1;\n                 h1 \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> Ball (set_tree h1) ((\\<le>) (get_min h1));\n        \\<lbrakk>bst_wrt (\\<le>) h2; h2 \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> Ball (set_tree h2) ((\\<le>) (get_min h2));\n        bst_wrt (\\<le>) \\<langle>h1, x2, h2\\<rangle>;\n        \\<langle>h1, x2, h2\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> Ball (set_tree \\<langle>h1, x2, h2\\<rangle>)\n                          ((\\<le>) (get_min \\<langle>h1, x2, h2\\<rangle>))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>bst_wrt (\\<le>) l; l \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree l. get_min l \\<le> a\n  \\<lbrakk>bst_wrt (\\<le>) r; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree r. get_min r \\<le> a\n  bst_wrt (\\<le>) \\<langle>l, x, r\\<rangle>\n  \\<langle>l, x, r\\<rangle> \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n       get_min \\<langle>l, x, r\\<rangle> \\<le> a", "using get_min_in[of l] get_min_in[of r]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bst_wrt (\\<le>) l; l \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree l. get_min l \\<le> a\n  \\<lbrakk>bst_wrt (\\<le>) r; r \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set_tree r. get_min r \\<le> a\n  bst_wrt (\\<le>) \\<langle>l, x, r\\<rangle>\n  \\<langle>l, x, r\\<rangle> \\<noteq> \\<langle>\\<rangle>\n  l \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> get_min l \\<in> set_tree l\n  r \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow> get_min r \\<in> set_tree r\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n       get_min \\<langle>l, x, r\\<rangle> \\<le> a", "by auto (blast intro: order_trans)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set_tree \\<langle>l, x, r\\<rangle>.\n     get_min \\<langle>l, x, r\\<rangle> \\<le> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n     \\<langle>\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Ball (set_tree \\<langle>\\<rangle>)\n                       ((\\<le>) (get_min \\<langle>\\<rangle>))", "qed simp"], ["", "lemma size_partition: \"partition p t = (l',r') \\<Longrightarrow> size t = size l' + size r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Splay_Heap.partition p t = (l', r') \\<Longrightarrow>\n    size t = size l' + size r'", "by (induction p t arbitrary: l' r' rule: partition.induct)\n   (auto split: if_splits tree.splits prod.splits)"], ["", "lemma mset_partition: \"\\<lbrakk> bst_wrt (\\<le>) t; partition p t = (l',r') \\<rbrakk>\n \\<Longrightarrow> mset_tree t = mset_tree l' + mset_tree r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst_wrt (\\<le>) t; Splay_Heap.partition p t = (l', r')\\<rbrakk>\n    \\<Longrightarrow> mset_tree t = mset_tree l' + mset_tree r'", "proof(induction p t arbitrary: l' r' rule: partition.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n        Splay_Heap.partition p \\<langle>\\<rangle> = (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>\\<rangle> =\n                         mset_tree l' + mset_tree r'\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> mset_tree x23 =\n                                     mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x23 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>al, a, ar\\<rangle> =\n                         mset_tree l' + mset_tree r'", "case 1"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n        Splay_Heap.partition p \\<langle>\\<rangle> = (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>\\<rangle> =\n                         mset_tree l' + mset_tree r'\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> mset_tree x23 =\n                                     mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x23 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>al, a, ar\\<rangle> =\n                         mset_tree l' + mset_tree r'", "thus ?case"], ["proof (prove)\nusing this:\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = mset_tree l' + mset_tree r'", "by simp"], ["proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> mset_tree x23 =\n                                     mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x23 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>al, a, ar\\<rangle> =\n                         mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> mset_tree x23 =\n                                     mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x23 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>al, a, ar\\<rangle> =\n                         mset_tree l' + mset_tree r'", "case (2 p l a r)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x23.0;\n   Splay_Heap.partition p ?x23.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree ?x23.0 = mset_tree ?l' + mset_tree ?r'\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x21.0;\n   Splay_Heap.partition p ?x21.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree ?x21.0 = mset_tree ?l' + mset_tree ?r'\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x23.0;\n   Splay_Heap.partition p ?x23.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree ?x23.0 = mset_tree ?l' + mset_tree ?r'\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x21.0;\n   Splay_Heap.partition p ?x21.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree ?x21.0 = mset_tree ?l' + mset_tree ?r'\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> mset_tree x23 =\n                                     mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x23 = mset_tree l' + mset_tree r';\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> mset_tree x21 = mset_tree l' + mset_tree r';\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> mset_tree \\<langle>al, a, ar\\<rangle> =\n                         mset_tree l' + mset_tree r'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"a \\<le> p\""], ["proof (state)\nthis:\n  a \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "case Leaf"], ["proof (state)\nthis:\n  r = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using \\<open>a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by auto"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "case (Node rl b rr)"], ["proof (state)\nthis:\n  r = \\<langle>rl, b, rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using Node \\<open>a \\<le> p\\<close> \"2.prems\" \"2.IH\"(1)[OF _ Node]"], ["proof (prove)\nusing this:\n  b \\<le> p\n  r = \\<langle>rl, b, rr\\<rangle>\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<lbrakk>a \\<le> p; b \\<le> p; bst_wrt (\\<le>) rr;\n   Splay_Heap.partition p rr = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree rr = mset_tree ?l' + mset_tree ?r'\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by (auto simp: ac_simps split: prod.splits)"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using Node \\<open>a \\<le> p\\<close> \"2.prems\" \"2.IH\"(2)[OF _ Node]"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n  r = \\<langle>rl, b, rr\\<rangle>\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<lbrakk>a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) rl;\n   Splay_Heap.partition p rl = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree rl = mset_tree ?l' + mset_tree ?r'\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by (auto simp: ac_simps split: prod.splits)"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"\\<not> a \\<le> p\""], ["proof (state)\nthis:\n  \\<not> a \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "case Leaf"], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using \\<open>\\<not> a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by auto"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "case (Node ll b lr)"], ["proof (state)\nthis:\n  l = \\<langle>ll, b, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using Node \\<open>\\<not> a \\<le> p\\<close> \"2.prems\" \"2.IH\"(3)[OF _ Node]"], ["proof (prove)\nusing this:\n  b \\<le> p\n  l = \\<langle>ll, b, lr\\<rangle>\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<lbrakk>\\<not> a \\<le> p; b \\<le> p; bst_wrt (\\<le>) lr;\n   Splay_Heap.partition p lr = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree lr = mset_tree ?l' + mset_tree ?r'\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by (auto simp: ac_simps split: prod.splits)"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "using Node \\<open>\\<not> a \\<le> p\\<close> \"2.prems\" \"2.IH\"(4)[OF _ Node]"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n  l = \\<langle>ll, b, lr\\<rangle>\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<lbrakk>\\<not> a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) ll;\n   Splay_Heap.partition p ll = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> mset_tree ll = mset_tree ?l' + mset_tree ?r'\n\ngoal (1 subgoal):\n 1. mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'", "by (auto simp: ac_simps split: prod.splits)"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree \\<langle>l, a, r\\<rangle> = mset_tree l' + mset_tree r'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_partition: \"\\<lbrakk> bst_wrt (\\<le>) t; partition p t = (l',r') \\<rbrakk>\n \\<Longrightarrow> set_tree t = set_tree l' \\<union> set_tree r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst_wrt (\\<le>) t; Splay_Heap.partition p t = (l', r')\\<rbrakk>\n    \\<Longrightarrow> set_tree t = set_tree l' \\<union> set_tree r'", "by (metis mset_partition set_mset_tree set_mset_union)"], ["", "lemma bst_partition:\n  \"partition p t = (l',r') \\<Longrightarrow> bst_wrt (\\<le>) t \\<Longrightarrow> bst_wrt (\\<le>) (Node l' p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Splay_Heap.partition p t = (l', r'); bst_wrt (\\<le>) t\\<rbrakk>\n    \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof(induction p t arbitrary: l' r' rule: partition.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>Splay_Heap.partition p \\<langle>\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n                    bst_wrt (\\<le>) x23\\<rbrakk>\n                   \\<Longrightarrow> bst_wrt (\\<le>)\n\\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n            bst_wrt (\\<le>) x23\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case 1"], ["proof (state)\nthis:\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>Splay_Heap.partition p \\<langle>\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n                    bst_wrt (\\<le>) x23\\<rbrakk>\n                   \\<Longrightarrow> bst_wrt (\\<le>)\n\\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n            bst_wrt (\\<le>) x23\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p_, r'\\<rangle>", "by simp"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p_, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n                    bst_wrt (\\<le>) x23\\<rbrakk>\n                   \\<Longrightarrow> bst_wrt (\\<le>)\n\\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n            bst_wrt (\\<le>) x23\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n                    bst_wrt (\\<le>) x23\\<rbrakk>\n                   \\<Longrightarrow> bst_wrt (\\<le>)\n\\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n            bst_wrt (\\<le>) x23\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case (2 p l a r)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; Splay_Heap.partition p ?x23.0 = (?l', ?r');\n   bst_wrt (\\<le>) ?x23.0\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; Splay_Heap.partition p ?x21.0 = (?l', ?r');\n   bst_wrt (\\<le>) ?x21.0\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; Splay_Heap.partition p ?x23.0 = (?l', ?r');\n   bst_wrt (\\<le>) ?x23.0\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; Splay_Heap.partition p ?x21.0 = (?l', ?r');\n   bst_wrt (\\<le>) ?x21.0\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n                    bst_wrt (\\<le>) x23\\<rbrakk>\n                   \\<Longrightarrow> bst_wrt (\\<le>)\n\\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; Splay_Heap.partition p x23 = (l', r');\n            bst_wrt (\\<le>) x23\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; Splay_Heap.partition p x21 = (l', r');\n            bst_wrt (\\<le>) x21\\<rbrakk>\n           \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> = (l', r');\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"a \\<le> p\""], ["proof (state)\nthis:\n  a \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case Leaf"], ["proof (state)\nthis:\n  r = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using \\<open>a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n  a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case (Node rl b rr)"], ["proof (state)\nthis:\n  r = \\<langle>rl, b, rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using Node \\<open>a \\<le> p\\<close> \"2.prems\" \"2.IH\"(1)[OF _ Node] set_partition[of rr]"], ["proof (prove)\nusing this:\n  b \\<le> p\n  r = \\<langle>rl, b, rr\\<rangle>\n  a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; b \\<le> p; Splay_Heap.partition p rr = (?l', ?r');\n   bst_wrt (\\<le>) rr\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>bst_wrt (\\<le>) rr;\n   Splay_Heap.partition ?p rr = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> set_tree rr = set_tree ?l' \\<union> set_tree ?r'\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by (fastforce split: prod.splits)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using Node \\<open>a \\<le> p\\<close> \"2.prems\" \"2.IH\"(2)[OF _ Node] set_partition[of rl]"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n  r = \\<langle>rl, b, rr\\<rangle>\n  a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; \\<not> b \\<le> p;\n   Splay_Heap.partition p rl = (?l', ?r'); bst_wrt (\\<le>) rl\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>bst_wrt (\\<le>) rl;\n   Splay_Heap.partition ?p rl = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> set_tree rl = set_tree ?l' \\<union> set_tree ?r'\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by (fastforce split: prod.splits)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"\\<not> a \\<le> p\""], ["proof (state)\nthis:\n  \\<not> a \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case Leaf"], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using \\<open>\\<not> a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  \\<not> a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "case (Node ll b lr)"], ["proof (state)\nthis:\n  l = \\<langle>ll, b, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n 2. \\<not> ?P \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using Node \\<open>\\<not> a \\<le> p\\<close> \"2.prems\" \"2.IH\"(3)[OF _ Node] set_partition[of lr]"], ["proof (prove)\nusing this:\n  b \\<le> p\n  l = \\<langle>ll, b, lr\\<rangle>\n  \\<not> a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; b \\<le> p;\n   Splay_Heap.partition p lr = (?l', ?r'); bst_wrt (\\<le>) lr\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>bst_wrt (\\<le>) lr;\n   Splay_Heap.partition ?p lr = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> set_tree lr = set_tree ?l' \\<union> set_tree ?r'\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by (fastforce split: prod.splits)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "using Node \\<open>\\<not> a \\<le> p\\<close> \"2.prems\" \"2.IH\"(4)[OF _ Node] set_partition[of ll]"], ["proof (prove)\nusing this:\n  \\<not> b \\<le> p\n  l = \\<langle>ll, b, lr\\<rangle>\n  \\<not> a \\<le> p\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; \\<not> b \\<le> p;\n   Splay_Heap.partition p ll = (?l', ?r'); bst_wrt (\\<le>) ll\\<rbrakk>\n  \\<Longrightarrow> bst_wrt (\\<le>) \\<langle>?l', p, ?r'\\<rangle>\n  \\<lbrakk>bst_wrt (\\<le>) ll;\n   Splay_Heap.partition ?p ll = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> set_tree ll = set_tree ?l' \\<union> set_tree ?r'\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>", "by (fastforce split: prod.splits)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>l', p, r'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_del_min[simp]: \"size(del_min t) = size t - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (del_min t) = size t - 1", "by(induction t rule: del_min.induct) (auto simp: neq_Leaf_iff)"], ["", "lemma mset_del_min: \"mset_tree (del_min h) = mset_tree h - {# get_min h #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (del_min h) = mset_tree h - {#get_min h#}", "proof(induction h rule: del_min.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. mset_tree (del_min \\<langle>\\<rangle>) =\n    mset_tree \\<langle>\\<rangle> - {#get_min \\<langle>\\<rangle>#}\n 2. \\<And>uu_ r.\n       mset_tree (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) =\n       mset_tree \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> -\n       {#get_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>#}\n 3. \\<And>ll a lr b r.\n       (ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        mset_tree (del_min ll) =\n        mset_tree ll - {#get_min ll#}) \\<Longrightarrow>\n       mset_tree\n        (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) =\n       mset_tree \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n       {#get_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>#}", "case (3 ll)"], ["proof (state)\nthis:\n  ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  mset_tree (del_min ll) = mset_tree ll - {#get_min ll#}\n\ngoal (3 subgoals):\n 1. mset_tree (del_min \\<langle>\\<rangle>) =\n    mset_tree \\<langle>\\<rangle> - {#get_min \\<langle>\\<rangle>#}\n 2. \\<And>uu_ r.\n       mset_tree (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) =\n       mset_tree \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> -\n       {#get_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>#}\n 3. \\<And>ll a lr b r.\n       (ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        mset_tree (del_min ll) =\n        mset_tree ll - {#get_min ll#}) \\<Longrightarrow>\n       mset_tree\n        (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) =\n       mset_tree \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n       {#get_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>#}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "assume \"ll = Leaf\""], ["proof (state)\nthis:\n  ll = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}\n 2. \\<not> ?P \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ll = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "using 3"], ["proof (prove)\nusing this:\n  ll = \\<langle>\\<rangle>\n  ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  mset_tree (del_min ll) = mset_tree ll - {#get_min ll#}\n\ngoal (1 subgoal):\n 1. mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  mset_tree\n   (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n  mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n  {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "assume \"ll \\<noteq> Leaf\""], ["proof (state)\nthis:\n  ll \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "hence \"get_min ll \\<in># mset_tree ll\""], ["proof (prove)\nusing this:\n  ll \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. get_min ll \\<in># mset_tree ll", "by (simp add: get_min_in)"], ["proof (state)\nthis:\n  get_min ll \\<in># mset_tree ll\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "then"], ["proof (chain)\npicking this:\n  get_min ll \\<in># mset_tree ll", "obtain A where \"mset_tree ll = add_mset (get_min ll) A\""], ["proof (prove)\nusing this:\n  get_min ll \\<in># mset_tree ll\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        mset_tree ll = add_mset (get_min ll) A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: multi_member_split)"], ["proof (state)\nthis:\n  mset_tree ll = add_mset (get_min ll) A\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "then"], ["proof (chain)\npicking this:\n  mset_tree ll = add_mset (get_min ll) A", "show ?thesis"], ["proof (prove)\nusing this:\n  mset_tree ll = add_mset (get_min ll) A\n\ngoal (1 subgoal):\n 1. mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "using 3"], ["proof (prove)\nusing this:\n  mset_tree ll = add_mset (get_min ll) A\n  ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  mset_tree (del_min ll) = mset_tree ll - {#get_min ll#}\n\ngoal (1 subgoal):\n 1. mset_tree\n     (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n    mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n    {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}", "by auto"], ["proof (state)\nthis:\n  mset_tree\n   (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n  mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n  {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_tree\n   (del_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>) =\n  mset_tree \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle> -\n  {#get_min \\<langle>\\<langle>ll, a_, lr_\\<rangle>, b_, r_\\<rangle>#}\n\ngoal (2 subgoals):\n 1. mset_tree (del_min \\<langle>\\<rangle>) =\n    mset_tree \\<langle>\\<rangle> - {#get_min \\<langle>\\<rangle>#}\n 2. \\<And>uu_ r.\n       mset_tree (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) =\n       mset_tree \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> -\n       {#get_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>#}", "qed auto"], ["", "lemma bst_del_min: \"bst_wrt (\\<le>) t \\<Longrightarrow> bst_wrt (\\<le>) (del_min t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) t \\<Longrightarrow> bst_wrt (\\<le>) (del_min t)", "apply(induction t rule: del_min.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bst_wrt (\\<le>) \\<langle>\\<rangle> \\<Longrightarrow>\n    bst_wrt (\\<le>) (del_min \\<langle>\\<rangle>)\n 2. \\<And>uu_ r.\n       bst_wrt (\\<le>)\n        \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>)\n        (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>)\n 3. \\<And>ll a lr b r.\n       \\<lbrakk>\\<lbrakk>ll \\<noteq> \\<langle>\\<rangle>;\n                 bst_wrt (\\<le>) ll\\<rbrakk>\n                \\<Longrightarrow> bst_wrt (\\<le>) (del_min ll);\n        bst_wrt (\\<le>)\n         \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>)\n                          (del_min\n                            \\<langle>\\<langle>ll, a, lr\\<rangle>, b,\n                             r\\<rangle>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ r.\n       bst_wrt (\\<le>)\n        \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> \\<Longrightarrow>\n       bst_wrt (\\<le>)\n        (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>)\n 2. \\<And>ll a lr b r.\n       \\<lbrakk>\\<lbrakk>ll \\<noteq> \\<langle>\\<rangle>;\n                 bst_wrt (\\<le>) ll\\<rbrakk>\n                \\<Longrightarrow> bst_wrt (\\<le>) (del_min ll);\n        bst_wrt (\\<le>)\n         \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>)\n                          (del_min\n                            \\<langle>\\<langle>ll, a, lr\\<rangle>, b,\n                             r\\<rangle>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll a lr b r.\n       \\<lbrakk>\\<lbrakk>ll \\<noteq> \\<langle>\\<rangle>;\n                 bst_wrt (\\<le>) ll\\<rbrakk>\n                \\<Longrightarrow> bst_wrt (\\<le>) (del_min ll);\n        bst_wrt (\\<le>)\n         \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>)\n                          (del_min\n                            \\<langle>\\<langle>ll, a, lr\\<rangle>, b,\n                             r\\<rangle>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll a lr b r x.\n       \\<lbrakk>bst_wrt (\\<le>) (del_min ll); a \\<le> b;\n        \\<forall>x\\<in>set_tree ll \\<union> set_tree lr. x \\<le> b;\n        \\<forall>x\\<in>set_tree r. b \\<le> x;\n        \\<forall>x\\<in>set_tree ll. x \\<le> a;\n        \\<forall>x\\<in>set_tree lr. a \\<le> x; bst_wrt (\\<le>) ll;\n        bst_wrt (\\<le>) lr; bst_wrt (\\<le>) r;\n        ll \\<noteq> \\<langle>\\<rangle>;\n        x \\<in> set_tree (del_min ll)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> a", "by (metis Multiset.diff_subset_eq_self subsetD set_mset_mono set_mset_tree mset_del_min)"], ["", "end"]]}