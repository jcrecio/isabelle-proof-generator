{"file_name": "/home/qj213/afp-2021-10-22/thys/Splay_Tree/Splay_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Splay_Tree", "problem_names": ["lemma splay_code: \"splay x (Node AB b CD) =\n  (case cmp x b of\n   EQ \\<Rightarrow> Node AB b CD |\n   LT \\<Rightarrow> (case AB of\n          Leaf \\<Rightarrow> Node AB b CD |\n          Node A a B \\<Rightarrow>\n            (case cmp x a of EQ \\<Rightarrow> Node A a (Node B b CD) |\n             LT \\<Rightarrow>  if A = Leaf then Node A a (Node B b CD)\n                       else case splay x A of\n                         Node A\\<^sub>1 a' A\\<^sub>2 \\<Rightarrow> Node A\\<^sub>1 a' (Node A\\<^sub>2 a (Node B b CD)) |\n             GT \\<Rightarrow> if B = Leaf then Node A a (Node B b CD)\n                       else case splay x B of\n                         Node B\\<^sub>1 b' B\\<^sub>2 \\<Rightarrow> Node (Node A a B\\<^sub>1) b' (Node B\\<^sub>2 b CD))) |\n   GT \\<Rightarrow> (case CD of\n          Leaf \\<Rightarrow> Node AB b CD |\n          Node C c D \\<Rightarrow>\n            (case cmp x c of EQ \\<Rightarrow> Node (Node AB b C) c D |\n             LT \\<Rightarrow> if C = Leaf then Node (Node AB b C) c D\n                       else case splay x C of\n                         Node C\\<^sub>1 c' C\\<^sub>2 \\<Rightarrow> Node (Node AB b C\\<^sub>1) c' (Node C\\<^sub>2 c D) |\n             GT \\<Rightarrow> if D=Leaf then Node (Node AB b C) c D\n                       else case splay x D of\n                         Node D\\<^sub>1 d D\\<^sub>2 \\<Rightarrow> Node (Node (Node AB b C) c D\\<^sub>1) d D\\<^sub>2)))\"", "lemma splay_max_code: \"splay_max t = (case t of\n  Leaf \\<Rightarrow> t |\n  Node la a ra \\<Rightarrow> (case ra of\n    Leaf \\<Rightarrow> t |\n    Node lb b rb \\<Rightarrow>\n      (if rb=Leaf then Node (Node la a lb) b rb\n       else case splay_max rb of\n              Node lc c rc \\<Rightarrow> Node (Node (Node la a lb) b lc) c rc)))\"", "lemma splay_Leaf_iff[simp]: \"(splay a t = Leaf) = (t = Leaf)\"", "lemma splay_max_Leaf_iff[simp]: \"(splay_max t = Leaf) = (t = Leaf)\"", "lemma splay_elemsD:\n  \"splay x t = Node l a r \\<Longrightarrow> sorted(inorder t) \\<Longrightarrow>\n  x \\<in> set (inorder t) \\<longleftrightarrow> x=a\"", "lemma isin_set: \"sorted(inorder t) \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\"", "lemma inorder_splay: \"inorder(splay x t) = inorder t\"", "lemma sorted_splay:\n  \"sorted(inorder t) \\<Longrightarrow> splay x t = Node l a r \\<Longrightarrow>\n  sorted(inorder l @ x # inorder r)\"", "lemma inorder_insert:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(insert x t) = ins_list x (inorder t)\"", "lemma inorder_splay_maxD:\n  \"splay_max t = Node l a r \\<Longrightarrow> sorted(inorder t) \\<Longrightarrow>\n  inorder l @ [a] = inorder t \\<and> r = Leaf\"", "lemma inorder_delete:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\"", "lemma bst_splay: \"bst t \\<Longrightarrow> bst (splay x t)\"", "lemma bst_insert: \"bst t \\<Longrightarrow> bst(insert x t)\"", "lemma bst_delete: \"bst t \\<Longrightarrow> bst(delete x t)\"", "lemma splay_bstL: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree l \\<Longrightarrow> x < a\"", "lemma splay_bstR: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree r \\<Longrightarrow> a < x\"", "lemma size_splay[simp]: \"size (splay a t) = size t\"", "lemma size_if_splay: \"splay a t = Node l u r \\<Longrightarrow> size t = size l + size r + 1\"", "lemma splay_not_Leaf: \"t \\<noteq> Leaf \\<Longrightarrow> \\<exists>l x r. splay a t = Node l x r\"", "lemma size_splay_max: \"size(splay_max t) = size t\"", "lemma size_if_splay_max: \"splay_max t = Node l u r \\<Longrightarrow> size t = size l + size r + 1\""], "translations": [["", "lemma splay_code: \"splay x (Node AB b CD) =\n  (case cmp x b of\n   EQ \\<Rightarrow> Node AB b CD |\n   LT \\<Rightarrow> (case AB of\n          Leaf \\<Rightarrow> Node AB b CD |\n          Node A a B \\<Rightarrow>\n            (case cmp x a of EQ \\<Rightarrow> Node A a (Node B b CD) |\n             LT \\<Rightarrow>  if A = Leaf then Node A a (Node B b CD)\n                       else case splay x A of\n                         Node A\\<^sub>1 a' A\\<^sub>2 \\<Rightarrow> Node A\\<^sub>1 a' (Node A\\<^sub>2 a (Node B b CD)) |\n             GT \\<Rightarrow> if B = Leaf then Node A a (Node B b CD)\n                       else case splay x B of\n                         Node B\\<^sub>1 b' B\\<^sub>2 \\<Rightarrow> Node (Node A a B\\<^sub>1) b' (Node B\\<^sub>2 b CD))) |\n   GT \\<Rightarrow> (case CD of\n          Leaf \\<Rightarrow> Node AB b CD |\n          Node C c D \\<Rightarrow>\n            (case cmp x c of EQ \\<Rightarrow> Node (Node AB b C) c D |\n             LT \\<Rightarrow> if C = Leaf then Node (Node AB b C) c D\n                       else case splay x C of\n                         Node C\\<^sub>1 c' C\\<^sub>2 \\<Rightarrow> Node (Node AB b C\\<^sub>1) c' (Node C\\<^sub>2 c D) |\n             GT \\<Rightarrow> if D=Leaf then Node (Node AB b C) c D\n                       else case splay x D of\n                         Node D\\<^sub>1 d D\\<^sub>2 \\<Rightarrow> Node (Node (Node AB b C) c D\\<^sub>1) d D\\<^sub>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splay x \\<langle>AB, b, CD\\<rangle> =\n    (case cmp x b of\n     LT \\<Rightarrow>\n       case AB of\n       \\<langle>\\<rangle> \\<Rightarrow> \\<langle>AB, b, CD\\<rangle>\n       | \\<langle>A, a, B\\<rangle> \\<Rightarrow>\n           case cmp x a of\n           LT \\<Rightarrow>\n             if A = \\<langle>\\<rangle>\n             then \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>\n             else case splay x A of\n                  \\<langle>A\\<^sub>1, a', A\\<^sub>2\\<rangle> \\<Rightarrow>\n                    \\<langle>A\\<^sub>1, a',\n                     \\<langle>A\\<^sub>2, a,\n                      \\<langle>B, b, CD\\<rangle>\\<rangle>\\<rangle>\n           | EQ \\<Rightarrow>\n               \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>\n           | GT \\<Rightarrow>\n               if B = \\<langle>\\<rangle>\n               then \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>\n               else case splay x B of\n                    \\<langle>B\\<^sub>1, b', B\\<^sub>2\\<rangle> \\<Rightarrow>\n                      \\<langle>\\<langle>A, a, B\\<^sub>1\\<rangle>, b',\n                       \\<langle>B\\<^sub>2, b, CD\\<rangle>\\<rangle>\n     | EQ \\<Rightarrow> \\<langle>AB, b, CD\\<rangle>\n     | GT \\<Rightarrow>\n         case CD of\n         \\<langle>\\<rangle> \\<Rightarrow> \\<langle>AB, b, CD\\<rangle>\n         | \\<langle>C, c, D\\<rangle> \\<Rightarrow>\n             case cmp x c of\n             LT \\<Rightarrow>\n               if C = \\<langle>\\<rangle>\n               then \\<langle>\\<langle>AB, b, C\\<rangle>, c, D\\<rangle>\n               else case splay x C of\n                    \\<langle>C\\<^sub>1, c', C\\<^sub>2\\<rangle> \\<Rightarrow>\n                      \\<langle>\\<langle>AB, b, C\\<^sub>1\\<rangle>, c',\n                       \\<langle>C\\<^sub>2, c, D\\<rangle>\\<rangle>\n             | EQ \\<Rightarrow>\n                 \\<langle>\\<langle>AB, b, C\\<rangle>, c, D\\<rangle>\n             | GT \\<Rightarrow>\n                 if D = \\<langle>\\<rangle>\n                 then \\<langle>\\<langle>AB, b, C\\<rangle>, c, D\\<rangle>\n                 else case splay x D of\n                      \\<langle>D\\<^sub>1, d,\n                       D\\<^sub>2\\<rangle> \\<Rightarrow>\n                        \\<langle>\\<langle>\\<langle>AB, b, C\\<rangle>, c,\n                                  D\\<^sub>1\\<rangle>,\n                         d, D\\<^sub>2\\<rangle>)", "by(auto split!: tree.split)"], ["", "definition is_root :: \"'a \\<Rightarrow> 'a tree \\<Rightarrow> bool\" where\n\"is_root x t = (case t of Leaf \\<Rightarrow> False | Node l a r \\<Rightarrow> x = a)\""], ["", "definition \"isin t x = is_root x (splay x t)\""], ["", "definition empty :: \"'a tree\" where\n\"empty = Leaf\""], ["", "hide_const (open) insert"], ["", "fun insert :: \"'a::linorder \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"insert x t =\n  (if t = Leaf then Node Leaf x Leaf\n   else case splay x t of\n     Node l a r \\<Rightarrow>\n      case cmp x a of\n        EQ \\<Rightarrow> Node l a r |\n        LT \\<Rightarrow> Node l x (Node Leaf a r) |\n        GT \\<Rightarrow> Node (Node l a Leaf) x r)\""], ["", "fun splay_max :: \"'a tree \\<Rightarrow> 'a tree\" where\n\"splay_max Leaf = Leaf\" |\n\"splay_max (Node A a Leaf) = Node A a Leaf\" |\n\"splay_max (Node A a (Node B b CD)) =\n  (if CD = Leaf then Node (Node A a B) b Leaf\n   else case splay_max CD of\n     Node C c D \\<Rightarrow> Node (Node (Node A a B) b C) c D)\""], ["", "lemma splay_max_code: \"splay_max t = (case t of\n  Leaf \\<Rightarrow> t |\n  Node la a ra \\<Rightarrow> (case ra of\n    Leaf \\<Rightarrow> t |\n    Node lb b rb \\<Rightarrow>\n      (if rb=Leaf then Node (Node la a lb) b rb\n       else case splay_max rb of\n              Node lc c rc \\<Rightarrow> Node (Node (Node la a lb) b lc) c rc)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splay_max t =\n    (case t of \\<langle>\\<rangle> \\<Rightarrow> t\n     | \\<langle>la, a, \\<langle>\\<rangle>\\<rangle> \\<Rightarrow> t\n     | \\<langle>la, a, \\<langle>lb, b, rb\\<rangle>\\<rangle> \\<Rightarrow>\n         if rb = \\<langle>\\<rangle>\n         then \\<langle>\\<langle>la, a, lb\\<rangle>, b, rb\\<rangle>\n         else case splay_max rb of\n              \\<langle>lc, c, rc\\<rangle> \\<Rightarrow>\n                \\<langle>\\<langle>\\<langle>la, a, lb\\<rangle>, b,\n                          lc\\<rangle>,\n                 c, rc\\<rangle>)", "by(auto simp: neq_Leaf_iff split: tree.split)"], ["", "definition delete :: \"'a::linorder \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"delete x t =\n  (if t = Leaf then Leaf\n   else case splay x t of Node l a r \\<Rightarrow>\n     if x \\<noteq> a then Node l a r\n     else if l = Leaf then r else case splay_max l of Node l' m r' \\<Rightarrow> Node l' m r)\""], ["", "subsection \"Functional Correctness Proofs I\""], ["", "text \\<open>This subsection follows the automated method by Nipkow \\cite{Nipkow-ITP16}.\\<close>"], ["", "lemma splay_Leaf_iff[simp]: \"(splay a t = Leaf) = (t = Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (splay a t = \\<langle>\\<rangle>) = (t = \\<langle>\\<rangle>)", "by(induction a t rule: splay.induct) (auto split: tree.splits)"], ["", "lemma splay_max_Leaf_iff[simp]: \"(splay_max t = Leaf) = (t = Leaf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (splay_max t = \\<langle>\\<rangle>) = (t = \\<langle>\\<rangle>)", "by(induction t rule: splay_max.induct)(auto split: tree.splits)"], ["", "subsubsection \"Verification of @{const isin}\""], ["", "lemma splay_elemsD:\n  \"splay x t = Node l a r \\<Longrightarrow> sorted(inorder t) \\<Longrightarrow>\n  x \\<in> set (inorder t) \\<longleftrightarrow> x=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>splay x t = \\<langle>l, a, r\\<rangle>;\n     Sorted_Less.sorted (inorder t)\\<rbrakk>\n    \\<Longrightarrow> (x \\<in> set (inorder t)) = (x = a)", "by(induction x t arbitrary: l a r rule: splay.induct)\n  (auto simp: isin_simps ball_Un split: tree.splits)"], ["", "lemma isin_set: \"sorted(inorder t) \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n    isin t x = (x \\<in> set (inorder t))", "by (auto simp: isin_def is_root_def dest: splay_elemsD split: tree.splits)"], ["", "subsubsection \"Verification of @{const insert}\""], ["", "lemma inorder_splay: \"inorder(splay x t) = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (splay x t) = inorder t", "by(induction x t rule: splay.induct)\n  (auto simp: neq_Leaf_iff split: tree.split)"], ["", "lemma sorted_splay:\n  \"sorted(inorder t) \\<Longrightarrow> splay x t = Node l a r \\<Longrightarrow>\n  sorted(inorder l @ x # inorder r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Sorted_Less.sorted (inorder t);\n     splay x t = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Sorted_Less.sorted (inorder l @ x # inorder r)", "unfolding inorder_splay[of x t, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Sorted_Less.sorted (inorder (splay x t));\n     splay x t = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> Sorted_Less.sorted (inorder l @ x # inorder r)", "by(induction x t arbitrary: l a r rule: splay.induct)\n  (auto simp: sorted_lems sorted_Cons_le sorted_snoc_le split: tree.splits)"], ["", "lemma inorder_insert:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(insert x t) = ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n    inorder (insert x t) = ins_list x (inorder t)", "using inorder_splay[of x t, symmetric] sorted_splay[of t x]"], ["proof (prove)\nusing this:\n  inorder t = inorder (splay x t)\n  \\<lbrakk>Sorted_Less.sorted (inorder t);\n   splay x t = \\<langle>?l, ?a, ?r\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> Sorted_Less.sorted (inorder ?l @ x # inorder ?r)\n\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n    inorder (insert x t) = ins_list x (inorder t)", "by(auto simp: ins_list_simps ins_list_Cons ins_list_snoc neq_Leaf_iff split: tree.split)"], ["", "subsubsection \"Verification of @{const delete}\""], ["", "lemma inorder_splay_maxD:\n  \"splay_max t = Node l a r \\<Longrightarrow> sorted(inorder t) \\<Longrightarrow>\n  inorder l @ [a] = inorder t \\<and> r = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>splay_max t = \\<langle>l, a, r\\<rangle>;\n     Sorted_Less.sorted (inorder t)\\<rbrakk>\n    \\<Longrightarrow> inorder l @ [a] = inorder t \\<and>\n                      r = \\<langle>\\<rangle>", "by(induction t arbitrary: l a r rule: splay_max.induct)\n  (auto simp: sorted_lems split: tree.splits if_splits)"], ["", "lemma inorder_delete:\n  \"sorted(inorder t) \\<Longrightarrow> inorder(delete x t) = del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n    inorder (delete x t) = del_list x (inorder t)", "using inorder_splay[of x t, symmetric] sorted_splay[of t x]"], ["proof (prove)\nusing this:\n  inorder t = inorder (splay x t)\n  \\<lbrakk>Sorted_Less.sorted (inorder t);\n   splay x t = \\<langle>?l, ?a, ?r\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> Sorted_Less.sorted (inorder ?l @ x # inorder ?r)\n\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n    inorder (delete x t) = del_list x (inorder t)", "by (auto simp: del_list_simps del_list_sorted_app delete_def\n  del_list_notin_Cons inorder_splay_maxD split: tree.splits)"], ["", "subsubsection \"Overall Correctness\""], ["", "interpretation splay: Set_by_Ordered\nwhere empty = empty and isin = isin and insert = insert\nand delete = delete and inorder = inorder and inv = \"\\<lambda>_. True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_by_Ordered Splay_Tree.empty insert delete isin inorder\n     (\\<lambda>_. True)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (inorder t))\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (insert x t) = ins_list x (inorder t)\n 4. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 5. True\n 6. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "case 2"], ["proof (state)\nthis:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (6 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (inorder t))\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (insert x t) = ins_list x (inorder t)\n 4. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 5. True\n 6. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (1 subgoal):\n 1. isin t_ x_ = (x_ \\<in> set (inorder t_))", "by(simp add: isin_set)"], ["proof (state)\nthis:\n  isin t_ x_ = (x_ \\<in> set (inorder t_))\n\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (insert x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 4. True\n 5. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (insert x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 4. True\n 5. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "case 3"], ["proof (state)\nthis:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (5 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (insert x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 4. True\n 5. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (1 subgoal):\n 1. inorder (insert x_ t_) = ins_list x_ (inorder t_)", "by(simp add: inorder_insert del: insert.simps)"], ["proof (state)\nthis:\n  inorder (insert x_ t_) = ins_list x_ (inorder t_)\n\ngoal (4 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 3. True\n 4. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 3. True\n 4. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "case 4"], ["proof (state)\nthis:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (4 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow>\n       inorder (delete x t) = del_list x (inorder t)\n 3. True\n 4. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "thus ?case"], ["proof (prove)\nusing this:\n  True \\<and> Sorted_Less.sorted (inorder t_)\n\ngoal (1 subgoal):\n 1. inorder (delete x_ t_) = del_list x_ (inorder t_)", "by(simp add: inorder_delete)"], ["proof (state)\nthis:\n  inorder (delete x_ t_) = del_list x_ (inorder t_)\n\ngoal (3 subgoals):\n 1. inorder Splay_Tree.empty = []\n 2. True\n 3. \\<And>t x.\n       True \\<and> Sorted_Less.sorted (inorder t) \\<Longrightarrow> True", "qed (auto simp: empty_def)"], ["", "text \\<open>Corollaries:\\<close>"], ["", "lemma bst_splay: \"bst t \\<Longrightarrow> bst (splay x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> bst (splay x t)", "by (simp add: bst_iff_sorted_wrt_less inorder_splay)"], ["", "lemma bst_insert: \"bst t \\<Longrightarrow> bst(insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> bst (insert x t)", "using splay.invar_insert[of t x]"], ["proof (prove)\nusing this:\n  splay.invar t \\<Longrightarrow> splay.invar (insert x t)\n\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> bst (insert x t)", "by (simp add: bst_iff_sorted_wrt_less splay.invar_def)"], ["", "lemma bst_delete: \"bst t \\<Longrightarrow> bst(delete x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> bst (delete x t)", "using splay.invar_delete[of t x]"], ["proof (prove)\nusing this:\n  splay.invar t \\<Longrightarrow> splay.invar (delete x t)\n\ngoal (1 subgoal):\n 1. bst t \\<Longrightarrow> bst (delete x t)", "by (simp add: bst_iff_sorted_wrt_less splay.invar_def)"], ["", "lemma splay_bstL: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree l \\<Longrightarrow> x < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst t; splay a t = \\<langle>l, e, r\\<rangle>;\n     x \\<in> set_tree l\\<rbrakk>\n    \\<Longrightarrow> x < a", "by (metis bst_iff_sorted_wrt_less list.set_intros(1) set_inorder sorted_splay sorted_wrt_append)"], ["", "lemma splay_bstR: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree r \\<Longrightarrow> a < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst t; splay a t = \\<langle>l, e, r\\<rangle>;\n     x \\<in> set_tree r\\<rbrakk>\n    \\<Longrightarrow> a < x", "by (metis bst_iff_sorted_wrt_less sorted_Cons_iff set_inorder sorted_splay sorted_wrt_append)"], ["", "subsubsection \"Size lemmas\""], ["", "lemma size_splay[simp]: \"size (splay a t) = size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (splay a t) = size t", "apply(induction a t rule: splay.induct)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x. size (splay x \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>x AB CD.\n       size (splay x \\<langle>AB, x, CD\\<rangle>) =\n       size \\<langle>AB, x, CD\\<rangle>\n 3. \\<And>x b A B CD.\n       x < b \\<Longrightarrow>\n       size (splay x \\<langle>\\<langle>A, x, B\\<rangle>, b, CD\\<rangle>) =\n       size \\<langle>\\<langle>A, x, B\\<rangle>, b, CD\\<rangle>\n 4. \\<And>x b CD.\n       x < b \\<Longrightarrow>\n       size (splay x \\<langle>\\<langle>\\<rangle>, b, CD\\<rangle>) =\n       size \\<langle>\\<langle>\\<rangle>, b, CD\\<rangle>\n 5. \\<And>x a b B CD.\n       \\<lbrakk>x < a; x < b\\<rbrakk>\n       \\<Longrightarrow> size\n                          (splay x\n                            \\<langle>\\<langle>\\<langle>\\<rangle>, a,\nB\\<rangle>,\n                             b, CD\\<rangle>) =\n                         size\n                          \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                                    B\\<rangle>,\n                           b, CD\\<rangle>\n 6. \\<And>x a b A B CD.\n       \\<lbrakk>x < a; x < b; A \\<noteq> \\<langle>\\<rangle>;\n        size (splay x A) = size A\\<rbrakk>\n       \\<Longrightarrow> size\n                          (splay x\n                            \\<langle>\\<langle>A, a, B\\<rangle>, b,\n                             CD\\<rangle>) =\n                         size\n                          \\<langle>\\<langle>A, a, B\\<rangle>, b, CD\\<rangle>\n 7. \\<And>a x b A CD.\n       \\<lbrakk>a < x; x < b\\<rbrakk>\n       \\<Longrightarrow> size\n                          (splay x\n                            \\<langle>\\<langle>A, a,\n\\<langle>\\<rangle>\\<rangle>,\n                             b, CD\\<rangle>) =\n                         size\n                          \\<langle>\\<langle>A, a,\n                                    \\<langle>\\<rangle>\\<rangle>,\n                           b, CD\\<rangle>\n 8. \\<And>a x b B A CD.\n       \\<lbrakk>a < x; x < b; B \\<noteq> \\<langle>\\<rangle>;\n        size (splay x B) = size B\\<rbrakk>\n       \\<Longrightarrow> size\n                          (splay x\n                            \\<langle>\\<langle>A, a, B\\<rangle>, b,\n                             CD\\<rangle>) =\n                         size\n                          \\<langle>\\<langle>A, a, B\\<rangle>, b, CD\\<rangle>\n 9. \\<And>b x AB C D.\n       b < x \\<Longrightarrow>\n       size (splay x \\<langle>AB, b, \\<langle>C, x, D\\<rangle>\\<rangle>) =\n       size \\<langle>AB, b, \\<langle>C, x, D\\<rangle>\\<rangle>\n 10. \\<And>b x AB.\n        b < x \\<Longrightarrow>\n        size (splay x \\<langle>AB, b, \\<langle>\\<rangle>\\<rangle>) =\n        size \\<langle>AB, b, \\<langle>\\<rangle>\\<rangle>\nA total of 14 subgoals...", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b A B CD.\n       \\<lbrakk>x < a; x < b; A \\<noteq> \\<langle>\\<rangle>;\n        size (splay x A) = size A\\<rbrakk>\n       \\<Longrightarrow> size\n                          (case splay x A of\n                           \\<langle>A1, a', A2\\<rangle> \\<Rightarrow>\n                             \\<langle>A1, a',\n                              \\<langle>A2, a,\n                               \\<langle>B, b,\n                                CD\\<rangle>\\<rangle>\\<rangle>) =\n                         Suc (Suc (size A + size B + size CD))\n 2. \\<And>a x b B A CD.\n       \\<lbrakk>a < x; x < b; B \\<noteq> \\<langle>\\<rangle>;\n        size (splay x B) = size B\\<rbrakk>\n       \\<Longrightarrow> size\n                          (case splay x B of\n                           \\<langle>B1, b', B2\\<rangle> \\<Rightarrow>\n                             \\<langle>\\<langle>A, a, B1\\<rangle>, b',\n                              \\<langle>B2, b, CD\\<rangle>\\<rangle>) =\n                         Suc (Suc (size A + size B + size CD))\n 3. \\<And>b x c C AB D.\n       \\<lbrakk>b < x; x < c; C \\<noteq> \\<langle>\\<rangle>;\n        size (splay x C) = size C\\<rbrakk>\n       \\<Longrightarrow> size\n                          (case splay x C of\n                           \\<langle>C1, c', C\\<rangle> \\<Rightarrow>\n                             \\<langle>\\<langle>AB, b, C1\\<rangle>, c',\n                              \\<langle>C, c, D\\<rangle>\\<rangle>) =\n                         Suc (Suc (size AB + (size C + size D)))\n 4. \\<And>a x c D AB C.\n       \\<lbrakk>a < x; c < x; D \\<noteq> \\<langle>\\<rangle>;\n        size (splay x D) = size D\\<rbrakk>\n       \\<Longrightarrow> size\n                          (case splay x D of\n                           \\<langle>D1, x, xa\\<rangle> \\<Rightarrow>\n                             \\<langle>\\<langle>\\<langle>AB, a, C\\<rangle>,\n c, D1\\<rangle>,\n                              x, xa\\<rangle>) =\n                         Suc (Suc (size AB + (size C + size D)))", "apply(force split: tree.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_if_splay: \"splay a t = Node l u r \\<Longrightarrow> size t = size l + size r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splay a t = \\<langle>l, u, r\\<rangle> \\<Longrightarrow>\n    size t = size l + size r + 1", "by (metis One_nat_def size_splay tree.size(4))"], ["", "lemma splay_not_Leaf: \"t \\<noteq> Leaf \\<Longrightarrow> \\<exists>l x r. splay a t = Node l x r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    \\<exists>l x r. splay a t = \\<langle>l, x, r\\<rangle>", "by (metis neq_Leaf_iff splay_Leaf_iff)"], ["", "lemma size_splay_max: \"size(splay_max t) = size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (splay_max t) = size t", "apply(induction t rule: splay_max.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. size (splay_max \\<langle>\\<rangle>) = size \\<langle>\\<rangle>\n 2. \\<And>A a.\n       size (splay_max \\<langle>A, a, \\<langle>\\<rangle>\\<rangle>) =\n       size \\<langle>A, a, \\<langle>\\<rangle>\\<rangle>\n 3. \\<And>A a B b CD.\n       (CD \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        size (splay_max CD) = size CD) \\<Longrightarrow>\n       size (splay_max \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>) =\n       size \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A a.\n       size (splay_max \\<langle>A, a, \\<langle>\\<rangle>\\<rangle>) =\n       size \\<langle>A, a, \\<langle>\\<rangle>\\<rangle>\n 2. \\<And>A a B b CD.\n       (CD \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        size (splay_max CD) = size CD) \\<Longrightarrow>\n       size (splay_max \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>) =\n       size \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A a B b CD.\n       (CD \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        size (splay_max CD) = size CD) \\<Longrightarrow>\n       size (splay_max \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>) =\n       size \\<langle>A, a, \\<langle>B, b, CD\\<rangle>\\<rangle>", "apply(clarsimp split: tree.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_if_splay_max: \"splay_max t = Node l u r \\<Longrightarrow> size t = size l + size r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. splay_max t = \\<langle>l, u, r\\<rangle> \\<Longrightarrow>\n    size t = size l + size r + 1", "by (metis One_nat_def size_splay_max tree.size(4))"], ["", "(*\nsubsection \"Functional Correctness Proofs II\"\n\ntext \\<open>This subsection follows the traditional approach, is less automated\nand is retained more for historic reasons.\\<close>\n\nlemma set_splay: \"set_tree(splay a t) = set_tree t\"\nproof(induction a t rule: splay.induct)\n  case (6 a)\n  with splay_not_Leaf[OF 6(3), of a] show ?case by(fastforce)\nnext\n  case (8 _ a)\n  with splay_not_Leaf[OF 8(3), of a] show ?case by(fastforce)\nnext\n  case (11 _ a)\n  with splay_not_Leaf[OF 11(3), of a] show ?case by(fastforce)\nnext\n  case (14 _ a)\n  with splay_not_Leaf[OF 14(3), of a] show ?case by(fastforce)\nqed auto\n\nlemma splay_bstL: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree l \\<Longrightarrow> x < a\"\napply(induction a t arbitrary: l x r rule: splay.induct)\napply (auto split: tree.splits)\napply auto\ndone\n\nlemma splay_bstR: \"bst t \\<Longrightarrow> splay a t = Node l e r \\<Longrightarrow> x \\<in> set_tree r \\<Longrightarrow> a < x\"\napply(induction a t arbitrary: l e x r rule: splay.induct)\napply auto\napply (fastforce split!: tree.splits)+\ndone\n\nlemma bst_splay: \"bst t \\<Longrightarrow> bst(splay a t)\"\nproof(induction a t rule: splay.induct)\n  case (6 a _ _ ll)\n  with splay_not_Leaf[OF 6(3), of a] set_splay[of a ll,symmetric]\n  show ?case by (fastforce)\nnext\n  case (8 _ a _ t)\n  with splay_not_Leaf[OF 8(3), of a] set_splay[of a t,symmetric]\n  show ?case by fastforce\nnext\n  case (11 _ a _ t)\n  with splay_not_Leaf[OF 11(3), of a] set_splay[of a t,symmetric]\n  show ?case by fastforce\nnext\n  case (14 _ a _ t)\n  with splay_not_Leaf[OF 14(3), of a] set_splay[of a t,symmetric]\n  show ?case by fastforce\nqed auto\n\nlemma splay_to_root: \"\\<lbrakk> bst t;  splay a t = t' \\<rbrakk> \\<Longrightarrow>\n  a \\<in> set_tree t \\<longleftrightarrow> (\\<exists>l r. t' = Node l a r)\"\nproof(induction a t arbitrary: t' rule: splay.induct)\n  case (6 a)\n  with splay_not_Leaf[OF 6(3), of a] show ?case by auto\nnext\n  case (8 _ a)\n  with splay_not_Leaf[OF 8(3), of a] show ?case by auto\nnext\n  case (11 _ a)\n  with splay_not_Leaf[OF 11(3), of a] show ?case by auto\nnext\n  case (14 _ a)\n  with splay_not_Leaf[OF 14(3), of a] show ?case by auto\nqed fastforce+\n\n\nsubsubsection \"Verification of Is-in Test\"\n\ntext\\<open>To test if an element \\<open>a\\<close> is in \\<open>t\\<close>, first perform\n@{term\"splay a t\"}, then check if the root is \\<open>a\\<close>. One could\nput this into one function that returns both a new tree and the test result.\\<close>\n\nlemma is_root_splay: \"bst t \\<Longrightarrow> is_root a (splay a t) \\<longleftrightarrow> a \\<in> set_tree t\"\nby(auto simp add: is_root_def splay_to_root split: tree.split)\n\n\nsubsubsection \"Verification of @{const insert}\"\n\nlemma set_insert: \"set_tree(insert a t) = Set.insert a (set_tree t)\"\napply(cases t)\n apply simp\nusing set_splay[of a t]\nby(simp split: tree.split) fastforce\n\nlemma bst_insert: \"bst t \\<Longrightarrow> bst(insert a t)\"\napply(cases t)\n apply simp\nusing bst_splay[of t a] splay_bstL[of t a] splay_bstR[of t a]\nby(auto simp: ball_Un split: tree.split)\n\n\nsubsubsection \"Verification of \\<open>splay_max\\<close>\"\n\nlemma set_splay_max: \"set_tree(splay_max t) = set_tree t\"\napply(induction t rule: splay_max.induct)\n   apply(simp)\n  apply(simp)\napply(force split: tree.split)\ndone\n\nlemma bst_splay_max: \"bst t \\<Longrightarrow> bst (splay_max t)\"\nproof(induction t rule: splay_max.induct)\n  case (3 l b rl c rr)\n  { fix rrl' d' rrr'\n    have \"splay_max rr = Node rrl' d' rrr'\n       \\<Longrightarrow> \\<forall>x \\<in> set_tree(Node rrl' d' rrr'). c < x\" \n      using \"3.prems\" set_splay_max[of rr]\n      by (clarsimp split: tree.split simp: ball_Un)\n  }\n  with 3 show ?case by (fastforce split: tree.split simp: ball_Un)\nqed auto\n\nlemma splay_max_Leaf: \"splay_max t = Node l a r \\<Longrightarrow> r = Leaf\"\nby(induction t arbitrary: l rule: splay_max.induct)\n  (auto split: tree.splits if_splits)\n\ntext\\<open>For sanity purposes only:\\<close>\n\nlemma splay_max_eq_splay:\n  \"bst t \\<Longrightarrow> \\<forall>x \\<in> set_tree t. x \\<le> a \\<Longrightarrow> splay_max t = splay a t\"\nproof(induction a t rule: splay.induct)\n  case (2 a l r)\n  show ?case\n  proof (cases r)\n    case Leaf with 2 show ?thesis by simp\n  next\n    case Node with 2 show ?thesis by(auto)\n  qed\nqed (auto simp: neq_Leaf_iff)\n\nlemma splay_max_eq_splay_ex: assumes \"bst t\" shows \"\\<exists>a. splay_max t = splay a t\"\nproof(cases t)\n  case Leaf thus ?thesis by simp\nnext\n  case Node\n  hence \"splay_max t = splay (Max(set_tree t)) t\"\n    using assms by (auto simp: splay_max_eq_splay)\n  thus ?thesis by auto\nqed\n\n\nsubsubsection \"Verification of @{const delete}\"\n\nlemma set_delete: assumes \"bst t\"\nshows \"set_tree (delete a t) = set_tree t - {a}\"\nproof(cases t)\n  case Leaf thus ?thesis by(simp add: delete_def)\nnext\n  case (Node l x r)\n  obtain l' x' r' where sp[simp]: \"splay a (Node l x r) = Node l' x' r'\"\n    by (metis neq_Leaf_iff splay_Leaf_iff)\n  show ?thesis\n  proof cases\n    assume [simp]: \"x' = a\"\n    show ?thesis\n    proof cases\n      assume \"l' = Leaf\"\n      thus ?thesis\n        using Node assms set_splay[of a \"Node l x r\"] bst_splay[of \"Node l x r\" a]\n        by(simp add: delete_def split: tree.split prod.split)(fastforce)\n    next\n      assume \"l' \\<noteq> Leaf\"\n      moreover then obtain l'' m r'' where \"splay_max l' = Node l'' m r''\"\n        using splay_max_Leaf_iff tree.exhaust by blast\n      moreover have \"a \\<notin> set_tree l'\"\n        by (metis (no_types) Node assms less_irrefl sp splay_bstL)\n      ultimately show ?thesis\n        using Node assms set_splay[of a \"Node l x r\"] bst_splay[of \"Node l x r\" a]\n          splay_max_Leaf[of l' l'' m r''] set_splay_max[of l']\n        by(clarsimp simp: delete_def split: tree.split) auto\n    qed\n  next\n    assume \"x' \\<noteq> a\"\n    thus ?thesis using Node assms set_splay[of a \"Node l x r\"] splay_to_root[OF _ sp]\n      by (simp add: delete_def)\n  qed\nqed\n\nlemma bst_delete: assumes \"bst t\" shows \"bst (delete a t)\"\nproof(cases t)\n  case Leaf thus ?thesis by(simp add: delete_def)\nnext\n  case (Node l x r)\n  obtain l' x' r' where sp[simp]: \"splay a (Node l x r) = Node l' x' r'\"\n    by (metis neq_Leaf_iff splay_Leaf_iff)\n  show ?thesis\n  proof cases\n    assume [simp]: \"x' = a\"\n    show ?thesis\n    proof cases\n      assume \"l' = Leaf\"\n      thus ?thesis using Node assms bst_splay[of \"Node l x r\" a]\n        by(simp add: delete_def split: tree.split prod.split)\n    next\n      assume \"l' \\<noteq> Leaf\"\n      thus ?thesis\n        using Node assms set_splay[of a \"Node l x r\"] bst_splay[of \"Node l x r\" a]\n          bst_splay_max[of l'] set_splay_max[of l']\n        by(clarsimp simp: delete_def split: tree.split)\n          (metis (no_types) insertI1 less_trans)\n    qed\n  next\n    assume \"x' \\<noteq> a\"\n    thus ?thesis using Node assms bst_splay[of \"Node l x r\" a]\n      by(auto simp: delete_def split: tree.split prod.split)\n  qed\nqed\n*)"], ["", "end"]]}