{"file_name": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian/Log_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian", "problem_names": ["lemma square_base: \"get_base (square_base b) = get_base b * get_base b\"", "lemma get_base_2: \"get_base b \\<ge> 2\"", "lemma b_less_square_base_b: \"get_base b < get_base (square_base b)\"", "lemma b_less_div_base_b: assumes xb: \"\\<not> x < get_base b\"\n  shows \"x div get_base b < x\"", "lemma log_main: \"x > 0 \\<Longrightarrow> log_main b x = (y,by) \\<Longrightarrow> by = (get_base b)^y \\<and> (get_base b)^y \\<le> x \\<and> x < (get_base b)^(Suc y)\"", "lemma log_floor_sound: assumes \"b > 1\" \"x > 0\" \"log_floor b x = y\"  \n  shows \"b^y \\<le> x\" \"x < b^(Suc y)\"", "lemma log_ceiling_sound: assumes \"b > 1\" \"x > 0\" \"log_ceiling b x = y\"  \n  shows \"x \\<le> b^y\" \"y \\<noteq> 0 \\<Longrightarrow> b^(y - 1) < x\"", "lemma log_floor[simp]: assumes b: \"b > 1\" and x: \"x > 0\"\n  shows \"log_floor b x = \\<lfloor>log b x\\<rfloor>\"", "lemma log_ceiling[simp]: assumes b: \"b > 1\" and x: \"x > 0\"\n  shows \"log_ceiling b x = \\<lceil>log b x\\<rceil>\""], "translations": [["", "lemma square_base: \"get_base (square_base b) = get_base b * get_base b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_base (square_base b) = get_base b * get_base b", "by (transfer, auto)"], ["", "lemma get_base_2: \"get_base b \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> get_base b", "by (transfer, auto)"], ["", "lemma b_less_square_base_b: \"get_base b < get_base (square_base b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_base b < get_base (square_base b)", "unfolding square_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_base b < get_base b * get_base b", "using get_base_2[of b]"], ["proof (prove)\nusing this:\n  2 \\<le> get_base b\n\ngoal (1 subgoal):\n 1. get_base b < get_base b * get_base b", "by simp"], ["", "lemma b_less_div_base_b: assumes xb: \"\\<not> x < get_base b\"\n  shows \"x div get_base b < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div get_base b < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x div get_base b < x", "from get_base_2[of b]"], ["proof (chain)\npicking this:\n  2 \\<le> get_base b", "have b: \"get_base b \\<ge> 2\""], ["proof (prove)\nusing this:\n  2 \\<le> get_base b\n\ngoal (1 subgoal):\n 1. 2 \\<le> get_base b", "."], ["proof (state)\nthis:\n  2 \\<le> get_base b\n\ngoal (1 subgoal):\n 1. x div get_base b < x", "with xb"], ["proof (chain)\npicking this:\n  \\<not> x < get_base b\n  2 \\<le> get_base b", "have x2: \"x \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<not> x < get_base b\n  2 \\<le> get_base b\n\ngoal (1 subgoal):\n 1. 2 \\<le> x", "by auto"], ["proof (state)\nthis:\n  2 \\<le> x\n\ngoal (1 subgoal):\n 1. x div get_base b < x", "with b int_div_less_self[of x \"(get_base b)\"]"], ["proof (chain)\npicking this:\n  2 \\<le> get_base b\n  \\<lbrakk>0 < x; 1 < get_base b\\<rbrakk>\n  \\<Longrightarrow> x div get_base b < x\n  2 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> get_base b\n  \\<lbrakk>0 < x; 1 < get_base b\\<rbrakk>\n  \\<Longrightarrow> x div get_base b < x\n  2 \\<le> x\n\ngoal (1 subgoal):\n 1. x div get_base b < x", "by auto"], ["proof (state)\nthis:\n  x div get_base b < x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now state the main algorithm.\\<close>"], ["", "function log_main :: \"proper_base \\<Rightarrow> int \\<Rightarrow> nat \\<times> int\" where\n  \"log_main b x = (if x < get_base b then (0,1) else\n    case log_main (square_base b) x of \n      (z, bz) \\<Rightarrow> \n    let l = 2 * z; bz1 = bz * get_base b\n      in if x < bz1 then (l,bz) else (Suc l,bz1))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>b xa. x = (b, xa) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>b x ba xa.\n       (b, x) = (ba, xa) \\<Longrightarrow>\n       (if x < get_base b then (0, 1)\n        else case log_main_sumC (square_base b, x) of\n             (z, bz) \\<Rightarrow>\n               let l = 2 * z; bz1 = bz * get_base b\n               in if x < bz1 then (l, bz) else (Suc l, bz1)) =\n       (if xa < get_base ba then (0, 1)\n        else case log_main_sumC (square_base ba, xa) of\n             (z, bz) \\<Rightarrow>\n               let l = 2 * z; bz1 = bz * get_base ba\n               in if xa < bz1 then (l, bz) else (Suc l, bz1))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All log_main_dom", "by (relation \"measure (\\<lambda> (b,x). nat (1 + x - get_base b))\",\n  insert b_less_square_base_b, auto)"], ["", "lemma log_main: \"x > 0 \\<Longrightarrow> log_main b x = (y,by) \\<Longrightarrow> by = (get_base b)^y \\<and> (get_base b)^y \\<le> x \\<and> x < (get_base b)^(Suc y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; log_main b x = (y, by)\\<rbrakk>\n    \\<Longrightarrow> by = get_base b ^ y \\<and>\n                      get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "proof (induct b x arbitrary: y \"by\" rule: log_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "case (1 b x y \"by\")"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> x < get_base b; 0 < x;\n   log_main (square_base b) x = (?y, ?by)\\<rbrakk>\n  \\<Longrightarrow> ?by = get_base (square_base b) ^ ?y \\<and>\n                    get_base (square_base b) ^ ?y \\<le> x \\<and>\n                    x < get_base (square_base b) ^ Suc ?y\n  0 < x\n  log_main b x = (y, by)\n\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "note x = 1(2)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "note y = 1(3)"], ["proof (state)\nthis:\n  log_main b x = (y, by)\n\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "note IH = 1(1)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> x < get_base b; 0 < x;\n   log_main (square_base b) x = (?y, ?by)\\<rbrakk>\n  \\<Longrightarrow> ?by = get_base (square_base b) ^ ?y \\<and>\n                    get_base (square_base b) ^ ?y \\<le> x \\<and>\n                    x < get_base (square_base b) ^ Suc ?y\n\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "let ?b = \"get_base b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b x y by.\n       \\<lbrakk>\\<And>y by.\n                   \\<lbrakk>\\<not> x < get_base b; 0 < x;\n                    log_main (square_base b) x = (y, by)\\<rbrakk>\n                   \\<Longrightarrow> by =\n                                     get_base (square_base b) ^ y \\<and>\n                                     get_base (square_base b) ^ y\n                                     \\<le> x \\<and>\n                                     x < get_base (square_base b) ^ Suc y;\n        0 < x; log_main b x = (y, by)\\<rbrakk>\n       \\<Longrightarrow> by = get_base b ^ y \\<and>\n                         get_base b ^ y \\<le> x \\<and>\n                         x < get_base b ^ Suc y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "proof (cases \"x < ?b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n 2. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "case True"], ["proof (state)\nthis:\n  x < get_base b\n\ngoal (2 subgoals):\n 1. x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n 2. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "with x y"], ["proof (chain)\npicking this:\n  0 < x\n  log_main b x = (y, by)\n  x < get_base b", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < x\n  log_main b x = (y, by)\n  x < get_base b\n\ngoal (1 subgoal):\n 1. by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "by auto"], ["proof (state)\nthis:\n  by = get_base b ^ y \\<and>\n  get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "case False"], ["proof (state)\nthis:\n  \\<not> x < get_base b\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "obtain z bz where zz: \"log_main (square_base b) x = (z,bz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z bz.\n        log_main (square_base b) x = (z, bz) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"log_main (square_base b) x\", auto)"], ["proof (state)\nthis:\n  log_main (square_base b) x = (z, bz)\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "have id: \"get_base (square_base b) ^ k = ?b ^ (2 * k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_base (square_base b) ^ k = get_base b ^ (2 * k)", "unfolding square_base"], ["proof (prove)\ngoal (1 subgoal):\n 1. (get_base b * get_base b) ^ k = get_base b ^ (2 * k)", "by (simp add: power_mult semiring_normalization_rules(29))"], ["proof (state)\nthis:\n  get_base (square_base b) ^ ?k = get_base b ^ (2 * ?k)\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "from IH[OF False x zz, unfolded id]"], ["proof (chain)\npicking this:\n  bz = get_base b ^ (2 * z) \\<and>\n  get_base b ^ (2 * z) \\<le> x \\<and> x < get_base b ^ (2 * Suc z)", "have z: \"?b ^ (2 * z) \\<le> x\" \"x < ?b ^ (2 * Suc z)\" and bz: \"bz = get_base b ^ (2 * z)\""], ["proof (prove)\nusing this:\n  bz = get_base b ^ (2 * z) \\<and>\n  get_base b ^ (2 * z) \\<le> x \\<and> x < get_base b ^ (2 * Suc z)\n\ngoal (1 subgoal):\n 1. (get_base b ^ (2 * z) \\<le> x &&& x < get_base b ^ (2 * Suc z)) &&&\n    bz = get_base b ^ (2 * z)", "by auto"], ["proof (state)\nthis:\n  get_base b ^ (2 * z) \\<le> x\n  x < get_base b ^ (2 * Suc z)\n  bz = get_base b ^ (2 * z)\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "from y[unfolded log_main.simps[of b x] Let_def zz split] bz False"], ["proof (chain)\npicking this:\n  (if x < get_base b then (0, 1)\n   else if x < bz * get_base b then (2 * z, bz)\n        else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  bz = get_base b ^ (2 * z)\n  \\<not> x < get_base b", "have yy: \"(if x < bz * ?b then (2 * z, bz) else (Suc (2 * z), bz * ?b)) =\n      (y, by)\""], ["proof (prove)\nusing this:\n  (if x < get_base b then (0, 1)\n   else if x < bz * get_base b then (2 * z, bz)\n        else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  bz = get_base b ^ (2 * z)\n  \\<not> x < get_base b\n\ngoal (1 subgoal):\n 1. (if x < bz * get_base b then (2 * z, bz)\n     else (Suc (2 * z), bz * get_base b)) =\n    (y, by)", "by auto"], ["proof (state)\nthis:\n  (if x < bz * get_base b then (2 * z, bz)\n   else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n\ngoal (1 subgoal):\n 1. \\<not> x < get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "proof (cases \"x < bz * ?b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n 2. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "case True"], ["proof (state)\nthis:\n  x < bz * get_base b\n\ngoal (2 subgoals):\n 1. x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n 2. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "with yy"], ["proof (chain)\npicking this:\n  (if x < bz * get_base b then (2 * z, bz)\n   else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  x < bz * get_base b", "have yz: \"y = 2 * z\" \"by = bz\""], ["proof (prove)\nusing this:\n  (if x < bz * get_base b then (2 * z, bz)\n   else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  x < bz * get_base b\n\ngoal (1 subgoal):\n 1. y = 2 * z &&& by = bz", "by auto"], ["proof (state)\nthis:\n  y = 2 * z\n  by = bz\n\ngoal (2 subgoals):\n 1. x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n 2. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "from True z(1) bz"], ["proof (chain)\npicking this:\n  x < bz * get_base b\n  get_base b ^ (2 * z) \\<le> x\n  bz = get_base b ^ (2 * z)", "show ?thesis"], ["proof (prove)\nusing this:\n  x < bz * get_base b\n  get_base b ^ (2 * z) \\<le> x\n  bz = get_base b ^ (2 * z)\n\ngoal (1 subgoal):\n 1. by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "unfolding yz"], ["proof (prove)\nusing this:\n  x < bz * get_base b\n  get_base b ^ (2 * z) \\<le> x\n  bz = get_base b ^ (2 * z)\n\ngoal (1 subgoal):\n 1. bz = get_base b ^ (2 * z) \\<and>\n    get_base b ^ (2 * z) \\<le> x \\<and> x < get_base b ^ Suc (2 * z)", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  by = get_base b ^ y \\<and>\n  get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n\ngoal (1 subgoal):\n 1. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "case False"], ["proof (state)\nthis:\n  \\<not> x < bz * get_base b\n\ngoal (1 subgoal):\n 1. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "with yy"], ["proof (chain)\npicking this:\n  (if x < bz * get_base b then (2 * z, bz)\n   else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  \\<not> x < bz * get_base b", "have yz: \"y = Suc (2 * z)\" \"by = ?b * bz\""], ["proof (prove)\nusing this:\n  (if x < bz * get_base b then (2 * z, bz)\n   else (Suc (2 * z), bz * get_base b)) =\n  (y, by)\n  \\<not> x < bz * get_base b\n\ngoal (1 subgoal):\n 1. y = Suc (2 * z) &&& by = get_base b * bz", "by auto"], ["proof (state)\nthis:\n  y = Suc (2 * z)\n  by = get_base b * bz\n\ngoal (1 subgoal):\n 1. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "from False"], ["proof (chain)\npicking this:\n  \\<not> x < bz * get_base b", "have \"?b ^ Suc (2 * z) \\<le> x\""], ["proof (prove)\nusing this:\n  \\<not> x < bz * get_base b\n\ngoal (1 subgoal):\n 1. get_base b ^ Suc (2 * z) \\<le> x", "by (auto simp: bz ac_simps)"], ["proof (state)\nthis:\n  get_base b ^ Suc (2 * z) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> x < bz * get_base b \\<Longrightarrow>\n    by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "with z(2) bz"], ["proof (chain)\npicking this:\n  x < get_base b ^ (2 * Suc z)\n  bz = get_base b ^ (2 * z)\n  get_base b ^ Suc (2 * z) \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  x < get_base b ^ (2 * Suc z)\n  bz = get_base b ^ (2 * z)\n  get_base b ^ Suc (2 * z) \\<le> x\n\ngoal (1 subgoal):\n 1. by = get_base b ^ y \\<and>\n    get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y", "unfolding yz"], ["proof (prove)\nusing this:\n  x < get_base b ^ (2 * Suc z)\n  bz = get_base b ^ (2 * z)\n  get_base b ^ Suc (2 * z) \\<le> x\n\ngoal (1 subgoal):\n 1. get_base b * bz = get_base b ^ Suc (2 * z) \\<and>\n    get_base b ^ Suc (2 * z) \\<le> x \\<and>\n    x < get_base b ^ Suc (Suc (2 * z))", "by auto"], ["proof (state)\nthis:\n  by = get_base b ^ y \\<and>\n  get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  by = get_base b ^ y \\<and>\n  get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  by = get_base b ^ y \\<and>\n  get_base b ^ y \\<le> x \\<and> x < get_base b ^ Suc y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We then derive the floor- and ceiling-log functions.\\<close>"], ["", "definition log_floor :: \"int \\<Rightarrow> int \\<Rightarrow> nat\" where\n  \"log_floor b x = fst (log_main (into_base b) x)\""], ["", "definition log_ceiling :: \"int \\<Rightarrow> int \\<Rightarrow> nat\" where\n  \"log_ceiling b x = (case log_main (into_base b) x of\n     (y,by) \\<Rightarrow> if x = by then y else Suc y)\""], ["", "lemma log_floor_sound: assumes \"b > 1\" \"x > 0\" \"log_floor b x = y\"  \n  shows \"b^y \\<le> x\" \"x < b^(Suc y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ^ y \\<le> x &&& x < b ^ Suc y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. b ^ y \\<le> x\n 2. x < b ^ Suc y", "from assms(1,3)"], ["proof (chain)\npicking this:\n  1 < b\n  log_floor b x = y", "have id: \"get_base (into_base b) = b\""], ["proof (prove)\nusing this:\n  1 < b\n  log_floor b x = y\n\ngoal (1 subgoal):\n 1. get_base (into_base b) = b", "by transfer auto"], ["proof (state)\nthis:\n  get_base (into_base b) = b\n\ngoal (2 subgoals):\n 1. b ^ y \\<le> x\n 2. x < b ^ Suc y", "obtain yy bb where log: \"log_main (into_base b) x = (yy,bb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yy bb.\n        log_main (into_base b) x = (yy, bb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"log_main (into_base b) x\", auto)"], ["proof (state)\nthis:\n  log_main (into_base b) x = (yy, bb)\n\ngoal (2 subgoals):\n 1. b ^ y \\<le> x\n 2. x < b ^ Suc y", "from log_main[OF assms(2) log] assms(3)[unfolded log_floor_def log] id"], ["proof (chain)\npicking this:\n  bb = get_base (into_base b) ^ yy \\<and>\n  get_base (into_base b) ^ yy \\<le> x \\<and>\n  x < get_base (into_base b) ^ Suc yy\n  fst (yy, bb) = y\n  get_base (into_base b) = b", "show \"b^y \\<le> x\" \"x < b^(Suc y)\""], ["proof (prove)\nusing this:\n  bb = get_base (into_base b) ^ yy \\<and>\n  get_base (into_base b) ^ yy \\<le> x \\<and>\n  x < get_base (into_base b) ^ Suc yy\n  fst (yy, bb) = y\n  get_base (into_base b) = b\n\ngoal (1 subgoal):\n 1. b ^ y \\<le> x &&& x < b ^ Suc y", "by auto"], ["proof (state)\nthis:\n  b ^ y \\<le> x\n  x < b ^ Suc y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma log_ceiling_sound: assumes \"b > 1\" \"x > 0\" \"log_ceiling b x = y\"  \n  shows \"x \\<le> b^y\" \"y \\<noteq> 0 \\<Longrightarrow> b^(y - 1) < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> b ^ y &&& (y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> b ^ y\n 2. y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x", "from assms(1,3)"], ["proof (chain)\npicking this:\n  1 < b\n  log_ceiling b x = y", "have id: \"get_base (into_base b) = b\""], ["proof (prove)\nusing this:\n  1 < b\n  log_ceiling b x = y\n\ngoal (1 subgoal):\n 1. get_base (into_base b) = b", "by transfer auto"], ["proof (state)\nthis:\n  get_base (into_base b) = b\n\ngoal (2 subgoals):\n 1. x \\<le> b ^ y\n 2. y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x", "obtain yy bb where log: \"log_main (into_base b) x = (yy,bb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yy bb.\n        log_main (into_base b) x = (yy, bb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"log_main (into_base b) x\", auto)"], ["proof (state)\nthis:\n  log_main (into_base b) x = (yy, bb)\n\ngoal (2 subgoals):\n 1. x \\<le> b ^ y\n 2. y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x", "from log_main[OF assms(2) log, unfolded id] assms(3)[unfolded log_ceiling_def log split]"], ["proof (chain)\npicking this:\n  bb = b ^ yy \\<and> b ^ yy \\<le> x \\<and> x < b ^ Suc yy\n  (if x = bb then yy else Suc yy) = y", "have bnd: \"b ^ yy \\<le> x\" \"x < b ^ Suc yy\" and\n    y: \"y = (if x = b ^ yy then yy else Suc yy)\""], ["proof (prove)\nusing this:\n  bb = b ^ yy \\<and> b ^ yy \\<le> x \\<and> x < b ^ Suc yy\n  (if x = bb then yy else Suc yy) = y\n\ngoal (1 subgoal):\n 1. (b ^ yy \\<le> x &&& x < b ^ Suc yy) &&&\n    y = (if x = b ^ yy then yy else Suc yy)", "by auto"], ["proof (state)\nthis:\n  b ^ yy \\<le> x\n  x < b ^ Suc yy\n  y = (if x = b ^ yy then yy else Suc yy)\n\ngoal (2 subgoals):\n 1. x \\<le> b ^ y\n 2. y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x", "have \"x \\<le> b^y \\<and> (y \\<noteq> 0 \\<longrightarrow> b^(y - 1) < x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "proof (cases \"x = b ^ yy\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n 2. x \\<noteq> b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "case True"], ["proof (state)\nthis:\n  x = b ^ yy\n\ngoal (2 subgoals):\n 1. x = b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n 2. x \\<noteq> b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "with y bnd assms(1)"], ["proof (chain)\npicking this:\n  y = (if x = b ^ yy then yy else Suc yy)\n  b ^ yy \\<le> x\n  x < b ^ Suc yy\n  1 < b\n  x = b ^ yy", "show ?thesis"], ["proof (prove)\nusing this:\n  y = (if x = b ^ yy then yy else Suc yy)\n  b ^ yy \\<le> x\n  x < b ^ Suc yy\n  1 < b\n  x = b ^ yy\n\ngoal (1 subgoal):\n 1. x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "by (cases yy, auto)"], ["proof (state)\nthis:\n  x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> b ^ yy\n\ngoal (1 subgoal):\n 1. x \\<noteq> b ^ yy \\<Longrightarrow>\n    x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "with y bnd"], ["proof (chain)\npicking this:\n  y = (if x = b ^ yy then yy else Suc yy)\n  b ^ yy \\<le> x\n  x < b ^ Suc yy\n  x \\<noteq> b ^ yy", "show ?thesis"], ["proof (prove)\nusing this:\n  y = (if x = b ^ yy then yy else Suc yy)\n  b ^ yy \\<le> x\n  x < b ^ Suc yy\n  x \\<noteq> b ^ yy\n\ngoal (1 subgoal):\n 1. x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)", "by auto"], ["proof (state)\nthis:\n  x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n\ngoal (2 subgoals):\n 1. x \\<le> b ^ y\n 2. y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x", "thus \"x \\<le> b^y\" \"y \\<noteq> 0 \\<Longrightarrow> b^(y - 1) < x\""], ["proof (prove)\nusing this:\n  x \\<le> b ^ y \\<and> (y \\<noteq> 0 \\<longrightarrow> b ^ (y - 1) < x)\n\ngoal (1 subgoal):\n 1. x \\<le> b ^ y &&& (y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x)", "by auto"], ["proof (state)\nthis:\n  x \\<le> b ^ y\n  y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we connect it to the @{const log} function working on real numbers.\\<close>"], ["", "lemma log_floor[simp]: assumes b: \"b > 1\" and x: \"x > 0\"\n  shows \"log_floor b x = \\<lfloor>log b x\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "obtain y where y: \"log_floor b x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. log_floor b x = y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  log_floor b x = y\n\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "note main = log_floor_sound[OF assms y]"], ["proof (state)\nthis:\n  b ^ y \\<le> x\n  x < b ^ Suc y\n\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "from b x"], ["proof (chain)\npicking this:\n  1 < b\n  0 < x", "have *: \"1 < real_of_int b\" \"0 < real_of_int (b ^ y)\" \"0 < real_of_int x\" \n    and **: \"1 < real_of_int b\" \"0 < real_of_int x\" \"0 < real_of_int (b ^ Suc y)\""], ["proof (prove)\nusing this:\n  1 < b\n  0 < x\n\ngoal (1 subgoal):\n 1. (1 < real_of_int b &&&\n     0 < real_of_int (b ^ y) &&& 0 < real_of_int x) &&&\n    1 < real_of_int b &&& 0 < real_of_int x &&& 0 < real_of_int (b ^ Suc y)", "by auto"], ["proof (state)\nthis:\n  1 < real_of_int b\n  0 < real_of_int (b ^ y)\n  0 < real_of_int x\n  1 < real_of_int b\n  0 < real_of_int x\n  0 < real_of_int (b ^ Suc y)\n\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (log_floor b x) =\n    \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "unfolding y"], ["proof (prove)\ngoal (1 subgoal):\n 1. int y = \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>", "proof (rule sym, rule floor_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)\n 2. log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1", "show \"real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)", "using main(1)[folded log_le_cancel_iff[OF *, unfolded of_int_le_iff]]"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int (b ^ y))\n  \\<le> log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)", "using log_pow_cancel[of b y] b"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int (b ^ y))\n  \\<le> log (real_of_int b) (real_of_int x)\n  \\<lbrakk>0 < real_of_int b; real_of_int b \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> log (real_of_int b) (real_of_int b ^ y) = real y\n  1 < b\n\ngoal (1 subgoal):\n 1. real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)", "by auto"], ["proof (state)\nthis:\n  real_of_int (int y) \\<le> log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1", "show \"log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1", "using main(2)[folded log_less_cancel_iff[OF **, unfolded of_int_less_iff]]"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int x)\n  < log (real_of_int b) (real_of_int (b ^ Suc y))\n\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1", "using log_pow_cancel[of b \"Suc y\"] b"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int x)\n  < log (real_of_int b) (real_of_int (b ^ Suc y))\n  \\<lbrakk>0 < real_of_int b; real_of_int b \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> log (real_of_int b) (real_of_int b ^ Suc y) =\n                    real (Suc y)\n  1 < b\n\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1", "by auto"], ["proof (state)\nthis:\n  log (real_of_int b) (real_of_int x) < real_of_int (int y) + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (log_floor b x) =\n  \\<lfloor>log (real_of_int b) (real_of_int x)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma log_ceiling[simp]: assumes b: \"b > 1\" and x: \"x > 0\"\n  shows \"log_ceiling b x = \\<lceil>log b x\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "obtain y where y: \"log_ceiling b x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        log_ceiling b x = y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  log_ceiling b x = y\n\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "note main = log_ceiling_sound[OF assms y]"], ["proof (state)\nthis:\n  x \\<le> b ^ y\n  y \\<noteq> 0 \\<Longrightarrow> b ^ (y - 1) < x\n\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "from b x"], ["proof (chain)\npicking this:\n  1 < b\n  0 < x", "have *: \"1 < real_of_int b\" \"0 < real_of_int (b ^ (y - 1))\" \"0 < real_of_int x\" \n    and **: \"1 < real_of_int b\" \"0 < real_of_int x\" \"0 < real_of_int (b ^ y)\""], ["proof (prove)\nusing this:\n  1 < b\n  0 < x\n\ngoal (1 subgoal):\n 1. (1 < real_of_int b &&&\n     0 < real_of_int (b ^ (y - 1)) &&& 0 < real_of_int x) &&&\n    1 < real_of_int b &&& 0 < real_of_int x &&& 0 < real_of_int (b ^ y)", "by auto"], ["proof (state)\nthis:\n  1 < real_of_int b\n  0 < real_of_int (b ^ (y - 1))\n  0 < real_of_int x\n  1 < real_of_int b\n  0 < real_of_int x\n  0 < real_of_int (b ^ y)\n\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (log_ceiling b x) =\n    \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "unfolding y"], ["proof (prove)\ngoal (1 subgoal):\n 1. int y = \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>", "proof (rule sym, rule ceiling_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n 2. log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)", "show \"log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)", "using main(1)[folded log_le_cancel_iff[OF **, unfolded of_int_le_iff]]"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int x)\n  \\<le> log (real_of_int b) (real_of_int (b ^ y))\n\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)", "using log_pow_cancel[of b y] b"], ["proof (prove)\nusing this:\n  log (real_of_int b) (real_of_int x)\n  \\<le> log (real_of_int b) (real_of_int (b ^ y))\n  \\<lbrakk>0 < real_of_int b; real_of_int b \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> log (real_of_int b) (real_of_int b ^ y) = real y\n  1 < b\n\ngoal (1 subgoal):\n 1. log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)", "by auto"], ["proof (state)\nthis:\n  log (real_of_int b) (real_of_int x) \\<le> real_of_int (int y)\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "from x"], ["proof (chain)\npicking this:\n  0 < x", "have x: \"x \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. 1 \\<le> x", "by auto"], ["proof (state)\nthis:\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "show \"real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n 2. y \\<noteq> 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "using main(2)[folded log_less_cancel_iff[OF *, unfolded of_int_less_iff]]"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  y \\<noteq> 0 \\<Longrightarrow>\n  log (real_of_int b) (real_of_int (b ^ (y - 1)))\n  < log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "using log_pow_cancel[of b \"y - 1\"] b x"], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  y \\<noteq> 0 \\<Longrightarrow>\n  log (real_of_int b) (real_of_int (b ^ (y - 1)))\n  < log (real_of_int b) (real_of_int x)\n  \\<lbrakk>0 < real_of_int b; real_of_int b \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> log (real_of_int b) (real_of_int b ^ (y - 1)) =\n                    real (y - 1)\n  1 < b\n  1 \\<le> x\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "by auto"], ["proof (state)\nthis:\n  real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "case True"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "have \"real_of_int (int y) - 1 = log b (1/b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 = log (real_of_int b) (1 / real_of_int b)", "using True b"], ["proof (prove)\nusing this:\n  y = 0\n  1 < b\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 = log (real_of_int b) (1 / real_of_int b)", "by (subst log_divide, auto)"], ["proof (state)\nthis:\n  real_of_int (int y) - 1 = log (real_of_int b) (1 / real_of_int b)\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "also"], ["proof (state)\nthis:\n  real_of_int (int y) - 1 = log (real_of_int b) (1 / real_of_int b)\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "have \"\\<dots> < log b 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_int b) (1 / real_of_int b) < log (real_of_int b) 1", "by (subst log_less_cancel_iff, insert b, auto)"], ["proof (state)\nthis:\n  log (real_of_int b) (1 / real_of_int b) < log (real_of_int b) 1\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "also"], ["proof (state)\nthis:\n  log (real_of_int b) (1 / real_of_int b) < log (real_of_int b) 1\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "have \"\\<dots> \\<le> log b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log (real_of_int b) 1 \\<le> log (real_of_int b) (real_of_int x)", "by (subst log_le_cancel_iff, insert b x, auto)"], ["proof (state)\nthis:\n  log (real_of_int b) 1 \\<le> log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. y = 0 \\<Longrightarrow>\n    real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "finally"], ["proof (chain)\npicking this:\n  real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "show \"real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\""], ["proof (prove)\nusing this:\n  real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)", "."], ["proof (state)\nthis:\n  real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int (int y) - 1 < log (real_of_int b) (real_of_int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (log_ceiling b x) =\n  \\<lceil>log (real_of_int b) (real_of_int x)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}