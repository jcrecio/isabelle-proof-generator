{"file_name": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian/Sqrt_Babylonian.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian", "problem_names": ["lemma sqrt_int_main'_code[code]: \"sqrt_int_main' x n = (let x2 = x * x in if x2 \\<le> n then (x, x2 = n)\n    else sqrt_int_main' ((n div x + x) div 2) n)\"", "lemma sqrt_int_main_code[code]: \"sqrt_int_main x = sqrt_int_main' (start_value x 2) x\"", "lemma sqrt_int_code[code]: \"sqrt_int x = (if x < 0 then [] else case sqrt_int_main x of (y,True) \\<Rightarrow> if y = 0 then [0] else [y,-y] | _ \\<Rightarrow> [])\"", "lemma sqrt_int[simp]: \"set (sqrt_int x) = {y. y * y = x}\"", "lemma sqrt_int_pos: assumes res: \"sqrt_int x = Cons s ms\"\n  shows \"s \\<ge> 0\"", "lemma sqrt_int_floor_pos_code[code]: \"sqrt_int_floor_pos x = fst (sqrt_int_main x)\"", "lemma sqrt_int_floor_pos: assumes x: \"x \\<ge> 0\" \n  shows \"sqrt_int_floor_pos x = \\<lfloor> sqrt (of_int x) \\<rfloor>\"", "lemma sqrt_int_ceiling_pos_code[code]: \"sqrt_int_ceiling_pos x = (case sqrt_int_main x of (y,b) \\<Rightarrow> if b then y else y + 1)\"", "lemma sqrt_int_ceiling_pos: assumes x: \"x \\<ge> 0\" \n  shows \"sqrt_int_ceiling_pos x = \\<lceil> sqrt (of_int x) \\<rceil>\"", "lemma sqrt_int_floor_code[code]: \"sqrt_int_floor x = (if x \\<ge> 0 then sqrt_int_floor_pos x else - sqrt_int_ceiling_pos (- x))\"", "lemma sqrt_int_floor[simp]: \"sqrt_int_floor x = \\<lfloor> sqrt (of_int x) \\<rfloor>\"", "lemma sqrt_int_ceiling_code[code]: \"sqrt_int_ceiling x = (if x \\<ge> 0 then sqrt_int_ceiling_pos x else - sqrt_int_floor_pos (- x))\"", "lemma sqrt_int_ceiling[simp]: \"sqrt_int_ceiling x = \\<lceil> sqrt (of_int x) \\<rceil>\"", "lemma sqrt_int_ceiling_bound: \"0 \\<le> x \\<Longrightarrow> x \\<le> (sqrt_int_ceiling x)^2\"", "lemma sqrt_nat_code[code]: \"sqrt_nat x \\<equiv> map nat (take 1 (sqrt_int (int x)))\"", "lemma sqrt_nat[simp]: \"set (sqrt_nat x) = { y. y * y = x}\"", "lemma sqrt_nat_floor_code[code]: \"sqrt_nat_floor x = sqrt_int_floor_pos (int x)\"", "lemma sqrt_nat_floor[simp]: \"sqrt_nat_floor x = \\<lfloor> sqrt (real x) \\<rfloor>\"", "lemma sqrt_nat_ceiling_code[code]: \"sqrt_nat_ceiling x = sqrt_int_ceiling_pos (int x)\"", "lemma sqrt_nat_ceiling[simp]: \"sqrt_nat_ceiling x = \\<lceil> sqrt (real x) \\<rceil>\"", "lemma sqrt_rat_code[code]: \"sqrt_rat x = (case quotient_of x of (z,n) \\<Rightarrow> (case sqrt_int n of \n    [] \\<Rightarrow> [] \n  | sn # xs \\<Rightarrow> map (\\<lambda> sz. of_int sz / of_int sn) (sqrt_int z)))\"", "lemma sqrt_rat[simp]: \"set (sqrt_rat x) = { y. y * y = x}\"", "lemma sqrt_rat_pos: assumes sqrt: \"sqrt_rat x = Cons s ms\" \n  shows \"s \\<ge> 0\"", "lemma sqrt_rat_floor_code[code]: \"sqrt_rat_floor x = (case quotient_of x of (a,b) \\<Rightarrow> sqrt_int_floor (a * b) div b)\"", "lemma sqrt_rat_floor[simp]: \"sqrt_rat_floor x = \\<lfloor> sqrt (of_rat x) \\<rfloor>\"", "lemma sqrt_rat_ceiling_code[code]: \"sqrt_rat_ceiling x = - (sqrt_rat_floor (-x))\"", "lemma sqrt_rat_ceiling: \"sqrt_rat_ceiling x = \\<lceil> sqrt (of_rat x) \\<rceil>\"", "lemma sqr_rat_of_int: assumes x: \"x * x = rat_of_int i\"\n  shows \"\\<exists> j :: int. j * j = i\"", "lemma sqrt_approx_main_impl: \"x > 0 \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\"", "lemma sqrt_approx_main_sound: assumes x: \"x > 0\" and xx: \"x * x > n\"\n  shows \"sqrt_approx_main x * sqrt_approx_main x > n \\<and> sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\"", "lemma sqrt_approx: assumes \\<epsilon>: \"\\<epsilon> > 0\"\n  shows \"\\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x - \\<bar>x\\<bar>\\<bar> < \\<epsilon>\"", "lemma \"\\<not> (\\<exists> i :: rat. i * i = 2)\"", "lemma \"\\<not> (\\<exists> i :: int. i * i = 1234567890123456789012345678901234567890)\""], "translations": [["", "lemma sqrt_int_main'_code[code]: \"sqrt_int_main' x n = (let x2 = x * x in if x2 \\<le> n then (x, x2 = n)\n    else sqrt_int_main' ((n div x + x) div 2) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_main' x n =\n    (let x2 = x * x\n     in if x2 \\<le> n then (x, x2 = n)\n        else sqrt_int_main' ((n div x + x) div 2) n)", "using root_int_main'.simps[of 1 1 2 x n]"], ["proof (prove)\nusing this:\n  root_int_main' 1 1 2 x n =\n  (let xpm = x ^ 1; xp = xpm * x\n   in if xp \\<le> n then (x, xp = n)\n      else root_int_main' 1 1 2 ((n div xpm + x * 1) div 2) n)\n\ngoal (1 subgoal):\n 1. sqrt_int_main' x n =\n    (let x2 = x * x\n     in if x2 \\<le> n then (x, x2 = n)\n        else sqrt_int_main' ((n div x + x) div 2) n)", "unfolding Let_def"], ["proof (prove)\nusing this:\n  root_int_main' 1 1 2 x n =\n  (if x ^ 1 * x \\<le> n then (x, x ^ 1 * x = n)\n   else root_int_main' 1 1 2 ((n div x ^ 1 + x * 1) div 2) n)\n\ngoal (1 subgoal):\n 1. sqrt_int_main' x n =\n    (if x * x \\<le> n then (x, x * x = n)\n     else sqrt_int_main' ((n div x + x) div 2) n)", "by auto"], ["", "definition sqrt_int_main :: \"int \\<Rightarrow> int \\<times> bool\" where\n  [simp]: \"sqrt_int_main x = root_int_main 2 x\""], ["", "lemma sqrt_int_main_code[code]: \"sqrt_int_main x = sqrt_int_main' (start_value x 2) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_main x = sqrt_int_main' (start_value x 2) x", "by (simp add: root_int_main_def Let_def)"], ["", "definition sqrt_int :: \"int \\<Rightarrow> int list\" where\n  \"sqrt_int x = root_int 2 x\""], ["", "lemma sqrt_int_code[code]: \"sqrt_int x = (if x < 0 then [] else case sqrt_int_main x of (y,True) \\<Rightarrow> if y = 0 then [0] else [y,-y] | _ \\<Rightarrow> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int x =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt_int x =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "interpret fixed_root 2 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_root 2 1", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt_int x =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "obtain b y where res: \"root_int_main 2 x = (b,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b y.\n        root_int_main 2 x = (b, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  root_int_main 2 x = (b, y)\n\ngoal (1 subgoal):\n 1. sqrt_int x =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int x =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "unfolding sqrt_int_def root_int_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 2 = 0 then []\n     else if x = 0 then [0]\n          else if x < 0 \\<and> even 2 then []\n               else case root_int_main 2 \\<bar>x\\<bar> of\n                    (y, True) \\<Rightarrow>\n                      if even 2 then [y, - y] else [sgn x * y]\n                    | (y, False) \\<Rightarrow> []) =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "using root_int_main[OF _ res]"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow> 0 \\<le> b\n  0 \\<le> x \\<Longrightarrow> y = (b\\<^sup>2 = x)\n  \\<lbrakk>0 \\<le> x; 0 < 2\\<rbrakk> \\<Longrightarrow> b\\<^sup>2 \\<le> x\n  \\<lbrakk>0 \\<le> x; 0 < 2\\<rbrakk> \\<Longrightarrow> x < (b + 1)\\<^sup>2\n  \\<lbrakk>0 \\<le> x; 0 < 2; 0 \\<le> ?x; ?x\\<^sup>2 = x\\<rbrakk>\n  \\<Longrightarrow> b = ?x \\<and> y\n\ngoal (1 subgoal):\n 1. (if 2 = 0 then []\n     else if x = 0 then [0]\n          else if x < 0 \\<and> even 2 then []\n               else case root_int_main 2 \\<bar>x\\<bar> of\n                    (y, True) \\<Rightarrow>\n                      if even 2 then [y, - y] else [sgn x * y]\n                    | (y, False) \\<Rightarrow> []) =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "using res"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow> 0 \\<le> b\n  0 \\<le> x \\<Longrightarrow> y = (b\\<^sup>2 = x)\n  \\<lbrakk>0 \\<le> x; 0 < 2\\<rbrakk> \\<Longrightarrow> b\\<^sup>2 \\<le> x\n  \\<lbrakk>0 \\<le> x; 0 < 2\\<rbrakk> \\<Longrightarrow> x < (b + 1)\\<^sup>2\n  \\<lbrakk>0 \\<le> x; 0 < 2; 0 \\<le> ?x; ?x\\<^sup>2 = x\\<rbrakk>\n  \\<Longrightarrow> b = ?x \\<and> y\n  root_int_main 2 x = (b, y)\n\ngoal (1 subgoal):\n 1. (if 2 = 0 then []\n     else if x = 0 then [0]\n          else if x < 0 \\<and> even 2 then []\n               else case root_int_main 2 \\<bar>x\\<bar> of\n                    (y, True) \\<Rightarrow>\n                      if even 2 then [y, - y] else [sgn x * y]\n                    | (y, False) \\<Rightarrow> []) =\n    (if x < 0 then []\n     else case sqrt_int_main x of\n          (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n          | (y, False) \\<Rightarrow> [])", "by simp"], ["proof (state)\nthis:\n  sqrt_int x =\n  (if x < 0 then []\n   else case sqrt_int_main x of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sqrt_int[simp]: \"set (sqrt_int x) = {y. y * y = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sqrt_int x) = {y. y * y = x}", "unfolding sqrt_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_int 2 x) = {y. y * y = x}", "by (simp add: power2_eq_square)"], ["", "lemma sqrt_int_pos: assumes res: \"sqrt_int x = Cons s ms\"\n  shows \"s \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "note res = res[unfolded sqrt_int_code Let_def, simplified]"], ["proof (state)\nthis:\n  (if x < 0 then []\n   else case sqrt_int_main x of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> []) =\n  s # ms\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from res"], ["proof (chain)\npicking this:\n  (if x < 0 then []\n   else case sqrt_int_main x of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> []) =\n  s # ms", "have x0: \"x \\<ge> 0\""], ["proof (prove)\nusing this:\n  (if x < 0 then []\n   else case sqrt_int_main x of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> []) =\n  s # ms\n\ngoal (1 subgoal):\n 1. 0 \\<le> x", "by (cases ?thesis, auto)"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "obtain ss b where call: \"sqrt_int_main x = (ss,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss b.\n        sqrt_int_main x = (ss, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  sqrt_int_main x = (ss, b)\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from res[unfolded call] x0"], ["proof (chain)\npicking this:\n  (if x < 0 then []\n   else case (ss, b) of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> []) =\n  s # ms\n  0 \\<le> x", "have \"ss = s\""], ["proof (prove)\nusing this:\n  (if x < 0 then []\n   else case (ss, b) of\n        (y, True) \\<Rightarrow> if y = 0 then [0] else [y, - y]\n        | (y, False) \\<Rightarrow> []) =\n  s # ms\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. ss = s", "by (cases b, cases \"ss = 0\", auto)"], ["proof (state)\nthis:\n  ss = s\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from root_int_main(1)[OF x0 call[unfolded this sqrt_int_main_def]]"], ["proof (chain)\npicking this:\n  0 \\<le> s", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> s\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "."], ["proof (state)\nthis:\n  0 \\<le> s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [simp]: \"sqrt_int_floor_pos x = root_int_floor_pos 2 x\""], ["", "lemma sqrt_int_floor_pos_code[code]: \"sqrt_int_floor_pos x = fst (sqrt_int_main x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_floor_pos x = fst (sqrt_int_main x)", "by (simp add: root_int_floor_pos_def)"], ["", "lemma sqrt_int_floor_pos: assumes x: \"x \\<ge> 0\" \n  shows \"sqrt_int_floor_pos x = \\<lfloor> sqrt (of_int x) \\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_floor_pos x = \\<lfloor>sqrt (real_of_int x)\\<rfloor>", "using root_int_floor_pos[OF x, of 2]"], ["proof (prove)\nusing this:\n  root_int_floor_pos 2 x = \\<lfloor>root 2 (real_of_int x)\\<rfloor>\n\ngoal (1 subgoal):\n 1. sqrt_int_floor_pos x = \\<lfloor>sqrt (real_of_int x)\\<rfloor>", "by (simp add: sqrt_def)"], ["", "definition [simp]: \"sqrt_int_ceiling_pos x = root_int_ceiling_pos 2 x\""], ["", "lemma sqrt_int_ceiling_pos_code[code]: \"sqrt_int_ceiling_pos x = (case sqrt_int_main x of (y,b) \\<Rightarrow> if b then y else y + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_ceiling_pos x =\n    (case sqrt_int_main x of (y, b) \\<Rightarrow> if b then y else y + 1)", "by (simp add: root_int_ceiling_pos_def)"], ["", "lemma sqrt_int_ceiling_pos: assumes x: \"x \\<ge> 0\" \n  shows \"sqrt_int_ceiling_pos x = \\<lceil> sqrt (of_int x) \\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_ceiling_pos x = \\<lceil>sqrt (real_of_int x)\\<rceil>", "using root_int_ceiling_pos[OF x, of 2]"], ["proof (prove)\nusing this:\n  root_int_ceiling_pos 2 x = \\<lceil>root 2 (real_of_int x)\\<rceil>\n\ngoal (1 subgoal):\n 1. sqrt_int_ceiling_pos x = \\<lceil>sqrt (real_of_int x)\\<rceil>", "by (simp add: sqrt_def)"], ["", "definition \"sqrt_int_floor x = root_int_floor 2 x\""], ["", "lemma sqrt_int_floor_code[code]: \"sqrt_int_floor x = (if x \\<ge> 0 then sqrt_int_floor_pos x else - sqrt_int_ceiling_pos (- x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_floor x =\n    (if 0 \\<le> x then sqrt_int_floor_pos x\n     else - sqrt_int_ceiling_pos (- x))", "unfolding sqrt_int_floor_def root_int_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_floor_pos 2 x\n     else - root_int_ceiling_pos 2 (- x)) =\n    (if 0 \\<le> x then sqrt_int_floor_pos x\n     else - sqrt_int_ceiling_pos (- x))", "by simp"], ["", "lemma sqrt_int_floor[simp]: \"sqrt_int_floor x = \\<lfloor> sqrt (of_int x) \\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_floor x = \\<lfloor>sqrt (real_of_int x)\\<rfloor>", "by (simp add: sqrt_int_floor_def sqrt_def)"], ["", "definition \"sqrt_int_ceiling x = root_int_ceiling 2 x\""], ["", "lemma sqrt_int_ceiling_code[code]: \"sqrt_int_ceiling x = (if x \\<ge> 0 then sqrt_int_ceiling_pos x else - sqrt_int_floor_pos (- x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_ceiling x =\n    (if 0 \\<le> x then sqrt_int_ceiling_pos x\n     else - sqrt_int_floor_pos (- x))", "unfolding sqrt_int_ceiling_def root_int_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_ceiling_pos 2 x\n     else - root_int_floor_pos 2 (- x)) =\n    (if 0 \\<le> x then sqrt_int_ceiling_pos x\n     else - sqrt_int_floor_pos (- x))", "by simp"], ["", "lemma sqrt_int_ceiling[simp]: \"sqrt_int_ceiling x = \\<lceil> sqrt (of_int x) \\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int_ceiling x = \\<lceil>sqrt (real_of_int x)\\<rceil>", "by (simp add: sqrt_int_ceiling_def sqrt_def)"], ["", "lemma sqrt_int_ceiling_bound: \"0 \\<le> x \\<Longrightarrow> x \\<le> (sqrt_int_ceiling x)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> x \\<le> (sqrt_int_ceiling x)\\<^sup>2", "unfolding sqrt_int_ceiling"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    x \\<le> \\<lceil>sqrt (real_of_int x)\\<rceil>\\<^sup>2", "using le_of_int_ceiling sqrt_le_D"], ["proof (prove)\nusing this:\n  ?x \\<le> of_int \\<lceil>?x\\<rceil>\n  sqrt ?x \\<le> ?y \\<Longrightarrow> ?x \\<le> ?y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    x \\<le> \\<lceil>sqrt (real_of_int x)\\<rceil>\\<^sup>2", "by (metis of_int_power_le_of_int_cancel_iff)"], ["", "subsection \\<open>Square roots for the naturals\\<close>"], ["", "definition sqrt_nat :: \"nat \\<Rightarrow> nat list\"\n  where \"sqrt_nat x = root_nat 2 x\""], ["", "lemma sqrt_nat_code[code]: \"sqrt_nat x \\<equiv> map nat (take 1 (sqrt_int (int x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_nat x \\<equiv> map nat (take 1 (sqrt_int (int x)))", "unfolding sqrt_nat_def root_nat_def sqrt_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map nat (take 1 (root_int 2 (int x))) \\<equiv>\n    map nat (take 1 (root_int 2 (int x)))", "by simp"], ["", "lemma sqrt_nat[simp]: \"set (sqrt_nat x) = { y. y * y = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sqrt_nat x) = {y. y * y = x}", "unfolding sqrt_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_nat 2 x) = {y. y * y = x}", "using root_nat[of 2 x]"], ["proof (prove)\nusing this:\n  2 \\<noteq> 0 \\<or> x \\<noteq> 1 \\<Longrightarrow>\n  set (root_nat 2 x) = {y. y\\<^sup>2 = x}\n\ngoal (1 subgoal):\n 1. set (root_nat 2 x) = {y. y * y = x}", "by (simp add: power2_eq_square)"], ["", "definition sqrt_nat_floor :: \"nat \\<Rightarrow> int\" where\n  \"sqrt_nat_floor x = root_nat_floor 2 x\""], ["", "lemma sqrt_nat_floor_code[code]: \"sqrt_nat_floor x = sqrt_int_floor_pos (int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_nat_floor x = sqrt_int_floor_pos (int x)", "unfolding sqrt_nat_floor_def root_nat_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor_pos 2 (int x) = sqrt_int_floor_pos (int x)", "by simp"], ["", "lemma sqrt_nat_floor[simp]: \"sqrt_nat_floor x = \\<lfloor> sqrt (real x) \\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_nat_floor x = \\<lfloor>sqrt (real x)\\<rfloor>", "unfolding sqrt_nat_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_nat_floor 2 x = \\<lfloor>sqrt (real x)\\<rfloor>", "by (simp add: sqrt_def)"], ["", "definition sqrt_nat_ceiling :: \"nat \\<Rightarrow> int\" where\n  \"sqrt_nat_ceiling x = root_nat_ceiling 2 x\""], ["", "lemma sqrt_nat_ceiling_code[code]: \"sqrt_nat_ceiling x = sqrt_int_ceiling_pos (int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_nat_ceiling x = sqrt_int_ceiling_pos (int x)", "unfolding sqrt_nat_ceiling_def root_nat_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos 2 (int x) = sqrt_int_ceiling_pos (int x)", "by simp"], ["", "lemma sqrt_nat_ceiling[simp]: \"sqrt_nat_ceiling x = \\<lceil> sqrt (real x) \\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_nat_ceiling x = \\<lceil>sqrt (real x)\\<rceil>", "unfolding sqrt_nat_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_nat_ceiling 2 x = \\<lceil>sqrt (real x)\\<rceil>", "by (simp add: sqrt_def)"], ["", "subsection \\<open>Square roots for the rationals\\<close>"], ["", "definition sqrt_rat :: \"rat \\<Rightarrow> rat list\" where\n  \"sqrt_rat x = root_rat 2 x\""], ["", "lemma sqrt_rat_code[code]: \"sqrt_rat x = (case quotient_of x of (z,n) \\<Rightarrow> (case sqrt_int n of \n    [] \\<Rightarrow> [] \n  | sn # xs \\<Rightarrow> map (\\<lambda> sz. of_int sz / of_int sn) (sqrt_int z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat x =\n    (case quotient_of x of\n     (z, n) \\<Rightarrow>\n       case sqrt_int n of [] \\<Rightarrow> []\n       | sn # xs \\<Rightarrow>\n           map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt_rat x =\n    (case quotient_of x of\n     (z, n) \\<Rightarrow>\n       case sqrt_int n of [] \\<Rightarrow> []\n       | sn # xs \\<Rightarrow>\n           map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))", "obtain z n where q: \"quotient_of x = (z,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z n.\n        quotient_of x = (z, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (z, n)\n\ngoal (1 subgoal):\n 1. sqrt_rat x =\n    (case quotient_of x of\n     (z, n) \\<Rightarrow>\n       case sqrt_int n of [] \\<Rightarrow> []\n       | sn # xs \\<Rightarrow>\n           map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat x =\n    (case quotient_of x of\n     (z, n) \\<Rightarrow>\n       case sqrt_int n of [] \\<Rightarrow> []\n       | sn # xs \\<Rightarrow>\n           map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))", "unfolding sqrt_rat_def root_rat_def q split sqrt_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>rb.\n              map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n               (root_int 2 z))\n       (take 1 (root_int 2 n))) =\n    (case root_int 2 n of [] \\<Rightarrow> []\n     | sn # xs \\<Rightarrow>\n         map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (root_int 2 z))", "by (cases \"root_int 2 n\", auto)"], ["proof (state)\nthis:\n  sqrt_rat x =\n  (case quotient_of x of\n   (z, n) \\<Rightarrow>\n     case sqrt_int n of [] \\<Rightarrow> []\n     | sn # xs \\<Rightarrow>\n         map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sqrt_rat[simp]: \"set (sqrt_rat x) = { y. y * y = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sqrt_rat x) = {y. y * y = x}", "unfolding sqrt_rat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_rat 2 x) = {y. y * y = x}", "using root_rat[of 2 x]"], ["proof (prove)\nusing this:\n  2 \\<noteq> 0 \\<or> x \\<noteq> 1 \\<Longrightarrow>\n  set (root_rat 2 x) = {y. y\\<^sup>2 = x}\n\ngoal (1 subgoal):\n 1. set (root_rat 2 x) = {y. y * y = x}", "by (simp add: power2_eq_square)"], ["", "lemma sqrt_rat_pos: assumes sqrt: \"sqrt_rat x = Cons s ms\" \n  shows \"s \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "obtain z n where q: \"quotient_of x = (z,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z n.\n        quotient_of x = (z, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (z, n)\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "note sqrt = sqrt[unfolded sqrt_rat_code q, simplified]"], ["proof (state)\nthis:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "let ?sz = \"sqrt_int z\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "let ?sn = \"sqrt_int n\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from q"], ["proof (chain)\npicking this:\n  quotient_of x = (z, n)", "have n: \"n > 0\""], ["proof (prove)\nusing this:\n  quotient_of x = (z, n)\n\ngoal (1 subgoal):\n 1. 0 < n", "by (rule quotient_of_denom_pos)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from sqrt"], ["proof (chain)\npicking this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms", "obtain sz mz where sz: \"?sz = sz # mz\""], ["proof (prove)\nusing this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms\n\ngoal (1 subgoal):\n 1. (\\<And>sz mz.\n        sqrt_int z = sz # mz \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ?sn, auto)"], ["proof (state)\nthis:\n  sqrt_int z = sz # mz\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from sqrt"], ["proof (chain)\npicking this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms", "obtain sn mn where sn: \"?sn = sn # mn\""], ["proof (prove)\nusing this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms\n\ngoal (1 subgoal):\n 1. (\\<And>sn mn.\n        sqrt_int n = sn # mn \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ?sn, auto)"], ["proof (state)\nthis:\n  sqrt_int n = sn # mn\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from sqrt_int_pos[OF sz] sqrt_int_pos[OF sn]"], ["proof (chain)\npicking this:\n  0 \\<le> sz\n  0 \\<le> sn", "have pos: \"0 \\<le> sz\" \"0 \\<le> sn\""], ["proof (prove)\nusing this:\n  0 \\<le> sz\n  0 \\<le> sn\n\ngoal (1 subgoal):\n 1. 0 \\<le> sz &&& 0 \\<le> sn", "by auto"], ["proof (state)\nthis:\n  0 \\<le> sz\n  0 \\<le> sn\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "from sqrt sz sn"], ["proof (chain)\npicking this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms\n  sqrt_int z = sz # mz\n  sqrt_int n = sn # mn", "have s: \"s = of_int sz / of_int sn\""], ["proof (prove)\nusing this:\n  (case sqrt_int n of [] \\<Rightarrow> []\n   | sn # xs \\<Rightarrow>\n       map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z)) =\n  s # ms\n  sqrt_int z = sz # mz\n  sqrt_int n = sn # mn\n\ngoal (1 subgoal):\n 1. s = rat_of_int sz / rat_of_int sn", "by auto"], ["proof (state)\nthis:\n  s = rat_of_int sz / rat_of_int sn\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rat_of_int sz / rat_of_int sn", "using pos"], ["proof (prove)\nusing this:\n  0 \\<le> sz\n  0 \\<le> sn\n\ngoal (1 subgoal):\n 1. 0 \\<le> rat_of_int sz / rat_of_int sn", "by (metis of_int_0_le_iff zero_le_divide_iff)"], ["proof (state)\nthis:\n  0 \\<le> s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition sqrt_rat_floor :: \"rat \\<Rightarrow> int\" where\n  \"sqrt_rat_floor x = root_rat_floor 2 x\""], ["", "lemma sqrt_rat_floor_code[code]: \"sqrt_rat_floor x = (case quotient_of x of (a,b) \\<Rightarrow> sqrt_int_floor (a * b) div b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat_floor x =\n    (case quotient_of x of\n     (a, b) \\<Rightarrow> sqrt_int_floor (a * b) div b)", "unfolding sqrt_rat_floor_def root_rat_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case quotient_of x of\n     (a, b) \\<Rightarrow> root_int_floor 2 (a * b ^ (2 - 1)) div b) =\n    (case quotient_of x of\n     (a, b) \\<Rightarrow> sqrt_int_floor (a * b) div b)", "by (simp add: sqrt_def)"], ["", "lemma sqrt_rat_floor[simp]: \"sqrt_rat_floor x = \\<lfloor> sqrt (of_rat x) \\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat_floor x = \\<lfloor>sqrt (real_of_rat x)\\<rfloor>", "unfolding sqrt_rat_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_rat_floor 2 x = \\<lfloor>sqrt (real_of_rat x)\\<rfloor>", "by (simp add: sqrt_def)"], ["", "definition sqrt_rat_ceiling :: \"rat \\<Rightarrow> int\" where\n  \"sqrt_rat_ceiling x = root_rat_ceiling 2 x\""], ["", "lemma sqrt_rat_ceiling_code[code]: \"sqrt_rat_ceiling x = - (sqrt_rat_floor (-x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat_ceiling x = - sqrt_rat_floor (- x)", "unfolding sqrt_rat_ceiling_def sqrt_rat_floor_def root_rat_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - root_rat_floor 2 (- x) = - root_rat_floor 2 (- x)", "by simp"], ["", "lemma sqrt_rat_ceiling: \"sqrt_rat_ceiling x = \\<lceil> sqrt (of_rat x) \\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_rat_ceiling x = \\<lceil>sqrt (real_of_rat x)\\<rceil>", "unfolding sqrt_rat_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_rat_ceiling 2 x = \\<lceil>sqrt (real_of_rat x)\\<rceil>", "by (simp add: sqrt_def)"], ["", "lemma sqr_rat_of_int: assumes x: \"x * x = rat_of_int i\"\n  shows \"\\<exists> j :: int. j * j = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "from x"], ["proof (chain)\npicking this:\n  x * x = rat_of_int i", "have mem: \"x \\<in> set (sqrt_rat (rat_of_int i))\""], ["proof (prove)\nusing this:\n  x * x = rat_of_int i\n\ngoal (1 subgoal):\n 1. x \\<in> set (sqrt_rat (rat_of_int i))", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (sqrt_rat (rat_of_int i))\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "from x"], ["proof (chain)\npicking this:\n  x * x = rat_of_int i", "have \"rat_of_int i \\<ge> 0\""], ["proof (prove)\nusing this:\n  x * x = rat_of_int i\n\ngoal (1 subgoal):\n 1. 0 \\<le> rat_of_int i", "by (metis zero_le_square)"], ["proof (state)\nthis:\n  0 \\<le> rat_of_int i\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "hence *: \"quotient_of (rat_of_int i) = (i,1)\""], ["proof (prove)\nusing this:\n  0 \\<le> rat_of_int i\n\ngoal (1 subgoal):\n 1. quotient_of (rat_of_int i) = (i, 1)", "by (metis quotient_of_int)"], ["proof (state)\nthis:\n  quotient_of (rat_of_int i) = (i, 1)\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "have 1: \"sqrt_int 1 = [1,-1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_int 1 = [1, - 1]", "by code_simp"], ["proof (state)\nthis:\n  sqrt_int 1 = [1, - 1]\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "from mem sqrt_rat_code * split 1"], ["proof (chain)\npicking this:\n  x \\<in> set (sqrt_rat (rat_of_int i))\n  sqrt_rat ?x =\n  (case quotient_of ?x of\n   (z, n) \\<Rightarrow>\n     case sqrt_int n of [] \\<Rightarrow> []\n     | sn # xs \\<Rightarrow>\n         map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))\n  quotient_of (rat_of_int i) = (i, 1)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  sqrt_int 1 = [1, - 1]", "have x: \"x \\<in> rat_of_int ` {y. y * y = i}\""], ["proof (prove)\nusing this:\n  x \\<in> set (sqrt_rat (rat_of_int i))\n  sqrt_rat ?x =\n  (case quotient_of ?x of\n   (z, n) \\<Rightarrow>\n     case sqrt_int n of [] \\<Rightarrow> []\n     | sn # xs \\<Rightarrow>\n         map (\\<lambda>sz. rat_of_int sz / rat_of_int sn) (sqrt_int z))\n  quotient_of (rat_of_int i) = (i, 1)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  sqrt_int 1 = [1, - 1]\n\ngoal (1 subgoal):\n 1. x \\<in> rat_of_int ` {y. y * y = i}", "by auto"], ["proof (state)\nthis:\n  x \\<in> rat_of_int ` {y. y * y = i}\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> rat_of_int ` {y. y * y = i}\n\ngoal (1 subgoal):\n 1. \\<exists>j. j * j = i", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. j * j = i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Approximating square roots\\<close>"], ["", "text \\<open>\n  The difference to the previous algorithms is that now we abort, once the distance is below\n  $\\epsilon$.  \n  Moreover, here we use standard division and not integer division.\n  This part is not yet generalized by @{theory Sqrt_Babylonian.NthRoot_Impl}.\n\n  We first provide the executable version without guard @{term \"x > 0\"} as partial function,\n  and afterwards prove termination and soundness for a similar algorithm that is defined within the upcoming\nlocale.\n\\<close>"], ["", "partial_function (tailrec) sqrt_approx_main_impl :: \"'a :: linordered_field \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" where \n  [code]: \"sqrt_approx_main_impl \\<epsilon> n x = (if x * x - n < \\<epsilon> then x else sqrt_approx_main_impl \\<epsilon> n \n    ((n / x + x) / 2))\""], ["", "text \\<open>We setup a locale where we ensure that we have standard assumptions: positive $\\epsilon$ and\n  positive $n$. We require sort @{term floor_ceiling}, since @{term \"\\<lfloor> x \\<rfloor>\"} is used for the termination\n  argument.\\<close>"], ["", "locale sqrt_approximation = \n  fixes \\<epsilon> :: \"'a :: {linordered_field,floor_ceiling}\"\n  and n :: 'a\n  assumes \\<epsilon> : \"\\<epsilon> > 0\"\n  and n: \"n > 0\"\nbegin"], ["", "function sqrt_approx_main :: \"'a \\<Rightarrow> 'a\" where \n  \"sqrt_approx_main x = (if x > 0 then (if x * x - n < \\<epsilon> then x else sqrt_approx_main \n    ((n / x + x) / 2)) else 0)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xa. x = xa \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x xa.\n       x = xa \\<Longrightarrow>\n       (if (0::'a) < x\n        then if x * x - n < \\<epsilon> then x\n             else sqrt_approx_main_sumC ((n / x + x) / (2::'a))\n        else (0::'a)) =\n       (if (0::'a) < xa\n        then if xa * xa - n < \\<epsilon> then xa\n             else sqrt_approx_main_sumC ((n / xa + xa) / (2::'a))\n        else (0::'a))", "by pat_completeness auto"], ["", "text \\<open>Termination essentially is a proof of convergence. Here, one complication is the fact\n  that the limit is not always defined. E.g., if @{typ \"'a\"} is @{typ rat} then there is no\n  square root of 2. Therefore, the error-rate $\\frac x{\\sqrt n} - 1$ is not expressible. \n  Instead we use the expression $\\frac{x^2}n - 1$ as error-rate which\n  does not require any square-root operation.\\<close>"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "define er where \"er x = (x * x / n - 1)\" for x"], ["proof (state)\nthis:\n  er ?x = ?x * ?x / n - (1::'a)\n\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "define c where \"c = 2 * n / \\<epsilon>\""], ["proof (state)\nthis:\n  c = (2::'a) * n / \\<epsilon>\n\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "define m where \"m x = nat \\<lfloor> c * er x \\<rfloor>\" for x"], ["proof (state)\nthis:\n  m ?x = nat \\<lfloor>c * er ?x\\<rfloor>\n\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "have c: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < (2::'a) * n / \\<epsilon>", "using n \\<epsilon>"], ["proof (prove)\nusing this:\n  (0::'a) < n\n  (0::'a) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (0::'a) < (2::'a) * n / \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  (0::'a) < c\n\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sqrt_approx_main_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> ?R", "show \"wf (measures [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [m])", "by simp"], ["proof (state)\nthis:\n  wf (measures [m])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> measures [m]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> measures [m]", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> measures [m]", "assume x: \"0 < x\" and xe: \"\\<not> x * x - n < \\<epsilon>\""], ["proof (state)\nthis:\n  (0::'a) < x\n  \\<not> x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> measures [m]", "define y where \"y = (n / x + x) / 2\""], ["proof (state)\nthis:\n  y = (n / x + x) / (2::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> ((n / x + x) / (2::'a), x) \\<in> measures [m]", "show \"((n / x + x) / 2,x) \\<in> measures [m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n / x + x) / (2::'a), x) \\<in> measures [m]", "unfolding y_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> measures [m]", "proof (rule measures_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. m y < m x", "from n"], ["proof (chain)\npicking this:\n  (0::'a) < n", "have inv_n: \"1 / n > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. (0::'a) < (1::'a) / n", "by auto"], ["proof (state)\nthis:\n  (0::'a) < (1::'a) / n\n\ngoal (1 subgoal):\n 1. m y < m x", "from xe"], ["proof (chain)\npicking this:\n  \\<not> x * x - n < \\<epsilon>", "have \"x * x - n \\<ge> \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<not> x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<epsilon> \\<le> x * x - n", "by simp"], ["proof (state)\nthis:\n  \\<epsilon> \\<le> x * x - n\n\ngoal (1 subgoal):\n 1. m y < m x", "from this[unfolded mult_le_cancel_left_pos[OF inv_n, of \\<epsilon>, symmetric]]"], ["proof (chain)\npicking this:\n  (1::'a) / n * \\<epsilon> \\<le> (1::'a) / n * (x * x - n)", "have erxen: \"er x \\<ge> \\<epsilon> / n\""], ["proof (prove)\nusing this:\n  (1::'a) / n * \\<epsilon> \\<le> (1::'a) / n * (x * x - n)\n\ngoal (1 subgoal):\n 1. \\<epsilon> / n \\<le> er x", "unfolding er_def"], ["proof (prove)\nusing this:\n  (1::'a) / n * \\<epsilon> \\<le> (1::'a) / n * (x * x - n)\n\ngoal (1 subgoal):\n 1. \\<epsilon> / n \\<le> x * x / n - (1::'a)", "using n"], ["proof (prove)\nusing this:\n  (1::'a) / n * \\<epsilon> \\<le> (1::'a) / n * (x * x - n)\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. \\<epsilon> / n \\<le> x * x / n - (1::'a)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<epsilon> / n \\<le> er x\n\ngoal (1 subgoal):\n 1. m y < m x", "have en: \"\\<epsilon> / n > 0\" and ne: \"n / \\<epsilon> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < \\<epsilon> / n &&& (0::'a) < n / \\<epsilon>", "using \\<epsilon> n"], ["proof (prove)\nusing this:\n  (0::'a) < \\<epsilon>\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<epsilon> / n &&& (0::'a) < n / \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  (0::'a) < \\<epsilon> / n\n  (0::'a) < n / \\<epsilon>\n\ngoal (1 subgoal):\n 1. m y < m x", "from en erxen"], ["proof (chain)\npicking this:\n  (0::'a) < \\<epsilon> / n\n  \\<epsilon> / n \\<le> er x", "have erx: \"er x > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < \\<epsilon> / n\n  \\<epsilon> / n \\<le> er x\n\ngoal (1 subgoal):\n 1. (0::'a) < er x", "by linarith"], ["proof (state)\nthis:\n  (0::'a) < er x\n\ngoal (1 subgoal):\n 1. m y < m x", "have pos: \"er x * 4 + er x * (er x * 4) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < er x * (4::'a) + er x * (er x * (4::'a))", "using erx"], ["proof (prove)\nusing this:\n  (0::'a) < er x\n\ngoal (1 subgoal):\n 1. (0::'a) < er x * (4::'a) + er x * (er x * (4::'a))", "by (auto intro: add_pos_nonneg)"], ["proof (state)\nthis:\n  (0::'a) < er x * (4::'a) + er x * (er x * (4::'a))\n\ngoal (1 subgoal):\n 1. m y < m x", "have \"er y = 1 / 4 * (n / (x * x) - 2  + x * x / n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. er y = (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n)", "unfolding er_def y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n / x + x) / (2::'a) * ((n / x + x) / (2::'a)) / n - (1::'a) =\n    (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n)", "using x n"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. (n / x + x) / (2::'a) * ((n / x + x) / (2::'a)) / n - (1::'a) =\n    (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  er y = (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n)\n\ngoal (1 subgoal):\n 1. m y < m x", "also"], ["proof (state)\nthis:\n  er y = (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n)\n\ngoal (1 subgoal):\n 1. m y < m x", "have \"\\<dots> = 1 / 4 * er x * er x / (1 + er x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n) =\n    (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)", "unfolding er_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n) =\n    (1::'a) / (4::'a) * (x * x / n - (1::'a)) * (x * x / n - (1::'a)) /\n    ((1::'a) + (x * x / n - (1::'a)))", "using x n"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n) =\n    (1::'a) / (4::'a) * (x * x / n - (1::'a)) * (x * x / n - (1::'a)) /\n    ((1::'a) + (x * x / n - (1::'a)))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (1::'a) / (4::'a) * (n / (x * x) - (2::'a) + x * x / n) =\n  (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. m y < m x", "finally"], ["proof (chain)\npicking this:\n  er y = (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)", "have \"er y = 1 / 4 * er x * er x / (1 + er x)\""], ["proof (prove)\nusing this:\n  er y = (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. er y = (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)", "."], ["proof (state)\nthis:\n  er y = (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. m y < m x", "also"], ["proof (state)\nthis:\n  er y = (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. m y < m x", "have \"\\<dots> < 1 / 4 * (1 + er x) * er x / (1 + er x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n    < (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x)", "using erx erx pos"], ["proof (prove)\nusing this:\n  (0::'a) < er x\n  (0::'a) < er x\n  (0::'a) < er x * (4::'a) + er x * (er x * (4::'a))\n\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n    < (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n  < (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. m y < m x", "also"], ["proof (state)\nthis:\n  (1::'a) / (4::'a) * er x * er x / ((1::'a) + er x)\n  < (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x)\n\ngoal (1 subgoal):\n 1. m y < m x", "have \"\\<dots> = er x / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x) =\n    er x / (4::'a)", "using erx"], ["proof (prove)\nusing this:\n  (0::'a) < er x\n\ngoal (1 subgoal):\n 1. (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x) =\n    er x / (4::'a)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (1::'a) / (4::'a) * ((1::'a) + er x) * er x / ((1::'a) + er x) =\n  er x / (4::'a)\n\ngoal (1 subgoal):\n 1. m y < m x", "finally"], ["proof (chain)\npicking this:\n  er y < er x / (4::'a)", "have er_y_x: \"er y \\<le> er x / 4\""], ["proof (prove)\nusing this:\n  er y < er x / (4::'a)\n\ngoal (1 subgoal):\n 1. er y \\<le> er x / (4::'a)", "by linarith"], ["proof (state)\nthis:\n  er y \\<le> er x / (4::'a)\n\ngoal (1 subgoal):\n 1. m y < m x", "from erxen"], ["proof (chain)\npicking this:\n  \\<epsilon> / n \\<le> er x", "have \"c * er x \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<epsilon> / n \\<le> er x\n\ngoal (1 subgoal):\n 1. (2::'a) \\<le> c * er x", "unfolding c_def mult_le_cancel_left_pos[OF ne, of _ \"er x\", symmetric]"], ["proof (prove)\nusing this:\n  n / \\<epsilon> * (\\<epsilon> / n) \\<le> n / \\<epsilon> * er x\n\ngoal (1 subgoal):\n 1. (2::'a) \\<le> (2::'a) * n / \\<epsilon> * er x", "using n \\<epsilon>"], ["proof (prove)\nusing this:\n  n / \\<epsilon> * (\\<epsilon> / n) \\<le> n / \\<epsilon> * er x\n  (0::'a) < n\n  (0::'a) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (2::'a) \\<le> (2::'a) * n / \\<epsilon> * er x", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (2::'a) \\<le> c * er x\n\ngoal (1 subgoal):\n 1. m y < m x", "hence pos: \"\\<lfloor>c * er x\\<rfloor> > 0\" \"\\<lfloor>c * er x\\<rfloor> \\<ge> 2\""], ["proof (prove)\nusing this:\n  (2::'a) \\<le> c * er x\n\ngoal (1 subgoal):\n 1. 0 < \\<lfloor>c * er x\\<rfloor> &&& 2 \\<le> \\<lfloor>c * er x\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  0 < \\<lfloor>c * er x\\<rfloor>\n  2 \\<le> \\<lfloor>c * er x\\<rfloor>\n\ngoal (1 subgoal):\n 1. m y < m x", "show \"m y < m x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m y < m x", "unfolding m_def nat_mono_iff[OF pos(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "have \"\\<lfloor>c * er y\\<rfloor> \\<le> \\<lfloor>c * (er x / 4)\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> \\<le> \\<lfloor>c * (er x / (4::'a))\\<rfloor>", "by (rule floor_mono, unfold mult_le_cancel_left_pos[OF c], rule er_y_x)"], ["proof (state)\nthis:\n  \\<lfloor>c * er y\\<rfloor> \\<le> \\<lfloor>c * (er x / (4::'a))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>c * er y\\<rfloor> \\<le> \\<lfloor>c * (er x / (4::'a))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "have \"\\<dots> < \\<lfloor>c * er x / 4 + 1\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>c * (er x / (4::'a))\\<rfloor>\n    < \\<lfloor>c * er x / (4::'a) + (1::'a)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>c * (er x / (4::'a))\\<rfloor>\n  < \\<lfloor>c * er x / (4::'a) + (1::'a)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>c * (er x / (4::'a))\\<rfloor>\n  < \\<lfloor>c * er x / (4::'a) + (1::'a)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "have \"\\<dots> \\<le> \\<lfloor>c * er x\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>c * er x / (4::'a) + (1::'a)\\<rfloor>\n    \\<le> \\<lfloor>c * er x\\<rfloor>", "by (rule floor_mono, insert pos(2), simp add: field_simps)"], ["proof (state)\nthis:\n  \\<lfloor>c * er x / (4::'a) + (1::'a)\\<rfloor>\n  \\<le> \\<lfloor>c * er x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "show \"\\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>", "."], ["proof (state)\nthis:\n  \\<lfloor>c * er y\\<rfloor> < \\<lfloor>c * er x\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m y < m x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((n / x + x) / (2::'a), x) \\<in> measures [m]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  All sqrt_approx_main_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Once termination is proven, it is easy to show equivalence of \n  @{const sqrt_approx_main_impl} and @{const sqrt_approx_main}.\\<close>"], ["", "lemma sqrt_approx_main_impl: \"x > 0 \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < x \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "proof (induct x rule: sqrt_approx_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n                \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                                   ((n / x + x) / (2::'a)) =\n                                  sqrt_approx_main ((n / x + x) / (2::'a));\n        (0::'a) < x\\<rbrakk>\n       \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x =\n                         sqrt_approx_main x", "case (1 x)"], ["proof (state)\nthis:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n  \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                     ((n / x + x) / (2::'a)) =\n                    sqrt_approx_main ((n / x + x) / (2::'a))\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n                \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                                   ((n / x + x) / (2::'a)) =\n                                  sqrt_approx_main ((n / x + x) / (2::'a));\n        (0::'a) < x\\<rbrakk>\n       \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x =\n                         sqrt_approx_main x", "hence x: \"x > 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n  \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                     ((n / x + x) / (2::'a)) =\n                    sqrt_approx_main ((n / x + x) / (2::'a))\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (0::'a) < x", "by auto"], ["proof (state)\nthis:\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n                \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                                   ((n / x + x) / (2::'a)) =\n                                  sqrt_approx_main ((n / x + x) / (2::'a));\n        (0::'a) < x\\<rbrakk>\n       \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x =\n                         sqrt_approx_main x", "hence nx: \"0 < (n / x + x) / 2\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (0::'a) < (n / x + x) / (2::'a)", "using n"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  (0::'a) < n\n\ngoal (1 subgoal):\n 1. (0::'a) < (n / x + x) / (2::'a)", "by (auto intro: pos_add_strict)"], ["proof (state)\nthis:\n  (0::'a) < (n / x + x) / (2::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n                \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                                   ((n / x + x) / (2::'a)) =\n                                  sqrt_approx_main ((n / x + x) / (2::'a));\n        (0::'a) < x\\<rbrakk>\n       \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x =\n                         sqrt_approx_main x", "note simps = sqrt_approx_main_impl.simps[of _ _ x] sqrt_approx_main.simps[of x]"], ["proof (state)\nthis:\n  sqrt_approx_main_impl ?\\<epsilon> ?n x =\n  (if x * x - ?n < ?\\<epsilon> then x\n   else sqrt_approx_main_impl ?\\<epsilon> ?n ((?n / x + x) / (2::'a)))\n  sqrt_approx_main x =\n  (if (0::'a) < x\n   then if x * x - n < \\<epsilon> then x\n        else sqrt_approx_main ((n / x + x) / (2::'a))\n   else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a)\\<rbrakk>\n                \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n\n                                   ((n / x + x) / (2::'a)) =\n                                  sqrt_approx_main ((n / x + x) / (2::'a));\n        (0::'a) < x\\<rbrakk>\n       \\<Longrightarrow> sqrt_approx_main_impl \\<epsilon> n x =\n                         sqrt_approx_main x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "proof (cases \"x * x - n < \\<epsilon>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\n 2. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "case True"], ["proof (state)\nthis:\n  x * x - n < \\<epsilon>\n\ngoal (2 subgoals):\n 1. x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\n 2. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "unfolding simps"], ["proof (prove)\nusing this:\n  x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a))) =\n    (if (0::'a) < x\n     then if x * x - n < \\<epsilon> then x\n          else sqrt_approx_main ((n / x + x) / (2::'a))\n     else (0::'a))", "using x"], ["proof (prove)\nusing this:\n  x * x - n < \\<epsilon>\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a))) =\n    (if (0::'a) < x\n     then if x * x - n < \\<epsilon> then x\n          else sqrt_approx_main ((n / x + x) / (2::'a))\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "case False"], ["proof (state)\nthis:\n  \\<not> x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "using 1(1)[OF x False nx]"], ["proof (prove)\nusing this:\n  sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a)) =\n  sqrt_approx_main ((n / x + x) / (2::'a))\n\ngoal (1 subgoal):\n 1. sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x", "unfolding simps"], ["proof (prove)\nusing this:\n  sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a)) =\n  sqrt_approx_main ((n / x + x) / (2::'a))\n\ngoal (1 subgoal):\n 1. (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a))) =\n    (if (0::'a) < x\n     then if x * x - n < \\<epsilon> then x\n          else sqrt_approx_main ((n / x + x) / (2::'a))\n     else (0::'a))", "using x False"], ["proof (prove)\nusing this:\n  sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a)) =\n  sqrt_approx_main ((n / x + x) / (2::'a))\n  (0::'a) < x\n  \\<not> x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main_impl \\<epsilon> n ((n / x + x) / (2::'a))) =\n    (if (0::'a) < x\n     then if x * x - n < \\<epsilon> then x\n          else sqrt_approx_main ((n / x + x) / (2::'a))\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt_approx_main_impl \\<epsilon> n x = sqrt_approx_main x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Also soundness is not complicated.\\<close>"], ["", "lemma sqrt_approx_main_sound: assumes x: \"x > 0\" and xx: \"x * x > n\"\n  shows \"sqrt_approx_main x * sqrt_approx_main x > n \\<and> sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "using assms"], ["proof (prove)\nusing this:\n  (0::'a) < x\n  n < x * x\n\ngoal (1 subgoal):\n 1. n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "proof (induct x rule: sqrt_approx_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a);\n                 n < (n / x + x) / (2::'a) *\n                     ((n / x + x) / (2::'a))\\<rbrakk>\n                \\<Longrightarrow> n < sqrt_approx_main\n ((n / x + x) / (2::'a)) *\nsqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) *\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) -\n                                  n\n                                  < \\<epsilon>;\n        (0::'a) < x; n < x * x\\<rbrakk>\n       \\<Longrightarrow> n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n                         sqrt_approx_main x * sqrt_approx_main x - n\n                         < \\<epsilon>", "case (1 x)"], ["proof (state)\nthis:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a);\n                 n < (n / x + x) / (2::'a) *\n                     ((n / x + x) / (2::'a))\\<rbrakk>\n                \\<Longrightarrow> n < sqrt_approx_main\n ((n / x + x) / (2::'a)) *\nsqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) *\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) -\n                                  n\n                                  < \\<epsilon>;\n        (0::'a) < x; n < x * x\\<rbrakk>\n       \\<Longrightarrow> n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n                         sqrt_approx_main x * sqrt_approx_main x - n\n                         < \\<epsilon>", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x", "have x:  \"x > 0\" \"(x > 0) = True\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x\n\ngoal (1 subgoal):\n 1. (0::'a) < x &&& ((0::'a) < x) = True", "by auto"], ["proof (state)\nthis:\n  (0::'a) < x\n  ((0::'a) < x) = True\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a);\n                 n < (n / x + x) / (2::'a) *\n                     ((n / x + x) / (2::'a))\\<rbrakk>\n                \\<Longrightarrow> n < sqrt_approx_main\n ((n / x + x) / (2::'a)) *\nsqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) *\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) -\n                                  n\n                                  < \\<epsilon>;\n        (0::'a) < x; n < x * x\\<rbrakk>\n       \\<Longrightarrow> n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n                         sqrt_approx_main x * sqrt_approx_main x - n\n                         < \\<epsilon>", "note simp = sqrt_approx_main.simps[of x, unfolded x if_True]"], ["proof (state)\nthis:\n  sqrt_approx_main x =\n  (if x * x - n < \\<epsilon> then x\n   else sqrt_approx_main ((n / x + x) / (2::'a)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n                 (0::'a) < (n / x + x) / (2::'a);\n                 n < (n / x + x) / (2::'a) *\n                     ((n / x + x) / (2::'a))\\<rbrakk>\n                \\<Longrightarrow> n < sqrt_approx_main\n ((n / x + x) / (2::'a)) *\nsqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) *\n                                  sqrt_approx_main ((n / x + x) / (2::'a)) -\n                                  n\n                                  < \\<epsilon>;\n        (0::'a) < x; n < x * x\\<rbrakk>\n       \\<Longrightarrow> n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n                         sqrt_approx_main x * sqrt_approx_main x - n\n                         < \\<epsilon>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "proof (cases \"x * x - n < \\<epsilon>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\n 2. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "case True"], ["proof (state)\nthis:\n  x * x - n < \\<epsilon>\n\ngoal (2 subgoals):\n 1. x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\n 2. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x\n  x * x - n < \\<epsilon>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x\n  x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "unfolding simp"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) < x; \\<not> x * x - n < \\<epsilon>;\n   (0::'a) < (n / x + x) / (2::'a);\n   n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\\<rbrakk>\n  \\<Longrightarrow> n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n                        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n                    sqrt_approx_main ((n / x + x) / (2::'a)) *\n                    sqrt_approx_main ((n / x + x) / (2::'a)) -\n                    n\n                    < \\<epsilon>\n  (0::'a) < x\n  n < x * x\n  x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. n < (if x * x - n < \\<epsilon> then x\n         else sqrt_approx_main ((n / x + x) / (2::'a))) *\n        (if x * x - n < \\<epsilon> then x\n         else sqrt_approx_main ((n / x + x) / (2::'a))) \\<and>\n    (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main ((n / x + x) / (2::'a))) *\n    (if x * x - n < \\<epsilon> then x\n     else sqrt_approx_main ((n / x + x) / (2::'a))) -\n    n\n    < \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n  sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "case False"], ["proof (state)\nthis:\n  \\<not> x * x - n < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "let ?y = \"(n / x + x) / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "from False simp"], ["proof (chain)\npicking this:\n  \\<not> x * x - n < \\<epsilon>\n  sqrt_approx_main x =\n  (if x * x - n < \\<epsilon> then x\n   else sqrt_approx_main ((n / x + x) / (2::'a)))", "have simp: \"sqrt_approx_main x = sqrt_approx_main ?y\""], ["proof (prove)\nusing this:\n  \\<not> x * x - n < \\<epsilon>\n  sqrt_approx_main x =\n  (if x * x - n < \\<epsilon> then x\n   else sqrt_approx_main ((n / x + x) / (2::'a)))\n\ngoal (1 subgoal):\n 1. sqrt_approx_main x = sqrt_approx_main ((n / x + x) / (2::'a))", "by simp"], ["proof (state)\nthis:\n  sqrt_approx_main x = sqrt_approx_main ((n / x + x) / (2::'a))\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "from n x"], ["proof (chain)\npicking this:\n  (0::'a) < n\n  (0::'a) < x\n  ((0::'a) < x) = True", "have y: \"?y > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < n\n  (0::'a) < x\n  ((0::'a) < x) = True\n\ngoal (1 subgoal):\n 1. (0::'a) < (n / x + x) / (2::'a)", "by (auto intro: pos_add_strict)"], ["proof (state)\nthis:\n  (0::'a) < (n / x + x) / (2::'a)\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "note IH = 1(1)[OF x(1) False y]"], ["proof (state)\nthis:\n  n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a)) \\<Longrightarrow>\n  n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n      sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n  sqrt_approx_main ((n / x + x) / (2::'a)) *\n  sqrt_approx_main ((n / x + x) / (2::'a)) -\n  n\n  < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "from x"], ["proof (chain)\npicking this:\n  (0::'a) < x\n  ((0::'a) < x) = True", "have x4: \"4 * x * x > 0\""], ["proof (prove)\nusing this:\n  (0::'a) < x\n  ((0::'a) < x) = True\n\ngoal (1 subgoal):\n 1. (0::'a) < (4::'a) * x * x", "by (auto intro: mult_sign_intros)"], ["proof (state)\nthis:\n  (0::'a) < (4::'a) * x * x\n\ngoal (1 subgoal):\n 1. \\<not> x * x - n < \\<epsilon> \\<Longrightarrow>\n    n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n    sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>", "unfolding simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < sqrt_approx_main ((n / x + x) / (2::'a)) *\n        sqrt_approx_main ((n / x + x) / (2::'a)) \\<and>\n    sqrt_approx_main ((n / x + x) / (2::'a)) *\n    sqrt_approx_main ((n / x + x) / (2::'a)) -\n    n\n    < \\<epsilon>", "proof (rule IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))", "show \"n < ?y * ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))", "unfolding mult_less_cancel_left_pos[OF x4, of n, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n\n    < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n\n    < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))", "have id: \"4 * x * x * (?y * ?y) = 4 * x * x * n + (n - x * x) * (n - x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a))) =\n    (4::'a) * x * x * n + (n - x * x) * (n - x * x)", "using x(1)"], ["proof (prove)\nusing this:\n  (0::'a) < x\n\ngoal (1 subgoal):\n 1. (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a))) =\n    (4::'a) * x * x * n + (n - x * x) * (n - x * x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a))) =\n  (4::'a) * x * x * n + (n - x * x) * (n - x * x)\n\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n\n    < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))", "from 1(3)"], ["proof (chain)\npicking this:\n  n < x * x", "have \"x * x - n > 0\""], ["proof (prove)\nusing this:\n  n < x * x\n\ngoal (1 subgoal):\n 1. (0::'a) < x * x - n", "by auto"], ["proof (state)\nthis:\n  (0::'a) < x * x - n\n\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n\n    < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))", "from mult_pos_pos[OF this this]"], ["proof (chain)\npicking this:\n  (0::'a) < (x * x - n) * (x * x - n)", "show \"4 * x * x * n < 4 * x * x * (?y * ?y)\""], ["proof (prove)\nusing this:\n  (0::'a) < (x * x - n) * (x * x - n)\n\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n\n    < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))", "unfolding id"], ["proof (prove)\nusing this:\n  (0::'a) < (x * x - n) * (x * x - n)\n\ngoal (1 subgoal):\n 1. (4::'a) * x * x * n < (4::'a) * x * x * n + (n - x * x) * (n - x * x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (4::'a) * x * x * n\n  < (4::'a) * x * x * ((n / x + x) / (2::'a) * ((n / x + x) / (2::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < (n / x + x) / (2::'a) * ((n / x + x) / (2::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n  sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < sqrt_approx_main x * sqrt_approx_main x \\<and>\n  sqrt_approx_main x * sqrt_approx_main x - n < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>It remains to assemble everything into one algorithm.\\<close>"], ["", "definition sqrt_approx :: \"'a :: {linordered_field,floor_ceiling} \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"sqrt_approx \\<epsilon> x \\<equiv> if \\<epsilon> > 0 then (if x = 0 then 0 else let xpos = abs x in sqrt_approx_main_impl \\<epsilon> xpos (xpos + 1)) else 0\""], ["", "lemma sqrt_approx: assumes \\<epsilon>: \"\\<epsilon> > 0\"\n  shows \"\\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x - \\<bar>x\\<bar>\\<bar> < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "case True"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "with \\<epsilon>"], ["proof (chain)\npicking this:\n  (0::'a) < \\<epsilon>\n  x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < \\<epsilon>\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "unfolding sqrt_approx_def"], ["proof (prove)\nusing this:\n  (0::'a) < \\<epsilon>\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<bar>(if (0::'a) < \\<epsilon>\n           then if x = (0::'a) then 0::'a\n                else let xpos = \\<bar>x\\<bar>\n                     in sqrt_approx_main_impl \\<epsilon> xpos\n                         (xpos + (1::'a))\n           else (0::'a)) *\n          (if (0::'a) < \\<epsilon>\n           then if x = (0::'a) then 0::'a\n                else let xpos = \\<bar>x\\<bar>\n                     in sqrt_approx_main_impl \\<epsilon> xpos\n                         (xpos + (1::'a))\n           else (0::'a)) -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n        \\<bar>x\\<bar>\\<bar>\n  < \\<epsilon>\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "case False"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "let ?x = \"\\<bar>x\\<bar>\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "let ?sqrti = \"sqrt_approx_main_impl \\<epsilon> ?x (?x + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "let ?sqrt = \"sqrt_approximation.sqrt_approx_main \\<epsilon> ?x (?x + 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "define sqrt where \"sqrt = ?sqrt\""], ["proof (state)\nthis:\n  sqrt =\n  sqrt_approximation.sqrt_approx_main \\<epsilon> \\<bar>x\\<bar>\n   (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "from False"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)", "have x: \"?x > 0\" \"?x + 1 > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < \\<bar>x\\<bar> &&& (0::'a) < \\<bar>x\\<bar> + (1::'a)", "by auto"], ["proof (state)\nthis:\n  (0::'a) < \\<bar>x\\<bar>\n  (0::'a) < \\<bar>x\\<bar> + (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "interpret sqrt_approximation \\<epsilon> ?x"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_approximation \\<epsilon> \\<bar>x\\<bar>", "by (unfold_locales, insert x \\<epsilon>, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "from False \\<epsilon>"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)\n  (0::'a) < \\<epsilon>", "have \"sqrt_approx \\<epsilon> x = ?sqrti\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  (0::'a) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. sqrt_approx \\<epsilon> x =\n    sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar> (\\<bar>x\\<bar> + (1::'a))", "unfolding sqrt_approx_def"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  (0::'a) < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (if (0::'a) < \\<epsilon>\n     then if x = (0::'a) then 0::'a\n          else let xpos = \\<bar>x\\<bar>\n               in sqrt_approx_main_impl \\<epsilon> xpos (xpos + (1::'a))\n     else (0::'a)) =\n    sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar> (\\<bar>x\\<bar> + (1::'a))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  sqrt_approx \\<epsilon> x =\n  sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar> (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "also"], ["proof (state)\nthis:\n  sqrt_approx \\<epsilon> x =\n  sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar> (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "have \"?sqrti = ?sqrt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar>\n     (\\<bar>x\\<bar> + (1::'a)) =\n    sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))", "by (rule sqrt_approx_main_impl, auto)"], ["proof (state)\nthis:\n  sqrt_approx_main_impl \\<epsilon> \\<bar>x\\<bar> (\\<bar>x\\<bar> + (1::'a)) =\n  sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  sqrt_approx \\<epsilon> x = sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))", "have id: \"sqrt_approx \\<epsilon> x = sqrt\""], ["proof (prove)\nusing this:\n  sqrt_approx \\<epsilon> x = sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. sqrt_approx \\<epsilon> x = sqrt", "unfolding sqrt_def"], ["proof (prove)\nusing this:\n  sqrt_approx \\<epsilon> x = sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))\n\ngoal (1 subgoal):\n 1. sqrt_approx \\<epsilon> x = sqrt_approx_main (\\<bar>x\\<bar> + (1::'a))", "."], ["proof (state)\nthis:\n  sqrt_approx \\<epsilon> x = sqrt\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "have sqrt: \"sqrt * sqrt > ?x \\<and> sqrt * sqrt - ?x < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> < sqrt * sqrt \\<and>\n    sqrt * sqrt - \\<bar>x\\<bar> < \\<epsilon>", "unfolding sqrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar>\n    < sqrt_approx_main (\\<bar>x\\<bar> + (1::'a)) *\n      sqrt_approx_main (\\<bar>x\\<bar> + (1::'a)) \\<and>\n    sqrt_approx_main (\\<bar>x\\<bar> + (1::'a)) *\n    sqrt_approx_main (\\<bar>x\\<bar> + (1::'a)) -\n    \\<bar>x\\<bar>\n    < \\<epsilon>", "by (rule sqrt_approx_main_sound[OF x(2)], insert x mult_pos_pos[OF x(1) x(1)], auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> < sqrt * sqrt \\<and>\n  sqrt * sqrt - \\<bar>x\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n          \\<bar>x\\<bar>\\<bar>\n    < \\<epsilon>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>sqrt * sqrt - \\<bar>x\\<bar>\\<bar> < \\<epsilon>", "using sqrt"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < sqrt * sqrt \\<and>\n  sqrt * sqrt - \\<bar>x\\<bar> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<bar>sqrt * sqrt - \\<bar>x\\<bar>\\<bar> < \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  \\<bar>sqrt_approx \\<epsilon> x * sqrt_approx \\<epsilon> x -\n        \\<bar>x\\<bar>\\<bar>\n  < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Some tests\\<close>"], ["", "text \\<open>Testing executabity and show that sqrt 2 is irrational\\<close>"], ["", "lemma \"\\<not> (\\<exists> i :: rat. i * i = 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 2", "have \"set (sqrt_rat 2) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sqrt_rat 2) = {}", "by eval"], ["proof (state)\nthis:\n  set (sqrt_rat 2) = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (sqrt_rat 2) = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 2", "by simp"], ["proof (state)\nthis:\n  \\<nexists>i. i * i = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Testing speed\\<close>"], ["", "lemma \"\\<not> (\\<exists> i :: int. i * i = 1234567890123456789012345678901234567890)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 1234567890123456789012345678901234567890", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 1234567890123456789012345678901234567890", "have \"set (sqrt_int 1234567890123456789012345678901234567890) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sqrt_int 1234567890123456789012345678901234567890) = {}", "by eval"], ["proof (state)\nthis:\n  set (sqrt_int 1234567890123456789012345678901234567890) = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 1234567890123456789012345678901234567890", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (sqrt_int 1234567890123456789012345678901234567890) = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>i. i * i = 1234567890123456789012345678901234567890", "by simp"], ["proof (state)\nthis:\n  \\<nexists>i. i * i = 1234567890123456789012345678901234567890\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following test\\<close>"], ["", "value \"let \\<epsilon> = 1 / 100000000 :: rat; s = sqrt_approx \\<epsilon> 2 in (s, s * s - 2, \\<bar>s * s - 2\\<bar> < \\<epsilon>)\""], ["", "text \\<open>results in (1.4142135623731116, 4.738200762148612e-14, True).\\<close>"], ["", "end"]]}