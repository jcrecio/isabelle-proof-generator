{"file_name": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian/NthRoot_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Sqrt_Babylonian", "problem_names": ["lemma start_value_main: assumes x: \"x \\<ge> 0\" and p: \"p > 0\"\n  shows \"x \\<le> (start_value x p)^p \\<and> start_value x p \\<ge> 0\"", "lemma start_value: assumes x: \"x \\<ge> 0\" and p: \"p > 0\" shows \"x \\<le> (start_value x p) ^ p\" \"start_value x p \\<ge> 0\"", "lemma iteration_mono_eq: assumes xn: \"x ^ p = (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p = x\"", "lemma p0: \"p \\<noteq> 0\"", "lemma iteration_mono_less: assumes x: \"x \\<ge> 0\"\n  and n: \"n \\<ge> 0\"\n  and xn: \"x ^ p > (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p < x\"", "lemma iteration_mono_lesseq: assumes x: \"x \\<ge> 0\" and n: \"n \\<ge> 0\" and xn: \"x ^ p \\<ge> (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p \\<le> x\"", "lemmas root_main'_simps = root_int_main'.simps[of pm \"int pm\" \"int p\"]", "lemma root_main'_newton_pos: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow>\n  root_main' x n = root_newton_int_main x n \\<and> (root_main' x n = (y,b) \\<longrightarrow> y \\<ge> 0 \\<and> y^p \\<le> n \\<and> b = (y^p = n))\"", "lemma root_main': \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = root_newton_int_main x n\"", "lemma root_main'_pos: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> y \\<ge> 0\"", "lemma root_main'_sound: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> b = (y ^ p = n)\"", "lemma root_main'_lower: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> y ^ p \\<le> n\"", "lemma root_newton_int_main_upper:\n  shows \"y ^ p \\<ge> n \\<Longrightarrow> y \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_newton_int_main y n = (x,b) \\<Longrightarrow> n < (x + 1) ^ p\"", "lemma root_main'_upper:\n  \"x ^ p \\<ge> n \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> n < (y + 1) ^ p\"", "lemma root_int_main_all: assumes n: \"n \\<ge> 0\"\n  and rm: \"root_int_main p n = (y,b)\"\n  shows \"y \\<ge> 0 \\<and> b = (y ^ p = n) \\<and> (p > 0 \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1)^p)\n    \\<and> (p > 0 \\<longrightarrow> x \\<ge> 0 \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\"", "lemma root_int_main: assumes n: \"n \\<ge> 0\"\n  and rm: \"root_int_main p n = (y,b)\"\n  shows \"y \\<ge> 0\" \"b = (y ^ p = n)\" \"p > 0 \\<Longrightarrow> y ^ p \\<le> n\" \"p > 0 \\<Longrightarrow> n < (y + 1)^p\"\n    \"p > 0 \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> x ^ p = n \\<Longrightarrow> y = x \\<and> b\"", "lemma root_int[simp]: assumes p: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_int p x) = {y . y ^ p = x}\"", "lemma root_int_pos: assumes x: \"x \\<ge> 0\" and ri: \"root_int p x = y # ys\"\n  shows \"y \\<ge> 0\"", "lemma root_int_floor_pos_lower: assumes p0: \"p \\<noteq> 0\" and x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x ^ p \\<le> x\"", "lemma root_int_floor_pos_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x \\<ge> 0\"", "lemma root_int_floor_pos_upper: assumes p0: \"p \\<noteq> 0\" and x: \"x \\<ge> 0\"\n  shows \"(root_int_floor_pos p x + 1) ^ p > x\"", "lemma root_int_floor_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x = floor (root p (of_int x))\"", "lemma root_int_ceiling_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_ceiling_pos p x = ceiling (root p (of_int x))\"", "lemma root_int_floor[simp]: \"root_int_floor p x = floor (root p (of_int x))\"", "lemma root_int_ceiling[simp]: \"root_int_ceiling p x = ceiling (root p (of_int x))\"", "lemma root_nat_floor [simp]: \"root_nat_floor p x = floor (root p (real x))\"", "lemma root_nat_floor_lower: assumes p0: \"p \\<noteq> 0\"\n  shows \"root_nat_floor p x ^ p \\<le> x\"", "lemma root_nat_floor_upper: assumes p0: \"p \\<noteq> 0\"\n  shows \"(root_nat_floor p x + 1) ^ p > x\"", "lemma root_nat_ceiling [simp]: \"root_nat_ceiling p x = ceiling (root p x)\"", "lemma root_nat: assumes p0: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_nat p x) = { y. y ^ p = x}\"", "lemma root_rat_reform: assumes q: \"quotient_of x = (a,b)\"\n  shows \"root p (real_of_rat x) = root p (of_int (a * b ^ (p - 1))) / of_int b\"", "lemma root_rat_floor [simp]: \"root_rat_floor p x = floor (root p (of_rat x))\"", "lemma root_rat_ceiling [simp]: \"root_rat_ceiling p x = ceiling (root p (of_rat x))\"", "lemma root_rat[simp]: assumes p: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_rat p x) = { y. y ^ p = x}\""], "translations": [["", "lemma start_value_main: assumes x: \"x \\<ge> 0\" and p: \"p > 0\"\n  shows \"x \\<le> (start_value x p)^p \\<and> start_value x p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "with p"], ["proof (chain)\npicking this:\n  0 < p\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < p\n  x = 0\n\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "unfolding start_value_def True"], ["proof (prove)\nusing this:\n  0 < p\n  0 = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> (2 ^\n             nat \\<lceil>rat_of_nat (log_ceiling 2 0) /\n                         rat_of_nat p\\<rceil>) ^\n            p \\<and>\n    0 \\<le> 2 ^\n            nat \\<lceil>rat_of_nat (log_ceiling 2 0) / rat_of_nat p\\<rceil>", "by simp"], ["proof (state)\nthis:\n  x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "with x"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  x \\<noteq> 0", "have x: \"x > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < x", "by auto"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "define l2x where \"l2x = \\<lceil>log 2 x\\<rceil>\""], ["proof (state)\nthis:\n  l2x = \\<lceil>log 2 (real_of_int x)\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "define pow where \"pow = nat \\<lceil>rat_of_int l2x / of_nat p\\<rceil>\""], ["proof (state)\nthis:\n  pow = nat \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"root p x = x powr (1 / p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) = real_of_int x powr (1 / real p)", "by (rule root_powr_inverse, insert x p, auto)"], ["proof (state)\nthis:\n  root p (real_of_int x) = real_of_int x powr (1 / real p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  root p (real_of_int x) = real_of_int x powr (1 / real p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> = (2 powr (log 2 x)) powr (1 / p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int x powr (1 / real p) =\n    (2 powr log 2 (real_of_int x)) powr (1 / real p)", "using powr_log_cancel[of 2 x] x"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 2; 2 \\<noteq> 1; 0 < real_of_int x\\<rbrakk>\n  \\<Longrightarrow> 2 powr log 2 (real_of_int x) = real_of_int x\n  0 < x\n\ngoal (1 subgoal):\n 1. real_of_int x powr (1 / real p) =\n    (2 powr log 2 (real_of_int x)) powr (1 / real p)", "by auto"], ["proof (state)\nthis:\n  real_of_int x powr (1 / real p) =\n  (2 powr log 2 (real_of_int x)) powr (1 / real p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_int x powr (1 / real p) =\n  (2 powr log 2 (real_of_int x)) powr (1 / real p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> = 2 powr (log 2 x * (1 / p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr log 2 (real_of_int x)) powr (1 / real p) =\n    2 powr (log 2 (real_of_int x) * (1 / real p))", "by (rule powr_powr)"], ["proof (state)\nthis:\n  (2 powr log 2 (real_of_int x)) powr (1 / real p) =\n  2 powr (log 2 (real_of_int x) * (1 / real p))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  (2 powr log 2 (real_of_int x)) powr (1 / real p) =\n  2 powr (log 2 (real_of_int x) * (1 / real p))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"log 2 x * (1 / p) = log 2 x / p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) * (1 / real p) = log 2 (real_of_int x) / real p", "using p"], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) * (1 / real p) = log 2 (real_of_int x) / real p", "by auto"], ["proof (state)\nthis:\n  log 2 (real_of_int x) * (1 / real p) = log 2 (real_of_int x) / real p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "finally"], ["proof (chain)\npicking this:\n  root p (real_of_int x) = 2 powr (log 2 (real_of_int x) / real p)", "have r: \"root p x = 2 powr (log 2 x / p)\""], ["proof (prove)\nusing this:\n  root p (real_of_int x) = 2 powr (log 2 (real_of_int x) / real p)\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) = 2 powr (log 2 (real_of_int x) / real p)", "."], ["proof (state)\nthis:\n  root p (real_of_int x) = 2 powr (log 2 (real_of_int x) / real p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have lp: \"log 2 x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> log 2 (real_of_int x)", "using x"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 \\<le> log 2 (real_of_int x)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> log 2 (real_of_int x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "hence l2pos: \"l2x \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> log 2 (real_of_int x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> l2x", "by (auto simp: l2x_def)"], ["proof (state)\nthis:\n  0 \\<le> l2x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"log 2 x / p \\<le> l2x / p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) / real p \\<le> real_of_int l2x / real p", "using x p"], ["proof (prove)\nusing this:\n  0 < x\n  0 < p\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) / real p \\<le> real_of_int l2x / real p", "unfolding l2x_def"], ["proof (prove)\nusing this:\n  0 < x\n  0 < p\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) / real p\n    \\<le> real_of_int \\<lceil>log 2 (real_of_int x)\\<rceil> / real p", "by (metis divide_right_mono le_of_int_ceiling of_nat_0_le_iff)"], ["proof (state)\nthis:\n  log 2 (real_of_int x) / real p \\<le> real_of_int l2x / real p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  log 2 (real_of_int x) / real p \\<le> real_of_int l2x / real p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> \\<le> \\<lceil>l2x / (p :: real)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int l2x / real p\n    \\<le> real_of_int \\<lceil>real_of_int l2x / real p\\<rceil>", "by (simp add: ceiling_correct)"], ["proof (state)\nthis:\n  real_of_int l2x / real p\n  \\<le> real_of_int \\<lceil>real_of_int l2x / real p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_int l2x / real p\n  \\<le> real_of_int \\<lceil>real_of_int l2x / real p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"l2x / real p = l2x / real_of_rat (of_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int l2x / real p = real_of_int l2x / real_of_rat (rat_of_nat p)", "by (metis of_rat_of_nat_eq)"], ["proof (state)\nthis:\n  real_of_int l2x / real p = real_of_int l2x / real_of_rat (rat_of_nat p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_int l2x / real p = real_of_int l2x / real_of_rat (rat_of_nat p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"of_int l2x = real_of_rat (of_int l2x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int l2x = real_of_rat (rat_of_int l2x)", "by (metis of_rat_of_int_eq)"], ["proof (state)\nthis:\n  real_of_int l2x = real_of_rat (rat_of_int l2x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_int l2x = real_of_rat (rat_of_int l2x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"real_of_rat (of_int l2x) / real_of_rat (of_nat p) = real_of_rat (rat_of_int l2x / of_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int l2x) / real_of_rat (rat_of_nat p) =\n    real_of_rat (rat_of_int l2x / rat_of_nat p)", "by (metis of_rat_divide)"], ["proof (state)\nthis:\n  real_of_rat (rat_of_int l2x) / real_of_rat (rat_of_nat p) =\n  real_of_rat (rat_of_int l2x / rat_of_nat p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_rat (rat_of_int l2x) / real_of_rat (rat_of_nat p) =\n  real_of_rat (rat_of_int l2x / rat_of_nat p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<lceil>real_of_rat (rat_of_int l2x / rat_of_nat p)\\<rceil> = \\<lceil>rat_of_int l2x / of_nat p\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>real_of_rat (rat_of_int l2x / rat_of_nat p)\\<rceil> =\n    \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>", "by simp"], ["proof (state)\nthis:\n  \\<lceil>real_of_rat (rat_of_int l2x / rat_of_nat p)\\<rceil> =\n  \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  \\<lceil>real_of_rat (rat_of_int l2x / rat_of_nat p)\\<rceil> =\n  \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<lceil>rat_of_int l2x / of_nat p\\<rceil> \\<le> real pow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil> \\<le> real pow", "unfolding pow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>\n    \\<le> real (nat \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil>)", "by auto"], ["proof (state)\nthis:\n  real_of_int \\<lceil>rat_of_int l2x / rat_of_nat p\\<rceil> \\<le> real pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "finally"], ["proof (chain)\npicking this:\n  log 2 (real_of_int x) / real p \\<le> real pow", "have le: \"log 2 x / p \\<le> pow\""], ["proof (prove)\nusing this:\n  log 2 (real_of_int x) / real p \\<le> real pow\n\ngoal (1 subgoal):\n 1. log 2 (real_of_int x) / real p \\<le> real pow", "."], ["proof (state)\nthis:\n  log 2 (real_of_int x) / real p \\<le> real pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "from powr_mono[OF le, of 2, folded r]"], ["proof (chain)\npicking this:\n  1 \\<le> 2 \\<Longrightarrow> root p (real_of_int x) \\<le> 2 powr real pow", "have \"root p x \\<le> 2 powr pow\""], ["proof (prove)\nusing this:\n  1 \\<le> 2 \\<Longrightarrow> root p (real_of_int x) \\<le> 2 powr real pow\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) \\<le> 2 powr real pow", "by auto"], ["proof (state)\nthis:\n  root p (real_of_int x) \\<le> 2 powr real pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  root p (real_of_int x) \\<le> 2 powr real pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> = 2 ^ pow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr real pow = 2 ^ pow", "by (rule powr_realpow, auto)"], ["proof (state)\nthis:\n  2 powr real pow = 2 ^ pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  2 powr real pow = 2 ^ pow\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> = of_int ((2 :: int) ^ pow)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ pow = real_of_int (2 ^ pow)", "by simp"], ["proof (state)\nthis:\n  2 ^ pow = real_of_int (2 ^ pow)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  2 ^ pow = real_of_int (2 ^ pow)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"pow = (nat \\<lceil>of_int (log_ceiling 2 x) / rat_of_nat p\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pow =\n    nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>", "unfolding pow_def l2x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lceil>rat_of_int \\<lceil>log 2 (real_of_int x)\\<rceil> /\n                rat_of_nat p\\<rceil> =\n    nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>", "using x"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. nat \\<lceil>rat_of_int \\<lceil>log 2 (real_of_int x)\\<rceil> /\n                rat_of_nat p\\<rceil> =\n    nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>", "by simp"], ["proof (state)\nthis:\n  pow =\n  nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  pow =\n  nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"real_of_int ((2 :: int) ^ \\<dots> ) = start_value x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (2 ^\n      nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) /\n                  rat_of_nat p\\<rceil>) =\n    real_of_int (start_value x p)", "unfolding start_value_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (2 ^\n      nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) /\n                  rat_of_nat p\\<rceil>) =\n    real_of_int\n     (2 ^ nat \\<lceil>rat_of_nat (log_ceiling 2 x) / rat_of_nat p\\<rceil>)", "by simp"], ["proof (state)\nthis:\n  real_of_int\n   (2 ^\n    nat \\<lceil>rat_of_int (int (log_ceiling 2 x)) / rat_of_nat p\\<rceil>) =\n  real_of_int (start_value x p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "finally"], ["proof (chain)\npicking this:\n  root p (real_of_int x) \\<le> real_of_int (start_value x p)", "have less: \"root p x \\<le> start_value x p\""], ["proof (prove)\nusing this:\n  root p (real_of_int x) \\<le> real_of_int (start_value x p)\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) \\<le> real_of_int (start_value x p)", "."], ["proof (state)\nthis:\n  root p (real_of_int x) \\<le> real_of_int (start_value x p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"0 \\<le> root p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> root p (real_of_int x)", "using p x"], ["proof (prove)\nusing this:\n  0 < p\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 \\<le> root p (real_of_int x)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  0 \\<le> root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> \\<le> start_value x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) \\<le> real_of_int (start_value x p)", "by (rule less)"], ["proof (state)\nthis:\n  root p (real_of_int x) \\<le> real_of_int (start_value x p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> real_of_int (start_value x p)", "have start: \"0 \\<le> start_value x p\""], ["proof (prove)\nusing this:\n  0 \\<le> real_of_int (start_value x p)\n\ngoal (1 subgoal):\n 1. 0 \\<le> start_value x p", "by simp"], ["proof (state)\nthis:\n  0 \\<le> start_value x p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "from power_mono[OF less, of p]"], ["proof (chain)\npicking this:\n  0 \\<le> root p (real_of_int x) \\<Longrightarrow>\n  root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p", "have \"root p (of_int x) ^ p \\<le> of_int (start_value x p) ^ p\""], ["proof (prove)\nusing this:\n  0 \\<le> root p (real_of_int x) \\<Longrightarrow>\n  root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p", "using p x"], ["proof (prove)\nusing this:\n  0 \\<le> root p (real_of_int x) \\<Longrightarrow>\n  root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p\n  0 < p\n  0 < x\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p", "by auto"], ["proof (state)\nthis:\n  root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  root p (real_of_int x) ^ p \\<le> real_of_int (start_value x p) ^ p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"\\<dots> = start_value x p ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (start_value x p) ^ p = real_of_int (start_value x p ^ p)", "by simp"], ["proof (state)\nthis:\n  real_of_int (start_value x p) ^ p = real_of_int (start_value x p ^ p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "also"], ["proof (state)\nthis:\n  real_of_int (start_value x p) ^ p = real_of_int (start_value x p ^ p)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "have \"root p (of_int x) ^ p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "using p x"], ["proof (prove)\nusing this:\n  0 < p\n  0 < x\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "by force"], ["proof (state)\nthis:\n  root p (real_of_int x) ^ p = real_of_int x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "finally"], ["proof (chain)\npicking this:\n  real_of_int x \\<le> real_of_int (start_value x p ^ p)", "have \"x \\<le> (start_value x p) ^ p\""], ["proof (prove)\nusing this:\n  real_of_int x \\<le> real_of_int (start_value x p ^ p)\n\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p", "by presburger"], ["proof (state)\nthis:\n  x \\<le> start_value x p ^ p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "with start"], ["proof (chain)\npicking this:\n  0 \\<le> start_value x p\n  x \\<le> start_value x p ^ p", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> start_value x p\n  x \\<le> start_value x p ^ p\n\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p", "by auto"], ["proof (state)\nthis:\n  x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_value: assumes x: \"x \\<ge> 0\" and p: \"p > 0\" shows \"x \\<le> (start_value x p) ^ p\" \"start_value x p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p &&& 0 \\<le> start_value x p", "using start_value_main[OF x p]"], ["proof (prove)\nusing this:\n  x \\<le> start_value x p ^ p \\<and> 0 \\<le> start_value x p\n\ngoal (1 subgoal):\n 1. x \\<le> start_value x p ^ p &&& 0 \\<le> start_value x p", "by auto"], ["", "text \\<open>We now define the Newton iteration to compute the $p$-th root. We are working on the integers,\n  where every @{term \"(/)\"} is replaced by @{term \"(div)\"}. We are proving several things within\n  a locale which ensures that $p > 0$, and where $pm = p - 1$.\n\\<close>"], ["", "locale fixed_root =\n  fixes p pm :: nat\n  assumes p: \"p = Suc pm\"\nbegin"], ["", "function root_newton_int_main :: \"int \\<Rightarrow> int \\<Rightarrow> int \\<times> bool\" where\n  \"root_newton_int_main x n = (if (x < 0 \\<or> n < 0) then (0,False) else (if x ^ p \\<le> n then (x, x ^ p = n)\n    else root_newton_int_main ((n div (x ^ pm) + x * int pm) div (int p)) n))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>xa n. x = (xa, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>x n xa na.\n       (x, n) = (xa, na) \\<Longrightarrow>\n       (if x < 0 \\<or> n < 0 then (0, False)\n        else if x ^ p \\<le> n then (x, x ^ p = n)\n             else root_newton_int_main_sumC\n                   ((n div x ^ pm + x * int pm) div int p, n)) =\n       (if xa < 0 \\<or> na < 0 then (0, False)\n        else if xa ^ p \\<le> na then (xa, xa ^ p = na)\n             else root_newton_int_main_sumC\n                   ((na div xa ^ pm + xa * int pm) div int p, na))", "by pat_completeness auto"], ["", "end"], ["", "text \\<open>For the executable algorithm we omit the guard and use a let-construction\\<close>"], ["", "partial_function (tailrec) root_int_main' :: \"nat \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<times> bool\" where\n  [code]: \"root_int_main' pm ipm ip x n = (let xpm = x^pm; xp = xpm * x in if xp \\<le> n then (x, xp = n)\n    else root_int_main' pm ipm ip ((n div xpm + x * ipm) div ip) n)\""], ["", "text \\<open>In the following algorithm, we\n  start the iteration.\n  It will compute @{term \"\\<lfloor>root p n\\<rfloor>\"} and a boolean to indicate whether the root is exact.\\<close>"], ["", "definition root_int_main :: \"nat \\<Rightarrow> int \\<Rightarrow> int \\<times> bool\" where\n  \"root_int_main p n \\<equiv> if p = 0 then (1,n = 1) else\n     let pm = p - 1\n       in root_int_main' pm (int pm) (int p) (start_value n p) n\""], ["", "text \\<open>Once we have proven soundness of @{const fixed_root.root_newton_int_main} and equivalence\n  to @{const root_int_main}, it\n  is easy to assemble the following algorithm which computes all roots for arbitrary integers.\\<close>"], ["", "definition root_int :: \"nat \\<Rightarrow> int \\<Rightarrow> int list\" where\n  \"root_int p x \\<equiv> if p = 0 then [] else\n    if x = 0 then [0] else\n      let e = even p; s = sgn x; x' = abs x\n      in if x < 0 \\<and> e then [] else case root_int_main p x' of (y,True) \\<Rightarrow> if e then [y,-y] else [s * y] | _ \\<Rightarrow> []\""], ["", "text \\<open>We start with proving termination of @{const fixed_root.root_newton_int_main}.\\<close>"], ["", "context fixed_root\nbegin"], ["", "lemma iteration_mono_eq: assumes xn: \"x ^ p = (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p = x", "have [simp]: \"\\<And> n. (x + x * n) = x * (1 + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. x + x * n = x * (1 + n)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  x + x * ?n = x * (1 + ?n)\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p = x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p = x", "unfolding xn[symmetric] p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ Suc pm div x ^ pm + x * int pm) div int (Suc pm) = x", "by simp"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p0: \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc pm \\<noteq> 0", "by auto"], ["", "text \\<open>The following property is the essential property for\n  proving termination of @{const \"root_newton_int_main\"}.\n\\<close>"], ["", "lemma iteration_mono_less: assumes x: \"x \\<ge> 0\"\n  and n: \"n \\<ge> 0\"\n  and xn: \"x ^ p > (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "let ?sx = \"(n div x ^ pm + x * int pm) div int p\""], ["proof (state)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from xn"], ["proof (chain)\npicking this:\n  n < x ^ p", "have xn_le: \"x ^ p \\<ge> n\""], ["proof (prove)\nusing this:\n  n < x ^ p\n\ngoal (1 subgoal):\n 1. n \\<le> x ^ p", "by auto"], ["proof (state)\nthis:\n  n \\<le> x ^ p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from xn x n"], ["proof (chain)\npicking this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n", "have x0: \"x > 0\""], ["proof (prove)\nusing this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < x", "using not_le p"], ["proof (prove)\nusing this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. 0 < x", "by fastforce"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from p"], ["proof (chain)\npicking this:\n  p = Suc pm", "have xp: \"x ^ p = x * x ^ pm\""], ["proof (prove)\nusing this:\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. x ^ p = x * x ^ pm", "by auto"], ["proof (state)\nthis:\n  x ^ p = x * x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from x n"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  0 \\<le> n", "have \"n div x ^ pm * x ^ pm \\<le> n\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. n div x ^ pm * x ^ pm \\<le> n", "by (auto simp add: minus_mod_eq_div_mult [symmetric] mod_int_pos_iff not_less power_le_zero_eq)"], ["proof (state)\nthis:\n  n div x ^ pm * x ^ pm \\<le> n\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "also"], ["proof (state)\nthis:\n  n div x ^ pm * x ^ pm \\<le> n\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"\\<dots> \\<le> x ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> x ^ p", "using xn"], ["proof (prove)\nusing this:\n  n < x ^ p\n\ngoal (1 subgoal):\n 1. n \\<le> x ^ p", "by auto"], ["proof (state)\nthis:\n  n \\<le> x ^ p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "finally"], ["proof (chain)\npicking this:\n  n div x ^ pm * x ^ pm \\<le> x ^ p", "have le: \"n div x ^ pm \\<le> x\""], ["proof (prove)\nusing this:\n  n div x ^ pm * x ^ pm \\<le> x ^ p\n\ngoal (1 subgoal):\n 1. n div x ^ pm \\<le> x", "using x x0"], ["proof (prove)\nusing this:\n  n div x ^ pm * x ^ pm \\<le> x ^ p\n  0 \\<le> x\n  0 < x\n\ngoal (1 subgoal):\n 1. n div x ^ pm \\<le> x", "unfolding xp"], ["proof (prove)\nusing this:\n  n div x ^ pm * x ^ pm \\<le> x * x ^ pm\n  0 \\<le> x\n  0 < x\n\ngoal (1 subgoal):\n 1. n div x ^ pm \\<le> x", "by simp"], ["proof (state)\nthis:\n  n div x ^ pm \\<le> x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"?sx \\<le> (x^p div x ^ pm + x * int pm) div int p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p\n    \\<le> (x ^ p div x ^ pm + x * int pm) div int p", "by (rule zdiv_mono1, insert le p0, unfold xp, auto)"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p\n  \\<le> (x ^ p div x ^ pm + x * int pm) div int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "also"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p\n  \\<le> (x ^ p div x ^ pm + x * int pm) div int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"x^p div x ^ pm = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ p div x ^ pm = x", "unfolding xp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ pm div x ^ pm = x", "by auto"], ["proof (state)\nthis:\n  x ^ p div x ^ pm = x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "also"], ["proof (state)\nthis:\n  x ^ p div x ^ pm = x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"x + x * int pm = x * int p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x * int pm = x * int p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + x * int pm = x * int (Suc pm)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  x + x * int pm = x * int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "also"], ["proof (state)\nthis:\n  x + x * int pm = x * int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"x * int p div int p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * int p div int p = x", "using p"], ["proof (prove)\nusing this:\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. x * int p div int p = x", "by force"], ["proof (state)\nthis:\n  x * int p div int p = x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "finally"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p \\<le> x", "have le: \"?sx \\<le> x\""], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p \\<le> x", "."], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "{"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "assume \"?sx = x\""], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p = x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from arg_cong[OF this, of \"\\<lambda> x. x * int p\"]"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p * int p = x * int p", "have \"x * int p \\<le> (n div x ^ pm + x * int pm) div (int p) * int p\""], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p * int p = x * int p\n\ngoal (1 subgoal):\n 1. x * int p \\<le> (n div x ^ pm + x * int pm) div int p * int p", "using p0"], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p * int p = x * int p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * int p \\<le> (n div x ^ pm + x * int pm) div int p * int p", "by simp"], ["proof (state)\nthis:\n  x * int p \\<le> (n div x ^ pm + x * int pm) div int p * int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "also"], ["proof (state)\nthis:\n  x * int p \\<le> (n div x ^ pm + x * int pm) div int p * int p\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "have \"\\<dots> \\<le> n div x ^ pm + x * int pm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p * int p\n    \\<le> n div x ^ pm + x * int pm", "unfolding mod_div_equality_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. n div x ^ pm + x * int pm - (n div x ^ pm + x * int pm) mod int p\n    \\<le> n div x ^ pm + x * int pm", "using p"], ["proof (prove)\nusing this:\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. n div x ^ pm + x * int pm - (n div x ^ pm + x * int pm) mod int p\n    \\<le> n div x ^ pm + x * int pm", "by auto"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p * int p\n  \\<le> n div x ^ pm + x * int pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "finally"], ["proof (chain)\npicking this:\n  x * int p \\<le> n div x ^ pm + x * int pm", "have \"n div x^pm \\<ge> x\""], ["proof (prove)\nusing this:\n  x * int p \\<le> n div x ^ pm + x * int pm\n\ngoal (1 subgoal):\n 1. x \\<le> n div x ^ pm", "by (auto simp: p field_simps)"], ["proof (state)\nthis:\n  x \\<le> n div x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from mult_right_mono[OF this, of \"x ^ pm\"]"], ["proof (chain)\npicking this:\n  0 \\<le> x ^ pm \\<Longrightarrow> x * x ^ pm \\<le> n div x ^ pm * x ^ pm", "have ge: \"n div x^pm * x^pm \\<ge> x^p\""], ["proof (prove)\nusing this:\n  0 \\<le> x ^ pm \\<Longrightarrow> x * x ^ pm \\<le> n div x ^ pm * x ^ pm\n\ngoal (1 subgoal):\n 1. x ^ p \\<le> n div x ^ pm * x ^ pm", "unfolding xp"], ["proof (prove)\nusing this:\n  0 \\<le> x ^ pm \\<Longrightarrow> x * x ^ pm \\<le> n div x ^ pm * x ^ pm\n\ngoal (1 subgoal):\n 1. x * x ^ pm \\<le> n div x ^ pm * x ^ pm", "using x"], ["proof (prove)\nusing this:\n  0 \\<le> x ^ pm \\<Longrightarrow> x * x ^ pm \\<le> n div x ^ pm * x ^ pm\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. x * x ^ pm \\<le> n div x ^ pm * x ^ pm", "by auto"], ["proof (state)\nthis:\n  x ^ p \\<le> n div x ^ pm * x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from div_mult_mod_eq[of n \"x^pm\"]"], ["proof (chain)\npicking this:\n  n div x ^ pm * x ^ pm + n mod x ^ pm = n", "have \"n div x^pm * x^pm = n - n mod x^pm\""], ["proof (prove)\nusing this:\n  n div x ^ pm * x ^ pm + n mod x ^ pm = n\n\ngoal (1 subgoal):\n 1. n div x ^ pm * x ^ pm = n - n mod x ^ pm", "by arith"], ["proof (state)\nthis:\n  n div x ^ pm * x ^ pm = n - n mod x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from ge[unfolded this]"], ["proof (chain)\npicking this:\n  x ^ p \\<le> n - n mod x ^ pm", "have le: \"x^p \\<le> n - n mod x^pm\""], ["proof (prove)\nusing this:\n  x ^ p \\<le> n - n mod x ^ pm\n\ngoal (1 subgoal):\n 1. x ^ p \\<le> n - n mod x ^ pm", "."], ["proof (state)\nthis:\n  x ^ p \\<le> n - n mod x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from x n"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  0 \\<le> n", "have ge: \"n mod x ^ pm \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> n mod x ^ pm", "by (auto simp add: mod_int_pos_iff not_less power_le_zero_eq)"], ["proof (state)\nthis:\n  0 \\<le> n mod x ^ pm\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "from le ge"], ["proof (chain)\npicking this:\n  x ^ p \\<le> n - n mod x ^ pm\n  0 \\<le> n mod x ^ pm", "have \"n \\<ge> x^p\""], ["proof (prove)\nusing this:\n  x ^ p \\<le> n - n mod x ^ pm\n  0 \\<le> n mod x ^ pm\n\ngoal (1 subgoal):\n 1. x ^ p \\<le> n", "by auto"], ["proof (state)\nthis:\n  x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "with xn"], ["proof (chain)\npicking this:\n  n < x ^ p\n  x ^ p \\<le> n", "have False"], ["proof (prove)\nusing this:\n  n < x ^ p\n  x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "}"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "with le"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n  (n div x ^ pm + x * int pm) div int p = x \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n  (n div x ^ pm + x * int pm) div int p = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p < x", "unfolding p"], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int (Suc pm) \\<le> x\n  (n div x ^ pm + x * int pm) div int (Suc pm) = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int (Suc pm) < x", "by fastforce"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p < x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteration_mono_lesseq: assumes x: \"x \\<ge> 0\" and n: \"n \\<ge> 0\" and xn: \"x ^ p \\<ge> (n :: int)\"\n  shows \"(n div x ^ pm + x * int pm) div int p \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p \\<le> x", "proof (cases \"x ^ p = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x ^ p = n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x\n 2. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "case True"], ["proof (state)\nthis:\n  x ^ p = n\n\ngoal (2 subgoals):\n 1. x ^ p = n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x\n 2. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "from iteration_mono_eq[OF this]"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p = x", "show ?thesis"], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p = x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p \\<le> x", "by simp"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n\ngoal (1 subgoal):\n 1. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "case False"], ["proof (state)\nthis:\n  x ^ p \\<noteq> n\n\ngoal (1 subgoal):\n 1. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "with assms"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  0 \\<le> n\n  n \\<le> x ^ p\n  x ^ p \\<noteq> n", "have \"x ^ p > n\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  0 \\<le> n\n  n \\<le> x ^ p\n  x ^ p \\<noteq> n\n\ngoal (1 subgoal):\n 1. n < x ^ p", "by auto"], ["proof (state)\nthis:\n  n < x ^ p\n\ngoal (1 subgoal):\n 1. x ^ p \\<noteq> n \\<Longrightarrow>\n    (n div x ^ pm + x * int pm) div int p \\<le> x", "from iteration_mono_less[OF x n this]"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p < x", "show ?thesis"], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p < x\n\ngoal (1 subgoal):\n 1. (n div x ^ pm + x * int pm) div int p \\<le> x", "by simp"], ["proof (state)\nthis:\n  (n div x ^ pm + x * int pm) div int p \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "(* of root_newton_int_main *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "let ?mm = \"\\<lambda> x  n :: int. nat x\""], ["proof (state)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "let ?m1 = \"\\<lambda> (x,n). ?mm x n\""], ["proof (state)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "let ?m = \"measures [?m1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All root_newton_int_main_dom", "proof (relation ?m)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "fix x n :: int"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "assume \"\\<not> x ^ p \\<le> n\""], ["proof (state)\nthis:\n  \\<not> x ^ p \\<le> n\n\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "hence x: \"x ^ p > n\""], ["proof (prove)\nusing this:\n  \\<not> x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. n < x ^ p", "by auto"], ["proof (state)\nthis:\n  n < x ^ p\n\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "assume \"\\<not> (x < 0 \\<or> n < 0)\""], ["proof (state)\nthis:\n  \\<not> (x < 0 \\<or> n < 0)\n\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "hence x_n: \"x \\<ge> 0\" \"n \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> (x < 0 \\<or> n < 0)\n\ngoal (1 subgoal):\n 1. 0 \\<le> x &&& 0 \\<le> n", "by auto"], ["proof (state)\nthis:\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "from x x_n"], ["proof (chain)\npicking this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n", "have x0: \"x > 0\""], ["proof (prove)\nusing this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < x", "using p"], ["proof (prove)\nusing this:\n  n < x ^ p\n  0 \\<le> x\n  0 \\<le> n\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. 0 < x", "by (cases \"x = 0\", auto)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. wf (measures [\\<lambda>(x, n). nat x])\n 2. \\<And>x n.\n       \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (((n div x ^ pm + x * int pm) div int p, n), x, n)\n                         \\<in> measures [\\<lambda>(x, n). nat x]", "from iteration_mono_less[OF x_n x] x0"], ["proof (chain)\npicking this:\n  (n div x ^ pm + x * int pm) div int p < x\n  0 < x", "show \"(((n div x ^ pm + x * int pm) div int p, n), x, n) \\<in> ?m\""], ["proof (prove)\nusing this:\n  (n div x ^ pm + x * int pm) div int p < x\n  0 < x\n\ngoal (1 subgoal):\n 1. (((n div x ^ pm + x * int pm) div int p, n), x, n)\n    \\<in> measures [\\<lambda>(x, n). nat x]", "by auto"], ["proof (state)\nthis:\n  (((n div x ^ pm + x * int pm) div int p, n), x, n)\n  \\<in> measures [\\<lambda>(x, n). nat x]\n\ngoal (1 subgoal):\n 1. wf (measures [\\<lambda>(x, n). nat x])", "qed auto"], ["proof (state)\nthis:\n  All root_newton_int_main_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We next prove that @{const root_int_main'} is a correct implementation of @{const root_newton_int_main}.\nWe additionally prove that the result is always positive, a lower bound, and that the returned boolean indicates\nwhether the result has a root or not. We prove all these results in one go, so that we can share the\ninductive proof.\n\\<close>"], ["", "abbreviation root_main' where \"root_main' \\<equiv> root_int_main' pm (int pm) (int p)\""], ["", "lemmas root_main'_simps = root_int_main'.simps[of pm \"int pm\" \"int p\"]"], ["", "lemma root_main'_newton_pos: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow>\n  root_main' x n = root_newton_int_main x n \\<and> (root_main' x n = (y,b) \\<longrightarrow> y \\<ge> 0 \\<and> y^p \\<le> n \\<and> b = (y^p = n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                      (root_main' x n = (y, b) \\<longrightarrow>\n                       0 \\<le> y \\<and>\n                       y ^ p \\<le> n \\<and> b = (y ^ p = n))", "proof (induct x n rule: root_newton_int_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n                 0 \\<le> (n div x ^ pm + x * int pm) div int p;\n                 0 \\<le> n\\<rbrakk>\n                \\<Longrightarrow> root_main'\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n =\n                                  root_newton_int_main\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n \\<and>\n                                  (root_main'\n                                    ((n div x ^ pm + x * int pm) div int p)\n                                    n =\n                                   (y, b) \\<longrightarrow>\n                                   0 \\<le> y \\<and>\n                                   y ^ p \\<le> n \\<and> b = (y ^ p = n));\n        0 \\<le> x; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                         (root_main' x n = (y, b) \\<longrightarrow>\n                          0 \\<le> y \\<and>\n                          y ^ p \\<le> n \\<and> b = (y ^ p = n))", "case (1 x n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n   0 \\<le> (n div x ^ pm + x * int pm) div int p; 0 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                    root_newton_int_main\n                     ((n div x ^ pm + x * int pm) div int p) n \\<and>\n                    (root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                     (y, b) \\<longrightarrow>\n                     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n                 0 \\<le> (n div x ^ pm + x * int pm) div int p;\n                 0 \\<le> n\\<rbrakk>\n                \\<Longrightarrow> root_main'\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n =\n                                  root_newton_int_main\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n \\<and>\n                                  (root_main'\n                                    ((n div x ^ pm + x * int pm) div int p)\n                                    n =\n                                   (y, b) \\<longrightarrow>\n                                   0 \\<le> y \\<and>\n                                   y ^ p \\<le> n \\<and> b = (y ^ p = n));\n        0 \\<le> x; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                         (root_main' x n = (y, b) \\<longrightarrow>\n                          0 \\<le> y \\<and>\n                          y ^ p \\<le> n \\<and> b = (y ^ p = n))", "have pm_x[simp]: \"x ^ pm * x = x ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ pm * x = x ^ p", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ pm * x = x ^ Suc pm", "by simp"], ["proof (state)\nthis:\n  x ^ pm * x = x ^ p\n\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n                 0 \\<le> (n div x ^ pm + x * int pm) div int p;\n                 0 \\<le> n\\<rbrakk>\n                \\<Longrightarrow> root_main'\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n =\n                                  root_newton_int_main\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n \\<and>\n                                  (root_main'\n                                    ((n div x ^ pm + x * int pm) div int p)\n                                    n =\n                                   (y, b) \\<longrightarrow>\n                                   0 \\<le> y \\<and>\n                                   y ^ p \\<le> n \\<and> b = (y ^ p = n));\n        0 \\<le> x; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                         (root_main' x n = (y, b) \\<longrightarrow>\n                          0 \\<le> y \\<and>\n                          y ^ p \\<le> n \\<and> b = (y ^ p = n))", "from 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n   0 \\<le> (n div x ^ pm + x * int pm) div int p; 0 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                    root_newton_int_main\n                     ((n div x ^ pm + x * int pm) div int p) n \\<and>\n                    (root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                     (y, b) \\<longrightarrow>\n                     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n  0 \\<le> x\n  0 \\<le> n", "have id: \"(x < 0 \\<or> n < 0) = False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n   0 \\<le> (n div x ^ pm + x * int pm) div int p; 0 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                    root_newton_int_main\n                     ((n div x ^ pm + x * int pm) div int p) n \\<and>\n                    (root_main' ((n div x ^ pm + x * int pm) div int p) n =\n                     (y, b) \\<longrightarrow>\n                     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n  0 \\<le> x\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. (x < 0 \\<or> n < 0) = False", "by auto"], ["proof (state)\nthis:\n  (x < 0 \\<or> n < 0) = False\n\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n                 0 \\<le> (n div x ^ pm + x * int pm) div int p;\n                 0 \\<le> n\\<rbrakk>\n                \\<Longrightarrow> root_main'\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n =\n                                  root_newton_int_main\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n \\<and>\n                                  (root_main'\n                                    ((n div x ^ pm + x * int pm) div int p)\n                                    n =\n                                   (y, b) \\<longrightarrow>\n                                   0 \\<le> y \\<and>\n                                   y ^ p \\<le> n \\<and> b = (y ^ p = n));\n        0 \\<le> x; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                         (root_main' x n = (y, b) \\<longrightarrow>\n                          0 \\<le> y \\<and>\n                          y ^ p \\<le> n \\<and> b = (y ^ p = n))", "note d = root_main'_simps[of x n] root_newton_int_main.simps[of x n] id if_False Let_def"], ["proof (state)\nthis:\n  root_main' x n =\n  (let xpm = x ^ pm; xp = xpm * x\n   in if xp \\<le> n then (x, xp = n)\n      else root_main' ((n div xpm + x * int pm) div int p) n)\n  root_newton_int_main x n =\n  (if x < 0 \\<or> n < 0 then (0, False)\n   else if x ^ p \\<le> n then (x, x ^ p = n)\n        else root_newton_int_main ((n div x ^ pm + x * int pm) div int p) n)\n  (x < 0 \\<or> n < 0) = False\n  (if False then ?x else ?y) = ?y\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<lbrakk>\\<not> (x < 0 \\<or> n < 0); \\<not> x ^ p \\<le> n;\n                 0 \\<le> (n div x ^ pm + x * int pm) div int p;\n                 0 \\<le> n\\<rbrakk>\n                \\<Longrightarrow> root_main'\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n =\n                                  root_newton_int_main\n                                   ((n div x ^ pm + x * int pm) div int p)\n                                   n \\<and>\n                                  (root_main'\n                                    ((n div x ^ pm + x * int pm) div int p)\n                                    n =\n                                   (y, b) \\<longrightarrow>\n                                   0 \\<le> y \\<and>\n                                   y ^ p \\<le> n \\<and> b = (y ^ p = n));\n        0 \\<le> x; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> root_main' x n = root_newton_int_main x n \\<and>\n                         (root_main' x n = (y, b) \\<longrightarrow>\n                          0 \\<le> y \\<and>\n                          y ^ p \\<le> n \\<and> b = (y ^ p = n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "proof (cases \"x ^ p \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n 2. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "case True"], ["proof (state)\nthis:\n  x ^ p \\<le> n\n\ngoal (2 subgoals):\n 1. x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n 2. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "unfolding d"], ["proof (prove)\nusing this:\n  x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. (if x ^ pm * x \\<le> n then (x, x ^ pm * x = n)\n     else root_main' ((n div x ^ pm + x * int pm) div int p) n) =\n    (if x ^ p \\<le> n then (x, x ^ p = n)\n     else root_newton_int_main ((n div x ^ pm + x * int pm) div int p)\n           n) \\<and>\n    ((if x ^ pm * x \\<le> n then (x, x ^ pm * x = n)\n      else root_main' ((n div x ^ pm + x * int pm) div int p) n) =\n     (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "using 1(2)"], ["proof (prove)\nusing this:\n  x ^ p \\<le> n\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (if x ^ pm * x \\<le> n then (x, x ^ pm * x = n)\n     else root_main' ((n div x ^ pm + x * int pm) div int p) n) =\n    (if x ^ p \\<le> n then (x, x ^ p = n)\n     else root_newton_int_main ((n div x ^ pm + x * int pm) div int p)\n           n) \\<and>\n    ((if x ^ pm * x \\<le> n then (x, x ^ pm * x = n)\n      else root_main' ((n div x ^ pm + x * int pm) div int p) n) =\n     (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "by auto"], ["proof (state)\nthis:\n  root_main' x n = root_newton_int_main x n \\<and>\n  (root_main' x n = (y, b) \\<longrightarrow>\n   0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "case False"], ["proof (state)\nthis:\n  \\<not> x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "hence id: \"(x ^ p \\<le> n) = False\""], ["proof (prove)\nusing this:\n  \\<not> x ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. (x ^ p \\<le> n) = False", "by simp"], ["proof (state)\nthis:\n  (x ^ p \\<le> n) = False\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "from 1(3) 1(2)"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  0 \\<le> x", "have not: \"\\<not> (x < 0 \\<or> n < 0)\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<or> n < 0)", "by auto"], ["proof (state)\nthis:\n  \\<not> (x < 0 \\<or> n < 0)\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "then"], ["proof (chain)\npicking this:\n  \\<not> (x < 0 \\<or> n < 0)", "have x: \"x > 0 \\<or> x = 0\""], ["proof (prove)\nusing this:\n  \\<not> (x < 0 \\<or> n < 0)\n\ngoal (1 subgoal):\n 1. 0 < x \\<or> x = 0", "by auto"], ["proof (state)\nthis:\n  0 < x \\<or> x = 0\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "with \\<open>0 \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  0 < x \\<or> x = 0", "have \"0 \\<le> (n div x ^ pm + x * int pm) div int p\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n  0 < x \\<or> x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> (n div x ^ pm + x * int pm) div int p", "by (auto simp add: p algebra_simps pos_imp_zdiv_nonneg_iff power_0_left)"], ["proof (state)\nthis:\n  0 \\<le> (n div x ^ pm + x * int pm) div int p\n\ngoal (1 subgoal):\n 1. \\<not> x ^ p \\<le> n \\<Longrightarrow>\n    root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> (n div x ^ pm + x * int pm) div int p", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> (n div x ^ pm + x * int pm) div int p\n\ngoal (1 subgoal):\n 1. root_main' x n = root_newton_int_main x n \\<and>\n    (root_main' x n = (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "unfolding d id pm_x"], ["proof (prove)\nusing this:\n  0 \\<le> (n div x ^ pm + x * int pm) div int p\n\ngoal (1 subgoal):\n 1. root_main' ((n div x ^ pm + x * int pm) div int p) n =\n    root_newton_int_main ((n div x ^ pm + x * int pm) div int p) n \\<and>\n    (root_main' ((n div x ^ pm + x * int pm) div int p) n =\n     (y, b) \\<longrightarrow>\n     0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))", "by (rule 1(1)[OF not False _ 1(3)])"], ["proof (state)\nthis:\n  root_main' x n = root_newton_int_main x n \\<and>\n  (root_main' x n = (y, b) \\<longrightarrow>\n   0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_main' x n = root_newton_int_main x n \\<and>\n  (root_main' x n = (y, b) \\<longrightarrow>\n   0 \\<le> y \\<and> y ^ p \\<le> n \\<and> b = (y ^ p = n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_main': \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = root_newton_int_main x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> root_main' x n = root_newton_int_main x n", "using root_main'_newton_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> root_main' ?x ?n = root_newton_int_main ?x ?n \\<and>\n                    (root_main' ?x ?n = (?y, ?b) \\<longrightarrow>\n                     0 \\<le> ?y \\<and>\n                     ?y ^ p \\<le> ?n \\<and> ?b = (?y ^ p = ?n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> root_main' x n = root_newton_int_main x n", "by blast"], ["", "lemma root_main'_pos: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> y", "using root_main'_newton_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> root_main' ?x ?n = root_newton_int_main ?x ?n \\<and>\n                    (root_main' ?x ?n = (?y, ?b) \\<longrightarrow>\n                     0 \\<le> ?y \\<and>\n                     ?y ^ p \\<le> ?n \\<and> ?b = (?y ^ p = ?n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> y", "by blast"], ["", "lemma root_main'_sound: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> b = (y ^ p = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> b = (y ^ p = n)", "using root_main'_newton_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> root_main' ?x ?n = root_newton_int_main ?x ?n \\<and>\n                    (root_main' ?x ?n = (?y, ?b) \\<longrightarrow>\n                     0 \\<le> ?y \\<and>\n                     ?y ^ p \\<le> ?n \\<and> ?b = (?y ^ p = ?n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> b = (y ^ p = n)", "by blast"], ["", "text \\<open>In order to prove completeness of the algorithms, we provide sharp upper and lower bounds\n  for @{const root_main'}. For the upper bounds, we use Cauchy's mean theorem where we added\n  the non-strict variant to Porter's formalization of this theorem.\\<close>"], ["", "lemma root_main'_lower: \"x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> y ^ p \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> y ^ p \\<le> n", "using root_main'_newton_pos"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> root_main' ?x ?n = root_newton_int_main ?x ?n \\<and>\n                    (root_main' ?x ?n = (?y, ?b) \\<longrightarrow>\n                     0 \\<le> ?y \\<and>\n                     ?y ^ p \\<le> ?n \\<and> ?b = (?y ^ p = ?n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; 0 \\<le> n; root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> y ^ p \\<le> n", "by blast"], ["", "lemma root_newton_int_main_upper:\n  shows \"y ^ p \\<ge> n \\<Longrightarrow> y \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_newton_int_main y n = (x,b) \\<Longrightarrow> n < (x + 1) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> y ^ p; 0 \\<le> y; 0 \\<le> n;\n     root_newton_int_main y n = (x, b)\\<rbrakk>\n    \\<Longrightarrow> n < (x + 1) ^ p", "proof (induct y n rule: root_newton_int_main.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "case (1 y n)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> (y < 0 \\<or> n < 0); \\<not> y ^ p \\<le> n;\n   n \\<le> ((n div y ^ pm + y * int pm) div int p) ^ p;\n   0 \\<le> (n div y ^ pm + y * int pm) div int p; 0 \\<le> n;\n   root_newton_int_main ((n div y ^ pm + y * int pm) div int p) n =\n   (x, b)\\<rbrakk>\n  \\<Longrightarrow> n < (x + 1) ^ p\n  n \\<le> y ^ p\n  0 \\<le> y\n  0 \\<le> n\n  root_newton_int_main y n = (x, b)\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "from 1(3)"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have y0: \"y \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "."], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "then"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have \"y > 0 \\<or> y = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < y \\<or> y = 0", "by auto"], ["proof (state)\nthis:\n  0 < y \\<or> y = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "from 1(4)"], ["proof (chain)\npicking this:\n  0 \\<le> n", "have n0: \"n \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> n", "."], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "define y' where \"y' = (n div (y ^ pm) + y * int pm) div (int p)\""], ["proof (state)\nthis:\n  y' = (n div y ^ pm + y * int pm) div int p\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "from \\<open>y > 0 \\<or> y = 0\\<close> \\<open>n \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 < y \\<or> y = 0\n  0 \\<le> n", "have y'0: \"y' \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < y \\<or> y = 0\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> y'", "by (auto simp add: y'_def p algebra_simps pos_imp_zdiv_nonneg_iff power_0_left)"], ["proof (state)\nthis:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "let ?rt = \"root_newton_int_main\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "from 1(5)"], ["proof (chain)\npicking this:\n  root_newton_int_main y n = (x, b)", "have rt: \"?rt y n = (x,b)\""], ["proof (prove)\nusing this:\n  root_newton_int_main y n = (x, b)\n\ngoal (1 subgoal):\n 1. root_newton_int_main y n = (x, b)", "by auto"], ["proof (state)\nthis:\n  root_newton_int_main y n = (x, b)\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "from y0 n0"], ["proof (chain)\npicking this:\n  0 \\<le> y\n  0 \\<le> n", "have not: \"\\<not> (y < 0 \\<or> n < 0)\" \"(y < 0 \\<or> n < 0) = False\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> (y < 0 \\<or> n < 0) &&& (y < 0 \\<or> n < 0) = False", "by auto"], ["proof (state)\nthis:\n  \\<not> (y < 0 \\<or> n < 0)\n  (y < 0 \\<or> n < 0) = False\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "note rt = rt[unfolded root_newton_int_main.simps[of y n] not(2) if_False, folded y'_def]"], ["proof (state)\nthis:\n  (if y ^ p \\<le> n then (y, y ^ p = n) else root_newton_int_main y' n) =\n  (x, b)\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "note IH = 1(1)[folded y'_def, OF not(1) _ _ y'0 n0]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> y ^ p \\<le> n; n \\<le> y' ^ p;\n   root_newton_int_main y' n = (x, b)\\<rbrakk>\n  \\<Longrightarrow> n < (x + 1) ^ p\n\ngoal (1 subgoal):\n 1. \\<And>xa n.\n       \\<lbrakk>\\<lbrakk>\\<not> (xa < 0 \\<or> n < 0); \\<not> xa ^ p \\<le> n;\n                 n \\<le> ((n div xa ^ pm + xa * int pm) div int p) ^ p;\n                 0 \\<le> (n div xa ^ pm + xa * int pm) div int p; 0 \\<le> n;\n                 root_newton_int_main\n                  ((n div xa ^ pm + xa * int pm) div int p) n =\n                 (x, b)\\<rbrakk>\n                \\<Longrightarrow> n < (x + 1) ^ p;\n        n \\<le> xa ^ p; 0 \\<le> xa; 0 \\<le> n;\n        root_newton_int_main xa n = (x, b)\\<rbrakk>\n       \\<Longrightarrow> n < (x + 1) ^ p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "proof (cases \"y ^ p \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "case False"], ["proof (state)\nthis:\n  \\<not> y ^ p \\<le> n\n\ngoal (2 subgoals):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "note yyn = this"], ["proof (state)\nthis:\n  \\<not> y ^ p \\<le> n\n\ngoal (2 subgoals):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "with rt"], ["proof (chain)\npicking this:\n  (if y ^ p \\<le> n then (y, y ^ p = n) else root_newton_int_main y' n) =\n  (x, b)\n  \\<not> y ^ p \\<le> n", "have rt: \"?rt y' n = (x,b)\""], ["proof (prove)\nusing this:\n  (if y ^ p \\<le> n then (y, y ^ p = n) else root_newton_int_main y' n) =\n  (x, b)\n  \\<not> y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. root_newton_int_main y' n = (x, b)", "by simp"], ["proof (state)\nthis:\n  root_newton_int_main y' n = (x, b)\n\ngoal (2 subgoals):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "proof (cases \"n \\<le> y' ^ p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "case True"], ["proof (state)\nthis:\n  n \\<le> y' ^ p\n\ngoal (2 subgoals):\n 1. n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p\n 2. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "by (rule IH[OF False True rt])"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "case False"], ["proof (state)\nthis:\n  \\<not> n \\<le> y' ^ p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "with rt"], ["proof (chain)\npicking this:\n  root_newton_int_main y' n = (x, b)\n  \\<not> n \\<le> y' ^ p", "have x: \"x = y'\""], ["proof (prove)\nusing this:\n  root_newton_int_main y' n = (x, b)\n  \\<not> n \\<le> y' ^ p\n\ngoal (1 subgoal):\n 1. x = y'", "unfolding root_newton_int_main.simps[of y' n]"], ["proof (prove)\nusing this:\n  (if y' < 0 \\<or> n < 0 then (0, False)\n   else if y' ^ p \\<le> n then (y', y' ^ p = n)\n        else root_newton_int_main ((n div y' ^ pm + y' * int pm) div int p)\n              n) =\n  (x, b)\n  \\<not> n \\<le> y' ^ p\n\ngoal (1 subgoal):\n 1. x = y'", "using n0 y'0"], ["proof (prove)\nusing this:\n  (if y' < 0 \\<or> n < 0 then (0, False)\n   else if y' ^ p \\<le> n then (y', y' ^ p = n)\n        else root_newton_int_main ((n div y' ^ pm + y' * int pm) div int p)\n              n) =\n  (x, b)\n  \\<not> n \\<le> y' ^ p\n  0 \\<le> n\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. x = y'", "by simp"], ["proof (state)\nthis:\n  x = y'\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "from yyn"], ["proof (chain)\npicking this:\n  \\<not> y ^ p \\<le> n", "have yyn: \"y^p > n\""], ["proof (prove)\nusing this:\n  \\<not> y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. n < y ^ p", "by simp"], ["proof (state)\nthis:\n  n < y ^ p\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "from False"], ["proof (chain)\npicking this:\n  \\<not> n \\<le> y' ^ p", "have yyn': \"n > y' ^ p\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> y' ^ p\n\ngoal (1 subgoal):\n 1. y' ^ p < n", "by auto"], ["proof (state)\nthis:\n  y' ^ p < n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "{"], ["proof (state)\nthis:\n  y' ^ p < n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "assume pm: \"pm = 0\""], ["proof (state)\nthis:\n  pm = 0\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "have y': \"y' = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y' = n", "unfolding y'_def p pm"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n div y ^ 0 + y * int 0) div int (Suc 0) = n", "by simp"], ["proof (state)\nthis:\n  y' = n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "with yyn'"], ["proof (chain)\npicking this:\n  y' ^ p < n\n  y' = n", "have False"], ["proof (prove)\nusing this:\n  y' ^ p < n\n  y' = n\n\ngoal (1 subgoal):\n 1. False", "unfolding p pm"], ["proof (prove)\nusing this:\n  y' ^ Suc 0 < n\n  y' = n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "}"], ["proof (state)\nthis:\n  pm = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "hence pm0: \"pm > 0\""], ["proof (prove)\nusing this:\n  pm = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < pm", "by auto"], ["proof (state)\nthis:\n  0 < pm\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> y' ^ p \\<Longrightarrow> n < (x + 1) ^ p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> n < (x + 1) ^ p\n 2. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> n < (x + 1) ^ p\n 2. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "unfolding p"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. n < (x + 1) ^ Suc pm", "by (metis False y'0 zero_le_power)"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "note n00 = this"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "let ?y = \"of_int y :: real\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "let ?n = \"of_int n :: real\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "from yyn n0"], ["proof (chain)\npicking this:\n  n < y ^ p\n  0 \\<le> n", "have y00: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n < y ^ p\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "unfolding p"], ["proof (prove)\nusing this:\n  n < y ^ Suc pm\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "from y00 y0"], ["proof (chain)\npicking this:\n  y \\<noteq> 0\n  0 \\<le> y", "have y0: \"?y > 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 < real_of_int y", "by auto"], ["proof (state)\nthis:\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "from n0 False"], ["proof (chain)\npicking this:\n  0 \\<le> n\n  n \\<noteq> 0", "have n0: \"?n > 0\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real_of_int n", "by auto"], ["proof (state)\nthis:\n  0 < real_of_int n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "define Y where \"Y = ?y * of_int pm\""], ["proof (state)\nthis:\n  Y = real_of_int y * real_of_int (int pm)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "define NY where \"NY = ?n / ?y ^ pm\""], ["proof (state)\nthis:\n  NY = real_of_int n / real_of_int y ^ pm\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "note pos_intro = divide_nonneg_pos add_nonneg_nonneg mult_nonneg_nonneg"], ["proof (state)\nthis:\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) < ?y\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?x / ?y\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?a + ?b\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?a * ?b\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have NY0: \"NY > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < NY", "unfolding NY_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real_of_int n / real_of_int y ^ pm", "using y0 n0"], ["proof (prove)\nusing this:\n  0 < real_of_int y\n  0 < real_of_int n\n\ngoal (1 subgoal):\n 1. 0 < real_of_int n / real_of_int y ^ pm", "by (metis NY_def zero_less_divide_iff zero_less_power)"], ["proof (state)\nthis:\n  0 < NY\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "let ?ls = \"NY # replicate pm ?y\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have prod: \"\\<Prod>:replicate pm ?y = ?y ^ pm \""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (replicate pm (real_of_int y)) = real_of_int y ^ pm", "by (induct pm, auto)"], ["proof (state)\nthis:\n  prod_list (replicate pm (real_of_int y)) = real_of_int y ^ pm\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have sum: \"\\<Sum>:replicate pm ?y = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate pm (real_of_int y)) = Y", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (replicate pm (real_of_int y)) =\n    real_of_int y * real_of_int (int pm)", "by (induct pm, auto simp: field_simps)"], ["proof (state)\nthis:\n  sum_list (replicate pm (real_of_int y)) = Y\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have pos: \"pos ?ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos (NY # replicate pm (real_of_int y))", "unfolding pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if NY # replicate pm (real_of_int y) = [] then False\n    else \\<forall>e.\n            e \\<in> set (NY #\n                         replicate pm (real_of_int y)) \\<longrightarrow>\n            0 < e", "using NY0 y0"], ["proof (prove)\nusing this:\n  0 < NY\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. if NY # replicate pm (real_of_int y) = [] then False\n    else \\<forall>e.\n            e \\<in> set (NY #\n                         replicate pm (real_of_int y)) \\<longrightarrow>\n            0 < e", "by auto"], ["proof (state)\nthis:\n  pos (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"root p ?n = gmean ?ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int n) = gmean (NY # replicate pm (real_of_int y))", "unfolding gmean_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int n) =\n    root (length (NY # replicate pm (real_of_int y)))\n     (prod_list (NY # replicate pm (real_of_int y)))", "using y0"], ["proof (prove)\nusing this:\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. root p (real_of_int n) =\n    root (length (NY # replicate pm (real_of_int y)))\n     (prod_list (NY # replicate pm (real_of_int y)))", "by (auto simp: p NY_def prod)"], ["proof (state)\nthis:\n  root p (real_of_int n) = gmean (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "also"], ["proof (state)\nthis:\n  root p (real_of_int n) = gmean (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"\\<dots> < mean ?ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gmean (NY # replicate pm (real_of_int y))\n    < mean (NY # replicate pm (real_of_int y))", "proof (rule CauchysMeanTheorem_Less[OF pos het_gt_0I])"], ["proof (state)\ngoal (3 subgoals):\n 1. ?a1 \\<in> set (NY # replicate pm (real_of_int y))\n 2. ?b1 \\<in> set (NY # replicate pm (real_of_int y))\n 3. ?a1 \\<noteq> ?b1", "show \"NY \\<in> set ?ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NY \\<in> set (NY # replicate pm (real_of_int y))", "by simp"], ["proof (state)\nthis:\n  NY \\<in> set (NY # replicate pm (real_of_int y))\n\ngoal (2 subgoals):\n 1. ?b1 \\<in> set (NY # replicate pm (real_of_int y))\n 2. NY \\<noteq> ?b1", "from pm0"], ["proof (chain)\npicking this:\n  0 < pm", "show \"?y \\<in> set ?ls\""], ["proof (prove)\nusing this:\n  0 < pm\n\ngoal (1 subgoal):\n 1. real_of_int y \\<in> set (NY # replicate pm (real_of_int y))", "by simp"], ["proof (state)\nthis:\n  real_of_int y \\<in> set (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. NY \\<noteq> real_of_int y", "have \"NY < ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NY < real_of_int y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NY < real_of_int y", "from yyn"], ["proof (chain)\npicking this:\n  n < y ^ p", "have less: \"?n < ?y ^ Suc pm\""], ["proof (prove)\nusing this:\n  n < y ^ p\n\ngoal (1 subgoal):\n 1. real_of_int n < real_of_int y ^ Suc pm", "unfolding p"], ["proof (prove)\nusing this:\n  n < y ^ Suc pm\n\ngoal (1 subgoal):\n 1. real_of_int n < real_of_int y ^ Suc pm", "by (metis of_int_less_iff of_int_power)"], ["proof (state)\nthis:\n  real_of_int n < real_of_int y ^ Suc pm\n\ngoal (1 subgoal):\n 1. NY < real_of_int y", "have \"NY < ?y ^ Suc pm / ?y ^ pm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NY < real_of_int y ^ Suc pm / real_of_int y ^ pm", "unfolding NY_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n / real_of_int y ^ pm\n    < real_of_int y ^ Suc pm / real_of_int y ^ pm", "by (rule divide_strict_right_mono[OF less], insert y0, auto)"], ["proof (state)\nthis:\n  NY < real_of_int y ^ Suc pm / real_of_int y ^ pm\n\ngoal (1 subgoal):\n 1. NY < real_of_int y", "thus ?thesis"], ["proof (prove)\nusing this:\n  NY < real_of_int y ^ Suc pm / real_of_int y ^ pm\n\ngoal (1 subgoal):\n 1. NY < real_of_int y", "using y0"], ["proof (prove)\nusing this:\n  NY < real_of_int y ^ Suc pm / real_of_int y ^ pm\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. NY < real_of_int y", "by auto"], ["proof (state)\nthis:\n  NY < real_of_int y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NY < real_of_int y\n\ngoal (1 subgoal):\n 1. NY \\<noteq> real_of_int y", "thus \"NY \\<noteq> ?y\""], ["proof (prove)\nusing this:\n  NY < real_of_int y\n\ngoal (1 subgoal):\n 1. NY \\<noteq> real_of_int y", "by blast"], ["proof (state)\nthis:\n  NY \\<noteq> real_of_int y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gmean (NY # replicate pm (real_of_int y))\n  < mean (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "also"], ["proof (state)\nthis:\n  gmean (NY # replicate pm (real_of_int y))\n  < mean (NY # replicate pm (real_of_int y))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"\\<dots> = (NY + Y) / real p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mean (NY # replicate pm (real_of_int y)) = (NY + Y) / real p", "by (simp add: mean_def sum p)"], ["proof (state)\nthis:\n  mean (NY # replicate pm (real_of_int y)) = (NY + Y) / real p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "finally"], ["proof (chain)\npicking this:\n  root p (real_of_int n) < (NY + Y) / real p", "have *: \"root p ?n < (NY + Y) / real p\""], ["proof (prove)\nusing this:\n  root p (real_of_int n) < (NY + Y) / real p\n\ngoal (1 subgoal):\n 1. root p (real_of_int n) < (NY + Y) / real p", "."], ["proof (state)\nthis:\n  root p (real_of_int n) < (NY + Y) / real p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"?n = (root p ?n)^p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n = root p (real_of_int n) ^ p", "using n0"], ["proof (prove)\nusing this:\n  0 < real_of_int n\n\ngoal (1 subgoal):\n 1. real_of_int n = root p (real_of_int n) ^ p", "by (metis neq0_conv p0 real_root_pow_pos)"], ["proof (state)\nthis:\n  real_of_int n = root p (real_of_int n) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "also"], ["proof (state)\nthis:\n  real_of_int n = root p (real_of_int n) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"\\<dots> < ((NY + Y) / real p)^p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int n) ^ p < ((NY + Y) / real p) ^ p", "by (rule power_strict_mono[OF *], insert n0 p, auto)"], ["proof (state)\nthis:\n  root p (real_of_int n) ^ p < ((NY + Y) / real p) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "finally"], ["proof (chain)\npicking this:\n  real_of_int n < ((NY + Y) / real p) ^ p", "have ineq1: \"?n < ((NY + Y) / real p)^p\""], ["proof (prove)\nusing this:\n  real_of_int n < ((NY + Y) / real p) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int n < ((NY + Y) / real p) ^ p", "by auto"], ["proof (state)\nthis:\n  real_of_int n < ((NY + Y) / real p) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "{"], ["proof (state)\nthis:\n  real_of_int n < ((NY + Y) / real p) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "define s where \"s = n div y ^ pm + y * int pm\""], ["proof (state)\nthis:\n  s = n div y ^ pm + y * int pm\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "define S where \"S = NY + Y\""], ["proof (state)\nthis:\n  S = NY + Y\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have Y0: \"Y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Y", "using y0"], ["proof (prove)\nusing this:\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. 0 \\<le> Y", "unfolding Y_def"], ["proof (prove)\nusing this:\n  0 < real_of_int y\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int y * real_of_int (int pm)", "by (metis \"1.prems\"(2) mult_nonneg_nonneg of_int_0_le_iff of_nat_0_le_iff)"], ["proof (state)\nthis:\n  0 \\<le> Y\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have S0: \"S > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < S", "using NY0 Y0"], ["proof (prove)\nusing this:\n  0 < NY\n  0 \\<le> Y\n\ngoal (1 subgoal):\n 1. 0 < S", "unfolding S_def"], ["proof (prove)\nusing this:\n  0 < NY\n  0 \\<le> Y\n\ngoal (1 subgoal):\n 1. 0 < NY + Y", "by auto"], ["proof (state)\nthis:\n  0 < S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "from p"], ["proof (chain)\npicking this:\n  p = Suc pm", "have p0: \"p > 0\""], ["proof (prove)\nusing this:\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"?n / ?y ^ pm  < of_int (floor (?n / ?y^pm)) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n / real_of_int y ^ pm\n    < real_of_int \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> + 1", "by (rule divide_less_floor1)"], ["proof (state)\nthis:\n  real_of_int n / real_of_int y ^ pm\n  < real_of_int \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "also"], ["proof (state)\nthis:\n  real_of_int n / real_of_int y ^ pm\n  < real_of_int \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"floor (?n / ?y ^ pm) = n div y^pm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> = n div y ^ pm", "unfolding div_is_floor_divide_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> =\n    \\<lfloor>real_of_int n / real_of_int (y ^ pm)\\<rfloor>", "by (metis of_int_power)"], ["proof (state)\nthis:\n  \\<lfloor>real_of_int n / real_of_int y ^ pm\\<rfloor> = n div y ^ pm\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "finally"], ["proof (chain)\npicking this:\n  real_of_int n / real_of_int y ^ pm < real_of_int (n div y ^ pm) + 1", "have \"NY < of_int (n div y ^ pm) + 1\""], ["proof (prove)\nusing this:\n  real_of_int n / real_of_int y ^ pm < real_of_int (n div y ^ pm) + 1\n\ngoal (1 subgoal):\n 1. NY < real_of_int (n div y ^ pm) + 1", "unfolding NY_def"], ["proof (prove)\nusing this:\n  real_of_int n / real_of_int y ^ pm < real_of_int (n div y ^ pm) + 1\n\ngoal (1 subgoal):\n 1. real_of_int n / real_of_int y ^ pm < real_of_int (n div y ^ pm) + 1", "by simp"], ["proof (state)\nthis:\n  NY < real_of_int (n div y ^ pm) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence less: \"S < of_int s + 1\""], ["proof (prove)\nusing this:\n  NY < real_of_int (n div y ^ pm) + 1\n\ngoal (1 subgoal):\n 1. S < real_of_int s + 1", "unfolding Y_def s_def S_def"], ["proof (prove)\nusing this:\n  NY < real_of_int (n div y ^ pm) + 1\n\ngoal (1 subgoal):\n 1. NY + real_of_int y * real_of_int (int pm)\n    < real_of_int (n div y ^ pm + y * int pm) + 1", "by simp"], ["proof (state)\nthis:\n  S < real_of_int s + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "{"], ["proof (state)\nthis:\n  S < real_of_int s + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "(* by sledgehammer *)"], ["proof (state)\nthis:\n  S < real_of_int s + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have f1: \"\\<forall>x\\<^sub>0. rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = rat_of_nat x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n       rat_of_nat x\\<^sub>0", "using of_int_of_nat_eq"], ["proof (prove)\nusing this:\n  of_int (int ?n) = of_nat ?n\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n       rat_of_nat x\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0.\n     rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n     rat_of_nat x\\<^sub>0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have f2: \"\\<forall>x\\<^sub>0. real_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = real x\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       real_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = real x\\<^sub>0", "using of_int_of_nat_eq"], ["proof (prove)\nusing this:\n  of_int (int ?n) = of_nat ?n\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0.\n       real_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = real x\\<^sub>0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0.\n     real_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = real x\\<^sub>0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have f3: \"\\<forall>x\\<^sub>0 x\\<^sub>1. \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> = \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0 x\\<^sub>1.\n       \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n       \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>", "using div_is_floor_divide_rat div_is_floor_divide_real"], ["proof (prove)\nusing this:\n  ?n div ?y = \\<lfloor>rat_of_int ?n / rat_of_int ?y\\<rfloor>\n  ?n div ?y = \\<lfloor>real_of_int ?n / real_of_int ?y\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<^sub>0 x\\<^sub>1.\n       \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n       \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<^sub>0 x\\<^sub>1.\n     \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n     \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have f4: \"0 < \\<lfloor>rat_of_nat p\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<lfloor>rat_of_nat p\\<rfloor>", "using p"], ["proof (prove)\nusing this:\n  p = Suc pm\n\ngoal (1 subgoal):\n 1. 0 < \\<lfloor>rat_of_nat p\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  0 < \\<lfloor>rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have \"\\<lfloor>S\\<rfloor> \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>S\\<rfloor> \\<le> s", "using less floor_le_iff"], ["proof (prove)\nusing this:\n  S < real_of_int s + 1\n  (\\<lfloor>?x\\<rfloor> \\<le> ?z) = (?x < of_int ?z + (1::?'a))\n\ngoal (1 subgoal):\n 1. \\<lfloor>S\\<rfloor> \\<le> s", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>S\\<rfloor> \\<le> s\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence \"\\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor> \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<lfloor>S\\<rfloor> \\<le> s\n\ngoal (1 subgoal):\n 1. \\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor>\n    \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>", "using f1 f3 f4"], ["proof (prove)\nusing this:\n  \\<lfloor>S\\<rfloor> \\<le> s\n  \\<forall>x\\<^sub>0.\n     rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n     rat_of_nat x\\<^sub>0\n  \\<forall>x\\<^sub>0 x\\<^sub>1.\n     \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n     \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>\n  0 < \\<lfloor>rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor>\n    \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>", "by (metis div_is_floor_divide_real zdiv_mono1)"], ["proof (state)\nthis:\n  \\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence \"\\<lfloor>S / real p\\<rfloor> \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\""], ["proof (prove)\nusing this:\n  \\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>S / real p\\<rfloor>\n    \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>", "using f1 f2 f3 f4"], ["proof (prove)\nusing this:\n  \\<lfloor>rat_of_int \\<lfloor>S\\<rfloor> / rat_of_nat p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n  \\<forall>x\\<^sub>0.\n     rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n     rat_of_nat x\\<^sub>0\n  \\<forall>x\\<^sub>0.\n     real_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> = real x\\<^sub>0\n  \\<forall>x\\<^sub>0 x\\<^sub>1.\n     \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n     \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>\n  0 < \\<lfloor>rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>S / real p\\<rfloor>\n    \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>", "by (metis div_is_floor_divide_real floor_div_pos_int)"], ["proof (state)\nthis:\n  \\<lfloor>S / real p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence \"S / real p \\<le> real_of_int (s div int p) + 1\""], ["proof (prove)\nusing this:\n  \\<lfloor>S / real p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n\ngoal (1 subgoal):\n 1. S / real p \\<le> real_of_int (s div int p) + 1", "using f1 f3"], ["proof (prove)\nusing this:\n  \\<lfloor>S / real p\\<rfloor>\n  \\<le> \\<lfloor>rat_of_int s / rat_of_nat p\\<rfloor>\n  \\<forall>x\\<^sub>0.\n     rat_of_int \\<lfloor>rat_of_nat x\\<^sub>0\\<rfloor> =\n     rat_of_nat x\\<^sub>0\n  \\<forall>x\\<^sub>0 x\\<^sub>1.\n     \\<lfloor>rat_of_int x\\<^sub>0 / rat_of_int x\\<^sub>1\\<rfloor> =\n     \\<lfloor>real_of_int x\\<^sub>0 / real_of_int x\\<^sub>1\\<rfloor>\n\ngoal (1 subgoal):\n 1. S / real p \\<le> real_of_int (s div int p) + 1", "by (metis div_is_floor_divide_real floor_le_iff floor_of_nat less_eq_real_def)"], ["proof (state)\nthis:\n  S / real p \\<le> real_of_int (s div int p) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "}"], ["proof (state)\nthis:\n  S / real p \\<le> real_of_int (s div int p) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence \"S / real p \\<le> of_int(s div p) + 1\""], ["proof (prove)\nusing this:\n  S / real p \\<le> real_of_int (s div int p) + 1\n\ngoal (1 subgoal):\n 1. S / real p \\<le> real_of_int (s div int p) + 1", "."], ["proof (state)\nthis:\n  S / real p \\<le> real_of_int (s div int p) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "note this[unfolded S_def s_def]"], ["proof (state)\nthis:\n  (NY + Y) / real p\n  \\<le> real_of_int ((n div y ^ pm + y * int pm) div int p) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "}"], ["proof (state)\nthis:\n  (NY + Y) / real p\n  \\<le> real_of_int ((n div y ^ pm + y * int pm) div int p) + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "hence ge: \"of_int y' + 1 \\<ge> (NY + Y) / p\""], ["proof (prove)\nusing this:\n  (NY + Y) / real p\n  \\<le> real_of_int ((n div y ^ pm + y * int pm) div int p) + 1\n\ngoal (1 subgoal):\n 1. (NY + Y) / real p \\<le> real_of_int y' + 1", "unfolding y'_def"], ["proof (prove)\nusing this:\n  (NY + Y) / real p\n  \\<le> real_of_int ((n div y ^ pm + y * int pm) div int p) + 1\n\ngoal (1 subgoal):\n 1. (NY + Y) / real p\n    \\<le> real_of_int ((n div y ^ pm + y * int pm) div int p) + 1", "by simp"], ["proof (state)\nthis:\n  (NY + Y) / real p \\<le> real_of_int y' + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have pos1: \"(NY + Y) / p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (NY + Y) / real p", "unfolding Y_def NY_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (real_of_int n / real_of_int y ^ pm +\n             real_of_int y * real_of_int (int pm)) /\n            real p", "by (intro divide_nonneg_pos add_nonneg_nonneg mult_nonneg_nonneg,\n          insert y0 n0 p0, auto)"], ["proof (state)\nthis:\n  0 \\<le> (NY + Y) / real p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have pos2: \"of_int y' + (1 :: rat) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> rat_of_int y' + 1", "using y'0"], ["proof (prove)\nusing this:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. 0 \\<le> rat_of_int y' + 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> rat_of_int y' + 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "have ineq2: \"(of_int y' + 1) ^ p \\<ge> ((NY + Y) / p) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((NY + Y) / real p) ^ p \\<le> (real_of_int y' + 1) ^ p", "by (rule power_mono[OF ge pos1])"], ["proof (state)\nthis:\n  ((NY + Y) / real p) ^ p \\<le> (real_of_int y' + 1) ^ p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "from order.strict_trans2[OF ineq1 ineq2]"], ["proof (chain)\npicking this:\n  real_of_int n < (real_of_int y' + 1) ^ p", "have \"?n < of_int ((x + 1) ^ p)\""], ["proof (prove)\nusing this:\n  real_of_int n < (real_of_int y' + 1) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int n < real_of_int ((x + 1) ^ p)", "unfolding x"], ["proof (prove)\nusing this:\n  real_of_int n < (real_of_int y' + 1) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int n < real_of_int ((y' + 1) ^ p)", "by (metis of_int_1 of_int_add of_int_power)"], ["proof (state)\nthis:\n  real_of_int n < real_of_int ((x + 1) ^ p)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> n < (x + 1) ^ p", "thus \"n < (x + 1) ^ p\""], ["proof (prove)\nusing this:\n  real_of_int n < real_of_int ((x + 1) ^ p)\n\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "using of_int_less_iff"], ["proof (prove)\nusing this:\n  real_of_int n < real_of_int ((x + 1) ^ p)\n  (of_int ?w < of_int ?z) = (?w < ?z)\n\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "by blast"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "case True"], ["proof (state)\nthis:\n  y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "with rt"], ["proof (chain)\npicking this:\n  (if y ^ p \\<le> n then (y, y ^ p = n) else root_newton_int_main y' n) =\n  (x, b)\n  y ^ p \\<le> n", "have x: \"x = y\""], ["proof (prove)\nusing this:\n  (if y ^ p \\<le> n then (y, y ^ p = n) else root_newton_int_main y' n) =\n  (x, b)\n  y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "with 1(2) True"], ["proof (chain)\npicking this:\n  n \\<le> y ^ p\n  y ^ p \\<le> n\n  x = y", "have n: \"n = y ^ p\""], ["proof (prove)\nusing this:\n  n \\<le> y ^ p\n  y ^ p \\<le> n\n  x = y\n\ngoal (1 subgoal):\n 1. n = y ^ p", "by auto"], ["proof (state)\nthis:\n  n = y ^ p\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> n \\<Longrightarrow> n < (x + 1) ^ p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (x + 1) ^ p", "unfolding n x"], ["proof (prove)\ngoal (1 subgoal):\n 1. y ^ p < (y + 1) ^ p", "using y0"], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. y ^ p < (y + 1) ^ p", "unfolding p"], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. y ^ Suc pm < (y + 1) ^ Suc pm", "by (metis add_le_less_mono add_less_cancel_left lessI less_add_one add.right_neutral le_iff_add power_strict_mono)"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < (x + 1) ^ p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_main'_upper:\n  \"x ^ p \\<ge> n \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> n \\<ge> 0 \\<Longrightarrow> root_main' x n = (y,b) \\<Longrightarrow> n < (y + 1) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> x ^ p; 0 \\<le> x; 0 \\<le> n;\n     root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> n < (y + 1) ^ p", "using root_newton_int_main_upper[of n x y b] root_main'[of x n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<le> x ^ p; 0 \\<le> x; 0 \\<le> n;\n   root_newton_int_main x n = (y, b)\\<rbrakk>\n  \\<Longrightarrow> n < (y + 1) ^ p\n  \\<lbrakk>0 \\<le> x; 0 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> root_main' x n = root_newton_int_main x n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> x ^ p; 0 \\<le> x; 0 \\<le> n;\n     root_main' x n = (y, b)\\<rbrakk>\n    \\<Longrightarrow> n < (y + 1) ^ p", "by auto"], ["", "end"], ["", "text \\<open>Now we can prove all the nice properties of @{const root_int_main}.\\<close>"], ["", "lemma root_int_main_all: assumes n: \"n \\<ge> 0\"\n  and rm: \"root_int_main p n = (y,b)\"\n  shows \"y \\<ge> 0 \\<and> b = (y ^ p = n) \\<and> (p > 0 \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1)^p)\n    \\<and> (p > 0 \\<longrightarrow> x \\<ge> 0 \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "with rm[unfolded root_int_main_def]"], ["proof (chain)\npicking this:\n  (if p = 0 then (1, n = 1)\n   else let pm = p - 1\n        in root_int_main' pm (int pm) (int p) (start_value n p) n) =\n  (y, b)\n  p = 0", "have y: \"y = 1\" and b: \"b = (n = 1)\""], ["proof (prove)\nusing this:\n  (if p = 0 then (1, n = 1)\n   else let pm = p - 1\n        in root_int_main' pm (int pm) (int p) (start_value n p) n) =\n  (y, b)\n  p = 0\n\ngoal (1 subgoal):\n 1. y = 1 &&& b = (n = 1)", "by auto"], ["proof (state)\nthis:\n  y = 1\n  b = (n = 1)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "unfolding True y b"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 \\<and>\n    (n = 1) = (1 ^ 0 = n) \\<and>\n    (0 < 0 \\<longrightarrow> 1 ^ 0 \\<le> n \\<and> n < (1 + 1) ^ 0) \\<and>\n    (0 < 0 \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow>\n     x ^ 0 = n \\<longrightarrow> 1 = x \\<and> n = 1)", "using n"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 \\<and>\n    (n = 1) = (1 ^ 0 = n) \\<and>\n    (0 < 0 \\<longrightarrow> 1 ^ 0 \\<le> n \\<and> n < (1 + 1) ^ 0) \\<and>\n    (0 < 0 \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow>\n     x ^ 0 = n \\<longrightarrow> 1 = x \\<and> n = 1)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> y \\<and>\n  b = (y ^ p = n) \\<and>\n  (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n  (0 < p \\<longrightarrow>\n   0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have p_0: \"p > 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from False"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"(p = 0) = False\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p = 0) = False", "by simp"], ["proof (state)\nthis:\n  (p = 0) = False\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from rm[unfolded root_int_main_def this Let_def]"], ["proof (chain)\npicking this:\n  (if False then (1, n = 1)\n   else root_int_main' (p - 1) (int (p - 1)) (int p) (start_value n p) n) =\n  (y, b)", "have rm: \"root_int_main' (p - 1) (int (p - 1)) (int p) (start_value n p) n = (y,b)\""], ["proof (prove)\nusing this:\n  (if False then (1, n = 1)\n   else root_int_main' (p - 1) (int (p - 1)) (int p) (start_value n p) n) =\n  (y, b)\n\ngoal (1 subgoal):\n 1. root_int_main' (p - 1) (int (p - 1)) (int p) (start_value n p) n =\n    (y, b)", "by simp"], ["proof (state)\nthis:\n  root_int_main' (p - 1) (int (p - 1)) (int p) (start_value n p) n = (y, b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from start_value[OF n p_0]"], ["proof (chain)\npicking this:\n  n \\<le> start_value n p ^ p\n  0 \\<le> start_value n p", "have start: \"n \\<le> (start_value n p)^p\" \"0 \\<le> start_value n p\""], ["proof (prove)\nusing this:\n  n \\<le> start_value n p ^ p\n  0 \\<le> start_value n p\n\ngoal (1 subgoal):\n 1. n \\<le> start_value n p ^ p &&& 0 \\<le> start_value n p", "by auto"], ["proof (state)\nthis:\n  n \\<le> start_value n p ^ p\n  0 \\<le> start_value n p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "interpret fixed_root p \"p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_root p (p - 1)", "by (unfold_locales, insert False, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from root_main'_pos[OF start(2) n rm]"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have y: \"y \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "."], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from root_main'_sound[OF start(2) n rm]"], ["proof (chain)\npicking this:\n  b = (y ^ p = n)", "have b: \"b = (y ^ p = n)\""], ["proof (prove)\nusing this:\n  b = (y ^ p = n)\n\ngoal (1 subgoal):\n 1. b = (y ^ p = n)", "."], ["proof (state)\nthis:\n  b = (y ^ p = n)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from root_main'_lower[OF start(2) n rm]"], ["proof (chain)\npicking this:\n  y ^ p \\<le> n", "have low: \"y ^ p \\<le> n\""], ["proof (prove)\nusing this:\n  y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> n", "."], ["proof (state)\nthis:\n  y ^ p \\<le> n\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from root_main'_upper[OF start n rm]"], ["proof (chain)\npicking this:\n  n < (y + 1) ^ p", "have up: \"n < (y + 1) ^ p\""], ["proof (prove)\nusing this:\n  n < (y + 1) ^ p\n\ngoal (1 subgoal):\n 1. n < (y + 1) ^ p", "."], ["proof (state)\nthis:\n  n < (y + 1) ^ p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "{"], ["proof (state)\nthis:\n  n < (y + 1) ^ p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "assume n: \"x ^ p = n\" and x: \"x \\<ge> 0\""], ["proof (state)\nthis:\n  x ^ p = n\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "with low up"], ["proof (chain)\npicking this:\n  y ^ p \\<le> n\n  n < (y + 1) ^ p\n  x ^ p = n\n  0 \\<le> x", "have low: \"y ^ p \\<le> x ^ p\" and up: \"x ^ p < (y+1) ^ p\""], ["proof (prove)\nusing this:\n  y ^ p \\<le> n\n  n < (y + 1) ^ p\n  x ^ p = n\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. y ^ p \\<le> x ^ p &&& x ^ p < (y + 1) ^ p", "by auto"], ["proof (state)\nthis:\n  y ^ p \\<le> x ^ p\n  x ^ p < (y + 1) ^ p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from power_strict_mono[of x y, OF _ x p_0] low"], ["proof (chain)\npicking this:\n  x < y \\<Longrightarrow> x ^ p < y ^ p\n  y ^ p \\<le> x ^ p", "have x: \"x \\<ge> y\""], ["proof (prove)\nusing this:\n  x < y \\<Longrightarrow> x ^ p < y ^ p\n  y ^ p \\<le> x ^ p\n\ngoal (1 subgoal):\n 1. y \\<le> x", "by arith"], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from power_mono[of \"(y + 1)\" x p] y up"], ["proof (chain)\npicking this:\n  \\<lbrakk>y + 1 \\<le> x; 0 \\<le> y + 1\\<rbrakk>\n  \\<Longrightarrow> (y + 1) ^ p \\<le> x ^ p\n  0 \\<le> y\n  x ^ p < (y + 1) ^ p", "have y: \"y \\<ge> x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>y + 1 \\<le> x; 0 \\<le> y + 1\\<rbrakk>\n  \\<Longrightarrow> (y + 1) ^ p \\<le> x ^ p\n  0 \\<le> y\n  x ^ p < (y + 1) ^ p\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by arith"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "from x y"], ["proof (chain)\npicking this:\n  y \\<le> x\n  x \\<le> y", "have \"x = y\""], ["proof (prove)\nusing this:\n  y \\<le> x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "with b n"], ["proof (chain)\npicking this:\n  b = (y ^ p = n)\n  x ^ p = n\n  x = y", "have \"y = x \\<and> b\""], ["proof (prove)\nusing this:\n  b = (y ^ p = n)\n  x ^ p = n\n  x = y\n\ngoal (1 subgoal):\n 1. y = x \\<and> b", "by auto"], ["proof (state)\nthis:\n  y = x \\<and> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x ^ p = n; 0 \\<le> x\\<rbrakk> \\<Longrightarrow> y = x \\<and> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x ^ p = n; 0 \\<le> x\\<rbrakk> \\<Longrightarrow> y = x \\<and> b\n\ngoal (1 subgoal):\n 1. 0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "using b low up y"], ["proof (prove)\nusing this:\n  \\<lbrakk>x ^ p = n; 0 \\<le> x\\<rbrakk> \\<Longrightarrow> y = x \\<and> b\n  b = (y ^ p = n)\n  y ^ p \\<le> n\n  n < (y + 1) ^ p\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 \\<le> y \\<and>\n    b = (y ^ p = n) \\<and>\n    (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n    (0 < p \\<longrightarrow>\n     0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> y \\<and>\n  b = (y ^ p = n) \\<and>\n  (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n  (0 < p \\<longrightarrow>\n   0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_int_main: assumes n: \"n \\<ge> 0\"\n  and rm: \"root_int_main p n = (y,b)\"\n  shows \"y \\<ge> 0\" \"b = (y ^ p = n)\" \"p > 0 \\<Longrightarrow> y ^ p \\<le> n\" \"p > 0 \\<Longrightarrow> n < (y + 1)^p\"\n    \"p > 0 \\<Longrightarrow> x \\<ge> 0 \\<Longrightarrow> x ^ p = n \\<Longrightarrow> y = x \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> y &&& b = (y ^ p = n)) &&&\n    (0 < p \\<Longrightarrow> y ^ p \\<le> n) &&&\n    (0 < p \\<Longrightarrow> n < (y + 1) ^ p) &&&\n    (\\<lbrakk>0 < p; 0 \\<le> x; x ^ p = n\\<rbrakk>\n     \\<Longrightarrow> y = x \\<and> b)", "using root_int_main_all[OF n rm, of x]"], ["proof (prove)\nusing this:\n  0 \\<le> y \\<and>\n  b = (y ^ p = n) \\<and>\n  (0 < p \\<longrightarrow> y ^ p \\<le> n \\<and> n < (y + 1) ^ p) \\<and>\n  (0 < p \\<longrightarrow>\n   0 \\<le> x \\<longrightarrow> x ^ p = n \\<longrightarrow> y = x \\<and> b)\n\ngoal (1 subgoal):\n 1. (0 \\<le> y &&& b = (y ^ p = n)) &&&\n    (0 < p \\<Longrightarrow> y ^ p \\<le> n) &&&\n    (0 < p \\<Longrightarrow> n < (y + 1) ^ p) &&&\n    (\\<lbrakk>0 < p; 0 \\<le> x; x ^ p = n\\<rbrakk>\n     \\<Longrightarrow> y = x \\<and> b)", "by blast+"], ["", "lemma root_int[simp]: assumes p: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_int p x) = {y . y ^ p = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "with p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0", "have \"x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "unfolding root_int_def True"], ["proof (prove)\nusing this:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. set (if 0 = 0 then []\n         else if x = 0 then [0]\n              else let e = even 0; s = sgn x; x' = \\<bar>x\\<bar>\n                   in if x < 0 \\<and> e then []\n                      else case root_int_main 0 x' of\n                           (y, True) \\<Rightarrow>\n                             if e then [y, - y] else [s * y]\n                           | (y, False) \\<Rightarrow> []) =\n    {y. y ^ 0 = x}", "by auto"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "hence p: \"(p = 0) = False\" and p0: \"p > 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (p = 0) = False &&& 0 < p", "by auto"], ["proof (state)\nthis:\n  (p = 0) = False\n  0 < p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "note d = root_int_def p if_False Let_def"], ["proof (state)\nthis:\n  root_int ?p ?x \\<equiv>\n  if ?p = 0 then []\n  else if ?x = 0 then [0]\n       else let e = even ?p; s = sgn ?x; x' = \\<bar>?x\\<bar>\n            in if ?x < 0 \\<and> e then []\n               else case root_int_main ?p x' of\n                    (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n                    | (y, False) \\<Rightarrow> []\n  (p = 0) = False\n  (if False then ?x else ?y) = ?y\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}\n 2. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}\n 2. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "unfolding d"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. set (if x = 0 then [0]\n         else if x < 0 \\<and> even p then []\n              else case root_int_main p \\<bar>x\\<bar> of\n                   (y, True) \\<Rightarrow>\n                     if even p then [y, - y] else [sgn x * y]\n                   | (y, False) \\<Rightarrow> []) =\n    {y. y ^ p = x}", "using p0"], ["proof (prove)\nusing this:\n  x = 0\n  0 < p\n\ngoal (1 subgoal):\n 1. set (if x = 0 then [0]\n         else if x < 0 \\<and> even p then []\n              else case root_int_main p \\<bar>x\\<bar> of\n                   (y, True) \\<Rightarrow>\n                     if even p then [y, - y] else [sgn x * y]\n                   | (y, False) \\<Rightarrow> []) =\n    {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "hence x: \"(x = 0) = False\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x = 0) = False", "by auto"], ["proof (state)\nthis:\n  (x = 0) = False\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> set (root_int p x) = {y. y ^ p = x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "proof (cases \"x < 0 \\<and> even p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "case True"], ["proof (state)\nthis:\n  x < 0 \\<and> even p\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "hence left: \"set (root_int p x) = {}\""], ["proof (prove)\nusing this:\n  x < 0 \\<and> even p\n\ngoal (1 subgoal):\n 1. set (root_int p x) = {}", "unfolding d"], ["proof (prove)\nusing this:\n  x < 0 \\<and> even p\n\ngoal (1 subgoal):\n 1. set (if x = 0 then [0]\n         else if x < 0 \\<and> even p then []\n              else case root_int_main p \\<bar>x\\<bar> of\n                   (y, True) \\<Rightarrow>\n                     if even p then [y, - y] else [sgn x * y]\n                   | (y, False) \\<Rightarrow> []) =\n    {}", "by auto"], ["proof (state)\nthis:\n  set (root_int p x) = {}\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  set (root_int p x) = {}\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "assume x: \"y ^ p = x\""], ["proof (state)\nthis:\n  y ^ p = x\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "with True"], ["proof (chain)\npicking this:\n  x < 0 \\<and> even p\n  y ^ p = x", "have \"y ^ p < 0 \\<and> even p\""], ["proof (prove)\nusing this:\n  x < 0 \\<and> even p\n  y ^ p = x\n\ngoal (1 subgoal):\n 1. y ^ p < 0 \\<and> even p", "by auto"], ["proof (state)\nthis:\n  y ^ p < 0 \\<and> even p\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "hence False"], ["proof (prove)\nusing this:\n  y ^ p < 0 \\<and> even p\n\ngoal (1 subgoal):\n 1. False", "by presburger"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?y2 ^ p = x \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. x < 0 \\<and> even p \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}\n 2. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "with left"], ["proof (chain)\npicking this:\n  set (root_int p x) = {}\n  ?y2 ^ p = x \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  set (root_int p x) = {}\n  ?y2 ^ p = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "case False"], ["proof (state)\nthis:\n  \\<not> (x < 0 \\<and> even p)\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "with x p"], ["proof (chain)\npicking this:\n  (x = 0) = False\n  (p = 0) = False\n  \\<not> (x < 0 \\<and> even p)", "have cond: \"(x = 0) = False\" \"(x < 0 \\<and> even p) = False\""], ["proof (prove)\nusing this:\n  (x = 0) = False\n  (p = 0) = False\n  \\<not> (x < 0 \\<and> even p)\n\ngoal (1 subgoal):\n 1. (x = 0) = False &&& (x < 0 \\<and> even p) = False", "by auto"], ["proof (state)\nthis:\n  (x = 0) = False\n  (x < 0 \\<and> even p) = False\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "obtain y b where rt: \"root_int_main p \\<bar>x\\<bar> = (y,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y b.\n        root_int_main p \\<bar>x\\<bar> = (y, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  root_int_main p \\<bar>x\\<bar> = (y, b)\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "have \"abs x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<bar>x\\<bar>", "by auto"], ["proof (state)\nthis:\n  0 \\<le> \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "note rm = root_int_main[OF this rt]"], ["proof (state)\nthis:\n  0 \\<le> y\n  b = (y ^ p = \\<bar>x\\<bar>)\n  0 < p \\<Longrightarrow> y ^ p \\<le> \\<bar>x\\<bar>\n  0 < p \\<Longrightarrow> \\<bar>x\\<bar> < (y + 1) ^ p\n  \\<lbrakk>0 < p; 0 \\<le> ?x; ?x ^ p = \\<bar>x\\<bar>\\<rbrakk>\n  \\<Longrightarrow> y = ?x \\<and> b\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "have \"?thesis =\n        (set (case root_int_main p \\<bar>x\\<bar> of (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y] | (y, False) \\<Rightarrow> []) =\n        {y. y ^ p = x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (root_int p x) = {y. y ^ p = x}) =\n    (set (case root_int_main p \\<bar>x\\<bar> of\n          (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n          | (y, False) \\<Rightarrow> []) =\n     {y. y ^ p = x})", "unfolding d cond"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set (case root_int_main p \\<bar>x\\<bar> of\n          (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n          | (y, False) \\<Rightarrow> []) =\n     {y. y ^ p = x}) =\n    (set (case root_int_main p \\<bar>x\\<bar> of\n          (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n          | (y, False) \\<Rightarrow> []) =\n     {y. y ^ p = x})", "by blast"], ["proof (state)\nthis:\n  (set (root_int p x) = {y. y ^ p = x}) =\n  (set (case root_int_main p \\<bar>x\\<bar> of\n        (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n        | (y, False) \\<Rightarrow> []) =\n   {y. y ^ p = x})\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  (set (root_int p x) = {y. y ^ p = x}) =\n  (set (case root_int_main p \\<bar>x\\<bar> of\n        (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n        | (y, False) \\<Rightarrow> []) =\n   {y. y ^ p = x})\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "have \"(case root_int_main p \\<bar>x\\<bar> of (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y] | (y, False) \\<Rightarrow> [])\n        = (if b then if even p then [y, - y] else [sgn x * y] else [])\" (is \"_ = ?lhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case root_int_main p \\<bar>x\\<bar> of\n     (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n     | (y, False) \\<Rightarrow> []) =\n    (if b then if even p then [y, - y] else [sgn x * y] else [])", "unfolding rt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (y, b) of\n     (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n     | (y, False) \\<Rightarrow> []) =\n    (if b then if even p then [y, - y] else [sgn x * y] else [])", "by auto"], ["proof (state)\nthis:\n  (case root_int_main p \\<bar>x\\<bar> of\n   (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n   | (y, False) \\<Rightarrow> []) =\n  (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  (case root_int_main p \\<bar>x\\<bar> of\n   (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n   | (y, False) \\<Rightarrow> []) =\n  (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "have \"set ?lhs = {y. y ^ p = x}\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "assume idx: \"z ^ p = x\""], ["proof (state)\nthis:\n  z ^ p = x\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "hence eq: \"(abs z) ^ p = abs x\""], ["proof (prove)\nusing this:\n  z ^ p = x\n\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> ^ p = \\<bar>x\\<bar>", "by (metis power_abs)"], ["proof (state)\nthis:\n  \\<bar>z\\<bar> ^ p = \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "from idx x p0"], ["proof (chain)\npicking this:\n  z ^ p = x\n  (x = 0) = False\n  0 < p", "have z: \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z ^ p = x\n  (x = 0) = False\n  0 < p\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "unfolding p"], ["proof (prove)\nusing this:\n  z ^ p = x\n  (x = 0) = False\n  0 < p\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "have \"(y, b) = (\\<bar>z\\<bar>, True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, b) = (\\<bar>z\\<bar>, True)", "using rm(5)[OF p0 _ eq]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<bar>z\\<bar> \\<Longrightarrow> y = \\<bar>z\\<bar> \\<and> b\n\ngoal (1 subgoal):\n 1. (y, b) = (\\<bar>z\\<bar>, True)", "by auto"], ["proof (state)\nthis:\n  (y, b) = (\\<bar>z\\<bar>, True)\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "hence id: \"y = abs z\" \"b = True\""], ["proof (prove)\nusing this:\n  (y, b) = (\\<bar>z\\<bar>, True)\n\ngoal (1 subgoal):\n 1. y = \\<bar>z\\<bar> &&& b = True", "by auto"], ["proof (state)\nthis:\n  y = \\<bar>z\\<bar>\n  b = True\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "have \"z \\<in> set ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (if True\n                 then if even p then [\\<bar>z\\<bar>, - \\<bar>z\\<bar>]\n                      else [sgn x * \\<bar>z\\<bar>]\n                 else [])", "using z"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<in> set (if True\n                 then if even p then [\\<bar>z\\<bar>, - \\<bar>z\\<bar>]\n                      else [sgn x * \\<bar>z\\<bar>]\n                 else [])", "by (auto simp: idx[symmetric], cases \"z < 0\", auto)"], ["proof (state)\nthis:\n  z \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?z2 ^ p = x \\<Longrightarrow>\n  ?z2 \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "moreover"], ["proof (state)\nthis:\n  ?z2 ^ p = x \\<Longrightarrow>\n  ?z2 \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  ?z2 ^ p = x \\<Longrightarrow>\n  ?z2 \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "assume z: \"z \\<in> set ?lhs\""], ["proof (state)\nthis:\n  z \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "hence b: \"b = True\""], ["proof (prove)\nusing this:\n  z \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n\ngoal (1 subgoal):\n 1. b = True", "by (cases b, auto)"], ["proof (state)\nthis:\n  b = True\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "note z = z[unfolded b if_True]"], ["proof (state)\nthis:\n  z \\<in> set (if even p then [y, - y] else [sgn x * y])\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "from rm(2) b"], ["proof (chain)\npicking this:\n  b = (y ^ p = \\<bar>x\\<bar>)\n  b = True", "have yx: \"y ^ p = \\<bar>x\\<bar>\""], ["proof (prove)\nusing this:\n  b = (y ^ p = \\<bar>x\\<bar>)\n  b = True\n\ngoal (1 subgoal):\n 1. y ^ p = \\<bar>x\\<bar>", "by auto"], ["proof (state)\nthis:\n  y ^ p = \\<bar>x\\<bar>\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "from rm(1)"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have y: \"y \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "."], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "from False"], ["proof (chain)\npicking this:\n  \\<not> (x < 0 \\<and> even p)", "have \"odd p \\<or> even p \\<and> x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> (x < 0 \\<and> even p)\n\ngoal (1 subgoal):\n 1. odd p \\<or> even p \\<and> 0 \\<le> x", "by auto"], ["proof (state)\nthis:\n  odd p \\<or> even p \\<and> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "hence \"z \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  odd p \\<or> even p \\<and> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. z \\<in> {y. y ^ p = x}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "assume odd: \"odd p\""], ["proof (state)\nthis:\n  odd p\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "with z"], ["proof (chain)\npicking this:\n  z \\<in> set (if even p then [y, - y] else [sgn x * y])\n  odd p", "have \"z = sgn x * y\""], ["proof (prove)\nusing this:\n  z \\<in> set (if even p then [y, - y] else [sgn x * y])\n  odd p\n\ngoal (1 subgoal):\n 1. z = sgn x * y", "by auto"], ["proof (state)\nthis:\n  z = sgn x * y\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "hence \"z ^ p = (sgn x * y) ^ p\""], ["proof (prove)\nusing this:\n  z = sgn x * y\n\ngoal (1 subgoal):\n 1. z ^ p = (sgn x * y) ^ p", "by auto"], ["proof (state)\nthis:\n  z ^ p = (sgn x * y) ^ p\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  z ^ p = (sgn x * y) ^ p\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"\\<dots> = sgn x ^ p * y ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn x * y) ^ p = sgn x ^ p * y ^ p", "unfolding power_mult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x ^ p * y ^ p = sgn x ^ p * y ^ p", "by auto"], ["proof (state)\nthis:\n  (sgn x * y) ^ p = sgn x ^ p * y ^ p\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  (sgn x * y) ^ p = sgn x ^ p * y ^ p\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"\\<dots> = sgn x ^ p * abs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x ^ p * y ^ p = sgn x ^ p * \\<bar>x\\<bar>", "unfolding yx"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x ^ p * \\<bar>x\\<bar> = sgn x ^ p * \\<bar>x\\<bar>", "by simp"], ["proof (state)\nthis:\n  sgn x ^ p * y ^ p = sgn x ^ p * \\<bar>x\\<bar>\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  sgn x ^ p * y ^ p = sgn x ^ p * \\<bar>x\\<bar>\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"sgn x ^ p = sgn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x ^ p = sgn x", "using x odd"], ["proof (prove)\nusing this:\n  (x = 0) = False\n  odd p\n\ngoal (1 subgoal):\n 1. sgn x ^ p = sgn x", "by auto"], ["proof (state)\nthis:\n  sgn x ^ p = sgn x\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  sgn x ^ p = sgn x\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"sgn x * abs x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x * \\<bar>x\\<bar> = x", "by (rule mult_sgn_abs)"], ["proof (state)\nthis:\n  sgn x * \\<bar>x\\<bar> = x\n\ngoal (2 subgoals):\n 1. odd p \\<Longrightarrow> z \\<in> {y. y ^ p = x}\n 2. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "finally"], ["proof (chain)\npicking this:\n  z ^ p = x", "show \"z \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  z ^ p = x\n\ngoal (1 subgoal):\n 1. z \\<in> {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  z \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "assume even: \"even p \\<and> x \\<ge> 0\""], ["proof (state)\nthis:\n  even p \\<and> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "from z even"], ["proof (chain)\npicking this:\n  z \\<in> set (if even p then [y, - y] else [sgn x * y])\n  even p \\<and> 0 \\<le> x", "have \"z = y \\<or> z = -y\""], ["proof (prove)\nusing this:\n  z \\<in> set (if even p then [y, - y] else [sgn x * y])\n  even p \\<and> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. z = y \\<or> z = - y", "by auto"], ["proof (state)\nthis:\n  z = y \\<or> z = - y\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "hence id: \"abs z = y\""], ["proof (prove)\nusing this:\n  z = y \\<or> z = - y\n\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> = y", "using y"], ["proof (prove)\nusing this:\n  z = y \\<or> z = - y\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> = y", "by auto"], ["proof (state)\nthis:\n  \\<bar>z\\<bar> = y\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "with yx x even"], ["proof (chain)\npicking this:\n  y ^ p = \\<bar>x\\<bar>\n  (x = 0) = False\n  even p \\<and> 0 \\<le> x\n  \\<bar>z\\<bar> = y", "have z: \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y ^ p = \\<bar>x\\<bar>\n  (x = 0) = False\n  even p \\<and> 0 \\<le> x\n  \\<bar>z\\<bar> = y\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "using p0"], ["proof (prove)\nusing this:\n  y ^ p = \\<bar>x\\<bar>\n  (x = 0) = False\n  even p \\<and> 0 \\<le> x\n  \\<bar>z\\<bar> = y\n  0 < p\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by (cases \"y = 0\", auto)"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"z ^ p = (sgn z * abs z) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ^ p = (sgn z * \\<bar>z\\<bar>) ^ p", "by (simp add: mult_sgn_abs)"], ["proof (state)\nthis:\n  z ^ p = (sgn z * \\<bar>z\\<bar>) ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  z ^ p = (sgn z * \\<bar>z\\<bar>) ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"\\<dots> = (sgn z * y) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn z * \\<bar>z\\<bar>) ^ p = (sgn z * y) ^ p", "using id"], ["proof (prove)\nusing this:\n  \\<bar>z\\<bar> = y\n\ngoal (1 subgoal):\n 1. (sgn z * \\<bar>z\\<bar>) ^ p = (sgn z * y) ^ p", "by auto"], ["proof (state)\nthis:\n  (sgn z * \\<bar>z\\<bar>) ^ p = (sgn z * y) ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  (sgn z * \\<bar>z\\<bar>) ^ p = (sgn z * y) ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"\\<dots> = (sgn z)^p * y ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn z * y) ^ p = sgn z ^ p * y ^ p", "unfolding power_mult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn z ^ p * y ^ p = sgn z ^ p * y ^ p", "by simp"], ["proof (state)\nthis:\n  (sgn z * y) ^ p = sgn z ^ p * y ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  (sgn z * y) ^ p = sgn z ^ p * y ^ p\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"\\<dots> = sgn z ^ p * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn z ^ p * y ^ p = sgn z ^ p * x", "unfolding yx"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn z ^ p * \\<bar>x\\<bar> = sgn z ^ p * x", "using even"], ["proof (prove)\nusing this:\n  even p \\<and> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. sgn z ^ p * \\<bar>x\\<bar> = sgn z ^ p * x", "by auto"], ["proof (state)\nthis:\n  sgn z ^ p * y ^ p = sgn z ^ p * x\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  sgn z ^ p * y ^ p = sgn z ^ p * x\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "have \"sgn z ^ p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn z ^ p = 1", "using even z"], ["proof (prove)\nusing this:\n  even p \\<and> 0 \\<le> x\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn z ^ p = 1", "by (auto)"], ["proof (state)\nthis:\n  sgn z ^ p = 1\n\ngoal (1 subgoal):\n 1. even p \\<and> 0 \\<le> x \\<Longrightarrow> z \\<in> {y. y ^ p = x}", "finally"], ["proof (chain)\npicking this:\n  z ^ p = 1 * x", "show \"z \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  z ^ p = 1 * x\n\ngoal (1 subgoal):\n 1. z \\<in> {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  z \\<in> {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?z2\n  \\<in> set (if b then if even p then [y, - y] else [sgn x * y]\n             else []) \\<Longrightarrow>\n  ?z2 \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "ultimately"], ["proof (chain)\npicking this:\n  ?z2 ^ p = x \\<Longrightarrow>\n  ?z2 \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n  ?z2\n  \\<in> set (if b then if even p then [y, - y] else [sgn x * y]\n             else []) \\<Longrightarrow>\n  ?z2 \\<in> {y. y ^ p = x}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?z2 ^ p = x \\<Longrightarrow>\n  ?z2 \\<in> set (if b then if even p then [y, - y] else [sgn x * y] else [])\n  ?z2\n  \\<in> set (if b then if even p then [y, - y] else [sgn x * y]\n             else []) \\<Longrightarrow>\n  ?z2 \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n    {y. y ^ p = x}", "by blast"], ["proof (state)\nthis:\n  set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n  {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (if b then if even p then [y, - y] else [sgn x * y] else []) =\n  {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. \\<not> (x < 0 \\<and> even p) \\<Longrightarrow>\n    set (root_int p x) = {y. y ^ p = x}", "finally"], ["proof (chain)\npicking this:\n  (set (root_int p x) = {y. y ^ p = x}) = ({y. y ^ p = x} = {y. y ^ p = x})", "show ?thesis"], ["proof (prove)\nusing this:\n  (set (root_int p x) = {y. y ^ p = x}) = ({y. y ^ p = x} = {y. y ^ p = x})\n\ngoal (1 subgoal):\n 1. set (root_int p x) = {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (root_int p x) = {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_int_pos: assumes x: \"x \\<ge> 0\" and ri: \"root_int p x = y # ys\"\n  shows \"y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> y", "from x"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have abs: \"abs x = x\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> = x", "by auto"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> = x\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "note ri = ri[unfolded root_int_def Let_def abs]"], ["proof (state)\nthis:\n  (if p = 0 then []\n   else if x = 0 then [0]\n        else if x < 0 \\<and> even p then []\n             else case root_int_main p x of\n                  (y, True) \\<Rightarrow>\n                    if even p then [y, - y] else [sgn x * y]\n                  | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "from ri"], ["proof (chain)\npicking this:\n  (if p = 0 then []\n   else if x = 0 then [0]\n        else if x < 0 \\<and> even p then []\n             else case root_int_main p x of\n                  (y, True) \\<Rightarrow>\n                    if even p then [y, - y] else [sgn x * y]\n                  | (y, False) \\<Rightarrow> []) =\n  y # ys", "have p: \"(p = 0) = False\""], ["proof (prove)\nusing this:\n  (if p = 0 then []\n   else if x = 0 then [0]\n        else if x < 0 \\<and> even p then []\n             else case root_int_main p x of\n                  (y, True) \\<Rightarrow>\n                    if even p then [y, - y] else [sgn x * y]\n                  | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. (p = 0) = False", "by (cases p, auto)"], ["proof (state)\nthis:\n  (p = 0) = False\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "note ri = ri[unfolded p if_False]"], ["proof (state)\nthis:\n  (if x = 0 then [0]\n   else if x < 0 \\<and> even p then []\n        else case root_int_main p x of\n             (y, True) \\<Rightarrow>\n               if even p then [y, - y] else [sgn x * y]\n             | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> y", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> 0 \\<le> y\n 2. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> 0 \\<le> y\n 2. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "with ri"], ["proof (chain)\npicking this:\n  (if x = 0 then [0]\n   else if x < 0 \\<and> even p then []\n        else case root_int_main p x of\n             (y, True) \\<Rightarrow>\n               if even p then [y, - y] else [sgn x * y]\n             | (y, False) \\<Rightarrow> []) =\n  y # ys\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (if x = 0 then [0]\n   else if x < 0 \\<and> even p then []\n        else case root_int_main p x of\n             (y, True) \\<Rightarrow>\n               if even p then [y, - y] else [sgn x * y]\n             | (y, False) \\<Rightarrow> []) =\n  y # ys\n  x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "hence \"(x = 0) = False\" \"(x < 0 \\<and> even p) = False\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (x = 0) = False &&& (x < 0 \\<and> even p) = False", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (x = 0) = False &&& (x < 0 \\<and> even p) = False", "by auto"], ["proof (state)\nthis:\n  (x = 0) = False\n  (x < 0 \\<and> even p) = False\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "note ri = ri[unfolded this if_False]"], ["proof (state)\nthis:\n  (case root_int_main p x of\n   (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n   | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "obtain y' b' where r: \"root_int_main p x = (y',b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y' b'.\n        root_int_main p x = (y', b') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  root_int_main p x = (y', b')\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "note ri = ri[unfolded this]"], ["proof (state)\nthis:\n  (case (y', b') of\n   (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n   | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "hence y: \"y = (if even p then y' else sgn x * y')\""], ["proof (prove)\nusing this:\n  (case (y', b') of\n   (y, True) \\<Rightarrow> if even p then [y, - y] else [sgn x * y]\n   | (y, False) \\<Rightarrow> []) =\n  y # ys\n\ngoal (1 subgoal):\n 1. y = (if even p then y' else sgn x * y')", "by (cases b', auto)"], ["proof (state)\nthis:\n  y = (if even p then y' else sgn x * y')\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "from root_int_main(1)[OF x r]"], ["proof (chain)\npicking this:\n  0 \\<le> y'", "have y': \"0 \\<le> y'\""], ["proof (prove)\nusing this:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. 0 \\<le> y'", "."], ["proof (state)\nthis:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> 0 \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "unfolding y"], ["proof (prove)\nusing this:\n  0 \\<le> y'\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if even p then y' else sgn x * y')", "using x False"], ["proof (prove)\nusing this:\n  0 \\<le> y'\n  0 \\<le> x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if even p then y' else sgn x * y')", "by auto"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Floor and ceiling of roots\\<close>"], ["", "text \\<open>Using the bounds for @{const root_int_main} we can easily design\n  algorithms which compute @{term \"floor (root p x)\"} and @{term \"ceiling (root p x)\"}.\n  To this end, we first develop algorithms for non-negative @{term x}, and later on\n  these are used for the general case.\\<close>"], ["", "definition \"root_int_floor_pos p x = (if p = 0 then 0 else fst (root_int_main p x))\""], ["", "definition \"root_int_ceiling_pos p x = (if p = 0 then 0 else (case root_int_main p x of (y,b) \\<Rightarrow> if b then y else y + 1))\""], ["", "lemma root_int_floor_pos_lower: assumes p0: \"p \\<noteq> 0\" and x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x ^ p \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor_pos p x ^ p \\<le> x", "using root_int_main(3)[OF x, of p] p0"], ["proof (prove)\nusing this:\n  \\<lbrakk>root_int_main p x = (?y, ?b); 0 < p\\<rbrakk>\n  \\<Longrightarrow> ?y ^ p \\<le> x\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_int_floor_pos p x ^ p \\<le> x", "unfolding root_int_floor_pos_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>root_int_main p x = (?y, ?b); 0 < p\\<rbrakk>\n  \\<Longrightarrow> ?y ^ p \\<le> x\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0 else fst (root_int_main p x)) ^ p \\<le> x", "by (cases \"root_int_main p x\", auto)"], ["", "lemma root_int_floor_pos_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> root_int_floor_pos p x", "using root_int_main(1)[OF x, of p]"], ["proof (prove)\nusing this:\n  root_int_main p x = (?y, ?b) \\<Longrightarrow> 0 \\<le> ?y\n\ngoal (1 subgoal):\n 1. 0 \\<le> root_int_floor_pos p x", "unfolding root_int_floor_pos_def"], ["proof (prove)\nusing this:\n  root_int_main p x = (?y, ?b) \\<Longrightarrow> 0 \\<le> ?y\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if p = 0 then 0 else fst (root_int_main p x))", "by (cases \"root_int_main p x\", auto)"], ["", "lemma root_int_floor_pos_upper: assumes p0: \"p \\<noteq> 0\" and x: \"x \\<ge> 0\"\n  shows \"(root_int_floor_pos p x + 1) ^ p > x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < (root_int_floor_pos p x + 1) ^ p", "using root_int_main(4)[OF x, of p] p0"], ["proof (prove)\nusing this:\n  \\<lbrakk>root_int_main p x = (?y, ?b); 0 < p\\<rbrakk>\n  \\<Longrightarrow> x < (?y + 1) ^ p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x < (root_int_floor_pos p x + 1) ^ p", "unfolding root_int_floor_pos_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>root_int_main p x = (?y, ?b); 0 < p\\<rbrakk>\n  \\<Longrightarrow> x < (?y + 1) ^ p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x < ((if p = 0 then 0 else fst (root_int_main p x)) + 1) ^ p", "by (cases \"root_int_main p x\", auto)"], ["", "lemma root_int_floor_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_floor_pos p x = floor (root p (of_int x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "by (simp add: root_int_floor_pos_def)"], ["proof (state)\nthis:\n  root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "hence p: \"p > 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "let ?s1 = \"real_of_int (root_int_floor_pos p x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "let ?s2 = \"root p (of_int x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "from x"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have s1: \"?s1 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (root_int_floor_pos p x)", "by (metis of_int_0_le_iff root_int_floor_pos_pos)"], ["proof (state)\nthis:\n  0 \\<le> real_of_int (root_int_floor_pos p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "from x"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have s2: \"?s2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> root p (real_of_int x)", "by (metis of_int_0_le_iff real_root_pos_pos_le)"], ["proof (state)\nthis:\n  0 \\<le> root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "from s1"], ["proof (chain)\npicking this:\n  0 \\<le> real_of_int (root_int_floor_pos p x)", "have s11: \"?s1 + 1 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> real_of_int (root_int_floor_pos p x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (root_int_floor_pos p x) + 1", "by auto"], ["proof (state)\nthis:\n  0 \\<le> real_of_int (root_int_floor_pos p x) + 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "have id: \"?s2 ^ p = of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "using x"], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "by (metis p of_int_0_le_iff real_root_pow_pos2)"], ["proof (state)\nthis:\n  root p (real_of_int x) ^ p = real_of_int x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "proof (rule floor_unique[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_int (root_int_floor_pos p x) \\<le> root p (real_of_int x)\n 2. root p (real_of_int x) < real_of_int (root_int_floor_pos p x) + 1", "show \"?s1 \\<le> ?s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (root_int_floor_pos p x) \\<le> root p (real_of_int x)", "unfolding compare_pow_le_iff[OF p s1 s2, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (root_int_floor_pos p x) ^ p\n    \\<le> root p (real_of_int x) ^ p", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (root_int_floor_pos p x) ^ p \\<le> real_of_int x", "using root_int_floor_pos_lower[OF False x]"], ["proof (prove)\nusing this:\n  root_int_floor_pos p x ^ p \\<le> x\n\ngoal (1 subgoal):\n 1. real_of_int (root_int_floor_pos p x) ^ p \\<le> real_of_int x", "by (metis of_int_le_iff of_int_power)"], ["proof (state)\nthis:\n  real_of_int (root_int_floor_pos p x) \\<le> root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) < real_of_int (root_int_floor_pos p x) + 1", "show \"?s2 < ?s1 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) < real_of_int (root_int_floor_pos p x) + 1", "unfolding compare_pow_less_iff[OF p s2 s11, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p\n    < (real_of_int (root_int_floor_pos p x) + 1) ^ p", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int x < (real_of_int (root_int_floor_pos p x) + 1) ^ p", "using root_int_floor_pos_upper[OF False x]"], ["proof (prove)\nusing this:\n  x < (root_int_floor_pos p x + 1) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int x < (real_of_int (root_int_floor_pos p x) + 1) ^ p", "by (metis of_int_add of_int_less_iff of_int_power of_int_1)"], ["proof (state)\nthis:\n  root p (real_of_int x) < real_of_int (root_int_floor_pos p x) + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_int_ceiling_pos: assumes x: \"x \\<ge> 0\"\n  shows \"root_int_ceiling_pos p x = ceiling (root p (of_int x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "by (simp add: root_int_ceiling_pos_def)"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "hence p: \"p > 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "obtain y b where s: \"root_int_main p x = (y,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y b.\n        root_int_main p x = (y, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  root_int_main p x = (y, b)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "note rm = root_int_main[OF x s]"], ["proof (state)\nthis:\n  0 \\<le> y\n  b = (y ^ p = x)\n  0 < p \\<Longrightarrow> y ^ p \\<le> x\n  0 < p \\<Longrightarrow> x < (y + 1) ^ p\n  \\<lbrakk>0 < p; 0 \\<le> ?x; ?x ^ p = x\\<rbrakk>\n  \\<Longrightarrow> y = ?x \\<and> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "note rm = rm(1-2) rm(3-5)[OF p]"], ["proof (state)\nthis:\n  0 \\<le> y\n  b = (y ^ p = x)\n  y ^ p \\<le> x\n  x < (y + 1) ^ p\n  \\<lbrakk>0 \\<le> ?x; ?x ^ p = x\\<rbrakk> \\<Longrightarrow> y = ?x \\<and> b\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "from rm(1)"], ["proof (chain)\npicking this:\n  0 \\<le> y", "have y: \"y \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. 0 \\<le> y", "by simp"], ["proof (state)\nthis:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "let ?s = \"root_int_ceiling_pos p x\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "let ?sx = \"root p (of_int x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "note d = root_int_ceiling_pos_def"], ["proof (state)\nthis:\n  root_int_ceiling_pos ?p ?x =\n  (if ?p = 0 then 0\n   else case root_int_main ?p ?x of\n        (y, b) \\<Rightarrow> if b then y else y + 1)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "proof (cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case True"], ["proof (state)\nthis:\n  b\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "hence id: \"?s = y\""], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = y", "unfolding s d"], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else case (y, b) of (y, b) \\<Rightarrow> if b then y else y + 1) =\n    y", "using p"], ["proof (prove)\nusing this:\n  b\n  0 < p\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else case (y, b) of (y, b) \\<Rightarrow> if b then y else y + 1) =\n    y", "by auto"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = y\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "from rm(2) True"], ["proof (chain)\npicking this:\n  b = (y ^ p = x)\n  b", "have xy: \"x = y ^ p\""], ["proof (prove)\nusing this:\n  b = (y ^ p = x)\n  b\n\ngoal (1 subgoal):\n 1. x = y ^ p", "by auto"], ["proof (state)\nthis:\n  x = y ^ p\n\ngoal (2 subgoals):\n 1. b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = \\<lceil>root p (real_of_int x)\\<rceil>", "unfolding xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = \\<lceil>root p (real_of_int (y ^ p))\\<rceil>", "using y"], ["proof (prove)\nusing this:\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. y = \\<lceil>root p (real_of_int (y ^ p))\\<rceil>", "by (simp add: p real_root_power_cancel)"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case False"], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "hence id: \"?s = root_int_floor_pos p x + 1\""], ["proof (prove)\nusing this:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = root_int_floor_pos p x + 1", "unfolding d root_int_floor_pos_def"], ["proof (prove)\nusing this:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else case root_int_main p x of\n          (y, b) \\<Rightarrow> if b then y else y + 1) =\n    (if p = 0 then 0 else fst (root_int_main p x)) + 1", "using s p"], ["proof (prove)\nusing this:\n  \\<not> b\n  root_int_main p x = (y, b)\n  0 < p\n\ngoal (1 subgoal):\n 1. (if p = 0 then 0\n     else case root_int_main p x of\n          (y, b) \\<Rightarrow> if b then y else y + 1) =\n    (if p = 0 then 0 else fst (root_int_main p x)) + 1", "by simp"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = root_int_floor_pos p x + 1\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "from False"], ["proof (chain)\npicking this:\n  \\<not> b", "have x0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using rm(5)[of 0]"], ["proof (prove)\nusing this:\n  \\<not> b\n  \\<lbrakk>0 \\<le> 0; 0 ^ p = x\\<rbrakk> \\<Longrightarrow> y = 0 \\<and> b\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using s"], ["proof (prove)\nusing this:\n  \\<not> b\n  \\<lbrakk>0 \\<le> 0; 0 ^ p = x\\<rbrakk> \\<Longrightarrow> y = 0 \\<and> b\n  root_int_main p x = (y, b)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "unfolding root_int_main_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> b\n  \\<lbrakk>0 \\<le> 0; 0 ^ p = x\\<rbrakk> \\<Longrightarrow> y = 0 \\<and> b\n  (if p = 0 then (1, x = 1)\n   else root_int_main' (p - 1) (int (p - 1)) (int p) (start_value x p) x) =\n  (y, b)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  \\<not> b\n  \\<lbrakk>0 \\<le> 0; 0 ^ p = x\\<rbrakk> \\<Longrightarrow> y = 0 \\<and> b\n  (if p = 0 then (1, x = 1)\n   else root_int_main' (p - 1) (int (p - 1)) (int p) (start_value x p) x) =\n  (y, b)\n  0 < p\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (cases \"x = 0\", auto)"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> b \\<Longrightarrow>\n    root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>", "unfolding id root_int_floor_pos[OF x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>root p (real_of_int x)\\<rfloor> + 1 =\n    \\<lceil>root p (real_of_int x)\\<rceil>", "proof (rule ceiling_unique[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)\n 2. root p (real_of_int x)\n    \\<le> real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1)", "show \"?sx \\<le> real_of_int (\\<lfloor>root p (of_int x)\\<rfloor> + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x)\n    \\<le> real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1)", "by (metis of_int_add real_of_int_floor_add_one_ge of_int_1)"], ["proof (state)\nthis:\n  root p (real_of_int x)\n  \\<le> real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "let ?l = \"real_of_int (\\<lfloor>root p (of_int x)\\<rfloor> + 1) - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "let ?m = \"real_of_int \\<lfloor>root p (of_int x)\\<rfloor>\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "have \"?l = ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1 =\n    real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1 =\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "also"], ["proof (state)\nthis:\n  real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1 =\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "have \"\\<dots> < ?sx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    < root p (real_of_int x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    < root p (real_of_int x)", "have le: \"?m \\<le> ?sx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    \\<le> root p (real_of_int x)", "by (rule of_int_floor_le)"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n  \\<le> root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    < root p (real_of_int x)", "have neq: \"?m \\<noteq> ?sx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> \\<noteq>\n    root p (real_of_int x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "assume \"?m = ?sx\""], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n  root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "hence \"?m ^ p = ?sx ^ p\""], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n  root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p =\n    root p (real_of_int x) ^ p", "by auto"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p =\n  root p (real_of_int x) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p =\n  root p (real_of_int x) ^ p\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "have \"\\<dots> = of_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "using x False"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  \\<not> b\n\ngoal (1 subgoal):\n 1. root p (real_of_int x) ^ p = real_of_int x", "by (metis p real_root_ge_0_iff real_root_pow_pos2 root_int_floor_pos root_int_floor_pos_pos zero_le_floor zero_less_Suc)"], ["proof (state)\nthis:\n  root p (real_of_int x) ^ p = real_of_int x\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p = real_of_int x", "have xs: \"x = \\<lfloor>root p (of_int x)\\<rfloor> ^ p\""], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p = real_of_int x\n\ngoal (1 subgoal):\n 1. x = \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p", "by (metis floor_power floor_of_int)"], ["proof (state)\nthis:\n  x = \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "hence \"\\<lfloor>root p (of_int x)\\<rfloor> \\<in> set (root_int p x)\""], ["proof (prove)\nusing this:\n  x = \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p\n\ngoal (1 subgoal):\n 1. \\<lfloor>root p (real_of_int x)\\<rfloor> \\<in> set (root_int p x)", "using p"], ["proof (prove)\nusing this:\n  x = \\<lfloor>root p (real_of_int x)\\<rfloor> ^ p\n  0 < p\n\ngoal (1 subgoal):\n 1. \\<lfloor>root p (real_of_int x)\\<rfloor> \\<in> set (root_int p x)", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>root p (real_of_int x)\\<rfloor> \\<in> set (root_int p x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "hence \"root_int p x \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lfloor>root p (real_of_int x)\\<rfloor> \\<in> set (root_int p x)\n\ngoal (1 subgoal):\n 1. root_int p x \\<noteq> []", "by force"], ["proof (state)\nthis:\n  root_int p x \\<noteq> []\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> =\n    root p (real_of_int x) \\<Longrightarrow>\n    False", "with s False \\<open>p \\<noteq> 0\\<close> x x0"], ["proof (chain)\npicking this:\n  root_int_main p x = (y, b)\n  \\<not> b\n  p \\<noteq> 0\n  0 \\<le> x\n  x \\<noteq> 0\n  root_int p x \\<noteq> []", "show False"], ["proof (prove)\nusing this:\n  root_int_main p x = (y, b)\n  \\<not> b\n  p \\<noteq> 0\n  0 \\<le> x\n  x \\<noteq> 0\n  root_int p x \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "unfolding root_int_def"], ["proof (prove)\nusing this:\n  root_int_main p x = (y, b)\n  \\<not> b\n  p \\<noteq> 0\n  0 \\<le> x\n  x \\<noteq> 0\n  (if p = 0 then []\n   else if x = 0 then [0]\n        else let e = even p; s = sgn x; x' = \\<bar>x\\<bar>\n             in if x < 0 \\<and> e then []\n                else case root_int_main p x' of\n                     (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n                     | (y, False) \\<Rightarrow> []) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. False", "by (cases p, auto)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> \\<noteq>\n  root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    < root p (real_of_int x)", "from le neq"], ["proof (chain)\npicking this:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n  \\<le> root p (real_of_int x)\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> \\<noteq>\n  root p (real_of_int x)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n  \\<le> root p (real_of_int x)\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor> \\<noteq>\n  root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n    < root p (real_of_int x)", "by arith"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n  < root p (real_of_int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int \\<lfloor>root p (real_of_int x)\\<rfloor>\n  < root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "finally"], ["proof (chain)\npicking this:\n  real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n  < root p (real_of_int x)", "show \"?l < ?sx\""], ["proof (prove)\nusing this:\n  real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n  < root p (real_of_int x)\n\ngoal (1 subgoal):\n 1. real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n    < root p (real_of_int x)", "."], ["proof (state)\nthis:\n  real_of_int (\\<lfloor>root p (real_of_int x)\\<rfloor> + 1) - 1\n  < root p (real_of_int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_int_ceiling_pos p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"root_int_floor p x = (if x \\<ge> 0 then root_int_floor_pos p x else - root_int_ceiling_pos p (- x))\""], ["", "definition \"root_int_ceiling p x = (if x \\<ge> 0 then root_int_ceiling_pos p x else - root_int_floor_pos p (- x))\""], ["", "lemma root_int_floor[simp]: \"root_int_floor p x = floor (root p (of_int x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "note d = root_int_floor_def"], ["proof (state)\nthis:\n  root_int_floor ?p ?x =\n  (if 0 \\<le> ?x then root_int_floor_pos ?p ?x\n   else - root_int_ceiling_pos ?p (- ?x))\n\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "case True"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "with root_int_floor_pos[OF True, of p]"], ["proof (chain)\npicking this:\n  root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n  0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "unfolding d"], ["proof (prove)\nusing this:\n  root_int_floor_pos p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_floor_pos p x\n     else - root_int_ceiling_pos p (- x)) =\n    \\<lfloor>root p (real_of_int x)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "hence \"- x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> - x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> - x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "from False root_int_ceiling_pos[OF this]"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> x\n  root_int_ceiling_pos ?p (- x) =\n  \\<lceil>root ?p (real_of_int (- x))\\<rceil>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n  root_int_ceiling_pos ?p (- x) =\n  \\<lceil>root ?p (real_of_int (- x))\\<rceil>\n\ngoal (1 subgoal):\n 1. root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n  root_int_ceiling_pos ?p (- x) =\n  \\<lceil>root ?p (real_of_int (- x))\\<rceil>\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_floor_pos p x\n     else - root_int_ceiling_pos p (- x)) =\n    \\<lfloor>root p (real_of_int x)\\<rfloor>", "by (simp add: real_root_minus ceiling_minus)"], ["proof (state)\nthis:\n  root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_int_floor p x = \\<lfloor>root p (real_of_int x)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_int_ceiling[simp]: \"root_int_ceiling p x = ceiling (root p (of_int x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "note d = root_int_ceiling_def"], ["proof (state)\nthis:\n  root_int_ceiling ?p ?x =\n  (if 0 \\<le> ?x then root_int_ceiling_pos ?p ?x\n   else - root_int_floor_pos ?p (- ?x))\n\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case True"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "with root_int_ceiling_pos[OF True]"], ["proof (chain)\npicking this:\n  root_int_ceiling_pos ?p x = \\<lceil>root ?p (real_of_int x)\\<rceil>\n  0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  root_int_ceiling_pos ?p x = \\<lceil>root ?p (real_of_int x)\\<rceil>\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "unfolding d"], ["proof (prove)\nusing this:\n  root_int_ceiling_pos ?p x = \\<lceil>root ?p (real_of_int x)\\<rceil>\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_ceiling_pos p x\n     else - root_int_floor_pos p (- x)) =\n    \\<lceil>root p (real_of_int x)\\<rceil>", "by simp"], ["proof (state)\nthis:\n  root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "hence \"- x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> - x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> - x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "from False root_int_floor_pos[OF this, of p]"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> x\n  root_int_floor_pos p (- x) = \\<lfloor>root p (real_of_int (- x))\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n  root_int_floor_pos p (- x) = \\<lfloor>root p (real_of_int (- x))\\<rfloor>\n\ngoal (1 subgoal):\n 1. root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n  root_int_floor_pos p (- x) = \\<lfloor>root p (real_of_int (- x))\\<rfloor>\n\ngoal (1 subgoal):\n 1. (if 0 \\<le> x then root_int_ceiling_pos p x\n     else - root_int_floor_pos p (- x)) =\n    \\<lceil>root p (real_of_int x)\\<rceil>", "by (simp add: real_root_minus floor_minus)"], ["proof (state)\nthis:\n  root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_int_ceiling p x = \\<lceil>root p (real_of_int x)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Downgrading algorithms to the naturals\\<close>"], ["", "definition root_nat_floor :: \"nat \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"root_nat_floor p x = root_int_floor_pos p (int x)\""], ["", "definition root_nat_ceiling :: \"nat \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"root_nat_ceiling p x = root_int_ceiling_pos p (int x)\""], ["", "definition root_nat :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n  \"root_nat p x = map nat (take 1 (root_int p x))\""], ["", "lemma root_nat_floor [simp]: \"root_nat_floor p x = floor (root p (real x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_nat_floor p x = \\<lfloor>root p (real x)\\<rfloor>", "unfolding root_nat_floor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_floor_pos p (int x) = \\<lfloor>root p (real x)\\<rfloor>", "using root_int_floor_pos[of \"int x\" p]"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  root_int_floor_pos p (int x) =\n  \\<lfloor>root p (real_of_int (int x))\\<rfloor>\n\ngoal (1 subgoal):\n 1. root_int_floor_pos p (int x) = \\<lfloor>root p (real x)\\<rfloor>", "by auto"], ["", "lemma root_nat_floor_lower: assumes p0: \"p \\<noteq> 0\"\n  shows \"root_nat_floor p x ^ p \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_nat_floor p x ^ p \\<le> int x", "using root_int_floor_pos_lower[OF p0, of x]"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  root_int_floor_pos p (int x) ^ p \\<le> int x\n\ngoal (1 subgoal):\n 1. root_nat_floor p x ^ p \\<le> int x", "unfolding root_nat_floor_def"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  root_int_floor_pos p (int x) ^ p \\<le> int x\n\ngoal (1 subgoal):\n 1. root_int_floor_pos p (int x) ^ p \\<le> int x", "by auto"], ["", "lemma root_nat_floor_upper: assumes p0: \"p \\<noteq> 0\"\n  shows \"(root_nat_floor p x + 1) ^ p > x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int x < (root_nat_floor p x + 1) ^ p", "using root_int_floor_pos_upper[OF p0, of x]"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  int x < (root_int_floor_pos p (int x) + 1) ^ p\n\ngoal (1 subgoal):\n 1. int x < (root_nat_floor p x + 1) ^ p", "unfolding root_nat_floor_def"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  int x < (root_int_floor_pos p (int x) + 1) ^ p\n\ngoal (1 subgoal):\n 1. int x < (root_int_floor_pos p (int x) + 1) ^ p", "by auto"], ["", "lemma root_nat_ceiling [simp]: \"root_nat_ceiling p x = ceiling (root p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_nat_ceiling p x = \\<lceil>root p (real x)\\<rceil>", "unfolding root_nat_ceiling_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p (int x) = \\<lceil>root p (real x)\\<rceil>", "using root_int_ceiling_pos[of x p]"], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow>\n  root_int_ceiling_pos p (int x) =\n  \\<lceil>root p (real_of_int (int x))\\<rceil>\n\ngoal (1 subgoal):\n 1. root_int_ceiling_pos p (int x) = \\<lceil>root p (real x)\\<rceil>", "by auto"], ["", "lemma root_nat: assumes p0: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_nat p x) = { y. y ^ p = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "assume \"y \\<in> set (root_nat p x)\""], ["proof (state)\nthis:\n  y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "note y = this[unfolded root_nat_def]"], ["proof (state)\nthis:\n  y \\<in> set (map nat (take 1 (root_int p (int x))))\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "then"], ["proof (chain)\npicking this:\n  y \\<in> set (map nat (take 1 (root_int p (int x))))", "obtain yi ys where ri: \"root_int p x = yi # ys\""], ["proof (prove)\nusing this:\n  y \\<in> set (map nat (take 1 (root_int p (int x))))\n\ngoal (1 subgoal):\n 1. (\\<And>yi ys.\n        root_int p (int x) = yi # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"root_int p x\", auto)"], ["proof (state)\nthis:\n  root_int p (int x) = yi # ys\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "with y"], ["proof (chain)\npicking this:\n  y \\<in> set (map nat (take 1 (root_int p (int x))))\n  root_int p (int x) = yi # ys", "have y: \"y = nat yi\""], ["proof (prove)\nusing this:\n  y \\<in> set (map nat (take 1 (root_int p (int x))))\n  root_int p (int x) = yi # ys\n\ngoal (1 subgoal):\n 1. y = nat yi", "by auto"], ["proof (state)\nthis:\n  y = nat yi\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from root_int_pos[OF _ ri]"], ["proof (chain)\npicking this:\n  0 \\<le> int x \\<Longrightarrow> 0 \\<le> yi", "have yi: \"0 \\<le> yi\""], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow> 0 \\<le> yi\n\ngoal (1 subgoal):\n 1. 0 \\<le> yi", "by auto"], ["proof (state)\nthis:\n  0 \\<le> yi\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from root_int[of p \"int x\"] p0 ri"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> int x \\<noteq> 1 \\<Longrightarrow>\n  set (root_int p (int x)) = {y. y ^ p = int x}\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  root_int p (int x) = yi # ys", "have \"yi ^ p = x\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> int x \\<noteq> 1 \\<Longrightarrow>\n  set (root_int p (int x)) = {y. y ^ p = int x}\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  root_int p (int x) = yi # ys\n\ngoal (1 subgoal):\n 1. yi ^ p = int x", "by auto"], ["proof (state)\nthis:\n  yi ^ p = int x\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from arg_cong[OF this, of nat] yi"], ["proof (chain)\npicking this:\n  nat (yi ^ p) = nat (int x)\n  0 \\<le> yi", "have \"nat yi ^ p = x\""], ["proof (prove)\nusing this:\n  nat (yi ^ p) = nat (int x)\n  0 \\<le> yi\n\ngoal (1 subgoal):\n 1. nat yi ^ p = x", "by (metis nat_int nat_power_eq)"], ["proof (state)\nthis:\n  nat yi ^ p = x\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "hence \"y \\<in> {y. y ^ p = x}\""], ["proof (prove)\nusing this:\n  nat yi ^ p = x\n\ngoal (1 subgoal):\n 1. y \\<in> {y. y ^ p = x}", "using y"], ["proof (prove)\nusing this:\n  nat yi ^ p = x\n  y = nat yi\n\ngoal (1 subgoal):\n 1. y \\<in> {y. y ^ p = x}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?y2 \\<in> set (root_nat p x) \\<Longrightarrow> ?y2 \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "moreover"], ["proof (state)\nthis:\n  ?y2 \\<in> set (root_nat p x) \\<Longrightarrow> ?y2 \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  ?y2 \\<in> set (root_nat p x) \\<Longrightarrow> ?y2 \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "assume yx: \"y ^ p = x\""], ["proof (state)\nthis:\n  y ^ p = x\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "hence y: \"int y ^ p = int x\""], ["proof (prove)\nusing this:\n  y ^ p = x\n\ngoal (1 subgoal):\n 1. int y ^ p = int x", "by (metis of_nat_power)"], ["proof (state)\nthis:\n  int y ^ p = int x\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "hence \"set (root_int p (int x)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  int y ^ p = int x\n\ngoal (1 subgoal):\n 1. set (root_int p (int x)) \\<noteq> {}", "using root_int[of p \"int x\"] p0"], ["proof (prove)\nusing this:\n  int y ^ p = int x\n  p \\<noteq> 0 \\<or> int x \\<noteq> 1 \\<Longrightarrow>\n  set (root_int p (int x)) = {y. y ^ p = int x}\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. set (root_int p (int x)) \\<noteq> {}", "by (metis (mono_tags) One_nat_def \\<open>y ^ p = x\\<close> empty_Collect_eq nat_power_eq_Suc_0_iff)"], ["proof (state)\nthis:\n  set (root_int p (int x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "then"], ["proof (chain)\npicking this:\n  set (root_int p (int x)) \\<noteq> {}", "obtain yi ys where ri: \"root_int p (int x) = yi # ys\""], ["proof (prove)\nusing this:\n  set (root_int p (int x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>yi ys.\n        root_int p (int x) = yi # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"root_int p (int x)\", auto)"], ["proof (state)\nthis:\n  root_int p (int x) = yi # ys\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from root_int_pos[OF _ this]"], ["proof (chain)\npicking this:\n  0 \\<le> int x \\<Longrightarrow> 0 \\<le> yi", "have yip: \"yi \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> int x \\<Longrightarrow> 0 \\<le> yi\n\ngoal (1 subgoal):\n 1. 0 \\<le> yi", "by auto"], ["proof (state)\nthis:\n  0 \\<le> yi\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from root_int[of p \"int x\", unfolded ri] p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> int x \\<noteq> 1 \\<Longrightarrow>\n  set (yi # ys) = {y. y ^ p = int x}\n  p \\<noteq> 0 \\<or> x \\<noteq> 1", "have yi: \"yi ^ p = int x\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> int x \\<noteq> 1 \\<Longrightarrow>\n  set (yi # ys) = {y. y ^ p = int x}\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. yi ^ p = int x", "by auto"], ["proof (state)\nthis:\n  yi ^ p = int x\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "with y"], ["proof (chain)\npicking this:\n  int y ^ p = int x\n  yi ^ p = int x", "have \"int y ^ p = yi ^ p\""], ["proof (prove)\nusing this:\n  int y ^ p = int x\n  yi ^ p = int x\n\ngoal (1 subgoal):\n 1. int y ^ p = yi ^ p", "by auto"], ["proof (state)\nthis:\n  int y ^ p = yi ^ p\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from arg_cong[OF this, of nat]"], ["proof (chain)\npicking this:\n  nat (int y ^ p) = nat (yi ^ p)", "have id: \"y ^ p = nat yi ^ p\""], ["proof (prove)\nusing this:\n  nat (int y ^ p) = nat (yi ^ p)\n\ngoal (1 subgoal):\n 1. y ^ p = nat yi ^ p", "by (metis \\<open>y ^ p = x\\<close> nat_int nat_power_eq yi yip)"], ["proof (state)\nthis:\n  y ^ p = nat yi ^ p\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  y ^ p = nat yi ^ p\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "assume p: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "hence p0: \"p > 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < p", "by auto"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "obtain yy b where rm: \"root_int_main p (int x) = (yy,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yy b.\n        root_int_main p (int x) = (yy, b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  root_int_main p (int x) = (yy, b)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "from root_int_main(5)[OF _ rm p0 _ y]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> int x; 0 \\<le> int y\\<rbrakk>\n  \\<Longrightarrow> yy = int y \\<and> b", "have \"yy = int y\" and \"b = True\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> int x; 0 \\<le> int y\\<rbrakk>\n  \\<Longrightarrow> yy = int y \\<and> b\n\ngoal (1 subgoal):\n 1. yy = int y &&& b = True", "by auto"], ["proof (state)\nthis:\n  yy = int y\n  b = True\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "note rm = rm[unfolded this]"], ["proof (state)\nthis:\n  root_int_main p (int x) = (int y, True)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "hence \"y \\<in> set (root_nat p x)\""], ["proof (prove)\nusing this:\n  root_int_main p (int x) = (int y, True)\n\ngoal (1 subgoal):\n 1. y \\<in> set (root_nat p x)", "unfolding root_nat_def p root_int_def"], ["proof (prove)\nusing this:\n  root_int_main p (int x) = (int y, True)\n\ngoal (1 subgoal):\n 1. y \\<in> set (map nat\n                  (take 1\n                    (if p = 0 then []\n                     else if int x = 0 then [0]\n                          else let e = even p; s = sgn (int x);\n                                   x' = \\<bar>int x\\<bar>\n                               in if int x < 0 \\<and> e then []\n                                  else case root_int_main p x' of\n (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n | (y, False) \\<Rightarrow> [])))", "using p0 p yx"], ["proof (prove)\nusing this:\n  root_int_main p (int x) = (int y, True)\n  0 < p\n  p \\<noteq> 0\n  y ^ p = x\n\ngoal (1 subgoal):\n 1. y \\<in> set (map nat\n                  (take 1\n                    (if p = 0 then []\n                     else if int x = 0 then [0]\n                          else let e = even p; s = sgn (int x);\n                                   x' = \\<bar>int x\\<bar>\n                               in if int x < 0 \\<and> e then []\n                                  else case root_int_main p x' of\n (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n | (y, False) \\<Rightarrow> [])))", "by auto"], ["proof (state)\nthis:\n  y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "assume p: \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "with p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0", "have \"x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "with y p"], ["proof (chain)\npicking this:\n  int y ^ p = int x\n  p = 0\n  x \\<noteq> 1", "have False"], ["proof (prove)\nusing this:\n  int y ^ p = int x\n  p = 0\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  p = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow> y \\<in> set (root_nat p x)\n  p = 0 \\<Longrightarrow> False", "have \"y \\<in> set (root_nat p x)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow> y \\<in> set (root_nat p x)\n  p = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. y \\<in> set (root_nat p x)", "by auto"], ["proof (state)\nthis:\n  y \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?y2 ^ p = x \\<Longrightarrow> ?y2 \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "ultimately"], ["proof (chain)\npicking this:\n  ?y2 \\<in> set (root_nat p x) \\<Longrightarrow> ?y2 \\<in> {y. y ^ p = x}\n  ?y2 ^ p = x \\<Longrightarrow> ?y2 \\<in> set (root_nat p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?y2 \\<in> set (root_nat p x) \\<Longrightarrow> ?y2 \\<in> {y. y ^ p = x}\n  ?y2 ^ p = x \\<Longrightarrow> ?y2 \\<in> set (root_nat p x)\n\ngoal (1 subgoal):\n 1. set (root_nat p x) = {y. y ^ p = x}", "by blast"], ["proof (state)\nthis:\n  set (root_nat p x) = {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Upgrading algorithms to the rationals\\<close>"], ["", "text \\<open>The main observation to lift everything from the integers to the rationals is the fact, that one\n  can reformulate $\\frac{a}{b}^{1/p}$ as $\\frac{(ab^{p-1})^{1/p}}b$.\\<close>"], ["", "definition root_rat_floor :: \"nat \\<Rightarrow> rat \\<Rightarrow> int\" where\n  \"root_rat_floor p x \\<equiv> case quotient_of x of (a,b) \\<Rightarrow> root_int_floor p (a * b^(p - 1)) div b\""], ["", "definition root_rat_ceiling :: \"nat \\<Rightarrow> rat \\<Rightarrow> int\" where\n  \"root_rat_ceiling p x \\<equiv> - (root_rat_floor p (-x))\""], ["", "definition root_rat :: \"nat \\<Rightarrow> rat \\<Rightarrow> rat list\" where\n  \"root_rat p x \\<equiv> case quotient_of x of (a,b) \\<Rightarrow> concat\n  (map (\\<lambda> rb. map (\\<lambda> ra. of_int ra / rat_of_int rb) (root_int p a)) (take 1 (root_int p b)))\""], ["", "lemma root_rat_reform: assumes q: \"quotient_of x = (a,b)\"\n  shows \"root p (real_of_rat x) = root p (of_int (a * b ^ (p - 1))) / of_int b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "from quotient_of_denom_pos[OF q]"], ["proof (chain)\npicking this:\n  0 < b", "have b: \"0 < b\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < b", "by auto"], ["proof (state)\nthis:\n  0 < b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "hence b: \"0 < real_of_int b\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < real_of_int b", "by auto"], ["proof (state)\nthis:\n  0 < real_of_int b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "from quotient_of_div[OF q]"], ["proof (chain)\npicking this:\n  x = rat_of_int a / rat_of_int b", "have x: \"root p (real_of_rat x) = root p (a / b)\""], ["proof (prove)\nusing this:\n  x = rat_of_int a / rat_of_int b\n\ngoal (1 subgoal):\n 1. root p (real_of_rat x) = root p (real_of_int a / real_of_int b)", "by (metis of_rat_divide of_rat_of_int_eq)"], ["proof (state)\nthis:\n  root p (real_of_rat x) = root p (real_of_int a / real_of_int b)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "also"], ["proof (state)\nthis:\n  root p (real_of_rat x) = root p (real_of_int a / real_of_int b)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "have \"a / b = a * real_of_int b ^ (p - 1) / of_int b ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int a / real_of_int b =\n    real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p", "using b False"], ["proof (prove)\nusing this:\n  0 < real_of_int b\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int a / real_of_int b =\n    real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p", "by (cases p, auto simp: field_simps)"], ["proof (state)\nthis:\n  real_of_int a / real_of_int b =\n  real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "also"], ["proof (state)\nthis:\n  real_of_int a / real_of_int b =\n  real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "have \"root p \\<dots> = root p (a * real_of_int b ^ (p - 1)) / root p (of_int b ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p) =\n    root p (real_of_int a * real_of_int b ^ (p - 1)) /\n    root p (real_of_int b ^ p)", "by (rule real_root_divide)"], ["proof (state)\nthis:\n  root p (real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p) =\n  root p (real_of_int a * real_of_int b ^ (p - 1)) /\n  root p (real_of_int b ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "also"], ["proof (state)\nthis:\n  root p (real_of_int a * real_of_int b ^ (p - 1) / real_of_int b ^ p) =\n  root p (real_of_int a * real_of_int b ^ (p - 1)) /\n  root p (real_of_int b ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "have \"root p (of_int b ^ p) = of_int b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root p (real_of_int b ^ p) = real_of_int b", "using False b"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < real_of_int b\n\ngoal (1 subgoal):\n 1. root p (real_of_int b ^ p) = real_of_int b", "by (metis neq0_conv real_root_pow_pos real_root_power)"], ["proof (state)\nthis:\n  root p (real_of_int b ^ p) = real_of_int b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "also"], ["proof (state)\nthis:\n  root p (real_of_int b ^ p) = real_of_int b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "have \"a * real_of_int b ^ (p - 1) = of_int (a * b ^ (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int a * real_of_int b ^ (p - 1) = real_of_int (a * b ^ (p - 1))", "by (metis of_int_mult of_int_power)"], ["proof (state)\nthis:\n  real_of_int a * real_of_int b ^ (p - 1) = real_of_int (a * b ^ (p - 1))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "finally"], ["proof (chain)\npicking this:\n  root p (real_of_rat x) =\n  root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "show ?thesis"], ["proof (prove)\nusing this:\n  root p (real_of_rat x) =\n  root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n\ngoal (1 subgoal):\n 1. root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "."], ["proof (state)\nthis:\n  root p (real_of_rat x) =\n  root p (real_of_int (a * b ^ (p - 1))) / real_of_int b\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    root p (real_of_rat x) =\n    root p (real_of_int (a * b ^ (p - 1))) / real_of_int b", "qed auto"], ["", "lemma root_rat_floor [simp]: \"root_rat_floor p x = floor (root p (of_rat x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>", "obtain a b where q: \"quotient_of x = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        quotient_of x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (a, b)\n\ngoal (1 subgoal):\n 1. root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>", "from quotient_of_denom_pos[OF q]"], ["proof (chain)\npicking this:\n  0 < b", "have b: \"b > 0\""], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 < b", "."], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>", "unfolding root_rat_floor_def q split root_int_floor"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>root p (real_of_int (a * b ^ (p - 1)))\\<rfloor> div b =\n    \\<lfloor>root p (real_of_rat x)\\<rfloor>", "unfolding root_rat_reform[OF q] floor_div_pos_int[OF b]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>root p (real_of_int (a * b ^ (p - 1)))\\<rfloor> div b =\n    \\<lfloor>root p (real_of_int (a * b ^ (p - 1)))\\<rfloor> div b", ".."], ["proof (state)\nthis:\n  root_rat_floor p x = \\<lfloor>root p (real_of_rat x)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_rat_ceiling [simp]: \"root_rat_ceiling p x = ceiling (root p (of_rat x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_rat_ceiling p x = \\<lceil>root p (real_of_rat x)\\<rceil>", "unfolding\n    root_rat_ceiling_def\n    ceiling_def\n    real_root_minus\n    root_rat_floor\n    of_rat_minus"], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<lfloor>- root p (real_of_rat x)\\<rfloor> =\n    - \\<lfloor>- root p (real_of_rat x)\\<rfloor>", ".."], ["", "lemma root_rat[simp]: assumes p: \"p \\<noteq> 0 \\<or> x \\<noteq> 1\"\n  shows \"set (root_rat p x) = { y. y ^ p = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_rat p x) = {y. y ^ p = x}", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note p = this"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "obtain a b where q: \"quotient_of x = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        quotient_of x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (a, b)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note x = quotient_of_div[OF q]"], ["proof (state)\nthis:\n  x = rat_of_int a / rat_of_int b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have b: \"b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b", "by (rule quotient_of_denom_pos[OF q])"], ["proof (state)\nthis:\n  0 < b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note d = root_rat_def q split set_concat set_map"], ["proof (state)\nthis:\n  root_rat ?p ?x \\<equiv>\n  case quotient_of ?x of\n  (a, b) \\<Rightarrow>\n    concat\n     (map (\\<lambda>rb.\n              map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n               (root_int ?p a))\n       (take 1 (root_int ?p b)))\n  quotient_of x = (a, b)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  set (concat ?xs) = \\<Union> (set ` set ?xs)\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  root_rat ?p ?x \\<equiv>\n  case quotient_of ?x of\n  (a, b) \\<Rightarrow>\n    concat\n     (map (\\<lambda>rb.\n              map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n               (root_int ?p a))\n       (take 1 (root_int ?p b)))\n  quotient_of x = (a, b)\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  set (concat ?xs) = \\<Union> (set ` set ?xs)\n  set (map ?f ?xs) = ?f ` set ?xs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "assume \"q \\<in> set (root_rat p x)\""], ["proof (state)\nthis:\n  q \\<in> set (root_rat p x)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note mem = this[unfolded d]"], ["proof (state)\nthis:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (root_int p b)))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from mem"], ["proof (chain)\npicking this:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (root_int p b)))", "obtain rb xs where rb: \"root_int p b = Cons rb xs\""], ["proof (prove)\nusing this:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (root_int p b)))\n\ngoal (1 subgoal):\n 1. (\\<And>rb xs.\n        root_int p b = rb # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"root_int p b\", auto)"], ["proof (state)\nthis:\n  root_int p b = rb # xs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note mem = mem[unfolded this]"], ["proof (state)\nthis:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (rb # xs)))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from mem"], ["proof (chain)\npicking this:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (rb # xs)))", "obtain ra where ra: \"ra \\<in> set (root_int p a)\" and q: \"q = of_int ra / of_int rb\""], ["proof (prove)\nusing this:\n  q \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (rb # xs)))\n\ngoal (1 subgoal):\n 1. (\\<And>ra.\n        \\<lbrakk>ra \\<in> set (root_int p a);\n         q = rat_of_int ra / rat_of_int rb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"root_int p a\", auto)"], ["proof (state)\nthis:\n  ra \\<in> set (root_int p a)\n  q = rat_of_int ra / rat_of_int rb\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from rb"], ["proof (chain)\npicking this:\n  root_int p b = rb # xs", "have \"rb \\<in> set (root_int p b)\""], ["proof (prove)\nusing this:\n  root_int p b = rb # xs\n\ngoal (1 subgoal):\n 1. rb \\<in> set (root_int p b)", "by auto"], ["proof (state)\nthis:\n  rb \\<in> set (root_int p b)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "with ra p"], ["proof (chain)\npicking this:\n  ra \\<in> set (root_int p a)\n  p \\<noteq> 0\n  rb \\<in> set (root_int p b)", "have rb: \"b = rb ^ p\" and ra: \"a = ra ^ p\""], ["proof (prove)\nusing this:\n  ra \\<in> set (root_int p a)\n  p \\<noteq> 0\n  rb \\<in> set (root_int p b)\n\ngoal (1 subgoal):\n 1. b = rb ^ p &&& a = ra ^ p", "by auto"], ["proof (state)\nthis:\n  b = rb ^ p\n  a = ra ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have \"q \\<in> {y. y ^ p = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> {y. y ^ p = x}", "unfolding q x ra rb"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int ra / rat_of_int rb\n    \\<in> {y. y ^ p = rat_of_int (ra ^ p) / rat_of_int (rb ^ p)}", "by (auto simp: power_divide)"], ["proof (state)\nthis:\n  q \\<in> {y. y ^ p = x}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> set (root_rat p x) \\<Longrightarrow> ?q2 \\<in> {y. y ^ p = x}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "moreover"], ["proof (state)\nthis:\n  ?q2 \\<in> set (root_rat p x) \\<Longrightarrow> ?q2 \\<in> {y. y ^ p = x}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "{"], ["proof (state)\nthis:\n  ?q2 \\<in> set (root_rat p x) \\<Longrightarrow> ?q2 \\<in> {y. y ^ p = x}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "assume \"q \\<in> {y. y ^ p = x}\""], ["proof (state)\nthis:\n  q \\<in> {y. y ^ p = x}\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "hence \"q ^ p = of_int a / of_int b\""], ["proof (prove)\nusing this:\n  q \\<in> {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. q ^ p = rat_of_int a / rat_of_int b", "unfolding x"], ["proof (prove)\nusing this:\n  q \\<in> {y. y ^ p = rat_of_int a / rat_of_int b}\n\ngoal (1 subgoal):\n 1. q ^ p = rat_of_int a / rat_of_int b", "by auto"], ["proof (state)\nthis:\n  q ^ p = rat_of_int a / rat_of_int b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "hence eq: \"of_int b * q ^ p = of_int a\""], ["proof (prove)\nusing this:\n  q ^ p = rat_of_int a / rat_of_int b\n\ngoal (1 subgoal):\n 1. rat_of_int b * q ^ p = rat_of_int a", "using b"], ["proof (prove)\nusing this:\n  q ^ p = rat_of_int a / rat_of_int b\n  0 < b\n\ngoal (1 subgoal):\n 1. rat_of_int b * q ^ p = rat_of_int a", "by auto"], ["proof (state)\nthis:\n  rat_of_int b * q ^ p = rat_of_int a\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "obtain z n where quo: \"quotient_of q = (z,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z n.\n        quotient_of q = (z, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of q = (z, n)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "note qzn = quotient_of_div[OF quo]"], ["proof (state)\nthis:\n  q = rat_of_int z / rat_of_int n\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have n: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using quotient_of_denom_pos[OF quo]"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "."], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from eq[unfolded qzn]"], ["proof (chain)\npicking this:\n  rat_of_int b * (rat_of_int z / rat_of_int n) ^ p = rat_of_int a", "have \"rat_of_int b * of_int z^p / of_int n^p = of_int a\""], ["proof (prove)\nusing this:\n  rat_of_int b * (rat_of_int z / rat_of_int n) ^ p = rat_of_int a\n\ngoal (1 subgoal):\n 1. rat_of_int b * rat_of_int z ^ p / rat_of_int n ^ p = rat_of_int a", "unfolding power_divide"], ["proof (prove)\nusing this:\n  rat_of_int b * (rat_of_int z ^ p / rat_of_int n ^ p) = rat_of_int a\n\ngoal (1 subgoal):\n 1. rat_of_int b * rat_of_int z ^ p / rat_of_int n ^ p = rat_of_int a", "by simp"], ["proof (state)\nthis:\n  rat_of_int b * rat_of_int z ^ p / rat_of_int n ^ p = rat_of_int a\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from arg_cong[OF this, of \"\\<lambda> x. x * of_int n^p\"] n"], ["proof (chain)\npicking this:\n  rat_of_int b * rat_of_int z ^ p / rat_of_int n ^ p * rat_of_int n ^ p =\n  rat_of_int a * rat_of_int n ^ p\n  0 < n", "have \"rat_of_int b * of_int z^p = of_int a * of_int n ^ p\""], ["proof (prove)\nusing this:\n  rat_of_int b * rat_of_int z ^ p / rat_of_int n ^ p * rat_of_int n ^ p =\n  rat_of_int a * rat_of_int n ^ p\n  0 < n\n\ngoal (1 subgoal):\n 1. rat_of_int b * rat_of_int z ^ p = rat_of_int a * rat_of_int n ^ p", "by auto"], ["proof (state)\nthis:\n  rat_of_int b * rat_of_int z ^ p = rat_of_int a * rat_of_int n ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  rat_of_int b * rat_of_int z ^ p = rat_of_int a * rat_of_int n ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have \"rat_of_int b * of_int z^p = rat_of_int (b * z^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int b * rat_of_int z ^ p = rat_of_int (b * z ^ p)", "unfolding of_int_mult of_int_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int b * rat_of_int z ^ p = rat_of_int b * rat_of_int z ^ p", ".."], ["proof (state)\nthis:\n  rat_of_int b * rat_of_int z ^ p = rat_of_int (b * z ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "also"], ["proof (state)\nthis:\n  rat_of_int b * rat_of_int z ^ p = rat_of_int (b * z ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have \"of_int a * rat_of_int n ^ p = of_int (a * n ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int a * rat_of_int n ^ p = rat_of_int (a * n ^ p)", "unfolding of_int_mult of_int_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int a * rat_of_int n ^ p = rat_of_int a * rat_of_int n ^ p", ".."], ["proof (state)\nthis:\n  rat_of_int a * rat_of_int n ^ p = rat_of_int (a * n ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "finally"], ["proof (chain)\npicking this:\n  rat_of_int (b * z ^ p) = rat_of_int (a * n ^ p)", "have id: \"a * n ^ p = b * z ^ p\""], ["proof (prove)\nusing this:\n  rat_of_int (b * z ^ p) = rat_of_int (a * n ^ p)\n\ngoal (1 subgoal):\n 1. a * n ^ p = b * z ^ p", "by linarith"], ["proof (state)\nthis:\n  a * n ^ p = b * z ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from quotient_of_coprime[OF quo]"], ["proof (chain)\npicking this:\n  coprime z n", "have cop: \"coprime (z ^ p) (n ^ p)\""], ["proof (prove)\nusing this:\n  coprime z n\n\ngoal (1 subgoal):\n 1. coprime (z ^ p) (n ^ p)", "by simp"], ["proof (state)\nthis:\n  coprime (z ^ p) (n ^ p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from coprime_crossproduct_int[OF quotient_of_coprime[OF q] this] arg_cong[OF id, of abs]"], ["proof (chain)\npicking this:\n  (\\<bar>a\\<bar> * \\<bar>n ^ p\\<bar> = \\<bar>z ^ p\\<bar> * \\<bar>b\\<bar>) =\n  (\\<bar>a\\<bar> = \\<bar>z ^ p\\<bar> \\<and>\n   \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>)\n  \\<bar>a * n ^ p\\<bar> = \\<bar>b * z ^ p\\<bar>", "have \"\\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>\""], ["proof (prove)\nusing this:\n  (\\<bar>a\\<bar> * \\<bar>n ^ p\\<bar> = \\<bar>z ^ p\\<bar> * \\<bar>b\\<bar>) =\n  (\\<bar>a\\<bar> = \\<bar>z ^ p\\<bar> \\<and>\n   \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>)\n  \\<bar>a * n ^ p\\<bar> = \\<bar>b * z ^ p\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>", "by (simp add: field_simps abs_mult)"], ["proof (state)\nthis:\n  \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "with n b"], ["proof (chain)\npicking this:\n  0 < n\n  0 < b\n  \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>", "have bnp: \"b = n ^ p\""], ["proof (prove)\nusing this:\n  0 < n\n  0 < b\n  \\<bar>n ^ p\\<bar> = \\<bar>b\\<bar>\n\ngoal (1 subgoal):\n 1. b = n ^ p", "by auto"], ["proof (state)\nthis:\n  b = n ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "hence rn: \"n \\<in> set (root_int p b)\""], ["proof (prove)\nusing this:\n  b = n ^ p\n\ngoal (1 subgoal):\n 1. n \\<in> set (root_int p b)", "using p"], ["proof (prove)\nusing this:\n  b = n ^ p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<in> set (root_int p b)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (root_int p b)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "then"], ["proof (chain)\npicking this:\n  n \\<in> set (root_int p b)", "obtain rb rs where rb: \"root_int p b = Cons rb rs\""], ["proof (prove)\nusing this:\n  n \\<in> set (root_int p b)\n\ngoal (1 subgoal):\n 1. (\\<And>rb rs.\n        root_int p b = rb # rs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"root_int p b\", auto)"], ["proof (state)\nthis:\n  root_int p b = rb # rs\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from id[folded bnp] b"], ["proof (chain)\npicking this:\n  a * b = b * z ^ p\n  0 < b", "have \"a = z ^ p\""], ["proof (prove)\nusing this:\n  a * b = b * z ^ p\n  0 < b\n\ngoal (1 subgoal):\n 1. a = z ^ p", "by auto"], ["proof (state)\nthis:\n  a = z ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "hence a: \"z \\<in> set (root_int p a)\""], ["proof (prove)\nusing this:\n  a = z ^ p\n\ngoal (1 subgoal):\n 1. z \\<in> set (root_int p a)", "using p"], ["proof (prove)\nusing this:\n  a = z ^ p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<in> set (root_int p a)", "by auto"], ["proof (state)\nthis:\n  z \\<in> set (root_int p a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from root_int_pos[OF _ rb] b"], ["proof (chain)\npicking this:\n  0 \\<le> b \\<Longrightarrow> 0 \\<le> rb\n  0 < b", "have rb0: \"rb \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> b \\<Longrightarrow> 0 \\<le> rb\n  0 < b\n\ngoal (1 subgoal):\n 1. 0 \\<le> rb", "by auto"], ["proof (state)\nthis:\n  0 \\<le> rb\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "from root_int[OF disjI1[OF p], of b] rb"], ["proof (chain)\npicking this:\n  set (root_int p b) = {y. y ^ p = b}\n  root_int p b = rb # rs", "have \"rb ^ p = b\""], ["proof (prove)\nusing this:\n  set (root_int p b) = {y. y ^ p = b}\n  root_int p b = rb # rs\n\ngoal (1 subgoal):\n 1. rb ^ p = b", "by auto"], ["proof (state)\nthis:\n  rb ^ p = b\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "with bnp"], ["proof (chain)\npicking this:\n  b = n ^ p\n  rb ^ p = b", "have id: \"rb ^ p = n ^ p\""], ["proof (prove)\nusing this:\n  b = n ^ p\n  rb ^ p = b\n\ngoal (1 subgoal):\n 1. rb ^ p = n ^ p", "by auto"], ["proof (state)\nthis:\n  rb ^ p = n ^ p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have \"rb = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rb = n", "by (rule power_eq_imp_eq_base[OF id], insert n rb0 p, auto)"], ["proof (state)\nthis:\n  rb = n\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "with rb"], ["proof (chain)\npicking this:\n  root_int p b = rb # rs\n  rb = n", "have b: \"n \\<in> set (take 1 (root_int p b))\""], ["proof (prove)\nusing this:\n  root_int p b = rb # rs\n  rb = n\n\ngoal (1 subgoal):\n 1. n \\<in> set (take 1 (root_int p b))", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (take 1 (root_int p b))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "have \"q \\<in> set (root_rat p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (root_rat p x)", "unfolding d qzn"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int z / rat_of_int n\n    \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (root_int p b)))", "using b a"], ["proof (prove)\nusing this:\n  n \\<in> set (take 1 (root_int p b))\n  z \\<in> set (root_int p a)\n\ngoal (1 subgoal):\n 1. rat_of_int z / rat_of_int n\n    \\<in> \\<Union>\n           (set `\n            (\\<lambda>rb.\n                map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                 (root_int p a)) `\n            set (take 1 (root_int p b)))", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (root_rat p x)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> {y. y ^ p = x} \\<Longrightarrow> ?q2 \\<in> set (root_rat p x)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}\n 2. p \\<noteq> 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "ultimately"], ["proof (chain)\npicking this:\n  ?q2 \\<in> set (root_rat p x) \\<Longrightarrow> ?q2 \\<in> {y. y ^ p = x}\n  ?q2 \\<in> {y. y ^ p = x} \\<Longrightarrow> ?q2 \\<in> set (root_rat p x)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?q2 \\<in> set (root_rat p x) \\<Longrightarrow> ?q2 \\<in> {y. y ^ p = x}\n  ?q2 \\<in> {y. y ^ p = x} \\<Longrightarrow> ?q2 \\<in> set (root_rat p x)\n\ngoal (1 subgoal):\n 1. set (root_rat p x) = {y. y ^ p = x}", "by blast"], ["proof (state)\nthis:\n  set (root_rat p x) = {y. y ^ p = x}\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "with p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0", "have x: \"x \\<noteq> 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<or> x \\<noteq> 1\n  p = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "obtain a b where q: \"quotient_of x = (a,b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        quotient_of x = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (a, b)\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> set (root_rat p x) = {y. y ^ p = x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (root_rat p x) = {y. y ^ p = x}", "unfolding True root_rat_def q split root_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>rb.\n                   map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                    (if 0 = 0 then []\n                     else if a = 0 then [0]\n                          else let e = even 0; s = sgn a; x' = \\<bar>a\\<bar>\n                               in if a < 0 \\<and> e then []\n                                  else case root_int_main 0 x' of\n (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n | (y, False) \\<Rightarrow> []))\n            (take 1\n              (if 0 = 0 then []\n               else if b = 0 then [0]\n                    else let e = even 0; s = sgn b; x' = \\<bar>b\\<bar>\n                         in if b < 0 \\<and> e then []\n                            else case root_int_main 0 x' of\n                                 (y, True) \\<Rightarrow>\n                                   if e then [y, - y] else [s * y]\n                                 | (y, False) \\<Rightarrow> [])))) =\n    {y. y ^ 0 = x}", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>rb.\n                   map (\\<lambda>ra. rat_of_int ra / rat_of_int rb)\n                    (if 0 = 0 then []\n                     else if a = 0 then [0]\n                          else let e = even 0; s = sgn a; x' = \\<bar>a\\<bar>\n                               in if a < 0 \\<and> e then []\n                                  else case root_int_main 0 x' of\n (y, True) \\<Rightarrow> if e then [y, - y] else [s * y]\n | (y, False) \\<Rightarrow> []))\n            (take 1\n              (if 0 = 0 then []\n               else if b = 0 then [0]\n                    else let e = even 0; s = sgn b; x' = \\<bar>b\\<bar>\n                         in if b < 0 \\<and> e then []\n                            else case root_int_main 0 x' of\n                                 (y, True) \\<Rightarrow>\n                                   if e then [y, - y] else [s * y]\n                                 | (y, False) \\<Rightarrow> [])))) =\n    {y. y ^ 0 = x}", "by auto"], ["proof (state)\nthis:\n  set (root_rat p x) = {y. y ^ p = x}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}