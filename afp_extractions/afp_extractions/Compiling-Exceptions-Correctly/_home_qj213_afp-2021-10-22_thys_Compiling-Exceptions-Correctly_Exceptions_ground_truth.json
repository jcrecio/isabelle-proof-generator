{"file_name": "/home/qj213/afp-2021-10-22/thys/Compiling-Exceptions-Correctly/Exceptions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Compiling-Exceptions-Correctly", "problem_names": ["lemma size_jump1: \"size (jump l cs) < Suc (size cs)\"", "lemma size_jump2: \"size (jump l cs) < size cs \\<or> jump l cs = cs\"", "lemma 3:\n  \"(\\<And>l. c = Label l \\<Longrightarrow> isFresh l s) \\<Longrightarrow> unwind (c#cs) s = unwind cs s\"", "lemma 5: \"\\<lbrakk> isFresh l s; l \\<le> m \\<rbrakk> \\<Longrightarrow> isFresh m s\"", "lemma 6: \"\\<And>l. l \\<le> snd(compile l e)\"", "lemma 4 [simp]: \"\\<And>l cs. isFresh l s \\<Longrightarrow> unwind (cmp l e @ cs) s = unwind cs s\"", "lemma 7 [simp]: \"l < m \\<Longrightarrow> jump l (cmp m e @ cs) = jump l cs\"", "theorem comp_corr:\n  \"\\<And>l s cs. isFresh l s \\<Longrightarrow> exec (cmp l e @ cs) s = conv cs s (eval e)\""], "translations": [["", "lemma size_jump1: \"size (jump l cs) < Suc (size cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (jump l cs) < Suc (length cs)", "apply(induct cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (jump l []) < Suc (length [])\n 2. \\<And>a cs.\n       length (jump l cs) < Suc (length cs) \\<Longrightarrow>\n       length (jump l (a # cs)) < Suc (length (a # cs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       length (jump l cs) < Suc (length cs) \\<Longrightarrow>\n       length (jump l (a # cs)) < Suc (length (a # cs))", "apply(case_tac a)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a cs x1.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = Push x1\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 2. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = ADD\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 3. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = THROW\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 4. \\<And>a cs x4.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = Mark x4\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 5. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = Unmark\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 6. \\<And>a cs x6.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = Label x6\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))\n 7. \\<And>a cs x7.\n       \\<lbrakk>length (jump l cs) < Suc (length cs); a = Jump x7\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < Suc (length (a # cs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_jump2: \"size (jump l cs) < size cs \\<or> jump l cs = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (jump l cs) < length cs \\<or> jump l cs = cs", "apply(induct cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (jump l []) < length [] \\<or> jump l [] = []\n 2. \\<And>a cs.\n       length (jump l cs) < length cs \\<or> jump l cs = cs \\<Longrightarrow>\n       length (jump l (a # cs)) < length (a # cs) \\<or>\n       jump l (a # cs) = a # cs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       length (jump l cs) < length cs \\<or> jump l cs = cs \\<Longrightarrow>\n       length (jump l (a # cs)) < length (a # cs) \\<or>\n       jump l (a # cs) = a # cs", "apply(case_tac a)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a cs x1.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = Push x1\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 2. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = ADD\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 3. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = THROW\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 4. \\<And>a cs x4.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = Mark x4\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 5. \\<And>a cs.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = Unmark\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 6. \\<And>a cs x6.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = Label x6\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs\n 7. \\<And>a cs x7.\n       \\<lbrakk>length (jump l cs) < length cs \\<or> jump l cs = cs;\n        a = Jump x7\\<rbrakk>\n       \\<Longrightarrow> length (jump l (a # cs)) < length (a # cs) \\<or>\n                         jump l (a # cs) = a # cs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "function (sequential) exec2 :: \"bool \\<Rightarrow> code \\<Rightarrow> stack \\<Rightarrow> stack\" where\n  \"exec2 True [] s = s\"\n| \"exec2 True (Push i#cs) s = exec2 True cs (VAL i # s)\"\n| \"exec2 True (ADD#cs) (VAL j # VAL i # s) = exec2 True cs (VAL(i+j) # s)\"\n| \"exec2 True (THROW#cs) s = exec2 False cs s\"\n| \"exec2 True (Mark l#cs) s = exec2 True cs (HAN l # s)\"\n| \"exec2 True (Unmark#cs) (v # HAN l # s) = exec2 True cs (v # s)\"\n| \"exec2 True (Label l#cs) s = exec2 True cs s\"\n| \"exec2 True (Jump l#cs) s = exec2 True (jump l cs) s\"\n\n| \"exec2 False cs [] = []\"\n| \"exec2 False cs (VAL i # s) = exec2 False cs s\"\n| \"exec2 False cs (HAN l # s) = exec2 True (jump l cs) s\""], ["proof (prove)\ngoal (254 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>s. x = (True, [], s) \\<Longrightarrow> P;\n        \\<And>i cs s. x = (True, Push i # cs, s) \\<Longrightarrow> P;\n        \\<And>cs j i s.\n           x = (True, ADD # cs, VAL j # VAL i # s) \\<Longrightarrow> P;\n        \\<And>cs s. x = (True, THROW # cs, s) \\<Longrightarrow> P;\n        \\<And>l cs s. x = (True, Mark l # cs, s) \\<Longrightarrow> P;\n        \\<And>cs v l s.\n           x = (True, Unmark # cs, v # HAN l # s) \\<Longrightarrow> P;\n        \\<And>l cs s. x = (True, Label l # cs, s) \\<Longrightarrow> P;\n        \\<And>l cs s. x = (True, Jump l # cs, s) \\<Longrightarrow> P;\n        \\<And>cs. x = (False, cs, []) \\<Longrightarrow> P;\n        \\<And>cs i s. x = (False, cs, VAL i # s) \\<Longrightarrow> P;\n        \\<And>cs l s. x = (False, cs, HAN l # s) \\<Longrightarrow> P;\n        \\<And>va. x = (True, ADD # va, []) \\<Longrightarrow> P;\n        \\<And>va vc vb.\n           x = (True, ADD # va, HAN vc # vb) \\<Longrightarrow> P;\n        \\<And>va v. x = (True, ADD # va, [v]) \\<Longrightarrow> P;\n        \\<And>va vb. x = (True, ADD # va, [HAN vb]) \\<Longrightarrow> P;\n        \\<And>va v ve vd.\n           x = (True, ADD # va, v # HAN ve # vd) \\<Longrightarrow> P;\n        \\<And>va vb ve vd.\n           x = (True, ADD # va, HAN vb # HAN ve # vd) \\<Longrightarrow> P;\n        \\<And>va. x = (True, Unmark # va, []) \\<Longrightarrow> P;\n        \\<And>va v. x = (True, Unmark # va, [v]) \\<Longrightarrow> P;\n        \\<And>va vb. x = (True, Unmark # va, [HAN vb]) \\<Longrightarrow> P;\n        \\<And>va v ve vd.\n           x = (True, Unmark # va, v # VAL ve # vd) \\<Longrightarrow> P;\n        \\<And>va vb ve vd.\n           x = (True, Unmark # va, HAN vb # VAL ve # vd) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>s sa. (True, [], s) = (True, [], sa) \\<Longrightarrow> s = sa\n 3. \\<And>s i cs sa.\n       (True, [], s) = (True, Push i # cs, sa) \\<Longrightarrow>\n       s = exec2_sumC (True, cs, VAL i # sa)\n 4. \\<And>s cs j i sa.\n       (True, [], s) =\n       (True, ADD # cs, VAL j # VAL i # sa) \\<Longrightarrow>\n       s = exec2_sumC (True, cs, VAL (i + j) # sa)\n 5. \\<And>s cs sa.\n       (True, [], s) = (True, THROW # cs, sa) \\<Longrightarrow>\n       s = exec2_sumC (False, cs, sa)\n 6. \\<And>s l cs sa.\n       (True, [], s) = (True, Mark l # cs, sa) \\<Longrightarrow>\n       s = exec2_sumC (True, cs, HAN l # sa)\n 7. \\<And>s cs v l sa.\n       (True, [], s) = (True, Unmark # cs, v # HAN l # sa) \\<Longrightarrow>\n       s = exec2_sumC (True, cs, v # sa)\n 8. \\<And>s l cs sa.\n       (True, [], s) = (True, Label l # cs, sa) \\<Longrightarrow>\n       s = exec2_sumC (True, cs, sa)\n 9. \\<And>s l cs sa.\n       (True, [], s) = (True, Jump l # cs, sa) \\<Longrightarrow>\n       s = exec2_sumC (True, jump l cs, sa)\n 10. \\<And>s cs. (True, [], s) = (False, cs, []) \\<Longrightarrow> s = []\nA total of 254 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All exec2_dom", "by (relation\n  \"inv_image (measure(%cs. size cs) <*lex*> measure(%s. size s)) (%(b,cs,s). (cs,s))\")\n    (auto simp add: size_jump1 size_jump2)"], ["", "abbreviation \"exec \\<equiv> exec2 True\""], ["", "abbreviation \"unwind \\<equiv> exec2 False\""], ["", "subsection\\<open>The compiler\\<close>"], ["", "primrec compile :: \"nat \\<Rightarrow> expr \\<Rightarrow> code * nat\"\nwhere\n  \"compile l (Val i) = ([Push i], l)\"\n| \"compile l (Add x y) = (let (xs,m) = compile l x; (ys,n) = compile m y\n                       in (xs @ ys @ [ADD], n))\"\n| \"compile l Throw = ([THROW],l)\"\n| \"compile l (Catch x h) =\n    (let (xs,m) = compile (l+2) x; (hs,n) = compile m h\n     in (Mark l # xs @ [Unmark, Jump (l+1), Label l] @ hs @ [Label(l+1)], n))\""], ["", "abbreviation\n  cmp :: \"nat \\<Rightarrow> expr \\<Rightarrow> code\" where\n  \"cmp l e == fst(compile l e)\""], ["", "primrec isFresh :: \"nat \\<Rightarrow> stack \\<Rightarrow> bool\"\nwhere\n  \"isFresh l [] = True\"\n| \"isFresh l (it#s) = (case it of VAL i \\<Rightarrow> isFresh l s\n                       | HAN l' \\<Rightarrow> l' < l \\<and> isFresh l s)\""], ["", "definition\n  conv :: \"code \\<Rightarrow> stack \\<Rightarrow> int option \\<Rightarrow> stack\" where\n  \"conv cs s io = (case io of None \\<Rightarrow> unwind cs s\n                  | Some i \\<Rightarrow> exec cs (VAL i # s))\""], ["", "subsection\\<open>The proofs\\<close>"], ["", "text\\<open>Lemma numbers are the same as in the paper.\\<close>"], ["", "declare\n  conv_def[simp] option.splits[split] Let_def[simp]"], ["", "lemma 3:\n  \"(\\<And>l. c = Label l \\<Longrightarrow> isFresh l s) \\<Longrightarrow> unwind (c#cs) s = unwind cs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. c = Label l \\<Longrightarrow> isFresh l s) \\<Longrightarrow>\n    unwind (c # cs) s = unwind cs s", "apply(induct s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>l. c = Label l \\<Longrightarrow> isFresh l []) \\<Longrightarrow>\n    unwind (c # cs) [] = unwind cs []\n 2. \\<And>a s.\n       \\<lbrakk>(\\<And>l.\n                    c = Label l \\<Longrightarrow>\n                    isFresh l s) \\<Longrightarrow>\n                unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> isFresh l (a # s)\\<rbrakk>\n       \\<Longrightarrow> unwind (c # cs) (a # s) = unwind cs (a # s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>(\\<And>l.\n                    c = Label l \\<Longrightarrow>\n                    isFresh l s) \\<Longrightarrow>\n                unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> isFresh l (a # s)\\<rbrakk>\n       \\<Longrightarrow> unwind (c # cs) (a # s) = unwind cs (a # s)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>(\\<And>l.\n                    c = Label l \\<Longrightarrow>\n                    isFresh l s) \\<Longrightarrow>\n                unwind (c # cs) s = unwind cs s;\n        \\<And>l.\n           c = Label l \\<Longrightarrow>\n           case a of VAL i \\<Rightarrow> isFresh l s\n           | HAN l' \\<Rightarrow> l' < l \\<and> isFresh l s\\<rbrakk>\n       \\<Longrightarrow> unwind (c # cs) (a # s) = unwind cs (a # s)", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a s x1.\n       \\<lbrakk>(\\<And>l.\n                    c = Label l \\<Longrightarrow>\n                    isFresh l s) \\<Longrightarrow>\n                unwind (c # cs) s = unwind cs s;\n        \\<And>l.\n           c = Label l \\<Longrightarrow>\n           case a of VAL i \\<Rightarrow> isFresh l s\n           | HAN l' \\<Rightarrow> l' < l \\<and> isFresh l s;\n        a = VAL x1\\<rbrakk>\n       \\<Longrightarrow> unwind (c # cs) (a # s) = unwind cs (a # s)\n 2. \\<And>a s x2.\n       \\<lbrakk>(\\<And>l.\n                    c = Label l \\<Longrightarrow>\n                    isFresh l s) \\<Longrightarrow>\n                unwind (c # cs) s = unwind cs s;\n        \\<And>l.\n           c = Label l \\<Longrightarrow>\n           case a of VAL i \\<Rightarrow> isFresh l s\n           | HAN l' \\<Rightarrow> l' < l \\<and> isFresh l s;\n        a = HAN x2\\<rbrakk>\n       \\<Longrightarrow> unwind (c # cs) (a # s) = unwind cs (a # s)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x2.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l.\n           c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s", "apply(case_tac c)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s x2 x1.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = Push x1\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 2. \\<And>s x2.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = ADD\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 3. \\<And>s x2.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = THROW\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 4. \\<And>s x2 x4.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = Mark x4\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 5. \\<And>s x2.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = Unmark\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 6. \\<And>s x2 x6.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = Label x6\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s\n 7. \\<And>s x2 x7.\n       \\<lbrakk>unwind (c # cs) s = unwind cs s;\n        \\<And>l. c = Label l \\<Longrightarrow> x2 < l \\<and> isFresh l s;\n        c = Jump x7\\<rbrakk>\n       \\<Longrightarrow> exec (jump x2 (c # cs)) s = exec (jump x2 cs) s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary [simp]:\n  \"(!!l. c \\<noteq> Label l) \\<Longrightarrow> unwind (c#cs) s = unwind cs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. c \\<noteq> Label l) \\<Longrightarrow>\n    unwind (c # cs) s = unwind cs s", "by(blast intro: 3)"], ["", "corollary [simp]:\n  \"isFresh l s \\<Longrightarrow> unwind (Label l#cs) s = unwind cs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFresh l s \\<Longrightarrow> unwind (Label l # cs) s = unwind cs s", "by(blast intro: 3)"], ["", "lemma 5: \"\\<lbrakk> isFresh l s; l \\<le> m \\<rbrakk> \\<Longrightarrow> isFresh m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isFresh l s; l \\<le> m\\<rbrakk> \\<Longrightarrow> isFresh m s", "apply(induct s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>isFresh l []; l \\<le> m\\<rbrakk> \\<Longrightarrow> isFresh m []\n 2. \\<And>a s.\n       \\<lbrakk>\\<lbrakk>isFresh l s; l \\<le> m\\<rbrakk>\n                \\<Longrightarrow> isFresh m s;\n        isFresh l (a # s); l \\<le> m\\<rbrakk>\n       \\<Longrightarrow> isFresh m (a # s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>\\<lbrakk>isFresh l s; l \\<le> m\\<rbrakk>\n                \\<Longrightarrow> isFresh m s;\n        isFresh l (a # s); l \\<le> m\\<rbrakk>\n       \\<Longrightarrow> isFresh m (a # s)", "apply(auto split:item.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary [simp]: \"isFresh l s \\<Longrightarrow> isFresh (Suc l) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFresh l s \\<Longrightarrow> isFresh (Suc l) s", "by(auto intro:5)"], ["", "lemma 6: \"\\<And>l. l \\<le> snd(compile l e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l. l \\<le> snd (compile l e)", "proof(induct e)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x l. l \\<le> snd (compile l (Val x))\n 2. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Add e1 e2))\n 3. \\<And>l. l \\<le> snd (compile l Throw)\n 4. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "case Val"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x l. l \\<le> snd (compile l (Val x))\n 2. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Add e1 e2))\n 3. \\<And>l. l \\<le> snd (compile l Throw)\n 4. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> snd (compile l (Val x_))", "by simp"], ["proof (state)\nthis:\n  l \\<le> snd (compile l (Val x_))\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Add e1 e2))\n 2. \\<And>l. l \\<le> snd (compile l Throw)\n 3. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Add e1 e2))\n 2. \\<And>l. l \\<le> snd (compile l Throw)\n 3. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "case (Add x y)"], ["proof (state)\nthis:\n  ?l \\<le> snd (compile ?l x)\n  ?l \\<le> snd (compile ?l y)\n\ngoal (3 subgoals):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Add e1 e2))\n 2. \\<And>l. l \\<le> snd (compile l Throw)\n 3. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "from \\<open>l \\<le> snd (compile l x)\\<close>\n   and \\<open>snd (compile l x) \\<le> snd (compile (snd (compile l x)) y)\\<close>"], ["proof (chain)\npicking this:\n  l \\<le> snd (compile l x)\n  snd (compile l x) \\<le> snd (compile (snd (compile l x)) y)", "show ?case"], ["proof (prove)\nusing this:\n  l \\<le> snd (compile l x)\n  snd (compile l x) \\<le> snd (compile (snd (compile l x)) y)\n\ngoal (1 subgoal):\n 1. l \\<le> snd (compile l (Add x y))", "by(simp_all add:split_def)"], ["proof (state)\nthis:\n  l \\<le> snd (compile l (Add x y))\n\ngoal (2 subgoals):\n 1. \\<And>l. l \\<le> snd (compile l Throw)\n 2. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. l \\<le> snd (compile l Throw)\n 2. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "case Throw"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>l. l \\<le> snd (compile l Throw)\n 2. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> snd (compile l Throw)", "by simp"], ["proof (state)\nthis:\n  l \\<le> snd (compile l Throw)\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "case (Catch x h)"], ["proof (state)\nthis:\n  ?l \\<le> snd (compile ?l x)\n  ?l \\<le> snd (compile ?l h)\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 l.\n       \\<lbrakk>\\<And>l. l \\<le> snd (compile l e1);\n        \\<And>l. l \\<le> snd (compile l e2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> snd (compile l (Catch e1 e2))", "from \\<open>l+2 \\<le> snd (compile (l+2) x)\\<close>\n   and \\<open>snd (compile (l+2) x) \\<le> snd (compile (snd (compile (l+2) x)) h)\\<close>"], ["proof (chain)\npicking this:\n  l + 2 \\<le> snd (compile (l + 2) x)\n  snd (compile (l + 2) x) \\<le> snd (compile (snd (compile (l + 2) x)) h)", "show ?case"], ["proof (prove)\nusing this:\n  l + 2 \\<le> snd (compile (l + 2) x)\n  snd (compile (l + 2) x) \\<le> snd (compile (snd (compile (l + 2) x)) h)\n\ngoal (1 subgoal):\n 1. l \\<le> snd (compile l (Catch x h))", "by(simp_all add:split_def)"], ["proof (state)\nthis:\n  l \\<le> snd (compile l (Catch x h))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary [simp]: \"l < m \\<Longrightarrow> l < snd(compile m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < m \\<Longrightarrow> l < snd (compile m e)", "using 6[where l = m and e = e]"], ["proof (prove)\nusing this:\n  m \\<le> snd (compile m e)\n\ngoal (1 subgoal):\n 1. l < m \\<Longrightarrow> l < snd (compile m e)", "by auto"], ["", "corollary [simp]: \"isFresh l s \\<Longrightarrow> isFresh (snd(compile l e)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isFresh l s \\<Longrightarrow> isFresh (snd (compile l e)) s", "using 5 6"], ["proof (prove)\nusing this:\n  \\<lbrakk>isFresh ?l ?s; ?l \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> isFresh ?m ?s\n  ?l \\<le> snd (compile ?l ?e)\n\ngoal (1 subgoal):\n 1. isFresh l s \\<Longrightarrow> isFresh (snd (compile l e)) s", "by blast"], ["", "text\\<open>Contrary to what the paper says, the proof of lemma 4 does not\njust need lemma 3 but also the above corollary of 5 and 6. Hence the\nstrange order of the lemmas in our proof.\\<close>"], ["", "lemma 4 [simp]: \"\\<And>l cs. isFresh l s \\<Longrightarrow> unwind (cmp l e @ cs) s = unwind cs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l cs.\n       isFresh l s \\<Longrightarrow> unwind (cmp l e @ cs) s = unwind cs s", "by (induct e) (auto simp add:split_def)"], ["", "lemma 7 [simp]: \"l < m \\<Longrightarrow> jump l (cmp m e @ cs) = jump l cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < m \\<Longrightarrow> jump l (cmp m e @ cs) = jump l cs", "by (induct e arbitrary: m cs) (simp_all add:split_def)"], ["", "text\\<open>The compiler correctness theorem:\\<close>"], ["", "theorem comp_corr:\n  \"\\<And>l s cs. isFresh l s \\<Longrightarrow> exec (cmp l e @ cs) s = conv cs s (eval e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l s cs.\n       isFresh l s \\<Longrightarrow>\n       exec (cmp l e @ cs) s = conv cs s (eval e)", "by(induct e)(auto simp add:split_def)"], ["", "text\\<open>The specialized and more readable version (omitted in the paper):\\<close>"], ["", "corollary \"exec (cmp l e) [] = (case eval e of None \\<Rightarrow> [] | Some n \\<Rightarrow> [VAL n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec (cmp l e) [] =\n    (case eval e of None \\<Rightarrow> [] | Some n \\<Rightarrow> [VAL n])", "by (simp add: comp_corr[where cs = \"[]\", simplified])"], ["", "end"]]}